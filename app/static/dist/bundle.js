/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@egjs/preact-flicking/dist/flicking.esm.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@egjs/preact-flicking/dist/flicking.esm.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ALIGN: () => (/* binding */ ALIGN),
/* harmony export */   AnchorPoint: () => (/* binding */ AnchorPoint),
/* harmony export */   AnimatingState: () => (/* binding */ AnimatingState),
/* harmony export */   AxesController: () => (/* binding */ AxesController),
/* harmony export */   BoundCameraMode: () => (/* binding */ BoundCameraMode),
/* harmony export */   CIRCULAR_FALLBACK: () => (/* binding */ CIRCULAR_FALLBACK),
/* harmony export */   CLASS: () => (/* binding */ CLASS),
/* harmony export */   Camera: () => (/* binding */ Camera),
/* harmony export */   CircularCameraMode: () => (/* binding */ CircularCameraMode),
/* harmony export */   Control: () => (/* binding */ Control),
/* harmony export */   DIRECTION: () => (/* binding */ DIRECTION),
/* harmony export */   DisabledState: () => (/* binding */ DisabledState),
/* harmony export */   DraggingState: () => (/* binding */ DraggingState),
/* harmony export */   ERROR_CODE: () => (/* binding */ CODE),
/* harmony export */   EVENTS: () => (/* binding */ EVENTS),
/* harmony export */   ExternalRenderer: () => (/* binding */ ExternalRenderer),
/* harmony export */   FlickingError: () => (/* binding */ FlickingError),
/* harmony export */   FreeControl: () => (/* binding */ FreeControl),
/* harmony export */   HoldingState: () => (/* binding */ HoldingState),
/* harmony export */   IdleState: () => (/* binding */ IdleState),
/* harmony export */   LinearCameraMode: () => (/* binding */ LinearCameraMode),
/* harmony export */   MOVE_TYPE: () => (/* binding */ MOVE_TYPE),
/* harmony export */   NormalRenderingStrategy: () => (/* binding */ NormalRenderingStrategy),
/* harmony export */   ORDER: () => (/* binding */ ORDER),
/* harmony export */   Panel: () => (/* binding */ Panel),
/* harmony export */   Renderer: () => (/* binding */ Renderer),
/* harmony export */   SnapControl: () => (/* binding */ SnapControl),
/* harmony export */   State: () => (/* binding */ State),
/* harmony export */   StateMachine: () => (/* binding */ StateMachine),
/* harmony export */   StrictControl: () => (/* binding */ StrictControl),
/* harmony export */   VanillaElementProvider: () => (/* binding */ VanillaElementProvider),
/* harmony export */   VanillaRenderer: () => (/* binding */ VanillaRenderer),
/* harmony export */   Viewport: () => (/* binding */ Viewport),
/* harmony export */   ViewportSlot: () => (/* binding */ ViewportSlot),
/* harmony export */   VirtualElementProvider: () => (/* binding */ VirtualElementProvider),
/* harmony export */   VirtualManager: () => (/* binding */ VirtualManager),
/* harmony export */   VirtualPanel: () => (/* binding */ VirtualPanel),
/* harmony export */   VirtualRenderingStrategy: () => (/* binding */ VirtualRenderingStrategy),
/* harmony export */   checkExistence: () => (/* binding */ checkExistence),
/* harmony export */   circulateIndex: () => (/* binding */ circulateIndex),
/* harmony export */   circulatePosition: () => (/* binding */ circulatePosition),
/* harmony export */   clamp: () => (/* binding */ clamp$1),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   find: () => (/* binding */ find$1),
/* harmony export */   findIndex: () => (/* binding */ findIndex),
/* harmony export */   findRight: () => (/* binding */ findRight),
/* harmony export */   getDefaultCameraTransform: () => (/* binding */ getDefaultCameraTransform),
/* harmony export */   getDirection: () => (/* binding */ getDirection$1),
/* harmony export */   getElement: () => (/* binding */ getElement),
/* harmony export */   getElementSize: () => (/* binding */ getElementSize),
/* harmony export */   getFlickingAttached: () => (/* binding */ getFlickingAttached),
/* harmony export */   getMinusCompensatedIndex: () => (/* binding */ getMinusCompensatedIndex),
/* harmony export */   getProgress: () => (/* binding */ getProgress),
/* harmony export */   getRenderingPanels: () => (/* binding */ getRenderingPanels),
/* harmony export */   getStyle: () => (/* binding */ getStyle),
/* harmony export */   includes: () => (/* binding */ includes),
/* harmony export */   isBetween: () => (/* binding */ isBetween),
/* harmony export */   isString: () => (/* binding */ isString),
/* harmony export */   merge: () => (/* binding */ merge),
/* harmony export */   parseAlign: () => (/* binding */ parseAlign$1),
/* harmony export */   parseArithmeticExpression: () => (/* binding */ parseArithmeticExpression),
/* harmony export */   parseArithmeticSize: () => (/* binding */ parseArithmeticSize),
/* harmony export */   parseBounce: () => (/* binding */ parseBounce),
/* harmony export */   parseCSSSizeValue: () => (/* binding */ parseCSSSizeValue),
/* harmony export */   parseElement: () => (/* binding */ parseElement),
/* harmony export */   parsePanelAlign: () => (/* binding */ parsePanelAlign),
/* harmony export */   range: () => (/* binding */ range),
/* harmony export */   setPrototypeOf: () => (/* binding */ setPrototypeOf),
/* harmony export */   setSize: () => (/* binding */ setSize),
/* harmony export */   sync: () => (/* binding */ sync),
/* harmony export */   toArray: () => (/* binding */ toArray$2),
/* harmony export */   withFlickingMethods: () => (/* binding */ withFlickingMethods)
/* harmony export */ });
/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.module.js");
/*
Copyright (c) 2021-present NAVER Corp.
name: @egjs/preact-flicking
license: MIT
author: NAVER Corp.
repository: https://github.com/naver/egjs-flicking/blob/master/packages/preact-flicking
version: 4.11.4
*/


var t,u,r,o=0,i=[],c=preact__WEBPACK_IMPORTED_MODULE_0__.options.__b,f=preact__WEBPACK_IMPORTED_MODULE_0__.options.__r,e=preact__WEBPACK_IMPORTED_MODULE_0__.options.diffed,a=preact__WEBPACK_IMPORTED_MODULE_0__.options.__c,v=preact__WEBPACK_IMPORTED_MODULE_0__.options.unmount;function m(t,r){preact__WEBPACK_IMPORTED_MODULE_0__.options.__h&&preact__WEBPACK_IMPORTED_MODULE_0__.options.__h(u,t,o||r),o=0;var i=u.__H||(u.__H={__:[],__h:[]});return t>=i.__.length&&i.__.push({}),i.__[t]}function l(n){return o=1,p(w,n)}function p(n,r,o){var i=m(t++,2);return i.t=n,i.__c||(i.__=[o?o(r):w(void 0,r),function(n){var t=i.t(i.__[0],n);i.__[0]!==t&&(i.__=[t,i.__[1]],i.__c.setState({}));}],i.__c=u),i.__}function y(r,o){var i=m(t++,3);!preact__WEBPACK_IMPORTED_MODULE_0__.options.__s&&k(i.__H,o)&&(i.__=r,i.__H=o,u.__H.__h.push(i));}function h(r,o){var i=m(t++,4);!preact__WEBPACK_IMPORTED_MODULE_0__.options.__s&&k(i.__H,o)&&(i.__=r,i.__H=o,u.__h.push(i));}function s(n){return o=5,d(function(){return {current:n}},[])}function _(n,t,u){o=6,h(function(){"function"==typeof n?n(t()):n&&(n.current=t());},null==u?u:u.concat(n));}function d(n,u){var r=m(t++,7);return k(r.__H,u)&&(r.__=n(),r.__H=u,r.__h=n),r.__}function A(n,t){return o=8,d(function(){return n},t)}function F(n){var r=u.context[n.__c],o=m(t++,9);return o.c=n,r?(null==o.__&&(o.__=!0,r.sub(u)),r.props.value):n.__}function T(t,u){preact__WEBPACK_IMPORTED_MODULE_0__.options.useDebugValue&&preact__WEBPACK_IMPORTED_MODULE_0__.options.useDebugValue(u?u(t):t);}function x(){var t;for(i.sort(function(n,t){return n.__v.__b-t.__v.__b});t=i.pop();)if(t.__P)try{t.__H.__h.forEach(g),t.__H.__h.forEach(j),t.__H.__h=[];}catch(u){t.__H.__h=[],preact__WEBPACK_IMPORTED_MODULE_0__.options.__e(u,t.__v);}}preact__WEBPACK_IMPORTED_MODULE_0__.options.__b=function(n){u=null,c&&c(n);},preact__WEBPACK_IMPORTED_MODULE_0__.options.__r=function(n){f&&f(n),t=0;var r=(u=n.__c).__H;r&&(r.__h.forEach(g),r.__h.forEach(j),r.__h=[]);},preact__WEBPACK_IMPORTED_MODULE_0__.options.diffed=function(t){e&&e(t);var o=t.__c;o&&o.__H&&o.__H.__h.length&&(1!==i.push(o)&&r===preact__WEBPACK_IMPORTED_MODULE_0__.options.requestAnimationFrame||((r=preact__WEBPACK_IMPORTED_MODULE_0__.options.requestAnimationFrame)||function(n){var t,u=function(){clearTimeout(r),b&&cancelAnimationFrame(t),setTimeout(n);},r=setTimeout(u,100);b&&(t=requestAnimationFrame(u));})(x)),u=null;},preact__WEBPACK_IMPORTED_MODULE_0__.options.__c=function(t,u){u.some(function(t){try{t.__h.forEach(g),t.__h=t.__h.filter(function(n){return !n.__||j(n)});}catch(r){u.some(function(n){n.__h&&(n.__h=[]);}),u=[],preact__WEBPACK_IMPORTED_MODULE_0__.options.__e(r,t.__v);}}),a&&a(t,u);},preact__WEBPACK_IMPORTED_MODULE_0__.options.unmount=function(t){v&&v(t);var u,r=t.__c;r&&r.__H&&(r.__H.__.forEach(function(n){try{g(n);}catch(n){u=n;}}),u&&preact__WEBPACK_IMPORTED_MODULE_0__.options.__e(u,r.__v));};var b="function"==typeof requestAnimationFrame;function g(n){var t=u,r=n.__c;"function"==typeof r&&(n.__c=void 0,r()),u=t;}function j(n){var t=u;n.__c=n.__(),u=t;}function k(n,t){return !n||n.length!==t.length||t.some(function(t,u){return t!==n[u]})}function w(n,t){return "function"==typeof t?t(n):t}

function S(n,t){for(var e in t)n[e]=t[e];return n}function C(n,t){for(var e in n)if("__source"!==e&&!(e in t))return !0;for(var r in t)if("__source"!==r&&n[r]!==t[r])return !0;return !1}function E(n){this.props=n;}function g$1(n,t){function e(n){var e=this.props.ref,r=e==n.ref;return !r&&e&&(e.call?e(null):e.current=null),t?!t(this.props,n)||!r:C(this.props,n)}function r(t){return this.shouldComponentUpdate=e,(0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(n,t)}return r.displayName="Memo("+(n.displayName||n.name)+")",r.prototype.isReactComponent=!0,r.__f=!0,r}(E.prototype=new preact__WEBPACK_IMPORTED_MODULE_0__.Component).isPureReactComponent=!0,E.prototype.shouldComponentUpdate=function(n,t){return C(this.props,n)||C(this.state,t)};var w$1=preact__WEBPACK_IMPORTED_MODULE_0__.options.__b;preact__WEBPACK_IMPORTED_MODULE_0__.options.__b=function(n){n.type&&n.type.__f&&n.ref&&(n.props.ref=n.ref,n.ref=null),w$1&&w$1(n);};var R="undefined"!=typeof Symbol&&Symbol.for&&Symbol.for("react.forward_ref")||3911;function x$1(n){function t(t,e){var r=S({},t);return delete r.ref,n(r,(e=t.ref||e)&&("object"!=typeof e||"current"in e)?e:null)}return t.$$typeof=R,t.render=t,t.prototype.isReactComponent=t.__f=!0,t.displayName="ForwardRef("+(n.displayName||n.name)+")",t}var N=function(n,t){return null==n?null:(0,preact__WEBPACK_IMPORTED_MODULE_0__.toChildArray)((0,preact__WEBPACK_IMPORTED_MODULE_0__.toChildArray)(n).map(t))},k$1={map:N,forEach:N,count:function(n){return n?(0,preact__WEBPACK_IMPORTED_MODULE_0__.toChildArray)(n).length:0},only:function(n){var t=(0,preact__WEBPACK_IMPORTED_MODULE_0__.toChildArray)(n);if(1!==t.length)throw "Children.only";return t[0]},toArray:preact__WEBPACK_IMPORTED_MODULE_0__.toChildArray},A$1=preact__WEBPACK_IMPORTED_MODULE_0__.options.__e;preact__WEBPACK_IMPORTED_MODULE_0__.options.__e=function(n,t,e){if(n.then)for(var r,u=t;u=u.__;)if((r=u.__c)&&r.__c)return null==t.__e&&(t.__e=e.__e,t.__k=e.__k),r.__c(n,t);A$1(n,t,e);};var O=preact__WEBPACK_IMPORTED_MODULE_0__.options.unmount;function L(){this.__u=0,this.t=null,this.__b=null;}function U(n){var t=n.__.__c;return t&&t.__e&&t.__e(n)}function F$1(n){var t,e,r;function u(u){if(t||(t=n()).then(function(n){e=n.default||n;},function(n){r=n;}),r)throw r;if(!e)throw t;return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(e,u)}return u.displayName="Lazy",u.__f=!0,u}function M(){this.u=null,this.o=null;}preact__WEBPACK_IMPORTED_MODULE_0__.options.unmount=function(n){var t=n.__c;t&&t.__R&&t.__R(),t&&!0===n.__h&&(n.type=null),O&&O(n);},(L.prototype=new preact__WEBPACK_IMPORTED_MODULE_0__.Component).__c=function(n,t){var e=t.__c,r=this;null==r.t&&(r.t=[]),r.t.push(e);var u=U(r.__v),o=!1,i=function(){o||(o=!0,e.__R=null,u?u(l):l());};e.__R=i;var l=function(){if(!--r.__u){if(r.state.__e){var n=r.state.__e;r.__v.__k[0]=function n(t,e,r){return t&&(t.__v=null,t.__k=t.__k&&t.__k.map(function(t){return n(t,e,r)}),t.__c&&t.__c.__P===e&&(t.__e&&r.insertBefore(t.__e,t.__d),t.__c.__e=!0,t.__c.__P=r)),t}(n,n.__c.__P,n.__c.__O);}var t;for(r.setState({__e:r.__b=null});t=r.t.pop();)t.forceUpdate();}},c=!0===t.__h;r.__u++||c||r.setState({__e:r.__b=r.__v.__k[0]}),n.then(i,i);},L.prototype.componentWillUnmount=function(){this.t=[];},L.prototype.render=function(n,t){if(this.__b){if(this.__v.__k){var e=document.createElement("div"),r=this.__v.__k[0].__c;this.__v.__k[0]=function n(t,e,r){return t&&(t.__c&&t.__c.__H&&(t.__c.__H.__.forEach(function(n){"function"==typeof n.__c&&n.__c();}),t.__c.__H=null),null!=(t=S({},t)).__c&&(t.__c.__P===r&&(t.__c.__P=e),t.__c=null),t.__k=t.__k&&t.__k.map(function(t){return n(t,e,r)})),t}(this.__b,e,r.__O=r.__P);}this.__b=null;}var u=t.__e&&(0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(preact__WEBPACK_IMPORTED_MODULE_0__.Fragment,null,n.fallback);return u&&(u.__h=null),[(0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(preact__WEBPACK_IMPORTED_MODULE_0__.Fragment,null,t.__e?null:n.children),u]};var T$1=function(n,t,e){if(++e[1]===e[0]&&n.o.delete(t),n.props.revealOrder&&("t"!==n.props.revealOrder[0]||!n.o.size))for(e=n.u;e;){for(;e.length>3;)e.pop()();if(e[1]<e[0])break;n.u=e=e[2];}};function D(n){return this.getChildContext=function(){return n.context},n.children}function I(n){var t=this,e=n.i;t.componentWillUnmount=function(){(0,preact__WEBPACK_IMPORTED_MODULE_0__.render)(null,t.l),t.l=null,t.i=null;},t.i&&t.i!==e&&t.componentWillUnmount(),n.__v?(t.l||(t.i=e,t.l={nodeType:1,parentNode:e,childNodes:[],appendChild:function(n){this.childNodes.push(n),t.i.appendChild(n);},insertBefore:function(n,e){this.childNodes.push(n),t.i.appendChild(n);},removeChild:function(n){this.childNodes.splice(this.childNodes.indexOf(n)>>>1,1),t.i.removeChild(n);}}),(0,preact__WEBPACK_IMPORTED_MODULE_0__.render)((0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(D,{context:t.context},n.__v),t.l)):t.l&&t.componentWillUnmount();}function W(n,t){return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(I,{__v:n,i:t})}(M.prototype=new preact__WEBPACK_IMPORTED_MODULE_0__.Component).__e=function(n){var t=this,e=U(t.__v),r=t.o.get(n);return r[0]++,function(u){var o=function(){t.props.revealOrder?(r.push(u),T$1(t,n,r)):u();};e?e(o):o();}},M.prototype.render=function(n){this.u=null,this.o=new Map;var t=(0,preact__WEBPACK_IMPORTED_MODULE_0__.toChildArray)(n.children);n.revealOrder&&"b"===n.revealOrder[0]&&t.reverse();for(var e=t.length;e--;)this.o.set(t[e],this.u=[1,0,this.u]);return n.children},M.prototype.componentDidUpdate=M.prototype.componentDidMount=function(){var n=this;this.o.forEach(function(t,e){T$1(n,e,t);});};var j$1="undefined"!=typeof Symbol&&Symbol.for&&Symbol.for("react.element")||60103,P=/^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|marker(?!H|W|U)|overline|paint|stop|strikethrough|stroke|text(?!L)|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/,V="undefined"!=typeof document,z=function(n){return ("undefined"!=typeof Symbol&&"symbol"==typeof Symbol()?/fil|che|rad/i:/fil|che|ra/i).test(n)};function B(n,t,e){return null==t.__k&&(t.textContent=""),(0,preact__WEBPACK_IMPORTED_MODULE_0__.render)(n,t),"function"==typeof e&&e(),n?n.__c:null}function $(n,t,e){return (0,preact__WEBPACK_IMPORTED_MODULE_0__.hydrate)(n,t),"function"==typeof e&&e(),n?n.__c:null}preact__WEBPACK_IMPORTED_MODULE_0__.Component.prototype.isReactComponent={},["componentWillMount","componentWillReceiveProps","componentWillUpdate"].forEach(function(n){Object.defineProperty(preact__WEBPACK_IMPORTED_MODULE_0__.Component.prototype,n,{configurable:!0,get:function(){return this["UNSAFE_"+n]},set:function(t){Object.defineProperty(this,n,{configurable:!0,writable:!0,value:t});}});});var H=preact__WEBPACK_IMPORTED_MODULE_0__.options.event;function Z(){}function Y(){return this.cancelBubble}function q(){return this.defaultPrevented}preact__WEBPACK_IMPORTED_MODULE_0__.options.event=function(n){return H&&(n=H(n)),n.persist=Z,n.isPropagationStopped=Y,n.isDefaultPrevented=q,n.nativeEvent=n};var G,J={configurable:!0,get:function(){return this.class}},K=preact__WEBPACK_IMPORTED_MODULE_0__.options.vnode;preact__WEBPACK_IMPORTED_MODULE_0__.options.vnode=function(n){var t=n.type,e=n.props,r=e;if("string"==typeof t){var u=-1===t.indexOf("-");for(var o in r={},e){var i=e[o];V&&"children"===o&&"noscript"===t||"value"===o&&"defaultValue"in e&&null==i||("defaultValue"===o&&"value"in e&&null==e.value?o="value":"download"===o&&!0===i?i="":/ondoubleclick/i.test(o)?o="ondblclick":/^onchange(textarea|input)/i.test(o+t)&&!z(e.type)?o="oninput":/^onfocus$/i.test(o)?o="onfocusin":/^onblur$/i.test(o)?o="onfocusout":/^on(Ani|Tra|Tou|BeforeInp)/.test(o)?o=o.toLowerCase():u&&P.test(o)?o=o.replace(/[A-Z0-9]/,"-$&").toLowerCase():null===i&&(i=void 0),r[o]=i);}"select"==t&&r.multiple&&Array.isArray(r.value)&&(r.value=(0,preact__WEBPACK_IMPORTED_MODULE_0__.toChildArray)(e.children).forEach(function(n){n.props.selected=-1!=r.value.indexOf(n.props.value);})),"select"==t&&null!=r.defaultValue&&(r.value=(0,preact__WEBPACK_IMPORTED_MODULE_0__.toChildArray)(e.children).forEach(function(n){n.props.selected=r.multiple?-1!=r.defaultValue.indexOf(n.props.value):r.defaultValue==n.props.value;})),n.props=r,e.class!=e.className&&(J.enumerable="className"in e,null!=e.className&&(r.class=e.className),Object.defineProperty(r,"className",J));}n.$$typeof=j$1,K&&K(n);};var Q=preact__WEBPACK_IMPORTED_MODULE_0__.options.__r;preact__WEBPACK_IMPORTED_MODULE_0__.options.__r=function(n){Q&&Q(n),G=n.__c;};var X={ReactCurrentDispatcher:{current:{readContext:function(n){return G.__n[n.__c].props.value}}}};function tn(n){return preact__WEBPACK_IMPORTED_MODULE_0__.createElement.bind(null,n)}function en(n){return !!n&&n.$$typeof===j$1}function rn(n){return en(n)?preact__WEBPACK_IMPORTED_MODULE_0__.cloneElement.apply(null,arguments):n}function un(n){return !!n.__k&&((0,preact__WEBPACK_IMPORTED_MODULE_0__.render)(null,n),!0)}function on(n){return n&&(n.base||1===n.nodeType&&n)||null}var ln=function(n,t){return n(t)},cn=function(n,t){return n(t)};var React__default = {useState:l,useReducer:p,useEffect:y,useLayoutEffect:h,useRef:s,useImperativeHandle:_,useMemo:d,useCallback:A,useContext:F,useDebugValue:T,version:"17.0.2",Children:k$1,render:B,hydrate:$,unmountComponentAtNode:un,createPortal:W,createElement:preact__WEBPACK_IMPORTED_MODULE_0__.createElement,createContext:preact__WEBPACK_IMPORTED_MODULE_0__.createContext,createFactory:tn,cloneElement:rn,createRef:preact__WEBPACK_IMPORTED_MODULE_0__.createRef,Fragment:preact__WEBPACK_IMPORTED_MODULE_0__.Fragment,isValidElement:en,findDOMNode:on,Component:preact__WEBPACK_IMPORTED_MODULE_0__.Component,PureComponent:E,memo:g$1,forwardRef:x$1,flushSync:cn,unstable_batchedUpdates:ln,StrictMode:preact__WEBPACK_IMPORTED_MODULE_0__.Fragment,Suspense:L,SuspenseList:M,lazy:F$1,__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED:X};

/*
Copyright (c) NAVER Corp.
name: @egjs/component
license: MIT
author: NAVER Corp.
repository: https://github.com/naver/egjs-component
version: 3.0.4
*/
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator,
    m = s && o[s],
    i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function () {
      if (o && i >= o.length) o = void 0;
      return {
        value: o && o[i++],
        done: !o
      };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o),
    r,
    ar = [],
    e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = {
      error: error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
  return ar;
}

/*
 * Copyright (c) 2015 NAVER Corp.
 * egjs projects are licensed under the MIT license
 */
var isUndefined = function (value) {
  return typeof value === "undefined";
};

// This class name is not matched to file name intentionally
/**
 * Event class to provide additional properties
 * @ko Component에서 추가적인 프로퍼티를 제공하는 이벤트 클래스
 */
var ComponentEvent = /*#__PURE__*/function () {
  /**
   * Create a new instance of ComponentEvent.
   * @ko ComponentEvent의 새로운 인스턴스를 생성한다.
   * @param eventType The name of the event.<ko>이벤트 이름.</ko>
   * @param props An object that contains additional event properties.<ko>추가적인 이벤트 프로퍼티 오브젝트.</ko>
   */
  function ComponentEvent(eventType, props) {
    var e_1, _a;
    this._canceled = false;
    if (props) {
      try {
        for (var _b = __values(Object.keys(props)), _c = _b.next(); !_c.done; _c = _b.next()) {
          var key = _c.value;
          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
          this[key] = props[key];
        }
      } catch (e_1_1) {
        e_1 = {
          error: e_1_1
        };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        } finally {
          if (e_1) throw e_1.error;
        }
      }
    }
    this.eventType = eventType;
  }
  /**
   * Stop the event. {@link ComponentEvent#isCanceled} will return `true` after.
   * @ko 이벤트를 중단한다. 이후 {@link ComponentEvent#isCanceled}가 `true`를 반환한다.
   */
  var __proto = ComponentEvent.prototype;
  __proto.stop = function () {
    this._canceled = true;
  };
  /**
   * Returns a boolean value that indicates whether {@link ComponentEvent#stop} is called before.
   * @ko {@link ComponentEvent#stop}이 호출되었는지 여부를 반환한다.
   * @return {boolean} A boolean value that indicates whether {@link ComponentEvent#stop} is called before.<ko>이전에 {@link ComponentEvent#stop}이 불려졌는지 여부를 반환한다.</ko>
   */
  __proto.isCanceled = function () {
    return this._canceled;
  };
  return ComponentEvent;
}();

/**
 * A class used to manage events in a component
 * @ko 컴포넌트의 이벤트을 관리할 수 있게 하는 클래스
 */
var Component = /*#__PURE__*/function () {
  /**
   * @support {"ie": "7+", "ch" : "latest", "ff" : "latest",  "sf" : "latest", "edge" : "latest", "ios" : "7+", "an" : "2.1+ (except 3.x)"}
   */
  function Component() {
    this._eventHandler = {};
  }
  /**
   * Trigger a custom event.
   * @ko 커스텀 이벤트를 발생시킨다
   * @param {string | ComponentEvent} event The name of the custom event to be triggered or an instance of the ComponentEvent<ko>발생할 커스텀 이벤트의 이름 또는 ComponentEvent의 인스턴스</ko>
   * @param {any[]} params Event data to be sent when triggering a custom event <ko>커스텀 이벤트가 발생할 때 전달할 데이터</ko>
   * @return An instance of the component itself<ko>컴포넌트 자신의 인스턴스</ko>
   * @example
   * ```ts
   * import Component, { ComponentEvent } from "@egjs/component";
   *
   * class Some extends Component<{
   *   beforeHi: ComponentEvent<{ foo: number; bar: string }>;
   *   hi: { foo: { a: number; b: boolean } };
   *   someEvent: (foo: number, bar: string) => void;
   *   someOtherEvent: void; // When there's no event argument
   * }> {
   *   some(){
   *     if(this.trigger("beforeHi")){ // When event call to stop return false.
   *       this.trigger("hi");// fire hi event.
   *     }
   *   }
   * }
   *
   * const some = new Some();
   * some.on("beforeHi", e => {
   *   if(condition){
   *     e.stop(); // When event call to stop, `hi` event not call.
   *   }
   *   // `currentTarget` is component instance.
   *   console.log(some === e.currentTarget); // true
   *
   *   typeof e.foo; // number
   *   typeof e.bar; // string
   * });
   * some.on("hi", e => {
   *   typeof e.foo.b; // boolean
   * });
   * // If you want to more know event design. You can see article.
   * // https://github.com/naver/egjs-component/wiki/How-to-make-Component-event-design%3F
   * ```
   */
  var __proto = Component.prototype;
  __proto.trigger = function (event) {
    var params = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      params[_i - 1] = arguments[_i];
    }
    var eventName = event instanceof ComponentEvent ? event.eventType : event;
    var handlers = __spread(this._eventHandler[eventName] || []);
    if (handlers.length <= 0) {
      return this;
    }
    if (event instanceof ComponentEvent) {
      event.currentTarget = this;
      handlers.forEach(function (handler) {
        handler(event);
      });
    } else {
      handlers.forEach(function (handler) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-call
        handler.apply(void 0, __spread(params));
      });
    }
    return this;
  };
  /**
   * Executed event just one time.
   * @ko 이벤트가 한번만 실행된다.
   * @param {string} eventName The name of the event to be attached or an event name - event handler mapped object.<ko>등록할 이벤트의 이름 또는 이벤트 이름-핸들러 오브젝트</ko>
   * @param {function} handlerToAttach The handler function of the event to be attached <ko>등록할 이벤트의 핸들러 함수</ko>
   * @return An instance of the component itself<ko>컴포넌트 자신의 인스턴스</ko>
   * @example
   * ```ts
   * import Component, { ComponentEvent } from "@egjs/component";
   *
   * class Some extends Component<{
   *   hi: ComponentEvent;
   * }> {
   *   hi() {
   *     alert("hi");
   *   }
   *   thing() {
   *     this.once("hi", this.hi);
   *   }
   * }
   *
   * var some = new Some();
   * some.thing();
   * some.trigger(new ComponentEvent("hi"));
   * // fire alert("hi");
   * some.trigger(new ComponentEvent("hi"));
   * // Nothing happens
   * ```
   */
  __proto.once = function (eventName, handlerToAttach) {
    var _this = this;
    if (typeof eventName === "object" && isUndefined(handlerToAttach)) {
      var eventHash = eventName;
      for (var key in eventHash) {
        this.once(key, eventHash[key]);
      }
      return this;
    } else if (typeof eventName === "string" && typeof handlerToAttach === "function") {
      var listener_1 = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        // eslint-disable-next-line @typescript-eslint/no-unsafe-call
        handlerToAttach.apply(void 0, __spread(args));
        _this.off(eventName, listener_1);
      };
      this.on(eventName, listener_1);
    }
    return this;
  };
  /**
   * Checks whether an event has been attached to a component.
   * @ko 컴포넌트에 이벤트가 등록됐는지 확인한다.
   * @param {string} eventName The name of the event to be attached <ko>등록 여부를 확인할 이벤트의 이름</ko>
   * @return {boolean} Indicates whether the event is attached. <ko>이벤트 등록 여부</ko>
   * @example
   * ```ts
   * import Component from "@egjs/component";
   *
   * class Some extends Component<{
   *   hi: void;
   * }> {
   *   some() {
   *     this.hasOn("hi");// check hi event.
   *   }
   * }
   * ```
   */
  __proto.hasOn = function (eventName) {
    return !!this._eventHandler[eventName];
  };
  /**
   * Attaches an event to a component.
   * @ko 컴포넌트에 이벤트를 등록한다.
   * @param {string} eventName The name of the event to be attached or an event name - event handler mapped object.<ko>등록할 이벤트의 이름 또는 이벤트 이름-핸들러 오브젝트</ko>
   * @param {function} handlerToAttach The handler function of the event to be attached <ko>등록할 이벤트의 핸들러 함수</ko>
   * @return An instance of a component itself<ko>컴포넌트 자신의 인스턴스</ko>
   * @example
   * ```ts
   * import Component, { ComponentEvent } from "@egjs/component";
   *
   * class Some extends Component<{
   *   hi: void;
   * }> {
   *   hi() {
   *     console.log("hi");
   *   }
   *   some() {
   *     this.on("hi",this.hi); //attach event
   *   }
   * }
   * ```
   */
  __proto.on = function (eventName, handlerToAttach) {
    if (typeof eventName === "object" && isUndefined(handlerToAttach)) {
      var eventHash = eventName;
      for (var name in eventHash) {
        this.on(name, eventHash[name]);
      }
      return this;
    } else if (typeof eventName === "string" && typeof handlerToAttach === "function") {
      var handlerList = this._eventHandler[eventName];
      if (isUndefined(handlerList)) {
        this._eventHandler[eventName] = [];
        handlerList = this._eventHandler[eventName];
      }
      handlerList.push(handlerToAttach);
    }
    return this;
  };
  /**
   * Detaches an event from the component.<br/>If the `eventName` is not given this will detach all event handlers attached.<br/>If the `handlerToDetach` is not given, this will detach all event handlers for `eventName`.
   * @ko 컴포넌트에 등록된 이벤트를 해제한다.<br/>`eventName`이 주어지지 않았을 경우 모든 이벤트 핸들러를 제거한다.<br/>`handlerToAttach`가 주어지지 않았을 경우 `eventName`에 해당하는 모든 이벤트 핸들러를 제거한다.
   * @param {string?} eventName The name of the event to be detached <ko>해제할 이벤트의 이름</ko>
   * @param {function?} handlerToDetach The handler function of the event to be detached <ko>해제할 이벤트의 핸들러 함수</ko>
   * @return An instance of a component itself <ko>컴포넌트 자신의 인스턴스</ko>
   * @example
   * ```ts
   * import Component, { ComponentEvent } from "@egjs/component";
   *
   * class Some extends Component<{
   *   hi: void;
   * }> {
   *   hi() {
   *     console.log("hi");
   *   }
   *   some() {
   *     this.off("hi",this.hi); //detach event
   *   }
   * }
   * ```
   */
  __proto.off = function (eventName, handlerToDetach) {
    var e_1, _a;
    // Detach all event handlers.
    if (isUndefined(eventName)) {
      this._eventHandler = {};
      return this;
    }
    // Detach all handlers for eventname or detach event handlers by object.
    if (isUndefined(handlerToDetach)) {
      if (typeof eventName === "string") {
        delete this._eventHandler[eventName];
        return this;
      } else {
        var eventHash = eventName;
        for (var name in eventHash) {
          this.off(name, eventHash[name]);
        }
        return this;
      }
    }
    // Detach single event handler
    var handlerList = this._eventHandler[eventName];
    if (handlerList) {
      var idx = 0;
      try {
        for (var handlerList_1 = __values(handlerList), handlerList_1_1 = handlerList_1.next(); !handlerList_1_1.done; handlerList_1_1 = handlerList_1.next()) {
          var handlerFunction = handlerList_1_1.value;
          if (handlerFunction === handlerToDetach) {
            handlerList.splice(idx, 1);
            if (handlerList.length <= 0) {
              delete this._eventHandler[eventName];
            }
            break;
          }
          idx++;
        }
      } catch (e_1_1) {
        e_1 = {
          error: e_1_1
        };
      } finally {
        try {
          if (handlerList_1_1 && !handlerList_1_1.done && (_a = handlerList_1.return)) _a.call(handlerList_1);
        } finally {
          if (e_1) throw e_1.error;
        }
      }
    }
    return this;
  };
  /**
   * Version info string
   * @ko 버전정보 문자열
   * @name VERSION
   * @static
   * @example
   * Component.VERSION;  // ex) 3.0.0
   * @memberof Component
   */
  Component.VERSION = "3.0.4";
  return Component;
}();

/*
 * Copyright (c) 2015 NAVER Corp.
 * egjs projects are licensed under the MIT license
 */
// eslint-disable-next-line @typescript-eslint/naming-convention, @typescript-eslint/no-unsafe-assignment
var ComponentEvent$1 = ComponentEvent;

/*
Copyright (c) 2019-present NAVER Corp.
name: @egjs/list-differ
license: MIT
author: NAVER Corp.
repository: https://github.com/naver/egjs-list-differ
version: 1.0.1
*/
/*
egjs-list-differ
Copyright (c) 2019-present NAVER Corp.
MIT license
*/
var PolyMap =
/*#__PURE__*/
function () {
  function PolyMap() {
    this.keys = [];
    this.values = [];
  }

  var __proto = PolyMap.prototype;

  __proto.get = function (key) {
    return this.values[this.keys.indexOf(key)];
  };

  __proto.set = function (key, value) {
    var keys = this.keys;
    var values = this.values;
    var prevIndex = keys.indexOf(key);
    var index = prevIndex === -1 ? keys.length : prevIndex;
    keys[index] = key;
    values[index] = value;
  };

  return PolyMap;
}();

/*
egjs-list-differ
Copyright (c) 2019-present NAVER Corp.
MIT license
*/
var HashMap =
/*#__PURE__*/
function () {
  function HashMap() {
    this.object = {};
  }

  var __proto = HashMap.prototype;

  __proto.get = function (key) {
    return this.object[key];
  };

  __proto.set = function (key, value) {
    this.object[key] = value;
  };

  return HashMap;
}();

/*
egjs-list-differ
Copyright (c) 2019-present NAVER Corp.
MIT license
*/
var SUPPORT_MAP = typeof Map === "function";

/*
egjs-list-differ
Copyright (c) 2019-present NAVER Corp.
MIT license
*/
var Link =
/*#__PURE__*/
function () {
  function Link() {}

  var __proto = Link.prototype;

  __proto.connect = function (prevLink, nextLink) {
    this.prev = prevLink;
    this.next = nextLink;
    prevLink && (prevLink.next = this);
    nextLink && (nextLink.prev = this);
  };

  __proto.disconnect = function () {
    // In double linked list, diconnect the interconnected relationship.
    var prevLink = this.prev;
    var nextLink = this.next;
    prevLink && (prevLink.next = nextLink);
    nextLink && (nextLink.prev = prevLink);
  };

  __proto.getIndex = function () {
    var link = this;
    var index = -1;

    while (link) {
      link = link.prev;
      ++index;
    }

    return index;
  };

  return Link;
}();

/*
egjs-list-differ
Copyright (c) 2019-present NAVER Corp.
MIT license
*/

function orderChanged(changed, fixed) {
  // It is roughly in the order of these examples.
  // 4, 6, 0, 2, 1, 3, 5, 7
  var fromLinks = []; // 0, 1, 2, 3, 4, 5, 6, 7

  var toLinks = [];
  changed.forEach(function (_a) {
    var from = _a[0],
        to = _a[1];
    var link = new Link();
    fromLinks[from] = link;
    toLinks[to] = link;
  }); // `fromLinks` are connected to each other by double linked list.

  fromLinks.forEach(function (link, i) {
    link.connect(fromLinks[i - 1]);
  });
  return changed.filter(function (_, i) {
    return !fixed[i];
  }).map(function (_a, i) {
    var from = _a[0],
        to = _a[1];

    if (from === to) {
      return [0, 0];
    }

    var fromLink = fromLinks[from];
    var toLink = toLinks[to - 1];
    var fromIndex = fromLink.getIndex(); // Disconnect the link connected to `fromLink`.

    fromLink.disconnect(); // Connect `fromLink` to the right of `toLink`.

    if (!toLink) {
      fromLink.connect(undefined, fromLinks[0]);
    } else {
      fromLink.connect(toLink, toLink.next);
    }

    var toIndex = fromLink.getIndex();
    return [fromIndex, toIndex];
  });
}

var Result =
/*#__PURE__*/
function () {
  function Result(prevList, list, added, removed, changed, maintained, changedBeforeAdded, fixed) {
    this.prevList = prevList;
    this.list = list;
    this.added = added;
    this.removed = removed;
    this.changed = changed;
    this.maintained = maintained;
    this.changedBeforeAdded = changedBeforeAdded;
    this.fixed = fixed;
  }

  var __proto = Result.prototype;
  Object.defineProperty(__proto, "ordered", {
    get: function () {
      if (!this.cacheOrdered) {
        this.caculateOrdered();
      }

      return this.cacheOrdered;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(__proto, "pureChanged", {
    get: function () {
      if (!this.cachePureChanged) {
        this.caculateOrdered();
      }

      return this.cachePureChanged;
    },
    enumerable: true,
    configurable: true
  });

  __proto.caculateOrdered = function () {
    var ordered = orderChanged(this.changedBeforeAdded, this.fixed);
    var changed = this.changed;
    var pureChanged = [];
    this.cacheOrdered = ordered.filter(function (_a, i) {
      var from = _a[0],
          to = _a[1];
      var _b = changed[i],
          fromBefore = _b[0],
          toBefore = _b[1];

      if (from !== to) {
        pureChanged.push([fromBefore, toBefore]);
        return true;
      }
    });
    this.cachePureChanged = pureChanged;
  };

  return Result;
}();

/**
 *
 * @memberof eg.ListDiffer
 * @static
 * @function
 * @param - Previous List <ko> 이전 목록 </ko>
 * @param - List to Update <ko> 업데이트 할 목록 </ko>
 * @param - This callback function returns the key of the item. <ko> 아이템의 키를 반환하는 콜백 함수입니다.</ko>
 * @return - Returns the diff between `prevList` and `list` <ko> `prevList`와 `list`의 다른 점을 반환한다.</ko>
 * @example
 * import { diff } from "@egjs/list-differ";
 * // script => eg.ListDiffer.diff
 * const result = diff([0, 1, 2, 3, 4, 5], [7, 8, 0, 4, 3, 6, 2, 1], e => e);
 * // List before update
 * // [1, 2, 3, 4, 5]
 * console.log(result.prevList);
 * // Updated list
 * // [4, 3, 6, 2, 1]
 * console.log(result.list);
 * // Index array of values added to `list`
 * // [0, 1, 5]
 * console.log(result.added);
 * // Index array of values removed in `prevList`
 * // [5]
 * console.log(result.removed);
 * // An array of index pairs of `prevList` and `list` with different indexes from `prevList` and `list`
 * // [[0, 2], [4, 3], [3, 4], [2, 6], [1, 7]]
 * console.log(result.changed);
 * // The subset of `changed` and an array of index pairs that moved data directly. Indicate an array of absolute index pairs of `ordered`.(Formatted by: Array<[index of prevList, index of list]>)
 * // [[4, 3], [3, 4], [2, 6]]
 * console.log(result.pureChanged);
 * // An array of index pairs to be `ordered` that can synchronize `list` before adding data. (Formatted by: Array<[prevIndex, nextIndex]>)
 * // [[4, 1], [4, 2], [4, 3]]
 * console.log(result.ordered);
 * // An array of index pairs of `prevList` and `list` that have not been added/removed so data is preserved
 * // [[0, 2], [4, 3], [3, 4], [2, 6], [1, 7]]
 * console.log(result.maintained);
 */

function diff(prevList, list, findKeyCallback) {
  var mapClass = SUPPORT_MAP ? Map : findKeyCallback ? HashMap : PolyMap;

  var callback = findKeyCallback || function (e) {
    return e;
  };

  var added = [];
  var removed = [];
  var maintained = [];
  var prevKeys = prevList.map(callback);
  var keys = list.map(callback);
  var prevKeyMap = new mapClass();
  var keyMap = new mapClass();
  var changedBeforeAdded = [];
  var fixed = [];
  var removedMap = {};
  var changed = [];
  var addedCount = 0;
  var removedCount = 0; // Add prevKeys and keys to the hashmap.

  prevKeys.forEach(function (key, prevListIndex) {
    prevKeyMap.set(key, prevListIndex);
  });
  keys.forEach(function (key, listIndex) {
    keyMap.set(key, listIndex);
  }); // Compare `prevKeys` and `keys` and add them to `removed` if they are not in `keys`.

  prevKeys.forEach(function (key, prevListIndex) {
    var listIndex = keyMap.get(key); // In prevList, but not in list, it is removed.

    if (typeof listIndex === "undefined") {
      ++removedCount;
      removed.push(prevListIndex);
    } else {
      removedMap[listIndex] = removedCount;
    }
  }); // Compare `prevKeys` and `keys` and add them to `added` if they are not in `prevKeys`.

  keys.forEach(function (key, listIndex) {
    var prevListIndex = prevKeyMap.get(key); // In list, but not in prevList, it is added.

    if (typeof prevListIndex === "undefined") {
      added.push(listIndex);
      ++addedCount;
    } else {
      maintained.push([prevListIndex, listIndex]);
      removedCount = removedMap[listIndex] || 0;
      changedBeforeAdded.push([prevListIndex - removedCount, listIndex - addedCount]);
      fixed.push(listIndex === prevListIndex);

      if (prevListIndex !== listIndex) {
        changed.push([prevListIndex, listIndex]);
      }
    }
  }); // Sort by ascending order of 'to(list's index).

  removed.reverse();
  return new Result(prevList, list, added, removed, changed, maintained, changedBeforeAdded, fixed);
}

/**
 * A module that checks diff when values are added, removed, or changed in an array.
 * @ko 배열 또는 오브젝트에서 값이 추가되거나 삭제되거나 순서가 변경사항을 체크하는 모듈입니다.
 * @memberof eg
 */

var ListDiffer =
/*#__PURE__*/
function () {
  /**
   * @param - Initializing Data Array. <ko> 초기 설정할 데이터 배열.</ko>
   * @param - This callback function returns the key of the item. <ko> 아이템의 키를 반환하는 콜백 함수입니다.</ko>
   * @example
   * import ListDiffer from "@egjs/list-differ";
   * // script => eg.ListDiffer
   * const differ = new ListDiffer([0, 1, 2, 3, 4, 5], e => e);
   * const result = differ.update([7, 8, 0, 4, 3, 6, 2, 1]);
   * // List before update
   * // [1, 2, 3, 4, 5]
   * console.log(result.prevList);
   * // Updated list
   * // [4, 3, 6, 2, 1]
   * console.log(result.list);
   * // Index array of values added to `list`.
   * // [0, 1, 5]
   * console.log(result.added);
   * // Index array of values removed in `prevList`.
   * // [5]
   * console.log(result.removed);
   * // An array of index pairs of `prevList` and `list` with different indexes from `prevList` and `list`.
   * // [[0, 2], [4, 3], [3, 4], [2, 6], [1, 7]]
   * console.log(result.changed);
   * // The subset of `changed` and an array of index pairs that moved data directly. Indicate an array of absolute index pairs of `ordered`.(Formatted by: Array<[index of prevList, index of list]>)
   * // [[4, 3], [3, 4], [2, 6]]
   * console.log(result.pureChanged);
   * // An array of index pairs to be `ordered` that can synchronize `list` before adding data. (Formatted by: Array<[prevIndex, nextIndex]>)
   * // [[4, 1], [4, 2], [4, 3]]
   * console.log(result.ordered);
   * // An array of index pairs of `prevList` and `list` that have not been added/removed so data is preserved.
   * // [[0, 2], [4, 3], [3, 4], [2, 6], [1, 7]]
   * console.log(result.maintained);
   */
  function ListDiffer(list, findKeyCallback) {
    if (list === void 0) {
      list = [];
    }

    this.findKeyCallback = findKeyCallback;
    this.list = [].slice.call(list);
  }
  /**
   * Update list.
   * @ko 리스트를 업데이트를 합니다.
   * @param - List to update <ko> 업데이트할 리스트 </ko>
   * @return - Returns the results of an update from `prevList` to `list`.<ko> `prevList`에서 `list`로 업데이트한 결과를 반환한다. </ko>
   */


  var __proto = ListDiffer.prototype;

  __proto.update = function (list) {
    var newData = [].slice.call(list);
    var result = diff(this.list, newData, this.findKeyCallback);
    this.list = newData;
    return result;
  };

  return ListDiffer;
}();

/*
Copyright (c) 2015 NAVER Corp.
name: @egjs/agent
license: MIT
author: NAVER Corp.
repository: git+https://github.com/naver/agent.git
version: 2.4.3
*/
function some(arr, callback) {
  var length = arr.length;

  for (var i = 0; i < length; ++i) {
    if (callback(arr[i], i)) {
      return true;
    }
  }

  return false;
}
function find(arr, callback) {
  var length = arr.length;

  for (var i = 0; i < length; ++i) {
    if (callback(arr[i], i)) {
      return arr[i];
    }
  }

  return null;
}
function getUserAgentString(agent) {
  var userAgent = agent;

  if (typeof userAgent === "undefined") {
    if (typeof navigator === "undefined" || !navigator) {
      return "";
    }

    userAgent = navigator.userAgent || "";
  }

  return userAgent.toLowerCase();
}
function execRegExp(pattern, text) {
  try {
    return new RegExp(pattern, "g").exec(text);
  } catch (e) {
    return null;
  }
}
function hasUserAgentData() {
  if (typeof navigator === "undefined" || !navigator || !navigator.userAgentData) {
    return false;
  }

  var userAgentData = navigator.userAgentData;
  var brands = userAgentData.brands || userAgentData.uaList;
  return !!(brands && brands.length);
}
function findVersion(versionTest, userAgent) {
  var result = execRegExp("(" + versionTest + ")((?:\\/|\\s|:)([0-9|\\.|_]+))", userAgent);
  return result ? result[3] : "";
}
function convertVersion(text) {
  return text.replace(/_/g, ".");
}
function findPreset(presets, userAgent) {
  var userPreset = null;
  var version = "-1";
  some(presets, function (preset) {
    var result = execRegExp("(" + preset.test + ")((?:\\/|\\s|:)([0-9|\\.|_]+))?", userAgent);

    if (!result || preset.brand) {
      return false;
    }

    userPreset = preset;
    version = result[3] || "-1";

    if (preset.versionAlias) {
      version = preset.versionAlias;
    } else if (preset.versionTest) {
      version = findVersion(preset.versionTest.toLowerCase(), userAgent) || version;
    }

    version = convertVersion(version);
    return true;
  });
  return {
    preset: userPreset,
    version: version
  };
}
function findPresetBrand(presets, brands) {
  var brandInfo = {
    brand: "",
    version: "-1"
  };
  some(presets, function (preset) {
    var result = findBrand(brands, preset);

    if (!result) {
      return false;
    }

    brandInfo.brand = preset.id;
    brandInfo.version = preset.versionAlias || result.version;
    return brandInfo.version !== "-1";
  });
  return brandInfo;
}
function findBrand(brands, preset) {
  return find(brands, function (_a) {
    var brand = _a.brand;
    return execRegExp("" + preset.test, brand.toLowerCase());
  });
}

var BROWSER_PRESETS = [{
  test: "phantomjs",
  id: "phantomjs"
}, {
  test: "whale",
  id: "whale"
}, {
  test: "edgios|edge|edg",
  id: "edge"
}, {
  test: "msie|trident|windows phone",
  id: "ie",
  versionTest: "iemobile|msie|rv"
}, {
  test: "miuibrowser",
  id: "miui browser"
}, {
  test: "samsungbrowser",
  id: "samsung internet"
}, {
  test: "samsung",
  id: "samsung internet",
  versionTest: "version"
}, {
  test: "chrome|crios",
  id: "chrome"
}, {
  test: "firefox|fxios",
  id: "firefox"
}, {
  test: "android",
  id: "android browser",
  versionTest: "version"
}, {
  test: "safari|iphone|ipad|ipod",
  id: "safari",
  versionTest: "version"
}]; // chromium's engine(blink) is based on applewebkit 537.36.

var CHROMIUM_PRESETS = [{
  test: "(?=.*applewebkit/(53[0-7]|5[0-2]|[0-4]))(?=.*\\schrome)",
  id: "chrome",
  versionTest: "chrome"
}, {
  test: "chromium",
  id: "chrome"
}, {
  test: "whale",
  id: "chrome",
  versionAlias: "-1",
  brand: true
}];
var WEBKIT_PRESETS = [{
  test: "applewebkit",
  id: "webkit",
  versionTest: "applewebkit|safari"
}];
var WEBVIEW_PRESETS = [{
  test: "(?=(iphone|ipad))(?!(.*version))",
  id: "webview"
}, {
  test: "(?=(android|iphone|ipad))(?=.*(naver|daum|; wv))",
  id: "webview"
}, {
  // test webview
  test: "webview",
  id: "webview"
}];
var OS_PRESETS = [{
  test: "windows phone",
  id: "windows phone"
}, {
  test: "windows 2000",
  id: "window",
  versionAlias: "5.0"
}, {
  test: "windows nt",
  id: "window"
}, {
  test: "win32|windows",
  id: "window"
}, {
  test: "iphone|ipad|ipod",
  id: "ios",
  versionTest: "iphone os|cpu os"
}, {
  test: "macos|macintel|mac os x",
  id: "mac"
}, {
  test: "android|linux armv81",
  id: "android"
}, {
  test: "tizen",
  id: "tizen"
}, {
  test: "webos|web0s",
  id: "webos"
}];

function isWebView(userAgent) {
  return !!findPreset(WEBVIEW_PRESETS, userAgent).preset;
}
function getLegacyAgent(userAgent) {
  var nextAgent = getUserAgentString(userAgent);
  var isMobile = !!/mobi/g.exec(nextAgent);
  var browser = {
    name: "unknown",
    version: "-1",
    majorVersion: -1,
    webview: isWebView(nextAgent),
    chromium: false,
    chromiumVersion: "-1",
    webkit: false,
    webkitVersion: "-1"
  };
  var os = {
    name: "unknown",
    version: "-1",
    majorVersion: -1
  };

  var _a = findPreset(BROWSER_PRESETS, nextAgent),
      browserPreset = _a.preset,
      browserVersion = _a.version;

  var _b = findPreset(OS_PRESETS, nextAgent),
      osPreset = _b.preset,
      osVersion = _b.version;

  var chromiumPreset = findPreset(CHROMIUM_PRESETS, nextAgent);
  browser.chromium = !!chromiumPreset.preset;
  browser.chromiumVersion = chromiumPreset.version;

  if (!browser.chromium) {
    var webkitPreset = findPreset(WEBKIT_PRESETS, nextAgent);
    browser.webkit = !!webkitPreset.preset;
    browser.webkitVersion = webkitPreset.version;
  }

  if (osPreset) {
    os.name = osPreset.id;
    os.version = osVersion;
    os.majorVersion = parseInt(osVersion, 10);
  }

  if (browserPreset) {
    browser.name = browserPreset.id;
    browser.version = browserVersion; // Early whale bugs

    if (browser.webview && os.name === "ios" && browser.name !== "safari") {
      browser.webview = false;
    }
  }

  browser.majorVersion = parseInt(browser.version, 10);
  return {
    browser: browser,
    os: os,
    isMobile: isMobile,
    isHints: false
  };
}

function getClientHintsAgent(osData) {
  var userAgentData = navigator.userAgentData;
  var brands = (userAgentData.uaList || userAgentData.brands).slice();
  var fullVersionList = osData && osData.fullVersionList;
  var isMobile = userAgentData.mobile || false;
  var firstBrand = brands[0];
  var platform = (osData && osData.platform || userAgentData.platform || navigator.platform).toLowerCase();
  var browser = {
    name: firstBrand.brand,
    version: firstBrand.version,
    majorVersion: -1,
    webkit: false,
    webkitVersion: "-1",
    chromium: false,
    chromiumVersion: "-1",
    webview: !!findPresetBrand(WEBVIEW_PRESETS, brands).brand || isWebView(getUserAgentString())
  };
  var os = {
    name: "unknown",
    version: "-1",
    majorVersion: -1
  };
  browser.webkit = !browser.chromium && some(WEBKIT_PRESETS, function (preset) {
    return findBrand(brands, preset);
  });
  var chromiumBrand = findPresetBrand(CHROMIUM_PRESETS, brands);
  browser.chromium = !!chromiumBrand.brand;
  browser.chromiumVersion = chromiumBrand.version;

  if (!browser.chromium) {
    var webkitBrand = findPresetBrand(WEBKIT_PRESETS, brands);
    browser.webkit = !!webkitBrand.brand;
    browser.webkitVersion = webkitBrand.version;
  }

  var platfomResult = find(OS_PRESETS, function (preset) {
    return new RegExp("" + preset.test, "g").exec(platform);
  });
  os.name = platfomResult ? platfomResult.id : "";

  if (osData) {
    os.version = osData.platformVersion;
  }

  if (fullVersionList && fullVersionList.length) {
    var browserBrandByFullVersionList = findPresetBrand(BROWSER_PRESETS, fullVersionList);
    browser.name = browserBrandByFullVersionList.brand || browser.name;
    browser.version = browserBrandByFullVersionList.version || browser.version;
  } else {
    var browserBrand = findPresetBrand(BROWSER_PRESETS, brands);
    browser.name = browserBrand.brand || browser.name;
    browser.version = browserBrand.brand && osData ? osData.uaFullVersion : browserBrand.version;
  }

  if (browser.webkit) {
    os.name = isMobile ? "ios" : "mac";
  }

  if (os.name === "ios" && browser.webview) {
    browser.version = "-1";
  }

  os.version = convertVersion(os.version);
  browser.version = convertVersion(browser.version);
  os.majorVersion = parseInt(os.version, 10);
  browser.majorVersion = parseInt(browser.version, 10);
  return {
    browser: browser,
    os: os,
    isMobile: isMobile,
    isHints: true
  };
}
/**
 * Extracts browser and operating system information from the user agent string.
 * @ko 유저 에이전트 문자열에서 브라우저와 운영체제 정보를 추출한다.
 * @function eg.agent#agent
 * @param - user agent string to parse <ko>파싱할 유저에이전트 문자열</ko>
 * @return - agent Info <ko> 에이전트 정보 </ko>
 * @example
import agent from "@egjs/agent";
// eg.agent();
const { os, browser, isMobile } = agent();
 */

function agent(userAgent) {
  if (typeof userAgent === "undefined" && hasUserAgentData()) {
    return getClientHintsAgent();
  } else {
    return getLegacyAgent(userAgent);
  }
}

/*
Copyright (c) 2022-present NAVER Corp.
name: @cfcs/core
license: MIT
author: NAVER Crop.
repository: https://github.com/naver/cfcs/tree/main/packages/core
version: 0.1.0
*/

/**
 * cfcs
 * Copyright (c) 2022-present NAVER Corp.
 * MIT license
 */

/**
 * @hidden
 */
function keys(obj) {
  return Object.keys(obj);
}

/**
 * cfcs
 * Copyright (c) 2022-present NAVER Corp.
 * MIT license
 */
var OBSERVERS_PATH = "__observers__";
var COMPUTED_PATH = "__computed__";
var CFCS_DETECTED_DEPENDENCIES_VERSION = 1;
var CFCS_DETECTED_DEPENDENCIES = "__CFCS_DETECTED_DEPENDENCIES__";

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

/* global Reflect, Promise */
var extendStatics = function (d, b) {
  extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
  };

  return extendStatics(d, b);
};

function __extends(d, b) {
  if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);

  function __() {
    this.constructor = d;
  }

  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

/**
 * cfcs
 * Copyright (c) 2022-present NAVER Corp.
 * MIT license
 */
function getDetectedStack() {
  // Version issues do not occur when you access the native object in the global.
  Object[CFCS_DETECTED_DEPENDENCIES] = Object[CFCS_DETECTED_DEPENDENCIES] || {};
  var versionList = Object[CFCS_DETECTED_DEPENDENCIES];
  versionList[CFCS_DETECTED_DEPENDENCIES_VERSION] = versionList[CFCS_DETECTED_DEPENDENCIES_VERSION] || [];
  return versionList[CFCS_DETECTED_DEPENDENCIES_VERSION];
}
function getCurrentDetected() {
  var stack = getDetectedStack();
  return stack[stack.length - 1];
}
function detectDependencies(host) {
  var stack = getDetectedStack();
  var observers = [];
  var detected = {
    host: host,
    observers: observers,
    push: function (observer) {
      if (host !== observer && observers.indexOf(observer) === -1) {
        observers.push(observer);
      }
    }
  };
  stack.push(detected);
  return detected;
}
function endDetectDependencies() {
  var stack = getDetectedStack();
  return stack.pop();
}

/**
 * cfcs
 * Copyright (c) 2022-present NAVER Corp.
 * MIT license
 */
/**
 * Creates a mutable ref object. You can access the `.current` value and detect the value change through `.subscribe`.
 * @category Reactive
 * @see observe
 */

var Observer =
/*#__PURE__*/
function () {
  /**
   *
   */
  function Observer(value) {
    this._emitter = new Component();
    this._current = value;
  }

  var __proto = Observer.prototype;
  Object.defineProperty(__proto, "current", {
    /**
     * return the current value.
     */
    get: function () {
      var currentDetected = getCurrentDetected();
      currentDetected === null || currentDetected === void 0 ? void 0 : currentDetected.push(this);
      return this._current;
    },
    set: function (value) {
      this._setCurrent(value);
    },
    enumerable: false,
    configurable: true
  });
  /**
   * When the current value changes, the callback function is called.
   */

  __proto.subscribe = function (callback) {
    this.current;

    this._emitter.on("update", callback);

    return this;
  };
  /**
   * Cancel the registered subscription through callback.
   */


  __proto.unsubscribe = function (callback) {
    this._emitter.off("update", callback);

    return this;
  };

  __proto._setCurrent = function (value) {
    var prevValue = this._current;
    var isUpdate = value !== prevValue;
    this._current = value;

    if (isUpdate) {
      this._emitter.trigger("update", value, prevValue);
    }
  };
  /**
   * @hidden
   */


  __proto.toString = function () {
    return "".concat(this.current);
  };
  /**
   * @hidden
   */


  __proto.valueOf = function () {
    return this.current;
  };

  return Observer;
}();

/**
 * @category Reactive
 * @hidden
 */

var ComputedObserver =
/*#__PURE__*/
function (_super) {
  __extends(ComputedObserver, _super);
  /**
   * @description Creates a new computed observer from the values of other observers.
   * It is read-only and if you change the value of the observer used inside the callback, its value will be automatically updated.
   * @param _computedCallback A function for observers to be computed.
   */


  function ComputedObserver(_computedCallback) {
    var _this = _super.call(this) || this;

    _this._computedCallback = _computedCallback;
    _this._registered = [];

    _this._onCheckUpdate = function () {
      _this._setCurrent(_this.current);
    };

    _this._current = _this.current;
    return _this;
  }

  var __proto = ComputedObserver.prototype;
  Object.defineProperty(__proto, "current", {
    get: function () {
      var _this = this;

      detectDependencies(this);

      var value = this._computedCallback();

      var results = endDetectDependencies();

      this._registered.forEach(function (observer) {
        observer.unsubscribe(_this._onCheckUpdate);
      });

      results.observers.forEach(function (observer) {
        observer.subscribe(_this._onCheckUpdate);
      });
      this._registered = results.observers;
      return value;
    },
    enumerable: false,
    configurable: true
  });
  return ComputedObserver;
}(Observer);

/**
 * cfcs
 * Copyright (c) 2022-present NAVER Corp.
 * MIT license
 */

function injectObserve(prototype, memberName, publicName) {
  if (publicName === void 0) {
    publicName = memberName;
  }

  var nextAttributes = {
    configurable: true,
    get: function () {
      return getObserver(this, publicName).current;
    },
    set: function (value) {
      getObserver(this, publicName, value).current = value;
    }
  };
  Object.defineProperty(prototype, memberName, nextAttributes);

  if (publicName !== memberName) {
    Object.defineProperty(prototype, publicName, {
      configurable: true,
      get: function () {
        return getObserver(this, publicName).current;
      }
    });
  }
}
/**
 * @description `Observe` is a property decorator and converts the property into a `reactive state`. You can detect its status through `.subscribe`.
 * @category Reactive-Decorator
 * @see ReactiveSubscribe
 * @example
* ```ts
import { ReactiveSubscribe, Observe } from "@cfcs/core";

@ReactiveSubscribe
class Component {
  // The public name and state name are the same.
  @Observe value1 = 1;
  // If you want to set public name and private properties separately
  @Observe("value2") _value2 = 1;

  constructor() {
    requestAnimationFrame(() => {
      this.value1 = 2;
    });
  }
}
interface C
```
 */


function Observe() {
  var args = [];

  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }

  if (args.length > 1) {
    return injectObserve(args[0], args[1]);
  }

  return function (prototype, memberName) {
    return injectObserve(prototype, memberName, args[0]);
  };
}

/**
 * cfcs
 * Copyright (c) 2022-present NAVER Corp.
 * MIT license
 */
/**
 * @hidden
 */

function injectReactiveSubscribe(object) {
  object["subscribe"] = function (name, callback) {
    this[name];
    getObserver(this, name).subscribe(callback);
  };

  object["unsubscribe"] = function (name, callback) {
    var _this = this;

    if (!name) {
      keys(getObservers(this)).forEach(function (observerName) {
        _this.unsubscribe(observerName);
      });
      return;
    }

    if (!(name in this)) {
      return;
    }

    getObserver(this, name).unsubscribe(callback);
  };
}
/**
 * @description `ReactiveSubscribe` is a class decorator and adds `.subscribe` and `.unsubscribe` methods.
 * @category Reactive-Decorator
 * @see Observe
 * @example
 * ```ts
import { ReactiveSubscribe, Observe } from "@cfcs/core";

@ReactiveSubscribe
class Component {
  @Observe value1 = 1;

  constructor() {
    requestAnimationFrame(() => {
      this.value1 = 2;
    });
  }
}

interface Component extends ReactiveSubscribe<{
  value1: number;
  value2: number;
}> {}

const component = new Component();

// 1
console.log(component.value1);

component.subscribe("value1", nextValue => {
  // When the change event occurs => (2, 2)
  console.log(nextValue, component.value2);
});
```
 */

function ReactiveSubscribe(Constructor) {
  var prototype = Constructor.prototype;
  injectReactiveSubscribe(prototype);
}
/**
 * @description Creates a mutable ref object. You can access the `.current` value and detect the value change through `.subscribe`.
 * @category Reactive
 * @example
 * ```ts
 * import { observe } from "@cfcs/core";
 *
 * const ob1 = observe(1);
 *
 * ob1.subscribe(nextValue => {
 *   console.log(nextValue);
 * });
 *
 * ob1.current = 2;
 * ```
 */

function observe(defaultValue) {
  return new Observer(defaultValue);
}
/**
 * @hidden
 */

function computed(computedCallback) {
  return new ComputedObserver(computedCallback);
}
/**
 * @hidden
 */

function defineObservers(instance) {
  var observers = {};
  Object.defineProperty(instance, OBSERVERS_PATH, {
    get: function () {
      return observers;
    }
  });
  return observers;
}
/**
 * @hidden
 */

function getObservers(instance, isComputed) {
  var _a, _b;

  if (!instance[OBSERVERS_PATH]) {
    defineObservers(instance);
  }

  var observers = instance[OBSERVERS_PATH];

  if (!isComputed) {
    var computedList = (_b = (_a = instance === null || instance === void 0 ? void 0 : instance.constructor) === null || _a === void 0 ? void 0 : _a.prototype) === null || _b === void 0 ? void 0 : _b[COMPUTED_PATH];

    if (computedList) {
      computedList.forEach(function (name) {
        if (!(name in observers) && name in instance) {
          instance[name];
        }
      });
    }
  }

  return observers;
}
/**
 * @hidden
 */

function getObserver(instance, name, defaultValue) {
  var observers = getObservers(instance);

  if (!observers[name]) {
    observers[name] = observe(defaultValue);
  }

  return observers[name];
}

/**
 * cfcs
 * Copyright (c) 2022-present NAVER Corp.
 * MIT license
 */
/**
 * @description `Computed` is a property decorator.
 * Changes in computed state values are also recognized according to changes in observers used within the getter function.
 * You can detect its status through `.subscribe`.
 * @hidden
 * @category Reactive-Decorator
 * @see ReactiveSubscribe
 * @example
 * ```ts
const ob1 = observe(0);
const ob2 = observe(1);

// When
@ReactiveSubscribe
class TestComputed {
  @Computed
  get ob3() {
    return ob1.current + ob2.current;
  }
}
const inst = new TestComputed();

inst.subscribe("ob3", ob3 => {
  console.log(ob3);
});

ob1.current = 1;
```
 */

function Computed(prototype, memberName, attributes) {
  var get = attributes.get;

  function getComputed() {
    var observers = getObservers(this, true);

    if (!(memberName in observers)) {
      observers[memberName] = computed(get.bind(this));
    }

    return getObserver(this, memberName).current;
  }

  var nextAttributes = {
    configurable: true,
    get: getComputed
  };
  prototype[COMPUTED_PATH] || (prototype[COMPUTED_PATH] = []);
  var computedList = prototype[COMPUTED_PATH];

  if (computedList.indexOf(memberName) === -1) {
    computedList.push(memberName);
  }

  Object.defineProperty(prototype, memberName, nextAttributes);
  return nextAttributes;
}

/*
Copyright (c) NAVER Corp.
name: @egjs/axes
license: MIT
author: NAVER Corp.
repository: https://github.com/naver/egjs-axes
version: 3.9.1
*/

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics$1 = function (d, b) {
  extendStatics$1 = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
  };
  return extendStatics$1(d, b);
};
function __extends$1(d, b) {
  extendStatics$1(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function () {
  __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __decorate(decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}

/*
 * Copyright (c) 2015 NAVER Corp.
 * egjs projects are licensed under the MIT license
 */
/* eslint-disable no-new-func, no-nested-ternary */
var win;
if (typeof window === "undefined") {
  // window is undefined in node.js
  win = {
    navigator: {
      userAgent: ""
    }
  };
} else {
  win = window;
}

/*
 * Copyright (c) 2015 NAVER Corp.
 * egjs projects are licensed under the MIT license
 */
var DIRECTION_NONE = 1;
var DIRECTION_LEFT = 2;
var DIRECTION_RIGHT = 4;
var DIRECTION_HORIZONTAL = 2 | 4;
var DIRECTION_UP = 8;
var DIRECTION_DOWN = 16;
var DIRECTION_VERTICAL = 8 | 16;
var DIRECTION_ALL = 2 | 4 | 8 | 16;
var MOUSE_LEFT = "left";
var MOUSE_RIGHT = "right";
var MOUSE_MIDDLE = "middle";
var MOUSE_BUTTON_CODE_MAP = {
  1: MOUSE_LEFT,
  2: MOUSE_MIDDLE,
  3: MOUSE_RIGHT
};
var ANY = "any";
var NONE = "none";
var SHIFT = "shift";
var CTRL = "ctrl";
var ALT = "alt";
var META = "meta";
var VELOCITY_INTERVAL = 16;
var IOS_EDGE_THRESHOLD = 30;
var IS_IOS_SAFARI = "ontouchstart" in win && agent().browser.name === "safari";
var TRANSFORM = function () {
  if (typeof document === "undefined") {
    return "";
  }
  var bodyStyle = (document.head || document.getElementsByTagName("head")[0]).style;
  var target = ["transform", "webkitTransform", "msTransform", "mozTransform"];
  for (var i = 0, len = target.length; i < len; i++) {
    if (target[i] in bodyStyle) {
      return target[i];
    }
  }
  return "";
}();
var PREVENT_DRAG_CSSPROPS = {
  "-webkit-user-select": "none",
  "-ms-user-select": "none",
  "-moz-user-select": "none",
  "user-select": "none",
  "-webkit-user-drag": "none"
};

var toArray = function (nodes) {
  // const el = Array.prototype.slice.call(nodes);
  // for IE8
  var el = [];
  for (var i = 0, len = nodes.length; i < len; i++) {
    el.push(nodes[i]);
  }
  return el;
};
var $$1 = function (param, multi) {
  if (multi === void 0) {
    multi = false;
  }
  var el;
  if (typeof param === "string") {
    // String (HTML, Selector)
    // check if string is HTML tag format
    var match = param.match(/^<([a-z]+)\s*([^>]*)>/);
    // creating element
    if (match) {
      // HTML
      var dummy = document.createElement("div");
      dummy.innerHTML = param;
      el = toArray(dummy.childNodes);
    } else {
      // Selector
      el = toArray(document.querySelectorAll(param));
    }
    if (!multi) {
      el = el.length >= 1 ? el[0] : undefined;
    }
  } else if (param === win) {
    // window
    el = param;
  } else if ("value" in param || "current" in param) {
    el = param.value || param.current;
  } else if (param.nodeName && (param.nodeType === 1 || param.nodeType === 9)) {
    // HTMLElement, Document
    el = param;
  } else if ("jQuery" in win && param instanceof jQuery || param.constructor.prototype.jquery) {
    // jQuery
    el = multi ? param.toArray() : param.get(0);
  } else if (Array.isArray(param)) {
    el = param.map(function (v) {
      return $$1(v);
    });
    if (!multi) {
      el = el.length >= 1 ? el[0] : undefined;
    }
  }
  return el;
};
var raf = win.requestAnimationFrame || win.webkitRequestAnimationFrame;
var caf = win.cancelAnimationFrame || win.webkitCancelAnimationFrame;
if (raf && !caf) {
  var keyInfo_1 = {};
  var oldraf_1 = raf;
  raf = function (callback) {
    var wrapCallback = function (timestamp) {
      if (keyInfo_1[key]) {
        callback(timestamp);
      }
    };
    var key = oldraf_1(wrapCallback);
    keyInfo_1[key] = true;
    return key;
  };
  caf = function (key) {
    delete keyInfo_1[key];
  };
} else if (!(raf && caf)) {
  raf = function (callback) {
    return win.setTimeout(function () {
      callback(win.performance && win.performance.now && win.performance.now() || new Date().getTime());
    }, 16);
  };
  caf = win.clearTimeout;
}
/**
 * A polyfill for the window.requestAnimationFrame() method.
 * @see  https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame
 * @private
 */
var requestAnimationFrame$1 = function (fp) {
  return raf(fp);
};
/**
 * A polyfill for the window.cancelAnimationFrame() method. It cancels an animation executed through a call to the requestAnimationFrame() method.
 * @param {Number} key −  The ID value returned through a call to the requestAnimationFrame() method. <ko>requestAnimationFrame() 메서드가 반환한 아이디 값</ko>
 * @see  https://developer.mozilla.org/en-US/docs/Web/API/Window/cancelAnimationFrame
 * @private
 */
var cancelAnimationFrame$1 = function (key) {
  caf(key);
};
var map = function (obj, callback) {
  var tranformed = {};
  for (var k in obj) {
    if (k) {
      tranformed[k] = callback(obj[k], k);
    }
  }
  return tranformed;
};
var filter = function (obj, callback) {
  var filtered = {};
  for (var k in obj) {
    if (k && callback(obj[k], k)) {
      filtered[k] = obj[k];
    }
  }
  return filtered;
};
var every = function (obj, callback) {
  for (var k in obj) {
    if (k && !callback(obj[k], k)) {
      return false;
    }
  }
  return true;
};
var equal = function (target, base) {
  return every(target, function (v, k) {
    return v === base[k];
  });
};
var roundNumFunc = {};
var roundNumber = function (num, roundUnit) {
  // Cache for performance
  if (!roundNumFunc[roundUnit]) {
    roundNumFunc[roundUnit] = getRoundFunc(roundUnit);
  }
  return roundNumFunc[roundUnit](num);
};
var roundNumbers = function (num, roundUnit) {
  if (!num || !roundUnit) {
    return num;
  }
  return map(num, function (value, key) {
    return roundNumber(value, typeof roundUnit === "number" ? roundUnit : roundUnit[key]);
  });
};
var getDecimalPlace = function (val) {
  if (!isFinite(val)) {
    return 0;
  }
  var v = "".concat(val);
  if (v.indexOf("e") >= 0) {
    // Exponential Format
    // 1e-10, 1e-12
    var p = 0;
    var e = 1;
    while (Math.round(val * e) / e !== val) {
      e *= 10;
      p++;
    }
    return p;
  }
  // In general, following has performance benefit.
  // https://jsperf.com/precision-calculation
  return v.indexOf(".") >= 0 ? v.length - v.indexOf(".") - 1 : 0;
};
var inversePow = function (n) {
  // replace Math.pow(10, -n) to solve floating point issue.
  // eg. Math.pow(10, -4) => 0.00009999999999999999
  return 1 / Math.pow(10, n);
};
var getRoundFunc = function (v) {
  var p = v < 1 ? Math.pow(10, getDecimalPlace(v)) : 1;
  return function (n) {
    if (v === 0) {
      return 0;
    }
    return Math.round(Math.round(n / v) * v * p) / p;
  };
};
var getAngle = function (posX, posY) {
  return Math.atan2(posY, posX) * 180 / Math.PI;
};
var isCssPropsFromAxes = function (originalCssProps) {
  var same = true;
  Object.keys(PREVENT_DRAG_CSSPROPS).forEach(function (prop) {
    if (!originalCssProps || originalCssProps[prop] !== PREVENT_DRAG_CSSPROPS[prop]) {
      same = false;
    }
  });
  return same;
};
var getDirection = function (useHorizontal, useVertical) {
  if (useHorizontal && useVertical) {
    return DIRECTION_ALL;
  } else if (useHorizontal) {
    return DIRECTION_HORIZONTAL;
  } else if (useVertical) {
    return DIRECTION_VERTICAL;
  } else {
    return DIRECTION_NONE;
  }
};
var useDirection = function (checkType, direction, userDirection) {
  if (userDirection) {
    return !!(direction === DIRECTION_ALL || direction & checkType && userDirection & checkType);
  } else {
    return !!(direction & checkType);
  }
};
var setCssProps = function (element, option, direction) {
  var _a;
  var touchActionMap = (_a = {}, _a[DIRECTION_NONE] = "auto", _a[DIRECTION_ALL] = "none", _a[DIRECTION_VERTICAL] = "pan-x", _a[DIRECTION_HORIZONTAL] = "pan-y", _a);
  var oldCssProps = {};
  if (element && element.style) {
    var touchAction = option.touchAction ? option.touchAction : touchActionMap[direction];
    var newCssProps_1 = __assign(__assign({}, PREVENT_DRAG_CSSPROPS), {
      "touch-action": element.style["touch-action"] === "none" ? "none" : touchAction
    });
    Object.keys(newCssProps_1).forEach(function (prop) {
      oldCssProps[prop] = element.style[prop];
    });
    // Old style props like user-select can be corrupted if you change the style directly in the logic above.
    Object.keys(newCssProps_1).forEach(function (prop) {
      element.style[prop] = newCssProps_1[prop];
    });
  }
  return oldCssProps;
};
var revertCssProps = function (element, originalCssProps) {
  if (element && element.style && originalCssProps) {
    Object.keys(originalCssProps).forEach(function (prop) {
      element.style[prop] = originalCssProps[prop];
    });
  }
  return;
};

var EventManager = /*#__PURE__*/function () {
  function EventManager(_axes) {
    this._axes = _axes;
    this.holdingCount = 0;
  }
  /**
   * This event is fired when a user holds an element on the screen of the device.
   * @ko 사용자가 기기의 화면에 손을 대고 있을 때 발생하는 이벤트
   * @event Axes#hold
   * @type {object}
   * @property {Object.<string, number>} pos coordinate <ko>좌표 정보</ko>
   * @property {Object} input The instance of inputType where the event occurred<ko>이벤트가 발생한 inputType 인스턴스</ko>
   * @property {Object} inputEvent The event object received from inputType <ko>inputType으로 부터 받은 이벤트 객체</ko>
   * @property {Boolean} isTrusted Returns true if an event was generated by the user action, or false if it was caused by a script or API call <ko>사용자의 액션에 의해 이벤트가 발생하였으면 true, 스크립트나 API호출에 의해 발생하였을 경우에는 false를 반환한다.</ko>
   *
   * @example
   * ```js
   * const axes = new eg.Axes({
   *   "x": {
   *      range: [0, 100]
   *   },
   *   "zoom": {
   *      range: [50, 30]
   *   }
   * }).on("hold", function(event) {
   *   // event.pos
   *   // event.input
   *   // event.inputEvent
   *   // isTrusted
   * });
   * ```
   */
  var __proto = EventManager.prototype;
  __proto.hold = function (pos, option) {
    var roundPos = this._getRoundPos(pos).roundPos;
    this._axes.trigger(new ComponentEvent$1("hold", {
      pos: roundPos,
      input: option.input || null,
      inputEvent: option.event || null,
      isTrusted: true
    }));
  };
  /**
   * Specifies the coordinates to move after the 'change' event. It works when the holding value of the change event is true.
   * @ko 'change' 이벤트 이후 이동할 좌표를 지정한다. change이벤트의 holding 값이 true일 경우에 동작한다
   * @param {Object.<string, number>} pos The coordinate to move to <ko>이동할 좌표</ko>
   * @example
   * ```js
   * const axes = new eg.Axes({
   *   "x": {
   *      range: [0, 100]
   *   },
   *   "zoom": {
   *      range: [50, 30]
   *   }
   * }).on("change", function(event) {
   *   event.holding && event.set({x: 10});
   * });
   * ```
   */
  /** Specifies the animation coordinates to move after the 'release' or 'animationStart' events.
   * @ko 'release' 또는 'animationStart' 이벤트 이후 이동할 좌표를 지정한다.
   * @param {Object.<string, number>} pos The coordinate to move to <ko>이동할 좌표</ko>
   * @param {Number} [duration=0] Duration of the animation (unit: ms) <ko>애니메이션 진행 시간(단위: ms)</ko>
   * @example
   * ```js
   * const axes = new eg.Axes({
   *   "x": {
   *      range: [0, 100]
   *   },
   *   "zoom": {
   *      range: [50, 30]
   *   }
   * }).on("animationStart", function(event) {
   *   event.setTo({x: 10}, 2000);
   * });
   * ```
   */
  /**
   * This event is fired when a user release an element on the screen of the device.
   * @ko 사용자가 기기의 화면에서 손을 뗐을 때 발생하는 이벤트
   * @event Axes#release
   * @type {object}
   * @property {Object.<string, number>} depaPos The coordinates when releasing an element<ko>손을 뗐을 때의 좌표 </ko>
   * @property {Object.<string, number>} destPos The coordinates to move to after releasing an element<ko>손을 뗀 뒤에 이동할 좌표</ko>
   * @property {Object.<string, number>} delta  The movement variation of coordinate <ko>좌표의 변화량</ko>
   * @property {Object.<string, number>} bounceRatio If the coordinates at the time of release are in the bounce area, the current bounce value divided by the maximum bounce value <ko>손을 뗐을 때의 좌표가 bounce 영역에 있는 경우 현재 bounce된 값을 최대 bounce 값으로 나눈 수치.</ko>
   * @property {Object} inputEvent The event object received from inputType <ko>inputType으로 부터 받은 이벤트 객체</ko>
   * @property {Object} input The instance of inputType where the event occurred<ko>이벤트가 발생한 inputType 인스턴스</ko>
   * @property {setTo} setTo Specifies the animation coordinates to move after the event <ko>이벤트 이후 이동할 애니메이션 좌표를 지정한다</ko>
   * @property {Boolean} isTrusted Returns true if an event was generated by the user action, or false if it was caused by a script or API call <ko>사용자의 액션에 의해 이벤트가 발생하였으면 true, 스크립트나 API호출에 의해 발생하였을 경우에는 false를 반환한다.</ko>
   *
   * @example
   * ```js
   * const axes = new eg.Axes({
   *   "x": {
   *      range: [0, 100]
   *   },
   *   "zoom": {
   *      range: [50, 30]
   *   }
   * }).on("release", function(event) {
   *   // event.depaPos
   *   // event.destPos
   *   // event.delta
   *   // event.input
   *   // event.inputEvent
   *   // event.setTo
   *   // event.isTrusted
   *
   *   // if you want to change the animation coordinates to move after the 'release' event.
   *   event.setTo({x: 10}, 2000);
   * });
   * ```
   */
  __proto.triggerRelease = function (param) {
    var _a = this._getRoundPos(param.destPos, param.depaPos),
      roundPos = _a.roundPos,
      roundDepa = _a.roundDepa;
    param.destPos = roundPos;
    param.depaPos = roundDepa;
    param.setTo = this._createUserControll(param.destPos, param.duration);
    this._axes.trigger(new ComponentEvent$1("release", __assign(__assign({}, param), {
      bounceRatio: this._getBounceRatio(roundPos)
    })));
  };
  /**
   * This event is fired when coordinate changes.
   * @ko 좌표가 변경됐을 때 발생하는 이벤트
   * @event Axes#change
   * @type {object}
   * @property {Object.<string, number>} pos  The coordinate <ko>좌표</ko>
   * @property {Object.<string, number>} delta  The movement variation of coordinate <ko>좌표의 변화량</ko>
   * @property {Object.<string, number>} bounceRatio If the current coordinates are in the bounce area, the current bounce value divided by the maximum bounce value <ko>현재 좌표가 bounce 영역에 있는 경우 현재 bounce된 값을 최대 bounce 값으로 나눈 수치.</ko>
   * @property {Boolean} holding Indicates whether a user holds an element on the screen of the device.<ko>사용자가 기기의 화면을 누르고 있는지 여부</ko>
   * @property {Object} input The instance of inputType where the event occurred. If the value is changed by animation, it returns 'null'.<ko>이벤트가 발생한 inputType 인스턴스. 애니메이션에 의해 값이 변경될 경우에는 'null'을 반환한다.</ko>
   * @property {Object} inputEvent The event object received from inputType. If the value is changed by animation, it returns 'null'.<ko>inputType으로 부터 받은 이벤트 객체. 애니메이션에 의해 값이 변경될 경우에는 'null'을 반환한다.</ko>
   * @property {set} set Specifies the coordinates to move after the event. It works when the holding value is true <ko>이벤트 이후 이동할 좌표를 지정한다. holding 값이 true일 경우에 동작한다.</ko>
   * @property {Boolean} isTrusted Returns true if an event was generated by the user action, or false if it was caused by a script or API call <ko>사용자의 액션에 의해 이벤트가 발생하였으면 true, 스크립트나 API호출에 의해 발생하였을 경우에는 false를 반환한다.</ko>
   *
   * @example
   * ```js
   * const axes = new eg.Axes({
   *   "x": {
   *      range: [0, 100]
   *   },
   *   "zoom": {
   *      range: [50, 30]
   *   }
   * }).on("change", function(event) {
   *   // event.pos
   *   // event.delta
   *   // event.input
   *   // event.inputEvent
   *   // event.holding
   *   // event.set
   *   // event.isTrusted
   *
   *   // if you want to change the coordinates to move after the 'change' event.
   *   // it works when the holding value of the change event is true.
   *   event.holding && event.set({x: 10});
   * });
   * ```
   */
  __proto.triggerChange = function (pos, depaPos, option, holding) {
    var _this = this;
    if (holding === void 0) {
      holding = false;
    }
    var animationManager = this.animationManager;
    var axisManager = animationManager.axisManager;
    var eventInfo = animationManager.getEventInfo();
    var _a = this._getRoundPos(pos, depaPos),
      roundPos = _a.roundPos,
      roundDepa = _a.roundDepa;
    var moveTo = axisManager.moveTo(roundPos, roundDepa);
    var inputEvent = (option === null || option === void 0 ? void 0 : option.event) || (eventInfo === null || eventInfo === void 0 ? void 0 : eventInfo.event) || null;
    var param = {
      pos: moveTo.pos,
      delta: moveTo.delta,
      bounceRatio: this._getBounceRatio(moveTo.pos),
      holding: holding,
      inputEvent: inputEvent,
      isTrusted: !!inputEvent,
      input: (option === null || option === void 0 ? void 0 : option.input) || (eventInfo === null || eventInfo === void 0 ? void 0 : eventInfo.input) || null,
      set: inputEvent ? this._createUserControll(moveTo.pos) : function () {} // eslint-disable-line @typescript-eslint/no-empty-function
    };

    var event = new ComponentEvent$1("change", param);
    this._axes.trigger(event);
    Object.keys(moveTo.pos).forEach(function (axis) {
      var p = moveTo.pos[axis];
      getObserver(_this._axes, axis, p).current = p;
    });
    if (inputEvent) {
      axisManager.set(param.set().destPos);
    }
    return !event.isCanceled();
  };
  /**
   * This event is fired when animation starts.
   * @ko 에니메이션이 시작할 때 발생한다.
   * @event Axes#animationStart
   * @type {object}
   * @property {Object.<string, number>} depaPos The coordinates when animation starts<ko>애니메이션이 시작 되었을 때의 좌표 </ko>
   * @property {Object.<string, number>} destPos The coordinates to move to. If you change this value, you can run the animation<ko>이동할 좌표. 이값을 변경하여 애니메이션을 동작시킬수 있다</ko>
   * @property {Object.<string, number>} delta  The movement variation of coordinate <ko>좌표의 변화량</ko>
   * @property {Number} duration Duration of the animation (unit: ms). If you change this value, you can control the animation duration time.<ko>애니메이션 진행 시간(단위: ms). 이값을 변경하여 애니메이션의 이동시간을 조절할 수 있다.</ko>
   * @property {Object} input The instance of inputType where the event occurred. If the value is changed by animation, it returns 'null'.<ko>이벤트가 발생한 inputType 인스턴스. 애니메이션에 의해 값이 변경될 경우에는 'null'을 반환한다.</ko>
   * @property {Object} inputEvent The event object received from inputType <ko>inputType으로 부터 받은 이벤트 객체</ko>
   * @property {setTo} setTo Specifies the animation coordinates to move after the event <ko>이벤트 이후 이동할 애니메이션 좌표를 지정한다</ko>
   * @property {Boolean} isTrusted Returns true if an event was generated by the user action, or false if it was caused by a script or API call <ko>사용자의 액션에 의해 이벤트가 발생하였으면 true, 스크립트나 API호출에 의해 발생하였을 경우에는 false를 반환한다.</ko>
   *
   * @example
   * ```js
   * const axes = new eg.Axes({
   *   "x": {
   *      range: [0, 100]
   *   },
   *   "zoom": {
   *      range: [50, 30]
   *   }
   * }).on("release", function(event) {
   *   // event.depaPos
   *   // event.destPos
   *   // event.delta
   *   // event.input
   *   // event.inputEvent
   *   // event.setTo
   *   // event.isTrusted
   *
   *   // if you want to change the animation coordinates to move after the 'animationStart' event.
   *   event.setTo({x: 10}, 2000);
   * });
   * ```
   */
  __proto.triggerAnimationStart = function (param) {
    var _a = this._getRoundPos(param.destPos, param.depaPos),
      roundPos = _a.roundPos,
      roundDepa = _a.roundDepa;
    param.destPos = roundPos;
    param.depaPos = roundDepa;
    param.setTo = this._createUserControll(param.destPos, param.duration);
    var event = new ComponentEvent$1("animationStart", param);
    this._axes.trigger(event);
    return !event.isCanceled();
  };
  /**
   * This event is fired when animation ends.
   * @ko 에니메이션이 끝났을 때 발생한다.
   * @event Axes#animationEnd
   * @type {object}
   * @property {Boolean} isTrusted Returns true if an event was generated by the user action, or false if it was caused by a script or API call <ko>사용자의 액션에 의해 이벤트가 발생하였으면 true, 스크립트나 API호출에 의해 발생하였을 경우에는 false를 반환한다.</ko>
   *
   * @example
   * ```js
   * const axes = new eg.Axes({
   *   "x": {
   *      range: [0, 100]
   *   },
   *   "zoom": {
   *      range: [50, 30]
   *   }
   * }).on("animationEnd", function(event) {
   *   // event.isTrusted
   * });
   * ```
   */
  __proto.triggerAnimationEnd = function (isTrusted) {
    if (isTrusted === void 0) {
      isTrusted = false;
    }
    this._axes.trigger(new ComponentEvent$1("animationEnd", {
      isTrusted: isTrusted
    }));
  };
  /**
   * This event is fired when all actions have been completed.
   * @ko 에니메이션이 끝났을 때 발생한다.
   * @event Axes#finish
   * @type {object}
   * @property {Boolean} isTrusted Returns true if an event was generated by the user action, or false if it was caused by a script or API call <ko>사용자의 액션에 의해 이벤트가 발생하였으면 true, 스크립트나 API호출에 의해 발생하였을 경우에는 false를 반환한다.</ko>
   *
   * @example
   * ```js
   * const axes = new eg.Axes({
   *   "x": {
   *      range: [0, 100]
   *   },
   *   "zoom": {
   *      range: [50, 30]
   *   }
   * }).on("finish", function(event) {
   *   // event.isTrusted
   * });
   * ```
   */
  __proto.triggerFinish = function (isTrusted) {
    if (isTrusted === void 0) {
      isTrusted = false;
    }
    this._axes.trigger(new ComponentEvent$1("finish", {
      isTrusted: isTrusted
    }));
  };
  __proto.setAnimationManager = function (animationManager) {
    this.animationManager = animationManager;
  };
  __proto.destroy = function () {
    this._axes.off();
  };
  __proto._createUserControll = function (pos, duration) {
    if (duration === void 0) {
      duration = 0;
    }
    // to controll
    var userControl = {
      destPos: __assign({}, pos),
      duration: duration
    };
    return function (toPos, userDuration) {
      if (toPos) {
        userControl.destPos = __assign({}, toPos);
      }
      if (userDuration !== undefined) {
        userControl.duration = userDuration;
      }
      return userControl;
    };
  };
  __proto._getRoundPos = function (pos, depaPos) {
    // round value if round exist
    var roundUnit = this._axes.options.round;
    // if (round == null) {
    //   return {pos, depaPos}; // undefined, undefined
    // }
    return {
      roundPos: roundNumbers(pos, roundUnit),
      roundDepa: roundNumbers(depaPos, roundUnit)
    };
  };
  __proto._getBounceRatio = function (pos) {
    return this._axes.axisManager.map(pos, function (v, opt) {
      if (v < opt.range[0] && opt.bounce[0] !== 0) {
        return (opt.range[0] - v) / opt.bounce[0];
      } else if (v > opt.range[1] && opt.bounce[1] !== 0) {
        return (v - opt.range[1]) / opt.bounce[1];
      } else {
        return 0;
      }
    });
  };
  __decorate([Observe], EventManager.prototype, "holdingCount", void 0);
  return EventManager;
}();

var InterruptManager = /*#__PURE__*/function () {
  function InterruptManager(_options) {
    this._options = _options;
    this._prevented = false; //  check whether the animation event was prevented
  }
  var __proto = InterruptManager.prototype;
  __proto.isInterrupting = function () {
    // when interruptable is 'true', return value is always 'true'.
    return this._options.interruptable || this._prevented;
  };
  __proto.isInterrupted = function () {
    return !this._options.interruptable && this._prevented;
  };
  __proto.setInterrupt = function (prevented) {
    if (!this._options.interruptable) {
      this._prevented = prevented;
    }
  };
  return InterruptManager;
}();

/*
 * Copyright (c) 2015 NAVER Corp.
 * egjs projects are licensed under the MIT license
 */
var getInsidePosition = function (destPos, range, circular, bounce) {
  var toDestPos = destPos;
  var targetRange = [circular[0] ? range[0] : bounce ? range[0] - bounce[0] : range[0], circular[1] ? range[1] : bounce ? range[1] + bounce[1] : range[1]];
  toDestPos = Math.max(targetRange[0], toDestPos);
  toDestPos = Math.min(targetRange[1], toDestPos);
  return toDestPos;
};
// determine outside
var isOutside = function (pos, range) {
  return pos < range[0] || pos > range[1];
};
// determine whether position has reached the maximum moveable area
var isEndofBounce = function (pos, range, bounce, circular) {
  return !circular[0] && pos === range[0] - bounce[0] || !circular[1] && pos === range[1] + bounce[1];
};
var getDuration = function (distance, deceleration) {
  var duration = Math.sqrt(distance / deceleration * 2);
  // when duration is under 100, then value is zero
  return duration < 100 ? 0 : duration;
};
var isCircularable = function (destPos, range, circular) {
  return circular[1] && destPos > range[1] || circular[0] && destPos < range[0];
};
var getCirculatedPos = function (pos, range, circular) {
  var toPos = pos;
  var min = range[0];
  var max = range[1];
  var length = max - min;
  if (circular[1] && pos > max) {
    // right
    toPos = (toPos - max) % length + min;
  }
  if (circular[0] && pos < min) {
    // left
    toPos = (toPos - min) % length + max;
  }
  return toPos;
};

var AxisManager = /*#__PURE__*/function () {
  function AxisManager(_axis) {
    var _this = this;
    this._axis = _axis;
    this._complementOptions();
    this._pos = Object.keys(this._axis).reduce(function (pos, v) {
      pos[v] = _this._axis[v].startPos;
      return pos;
    }, {});
  }
  var __proto = AxisManager.prototype;
  __proto.getDelta = function (depaPos, destPos) {
    var fullDepaPos = this.get(depaPos);
    return map(this.get(destPos), function (v, k) {
      return v - fullDepaPos[k];
    });
  };
  __proto.get = function (axes) {
    var _this = this;
    if (axes && Array.isArray(axes)) {
      return axes.reduce(function (acc, v) {
        if (v && v in _this._pos) {
          acc[v] = _this._pos[v];
        }
        return acc;
      }, {});
    } else {
      return __assign(__assign({}, this._pos), axes || {});
    }
  };
  __proto.moveTo = function (pos, depaPos) {
    if (depaPos === void 0) {
      depaPos = this._pos;
    }
    var delta = map(this._pos, function (v, key) {
      return key in pos && key in depaPos ? pos[key] - depaPos[key] : 0;
    });
    this.set(this.map(pos, function (v, opt) {
      return opt ? getCirculatedPos(v, opt.range, opt.circular) : 0;
    }));
    return {
      pos: __assign({}, this._pos),
      delta: delta
    };
  };
  __proto.set = function (pos) {
    for (var k in pos) {
      if (k && k in this._pos) {
        this._pos[k] = pos[k];
      }
    }
  };
  __proto.every = function (pos, callback) {
    var axisOptions = this._axis;
    return every(pos, function (value, key) {
      return callback(value, axisOptions[key], key);
    });
  };
  __proto.filter = function (pos, callback) {
    var axisOptions = this._axis;
    return filter(pos, function (value, key) {
      return callback(value, axisOptions[key], key);
    });
  };
  __proto.map = function (pos, callback) {
    var axisOptions = this._axis;
    return map(pos, function (value, key) {
      return callback(value, axisOptions[key], key);
    });
  };
  __proto.isOutside = function (axes) {
    return !this.every(axes ? this.get(axes) : this._pos, function (v, opt) {
      return !isOutside(v, opt.range);
    });
  };
  __proto.getAxisOptions = function (key) {
    return this._axis[key];
  };
  __proto.setAxis = function (axis) {
    var _this = this;
    Object.keys(axis).forEach(function (key) {
      if (!_this._axis[key]) {
        throw new Error("Axis ".concat(key, " does not exist in Axes instance"));
      }
      _this._axis[key] = __assign(__assign({}, _this._axis[key]), axis[key]);
    });
    this._complementOptions();
  };
  /**
   * set up 'css' expression
   * @private
   */
  __proto._complementOptions = function () {
    var _this = this;
    Object.keys(this._axis).forEach(function (axis) {
      _this._axis[axis] = __assign({
        range: [0, 100],
        startPos: _this._axis[axis].range[0],
        bounce: [0, 0],
        circular: [false, false]
      }, _this._axis[axis]);
      ["bounce", "circular"].forEach(function (v) {
        var axisOption = _this._axis;
        var key = axisOption[axis][v];
        if (/string|number|boolean/.test(typeof key)) {
          axisOption[axis][v] = [key, key];
        }
      });
    });
  };
  return AxisManager;
}();

var SUPPORT_TOUCH = ("ontouchstart" in win);
var SUPPORT_POINTER = ("PointerEvent" in win);
var SUPPORT_MSPOINTER = ("MSPointerEvent" in win);
var SUPPORT_POINTER_EVENTS = SUPPORT_POINTER || SUPPORT_MSPOINTER;
var isValidKey = function (event, inputKey) {
  if (!inputKey || inputKey.indexOf(ANY) > -1 || inputKey.indexOf(NONE) > -1 && !event.shiftKey && !event.ctrlKey && !event.altKey && !event.metaKey || inputKey.indexOf(SHIFT) > -1 && event.shiftKey || inputKey.indexOf(CTRL) > -1 && event.ctrlKey || inputKey.indexOf(ALT) > -1 && event.altKey || inputKey.indexOf(META) > -1 && event.metaKey) {
    return true;
  }
  return false;
};
var EventInput = /*#__PURE__*/function () {
  function EventInput() {
    var _this = this;
    this._stopContextMenu = function (event) {
      event.preventDefault();
      win.removeEventListener("contextmenu", _this._stopContextMenu);
    };
  }
  var __proto = EventInput.prototype;
  __proto.extendEvent = function (event) {
    var _a;
    var prevEvent = this.prevEvent;
    var center = this._getCenter(event);
    var movement = prevEvent ? this._getMovement(event) : {
      x: 0,
      y: 0
    };
    var scale = prevEvent ? this._getScale(event) : 1;
    var angle = prevEvent ? getAngle(center.x - prevEvent.center.x, center.y - prevEvent.center.y) : 0;
    var deltaX = prevEvent ? prevEvent.deltaX + movement.x : movement.x;
    var deltaY = prevEvent ? prevEvent.deltaY + movement.y : movement.y;
    var offsetX = movement.x;
    var offsetY = movement.y;
    var latestInterval = this._latestInterval;
    var timeStamp = Date.now();
    var deltaTime = latestInterval ? timeStamp - latestInterval.timestamp : 0;
    var velocityX = prevEvent ? prevEvent.velocityX : 0;
    var velocityY = prevEvent ? prevEvent.velocityY : 0;
    if (!latestInterval || deltaTime >= VELOCITY_INTERVAL) {
      if (latestInterval) {
        _a = [(deltaX - latestInterval.deltaX) / deltaTime, (deltaY - latestInterval.deltaY) / deltaTime], velocityX = _a[0], velocityY = _a[1];
      }
      this._latestInterval = {
        timestamp: timeStamp,
        deltaX: deltaX,
        deltaY: deltaY
      };
    }
    return {
      srcEvent: event,
      scale: scale,
      angle: angle,
      center: center,
      deltaX: deltaX,
      deltaY: deltaY,
      offsetX: offsetX,
      offsetY: offsetY,
      velocityX: velocityX,
      velocityY: velocityY,
      preventSystemEvent: true
    };
  };
  __proto._getDistance = function (start, end) {
    var x = end.clientX - start.clientX;
    var y = end.clientY - start.clientY;
    return Math.sqrt(x * x + y * y);
  };
  __proto._getButton = function (event) {
    var buttonCodeMap = {
      1: MOUSE_LEFT,
      2: MOUSE_RIGHT,
      4: MOUSE_MIDDLE
    };
    var button = this._isTouchEvent(event) ? MOUSE_LEFT : buttonCodeMap[event.buttons];
    return button ? button : null;
  };
  __proto._isTouchEvent = function (event) {
    return event.type && event.type.indexOf("touch") > -1;
  };
  __proto._isValidButton = function (button, inputButton) {
    return inputButton.indexOf(button) > -1;
  };
  __proto._isValidEvent = function (event, inputKey, inputButton) {
    return (!inputKey || isValidKey(event, inputKey)) && (!inputButton || this._isValidButton(this._getButton(event), inputButton));
  };
  __proto._preventMouseButton = function (event, button) {
    if (button === MOUSE_RIGHT) {
      win.addEventListener("contextmenu", this._stopContextMenu);
    } else if (button === MOUSE_MIDDLE) {
      event.preventDefault();
    }
  };
  return EventInput;
}();

var MouseEventInput = /*#__PURE__*/function (_super) {
  __extends$1(MouseEventInput, _super);
  function MouseEventInput() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.start = ["mousedown"];
    _this.move = ["mousemove"];
    _this.end = ["mouseup"];
    return _this;
  }
  var __proto = MouseEventInput.prototype;
  __proto.onEventStart = function (event, inputKey, inputButton) {
    var button = this._getButton(event);
    if (!this._isValidEvent(event, inputKey, inputButton)) {
      return null;
    }
    this._preventMouseButton(event, button);
    return this.extendEvent(event);
  };
  __proto.onEventMove = function (event, inputKey, inputButton) {
    if (!this._isValidEvent(event, inputKey, inputButton)) {
      return null;
    }
    return this.extendEvent(event);
  };
  __proto.onEventEnd = function () {
    return;
  };
  __proto.onRelease = function () {
    this.prevEvent = null;
    return;
  };
  __proto.getTouches = function (event, inputButton) {
    if (inputButton) {
      return this._isValidButton(MOUSE_BUTTON_CODE_MAP[event.which], inputButton) && this.end.indexOf(event.type) === -1 ? 1 : 0;
    }
    return 0;
  };
  __proto._getScale = function () {
    return 1;
  };
  __proto._getCenter = function (event) {
    return {
      x: event.clientX,
      y: event.clientY
    };
  };
  __proto._getMovement = function (event) {
    var prev = this.prevEvent.srcEvent;
    return {
      x: event.clientX - prev.clientX,
      y: event.clientY - prev.clientY
    };
  };
  return MouseEventInput;
}(EventInput);

var TouchEventInput = /*#__PURE__*/function (_super) {
  __extends$1(TouchEventInput, _super);
  function TouchEventInput() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.start = ["touchstart"];
    _this.move = ["touchmove"];
    _this.end = ["touchend", "touchcancel"];
    return _this;
  }
  var __proto = TouchEventInput.prototype;
  __proto.onEventStart = function (event, inputKey) {
    this._baseTouches = event.touches;
    if (!this._isValidEvent(event, inputKey)) {
      return null;
    }
    return this.extendEvent(event);
  };
  __proto.onEventMove = function (event, inputKey) {
    if (!this._isValidEvent(event, inputKey)) {
      return null;
    }
    return this.extendEvent(event);
  };
  __proto.onEventEnd = function (event) {
    this._baseTouches = event.touches;
    return;
  };
  __proto.onRelease = function () {
    this.prevEvent = null;
    this._baseTouches = null;
    return;
  };
  __proto.getTouches = function (event) {
    return event.touches.length;
  };
  __proto._getScale = function (event) {
    if (event.touches.length !== 2 || this._baseTouches.length < 2) {
      return null; // TODO: consider calculating non-pinch gesture scale
    }

    return this._getDistance(event.touches[0], event.touches[1]) / this._getDistance(this._baseTouches[0], this._baseTouches[1]);
  };
  __proto._getCenter = function (event) {
    return {
      x: event.touches[0].clientX,
      y: event.touches[0].clientY
    };
  };
  __proto._getMovement = function (event) {
    var prev = this.prevEvent.srcEvent;
    if (event.touches[0].identifier !== prev.touches[0].identifier) {
      return {
        x: 0,
        y: 0
      };
    }
    return {
      x: event.touches[0].clientX - prev.touches[0].clientX,
      y: event.touches[0].clientY - prev.touches[0].clientY
    };
  };
  return TouchEventInput;
}(EventInput);

var PointerEventInput = /*#__PURE__*/function (_super) {
  __extends$1(PointerEventInput, _super);
  function PointerEventInput() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.start = SUPPORT_POINTER ? ["pointerdown"] : ["MSPointerDown"];
    _this.move = SUPPORT_POINTER ? ["pointermove"] : ["MSPointerMove"];
    _this.end = SUPPORT_POINTER ? ["pointerup", "pointercancel"] : ["MSPointerUp", "MSPointerCancel"];
    // store first, recent inputs for each event id
    _this._firstInputs = [];
    _this._recentInputs = [];
    return _this;
  }
  var __proto = PointerEventInput.prototype;
  __proto.onEventStart = function (event, inputKey, inputButton) {
    var button = this._getButton(event);
    if (!this._isValidEvent(event, inputKey, inputButton)) {
      return null;
    }
    this._preventMouseButton(event, button);
    this._updatePointerEvent(event);
    return this.extendEvent(event);
  };
  __proto.onEventMove = function (event, inputKey, inputButton) {
    if (!this._isValidEvent(event, inputKey, inputButton)) {
      return null;
    }
    this._updatePointerEvent(event);
    return this.extendEvent(event);
  };
  __proto.onEventEnd = function (event) {
    this._removePointerEvent(event);
  };
  __proto.onRelease = function () {
    this.prevEvent = null;
    this._firstInputs = [];
    this._recentInputs = [];
    return;
  };
  __proto.getTouches = function () {
    return this._recentInputs.length;
  };
  __proto._getScale = function () {
    if (this._recentInputs.length !== 2) {
      return null; // TODO: consider calculating non-pinch gesture scale
    }

    return this._getDistance(this._recentInputs[0], this._recentInputs[1]) / this._getDistance(this._firstInputs[0], this._firstInputs[1]);
  };
  __proto._getCenter = function (event) {
    return {
      x: event.clientX,
      y: event.clientY
    };
  };
  __proto._getMovement = function (event) {
    var prev = this.prevEvent.srcEvent;
    if (event.pointerId !== prev.pointerId) {
      return {
        x: 0,
        y: 0
      };
    }
    return {
      x: event.clientX - prev.clientX,
      y: event.clientY - prev.clientY
    };
  };
  __proto._updatePointerEvent = function (event) {
    var _this = this;
    var addFlag = false;
    this._recentInputs.forEach(function (e, i) {
      if (e.pointerId === event.pointerId) {
        addFlag = true;
        _this._recentInputs[i] = event;
      }
    });
    if (!addFlag) {
      this._firstInputs.push(event);
      this._recentInputs.push(event);
    }
  };
  __proto._removePointerEvent = function (event) {
    this._firstInputs = this._firstInputs.filter(function (x) {
      return x.pointerId !== event.pointerId;
    });
    this._recentInputs = this._recentInputs.filter(function (x) {
      return x.pointerId !== event.pointerId;
    });
  };
  return PointerEventInput;
}(EventInput);

var TouchMouseEventInput = /*#__PURE__*/function (_super) {
  __extends$1(TouchMouseEventInput, _super);
  function TouchMouseEventInput() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.start = ["mousedown", "touchstart"];
    _this.move = ["mousemove", "touchmove"];
    _this.end = ["mouseup", "touchend", "touchcancel"];
    return _this;
  }
  var __proto = TouchMouseEventInput.prototype;
  __proto.onEventStart = function (event, inputKey, inputButton) {
    var button = this._getButton(event);
    if (this._isTouchEvent(event)) {
      this._baseTouches = event.touches;
    }
    if (!this._isValidEvent(event, inputKey, inputButton)) {
      return null;
    }
    this._preventMouseButton(event, button);
    return this.extendEvent(event);
  };
  __proto.onEventMove = function (event, inputKey, inputButton) {
    if (!this._isValidEvent(event, inputKey, inputButton)) {
      return null;
    }
    return this.extendEvent(event);
  };
  __proto.onEventEnd = function (event) {
    if (this._isTouchEvent(event)) {
      this._baseTouches = event.touches;
    }
    return;
  };
  __proto.onRelease = function () {
    this.prevEvent = null;
    this._baseTouches = null;
    return;
  };
  __proto.getTouches = function (event, inputButton) {
    if (this._isTouchEvent(event)) {
      return event.touches.length;
    } else {
      return this._isValidButton(MOUSE_BUTTON_CODE_MAP[event.which], inputButton) && this.end.indexOf(event.type) === -1 ? 1 : 0;
    }
  };
  __proto._getScale = function (event) {
    if (this._isTouchEvent(event)) {
      if (event.touches.length !== 2 || this._baseTouches.length < 2) {
        return 1; // TODO: consider calculating non-pinch gesture scale
      }

      return this._getDistance(event.touches[0], event.touches[1]) / this._getDistance(this._baseTouches[0], this._baseTouches[1]);
    }
    return this.prevEvent.scale;
  };
  __proto._getCenter = function (event) {
    if (this._isTouchEvent(event)) {
      return {
        x: event.touches[0].clientX,
        y: event.touches[0].clientY
      };
    }
    return {
      x: event.clientX,
      y: event.clientY
    };
  };
  __proto._getMovement = function (event) {
    var _this = this;
    var prev = this.prevEvent.srcEvent;
    var _a = [event, prev].map(function (e) {
        if (_this._isTouchEvent(e)) {
          return {
            id: e.touches[0].identifier,
            x: e.touches[0].clientX,
            y: e.touches[0].clientY
          };
        }
        return {
          id: null,
          x: e.clientX,
          y: e.clientY
        };
      }),
      nextSpot = _a[0],
      prevSpot = _a[1];
    return nextSpot.id === prevSpot.id ? {
      x: nextSpot.x - prevSpot.x,
      y: nextSpot.y - prevSpot.y
    } : {
      x: 0,
      y: 0
    };
  };
  return TouchMouseEventInput;
}(EventInput);

var toAxis = function (source, offset) {
  return offset.reduce(function (acc, v, i) {
    if (source[i]) {
      acc[source[i]] = v;
    }
    return acc;
  }, {});
};
var convertInputType = function (inputType) {
  if (inputType === void 0) {
    inputType = [];
  }
  var hasTouch = false;
  var hasMouse = false;
  var hasPointer = false;
  inputType.forEach(function (v) {
    switch (v) {
      case "mouse":
        hasMouse = true;
        break;
      case "touch":
        hasTouch = SUPPORT_TOUCH;
        break;
      case "pointer":
        hasPointer = SUPPORT_POINTER_EVENTS;
      // no default
    }
  });

  if (hasPointer) {
    return new PointerEventInput();
  } else if (hasTouch && hasMouse) {
    return new TouchMouseEventInput();
  } else if (hasTouch) {
    return new TouchEventInput();
  } else if (hasMouse) {
    return new MouseEventInput();
  }
  return null;
};
function getAddEventOptions(eventName) {
  // The passive default value of the touch event is true.
  // If not a touch event, return false to support ie11
  return eventName.indexOf("touch") > -1 ? {
    passive: false
  } : false;
}

var InputObserver = /*#__PURE__*/function () {
  function InputObserver(_a) {
    var options = _a.options,
      interruptManager = _a.interruptManager,
      eventManager = _a.eventManager,
      axisManager = _a.axisManager,
      animationManager = _a.animationManager;
    this._isOutside = false;
    this._moveDistance = null;
    this._isStopped = false;
    this.options = options;
    this._interruptManager = interruptManager;
    this._eventManager = eventManager;
    this._axisManager = axisManager;
    this._animationManager = animationManager;
  }
  var __proto = InputObserver.prototype;
  __proto.get = function (input) {
    return this._axisManager.get(input.axes);
  };
  __proto.hold = function (input, event) {
    if (this._interruptManager.isInterrupted() || !input.axes.length) {
      return;
    }
    var changeOption = {
      input: input,
      event: event
    };
    this._isStopped = false;
    this._interruptManager.setInterrupt(true);
    this._animationManager.stopAnimation(changeOption);
    ++this._eventManager.holdingCount;
    if (!this._moveDistance) {
      this._eventManager.hold(this._axisManager.get(), changeOption);
    }
    this._isOutside = this._axisManager.isOutside(input.axes);
    this._moveDistance = this._axisManager.get(input.axes);
  };
  __proto.change = function (input, event, offset, useAnimation) {
    if (this._isStopped || !this._interruptManager.isInterrupting() || this._axisManager.every(offset, function (v) {
      return v === 0;
    })) {
      return;
    }
    var nativeEvent = event.srcEvent ? event.srcEvent : event;
    if (nativeEvent.__childrenAxesAlreadyChanged) {
      return;
    }
    var depaPos = this._moveDistance || this._axisManager.get(input.axes);
    var destPos;
    // for outside logic
    destPos = map(depaPos, function (v, k) {
      return v + (offset[k] || 0);
    });
    if (this._moveDistance) {
      this._moveDistance = this._axisManager.map(destPos, function (v, _a) {
        var circular = _a.circular,
          range = _a.range;
        return circular && (circular[0] || circular[1]) ? getCirculatedPos(v, range, circular) : v;
      });
    }
    // from outside to inside
    if (this._isOutside && this._axisManager.every(depaPos, function (v, opt) {
      return !isOutside(v, opt.range);
    })) {
      this._isOutside = false;
    }
    depaPos = this._atOutside(depaPos);
    destPos = this._atOutside(destPos);
    if (!this.options.nested || !this._isEndofAxis(offset, depaPos, destPos)) {
      nativeEvent.__childrenAxesAlreadyChanged = true;
    }
    var changeOption = {
      input: input,
      event: event
    };
    if (useAnimation) {
      var duration = this._animationManager.getDuration(destPos, depaPos);
      this._animationManager.animateTo(destPos, duration, changeOption);
    } else {
      var isCanceled = !this._eventManager.triggerChange(destPos, depaPos, changeOption, true);
      if (isCanceled) {
        this._isStopped = true;
        this._moveDistance = null;
        this._animationManager.finish(false);
      }
    }
  };
  __proto.release = function (input, event, velocity, inputDuration) {
    if (this._isStopped || !this._interruptManager.isInterrupting() || !this._moveDistance) {
      return;
    }
    var nativeEvent = event.srcEvent ? event.srcEvent : event;
    if (nativeEvent.__childrenAxesAlreadyReleased) {
      velocity = velocity.map(function () {
        return 0;
      });
    }
    var pos = this._axisManager.get(input.axes);
    var depaPos = this._axisManager.get();
    var displacement = this._animationManager.getDisplacement(velocity);
    var offset = toAxis(input.axes, displacement);
    var destPos = this._axisManager.get(this._axisManager.map(offset, function (v, opt, k) {
      if (opt.circular && (opt.circular[0] || opt.circular[1])) {
        return pos[k] + v;
      } else {
        return getInsidePosition(pos[k] + v, opt.range, opt.circular, opt.bounce);
      }
    }));
    nativeEvent.__childrenAxesAlreadyReleased = true;
    var duration = this._animationManager.getDuration(destPos, pos, inputDuration);
    if (duration === 0) {
      destPos = __assign({}, depaPos);
    }
    // prepare params
    var param = {
      depaPos: depaPos,
      destPos: destPos,
      duration: duration,
      delta: this._axisManager.getDelta(depaPos, destPos),
      inputEvent: event,
      input: input,
      isTrusted: true
    };
    --this._eventManager.holdingCount;
    this._eventManager.triggerRelease(param);
    if (this._eventManager.holdingCount === 0) {
      this._moveDistance = null;
    }
    // to contol
    var userWish = this._animationManager.getUserControl(param);
    var isEqual = equal(userWish.destPos, depaPos);
    var changeOption = {
      input: input,
      event: event
    };
    if (isEqual || userWish.duration === 0) {
      if (!isEqual) {
        this._eventManager.triggerChange(userWish.destPos, depaPos, changeOption, true);
      }
      this._interruptManager.setInterrupt(false);
      if (this._axisManager.isOutside()) {
        this._animationManager.restore(changeOption);
      } else {
        this._eventManager.triggerFinish(true);
      }
    } else {
      this._animationManager.animateTo(userWish.destPos, userWish.duration, changeOption);
    }
  };
  // when move pointer is held in outside
  __proto._atOutside = function (pos) {
    var _this = this;
    if (this._isOutside) {
      return this._axisManager.map(pos, function (v, opt) {
        var tn = opt.range[0] - opt.bounce[0];
        var tx = opt.range[1] + opt.bounce[1];
        return v > tx ? tx : v < tn ? tn : v;
      });
    } else {
      return this._axisManager.map(pos, function (v, opt) {
        var min = opt.range[0];
        var max = opt.range[1];
        var out = opt.bounce;
        var circular = opt.circular;
        if (circular[0] && v < min || circular[1] && v > max) {
          return v;
        } else if (v < min) {
          // left
          return min - _this._animationManager.interpolate(min - v, out[0]);
        } else if (v > max) {
          // right
          return max + _this._animationManager.interpolate(v - max, out[1]);
        }
        return v;
      });
    }
  };
  __proto._isEndofAxis = function (offset, depaPos, destPos) {
    return this._axisManager.every(depaPos, function (value, option, key) {
      return offset[key] === 0 || depaPos[key] === destPos[key] && isEndofBounce(value, option.range, option.bounce, option.circular);
    });
  };
  return InputObserver;
}();

var clamp = function (value, min, max) {
  return Math.max(Math.min(value, max), min);
};
var AnimationManager = /*#__PURE__*/function () {
  function AnimationManager(_a) {
    var options = _a.options,
      interruptManager = _a.interruptManager,
      eventManager = _a.eventManager,
      axisManager = _a.axisManager;
    this._options = options;
    this.interruptManager = interruptManager;
    this.eventManager = eventManager;
    this.axisManager = axisManager;
    this.animationEnd = this.animationEnd.bind(this);
  }
  var __proto = AnimationManager.prototype;
  __proto.getDuration = function (depaPos, destPos, wishDuration) {
    var _this = this;
    var duration;
    if (typeof wishDuration !== "undefined") {
      duration = wishDuration;
    } else {
      var durations_1 = map(destPos, function (v, k) {
        return getDuration(Math.abs(v - depaPos[k]), _this._options.deceleration);
      });
      duration = Object.keys(durations_1).reduce(function (max, v) {
        return Math.max(max, durations_1[v]);
      }, -Infinity);
    }
    return clamp(duration, this._options.minimumDuration, this._options.maximumDuration);
  };
  __proto.getDisplacement = function (velocity) {
    var totalVelocity = Math.pow(velocity.reduce(function (total, v) {
      return total + v * v;
    }, 0), 1 / velocity.length);
    var duration = Math.abs(totalVelocity / -this._options.deceleration);
    return velocity.map(function (v) {
      return v / 2 * duration;
    });
  };
  __proto.stopAnimation = function (option) {
    if (this._animateParam) {
      var orgPos_1 = this.axisManager.get();
      var pos = this.axisManager.map(orgPos_1, function (v, opt) {
        return getCirculatedPos(v, opt.range, opt.circular);
      });
      if (!every(pos, function (v, k) {
        return orgPos_1[k] === v;
      })) {
        this.eventManager.triggerChange(pos, orgPos_1, option, !!option);
      }
      this._animateParam = null;
      if (this._raf) {
        cancelAnimationFrame$1(this._raf);
      }
      this._raf = null;
      this.eventManager.triggerAnimationEnd(!!(option === null || option === void 0 ? void 0 : option.event));
    }
  };
  __proto.getEventInfo = function () {
    if (this._animateParam && this._animateParam.input && this._animateParam.inputEvent) {
      return {
        input: this._animateParam.input,
        event: this._animateParam.inputEvent
      };
    } else {
      return null;
    }
  };
  __proto.restore = function (option) {
    var pos = this.axisManager.get();
    var destPos = this.axisManager.map(pos, function (v, opt) {
      return Math.min(opt.range[1], Math.max(opt.range[0], v));
    });
    this.stopAnimation();
    this.animateTo(destPos, this.getDuration(pos, destPos), option);
  };
  __proto.animationEnd = function () {
    var beforeParam = this.getEventInfo();
    this._animateParam = null;
    // for Circular
    var circularTargets = this.axisManager.filter(this.axisManager.get(), function (v, opt) {
      return isCircularable(v, opt.range, opt.circular);
    });
    if (Object.keys(circularTargets).length > 0) {
      this.setTo(this.axisManager.map(circularTargets, function (v, opt) {
        return getCirculatedPos(v, opt.range, opt.circular);
      }));
    }
    this.interruptManager.setInterrupt(false);
    this.eventManager.triggerAnimationEnd(!!beforeParam);
    if (this.axisManager.isOutside()) {
      this.restore(beforeParam);
    } else {
      this.finish(!!beforeParam);
    }
  };
  __proto.finish = function (isTrusted) {
    this._animateParam = null;
    this.interruptManager.setInterrupt(false);
    this.eventManager.triggerFinish(isTrusted);
  };
  __proto.getUserControl = function (param) {
    var userWish = param.setTo();
    userWish.destPos = this.axisManager.get(userWish.destPos);
    userWish.duration = clamp(userWish.duration, this._options.minimumDuration, this._options.maximumDuration);
    return userWish;
  };
  __proto.animateTo = function (destPos, duration, option) {
    var _this = this;
    this.stopAnimation();
    var param = this._createAnimationParam(destPos, duration, option);
    var depaPos = __assign({}, param.depaPos);
    var retTrigger = this.eventManager.triggerAnimationStart(param);
    // to control
    var userWish = this.getUserControl(param);
    // You can't stop the 'animationStart' event when 'circular' is true.
    if (!retTrigger && this.axisManager.every(userWish.destPos, function (v, opt) {
      return isCircularable(v, opt.range, opt.circular);
    })) {
      console.warn("You can't stop the 'animation' event when 'circular' is true.");
    }
    if (retTrigger && !equal(userWish.destPos, depaPos)) {
      var inputEvent = (option === null || option === void 0 ? void 0 : option.event) || null;
      this._animateLoop({
        depaPos: depaPos,
        destPos: userWish.destPos,
        duration: userWish.duration,
        delta: this.axisManager.getDelta(depaPos, userWish.destPos),
        isTrusted: !!inputEvent,
        inputEvent: inputEvent,
        input: (option === null || option === void 0 ? void 0 : option.input) || null
      }, function () {
        return _this.animationEnd();
      });
    }
  };
  __proto.setTo = function (pos, duration) {
    if (duration === void 0) {
      duration = 0;
    }
    var axes = Object.keys(pos);
    var orgPos = this.axisManager.get(axes);
    if (equal(pos, orgPos)) {
      return this;
    }
    this.interruptManager.setInterrupt(true);
    var movedPos = filter(pos, function (v, k) {
      return orgPos[k] !== v;
    });
    if (!Object.keys(movedPos).length) {
      return this;
    }
    movedPos = this.axisManager.map(movedPos, function (v, opt) {
      var range = opt.range,
        circular = opt.circular;
      if (circular && (circular[0] || circular[1])) {
        return v;
      } else {
        return getInsidePosition(v, range, circular);
      }
    });
    if (equal(movedPos, orgPos)) {
      return this;
    }
    if (duration > 0) {
      this.animateTo(movedPos, duration);
    } else {
      this.stopAnimation();
      this.eventManager.triggerChange(movedPos);
      this.finish(false);
    }
    return this;
  };
  __proto.setBy = function (pos, duration) {
    if (duration === void 0) {
      duration = 0;
    }
    return this.setTo(map(this.axisManager.get(Object.keys(pos)), function (v, k) {
      return v + pos[k];
    }), duration);
  };
  __proto.setOptions = function (options) {
    this._options = __assign(__assign({}, this._options), options);
  };
  __proto._createAnimationParam = function (pos, duration, option) {
    var depaPos = this.axisManager.get();
    var destPos = pos;
    var inputEvent = (option === null || option === void 0 ? void 0 : option.event) || null;
    return {
      depaPos: depaPos,
      destPos: destPos,
      duration: clamp(duration, this._options.minimumDuration, this._options.maximumDuration),
      delta: this.axisManager.getDelta(depaPos, destPos),
      inputEvent: inputEvent,
      input: (option === null || option === void 0 ? void 0 : option.input) || null,
      isTrusted: !!inputEvent,
      done: this.animationEnd
    };
  };
  __proto._animateLoop = function (param, complete) {
    var _this = this;
    if (param.duration) {
      this._animateParam = __assign(__assign({}, param), {
        startTime: new Date().getTime()
      });
      var originalIntendedPos_1 = map(param.destPos, function (v) {
        return v;
      });
      var state_1 = this._initState(this._animateParam);
      var loop_1 = function () {
        _this._raf = null;
        var animateParam = _this._animateParam;
        var nextState = _this._getNextState(state_1);
        var isCanceled = !_this.eventManager.triggerChange(nextState.pos, state_1.pos);
        state_1 = nextState;
        if (nextState.finished) {
          animateParam.destPos = _this._getFinalPos(animateParam.destPos, originalIntendedPos_1);
          if (!equal(animateParam.destPos, _this.axisManager.get(Object.keys(animateParam.destPos)))) {
            _this.eventManager.triggerChange(animateParam.destPos, nextState.pos);
          }
          complete();
          return;
        } else if (isCanceled) {
          _this.finish(false);
        } else {
          _this._raf = requestAnimationFrame$1(loop_1);
        }
      };
      loop_1();
    } else {
      this.eventManager.triggerChange(param.destPos);
      complete();
    }
  };
  /**
   * Get estimated final value.
   *
   * If destPos is within the 'error range' of the original intended position, the initial intended position is returned.
   *   - eg. original intended pos: 100, destPos: 100.0000000004 ==> return 100;
   * If dest Pos is outside the 'range of error' compared to the originally intended pos, it is returned rounded based on the originally intended pos.
   *   - eg. original intended pos: 100.123 destPos: 50.12345 => return 50.123
   * @param originalIntendedPos
   * @param destPos
   */
  __proto._getFinalPos = function (destPos, originalIntendedPos) {
    var _this = this;
    // compare destPos and originalIntendedPos
    // eslint-disable-next-line @typescript-eslint/naming-convention
    var ERROR_LIMIT = 0.000001;
    var finalPos = map(destPos, function (value, key) {
      if (value >= originalIntendedPos[key] - ERROR_LIMIT && value <= originalIntendedPos[key] + ERROR_LIMIT) {
        // In error range, return original intended
        return originalIntendedPos[key];
      } else {
        // Out of error range, return rounded pos.
        var roundUnit = _this._getRoundUnit(value, key);
        var result = roundNumber(value, roundUnit);
        return result;
      }
    });
    return finalPos;
  };
  __proto._getRoundUnit = function (val, key) {
    var roundUnit = this._options.round; // manual mode
    var minRoundUnit = null; // auto mode
    // auto mode
    if (!roundUnit) {
      // Get minimum round unit
      var options = this.axisManager.getAxisOptions(key);
      minRoundUnit = inversePow(Math.max(getDecimalPlace(options.range[0]), getDecimalPlace(options.range[1]), getDecimalPlace(val)));
    }
    return minRoundUnit || roundUnit;
  };
  return AnimationManager;
}();

var EasingManager = /*#__PURE__*/function (_super) {
  __extends$1(EasingManager, _super);
  function EasingManager() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._useDuration = true;
    return _this;
  }
  var __proto = EasingManager.prototype;
  __proto.interpolate = function (displacement, threshold) {
    var initSlope = this._easing(0.00001) / 0.00001;
    return this._easing(displacement / (threshold * initSlope)) * threshold;
  };
  __proto.updateAnimation = function (options) {
    var _a;
    var animateParam = this._animateParam;
    if (!animateParam) {
      return;
    }
    var diffTime = new Date().getTime() - animateParam.startTime;
    var pos = (options === null || options === void 0 ? void 0 : options.destPos) || animateParam.destPos;
    var duration = (_a = options === null || options === void 0 ? void 0 : options.duration) !== null && _a !== void 0 ? _a : animateParam.duration;
    if ((options === null || options === void 0 ? void 0 : options.restart) || duration <= diffTime) {
      this.setTo(pos, duration - diffTime);
      return;
    }
    if (options === null || options === void 0 ? void 0 : options.destPos) {
      var currentPos = this.axisManager.get();
      // When destination is changed, new delta should be calculated as remaining percent.
      // For example, moving x:0, y:0 to x:200, y:200 and it has current easing percent of 92%. coordinate is x:184 and y:184
      // If destination changes to x:300, y:300. xdelta:200, ydelta:200 changes to xdelta:116, ydelta:116 and use remaining easingPer as 100%, not 8% as previous.
      // Therefore, original easingPer by time is kept. And divided by (1 - self._initialEasingPer) which means new total easing percent. Like calculating 8% as 100%.
      this._initialEasingPer = this._prevEasingPer;
      animateParam.delta = this.axisManager.getDelta(currentPos, pos);
      animateParam.destPos = pos;
    }
    if (options === null || options === void 0 ? void 0 : options.duration) {
      var ratio = (diffTime + this._durationOffset) / animateParam.duration;
      // Use durationOffset for keeping animation ratio after duration is changed.
      // newRatio = (diffTime + newDurationOffset) / newDuration = oldRatio
      // newDurationOffset = oldRatio * newDuration - diffTime
      this._durationOffset = ratio * duration - diffTime;
      animateParam.duration = duration;
    }
  };
  __proto._initState = function (info) {
    this._initialEasingPer = 0;
    this._prevEasingPer = 0;
    this._durationOffset = 0;
    return {
      pos: info.depaPos,
      easingPer: 0,
      finished: false
    };
  };
  __proto._getNextState = function (prevState) {
    var _this = this;
    var animateParam = this._animateParam;
    var prevPos = prevState.pos;
    var destPos = animateParam.destPos;
    var directions = map(prevPos, function (value, key) {
      return value <= destPos[key] ? 1 : -1;
    });
    var diffTime = new Date().getTime() - animateParam.startTime;
    var ratio = (diffTime + this._durationOffset) / animateParam.duration;
    var easingPer = this._easing(ratio);
    var toPos = this.axisManager.map(prevPos, function (pos, options, key) {
      var nextPos = ratio >= 1 ? destPos[key] : pos + animateParam.delta[key] * (easingPer - _this._prevEasingPer) / (1 - _this._initialEasingPer);
      // Subtract distance from distance already moved.
      // Recalculate the remaining distance.
      // Fix the bouncing phenomenon by changing the range.
      var circulatedPos = getCirculatedPos(nextPos, options.range, options.circular);
      if (nextPos !== circulatedPos) {
        // circular
        var rangeOffset = directions[key] * (options.range[1] - options.range[0]);
        destPos[key] -= rangeOffset;
        prevPos[key] -= rangeOffset;
      }
      return circulatedPos;
    });
    this._prevEasingPer = easingPer;
    return {
      pos: toPos,
      easingPer: easingPer,
      finished: easingPer >= 1
    };
  };
  __proto._easing = function (p) {
    return p > 1 ? 1 : this._options.easing(p);
  };
  return EasingManager;
}(AnimationManager);

/**
 * @typedef {Object} AxisOption The Axis information. The key of the axis specifies the name to use as the logical virtual coordinate system.
 * @ko 축 정보. 축의 키는 논리적인 가상 좌표계로 사용할 이름을 지정한다.
 * @param {Number[]} [range] The range of coordinate <ko>좌표 범위</ko>
 * @param {Number} [range[0]=0] The coordinate of the minimum <ko>최소 좌표</ko>
 * @param {Number} [range[1]=0] The coordinate of the maximum <ko>최대 좌표</ko>
 * @param {Number} [startPos=range[0]] The coordinates to be moved when creating an instance <ko>인스턴스 생성시 이동할 좌표</ko>
 * @param {Number[]} [bounce] The size of bouncing area. The coordinates can exceed the coordinate area as much as the bouncing area based on user action. If the coordinates does not exceed the bouncing area when an element is dragged, the coordinates where bouncing effects are applied are retuned back into the coordinate area<ko>바운스 영역의 크기. 사용자의 동작에 따라 좌표가 좌표 영역을 넘어 바운스 영역의 크기만큼 더 이동할 수 있다. 사용자가 끌어다 놓는 동작을 했을 때 좌표가 바운스 영역에 있으면, 바운스 효과가 적용된 좌표가 다시 좌표 영역 안으로 들어온다</ko>
 * @param {Number} [bounce[0]=0] The size of coordinate of the minimum area <ko>최소 좌표 바운스 영역의 크기</ko>
 * @param {Number} [bounce[1]=0] The size of coordinate of the maximum area <ko>최대 좌표 바운스 영역의 크기</ko>
 * @param {Boolean[]} [circular] Indicates whether a circular element is available. If it is set to "true" and an element is dragged outside the coordinate area, the element will appear on the other side.<ko>순환 여부. 'true'로 설정한 방향의 좌표 영역 밖으로 엘리먼트가 이동하면 반대 방향에서 엘리먼트가 나타난다</ko>
 * @param {Boolean} [circular[0]=false] Indicates whether to circulate to the coordinate of the minimum <ko>최소 좌표 방향의 순환 여부</ko>
 * @param {Boolean} [circular[1]=false] Indicates whether to circulate to the coordinate of the maximum <ko>최대 좌표 방향의 순환 여부</ko>
 **/
/**
 * @typedef {Object} AxesOption The option object of the eg.Axes module
 * @ko eg.Axes 모듈의 옵션 객체
 * @param {Function} [easing=easing.easeOutCubic] The easing function to apply to an animation <ko>애니메이션에 적용할 easing 함수</ko>
 * @param {Number} [maximumDuration=Infinity] Maximum duration of the animation <ko>가속도에 의해 애니메이션이 동작할 때의 최대 좌표 이동 시간</ko>
 * @param {Number} [minimumDuration=0] Minimum duration of the animation <ko>가속도에 의해 애니메이션이 동작할 때의 최소 좌표 이동 시간</ko>
 * @param {Number} [deceleration=0.0006] Deceleration of the animation where acceleration is manually enabled by user. A higher value indicates shorter running time. <ko>사용자의 동작으로 가속도가 적용된 애니메이션의 감속도. 값이 높을수록 애니메이션 실행 시간이 짧아진다</ko>
 * @param {Boolean} [interruptable=true] Indicates whether an animation is interruptible.
 * - true: It can be paused or stopped by user action or the API.
 * - false: It cannot be paused or stopped by user action or the API while it is running.
 * <ko>진행 중인 애니메이션 중지 가능 여부.
 * - true: 사용자의 동작이나 API로 애니메이션을 중지할 수 있다.
 * - false: 애니메이션이 진행 중일 때는 사용자의 동작이나 API가 적용되지 않는다</ko>
 * @param {Number} [round=null] Rounding unit. For example, 0.1 rounds to 0.1 decimal point(6.1234 => 6.1), 5 rounds to 5 (93 => 95)
 * [Details](https://github.com/naver/egjs-axes/wiki/round-option)<ko>반올림 단위. 예를 들어 0.1 은 소숫점 0.1 까지 반올림(6.1234 => 6.1), 5 는 5 단위로 반올림(93 => 95).
 * [상세내용](https://github.com/naver/egjs-axes/wiki/round-option)</ko>
 * @param {Boolean} [nested=false] Whether the event propagates to other instances when the coordinates reach the end of the movable area <ko>좌표가 이동 가능한 영역의 끝까지 도달했을 때 다른 인스턴스들로의 이벤트 전파 여부</ko>
 **/
/**
 * A module used to change the information of user action entered by various input devices such as touch screen or mouse into the logical virtual coordinates. You can easily create a UI that responds to user actions.
 * @ko 터치 입력 장치나 마우스와 같은 다양한 입력 장치를 통해 전달 받은 사용자의 동작을 논리적인 가상 좌표로 변경하는 모듈이다. 사용자 동작에 반응하는 UI를 손쉽게 만들수 있다.
 * @extends eg.Component
 *
 * @param {Object.<string, AxisOption>} axis Axis information managed by eg.Axes. The key of the axis specifies the name to use as the logical virtual coordinate system.  <ko>eg.Axes가 관리하는 축 정보. 축의 키는 논리적인 가상 좌표계로 사용할 이름을 지정한다.</ko>
 * @param {AxesOption} [options={}] The option object of the eg.Axes module<ko>eg.Axes 모듈의 옵션 객체</ko>
 * @param {Object.<string, number>} [startPos={}] The coordinates to be moved when creating an instance. It is applied with higher priority than startPos of axisOption.<ko>인스턴스 생성시 이동할 좌표, axisOption의 startPos보다 높은 우선순위로 적용된다.</ko>
 *
 * @support {"ie": "10+", "ch" : "latest", "ff" : "latest",  "sf" : "latest", "edge" : "latest", "ios" : "7+", "an" : "2.3+ (except 3.x)"}
 * @example
 * ```js
 * // 1. Initialize eg.Axes
 * const axes = new eg.Axes({
 *  something1: {
 *    range: [0, 150],
 *    bounce: 50
 *  },
 *  something2: {
 *    range: [0, 200],
 *    bounce: 100
 *  },
 *  somethingN: {
 *    range: [1, 10],
 *  }
 * }, {
 *  deceleration : 0.0024
 * });
 *
 * // 2. attach event handler
 * axes.on({
 *  "hold" : function(evt) {
 *  },
 *  "release" : function(evt) {
 *  },
 *  "animationStart" : function(evt) {
 *  },
 *  "animationEnd" : function(evt) {
 *  },
 *  "change" : function(evt) {
 *  }
 * });
 *
 * // 3. Initialize inputTypes
 * const panInputArea = new eg.Axes.PanInput("#area", {
 *  scale: [0.5, 1]
 * });
 * const panInputHmove = new eg.Axes.PanInput("#hmove");
 * const panInputVmove = new eg.Axes.PanInput("#vmove");
 * const pinchInputArea = new eg.Axes.PinchInput("#area", {
 *  scale: 1.5
 * });
 *
 * // 4. Connect eg.Axes and InputTypes
 * // [PanInput] When the mouse or touchscreen is down and moved.
 * // Connect the 'something2' axis to the mouse or touchscreen x position and
 * // connect the 'somethingN' axis to the mouse or touchscreen y position.
 * axes.connect(["something2", "somethingN"], panInputArea); // or axes.connect("something2 somethingN", panInputArea);
 *
 * // Connect only one 'something1' axis to the mouse or touchscreen x position.
 * axes.connect(["something1"], panInputHmove); // or axes.connect("something1", panInputHmove);
 *
 * // Connect only one 'something2' axis to the mouse or touchscreen y position.
 * axes.connect(["", "something2"], panInputVmove); // or axes.connect(" something2", panInputVmove);
 *
 * // [PinchInput] Connect 'something2' axis when two pointers are moving toward (zoom-in) or away from each other (zoom-out).
 * axes.connect("something2", pinchInputArea);
 * ```
 */
var Axes = /*#__PURE__*/function (_super) {
  __extends$1(Axes, _super);
  /**
   *
   */
  function Axes(axis, options, startPos) {
    if (axis === void 0) {
      axis = {};
    }
    if (options === void 0) {
      options = {};
    }
    if (startPos === void 0) {
      startPos = {};
    }
    var _this = _super.call(this) || this;
    _this.axis = axis;
    _this._inputs = [];
    _this.options = __assign({
      easing: function (x) {
        return 1 - Math.pow(1 - x, 3);
      },
      interruptable: true,
      maximumDuration: Infinity,
      minimumDuration: 0,
      deceleration: 0.0006,
      round: null,
      nested: false
    }, options);
    Object.keys(startPos).forEach(function (key) {
      _this.axis[key].startPos = startPos[key];
    });
    _this.interruptManager = new InterruptManager(_this.options);
    _this.axisManager = new AxisManager(_this.axis);
    _this.eventManager = new EventManager(_this);
    _this.animationManager = new EasingManager(_this);
    _this.inputObserver = new InputObserver(_this);
    _this.eventManager.setAnimationManager(_this.animationManager);
    _this.eventManager.triggerChange(_this.axisManager.get());
    return _this;
  }
  var __proto = Axes.prototype;
  Object.defineProperty(__proto, "holding", {
    /**
     * @name Axes#holding
     * @desc Returns true if at least one input is in progress.
     * @ko 입력이 하나 이상 진행 중인지 여부를 반환한다.
     *
     * @readonly
     * @type {boolean}
     * @example
     * ```js
     * const axes = new eg.Axes({
     *  x: {
     *    range: [0, 100],
     *  },
     * });
     *
     * axes.holding
     * ```
     */
    get: function () {
      return this.eventManager.holdingCount > 0;
    },
    enumerable: false,
    configurable: true
  });
  /**
   * Connect the axis of eg.Axes to the inputType.
   * @ko eg.Axes의 축과 inputType을 연결한다
   * @param {(String[]|String)} axes The name of the axis to associate with inputType <ko>inputType과 연결할 축의 이름</ko>
   * @param {Object} inputType The inputType instance to associate with the axis of eg.Axes <ko>eg.Axes의 축과 연결할 inputType 인스턴스</ko>
   * @return {eg.Axes} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>
   * @example
   * ```js
   * const axes = new eg.Axes({
   *   "x": {
   *      range: [0, 100]
   *   },
   *   "xOther": {
   *      range: [-100, 100]
   *   }
   * });
   *
   * axes.connect("x", new eg.Axes.PanInput("#area1"))
   *    .connect("x xOther", new eg.Axes.PanInput("#area2"))
   *    .connect(" xOther", new eg.Axes.PanInput("#area3"))
   *    .connect(["x"], new eg.Axes.PanInput("#area4"))
   *    .connect(["xOther", "x"], new eg.Axes.PanInput("#area5"))
   *    .connect(["", "xOther"], new eg.Axes.PanInput("#area6"));
   * ```
   */
  __proto.connect = function (axes, inputType) {
    var mapped;
    if (typeof axes === "string") {
      mapped = axes.split(" ");
    } else {
      mapped = axes.concat();
    }
    // check same instance
    if (~this._inputs.indexOf(inputType)) {
      this.disconnect(inputType);
    }
    inputType.mapAxes(mapped);
    inputType.connect(this.inputObserver);
    this._inputs.push(inputType);
    return this;
  };
  /**
   * Disconnect the axis of eg.Axes from the inputType.
   * @ko eg.Axes의 축과 inputType의 연결을 끊는다.
   * @param {Object} [inputType] An inputType instance associated with the axis of eg.Axes <ko>eg.Axes의 축과 연결한 inputType 인스턴스</ko>
   * @return {eg.Axes} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>
   * @example
   * ```js
   * const axes = new eg.Axes({
   *   "x": {
   *      range: [0, 100]
   *   },
   *   "xOther": {
   *      range: [-100, 100]
   *   }
   * });
   *
   * const input1 = new eg.Axes.PanInput("#area1");
   * const input2 = new eg.Axes.PanInput("#area2");
   * const input3 = new eg.Axes.PanInput("#area3");
   *
   * axes.connect("x", input1);
   *    .connect("x xOther", input2)
   *    .connect(["xOther", "x"], input3);
   *
   * axes.disconnect(input1); // disconnects input1
   * axes.disconnect(); // disconnects all of them
   * ```
   */
  __proto.disconnect = function (inputType) {
    if (inputType) {
      var index = this._inputs.indexOf(inputType);
      if (index >= 0) {
        this._inputs[index].disconnect();
        this._inputs.splice(index, 1);
      }
    } else {
      this._inputs.forEach(function (v) {
        return v.disconnect();
      });
      this._inputs = [];
    }
    return this;
  };
  /**
   * Returns the current position of the coordinates.
   * @ko 좌표의 현재 위치를 반환한다
   * @param {Object} [axes] The names of the axis <ko>축 이름들</ko>
   * @return {Object.<string, number>} Axis coordinate information <ko>축 좌표 정보</ko>
   * @example
   * ```js
   * const axes = new eg.Axes({
   *   "x": {
   *      range: [0, 100]
   *   },
   *   "xOther": {
   *      range: [-100, 100]
   *   },
   *    "zoom": {
   *      range: [50, 30]
   *   }
   * });
   *
   * axes.get(); // {"x": 0, "xOther": -100, "zoom": 50}
   * axes.get(["x", "zoom"]); // {"x": 0, "zoom": 50}
   * ```
   */
  __proto.get = function (axes) {
    return this.axisManager.get(axes);
  };
  /**
   * Moves an axis to specific coordinates.
   * @ko 좌표를 이동한다.
   * @param {Object.<string, number>} pos The coordinate to move to <ko>이동할 좌표</ko>
   * @param {Number} [duration=0] Duration of the animation (unit: ms) <ko>애니메이션 진행 시간(단위: ms)</ko>
   * @return {eg.Axes} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>
   * @example
   * ```js
   * const axes = new eg.Axes({
   *   "x": {
   *      range: [0, 100]
   *   },
   *   "xOther": {
   *      range: [-100, 100]
   *   },
   *    "zoom": {
   *      range: [50, 30]
   *   }
   * });
   *
   * axes.setTo({"x": 30, "zoom": 60});
   * axes.get(); // {"x": 30, "xOther": -100, "zoom": 60}
   *
   * axes.setTo({"x": 100, "xOther": 60}, 1000); // animatation
   *
   * // after 1000 ms
   * axes.get(); // {"x": 100, "xOther": 60, "zoom": 60}
   * ```
   */
  __proto.setTo = function (pos, duration) {
    if (duration === void 0) {
      duration = 0;
    }
    this.animationManager.setTo(pos, duration);
    return this;
  };
  /**
   * Moves an axis from the current coordinates to specific coordinates.
   * @ko 현재 좌표를 기준으로 좌표를 이동한다.
   * @param {Object.<string, number>} pos The coordinate to move to <ko>이동할 좌표</ko>
   * @param {Number} [duration=0] Duration of the animation (unit: ms) <ko>애니메이션 진행 시간(단위: ms)</ko>
   * @return {eg.Axes} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>
   * @example
   * ```js
   * const axes = new eg.Axes({
   *   "x": {
   *      range: [0, 100]
   *   },
   *   "xOther": {
   *      range: [-100, 100]
   *   },
   *    "zoom": {
   *      range: [50, 30]
   *   }
   * });
   *
   * axes.setBy({"x": 30, "zoom": 10});
   * axes.get(); // {"x": 30, "xOther": -100, "zoom": 60}
   *
   * axes.setBy({"x": 70, "xOther": 60}, 1000); // animatation
   *
   * // after 1000 ms
   * axes.get(); // {"x": 100, "xOther": -40, "zoom": 60}
   * ```
   */
  __proto.setBy = function (pos, duration) {
    if (duration === void 0) {
      duration = 0;
    }
    this.animationManager.setBy(pos, duration);
    return this;
  };
  /**
   * Change the options of Axes instance.
   * @ko 인스턴스의 옵션을 변경한다.
   * @param {AxesOption} options Axes options to change <ko>변경할 옵션 목록</ko>
   * @return {eg.Axes} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>
   * @example
   * ```js
   * const axes = new eg.Axes({
   *   "x": {
   *      range: [0, 100]
   *   },
   * }, {
   *   round: 10,
   * });
   *
   * axes.setTo({"x": 48});
   * axes.get(); // {"x": 50}
   *
   * axes.setOptions({
   *   round: 1,
   * });
   *
   * axes.setTo({"x": 48});
   * axes.get(); // {"x": 48}
   * ```
   */
  __proto.setOptions = function (options) {
    this.options = __assign(__assign({}, this.options), options);
    this.animationManager.setOptions(options);
    return this;
  };
  /**
   * Change the information of an existing axis.
   * @ko 존재하는 축의 정보를 변경한다.
   * @param {Object.<string, AxisOption>} axis Axis options to change <ko>변경할 축의 정보</ko>
   * @return {eg.Axes} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>
   * @example
   * ```js
   * const axes = new eg.Axes({
   *   "x": {
   *      range: [0, 100]
   *   },
   * });
   *
   * axes.setTo({"x": 150});
   * axes.get(); // {"x": 100}
   *
   * axes.setAxis({
   *   "x": {
   *      range: [0, 200]
   *   },
   * });
   *
   * axes.setTo({"x": 150});
   * axes.get(); // {"x": 150}
   * ```
   */
  __proto.setAxis = function (axis) {
    this.axisManager.setAxis(axis);
    return this;
  };
  /**
   * Stop an animation in progress.
   * @ko 재생 중인 애니메이션을 정지한다.
   * @return {eg.Axes} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>
   * @example
   * ```js
   * const axes = new eg.Axes({
   *   "x": {
   *      range: [0, 100]
   *   },
   * });
   *
   * axes.setTo({"x": 10}, 1000); // start animatation
   *
   * // after 500 ms
   * axes.stopAnimation(); // stop animation during movement.
   * ```
   */
  __proto.stopAnimation = function () {
    this.animationManager.stopAnimation();
    this.animationManager.finish(false);
    return this;
  };
  /**
   * Change the destination of an animation in progress.
   * @ko 재생 중인 애니메이션의 목적지와 진행 시간을 변경한다.
   * @param {UpdateAnimationOption} pos The coordinate to move to <ko>이동할 좌표</ko>
   * @return {eg.Axes} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>
   * @example
   * ```js
   * const axes = new eg.Axes({
   *   "x": {
   *      range: [0, 200]
   *   },
   *   "y": {
   *      range: [0, 200]
   *   }
   * });
   *
   * axes.setTo({"x": 50, "y": 50}, 1000); // trigger animation by setTo
   *
   * // after 500 ms
   * axes.updateAnimation({destPos: {"x": 100, "y": 100}}); // animation will end after 500 ms, at {"x": 100, "y": 100}
   *
   * // after 500 ms
   * axes.setTo({"x": 50, "y": 50}, 1000); // trigger animation by setTo
   *
   * // after 700 ms
   * axes.updateAnimation({destPos: {"x": 100, "y": 100}, duration: 1500, restart: true}); // this works same as axes.setTo({"x": 100, "y": 100}, 800) since restart is true.
   * ```
   */
  __proto.updateAnimation = function (options) {
    this.animationManager.updateAnimation(options);
    return this;
  };
  /**
   * Returns whether there is a coordinate in the bounce area of ​​the target axis.
   * @ko 대상 축 중 bounce영역에 좌표가 존재하는지를 반환한다
   * @param {Object} [axes] The names of the axis <ko>축 이름들</ko>
   * @return {Boolen} Whether the bounce area exists. <ko>bounce 영역 존재 여부</ko>
   * @example
   * ```js
   * const axes = new eg.Axes({
   *   "x": {
   *      range: [0, 100]
   *   },
   *   "xOther": {
   *      range: [-100, 100]
   *   },
   *    "zoom": {
   *      range: [50, 30]
   *   }
   * });
   *
   * axes.isBounceArea(["x"]);
   * axes.isBounceArea(["x", "zoom"]);
   * axes.isBounceArea();
   * ```
   */
  __proto.isBounceArea = function (axes) {
    return this.axisManager.isOutside(axes);
  };
  /**
   * Destroys properties, and events used in a module and disconnect all connections to inputTypes.
   * @ko 모듈에 사용한 속성, 이벤트를 해제한다. 모든 inputType과의 연결을 끊는다.
   */
  __proto.destroy = function () {
    this.disconnect();
    this.eventManager.destroy();
  };
  /**
   * @name VERSION
   * @desc Version info string
   * @ko 버전정보 문자열
   *
   * @constant
   * @type {String}
   * @example
   * ```js
   * eg.Axes.VERSION;  // ex) 3.3.3
   * ```
   */
  Axes.VERSION = "3.9.1";
  /* eslint-enable */
  /**
   * @name TRANSFORM
   * @desc Returns the transform attribute with CSS vendor prefixes.
   * @ko CSS vendor prefixes를 붙인 transform 속성을 반환한다.
   *
   * @constant
   * @type {String}
   * @example
   * ```js
   * eg.Axes.TRANSFORM; // "transform" or "webkitTransform"
   * ```
   */
  Axes.TRANSFORM = TRANSFORM;
  /**
   * @name DIRECTION_NONE
   * @constant
   * @type {Number}
   */
  Axes.DIRECTION_NONE = DIRECTION_NONE;
  /**
   * @name DIRECTION_LEFT
   * @constant
   * @type {Number}
   */
  Axes.DIRECTION_LEFT = DIRECTION_LEFT;
  /**
   * @name DIRECTION_RIGHT
   * @constant
   * @type {Number}
   */
  Axes.DIRECTION_RIGHT = DIRECTION_RIGHT;
  /**
   * @name DIRECTION_UP
   * @constant
   * @type {Number}
   */
  Axes.DIRECTION_UP = DIRECTION_UP;
  /**
   * @name DIRECTION_DOWN
   * @constant
   * @type {Number}
   */
  Axes.DIRECTION_DOWN = DIRECTION_DOWN;
  /**
   * @name DIRECTION_HORIZONTAL
   * @constant
   * @type {Number}
   */
  Axes.DIRECTION_HORIZONTAL = DIRECTION_HORIZONTAL;
  /**
   * @name DIRECTION_VERTICAL
   * @constant
   * @type {Number}
   */
  Axes.DIRECTION_VERTICAL = DIRECTION_VERTICAL;
  /**
   * @name DIRECTION_ALL
   * @constant
   * @type {Number}
   */
  Axes.DIRECTION_ALL = DIRECTION_ALL;
  __decorate([Computed], Axes.prototype, "holding", null);
  Axes = __decorate([ReactiveSubscribe], Axes);
  return Axes;
}(Component);

/*
 * Copyright (c) 2015 NAVER Corp.
 * egjs projects are licensed under the MIT license
 */
// get user's direction
var getDirectionByAngle = function (angle, thresholdAngle) {
  if (thresholdAngle < 0 || thresholdAngle > 90) {
    return DIRECTION_NONE;
  }
  var toAngle = Math.abs(angle);
  return toAngle > thresholdAngle && toAngle < 180 - thresholdAngle ? DIRECTION_VERTICAL : DIRECTION_HORIZONTAL;
};
/**
 * @typedef {Object} PanInputOption The option object of the eg.Axes.PanInput module.
 * @ko eg.Axes.PanInput 모듈의 옵션 객체
 * @param {String[]} [inputType=["touch", "mouse", "pointer"]] Types of input devices
 * - touch: Touch screen
 * - mouse: Mouse
 * - pointer: Mouse and touch <ko>입력 장치 종류
 * - touch: 터치 입력 장치
 * - mouse: 마우스
 * - pointer: 마우스 및 터치</ko>
 * @param {String[]} [inputKey=["any"]] List of key combinations to allow input
 * - any: any key
 * - shift: shift key
 * - ctrl: ctrl key and pinch gesture on the trackpad
 * - alt: alt key
 * - meta: meta key
 * - none: none of these keys are pressed <ko>입력을 허용할 키 조합 목록
 * - any: 아무 키
 * - shift: shift 키
 * - ctrl: ctrl 키 및 트랙패드의 pinch 제스쳐
 * - alt: alt 키
 * - meta: meta 키
 * - none: 아무 키도 눌리지 않은 상태 </ko>
 * @param {String[]} [inputButton=["left"]] List of buttons to allow input
 * - left: Left mouse button and normal touch
 * - middle: Mouse wheel press
 * - right: Right mouse button <ko>입력을 허용할 버튼 목록
 * - left: 마우스 왼쪽 버튼
 * - middle: 마우스 휠 눌림
 * - right: 마우스 오른쪽 버튼 </ko>
 * @param {Number[]} [scale] Coordinate scale that a user can move<ko>사용자의 동작으로 이동하는 좌표의 배율</ko>
 * @param {Number} [scale[0]=1] horizontal axis scale <ko>수평축 배율</ko>
 * @param {Number} [scale[1]=1] vertical axis scale <ko>수직축 배율</ko>
 * @param {Number} [thresholdAngle=45] The threshold value that determines whether user action is horizontal or vertical (0~90) <ko>사용자의 동작이 가로 방향인지 세로 방향인지 판단하는 기준 각도(0~90)</ko>
 * @param {Number} [threshold=0] Minimal pan distance required before recognizing <ko>사용자의 Pan 동작을 인식하기 위해산 최소한의 거리</ko>
 * @param {Boolean} [preventClickOnDrag=false] Whether to cancel the {@link https://developer.mozilla.org/en/docs/Web/API/Element/click_event click} event when the user finishes dragging more than 1 pixel <ko>사용자가 1픽셀 이상 드래그를 마쳤을 때 {@link https://developer.mozilla.org/ko/docs/Web/API/Element/click_event click} 이벤트 취소 여부</ko>
 * @param {Boolean} [preventDefaultOnDrag=false] Whether to use the {@link https://developer.mozilla.org/ko/docs/Web/API/Event/preventDefault preventDefault} when the user starts dragging <ko>사용자가 드래그를 시작할 때 {@link https://developer.mozilla.org/ko/docs/Web/API/Event/preventDefault preventDefault} 실행 여부</ko>
 * @param {Number} [iOSEdgeSwipeThreshold=30] Area (px) that can go to the next page when swiping the right edge in iOS safari <ko>iOS Safari에서 오른쪽 엣지를 스와이프 하는 경우 다음 페이지로 넘어갈 수 있는 영역(px)</ko>
 * @param {String} [touchAction=null] Value that overrides the element's "touch-action" css property. If set to null, it is automatically set to prevent scrolling in the direction of the connected axis. <ko>엘리먼트의 "touch-action" CSS 속성을 덮어쓰는 값. 만약 null로 설정된 경우, 연결된 축 방향으로의 스크롤을 방지하게끔 자동으로 설정된다.</ko>
 **/
/**
 * A module that passes the amount of change to eg.Axes when the mouse or touchscreen is down and moved. use less than two axes.
 * @ko 마우스나 터치 스크린을 누르고 움직일때의 변화량을 eg.Axes에 전달하는 모듈. 두개 이하의 축을 사용한다.
 *
 * @example
 * ```js
 * const pan = new eg.Axes.PanInput("#area", {
 *     inputType: ["touch"],
 *     scale: [1, 1.3],
 * });
 *
 * // Connect the 'something2' axis to the mouse or touchscreen x position when the mouse or touchscreen is down and moved.
 * // Connect the 'somethingN' axis to the mouse or touchscreen y position when the mouse or touchscreen is down and moved.
 * axes.connect(["something2", "somethingN"], pan); // or axes.connect("something2 somethingN", pan);
 *
 * // Connect only one 'something1' axis to the mouse or touchscreen x position when the mouse or touchscreen is down and moved.
 * axes.connect(["something1"], pan); // or axes.connect("something1", pan);
 *
 * // Connect only one 'something2' axis to the mouse or touchscreen y position when the mouse or touchscreen is down and moved.
 * axes.connect(["", "something2"], pan); // or axes.connect(" something2", pan);
 * ```
 * @param {String|HTMLElement|Ref<HTMLElement>|jQuery} element An element to use the eg.Axes.PanInput module <ko>eg.Axes.PanInput 모듈을 사용할 엘리먼트</ko>
 * @param {PanInputOption} [options={}] The option object of the eg.Axes.PanInput module<ko>eg.Axes.PanInput 모듈의 옵션 객체</ko>
 */
var PanInput = /*#__PURE__*/function () {
  /**
   *
   */
  function PanInput(el, options) {
    var _this = this;
    this.axes = [];
    this.element = null;
    this._enabled = false;
    this._activeEvent = null;
    this._atRightEdge = false;
    this._rightEdgeTimer = 0;
    this._dragged = false;
    this._isOverThreshold = false;
    this._preventClickWhenDragged = function (e) {
      if (_this._dragged) {
        e.preventDefault();
        e.stopPropagation();
      }
      _this._dragged = false;
    };
    this._voidFunction = function () {};
    this.element = $$1(el);
    this.options = __assign({
      inputType: ["touch", "mouse", "pointer"],
      inputKey: [ANY],
      inputButton: [MOUSE_LEFT],
      scale: [1, 1],
      thresholdAngle: 45,
      threshold: 0,
      preventClickOnDrag: false,
      preventDefaultOnDrag: false,
      iOSEdgeSwipeThreshold: IOS_EDGE_THRESHOLD,
      releaseOnScroll: false,
      touchAction: null
    }, options);
    this._onPanstart = this._onPanstart.bind(this);
    this._onPanmove = this._onPanmove.bind(this);
    this._onPanend = this._onPanend.bind(this);
  }
  var __proto = PanInput.prototype;
  __proto.mapAxes = function (axes) {
    this._direction = getDirection(!!axes[0], !!axes[1]);
    this.axes = axes;
  };
  __proto.connect = function (observer) {
    if (this._activeEvent) {
      this._detachElementEvent();
      this._detachWindowEvent(this._activeEvent);
    }
    this._attachElementEvent(observer);
    return this;
  };
  __proto.disconnect = function () {
    this._detachElementEvent();
    this._detachWindowEvent(this._activeEvent);
    this._direction = DIRECTION_NONE;
    return this;
  };
  /**
   * Destroys elements, properties, and events used in a module.
   * @ko 모듈에 사용한 엘리먼트와 속성, 이벤트를 해제한다.
   */
  __proto.destroy = function () {
    this.disconnect();
    this.element = null;
  };
  /**
   * Enables input devices
   * @ko 입력 장치를 사용할 수 있게 한다
   * @return {PanInput} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>
   */
  __proto.enable = function () {
    if (!this._enabled) {
      this._enabled = true;
      this._originalCssProps = setCssProps(this.element, this.options, this._direction);
    }
    return this;
  };
  /**
   * Disables input devices
   * @ko 입력 장치를 사용할 수 없게 한다.
   * @return {PanInput} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>
   */
  __proto.disable = function () {
    if (this._enabled) {
      this._enabled = false;
      if (!isCssPropsFromAxes(this._originalCssProps)) {
        revertCssProps(this.element, this._originalCssProps);
      }
    }
    return this;
  };
  /**
   * Returns whether to use an input device
   * @ko 입력 장치 사용 여부를 반환한다.
   * @return {Boolean} Whether to use an input device <ko>입력장치 사용여부</ko>
   */
  __proto.isEnabled = function () {
    return this._enabled;
  };
  /**
   * Releases current user input.
   * @ko 사용자의 입력을 강제로 중단시킨다.
   * @return {PanInput} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>
   */
  __proto.release = function () {
    var activeEvent = this._activeEvent;
    var prevEvent = activeEvent.prevEvent;
    activeEvent.onRelease();
    this._observer.release(this, prevEvent, [0, 0]);
    this._detachWindowEvent(activeEvent);
    return this;
  };
  __proto._onPanstart = function (event) {
    var _a = this.options,
      inputKey = _a.inputKey,
      inputButton = _a.inputButton,
      preventDefaultOnDrag = _a.preventDefaultOnDrag;
    var activeEvent = this._activeEvent;
    var panEvent = activeEvent.onEventStart(event, inputKey, inputButton);
    if (!panEvent || !this._enabled || activeEvent.getTouches(event, inputButton) > 1) {
      return;
    }
    if (panEvent.srcEvent.cancelable !== false) {
      var edgeThreshold = this.options.iOSEdgeSwipeThreshold;
      this._dragged = false;
      this._isOverThreshold = false;
      this._observer.hold(this, panEvent);
      this._atRightEdge = IS_IOS_SAFARI && panEvent.center.x > window.innerWidth - edgeThreshold;
      this._attachWindowEvent(activeEvent);
      preventDefaultOnDrag && panEvent.srcEvent.type !== "touchstart" && panEvent.srcEvent.preventDefault();
      activeEvent.prevEvent = panEvent;
    }
  };
  __proto._onPanmove = function (event) {
    var _this = this;
    var _a = this.options,
      iOSEdgeSwipeThreshold = _a.iOSEdgeSwipeThreshold,
      preventClickOnDrag = _a.preventClickOnDrag,
      releaseOnScroll = _a.releaseOnScroll,
      inputKey = _a.inputKey,
      inputButton = _a.inputButton,
      threshold = _a.threshold,
      thresholdAngle = _a.thresholdAngle;
    var activeEvent = this._activeEvent;
    var panEvent = activeEvent.onEventMove(event, inputKey, inputButton);
    var touches = activeEvent.getTouches(event, inputButton);
    if (touches === 0 || releaseOnScroll && panEvent && !panEvent.srcEvent.cancelable) {
      this._onPanend(event);
      return;
    }
    if (!panEvent || !this._enabled || touches > 1) {
      return;
    }
    var userDirection = getDirectionByAngle(panEvent.angle, thresholdAngle);
    var useHorizontal = useDirection(DIRECTION_HORIZONTAL, this._direction, userDirection);
    var useVertical = useDirection(DIRECTION_VERTICAL, this._direction, userDirection);
    if (activeEvent.prevEvent && IS_IOS_SAFARI) {
      var swipeLeftToRight = panEvent.center.x < 0;
      if (swipeLeftToRight) {
        // iOS swipe left => right
        this.release();
        return;
      } else if (this._atRightEdge) {
        clearTimeout(this._rightEdgeTimer);
        // - is right to left
        var swipeRightToLeft = panEvent.deltaX < -iOSEdgeSwipeThreshold;
        if (swipeRightToLeft) {
          this._atRightEdge = false;
        } else {
          // iOS swipe right => left
          this._rightEdgeTimer = window.setTimeout(function () {
            return _this.release();
          }, 100);
        }
      }
    }
    var distance = this._getDistance([panEvent.deltaX, panEvent.deltaY], [useHorizontal, useVertical]);
    var offset = this._getOffset([panEvent.offsetX, panEvent.offsetY], [useHorizontal, useVertical]);
    var prevent = offset.some(function (v) {
      return v !== 0;
    });
    if (prevent) {
      if (panEvent.srcEvent.cancelable !== false) {
        panEvent.srcEvent.preventDefault();
      }
      panEvent.srcEvent.stopPropagation();
    }
    panEvent.preventSystemEvent = prevent;
    if (prevent && (this._isOverThreshold || distance >= threshold)) {
      this._dragged = preventClickOnDrag;
      this._isOverThreshold = true;
      this._observer.change(this, panEvent, toAxis(this.axes, offset));
    }
    activeEvent.prevEvent = panEvent;
  };
  __proto._onPanend = function (event) {
    var inputButton = this.options.inputButton;
    var activeEvent = this._activeEvent;
    activeEvent.onEventEnd(event);
    if (!this._enabled || activeEvent.getTouches(event, inputButton) !== 0) {
      return;
    }
    this._detachWindowEvent(activeEvent);
    clearTimeout(this._rightEdgeTimer);
    var prevEvent = activeEvent.prevEvent;
    var velocity = this._isOverThreshold ? this._getOffset([Math.abs(prevEvent.velocityX) * (prevEvent.offsetX < 0 ? -1 : 1), Math.abs(prevEvent.velocityY) * (prevEvent.offsetY < 0 ? -1 : 1)], [useDirection(DIRECTION_HORIZONTAL, this._direction), useDirection(DIRECTION_VERTICAL, this._direction)]) : [0, 0];
    activeEvent.onRelease();
    this._observer.release(this, prevEvent, velocity);
  };
  __proto._attachWindowEvent = function (activeEvent) {
    var _this = this;
    activeEvent === null || activeEvent === void 0 ? void 0 : activeEvent.move.forEach(function (event) {
      window.addEventListener(event, _this._onPanmove, getAddEventOptions(event));
    });
    activeEvent === null || activeEvent === void 0 ? void 0 : activeEvent.end.forEach(function (event) {
      window.addEventListener(event, _this._onPanend, getAddEventOptions(event));
    });
  };
  __proto._detachWindowEvent = function (activeEvent) {
    var _this = this;
    activeEvent === null || activeEvent === void 0 ? void 0 : activeEvent.move.forEach(function (event) {
      window.removeEventListener(event, _this._onPanmove);
    });
    activeEvent === null || activeEvent === void 0 ? void 0 : activeEvent.end.forEach(function (event) {
      window.removeEventListener(event, _this._onPanend);
    });
  };
  __proto._getOffset = function (properties, direction) {
    var scale = this.options.scale;
    return [direction[0] ? properties[0] * scale[0] : 0, direction[1] ? properties[1] * scale[1] : 0];
  };
  __proto._getDistance = function (delta, direction) {
    return Math.sqrt(Number(direction[0]) * Math.pow(delta[0], 2) + Number(direction[1]) * Math.pow(delta[1], 2));
  };
  __proto._attachElementEvent = function (observer) {
    var _this = this;
    var activeEvent = convertInputType(this.options.inputType);
    var element = this.element;
    if (!activeEvent) {
      return;
    }
    if (!element) {
      throw new Error("Element to connect input does not exist.");
    }
    this._observer = observer;
    this.enable();
    this._activeEvent = activeEvent;
    element.addEventListener("click", this._preventClickWhenDragged, true);
    activeEvent.start.forEach(function (event) {
      element.addEventListener(event, _this._onPanstart);
    });
    // adding event listener to element prevents invalid behavior in iOS Safari
    activeEvent.move.forEach(function (event) {
      element.addEventListener(event, _this._voidFunction);
    });
  };
  __proto._detachElementEvent = function () {
    var _this = this;
    var activeEvent = this._activeEvent;
    var element = this.element;
    if (element) {
      element.removeEventListener("click", this._preventClickWhenDragged, true);
      activeEvent === null || activeEvent === void 0 ? void 0 : activeEvent.start.forEach(function (event) {
        element.removeEventListener(event, _this._onPanstart);
      });
      activeEvent === null || activeEvent === void 0 ? void 0 : activeEvent.move.forEach(function (event) {
        element.removeEventListener(event, _this._voidFunction);
      });
    }
    this.disable();
    this._observer = null;
  };
  return PanInput;
}();

/*
Copyright (c) 2020-present NAVER Corp.
name: @egjs/imready
license: MIT
author: NAVER Corp.
repository: https://github.com/naver/egjs-imready
version: 1.3.1
*/

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

/* global Reflect, Promise */
var extendStatics$2 = function (d, b) {
  extendStatics$2 = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
  };

  return extendStatics$2(d, b);
};

function __extends$2(d, b) {
  extendStatics$2(d, b);

  function __() {
    this.constructor = d;
  }

  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign$1 = function () {
  __assign$1 = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign$1.apply(this, arguments);
};
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;

  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];

  return r;
}

/*
egjs-imready
Copyright (c) 2020-present NAVER Corp.
MIT license
*/
var isWindow = typeof window !== "undefined";
var ua = isWindow ? window.navigator.userAgent : "";
var SUPPORT_COMPUTEDSTYLE = isWindow ? !!("getComputedStyle" in window) : false;
var IS_IE = /MSIE|Trident|Windows Phone|Edge/.test(ua);
var SUPPORT_ADDEVENTLISTENER = isWindow ? !!("addEventListener" in document) : false;
var WIDTH = "width";
var HEIGHT = "height";

function getAttribute(el, name) {
  return el.getAttribute(name) || "";
}
function toArray$1(arr) {
  return [].slice.call(arr);
}
function hasSizeAttribute(target, prefix) {
  if (prefix === void 0) {
    prefix = "data-";
  }

  return !!target.getAttribute(prefix + "width");
}
function hasLoadingAttribute(target, prefix) {
  if (prefix === void 0) {
    prefix = "data-";
  }

  return "loading" in target && target.getAttribute("loading") === "lazy" || !!target.getAttribute(prefix + "lazy");
}
function hasSkipAttribute(target, prefix) {
  if (prefix === void 0) {
    prefix = "data-";
  }

  return !!target.getAttribute(prefix + "skip");
}
function addEvent(element, type, handler) {
  if (SUPPORT_ADDEVENTLISTENER) {
    element.addEventListener(type, handler, false);
  } else if (element.attachEvent) {
    element.attachEvent("on" + type, handler);
  } else {
    element["on" + type] = handler;
  }
}
function removeEvent(element, type, handler) {
  if (element.removeEventListener) {
    element.removeEventListener(type, handler, false);
  } else if (element.detachEvent) {
    element.detachEvent("on" + type, handler);
  } else {
    element["on" + type] = null;
  }
}
function innerWidth(el) {
  return getSize(el, "Width");
}
function innerHeight(el) {
  return getSize(el, "Height");
}
function getStyles(el) {
  return (SUPPORT_COMPUTEDSTYLE ? window.getComputedStyle(el) : el.currentStyle) || {};
}

function getSize(el, name) {
  var size = el["client" + name] || el["offset" + name];
  return parseFloat(size || getStyles(el)[name.toLowerCase()]) || 0;
}

function getContentElements(element, tags, prefix) {
  var skipElements = toArray$1(element.querySelectorAll(__spreadArrays(["[" + prefix + "skip] [" + prefix + "width]"], tags.map(function (tag) {
    return ["[" + prefix + "skip] " + tag, tag + "[" + prefix + "skip]", "[" + prefix + "width] " + tag].join(", ");
  })).join(", ")));
  return toArray$1(element.querySelectorAll("[" + prefix + "width], " + tags.join(", "))).filter(function (el) {
    return skipElements.indexOf(el) === -1;
  });
}

/*
egjs-imready
Copyright (c) 2020-present NAVER Corp.
MIT license
*/
var elements = [];
function addAutoSizer(element, prefix) {
  !elements.length && addEvent(window, "resize", resizeAllAutoSizers);
  element.__PREFIX__ = prefix;
  elements.push(element);
  resize(element);
}
function removeAutoSizer(element, prefix) {
  var index = elements.indexOf(element);

  if (index < 0) {
    return;
  }

  var fixed = getAttribute(element, prefix + "fixed");
  delete element.__PREFIX__;
  element.style[fixed === HEIGHT ? WIDTH : HEIGHT] = "";
  elements.splice(index, 1);
  !elements.length && removeEvent(window, "resize", resizeAllAutoSizers);
}

function resize(element, prefix) {
  if (prefix === void 0) {
    prefix = "data-";
  }

  var elementPrefix = element.__PREFIX__ || prefix;
  var dataWidth = parseInt(getAttribute(element, "" + elementPrefix + WIDTH), 10) || 0;
  var dataHeight = parseInt(getAttribute(element, "" + elementPrefix + HEIGHT), 10) || 0;
  var fixed = getAttribute(element, elementPrefix + "fixed");

  if (fixed === HEIGHT) {
    var size = innerHeight(element) || dataHeight;
    element.style[WIDTH] = dataWidth / dataHeight * size + "px";
  } else {
    var size = innerWidth(element) || dataWidth;
    element.style[HEIGHT] = dataHeight / dataWidth * size + "px";
  }
}

function resizeAllAutoSizers() {
  elements.forEach(function (element) {
    resize(element);
  });
}

var Loader =
/*#__PURE__*/
function (_super) {
  __extends$2(Loader, _super);

  function Loader(element, options) {
    if (options === void 0) {
      options = {};
    }

    var _this = _super.call(this) || this;

    _this.isReady = false;
    _this.isPreReady = false;
    _this.hasDataSize = false;
    _this.hasLoading = false;
    _this.isSkip = false;

    _this.onCheck = function (e) {
      _this.clear();

      if (e && e.type === "error") {
        _this.onError(_this.element);
      }

      if (_this.hasLoading && _this.checkElement()) {
        // I'm not ready
        return;
      } // I'm pre-ready and ready!


      var withPreReady = !_this.hasDataSize && !_this.hasLoading;

      _this.onReady(withPreReady);
    };

    _this.options = __assign$1({
      prefix: "data-"
    }, options);
    _this.element = element;
    var prefix = _this.options.prefix;
    _this.hasDataSize = hasSizeAttribute(element, prefix);
    _this.isSkip = hasSkipAttribute(element, prefix);
    _this.hasLoading = hasLoadingAttribute(element, prefix);
    return _this;
  }

  var __proto = Loader.prototype;

  __proto.check = function () {
    if (this.isSkip || !this.checkElement()) {
      // I'm Ready
      this.onAlreadyReady(true);
      return false;
    }

    if (this.hasDataSize) {
      addAutoSizer(this.element, this.options.prefix);
    }

    if (this.hasDataSize || this.hasLoading) {
      // I'm Pre Ready
      this.onAlreadyPreReady();
    } // Wati Pre Ready, Ready


    return true;
  };

  __proto.addEvents = function () {
    var _this = this;

    var element = this.element;
    this.constructor.EVENTS.forEach(function (name) {
      addEvent(element, name, _this.onCheck);
    });
  };

  __proto.clear = function () {
    var _this = this;

    var element = this.element;
    this.constructor.EVENTS.forEach(function (name) {
      removeEvent(element, name, _this.onCheck);
    });
    this.removeAutoSizer();
  };

  __proto.destroy = function () {
    this.clear();
    this.off();
  };

  __proto.removeAutoSizer = function () {
    if (this.hasDataSize) {
      // I'm already ready.
      var prefix = this.options.prefix;
      removeAutoSizer(this.element, prefix);
    }
  };

  __proto.onError = function (target) {
    this.trigger("error", {
      element: this.element,
      target: target
    });
  };

  __proto.onPreReady = function () {
    if (this.isPreReady) {
      return;
    }

    this.isPreReady = true;
    this.trigger("preReady", {
      element: this.element,
      hasLoading: this.hasLoading,
      isSkip: this.isSkip
    });
  };

  __proto.onReady = function (withPreReady) {
    if (this.isReady) {
      return;
    }

    withPreReady = !this.isPreReady && withPreReady;

    if (withPreReady) {
      this.isPreReady = true;
    }

    this.removeAutoSizer();
    this.isReady = true;
    this.trigger("ready", {
      element: this.element,
      withPreReady: withPreReady,
      hasLoading: this.hasLoading,
      isSkip: this.isSkip
    });
  };

  __proto.onAlreadyError = function (target) {
    var _this = this;

    setTimeout(function () {
      _this.onError(target);
    });
  };

  __proto.onAlreadyPreReady = function () {
    var _this = this;

    setTimeout(function () {
      _this.onPreReady();
    });
  };

  __proto.onAlreadyReady = function (withPreReady) {
    var _this = this;

    setTimeout(function () {
      _this.onReady(withPreReady);
    });
  };

  Loader.EVENTS = [];
  return Loader;
}(Component);

var ElementLoader =
/*#__PURE__*/
function (_super) {
  __extends$2(ElementLoader, _super);

  function ElementLoader() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  var __proto = ElementLoader.prototype;

  __proto.setHasLoading = function (hasLoading) {
    this.hasLoading = hasLoading;
  };

  __proto.check = function () {
    if (this.isSkip) {
      // I'm Ready
      this.onAlreadyReady(true);
      return false;
    }

    if (this.hasDataSize) {
      addAutoSizer(this.element, this.options.prefix);
      this.onAlreadyPreReady();
    } else {
      // has not data size
      this.trigger("requestChildren");
    }

    return true;
  };

  __proto.checkElement = function () {
    return true;
  };

  __proto.destroy = function () {
    this.clear();
    this.trigger("requestDestroy");
    this.off();
  };

  __proto.onAlreadyPreReady = function () {
    // has data size
    _super.prototype.onAlreadyPreReady.call(this);

    this.trigger("reqeustReadyChildren");
  };

  ElementLoader.EVENTS = [];
  return ElementLoader;
}(Loader);

/**
 * @alias eg.ImReady
 * @extends eg.Component
 */

var ImReadyManager =
/*#__PURE__*/
function (_super) {
  __extends$2(ImReadyManager, _super);
  /**
   * @param - ImReady's options
   */


  function ImReadyManager(options) {
    if (options === void 0) {
      options = {};
    }

    var _this = _super.call(this) || this;

    _this.readyCount = 0;
    _this.preReadyCount = 0;
    _this.totalCount = 0;
    _this.totalErrorCount = 0;
    _this.isPreReadyOver = true;
    _this.elementInfos = [];
    _this.options = __assign$1({
      loaders: {},
      prefix: "data-"
    }, options);
    return _this;
  }
  /**
   * Checks whether elements are in the ready state.
   * @ko 엘리먼트가 준비 상태인지 체크한다.
   * @elements - Elements to check ready status. <ko> 준비 상태를 체크할 엘리먼트들.</ko>
   * @example
     * ```html
     * <div>
     *    <img src="./1.jpg" data-width="1280" data-height="853" style="width:100%"/>
     *    <img src="./2.jpg" data-width="1280" data-height="853"/>
     *    <img src="ERR" data-width="1280" data-height="853"/>
     * </div>
     * ```
     * ## Javascript
     * ```js
     * import ImReady from "@egjs/imready";
     *
     * const im = new ImReady(); // umd: eg.ImReady
     * im.check(document.querySelectorAll("img")).on({
     *   preReadyElement: e => {
     *     // 1, 3
     *     // 2, 3
     *     // 3, 3
     *     console.log(e.preReadyCount, e.totalCount),
     *   },
     * });
     * ```
   */


  var __proto = ImReadyManager.prototype;

  __proto.check = function (elements) {
    var _this = this;

    var prefix = this.options.prefix;
    this.clear();
    this.elementInfos = toArray$1(elements).map(function (element, index) {
      var loader = _this.getLoader(element, {
        prefix: prefix
      });

      loader.check();
      loader.on("error", function (e) {
        _this.onError(index, e.target);
      }).on("preReady", function (e) {
        var info = _this.elementInfos[index];
        info.hasLoading = e.hasLoading;
        info.isSkip = e.isSkip;

        var isPreReady = _this.checkPreReady(index);

        _this.onPreReadyElement(index);

        isPreReady && _this.onPreReady();
      }).on("ready", function (_a) {
        var withPreReady = _a.withPreReady,
            hasLoading = _a.hasLoading,
            isSkip = _a.isSkip;
        var info = _this.elementInfos[index];
        info.hasLoading = hasLoading;
        info.isSkip = isSkip;

        var isPreReady = withPreReady && _this.checkPreReady(index);

        var isReady = _this.checkReady(index); // Pre-ready and ready occur simultaneously


        withPreReady && _this.onPreReadyElement(index);

        _this.onReadyElement(index);

        isPreReady && _this.onPreReady();
        isReady && _this.onReady();
      });
      return {
        loader: loader,
        element: element,
        hasLoading: false,
        hasError: false,
        isPreReady: false,
        isReady: false,
        isSkip: false
      };
    });
    var length = this.elementInfos.length;
    this.totalCount = length;

    if (!length) {
      setTimeout(function () {
        _this.onPreReady();

        _this.onReady();
      });
    }

    return this;
  };
  /**
   * Gets the total count of elements to be checked.
   * @ko 체크하는 element의 총 개수를 가져온다.
   */


  __proto.getTotalCount = function () {
    return this.totalCount;
  };
  /**
   * Whether the elements are all pre-ready. (all sizes are known)
   * @ko 엘리먼트들이 모두 사전 준비가 됐는지 (사이즈를 전부 알 수 있는지) 여부.
   */


  __proto.isPreReady = function () {
    return this.elementInfos.every(function (info) {
      return info.isPreReady;
    });
  };
  /**
   * Whether the elements are all ready.
   * @ko 엘리먼트들이 모두 준비가 됐는지 여부.
   */


  __proto.isReady = function () {
    return this.elementInfos.every(function (info) {
      return info.isReady;
    });
  };
  /**
   * Whether an error has occurred in the elements in the current state.
   * @ko 현재 상태에서 엘리먼트들이 에러가 발생했는지 여부.
   */


  __proto.hasError = function () {
    return this.totalErrorCount > 0;
  };
  /**
   * Clears events of elements being checked.
   * @ko 체크 중인 엘리먼트들의 이벤트를 해제 한다.
   */


  __proto.clear = function () {
    this.isPreReadyOver = false;
    this.totalCount = 0;
    this.preReadyCount = 0;
    this.readyCount = 0;
    this.totalErrorCount = 0;
    this.elementInfos.forEach(function (info) {
      if (info.loader) {
        info.loader.destroy();
      }
    });
    this.elementInfos = [];
  };
  /**
   * Destory all events.
   * @ko 모든 이벤트를 해제 한다.
   */


  __proto.destroy = function () {
    this.clear();
    this.off();
  };

  __proto.getLoader = function (element, options) {
    var _this = this;

    var tagName = element.tagName.toLowerCase();
    var loaders = this.options.loaders;
    var prefix = options.prefix;
    var tags = Object.keys(loaders);

    if (loaders[tagName]) {
      return new loaders[tagName](element, options);
    }

    var loader = new ElementLoader(element, options);
    var children = toArray$1(element.querySelectorAll(tags.join(", ")));
    loader.setHasLoading(children.some(function (el) {
      return hasLoadingAttribute(el, prefix);
    }));
    var withPreReady = false;
    var childrenImReady = this.clone().on("error", function (e) {
      loader.onError(e.target);
    }).on("ready", function () {
      loader.onReady(withPreReady);
    });
    loader.on("requestChildren", function () {
      // has not data size
      var contentElements = getContentElements(element, tags, _this.options.prefix);
      childrenImReady.check(contentElements).on("preReady", function (e) {
        withPreReady = e.isReady;

        if (!withPreReady) {
          loader.onPreReady();
        }
      });
    }).on("reqeustReadyChildren", function () {
      // has data size
      // loader call preReady
      // check only video, image elements
      childrenImReady.check(children);
    }).on("requestDestroy", function () {
      childrenImReady.destroy();
    });
    return loader;
  };

  __proto.clone = function () {
    return new ImReadyManager(__assign$1({}, this.options));
  };

  __proto.checkPreReady = function (index) {
    this.elementInfos[index].isPreReady = true;
    ++this.preReadyCount;

    if (this.preReadyCount < this.totalCount) {
      return false;
    }

    return true;
  };

  __proto.checkReady = function (index) {
    this.elementInfos[index].isReady = true;
    ++this.readyCount;

    if (this.readyCount < this.totalCount) {
      return false;
    }

    return true;
  };

  __proto.onError = function (index, target) {
    var info = this.elementInfos[index];
    info.hasError = true;
    /**
     * An event occurs if the image, video fails to load.
     * @ko 이미지, 비디오가 로딩에 실패하면 이벤트가 발생한다.
     * @event eg.ImReady#error
     * @param {eg.ImReady.OnError} e - The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>
     * @example
     * ```html
     * <div>
     *    <img src="./1.jpg" data-width="1280" data-height="853" style="width:100%"/>
     *    <img src="./2.jpg"/>
     *    <img src="ERR"/>
     * </div>
     * ```
     * ## Javascript
     * ```js
     * import ImReady from "@egjs/imready";
     *
     * const im = new ImReady(); // umd: eg.ImReady
     * im.check([document.querySelector("div")]).on({
     *   error: e => {
     *     // <div>...</div>, 0, <img src="ERR"/>
     *     console.log(e.element, e.index, e.target),
     *   },
     * });
     * ```
     */

    this.trigger(new ComponentEvent$1("error", {
      element: info.element,
      index: index,
      target: target,
      errorCount: this.getErrorCount(),
      totalErrorCount: ++this.totalErrorCount
    }));
  };

  __proto.onPreReadyElement = function (index) {
    var info = this.elementInfos[index];
    /**
     * An event occurs when the element is pre-ready (when the loading attribute is applied or the size is known)
     * @ko 해당 엘리먼트가 사전 준비되었을 때(loading 속성이 적용되었거나 사이즈를 알 수 있을 때) 이벤트가 발생한다.
     * @event eg.ImReady#preReadyElement
     * @param {eg.ImReady.OnPreReadyElement} e - The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>
     * @example
     * ```html
     * <div>
     *    <img src="./1.jpg" data-width="1280" data-height="853" style="width:100%"/>
     *    <img src="./2.jpg" data-width="1280" data-height="853"/>
     *    <img src="ERR" data-width="1280" data-height="853"/>
     * </div>
     * ```
     * ## Javascript
     * ```js
     * import ImReady from "@egjs/imready";
     *
     * const im = new ImReady(); // umd: eg.ImReady
     * im.check(document.querySelectorAll("img")).on({
     *   preReadyElement: e => {
     *     // 1, 3
     *     // 2, 3
     *     // 3, 3
     *     console.log(e.preReadyCount, e.totalCount),
     *   },
     * });
     * ```
     */

    this.trigger(new ComponentEvent$1("preReadyElement", {
      element: info.element,
      index: index,
      preReadyCount: this.preReadyCount,
      readyCount: this.readyCount,
      totalCount: this.totalCount,
      isPreReady: this.isPreReady(),
      isReady: this.isReady(),
      hasLoading: info.hasLoading,
      isSkip: info.isSkip
    }));
  };

  __proto.onPreReady = function () {
    this.isPreReadyOver = true;
    /**
     * An event occurs when all element are pre-ready (When all elements have the loading attribute applied or the size is known)
     * @ko 모든 엘리먼트들이 사전 준비된 경우 (모든 엘리먼트들이 loading 속성이 적용되었거나 사이즈를 알 수 있는 경우) 이벤트가 발생한다.
     * @event eg.ImReady#preReady
     * @param {eg.ImReady.OnPreReady} e - The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>
     * @example
     * ```html
     * <div>
     *    <img src="./1.jpg" data-width="1280" data-height="853" style="width:100%"/>
     *    <img src="./2.jpg" data-width="1280" data-height="853"/>
     *    <img src="ERR" data-width="1280" data-height="853"/>
     * </div>
     * ```
     * ## Javascript
     * ```js
     * import ImReady from "@egjs/imready";
     *
     * const im = new ImReady(); // umd: eg.ImReady
     * im.check(document.querySelectorAll("img")).on({
     *   preReady: e => {
     *     // 0, 3
     *     console.log(e.readyCount, e.totalCount),
     *   },
     * });
     * ```
     */

    this.trigger(new ComponentEvent$1("preReady", {
      readyCount: this.readyCount,
      totalCount: this.totalCount,
      isReady: this.isReady(),
      hasLoading: this.hasLoading()
    }));
  };

  __proto.onReadyElement = function (index) {
    var info = this.elementInfos[index];
    /**
     * An event occurs when the element is ready
     * @ko 해당 엘리먼트가 준비가 되었을 때 이벤트가 발생한다.
     * @event eg.ImReady#readyElement
     * @param {eg.ImReady.OnReadyElement} e - The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>
     * @example
     * ```html
     * <div>
     *    <img src="./1.jpg" data-width="1280" data-height="853" style="width:100%"/>
     *    <img src="./2.jpg" data-width="1280" data-height="853"/>
     *    <img src="ERR" data-width="1280" data-height="853"/>
     * </div>
     * ```
     * ## Javascript
     * ```js
     * import ImReady from "@egjs/imready";
     *
     * const im = new ImReady(); // umd: eg.ImReady
     * im.check(document.querySelectorAll("img")).on({
     *   readyElement: e => {
     *     // 1, 0, false, 3
     *     // 2, 1, false, 3
     *     // 3, 2, true, 3
     *     console.log(e.readyCount, e.index, e.hasError, e.totalCount),
     *   },
     * });
     * ```
     */

    this.trigger(new ComponentEvent$1("readyElement", {
      index: index,
      element: info.element,
      hasError: info.hasError,
      errorCount: this.getErrorCount(),
      totalErrorCount: this.totalErrorCount,
      preReadyCount: this.preReadyCount,
      readyCount: this.readyCount,
      totalCount: this.totalCount,
      isPreReady: this.isPreReady(),
      isReady: this.isReady(),
      hasLoading: info.hasLoading,
      isPreReadyOver: this.isPreReadyOver,
      isSkip: info.isSkip
    }));
  };

  __proto.onReady = function () {
    /**
     * An event occurs when all element are ready
     * @ko 모든 엘리먼트들이 준비된 경우 이벤트가 발생한다.
     * @event eg.ImReady#ready
     * @param {eg.ImReady.OnReady} e - The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>
     * @example
     * ```html
     * <div>
     *    <img src="./1.jpg" data-width="1280" data-height="853" style="width:100%"/>
     *    <img src="./2.jpg" data-width="1280" data-height="853"/>
     *    <img src="ERR" data-width="1280" data-height="853"/>
     * </div>
     * ```
     * ## Javascript
     * ```js
     * import ImReady from "@egjs/imready";
     *
     * const im = new ImReady(); // umd: eg.ImReady
     * im.check(document.querySelectorAll("img")).on({
     *   preReady: e => {
     *     // 0, 3
     *     console.log(e.readyCount, e.totalCount),
     *   },
     *   ready: e => {
     *     // 1, 3
     *     console.log(e.errorCount, e.totalCount),
     *   },
     * });
     * ```
     */
    this.trigger(new ComponentEvent$1("ready", {
      errorCount: this.getErrorCount(),
      totalErrorCount: this.totalErrorCount,
      totalCount: this.totalCount
    }));
  };

  __proto.getErrorCount = function () {
    return this.elementInfos.filter(function (info) {
      return info.hasError;
    }).length;
  };

  __proto.hasLoading = function () {
    return this.elementInfos.some(function (info) {
      return info.hasLoading;
    });
  };

  return ImReadyManager;
}(Component);

var ImageLoader =
/*#__PURE__*/
function (_super) {
  __extends$2(ImageLoader, _super);

  function ImageLoader() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  var __proto = ImageLoader.prototype;

  __proto.checkElement = function () {
    var element = this.element;
    var src = element.getAttribute("src");

    if (element.complete) {
      if (src) {
        // complete
        if (!element.naturalWidth) {
          this.onAlreadyError(element);
        }

        return false;
      } else {
        // Using an external lazy loading module
        this.onAlreadyPreReady();
      }
    }

    this.addEvents();
    IS_IE && element.setAttribute("src", src);
    return true;
  };

  ImageLoader.EVENTS = ["load", "error"];
  return ImageLoader;
}(Loader);

var VideoLoader =
/*#__PURE__*/
function (_super) {
  __extends$2(VideoLoader, _super);

  function VideoLoader() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  var __proto = VideoLoader.prototype;

  __proto.checkElement = function () {
    var element = this.element; // HAVE_NOTHING: 0, no information whether or not the audio/video is ready
    // HAVE_METADATA: 1, HAVE_METADATA - metadata for the audio/video is ready
    // HAVE_CURRENT_DATA: 2, data for the current playback position is available, but not enough data to play next frame/millisecond
    // HAVE_FUTURE_DATA: 3, data for the current and at least the next frame is available
    // HAVE_ENOUGH_DATA: 4, enough data available to start playing

    if (element.readyState >= 1) {
      return false;
    }

    if (element.error) {
      this.onAlreadyError(element);
      return false;
    }

    this.addEvents();
    return true;
  };

  VideoLoader.EVENTS = ["loadedmetadata", "error"];
  return VideoLoader;
}(Loader);

var ImReady =
/*#__PURE__*/
function (_super) {
  __extends$2(ImReady, _super);

  function ImReady(options) {
    if (options === void 0) {
      options = {};
    }

    return _super.call(this, __assign$1({
      loaders: {
        img: ImageLoader,
        video: VideoLoader
      }
    }, options)) || this;
  }

  return ImReady;
}(ImReadyManager);

/*
Copyright (c) 2015-present NAVER Corp.
name: @egjs/flicking
license: MIT
author: NAVER Corp.
repository: https://github.com/naver/egjs-flicking
version: 4.11.4
*/

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol */

var extendStatics$3 = function (d, b) {
  extendStatics$3 = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
  };
  return extendStatics$3(d, b);
};
function __extends$3(d, b) {
  if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics$3(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign$2 = function () {
  __assign$2 = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign$2.apply(this, arguments);
};
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = {
      label: 0,
      sent: function () {
        if (t[0] & 1) throw t[1];
        return t[1];
      },
      trys: [],
      ops: []
    },
    f,
    y,
    t,
    g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;
  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return {
            value: op[1],
            done: false
          };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
}
function __values$1(o) {
  var s = typeof Symbol === "function" && Symbol.iterator,
    m = s && o[s],
    i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function () {
      if (o && i >= o.length) o = void 0;
      return {
        value: o && o[i++],
        done: !o
      };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read$1(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o),
    r,
    ar = [],
    e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = {
      error: error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
}

/** @deprecated */
function __spread$1() {
  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read$1(arguments[i]));
  return ar;
}
typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

/*
 * Copyright (c) 2015 NAVER Corp.
 * egjs projects are licensed under the MIT license
 */
/* eslint-disable @typescript-eslint/restrict-template-expressions */
/**
 * Error codes of {@link FlickingError}. Below are the conditions where each error code occurs.
 * @ko {@link FlickingError}의 에러 코드. 아래는 각각의 에러 코드가 발생하는 조건입니다.
 * @name ERROR_CODE
 * @constant
 * @type object
 * @property {number} WRONG_TYPE Parameter type is wrong<ko>패러미터의 타입이 잘못되었을 경우</ko>
 * @property {number} ELEMENT_NOT_FOUND Element is not found inside page with the given CSS selector<ko>주어진 CSS selector로 페이지 내에서 해당 엘리먼트를 찾지 못했을 경우</ko>
 * @property {number} VAL_MUST_NOT_NULL Expected non-null value, but given `null` or `undefined`<ko>값을 기대했으나, `null`이나 `undefined`를 받은 경우</ko>
 * @property {number} NOT_ATTACHED_TO_FLICKING When Flicking's component is not initialized (i.e. {@link Flicking#init} is not called)<ko>Flicking 내부 컴포넌트가 초기화되지 않은 경우 ({@link Flicking#init}이 호출되지 않은 경우)</ko>
 * @property {number} WRONG_OPTION One of the options is wrong<ko>옵션들 중 잘못된 값이 있을 때</ko>
 * @property {number} INDEX_OUT_OF_RANGE When the given index is out of possible range<ko>인덱스가 주어진 범위를 벗어난 경우</ko>
 * @property {number} POSITION_NOT_REACHABLE When {@link Control#moveToPosition}'s position parameter is out of possible range.<ko>{@link Control#moveToPosition}의 `position` 패러미터가 도달 가능한 범위를 벗어난 경우</ko>
 * @property {number} TRANSFORM_NOT_SUPPORTED CSS `transform` property is not available(<=IE8) <ko>CSS `transform` 속성을 사용할 수 없는 경우(<=IE8)</ko>
 * @property {number} STOP_CALLED_BY_USER When the event's `stop()` is called by user.<ko>사용자에 의해 이벤트의 `stop()`이 호출된 경우</ko>
 * @property {number} ANIMATION_INTERRUPTED When the animation is interrupted by user.<ko>사용자에 의해 애니메이션이 중단된 경우</ko>
 * @property {number} ANIMATION_ALREADY_PLAYING When the animation is already playing.<ko>현재 애니메이션이 이미 진행중인 경우</ko>
 * @property {number} NOT_ALLOWED_IN_FRAMEWORK When the non-allowed method is called from frameworks (React, Angular, Vue...)
 * <ko>프레임워크(React, Angular, Vue ...)에서 사용 불가능한 메소드를 호출했을 경우</ko>
 * @property {number} NOT_INITIALIZED When the {@link Flicking#init} is not called before but is needed<ko>{@link Flicking#init}의 호출이 필요하나, 아직 호출되지 않았을 경우</ko>
 * @property {number} NO_ACTIVE When there're no active panel that flicking has selected. This may be due to the absence of any panels<ko>현재 Flicking이 선택한 패널이 없을 경우. 일반적으로 패널이 하나도 없는 경우에 발생할 수 있습니다</ko>
 * @property {number} NOT_ALLOWED_IN_VIRTUAL When the non-allowed method is called while the virtual option is enabled<ko>virtual 옵션이 활성화된 상태에서 사용 불가능한 메소드가 호출되었을 경우</ko>
 */
var CODE = {
  WRONG_TYPE: 0,
  ELEMENT_NOT_FOUND: 1,
  VAL_MUST_NOT_NULL: 2,
  NOT_ATTACHED_TO_FLICKING: 3,
  WRONG_OPTION: 4,
  INDEX_OUT_OF_RANGE: 5,
  POSITION_NOT_REACHABLE: 6,
  TRANSFORM_NOT_SUPPORTED: 7,
  STOP_CALLED_BY_USER: 8,
  ANIMATION_INTERRUPTED: 9,
  ANIMATION_ALREADY_PLAYING: 10,
  NOT_ALLOWED_IN_FRAMEWORK: 11,
  NOT_INITIALIZED: 12,
  NO_ACTIVE: 13,
  NOT_ALLOWED_IN_VIRTUAL: 14
};
var MESSAGE = {
  WRONG_TYPE: function (wrongVal, correctTypes) {
    return wrongVal + "(" + typeof wrongVal + ") is not a " + correctTypes.map(function (type) {
      return "\"" + type + "\"";
    }).join(" or ") + ".";
  },
  ELEMENT_NOT_FOUND: function (selector) {
    return "Element with selector \"" + selector + "\" not found.";
  },
  VAL_MUST_NOT_NULL: function (val, name) {
    return name + " should be provided. Given: " + val;
  },
  NOT_ATTACHED_TO_FLICKING: "This module is not attached to the Flicking instance. \"init()\" should be called first.",
  WRONG_OPTION: function (optionName, val) {
    return "Option \"" + optionName + "\" is not in correct format, given: " + val;
  },
  INDEX_OUT_OF_RANGE: function (val, min, max) {
    return "Index \"" + val + "\" is out of range: should be between " + min + " and " + max + ".";
  },
  POSITION_NOT_REACHABLE: function (position) {
    return "Position \"" + position + "\" is not reachable.";
  },
  TRANSFORM_NOT_SUPPORTED: "Browser does not support CSS transform.",
  STOP_CALLED_BY_USER: "Event stop() is called by user.",
  ANIMATION_INTERRUPTED: "Animation is interrupted by user input.",
  ANIMATION_ALREADY_PLAYING: "Animation is already playing.",
  NOT_ALLOWED_IN_FRAMEWORK: "This behavior is not allowed in the frameworks like React, Vue, or Angular.",
  NOT_INITIALIZED: "Flicking is not initialized yet, call init() first.",
  NO_ACTIVE: "There's no active panel that Flicking has selected. This may be due to the absence of any panels.",
  NOT_ALLOWED_IN_VIRTUAL: "This behavior is not allowed when the virtual option is enabled"
};

/*
 * Copyright (c) 2015 NAVER Corp.
 * egjs projects are licensed under the MIT license
 */
/**
 * Event type object with event name strings of {@link Flicking}
 * @ko {@link Flicking}의 이벤트 이름 문자열들을 담은 객체
 * @type {object}
 * @property {"holdStart"} HOLD_START holdStart event<ko>holdStart 이벤트</ko>
 * @property {"holdEnd"} HOLD_END holdEnd event<ko>holdEnd 이벤트</ko>
 * @property {"moveStart"} MOVE_START moveStart event<ko>moveStart 이벤트</ko>
 * @property {"move"} MOVE move event<ko>move 이벤트</ko>
 * @property {"moveEnd"} MOVE_END moveEnd event<ko>moveEnd 이벤트</ko>
 * @property {"willChange"} WILL_CHANGE willChange event<ko>willChange 이벤트</ko>
 * @property {"changed"} CHANGED changed event<ko>changed 이벤트</ko>
 * @property {"willRestore"} WILL_RESTORE willRestore event<ko>willRestore 이벤트</ko>
 * @property {"restored"} RESTORED restored event<ko>restored 이벤트</ko>
 * @property {"select"} SELECT select event<ko>select 이벤트</ko>
 * @property {"needPanel"} NEED_PANEL needPanel event<ko>needPanel 이벤트</ko>
 * @property {"panelChange"} PANEL_CHANGE panelChange event<ko>panelChange 이벤트</ko>
 * @example
 * ```ts
 * import { EVENTS } from "@egjs/flicking";
 * EVENTS.MOVE_START; // "moveStart"
 * ```
 */
var EVENTS = {
  READY: "ready",
  BEFORE_RESIZE: "beforeResize",
  AFTER_RESIZE: "afterResize",
  HOLD_START: "holdStart",
  HOLD_END: "holdEnd",
  MOVE_START: "moveStart",
  MOVE: "move",
  MOVE_END: "moveEnd",
  WILL_CHANGE: "willChange",
  CHANGED: "changed",
  WILL_RESTORE: "willRestore",
  RESTORED: "restored",
  SELECT: "select",
  NEED_PANEL: "needPanel",
  VISIBLE_CHANGE: "visibleChange",
  REACH_EDGE: "reachEdge",
  PANEL_CHANGE: "panelChange"
};
/**
 * An object with all possible predefined literal string for the {@link Flicking#align align} option
 * @ko {@link Flicking#align align} 옵션에 사용되는 미리 정의된 리터럴 상수들을 담고 있는 객체
 * @type {object}
 * @property {"prev"} PREV left/top align<ko>좌/상 정렬</ko>
 * @property {"center"} CENTER center align<ko>중앙 정렬</ko>
 * @property {"next"} NEXT right/bottom align<ko>우/하 정렬</ko>
 */
var ALIGN = {
  PREV: "prev",
  CENTER: "center",
  NEXT: "next"
};
/**
 * An object of directions
 * @ko 방향을 나타내는 값들을 담고 있는 객체
 * @type {object}
 * @property {"PREV"} PREV "left" when {@link Flicking#horizontal horizontal} is true, and "top" when {@link Flicking#horizontal horizontal} is false
 * <ko>{@link Flicking#horizontal horizontal}가 `true`일 경우 왼쪽, {@link Flicking#horizontal horizontal}가 `false`일 경우 위쪽을 의미합니다</ko>
 * @property {"NEXT"} NEXT "right" when {@link Flicking#horizontal horizontal} is true, and "bottom" when {@link Flicking#horizontal horizontal} is false
 * <ko>{@link Flicking#horizontal horizontal}가 `true`일 경우 오른쪽, {@link Flicking#horizontal horizontal}가 `false`일 경우 아래쪽을 의미합니다</ko>
 * @property {null} NONE This value usually means it's the same position<ko>주로 제자리인 경우를 의미합니다</ko>
 */
var DIRECTION = {
  PREV: "PREV",
  NEXT: "NEXT",
  NONE: null
};
/**
 * An object with all possible {@link Flicking#moveType moveType}s
 * @ko Flicking이 제공하는 {@link Flicking#moveType moveType}들을 담고 있는 객체
 * @type {object}
 * @property {"snap"} SNAP Flicking's {@link Flicking#moveType moveType} that enables {@link SnapControl} as a Flicking's {@link Flicking#control control}
 * <ko>Flicking의 {@link Flicking#control control}을 {@link SnapControl}로 설정하게 하는 {@link Flicking#moveType moveType}</ko>
 * @property {"freeScroll"} FREE_SCROLL Flicking's {@link Flicking#moveType moveType} that enables {@link FreeControl} as a Flicking's {@link Flicking#control control}
 * <ko>Flicking의 {@link Flicking#control control}을 {@link FreeControl}로 설정하게 하는 {@link Flicking#moveType moveType}</ko>
 * @property {"strict"} STRICT Flicking's {@link Flicking#moveType moveType} that enables {@link StrictControl} as a Flicking's {@link Flicking#control control}
 * <ko>Flicking의 {@link Flicking#control control}을 {@link StrictControl}로 설정하게 하는 {@link Flicking#moveType moveType}</ko>
 */
var MOVE_TYPE = {
  SNAP: "snap",
  FREE_SCROLL: "freeScroll",
  STRICT: "strict"
};
var CLASS = {
  VERTICAL: "vertical",
  HIDDEN: "flicking-hidden",
  DEFAULT_VIRTUAL: "flicking-panel"
};
/**
 * An object with all possible {@link Flicking#circularFallback circularFallback}s
 * @ko Flicking의 {@link Flicking#circularFallback circularFallback}에 설정 가능한 값들을 담고 있는 객체
 * @type {object}
 * @property {string} LINEAR "linear"
 * @property {string} BOUND "bound"
 */
var CIRCULAR_FALLBACK = {
  LINEAR: "linear",
  BOUND: "bound"
};
/**
 * An object for identifying {@link https://developer.mozilla.org/en-US/docs/Web/CSS/direction direction} CSS property applied to the camera element(`.flicking-camera`)
 * @ko 카메라 엘리먼트(`.flicking-camera`)에 적용된 {@link https://developer.mozilla.org/en-US/docs/Web/CSS/direction direction} CSS 속성을 구분하기 위한 객체
 * @type {object}
 * @property {string} LTR "ltr"
 * @property {string} RTL "rtl"
 */
var ORDER = {
  LTR: "ltr",
  RTL: "rtl"
};

// eslint-disable-next-line @typescript-eslint/ban-types
var merge = function (target) {
  var sources = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    sources[_i - 1] = arguments[_i];
  }
  sources.forEach(function (source) {
    Object.keys(source).forEach(function (key) {
      target[key] = source[key];
    });
  });
  return target;
};
var getElement = function (el, parent) {
  var targetEl = null;
  if (isString(el)) {
    var parentEl = parent ? parent : document;
    var queryResult = parentEl.querySelector(el);
    if (!queryResult) {
      throw new FlickingError(MESSAGE.ELEMENT_NOT_FOUND(el), CODE.ELEMENT_NOT_FOUND);
    }
    targetEl = queryResult;
  } else if (el && el.nodeType === Node.ELEMENT_NODE) {
    targetEl = el;
  }
  if (!targetEl) {
    throw new FlickingError(MESSAGE.WRONG_TYPE(el, ["HTMLElement", "string"]), CODE.WRONG_TYPE);
  }
  return targetEl;
};
var checkExistence = function (value, nameOnErrMsg) {
  if (value == null) {
    throw new FlickingError(MESSAGE.VAL_MUST_NOT_NULL(value, nameOnErrMsg), CODE.VAL_MUST_NOT_NULL);
  }
};
var clamp$1 = function (x, min, max) {
  return Math.max(Math.min(x, max), min);
};
var getFlickingAttached = function (val) {
  if (!val) {
    throw new FlickingError(MESSAGE.NOT_ATTACHED_TO_FLICKING, CODE.NOT_ATTACHED_TO_FLICKING);
  }
  return val;
};
var toArray$2 = function (iterable) {
  return [].slice.call(iterable);
};
var parseAlign$1 = function (align, size) {
  var alignPoint;
  if (isString(align)) {
    switch (align) {
      case ALIGN.PREV:
        alignPoint = 0;
        break;
      case ALIGN.CENTER:
        alignPoint = 0.5 * size;
        break;
      case ALIGN.NEXT:
        alignPoint = size;
        break;
      default:
        alignPoint = parseArithmeticSize(align, size);
        if (alignPoint == null) {
          throw new FlickingError(MESSAGE.WRONG_OPTION("align", align), CODE.WRONG_OPTION);
        }
    }
  } else {
    alignPoint = align;
  }
  return alignPoint;
};
var parseBounce = function (bounce, size) {
  var parsedBounce;
  if (Array.isArray(bounce)) {
    parsedBounce = bounce.map(function (val) {
      return parseArithmeticSize(val, size);
    });
  } else {
    var parsedVal = parseArithmeticSize(bounce, size);
    parsedBounce = [parsedVal, parsedVal];
  }
  return parsedBounce.map(function (val) {
    if (val == null) {
      throw new FlickingError(MESSAGE.WRONG_OPTION("bounce", bounce), CODE.WRONG_OPTION);
    }
    return val;
  });
};
var parseArithmeticSize = function (cssValue, base) {
  var parsed = parseArithmeticExpression(cssValue);
  if (parsed == null) return null;
  return parsed.percentage * base + parsed.absolute;
};
var parseArithmeticExpression = function (cssValue) {
  var cssRegex = /(?:(\+|\-)\s*)?(\d+(?:\.\d+)?(%|px)?)/g;
  if (typeof cssValue === "number") {
    return {
      percentage: 0,
      absolute: cssValue
    };
  }
  var parsed = {
    percentage: 0,
    absolute: 0
  };
  var idx = 0;
  var matchResult = cssRegex.exec(cssValue);
  while (matchResult != null) {
    var sign = matchResult[1];
    var value = matchResult[2];
    var unit = matchResult[3];
    var parsedValue = parseFloat(value);
    if (idx <= 0) {
      sign = sign || "+";
    }
    // Return default value for values not in good form
    if (!sign) {
      return null;
    }
    var signMultiplier = sign === "+" ? 1 : -1;
    if (unit === "%") {
      parsed.percentage += signMultiplier * (parsedValue / 100);
    } else {
      parsed.absolute += signMultiplier * parsedValue;
    }
    // Match next occurrence
    ++idx;
    matchResult = cssRegex.exec(cssValue);
  }
  // None-matched
  if (idx === 0) {
    return null;
  }
  return parsed;
};
var parseCSSSizeValue = function (val) {
  return isString(val) ? val : val + "px";
};
var parsePanelAlign = function (align) {
  return typeof align === "object" ? align.panel : align;
};
var getDirection$1 = function (start, end) {
  if (start === end) return DIRECTION.NONE;
  return start < end ? DIRECTION.NEXT : DIRECTION.PREV;
};
var parseElement = function (element) {
  if (!Array.isArray(element)) {
    element = [element];
  }
  var elements = [];
  element.forEach(function (el) {
    if (isString(el)) {
      var tempDiv = document.createElement("div");
      tempDiv.innerHTML = el;
      elements.push.apply(elements, __spread$1(toArray$2(tempDiv.children)));
      while (tempDiv.firstChild) {
        tempDiv.removeChild(tempDiv.firstChild);
      }
    } else if (el && el.nodeType === Node.ELEMENT_NODE) {
      elements.push(el);
    } else {
      throw new FlickingError(MESSAGE.WRONG_TYPE(el, ["HTMLElement", "string"]), CODE.WRONG_TYPE);
    }
  });
  return elements;
};
var getMinusCompensatedIndex = function (idx, max) {
  return idx < 0 ? clamp$1(idx + max, 0, max) : clamp$1(idx, 0, max);
};
var includes = function (array, target) {
  var e_1, _a;
  try {
    for (var array_1 = __values$1(array), array_1_1 = array_1.next(); !array_1_1.done; array_1_1 = array_1.next()) {
      var val = array_1_1.value;
      if (val === target) return true;
    }
  } catch (e_1_1) {
    e_1 = {
      error: e_1_1
    };
  } finally {
    try {
      if (array_1_1 && !array_1_1.done && (_a = array_1.return)) _a.call(array_1);
    } finally {
      if (e_1) throw e_1.error;
    }
  }
  return false;
};
var isString = function (val) {
  return typeof val === "string";
};
var circulatePosition = function (pos, min, max) {
  var size = max - min;
  if (pos < min) {
    var offset = (min - pos) % size;
    pos = max - offset;
  } else if (pos > max) {
    var offset = (pos - max) % size;
    pos = min + offset;
  }
  return pos;
};
var find$1 = function (array, checker) {
  var e_2, _a;
  try {
    for (var array_2 = __values$1(array), array_2_1 = array_2.next(); !array_2_1.done; array_2_1 = array_2.next()) {
      var val = array_2_1.value;
      if (checker(val)) {
        return val;
      }
    }
  } catch (e_2_1) {
    e_2 = {
      error: e_2_1
    };
  } finally {
    try {
      if (array_2_1 && !array_2_1.done && (_a = array_2.return)) _a.call(array_2);
    } finally {
      if (e_2) throw e_2.error;
    }
  }
  return null;
};
var findRight = function (array, checker) {
  for (var idx = array.length - 1; idx >= 0; idx--) {
    var val = array[idx];
    if (checker(val)) {
      return val;
    }
  }
  return null;
};
var findIndex = function (array, checker) {
  for (var idx = 0; idx < array.length; idx++) {
    if (checker(array[idx])) {
      return idx;
    }
  }
  return -1;
};
var getProgress = function (pos, prev, next) {
  return (pos - prev) / (next - prev);
};
// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
var getStyle = function (el) {
  return window.getComputedStyle(el) || el.currentStyle;
};
var setSize = function (el, _a) {
  var width = _a.width,
    height = _a.height;
  if (width != null) {
    if (isString(width)) {
      el.style.width = width;
    } else {
      el.style.width = width + "px";
    }
  }
  if (height != null) {
    if (isString(height)) {
      el.style.height = height;
    } else {
      el.style.height = height + "px";
    }
  }
};
var isBetween = function (val, min, max) {
  return val >= min && val <= max;
};
var circulateIndex = function (index, max) {
  if (index >= max) {
    return index % max;
  } else if (index < 0) {
    return getMinusCompensatedIndex((index + 1) % max - 1, max);
  } else {
    return index;
  }
};
var range = function (end) {
  var arr = new Array(end);
  for (var i = 0; i < end; i++) {
    arr[i] = i;
  }
  return arr;
};
var getElementSize = function (_a) {
  var el = _a.el,
    horizontal = _a.horizontal,
    useFractionalSize = _a.useFractionalSize,
    useOffset = _a.useOffset,
    style = _a.style;
  var size = 0;
  if (useFractionalSize) {
    var baseSize = parseFloat(horizontal ? style.width : style.height) || 0;
    var isBorderBoxSizing = style.boxSizing === "border-box";
    var border = horizontal ? parseFloat(style.borderLeftWidth || "0") + parseFloat(style.borderRightWidth || "0") : parseFloat(style.borderTopWidth || "0") + parseFloat(style.borderBottomWidth || "0");
    if (isBorderBoxSizing) {
      size = useOffset ? baseSize : baseSize - border;
    } else {
      var padding = horizontal ? parseFloat(style.paddingLeft || "0") + parseFloat(style.paddingRight || "0") : parseFloat(style.paddingTop || "0") + parseFloat(style.paddingBottom || "0");
      size = useOffset ? baseSize + padding + border : baseSize + padding;
    }
  } else {
    var sizeStr = horizontal ? "Width" : "Height";
    size = useOffset ? el["offset" + sizeStr] : el["client" + sizeStr];
  }
  return Math.max(size, 0);
};
var setPrototypeOf = Object.setPrototypeOf || function (obj, proto) {
  obj.__proto__ = proto;
  return obj;
};

/*
 * Copyright (c) 2015 NAVER Corp.
 * egjs projects are licensed under the MIT license
 */
/**
 * Special type of known error that {@link Flicking} throws.
 * @ko Flicking 내부에서 알려진 오류 발생시 throw되는 에러
 * @property {number} code Error code<ko>에러 코드</ko>
 * @property {string} message Error message<ko>에러 메시지</ko>
 * @see {@link ERROR_CODE ERROR_CODE}
 * @example
 * ```ts
 * import Flicking, { FlickingError, ERROR_CODES } from "@egjs/flicking";
 * try {
 *   const flicking = new Flicking(".flicking-viewport")
 * } catch (e) {
 *   if (e instanceof FlickingError && e.code === ERROR_CODES.ELEMENT_NOT_FOUND) {
 *     console.error("Element not found")
 *   }
 * }
 * ```
 */
var FlickingError = /*#__PURE__*/function (_super) {
  __extends$3(FlickingError, _super);
  /**
   * @param message Error message<ko>에러 메시지</ko>
   * @param code Error code<ko>에러 코드</ko>
   */
  function FlickingError(message, code) {
    var _this = _super.call(this, message) || this;
    setPrototypeOf(_this, FlickingError.prototype);
    _this.name = "FlickingError";
    _this.code = code;
    return _this;
  }
  return FlickingError;
}(Error);

/**
 * A component that manages viewport size
 * @ko 뷰포트 크기 정보를 담당하는 컴포넌트
 */
var Viewport = /*#__PURE__*/function () {
  /**
   * @param el A viewport element<ko>뷰포트 엘리먼트</ko>
   */
  function Viewport(flicking, el) {
    this._flicking = flicking;
    this._el = el;
    this._width = 0;
    this._height = 0;
    this._padding = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    };
    this._isBorderBoxSizing = false;
  }
  var __proto = Viewport.prototype;
  Object.defineProperty(__proto, "element", {
    /**
     * A viewport(root) element
     * @ko 뷰포트(root) 엘리먼트
     * @type {HTMLElement}
     * @readonly
     */
    get: function () {
      return this._el;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "width", {
    /**
     * Viewport width, without paddings
     * @ko 뷰포트 너비
     * @type {number}
     * @readonly
     */
    get: function () {
      return this._width - this._padding.left - this._padding.right;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "height", {
    /**
     * Viewport height, without paddings
     * @ko 뷰포트 높이
     * @type {number}
     * @readonly
     */
    get: function () {
      return this._height - this._padding.top - this._padding.bottom;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "padding", {
    /**
     * Viewport paddings
     * @ko 뷰포트 CSS padding 값
     * @type {object}
     * @property {number} left CSS `padding-left`
     * @property {number} right CSS `padding-right`
     * @property {number} top CSS `padding-top`
     * @property {number} bottom CSS `padding-bottom`
     * @readonly
     */
    get: function () {
      return this._padding;
    },
    enumerable: false,
    configurable: true
  });
  /**
   * Change viewport's size.
   * This will change the actual size of `.flicking-viewport` element by changing its CSS width/height property
   * @ko 뷰포트 크기를 변경합니다.
   * `.flicking-viewport` 엘리먼트에 해당 크기의 CSS width/height를 적용합니다
   * @param {object} [size] New viewport size<ko>새 뷰포트 크기</ko>
   * @param {number|string} [size.width] CSS string or number(in px)<ko>CSS 문자열 또는 숫자(px)</ko>
   * @param {number|string} [size.height] CSS string or number(in px)<ko>CSS 문자열 또는 숫자(px)</ko>
   */
  __proto.setSize = function (_a) {
    var width = _a.width,
      height = _a.height;
    var el = this._el;
    var padding = this._padding;
    var isBorderBoxSizing = this._isBorderBoxSizing;
    if (width != null) {
      if (isString(width)) {
        el.style.width = width;
      } else {
        var newWidth = isBorderBoxSizing ? width + padding.left + padding.right : width;
        el.style.width = newWidth + "px";
      }
    }
    if (height != null) {
      if (isString(height)) {
        el.style.height = height;
      } else {
        var newHeight = isBorderBoxSizing ? height + padding.top + padding.bottom : height;
        el.style.height = newHeight + "px";
      }
    }
    this.resize();
  };
  /**
   * Update width/height to the current viewport element's size
   * @ko 현재 뷰포트 엘리먼트의 크기로 너비/높이를 업데이트합니다
   */
  __proto.resize = function () {
    var el = this._el;
    var elStyle = getStyle(el);
    var useFractionalSize = this._flicking.useFractionalSize;
    this._width = getElementSize({
      el: el,
      horizontal: true,
      useFractionalSize: useFractionalSize,
      useOffset: false,
      style: elStyle
    });
    this._height = getElementSize({
      el: el,
      horizontal: false,
      useFractionalSize: useFractionalSize,
      useOffset: false,
      style: elStyle
    });
    this._padding = {
      left: elStyle.paddingLeft ? parseFloat(elStyle.paddingLeft) : 0,
      right: elStyle.paddingRight ? parseFloat(elStyle.paddingRight) : 0,
      top: elStyle.paddingTop ? parseFloat(elStyle.paddingTop) : 0,
      bottom: elStyle.paddingBottom ? parseFloat(elStyle.paddingBottom) : 0
    };
    this._isBorderBoxSizing = elStyle.boxSizing === "border-box";
  };
  return Viewport;
}();

var AutoResizer = /*#__PURE__*/function () {
  function AutoResizer(flicking) {
    var _this = this;
    this._onResize = function () {
      var flicking = _this._flicking;
      var resizeDebounce = flicking.resizeDebounce;
      var maxResizeDebounce = flicking.maxResizeDebounce;
      if (resizeDebounce <= 0) {
        void flicking.resize();
      } else {
        if (_this._maxResizeDebounceTimer <= 0) {
          if (maxResizeDebounce > 0 && maxResizeDebounce >= resizeDebounce) {
            _this._maxResizeDebounceTimer = window.setTimeout(_this._doScheduledResize, maxResizeDebounce);
          }
        }
        if (_this._resizeTimer > 0) {
          clearTimeout(_this._resizeTimer);
          _this._resizeTimer = 0;
        }
        _this._resizeTimer = window.setTimeout(_this._doScheduledResize, resizeDebounce);
      }
    };
    this._doScheduledResize = function () {
      clearTimeout(_this._resizeTimer);
      clearTimeout(_this._maxResizeDebounceTimer);
      _this._maxResizeDebounceTimer = -1;
      _this._resizeTimer = -1;
      void _this._flicking.resize();
    };
    // eslint-disable-next-line @typescript-eslint/member-ordering
    this._skipFirstResize = function () {
      var isFirstResize = true;
      return function () {
        if (isFirstResize) {
          isFirstResize = false;
          return;
        }
        _this._onResize();
      };
    }();
    this._flicking = flicking;
    this._enabled = false;
    this._resizeObserver = null;
    this._resizeTimer = -1;
    this._maxResizeDebounceTimer = -1;
  }
  var __proto = AutoResizer.prototype;
  Object.defineProperty(__proto, "enabled", {
    get: function () {
      return this._enabled;
    },
    enumerable: false,
    configurable: true
  });
  __proto.enable = function () {
    var flicking = this._flicking;
    var viewport = flicking.viewport;
    if (this._enabled) {
      this.disable();
    }
    if (flicking.useResizeObserver && !!window.ResizeObserver) {
      var viewportSizeNot0 = viewport.width !== 0 || viewport.height !== 0;
      var resizeObserver = viewportSizeNot0 ? new ResizeObserver(this._skipFirstResize) : new ResizeObserver(this._onResize);
      resizeObserver.observe(flicking.viewport.element);
      this._resizeObserver = resizeObserver;
    } else {
      window.addEventListener("resize", this._onResize);
    }
    this._enabled = true;
    return this;
  };
  __proto.disable = function () {
    if (!this._enabled) return this;
    var resizeObserver = this._resizeObserver;
    if (resizeObserver) {
      resizeObserver.disconnect();
      this._resizeObserver = null;
    } else {
      window.removeEventListener("resize", this._onResize);
    }
    this._enabled = false;
    return this;
  };
  return AutoResizer;
}();

/**
 * @internal
 */
var VanillaElementProvider = /*#__PURE__*/function () {
  function VanillaElementProvider(element) {
    this._element = element;
    this._rendered = true;
  }
  var __proto = VanillaElementProvider.prototype;
  Object.defineProperty(__proto, "element", {
    get: function () {
      return this._element;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "rendered", {
    get: function () {
      return this._rendered;
    },
    enumerable: false,
    configurable: true
  });
  __proto.show = function (flicking) {
    var el = this.element;
    var cameraEl = flicking.camera.element;
    if (el.parentElement !== cameraEl) {
      cameraEl.appendChild(el);
      this._rendered = true;
    }
  };
  __proto.hide = function (flicking) {
    var el = this.element;
    var cameraEl = flicking.camera.element;
    if (el.parentElement === cameraEl) {
      cameraEl.removeChild(el);
      this._rendered = false;
    }
  };
  return VanillaElementProvider;
}();

/*
 * Copyright (c) 2015 NAVER Corp.
 * egjs projects are licensed under the MIT license
 */
/**
 * @internal
 */
var VirtualElementProvider = /*#__PURE__*/function () {
  function VirtualElementProvider(flicking) {
    this._flicking = flicking;
  }
  var __proto = VirtualElementProvider.prototype;
  Object.defineProperty(__proto, "element", {
    get: function () {
      return this._virtualElement.nativeElement;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "rendered", {
    get: function () {
      return this._virtualElement.visible;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "_virtualElement", {
    get: function () {
      var flicking = this._flicking;
      var elIndex = this._panel.elementIndex;
      var virtualElements = flicking.virtual.elements;
      return virtualElements[elIndex];
    },
    enumerable: false,
    configurable: true
  });
  __proto.init = function (panel) {
    this._panel = panel;
  };
  __proto.show = function () {
    // DO_NOTHING
    // Actual element visibility is controlled by VirtualManager
  };
  __proto.hide = function () {
    // DO_NOTHING
    // Actual element visibility is controlled by VirtualManager
  };
  return VirtualElementProvider;
}();

/**
 * A manager class to add / remove virtual panels
 */
var VirtualManager = /*#__PURE__*/function () {
  function VirtualManager(flicking, options) {
    var _a, _b, _c, _d;
    this._flicking = flicking;
    this._renderPanel = (_a = options === null || options === void 0 ? void 0 : options.renderPanel) !== null && _a !== void 0 ? _a : function () {
      return "";
    };
    this._initialPanelCount = (_b = options === null || options === void 0 ? void 0 : options.initialPanelCount) !== null && _b !== void 0 ? _b : -1;
    this._cache = (_c = options === null || options === void 0 ? void 0 : options.cache) !== null && _c !== void 0 ? _c : false;
    this._panelClass = (_d = options === null || options === void 0 ? void 0 : options.panelClass) !== null && _d !== void 0 ? _d : CLASS.DEFAULT_VIRTUAL;
    this._elements = [];
  }
  var __proto = VirtualManager.prototype;
  Object.defineProperty(__proto, "elements", {
    get: function () {
      return this._elements;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "renderPanel", {
    // Options
    /**
     * A rendering function for the panel element's innerHTML
     * @ko 패널 엘리먼트의 innerHTML을 렌더링하는 함수
     * @type {function}
     * @param {VirtualPanel} panel Instance of the panel<ko>패널 인스턴스</ko>
     * @param {number} index Index of the panel<ko>패널 인덱스</ko>
     * @default "() => {}"
     */
    get: function () {
      return this._renderPanel;
    },
    set: function (val) {
      this._renderPanel = val;
      this._flicking.renderer.panels.forEach(function (panel) {
        return panel.uncacheRenderResult();
      });
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "initialPanelCount", {
    /**
     * Initial panel count to render
     * @ko 최초로 렌더링할 패널의 개수
     * @readonly
     * @type {number}
     * @default -1
     */
    get: function () {
      return this._initialPanelCount;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "cache", {
    /**
     * Whether to cache rendered panel's innerHTML
     * @ko 렌더링된 패널의 innerHTML 정보를 캐시할지 여부
     * @type {boolean}
     * @default false
     */
    get: function () {
      return this._cache;
    },
    set: function (val) {
      this._cache = val;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "panelClass", {
    /**
     * The class name that will be applied to rendered panel elements
     * @ko 렌더링되는 패널 엘리먼트에 적용될 클래스 이름
     * @type {string}
     * @default "flicking-panel"
     */
    get: function () {
      return this._panelClass;
    },
    set: function (val) {
      this._panelClass = val;
    },
    enumerable: false,
    configurable: true
  });
  __proto.init = function () {
    var flicking = this._flicking;
    if (!flicking.virtualEnabled) return;
    if (!flicking.externalRenderer && !flicking.renderExternal) {
      this._initVirtualElements();
    }
    var virtualElements = flicking.camera.children;
    this._elements = virtualElements.map(function (el) {
      return {
        nativeElement: el,
        visible: true
      };
    });
  };
  __proto.show = function (index) {
    var el = this._elements[index];
    var nativeEl = el.nativeElement;
    el.visible = true;
    if (nativeEl.style.display) {
      nativeEl.style.display = "";
    }
  };
  __proto.hide = function (index) {
    var el = this._elements[index];
    var nativeEl = el.nativeElement;
    el.visible = false;
    nativeEl.style.display = "none";
  };
  /**
   * Add new virtual panels at the end of the list
   * @ko 새로운 가상 패널들을 리스트의 끝에 추가합니다
   * @param {number} count The number of panels to add<ko>추가할 패널의 개수</ko>
   * @returns {Array<VirtualPanel>} The new panels added<ko>새롭게 추가된 패널들</ko>
   */
  __proto.append = function (count) {
    if (count === void 0) {
      count = 1;
    }
    var flicking = this._flicking;
    return this.insert(flicking.panels.length, count);
  };
  /**
   * Add new virtual panels at the start of the list
   * @ko 새로운 가상 패널들을 리스트의 시작에 추가합니다
   * @param {number} count The number of panels to add<ko>추가할 패널의 개수</ko>
   * @returns {Array<VirtualPanel>} The new panels added<ko>새롭게 추가된 패널들</ko>
   */
  __proto.prepend = function (count) {
    if (count === void 0) {
      count = 1;
    }
    return this.insert(0, count);
  };
  /**
   * Add new virtual panels at the given index
   * @ko 새로운 가상 패널들을 주어진 인덱스에 추가합니다
   * @param {number} count The number of panels to add<ko>추가할 패널의 개수</ko>
   * @returns {Array<VirtualPanel>} The new panels added<ko>새롭게 추가된 패널들</ko>
   */
  __proto.insert = function (index, count) {
    if (count === void 0) {
      count = 1;
    }
    if (count <= 0) return [];
    var flicking = this._flicking;
    return flicking.renderer.batchInsert({
      index: index,
      elements: range(count),
      hasDOMInElements: false
    });
  };
  /**
   * Remove panels at the given index
   * @ko 주어진 인덱스에서 패널들을 삭제합니다
   * @param {number} count The number of panels to remove<ko>삭제할 패널의 개수</ko>
   * @returns {Array<VirtualPanel>} The panels removed<ko>삭제된 패널들</ko>
   */
  __proto.remove = function (index, count) {
    if (count <= 0) return [];
    var flicking = this._flicking;
    return flicking.renderer.batchRemove({
      index: index,
      deleteCount: count,
      hasDOMInElements: false
    });
  };
  __proto._initVirtualElements = function () {
    var _this = this;
    var flicking = this._flicking;
    var cameraElement = flicking.camera.element;
    var panelsPerView = flicking.panelsPerView;
    var fragment = document.createDocumentFragment();
    var newElements = range(panelsPerView + 1).map(function (idx) {
      var panelEl = document.createElement("div");
      panelEl.className = _this._panelClass;
      panelEl.dataset.elementIndex = idx.toString();
      return panelEl;
    });
    newElements.forEach(function (el) {
      fragment.appendChild(el);
    });
    cameraElement.appendChild(fragment);
  };
  return VirtualManager;
}();

/**
 * All possible @egjs/axes event keys
 * @internal
 */
var EVENT = {
  HOLD: "hold",
  CHANGE: "change",
  RELEASE: "release",
  ANIMATION_END: "animationEnd",
  FINISH: "finish"
};
/**
 * An Axis key that Flicking uses
 * @internal
 */
var POSITION_KEY = "flick";

var STATE_TYPE;
(function (STATE_TYPE) {
  STATE_TYPE[STATE_TYPE["IDLE"] = 0] = "IDLE";
  STATE_TYPE[STATE_TYPE["HOLDING"] = 1] = "HOLDING";
  STATE_TYPE[STATE_TYPE["DRAGGING"] = 2] = "DRAGGING";
  STATE_TYPE[STATE_TYPE["ANIMATING"] = 3] = "ANIMATING";
  STATE_TYPE[STATE_TYPE["DISABLED"] = 4] = "DISABLED";
})(STATE_TYPE || (STATE_TYPE = {}));
/**
 * A component that shows the current status of the user input or the animation
 * @ko 현재 사용자 입력 또는 애니메이션 상태를 나타내는 컴포넌트
 * @internal
 */
var State = /*#__PURE__*/function () {
  function State() {
    this._delta = 0;
    this._targetPanel = null;
  }
  var __proto = State.prototype;
  Object.defineProperty(__proto, "delta", {
    /**
     * A sum of delta values of change events from the last hold event of Axes
     * @ko 이전 hold이벤트부터 change에 의해 발생한 이동 delta값의 합산
     * @type {number}
     * @readonly
     */
    get: function () {
      return this._delta;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "targetPanel", {
    /**
     * A panel to set as {@link Control#activePanel} after the animation is finished
     * @ko 애니메이션 종료시 {@link Control#activePanel}로 설정할 패널
     * @type {number}
     * @readonly
     */
    get: function () {
      return this._targetPanel;
    },
    set: function (val) {
      this._targetPanel = val;
    },
    enumerable: false,
    configurable: true
  });
  /**
   * An callback which is called when state has changed to this state
   * @ko 현재 상태로 돌입했을때 호출되는 콜백 함수
   * @param {State} prevState An previous state<ko>이전 상태값</ko>
   * @return {void}
   */
  __proto.onEnter = function (prevState) {
    this._delta = prevState._delta;
    this._targetPanel = prevState._targetPanel;
  };
  /**
   * An event handler for Axes's {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:hold hold} event
   * @ko Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:hold hold} 이벤트 핸들러
   * @param {object} [ctx] Event context<ko>이벤트 콘텍스트</ko>
   * @param {Flicking} [ctx.flicking] An instance of Flicking<ko>Flicking 인스턴스</ko>
   * @param {object} [ctx.axesEvent] A {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:hold hold} event of Axes
   * <ko>Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:hold hold} 이벤트</ko>
   * @param {function} [ctx.transitTo] A function for changing current state to other state<ko>다른 상태로 변경하기 위한 함수</ko>
   * @return {void}
   */
  __proto.onHold = function (ctx) {
    // DO NOTHING
  };
  /**
   * An event handler for Axes's {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:change change} event
   * @ko Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:change change} 이벤트 핸들러
   * @param {object} [ctx] Event context<ko>이벤트 콘텍스트</ko>
   * @param {Flicking} [ctx.flicking] An instance of Flicking<ko>Flicking 인스턴스</ko>
   * @param {object} [ctx.axesEvent] A {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:change change} event of Axes
   * <ko>Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:change change} 이벤트</ko>
   * @param {function} [ctx.transitTo] A function for changing current state to other state<ko>다른 상태로 변경하기 위한 함수</ko>
   * @return {void}
   */
  __proto.onChange = function (ctx) {
    // DO NOTHING
  };
  /**
   * An event handler for Axes's {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} event
   * @ko Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} 이벤트 핸들러
   * @param {object} [ctx] Event context<ko>이벤트 콘텍스트</ko>
   * @param {Flicking} [ctx.flicking] An instance of Flicking<ko>Flicking 인스턴스</ko>
   * @param {object} [ctx.axesEvent] A {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} event of Axes
   * <ko>Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} 이벤트</ko>
   * @param {function} [ctx.transitTo] A function for changing current state to other state<ko>다른 상태로 변경하기 위한 함수</ko>
   * @return {void}
   */
  __proto.onRelease = function (ctx) {
    // DO NOTHING
  };
  /**
   * An event handler for Axes's {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:animationEnd animationEnd} event
   * @ko Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:animationEnd animationEnd} 이벤트 핸들러
   * @param {object} [ctx] Event context<ko>이벤트 콘텍스트</ko>
   * @param {Flicking} [ctx.flicking] An instance of Flicking<ko>Flicking 인스턴스</ko>
   * @param {object} [ctx.axesEvent] A {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:animationEnd animationEnd} event of Axes
   * <ko>Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:animationEnd animationEnd} 이벤트</ko>
   * @param {function} [ctx.transitTo] A function for changing current state to other state<ko>다른 상태로 변경하기 위한 함수</ko>
   * @return {void}
   */
  __proto.onAnimationEnd = function (ctx) {
    // DO NOTHING
  };
  /**
   * An event handler for Axes's {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:finish finish} event
   * @ko Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:finish finish} 이벤트 핸들러
   * @param {object} [ctx] Event context<ko>이벤트 콘텍스트</ko>
   * @param {Flicking} [ctx.flicking] An instance of Flicking<ko>Flicking 인스턴스</ko>
   * @param {object} [ctx.axesEvent] A {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:finish finish} event of Axes<ko>Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:finish finish} 이벤트</ko>
   * @param {function} [ctx.transitTo] A function for changing current state to other state<ko>다른 상태로 변경하기 위한 함수</ko>
   * @return {void}
   */
  __proto.onFinish = function (ctx) {
    // DO NOTHING
  };
  __proto._moveToChangedPosition = function (ctx) {
    var flicking = ctx.flicking,
      axesEvent = ctx.axesEvent,
      transitTo = ctx.transitTo;
    var delta = axesEvent.delta[POSITION_KEY];
    if (!delta) {
      return;
    }
    this._delta += delta;
    var camera = flicking.camera;
    var prevPosition = camera.position;
    var position = axesEvent.pos[POSITION_KEY];
    var newPosition = flicking.circularEnabled ? circulatePosition(position, camera.range.min, camera.range.max) : position;
    camera.lookAt(newPosition);
    var moveEvent = new ComponentEvent$1(EVENTS.MOVE, {
      isTrusted: axesEvent.isTrusted,
      holding: this.holding,
      direction: getDirection$1(0, axesEvent.delta[POSITION_KEY]),
      axesEvent: axesEvent
    });
    flicking.trigger(moveEvent);
    if (moveEvent.isCanceled()) {
      // Return to previous position
      camera.lookAt(prevPosition);
      transitTo(STATE_TYPE.DISABLED);
    }
  };
  return State;
}();

/**
 * A default state when there's no user input and no animation's playing
 * @ko 사용자의 입력이 없고, 애니메이션이 동작하고있지 않은 기본 상태
 * @internal
 */
var IdleState = /*#__PURE__*/function (_super) {
  __extends$3(IdleState, _super);
  function IdleState() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    /**
     * Whether user is clicking or touching
     * @ko 현재 사용자가 클릭/터치중인지 여부
     * @type {false}
     * @readonly
     */
    _this.holding = false;
    /**
     * Whether Flicking's animating
     * @ko 현재 애니메이션 동작 여부
     * @type {false}
     * @readonly
     */
    _this.animating = false;
    return _this;
  }
  var __proto = IdleState.prototype;
  __proto.onEnter = function () {
    this._delta = 0;
    this._targetPanel = null;
  };
  __proto.onHold = function (ctx) {
    // Shouldn't do any action until any panels on flicking area
    var flicking = ctx.flicking,
      axesEvent = ctx.axesEvent,
      transitTo = ctx.transitTo;
    if (flicking.renderer.panelCount <= 0) {
      transitTo(STATE_TYPE.DISABLED);
      return;
    }
    var holdStartEvent = new ComponentEvent$1(EVENTS.HOLD_START, {
      axesEvent: axesEvent
    });
    flicking.trigger(holdStartEvent);
    if (holdStartEvent.isCanceled()) {
      transitTo(STATE_TYPE.DISABLED);
    } else {
      transitTo(STATE_TYPE.HOLDING);
    }
  };
  // By methods call
  __proto.onChange = function (ctx) {
    var flicking = ctx.flicking,
      axesEvent = ctx.axesEvent,
      transitTo = ctx.transitTo;
    var controller = flicking.control.controller;
    var animatingContext = controller.animatingContext;
    var moveStartEvent = new ComponentEvent$1(EVENTS.MOVE_START, {
      isTrusted: axesEvent.isTrusted,
      holding: this.holding,
      direction: getDirection$1(animatingContext.start, animatingContext.end),
      axesEvent: axesEvent
    });
    flicking.trigger(moveStartEvent);
    if (moveStartEvent.isCanceled()) {
      transitTo(STATE_TYPE.DISABLED);
    } else {
      // Trigger AnimatingState's onChange, to trigger "move" event immediately
      transitTo(STATE_TYPE.ANIMATING).onChange(ctx);
    }
  };
  return IdleState;
}(State);

/**
 * A state that activates when user's holding the Flicking area, but not moved a single pixel yet
 * @ko 사용자의 입력이 시작되었으나, 아직 움직이지는 않은 상태
 * @internal
 */
var HoldingState = /*#__PURE__*/function (_super) {
  __extends$3(HoldingState, _super);
  function HoldingState() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    /**
     * Whether user is clicking or touching
     * @ko 현재 사용자가 클릭/터치중인지 여부
     * @type {true}
     * @readonly
     */
    _this.holding = true;
    /**
     * Whether Flicking's animating
     * @ko 현재 애니메이션 동작 여부
     * @type {false}
     * @readonly
     */
    _this.animating = false;
    _this._releaseEvent = null;
    return _this;
  }
  var __proto = HoldingState.prototype;
  __proto.onChange = function (ctx) {
    var flicking = ctx.flicking,
      axesEvent = ctx.axesEvent,
      transitTo = ctx.transitTo;
    var inputEvent = axesEvent.inputEvent;
    var offset = flicking.horizontal ? inputEvent.offsetX : inputEvent.offsetY;
    var moveStartEvent = new ComponentEvent$1(EVENTS.MOVE_START, {
      isTrusted: axesEvent.isTrusted,
      holding: this.holding,
      direction: getDirection$1(0, -offset),
      axesEvent: axesEvent
    });
    flicking.trigger(moveStartEvent);
    if (moveStartEvent.isCanceled()) {
      transitTo(STATE_TYPE.DISABLED);
    } else {
      // Trigger DraggingState's onChange, to trigger "move" event immediately
      transitTo(STATE_TYPE.DRAGGING).onChange(ctx);
    }
  };
  __proto.onRelease = function (ctx) {
    var flicking = ctx.flicking,
      axesEvent = ctx.axesEvent,
      transitTo = ctx.transitTo;
    flicking.trigger(new ComponentEvent$1(EVENTS.HOLD_END, {
      axesEvent: axesEvent
    }));
    if (axesEvent.delta.flick !== 0) {
      // Sometimes "release" event on axes triggered before "change" event
      // Especially if user flicked panel fast in really short amount of time
      // if delta is not zero, that means above case happened.
      // Event flow should be HOLD_START -> MOVE_START -> MOVE -> HOLD_END
      // At least one move event should be included between holdStart and holdEnd
      axesEvent.setTo({
        flick: flicking.camera.position
      }, 0);
      transitTo(STATE_TYPE.IDLE);
      return;
    }
    // Can't handle select event here,
    // As "finish" axes event happens
    this._releaseEvent = axesEvent;
  };
  __proto.onFinish = function (ctx) {
    var e_1, _a;
    var flicking = ctx.flicking,
      transitTo = ctx.transitTo;
    // Should transite to IDLE state before select event
    // As user expects hold is already finished
    transitTo(STATE_TYPE.IDLE);
    if (!this._releaseEvent) {
      return;
    }
    // Handle release event here
    // To prevent finish event called twice
    var releaseEvent = this._releaseEvent;
    // Static click
    /* eslint-disable @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access */
    var srcEvent = releaseEvent.inputEvent.srcEvent;
    var clickedElement;
    if (srcEvent.type === "touchend") {
      var touchEvent = srcEvent;
      var touch = touchEvent.changedTouches[0];
      clickedElement = document.elementFromPoint(touch.clientX, touch.clientY);
    } else {
      clickedElement = srcEvent.target;
    }
    /* eslint-enable */
    var panels = flicking.renderer.panels;
    var clickedPanel = null;
    try {
      for (var panels_1 = __values$1(panels), panels_1_1 = panels_1.next(); !panels_1_1.done; panels_1_1 = panels_1.next()) {
        var panel = panels_1_1.value;
        if (panel.contains(clickedElement)) {
          clickedPanel = panel;
          break;
        }
      }
    } catch (e_1_1) {
      e_1 = {
        error: e_1_1
      };
    } finally {
      try {
        if (panels_1_1 && !panels_1_1.done && (_a = panels_1.return)) _a.call(panels_1);
      } finally {
        if (e_1) throw e_1.error;
      }
    }
    if (clickedPanel) {
      var cameraPosition = flicking.camera.position;
      var clickedPanelPosition = clickedPanel.position;
      flicking.trigger(new ComponentEvent$1(EVENTS.SELECT, {
        index: clickedPanel.index,
        panel: clickedPanel,
        // Direction to the clicked panel
        direction: getDirection$1(cameraPosition, clickedPanelPosition)
      }));
    }
  };
  return HoldingState;
}(State);

/**
 * A state that activates when user's dragging the Flicking area
 * @ko 사용자가 드래깅중인 상태
 * @internal
 */
var DraggingState = /*#__PURE__*/function (_super) {
  __extends$3(DraggingState, _super);
  function DraggingState() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    /**
     * Whether user is clicking or touching
     * @ko 현재 사용자가 클릭/터치중인지 여부
     * @type {true}
     * @readonly
     */
    _this.holding = true;
    /**
     * Whether Flicking's animating
     * @ko 현재 애니메이션 동작 여부
     * @type {true}
     * @readonly
     */
    _this.animating = true;
    return _this;
  }
  var __proto = DraggingState.prototype;
  __proto.onChange = function (ctx) {
    this._moveToChangedPosition(ctx);
  };
  __proto.onRelease = function (ctx) {
    var _a;
    var flicking = ctx.flicking,
      axesEvent = ctx.axesEvent,
      transitTo = ctx.transitTo;
    // Update last position to cope with Axes's animating behavior
    // Axes uses start position when animation start
    flicking.trigger(new ComponentEvent$1(EVENTS.HOLD_END, {
      axesEvent: axesEvent
    }));
    if (flicking.renderer.panelCount <= 0) {
      // There're no panels
      transitTo(STATE_TYPE.IDLE);
      return;
    }
    transitTo(STATE_TYPE.ANIMATING);
    var control = flicking.control;
    var position = axesEvent.destPos[POSITION_KEY];
    var duration = Math.max(axesEvent.duration, flicking.duration);
    try {
      void control.moveToPosition(position, duration, axesEvent);
    } catch (err) {
      transitTo(STATE_TYPE.IDLE);
      axesEvent.setTo((_a = {}, _a[POSITION_KEY] = flicking.camera.position, _a), 0);
    }
  };
  return DraggingState;
}(State);

/**
 * A state that activates when Flicking's animating by user input or method call
 * @ko 사용자 입력이나 메소드 호출에 의해 Flicking의 애니메이션이 동작중인 상태
 * @internal
 */
var AnimatingState = /*#__PURE__*/function (_super) {
  __extends$3(AnimatingState, _super);
  function AnimatingState() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    /**
     * Whether user is clicking or touching
     * @ko 현재 사용자가 클릭/터치중인지 여부
     * @type {false}
     * @readonly
     */
    _this.holding = false;
    /**
     * Whether Flicking's animating
     * @ko 현재 애니메이션 동작 여부
     * @type {true}
     * @readonly
     */
    _this.animating = true;
    return _this;
  }
  var __proto = AnimatingState.prototype;
  __proto.onHold = function (ctx) {
    var flicking = ctx.flicking,
      axesEvent = ctx.axesEvent,
      transitTo = ctx.transitTo;
    var targetPanel = this._targetPanel;
    var control = flicking.control;
    this._delta = 0;
    flicking.control.updateInput();
    if (flicking.changeOnHold && targetPanel) {
      control.setActive(targetPanel, control.activePanel, axesEvent.isTrusted);
    }
    var holdStartEvent = new ComponentEvent$1(EVENTS.HOLD_START, {
      axesEvent: axesEvent
    });
    flicking.trigger(holdStartEvent);
    if (holdStartEvent.isCanceled()) {
      transitTo(STATE_TYPE.DISABLED);
    } else {
      transitTo(STATE_TYPE.DRAGGING);
    }
  };
  __proto.onChange = function (ctx) {
    this._moveToChangedPosition(ctx);
  };
  __proto.onFinish = function (ctx) {
    var flicking = ctx.flicking,
      axesEvent = ctx.axesEvent,
      transitTo = ctx.transitTo;
    var control = flicking.control;
    var controller = control.controller;
    var animatingContext = controller.animatingContext;
    transitTo(STATE_TYPE.IDLE);
    flicking.trigger(new ComponentEvent$1(EVENTS.MOVE_END, {
      isTrusted: axesEvent.isTrusted,
      direction: getDirection$1(animatingContext.start, animatingContext.end),
      axesEvent: axesEvent
    }));
    var targetPanel = this._targetPanel;
    if (targetPanel) {
      control.setActive(targetPanel, control.activePanel, axesEvent.isTrusted);
    }
  };
  return AnimatingState;
}(State);

/**
 * A state that activates when Flicking is stopped by event's `stop` method
 * @ko 이벤트의 `stop`호출에 의해 Flicking이 정지된 상태
 * @internal
 */
var DisabledState = /*#__PURE__*/function (_super) {
  __extends$3(DisabledState, _super);
  function DisabledState() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    /**
     * Whether user is clicking or touching
     * @ko 현재 사용자가 클릭/터치중인지 여부
     * @type {false}
     * @readonly
     */
    _this.holding = false;
    /**
     * Whether Flicking's animating
     * @ko 현재 애니메이션 동작 여부
     * @type {true}
     * @readonly
     */
    _this.animating = true;
    return _this;
  }
  var __proto = DisabledState.prototype;
  __proto.onAnimationEnd = function (ctx) {
    var transitTo = ctx.transitTo;
    transitTo(STATE_TYPE.IDLE);
  };
  __proto.onChange = function (ctx) {
    var axesEvent = ctx.axesEvent,
      transitTo = ctx.transitTo;
    // Can stop Axes's change event
    axesEvent.stop();
    transitTo(STATE_TYPE.IDLE);
  };
  __proto.onRelease = function (ctx) {
    var axesEvent = ctx.axesEvent,
      transitTo = ctx.transitTo;
    // This is needed when stopped hold start event
    if (axesEvent.delta.flick === 0) {
      transitTo(STATE_TYPE.IDLE);
    }
  };
  return DisabledState;
}(State);

/**
 * @internal
 */
var StateMachine = /*#__PURE__*/function () {
  function StateMachine() {
    var _this = this;
    this.transitTo = function (nextStateType) {
      var nextState;
      switch (nextStateType) {
        case STATE_TYPE.IDLE:
          nextState = new IdleState();
          break;
        case STATE_TYPE.HOLDING:
          nextState = new HoldingState();
          break;
        case STATE_TYPE.DRAGGING:
          nextState = new DraggingState();
          break;
        case STATE_TYPE.ANIMATING:
          nextState = new AnimatingState();
          break;
        case STATE_TYPE.DISABLED:
          nextState = new DisabledState();
          break;
      }
      nextState.onEnter(_this._state);
      _this._state = nextState;
      return _this._state;
    };
    this._state = new IdleState();
  }
  var __proto = StateMachine.prototype;
  Object.defineProperty(__proto, "state", {
    get: function () {
      return this._state;
    },
    enumerable: false,
    configurable: true
  });
  __proto.fire = function (eventType, externalCtx) {
    var currentState = this._state;
    var ctx = __assign$2(__assign$2({}, externalCtx), {
      transitTo: this.transitTo
    });
    switch (eventType) {
      case EVENT.HOLD:
        currentState.onHold(ctx);
        break;
      case EVENT.CHANGE:
        currentState.onChange(ctx);
        break;
      case EVENT.RELEASE:
        currentState.onRelease(ctx);
        break;
      case EVENT.ANIMATION_END:
        currentState.onAnimationEnd(ctx);
        break;
      case EVENT.FINISH:
        currentState.onFinish(ctx);
        break;
    }
  };
  return StateMachine;
}();

/**
 * A controller that handles the {@link https://naver.github.io/egjs-axes/ @egjs/axes} events
 * @ko {@link https://naver.github.io/egjs-axes/ @egjs/axes}의 이벤트를 처리하는 컨트롤러 컴포넌트
 * @internal
 */
var AxesController = /*#__PURE__*/function () {
  /** */
  function AxesController() {
    var _this = this;
    this._onAxesHold = function () {
      _this._dragged = false;
    };
    this._onAxesChange = function () {
      var _a;
      _this._dragged = !!((_a = _this._panInput) === null || _a === void 0 ? void 0 : _a.isEnabled());
    };
    this._preventClickWhenDragged = function (e) {
      if (_this._dragged) {
        e.preventDefault();
        e.stopPropagation();
      }
      _this._dragged = false;
    };
    this._resetInternalValues();
    this._stateMachine = new StateMachine();
  }
  var __proto = AxesController.prototype;
  Object.defineProperty(__proto, "axes", {
    /**
     * An {@link https://naver.github.io/egjs-axes/docs/api/Axes Axes} instance
     * @ko {@link https://naver.github.io/egjs-axes/docs/api/Axes Axes}의 인스턴스
     * @type {Axes | null}
     * @see https://naver.github.io/egjs-axes/docs/api/Axes
     * @readonly
     */
    get: function () {
      return this._axes;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "panInput", {
    /**
     * An {@link https://naver.github.io/egjs-axes/docs/api/PanInput PanInput} instance
     * @ko {@link https://naver.github.io/egjs-axes/docs/api/PanInput PanInput}의 인스턴스
     * @type {PanInput | null}
     * @see https://naver.github.io/egjs-axes/docs/api/PanInput
     * @readonly
     */
    get: function () {
      return this._panInput;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "stateMachine", {
    /**
     * @internal
     */
    get: function () {
      return this._stateMachine;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "state", {
    /**
     * A activated {@link State} that shows the current status of the user input or the animation
     * @ko 현재 활성화된 {@link State} 인스턴스로 사용자 입력 또는 애니메이션 상태를 나타냅니다
     * @type {State}
     */
    get: function () {
      return this._stateMachine.state;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "animatingContext", {
    /**
     * A context of the current animation playing
     * @ko 현재 재생중인 애니메이션 정보
     * @type {object}
     * @property {number} start A start position of the animation<ko>애니메이션 시작 지점</ko>
     * @property {number} end A end position of the animation<ko>애니메이션 끝 지점</ko>
     * @property {number} offset camera offset<ko>카메라 오프셋</ko>
     * @readonly
     */
    get: function () {
      return this._animatingContext;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "controlParams", {
    /**
     * A current control parameters of the Axes instance
     * @ko 활성화된 현재 Axes 패러미터들
     * @type {ControlParams}
     */
    get: function () {
      var axes = this._axes;
      if (!axes) {
        return {
          range: {
            min: 0,
            max: 0
          },
          position: 0,
          circular: false
        };
      }
      var axis = axes.axis[POSITION_KEY];
      return {
        range: {
          min: axis.range[0],
          max: axis.range[1]
        },
        circular: axis.circular[0],
        position: this.position
      };
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "enabled", {
    /**
     * A Boolean indicating whether the user input is enabled
     * @ko 현재 사용자 입력이 활성화되었는지를 나타내는 값
     * @type {boolean}
     * @readonly
     */
    get: function () {
      var _a, _b;
      return (_b = (_a = this._panInput) === null || _a === void 0 ? void 0 : _a.isEnabled()) !== null && _b !== void 0 ? _b : false;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "position", {
    /**
     * Current position value in {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html Axes} instance
     * @ko {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html Axes} 인스턴스 내부의 현재 좌표 값
     * @type {number}
     * @readonly
     */
    get: function () {
      var _a, _b;
      return (_b = (_a = this._axes) === null || _a === void 0 ? void 0 : _a.get([POSITION_KEY])[POSITION_KEY]) !== null && _b !== void 0 ? _b : 0;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "range", {
    /**
     * Current range value in {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html Axes} instance
     * @ko {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html Axes} 인스턴스 내부의 현재 이동 범위 값
     * @type {number[]}
     * @readonly
     */
    get: function () {
      var _a, _b;
      return (_b = (_a = this._axes) === null || _a === void 0 ? void 0 : _a.axis[POSITION_KEY].range) !== null && _b !== void 0 ? _b : [0, 0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "bounce", {
    /**
     * Actual bounce size(px)
     * @ko 적용된 bounce 크기(px 단위)
     * @type {number[]}
     * @readonly
     */
    get: function () {
      var _a;
      return (_a = this._axes) === null || _a === void 0 ? void 0 : _a.axis[POSITION_KEY].bounce;
    },
    enumerable: false,
    configurable: true
  });
  /**
   * Initialize AxesController
   * @ko AxesController를 초기화합니다
   * @param {Flicking} flicking An instance of Flicking
   * @chainable
   * @return {this}
   */
  __proto.init = function (flicking) {
    var _a;
    var _this = this;
    this._flicking = flicking;
    this._axes = new Axes((_a = {}, _a[POSITION_KEY] = {
      range: [0, 0],
      circular: false,
      bounce: [0, 0]
    }, _a), {
      deceleration: flicking.deceleration,
      interruptable: flicking.interruptable,
      nested: flicking.nested,
      easing: flicking.easing
    });
    this._panInput = new PanInput(flicking.viewport.element, {
      inputType: flicking.inputType,
      threshold: 1,
      iOSEdgeSwipeThreshold: flicking.iOSEdgeSwipeThreshold,
      preventDefaultOnDrag: flicking.preventDefaultOnDrag,
      scale: flicking.horizontal ? [flicking.camera.panelOrder === ORDER.RTL ? 1 : -1, 0] : [0, -1],
      releaseOnScroll: true
    });
    var axes = this._axes;
    axes.connect(flicking.horizontal ? [POSITION_KEY, ""] : ["", POSITION_KEY], this._panInput);
    var _loop_1 = function (key) {
      var eventType = EVENT[key];
      axes.on(eventType, function (e) {
        _this._stateMachine.fire(eventType, {
          flicking: flicking,
          axesEvent: e
        });
      });
    };
    for (var key in EVENT) {
      _loop_1(key);
    }
    return this;
  };
  /**
   * Destroy AxesController and return to initial state
   * @ko AxesController를 초기 상태로 되돌립니다
   * @return {void}
   */
  __proto.destroy = function () {
    var _a;
    if (this._axes) {
      this.removePreventClickHandler();
      this._axes.destroy();
    }
    (_a = this._panInput) === null || _a === void 0 ? void 0 : _a.destroy();
    this._resetInternalValues();
  };
  /**
   * Enable input from the user (mouse/touch)
   * @ko 사용자의 입력(마우스/터치)를 활성화합니다
   * @chainable
   * @return {this}
   */
  __proto.enable = function () {
    var _a;
    (_a = this._panInput) === null || _a === void 0 ? void 0 : _a.enable();
    return this;
  };
  /**
   * Disable input from the user (mouse/touch)
   * @ko 사용자의 입력(마우스/터치)를 막습니다
   * @chainable
   * @return {this}
   */
  __proto.disable = function () {
    var _a;
    (_a = this._panInput) === null || _a === void 0 ? void 0 : _a.disable();
    return this;
  };
  /**
   * Releases ongoing user input (mouse/touch)
   * @ko 사용자의 현재 입력(마우스/터치)를 중단시킵니다
   * @chainable
   * @return {this}
   */
  __proto.release = function () {
    var _a;
    (_a = this._panInput) === null || _a === void 0 ? void 0 : _a.release();
    return this;
  };
  /**
   * Change the destination and duration of the animation currently playing
   * @ko 재생 중인 애니메이션의 목적지와 재생 시간을 변경합니다
   * @param {number} position A position to move<ko>이동할 좌표</ko>
   * @param {number} duration Duration of the animation (unit: ms)<ko>애니메이션 진행 시간 (단위: ms)</ko>
   * @chainable
   * @return {this}
   */
  __proto.updateAnimation = function (position, duration) {
    var _a;
    var _b;
    this._animatingContext = __assign$2(__assign$2({}, this._animatingContext), {
      end: position
    });
    (_b = this._axes) === null || _b === void 0 ? void 0 : _b.updateAnimation({
      destPos: (_a = {}, _a[POSITION_KEY] = position, _a),
      duration: duration
    });
    return this;
  };
  /**
   * Stops the animation currently playing
   * @ko 재생 중인 애니메이션을 중단시킵니다
   * @chainable
   * @return {this}
   */
  __proto.stopAnimation = function () {
    var _a;
    (_a = this._axes) === null || _a === void 0 ? void 0 : _a.stopAnimation();
    return this;
  };
  /**
   * Update {@link https://naver.github.io/egjs-axes/ @egjs/axes}'s state
   * @ko {@link https://naver.github.io/egjs-axes/ @egjs/axes}의 상태를 갱신합니다
   * @chainable
   * @throws {FlickingError}
   * {@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} When {@link AxesController#init init} is not called before
   * <ko>{@link AxesController#init init}이 이전에 호출되지 않은 경우</ko>
   * @return {this}
   */
  __proto.update = function (controlParams) {
    var _a;
    var flicking = getFlickingAttached(this._flicking);
    var camera = flicking.camera;
    var axes = this._axes;
    var axis = axes.axis[POSITION_KEY];
    axis.circular = [controlParams.circular, controlParams.circular];
    axis.range = [controlParams.range.min, controlParams.range.max];
    axis.bounce = parseBounce(flicking.bounce, camera.size);
    axes.axisManager.set((_a = {}, _a[POSITION_KEY] = controlParams.position, _a));
    return this;
  };
  /**
   * Attach a handler to the camera element to prevent click events during animation
   * @ko 카메라 엘리먼트에 애니메이션 도중에 클릭 이벤트를 방지하는 핸들러를 부착합니다
   * @return {this}
   */
  __proto.addPreventClickHandler = function () {
    var flicking = getFlickingAttached(this._flicking);
    var axes = this._axes;
    var cameraEl = flicking.camera.element;
    axes.on(EVENT.HOLD, this._onAxesHold);
    axes.on(EVENT.CHANGE, this._onAxesChange);
    cameraEl.addEventListener("click", this._preventClickWhenDragged, true);
    return this;
  };
  /**
   * Detach a handler to the camera element to prevent click events during animation
   * @ko 카메라 엘리먼트에 애니메이션 도중에 클릭 이벤트를 방지하는 핸들러를 탈착합니다
   * @return {this}
   */
  __proto.removePreventClickHandler = function () {
    var flicking = getFlickingAttached(this._flicking);
    var axes = this._axes;
    var cameraEl = flicking.camera.element;
    axes.off(EVENT.HOLD, this._onAxesHold);
    axes.off(EVENT.CHANGE, this._onAxesChange);
    cameraEl.removeEventListener("click", this._preventClickWhenDragged, true);
    return this;
  };
  /**
   * Run Axes's {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#setTo setTo} using the given position
   * @ko Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#setTo setTo} 메소드를 주어진 좌표를 이용하여 수행합니다
   * @param {number} position A position to move<ko>이동할 좌표</ko>
   * @param {number} duration Duration of the animation (unit: ms)<ko>애니메이션 진행 시간 (단위: ms)</ko>
   * @param {number} [axesEvent] If provided, it'll use its {@link https://naver#github#io/egjs-axes/release/latest/doc/eg#Axes#html#setTo setTo} method instead<ko>이 값이 주어졌을 경우, 해당 이벤트의 {@link https://naver#github#io/egjs-axes/release/latest/doc/eg#Axes#html#setTo setTo} 메소드를 대신해서 사용합니다.</ko>
   * @throws {FlickingError}
   * |code|condition|
   * |---|---|
   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|When {@link Control#init init} is not called before|
   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|When the animation is interrupted by user input|
   * <ko>
   *
   * |code|condition|
   * |---|---|
   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|{@link Control#init init}이 이전에 호출되지 않은 경우|
   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|사용자 입력에 의해 애니메이션이 중단된 경우|
   *
   * </ko>
   * @return {Promise<void>} A Promise which will be resolved after reaching the target position<ko>해당 좌표 도달시에 resolve되는 Promise</ko>
   */
  __proto.animateTo = function (position, duration, axesEvent) {
    var _this = this;
    var _a;
    var axes = this._axes;
    var state = this._stateMachine.state;
    if (!axes) {
      return Promise.reject(new FlickingError(MESSAGE.NOT_ATTACHED_TO_FLICKING, CODE.NOT_ATTACHED_TO_FLICKING));
    }
    var startPos = axes.get([POSITION_KEY])[POSITION_KEY];
    if (startPos === position) {
      var flicking = getFlickingAttached(this._flicking);
      flicking.camera.lookAt(position);
      if (state.targetPanel) {
        flicking.control.setActive(state.targetPanel, flicking.control.activePanel, (_a = axesEvent === null || axesEvent === void 0 ? void 0 : axesEvent.isTrusted) !== null && _a !== void 0 ? _a : false);
      }
      return Promise.resolve();
    }
    this._animatingContext = {
      start: startPos,
      end: position,
      offset: 0
    };
    var animate = function () {
      var _a, _b;
      var resetContext = function () {
        _this._animatingContext = {
          start: 0,
          end: 0,
          offset: 0
        };
      };
      axes.once(EVENT.FINISH, resetContext);
      if (axesEvent) {
        axesEvent.setTo((_a = {}, _a[POSITION_KEY] = position, _a), duration);
      } else {
        axes.setTo((_b = {}, _b[POSITION_KEY] = position, _b), duration);
      }
    };
    return new Promise(function (resolve, reject) {
      var animationFinishHandler = function () {
        axes.off(EVENT.HOLD, interruptionHandler);
        resolve();
      };
      var interruptionHandler = function () {
        axes.off(EVENT.FINISH, animationFinishHandler);
        reject(new FlickingError(MESSAGE.ANIMATION_INTERRUPTED, CODE.ANIMATION_INTERRUPTED));
      };
      axes.once(EVENT.FINISH, animationFinishHandler);
      axes.once(EVENT.HOLD, interruptionHandler);
      animate();
    });
  };
  __proto.updateDirection = function () {
    var flicking = getFlickingAttached(this._flicking);
    var axes = this._axes;
    var panInput = this._panInput;
    axes.disconnect(panInput);
    axes.connect(flicking.horizontal ? [POSITION_KEY, ""] : ["", POSITION_KEY], panInput);
    panInput.options.scale = flicking.horizontal ? [flicking.camera.panelOrder === ORDER.RTL ? 1 : -1, 0] : [0, -1];
  };
  __proto._resetInternalValues = function () {
    this._flicking = null;
    this._axes = null;
    this._panInput = null;
    this._animatingContext = {
      start: 0,
      end: 0,
      offset: 0
    };
    this._dragged = false;
  };
  return AxesController;
}();

/**
 * A component that manages inputs and animation of Flicking
 * @ko Flicking의 입력 장치 & 애니메이션을 담당하는 컴포넌트
 */
var Control = /*#__PURE__*/function () {
  /** */
  function Control() {
    this._flicking = null;
    this._controller = new AxesController();
    this._activePanel = null;
  }
  var __proto = Control.prototype;
  Object.defineProperty(__proto, "controller", {
    /**
     * A controller that handles the {@link https://naver.github.io/egjs-axes/ @egjs/axes} events
     * @ko {@link https://naver.github.io/egjs-axes/ @egjs/axes}의 이벤트를 처리하는 컨트롤러 컴포넌트
     * @type {AxesController}
     * @readonly
     */
    get: function () {
      return this._controller;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "activeIndex", {
    /**
     * Index number of the {@link Flicking#currentPanel currentPanel}
     * @ko {@link Flicking#currentPanel currentPanel}의 인덱스 번호
     * @type {number}
     * @default 0
     * @readonly
     */
    get: function () {
      var _a, _b;
      return (_b = (_a = this._activePanel) === null || _a === void 0 ? void 0 : _a.index) !== null && _b !== void 0 ? _b : -1;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "activePanel", {
    /**
     * An active panel
     * @ko 현재 선택된 패널
     * @type {Panel | null}
     * @readonly
     */
    get: function () {
      return this._activePanel;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "animating", {
    /**
     * Whether Flicking's animating
     * @ko 현재 애니메이션 동작 여부
     * @type {boolean}
     * @readonly
     */
    get: function () {
      return this._controller.state.animating;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "holding", {
    /**
     * Whether user is clicking or touching
     * @ko 현재 사용자가 클릭/터치중인지 여부
     * @type {boolean}
     * @readonly
     */
    get: function () {
      return this._controller.state.holding;
    },
    enumerable: false,
    configurable: true
  });
  /**
   * Initialize Control
   * @ko Control을 초기화합니다
   * @param {Flicking} flicking An instance of {@link Flicking}<ko>Flicking의 인스턴스</ko>
   * @chainable
   * @return {this}
   */
  __proto.init = function (flicking) {
    this._flicking = flicking;
    this._controller.init(flicking);
    return this;
  };
  /**
   * Destroy Control and return to initial state
   * @ko Control을 초기 상태로 되돌립니다
   * @return {void}
   */
  __proto.destroy = function () {
    this._controller.destroy();
    this._flicking = null;
    this._activePanel = null;
  };
  /**
   * Enable input from the user (mouse/touch)
   * @ko 사용자의 입력(마우스/터치)를 활성화합니다
   * @chainable
   * @return {this}
   */
  __proto.enable = function () {
    this._controller.enable();
    return this;
  };
  /**
   * Disable input from the user (mouse/touch)
   * @ko 사용자의 입력(마우스/터치)를 막습니다
   * @chainable
   * @return {this}
   */
  __proto.disable = function () {
    this._controller.disable();
    return this;
  };
  /**
   * Releases ongoing user input (mouse/touch)
   * @ko 사용자의 현재 입력(마우스/터치)를 중단시킵니다
   * @chainable
   * @return {this}
   */
  __proto.release = function () {
    this._controller.release();
    return this;
  };
  /**
   * Change the destination and duration of the animation currently playing
   * @ko 재생 중인 애니메이션의 목적지와 재생 시간을 변경합니다
   * @param {Panel} panel The target panel to move<ko>이동할 패널</ko>
   * @param {number} duration Duration of the animation (unit: ms)<ko>애니메이션 진행 시간 (단위: ms)</ko>
   * @param {DIRECTION} direction Direction to move, only available in the {@link Flicking#circular circular} mode<ko>이동할 방향. {@link Flicking#circular circular} 옵션 활성화시에만 사용 가능합니다</ko>
   * @chainable
   * @throws {FlickingError}
   * {@link ERROR_CODE POSITION_NOT_REACHABLE} When the given panel is already removed or not in the Camera's {@link Camera#range range}
   * <ko>{@link ERROR_CODE POSITION_NOT_REACHABLE} 주어진 패널이 제거되었거나, Camera의 {@link Camera#range range} 밖에 있을 경우</ko>
   * @return {this}
   */
  __proto.updateAnimation = function (panel, duration, direction) {
    var state = this._controller.state;
    var position = this._getPosition(panel, direction !== null && direction !== void 0 ? direction : DIRECTION.NONE);
    state.targetPanel = panel;
    this._controller.updateAnimation(position, duration);
    return this;
  };
  /**
   * Stops the animation currently playing
   * @ko 재생 중인 애니메이션을 중단시킵니다
   * @chainable
   * @return {this}
   */
  __proto.stopAnimation = function () {
    var state = this._controller.state;
    state.targetPanel = null;
    this._controller.stopAnimation();
    return this;
  };
  /**
   * Update position after resizing
   * @ko resize 이후에 position을 업데이트합니다
   * @param {number} progressInPanel Previous camera's progress in active panel before resize<ko>Resize 이전 현재 선택된 패널 내에서의 카메라 progress 값</ko>
   * @throws {FlickingError}
   * {@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} When {@link Camera#init init} is not called before
   * <ko>{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} {@link Camera#init init}이 이전에 호출되지 않은 경우</ko>
   * @chainable
   * @return {Promise<void>}
   */
  __proto.updatePosition = function (progressInPanel) {
    var flicking = getFlickingAttached(this._flicking);
    var camera = flicking.camera;
    var activePanel = this._activePanel;
    if (activePanel) {
      camera.lookAt(camera.clampToReachablePosition(activePanel.position));
    }
  };
  /**
   * Update {@link Control#controller controller}'s state
   * @ko {@link Control#controller controller}의 내부 상태를 갱신합니다
   * @chainable
   * @return {this}
   */
  __proto.updateInput = function () {
    var flicking = getFlickingAttached(this._flicking);
    var camera = flicking.camera;
    this._controller.update(camera.controlParams);
    return this;
  };
  /**
   * Reset {@link Control#activePanel activePanel} to `null`
   * @ko {@link Control#activePanel activePanel}을 `null`로 초기화합니다
   * @chainable
   * @return {this}
   */
  __proto.resetActive = function () {
    this._activePanel = null;
    return this;
  };
  /**
   * Move {@link Camera} to the given panel
   * @ko {@link Camera}를 해당 패널 위로 이동합니다
   * @param {Panel} panel The target panel to move<ko>이동할 패널</ko>
   * @param {object} options An options object<ko>옵션 오브젝트</ko>
   * @param {number} duration Duration of the animation (unit: ms)<ko>애니메이션 진행 시간 (단위: ms)</ko>
   * @param {object} [axesEvent] {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} event of {@link https://naver.github.io/egjs-axes/ Axes}
   * <ko>{@link https://naver.github.io/egjs-axes/ Axes}의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} 이벤트</ko>
   * @param {DIRECTION} [direction=DIRECTION.NONE] Direction to move, only available in the {@link Flicking#circular circular} mode<ko>이동할 방향. {@link Flicking#circular circular} 옵션 활성화시에만 사용 가능합니다</ko>
   * @fires Flicking#moveStart
   * @fires Flicking#move
   * @fires Flicking#moveEnd
   * @fires Flicking#willChange
   * @fires Flicking#changed
   * @fires Flicking#willRestore
   * @fires Flicking#restored
   * @fires Flicking#needPanel
   * @fires Flicking#visibleChange
   * @fires Flicking#reachEdge
   * @throws {FlickingError}
   * |code|condition|
   * |---|---|
   * |{@link ERROR_CODE POSITION_NOT_REACHABLE}|When the given panel is already removed or not in the Camera's {@link Camera#range range}|
   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|When {@link Control#init init} is not called before|
   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|When the animation is interrupted by user input|
   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|When the animation is interrupted by user input|
   * <ko>
   *
   * |code|condition|
   * |---|---|
   * |{@link ERROR_CODE POSITION_NOT_REACHABLE}|주어진 패널이 제거되었거나, Camera의 {@link Camera#range range} 밖에 있을 경우|
   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|{@link Control#init init}이 이전에 호출되지 않은 경우|
   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|사용자 입력에 의해 애니메이션이 중단된 경우|
   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|발생된 이벤트들 중 하나라도 `stop()`이 호출된 경우|
   *
   * </ko>
   * @return {Promise<void>} A Promise which will be resolved after reaching the target panel<ko>해당 패널 도달시에 resolve되는 Promise</ko>
   */
  __proto.moveToPanel = function (panel, _a) {
    var duration = _a.duration,
      _b = _a.direction,
      direction = _b === void 0 ? DIRECTION.NONE : _b,
      axesEvent = _a.axesEvent;
    return __awaiter(this, void 0, void 0, function () {
      var position;
      return __generator(this, function (_c) {
        position = this._getPosition(panel, direction);
        this._triggerIndexChangeEvent(panel, panel.position, axesEvent, direction);
        return [2 /*return*/, this._animateToPosition({
          position: position,
          duration: duration,
          newActivePanel: panel,
          axesEvent: axesEvent
        })];
      });
    });
  };
  /**
   * @internal
   */
  __proto.setActive = function (newActivePanel, prevActivePanel, isTrusted) {
    var _a;
    var flicking = getFlickingAttached(this._flicking);
    this._activePanel = newActivePanel;
    this._nextPanel = null;
    flicking.camera.updateAdaptiveHeight();
    if (newActivePanel !== prevActivePanel) {
      flicking.trigger(new ComponentEvent$1(EVENTS.CHANGED, {
        index: newActivePanel.index,
        panel: newActivePanel,
        prevIndex: (_a = prevActivePanel === null || prevActivePanel === void 0 ? void 0 : prevActivePanel.index) !== null && _a !== void 0 ? _a : -1,
        prevPanel: prevActivePanel,
        isTrusted: isTrusted,
        direction: prevActivePanel ? getDirection$1(prevActivePanel.position, newActivePanel.position) : DIRECTION.NONE
      }));
    } else {
      flicking.trigger(new ComponentEvent$1(EVENTS.RESTORED, {
        isTrusted: isTrusted
      }));
    }
  };
  /**
   * @internal
   */
  __proto.copy = function (control) {
    this._flicking = control._flicking;
    this._activePanel = control._activePanel;
    this._controller = control._controller;
  };
  __proto._triggerIndexChangeEvent = function (panel, position, axesEvent, direction) {
    var _a;
    var flicking = getFlickingAttached(this._flicking);
    var triggeringEvent = panel !== this._activePanel ? EVENTS.WILL_CHANGE : EVENTS.WILL_RESTORE;
    var camera = flicking.camera;
    var activePanel = this._activePanel;
    var event = new ComponentEvent$1(triggeringEvent, {
      index: panel.index,
      panel: panel,
      isTrusted: (axesEvent === null || axesEvent === void 0 ? void 0 : axesEvent.isTrusted) || false,
      direction: direction !== null && direction !== void 0 ? direction : getDirection$1((_a = activePanel === null || activePanel === void 0 ? void 0 : activePanel.position) !== null && _a !== void 0 ? _a : camera.position, position)
    });
    this._nextPanel = panel;
    flicking.trigger(event);
    if (event.isCanceled()) {
      throw new FlickingError(MESSAGE.STOP_CALLED_BY_USER, CODE.STOP_CALLED_BY_USER);
    }
  };
  __proto._animateToPosition = function (_a) {
    var position = _a.position,
      duration = _a.duration,
      newActivePanel = _a.newActivePanel,
      axesEvent = _a.axesEvent;
    return __awaiter(this, void 0, void 0, function () {
      var flicking, animate, state;
      var _this = this;
      return __generator(this, function (_b) {
        flicking = getFlickingAttached(this._flicking);
        animate = function () {
          return _this._controller.animateTo(position, duration, axesEvent);
        };
        state = this._controller.state;
        state.targetPanel = newActivePanel;
        if (duration <= 0) {
          return [2 /*return*/, animate()];
        } else {
          return [2 /*return*/, animate().then(function () {
            return __awaiter(_this, void 0, void 0, function () {
              return __generator(this, function (_a) {
                switch (_a.label) {
                  case 0:
                    return [4 /*yield*/, flicking.renderer.render()];
                  case 1:
                    _a.sent();
                    return [2 /*return*/];
                }
              });
            });
          }).catch(function (err) {
            if (axesEvent && err instanceof FlickingError && err.code === CODE.ANIMATION_INTERRUPTED) return;
            throw err;
          })];
        }
      });
    });
  };

  __proto._getPosition = function (panel, direction) {
    if (direction === void 0) {
      direction = DIRECTION.NONE;
    }
    var flicking = getFlickingAttached(this._flicking);
    var camera = flicking.camera;
    var position = panel.position;
    var nearestAnchor = camera.findNearestAnchor(position);
    if (panel.removed || !nearestAnchor) {
      throw new FlickingError(MESSAGE.POSITION_NOT_REACHABLE(panel.position), CODE.POSITION_NOT_REACHABLE);
    }
    if (!camera.canReach(panel)) {
      // Override position & panel if that panel is not reachable
      position = nearestAnchor.position;
      panel = nearestAnchor.panel;
    } else if (flicking.circularEnabled) {
      // Circular mode is enabled, find nearest distance to panel
      var camPos_1 = this._controller.position; // Actual position of the Axes
      var camRangeDiff = camera.rangeDiff;
      var possiblePositions = [position, position + camRangeDiff, position - camRangeDiff].filter(function (pos) {
        if (direction === DIRECTION.NONE) return true;
        return direction === DIRECTION.PREV ? pos <= camPos_1 : pos >= camPos_1;
      });
      position = possiblePositions.reduce(function (nearestPosition, pos) {
        if (Math.abs(camPos_1 - pos) < Math.abs(camPos_1 - nearestPosition)) {
          return pos;
        } else {
          return nearestPosition;
        }
      }, Infinity);
    }
    return position;
  };
  return Control;
}();

/**
 * A data component that has actual position where the camera should be stopped at
 * @ko 카메라가 정지해야하는 실제 위치를 담고 있는 데이터 컴포넌트
 */
var AnchorPoint = /*#__PURE__*/function () {
  /**
   * @param {object} options An options object<ko>옵션 객체</ko>
   * @param {number} [options.index] Index of AnchorPoint<ko>AnchorPoint의 인덱스</ko>
   * @param {number} [options.position] Position of AnchorPoint<ko>AnchorPoint의 좌표</ko>
   * @param {Panel} [options.panel] A {@link Panel} instance AnchorPoint is referencing to<ko>AnchorPoint가 참조하고 있는 {@link Panel}</ko>
   */
  function AnchorPoint(_a) {
    var index = _a.index,
      position = _a.position,
      panel = _a.panel;
    this._index = index;
    this._pos = position;
    this._panel = panel;
  }
  var __proto = AnchorPoint.prototype;
  Object.defineProperty(__proto, "index", {
    /**
     * Index of AnchorPoint
     * @ko AnchorPoint의 인덱스
     * @type {number}
     * @readonly
     */
    get: function () {
      return this._index;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "position", {
    /**
     * Position of AnchorPoint
     * @ko AnchorPoint의 좌표
     * @type {number}
     * @readonly
     */
    get: function () {
      return this._pos;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "panel", {
    /**
     * A {@link Panel} instance AnchorPoint is referencing to
     * @ko AnchorPoint가 참조하고 있는 {@link Panel}
     * @type {Panel}
     * @readonly
     */
    get: function () {
      return this._panel;
    },
    enumerable: false,
    configurable: true
  });
  return AnchorPoint;
}();

/**
 * A {@link Control} that uses a release momentum to choose destination panel
 * @ko 입력을 중단한 시점의 가속도에 영향받아 도달할 패널을 계산하는 이동 방식을 사용하는 {@link Control}
 */
var SnapControl = /*#__PURE__*/function (_super) {
  __extends$3(SnapControl, _super);
  /** */
  function SnapControl(_a) {
    var _b = (_a === void 0 ? {} : _a).count,
      count = _b === void 0 ? Infinity : _b;
    var _this = _super.call(this) || this;
    _this._count = count;
    return _this;
  }
  var __proto = SnapControl.prototype;
  Object.defineProperty(__proto, "count", {
    /**
     * Maximum number of panels can go after release
     * @ko 입력 중단 이후 통과하여 이동할 수 있는 패널의 최대 갯수
     * @type {number}
     * @default Infinity
     */
    get: function () {
      return this._count;
    },
    set: function (val) {
      this._count = val;
    },
    enumerable: false,
    configurable: true
  });
  /**
   * Move {@link Camera} to the given position
   * @ko {@link Camera}를 주어진 좌표로 이동합니다
   * @param {number} position The target position to move<ko>이동할 좌표</ko>
   * @param {number} duration Duration of the panel movement animation (unit: ms).<ko>패널 이동 애니메이션 진행 시간 (단위: ms)</ko>
   * @param {object} [axesEvent] {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} event of {@link https://naver.github.io/egjs-axes/ Axes}
   * <ko>{@link https://naver.github.io/egjs-axes/ Axes}의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} 이벤트</ko>
   * @fires Flicking#moveStart
   * @fires Flicking#move
   * @fires Flicking#moveEnd
   * @fires Flicking#willChange
   * @fires Flicking#changed
   * @fires Flicking#willRestore
   * @fires Flicking#restored
   * @fires Flicking#needPanel
   * @fires Flicking#visibleChange
   * @fires Flicking#reachEdge
   * @throws {FlickingError}
   * |code|condition|
   * |---|---|
   * |{@link ERROR_CODE POSITION_NOT_REACHABLE}|When the given panel is already removed or not in the Camera's {@link Camera#range range}|
   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|When {@link Control#init init} is not called before|
   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|When the animation is interrupted by user input|
   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|When the animation is interrupted by user input|
   * <ko>
   *
   * |code|condition|
   * |---|---|
   * |{@link ERROR_CODE POSITION_NOT_REACHABLE}|주어진 패널이 제거되었거나, Camera의 {@link Camera#range range} 밖에 있을 경우|
   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|{@link Control#init init}이 이전에 호출되지 않은 경우|
   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|사용자 입력에 의해 애니메이션이 중단된 경우|
   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|발생된 이벤트들 중 하나라도 `stop()`이 호출된 경우|
   *
   * </ko>
   * @return {Promise<void>} A Promise which will be resolved after reaching the target position<ko>해당 좌표 도달시에 resolve되는 Promise</ko>
   */
  __proto.moveToPosition = function (position, duration, axesEvent) {
    var flicking = getFlickingAttached(this._flicking);
    var camera = flicking.camera;
    var activeAnchor = camera.findActiveAnchor();
    var anchorAtCamera = camera.findNearestAnchor(camera.position);
    var state = this._controller.state;
    if (!activeAnchor || !anchorAtCamera) {
      return Promise.reject(new FlickingError(MESSAGE.POSITION_NOT_REACHABLE(position), CODE.POSITION_NOT_REACHABLE));
    }
    var snapThreshold = this._calcSnapThreshold(flicking.threshold, position, activeAnchor);
    var posDelta = flicking.animating ? state.delta : position - camera.position;
    var absPosDelta = Math.abs(posDelta);
    var snapDelta = axesEvent && axesEvent.delta[POSITION_KEY] !== 0 ? Math.abs(axesEvent.delta[POSITION_KEY]) : absPosDelta;
    var targetAnchor;
    if (snapDelta >= snapThreshold && snapDelta > 0) {
      // Move to anchor at position
      targetAnchor = this._findSnappedAnchor(position, anchorAtCamera);
    } else if (absPosDelta >= flicking.threshold && absPosDelta > 0) {
      // Move to the adjacent panel
      targetAnchor = this._findAdjacentAnchor(position, posDelta, anchorAtCamera);
    } else {
      // Fallback to nearest panel from current camera
      return this.moveToPanel(anchorAtCamera.panel, {
        duration: duration,
        axesEvent: axesEvent
      });
    }
    this._triggerIndexChangeEvent(targetAnchor.panel, position, axesEvent);
    return this._animateToPosition({
      position: camera.clampToReachablePosition(targetAnchor.position),
      duration: duration,
      newActivePanel: targetAnchor.panel,
      axesEvent: axesEvent
    });
  };
  __proto._findSnappedAnchor = function (position, anchorAtCamera) {
    var flicking = getFlickingAttached(this._flicking);
    var camera = flicking.camera;
    var count = this._count;
    var currentPos = camera.position;
    var clampedPosition = camera.clampToReachablePosition(position);
    var anchorAtPosition = camera.findAnchorIncludePosition(clampedPosition);
    if (!anchorAtCamera || !anchorAtPosition) {
      throw new FlickingError(MESSAGE.POSITION_NOT_REACHABLE(position), CODE.POSITION_NOT_REACHABLE);
    }
    if (!isFinite(count)) {
      return anchorAtPosition;
    }
    var panelCount = flicking.panelCount;
    var anchors = camera.anchorPoints;
    var loopCount = Math.sign(position - currentPos) * Math.floor(Math.abs(position - currentPos) / camera.rangeDiff);
    if (position > currentPos && anchorAtPosition.index < anchorAtCamera.index || anchorAtPosition.position > anchorAtCamera.position && anchorAtPosition.index === anchorAtCamera.index) {
      loopCount += 1;
    } else if (position < currentPos && anchorAtPosition.index > anchorAtCamera.index || anchorAtPosition.position < anchorAtCamera.position && anchorAtPosition.index === anchorAtCamera.index) {
      loopCount -= 1;
    }
    var circularIndexOffset = loopCount * panelCount;
    var anchorAtPositionIndex = anchorAtPosition.index + circularIndexOffset;
    if (Math.abs(anchorAtPositionIndex - anchorAtCamera.index) <= count) {
      var anchor = anchors[anchorAtPosition.index];
      return new AnchorPoint({
        index: anchor.index,
        position: anchor.position + loopCount * camera.rangeDiff,
        panel: anchor.panel
      });
    }
    if (flicking.circularEnabled) {
      var targetAnchor = anchors[circulateIndex(anchorAtCamera.index + Math.sign(position - currentPos) * count, panelCount)];
      var loop = Math.floor(count / panelCount);
      if (position > currentPos && targetAnchor.index < anchorAtCamera.index) {
        loop += 1;
      } else if (position < currentPos && targetAnchor.index > anchorAtCamera.index) {
        loop -= 1;
      }
      return new AnchorPoint({
        index: targetAnchor.index,
        position: targetAnchor.position + loop * camera.rangeDiff,
        panel: targetAnchor.panel
      });
    } else {
      return anchors[clamp$1(anchorAtCamera.index + Math.sign(position - currentPos) * count, 0, anchors.length - 1)];
    }
  };
  __proto._findAdjacentAnchor = function (position, posDelta, anchorAtCamera) {
    var _a;
    var flicking = getFlickingAttached(this._flicking);
    var camera = flicking.camera;
    if (camera.circularEnabled) {
      var anchorIncludePosition = camera.findAnchorIncludePosition(position);
      if (anchorIncludePosition && anchorIncludePosition.position !== anchorAtCamera.position) {
        return anchorIncludePosition;
      }
    }
    var adjacentAnchor = (_a = posDelta > 0 ? camera.getNextAnchor(anchorAtCamera) : camera.getPrevAnchor(anchorAtCamera)) !== null && _a !== void 0 ? _a : anchorAtCamera;
    return adjacentAnchor;
  };
  __proto._calcSnapThreshold = function (threshold, position, activeAnchor) {
    var isNextDirection = position > activeAnchor.position;
    var panel = activeAnchor.panel;
    var panelSize = panel.size;
    var alignPos = panel.alignPosition;
    // Minimum distance needed to decide prev/next panel as nearest
    /*
     * |  Prev  |     Next     |
     * |<------>|<------------>|
     * [        |<-Anchor      ]
     */
    return Math.max(threshold, isNextDirection ? panelSize - alignPos + panel.margin.next : alignPos + panel.margin.prev);
  };
  return SnapControl;
}(Control);

/**
 * A {@link Control} that can be scrolled freely without alignment
 * @ko 패널이 정해진 지점에 정렬되지 않고, 자유롭게 스크롤할 수 있는 이동 방식을 사용하는 {@link Control}
 */
var FreeControl = /*#__PURE__*/function (_super) {
  __extends$3(FreeControl, _super);
  /** */
  function FreeControl(_a) {
    var _b = (_a === void 0 ? {} : _a).stopAtEdge,
      stopAtEdge = _b === void 0 ? true : _b;
    var _this = _super.call(this) || this;
    _this._stopAtEdge = stopAtEdge;
    return _this;
  }
  var __proto = FreeControl.prototype;
  Object.defineProperty(__proto, "stopAtEdge", {
    /**
     * Make scroll animation to stop at the start/end of the scroll area, not going out the bounce area
     * @ko 스크롤 애니메이션을 스크롤 영역의 시작과 끝부분에서 멈추도록 하여, 바운스 영역을 넘어가지 않도록 합니다
     * @type {boolean}
     * @default true
     */
    get: function () {
      return this._stopAtEdge;
    },
    set: function (val) {
      this._stopAtEdge = val;
    },
    enumerable: false,
    configurable: true
  });
  /**
   * Update position after resizing
   * @ko resize 이후에 position을 업데이트합니다
   * @param {number} progressInPanel Previous camera's progress in active panel before resize<ko>Resize 이전 현재 선택된 패널 내에서의 카메라 progress 값</ko>
   * @throws {FlickingError}
   * {@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} When {@link Camera#init init} is not called before
   * <ko>{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} {@link Camera#init init}이 이전에 호출되지 않은 경우</ko>
   * @chainable
   * @return {Promise<void>}
   */
  __proto.updatePosition = function (progressInPanel) {
    var flicking = getFlickingAttached(this._flicking);
    var camera = flicking.camera;
    var activePanel = this._activePanel;
    if (activePanel) {
      var panelRange = activePanel.range;
      var newPosition = panelRange.min + (panelRange.max - panelRange.min) * progressInPanel;
      camera.lookAt(camera.clampToReachablePosition(newPosition));
    }
  };
  /**
   * Move {@link Camera} to the given position
   * @ko {@link Camera}를 주어진 좌표로 이동합니다
   * @param {number} position The target position to move<ko>이동할 좌표</ko>
   * @param {number} duration Duration of the panel movement animation (unit: ms).<ko>패널 이동 애니메이션 진행 시간 (단위: ms)</ko>
   * @param {object} [axesEvent] {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} event of {@link https://naver.github.io/egjs-axes/ Axes}
   * <ko>{@link https://naver.github.io/egjs-axes/ Axes}의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} 이벤트</ko>
   * @fires Flicking#moveStart
   * @fires Flicking#move
   * @fires Flicking#moveEnd
   * @fires Flicking#willChange
   * @fires Flicking#changed
   * @fires Flicking#willRestore
   * @fires Flicking#restored
   * @fires Flicking#needPanel
   * @fires Flicking#visibleChange
   * @fires Flicking#reachEdge
   * @throws {FlickingError}
   * |code|condition|
   * |---|---|
   * |{@link ERROR_CODE POSITION_NOT_REACHABLE}|When the given panel is already removed or not in the Camera's {@link Camera#range range}|
   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|When {@link Control#init init} is not called before|
   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|When the animation is interrupted by user input|
   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|When the animation is interrupted by user input|
   * <ko>
   *
   * |code|condition|
   * |---|---|
   * |{@link ERROR_CODE POSITION_NOT_REACHABLE}|주어진 패널이 제거되었거나, Camera의 {@link Camera#range range} 밖에 있을 경우|
   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|{@link Control#init init}이 이전에 호출되지 않은 경우|
   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|사용자 입력에 의해 애니메이션이 중단된 경우|
   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|발생된 이벤트들 중 하나라도 `stop()`이 호출된 경우|
   *
   * </ko>
   * @return {Promise<void>} A Promise which will be resolved after reaching the target position<ko>해당 좌표 도달시에 resolve되는 Promise</ko>
   */
  __proto.moveToPosition = function (position, duration, axesEvent) {
    var flicking = getFlickingAttached(this._flicking);
    var camera = flicking.camera;
    var targetPos = camera.clampToReachablePosition(position);
    var anchorAtPosition = camera.findAnchorIncludePosition(targetPos);
    if (!anchorAtPosition) {
      return Promise.reject(new FlickingError(MESSAGE.POSITION_NOT_REACHABLE(position), CODE.POSITION_NOT_REACHABLE));
    }
    var targetPanel = anchorAtPosition.panel;
    // Trigger only change event
    if (targetPanel !== this._activePanel) {
      this._triggerIndexChangeEvent(targetPanel, position, axesEvent);
    }
    return this._animateToPosition({
      position: this._stopAtEdge ? targetPos : position,
      duration: duration,
      newActivePanel: targetPanel,
      axesEvent: axesEvent
    });
  };
  return FreeControl;
}(Control);

/**
 * A {@link Control} that allow you to select the maximum number of panels to move at a time
 * @ko 한번에 최대로 이동할 패널의 개수를 선택 가능한 {@link Control}
 */
var StrictControl = /*#__PURE__*/function (_super) {
  __extends$3(StrictControl, _super);
  /** */
  function StrictControl(_a) {
    var _b = (_a === void 0 ? {} : _a).count,
      count = _b === void 0 ? 1 : _b;
    var _this = _super.call(this) || this;
    _this.setActive = function (newActivePanel, prevActivePanel, isTrusted) {
      _super.prototype.setActive.call(_this, newActivePanel, prevActivePanel, isTrusted);
      _this.updateInput();
    };
    _this._count = count;
    _this._resetIndexRange();
    return _this;
  }
  var __proto = StrictControl.prototype;
  Object.defineProperty(__proto, "count", {
    /**
     * Maximum number of panels that can be moved at a time
     * @ko 최대로 움직일 수 있는 패널의 개수
     * @type {number}
     * @default 1
     */
    get: function () {
      return this._count;
    },
    set: function (val) {
      this._count = val;
    },
    enumerable: false,
    configurable: true
  });
  /**
   * Destroy Control and return to initial state
   * @ko Control을 초기 상태로 되돌립니다
   * @return {void}
   */
  __proto.destroy = function () {
    _super.prototype.destroy.call(this);
    this._resetIndexRange();
  };
  /**
   * Update {@link Control#controller controller}'s state
   * @ko {@link Control#controller controller}의 내부 상태를 갱신합니다
   * @chainable
   * @return {this}
   */
  __proto.updateInput = function () {
    var _a;
    var flicking = getFlickingAttached(this._flicking);
    var camera = flicking.camera;
    var renderer = flicking.renderer;
    var controller = this._controller;
    var controlParams = camera.controlParams;
    var count = this._count;
    var activePanel = controller.state.animating ? (_a = camera.findNearestAnchor(camera.position)) === null || _a === void 0 ? void 0 : _a.panel : this._activePanel;
    if (!activePanel) {
      controller.update(controlParams);
      this._resetIndexRange();
      return this;
    }
    var cameraRange = controlParams.range;
    var currentPos = activePanel.position;
    var currentIndex = activePanel.index;
    var panelCount = renderer.panelCount;
    var prevPanelIndex = currentIndex - count;
    var nextPanelIndex = currentIndex + count;
    if (prevPanelIndex < 0) {
      prevPanelIndex = flicking.circularEnabled ? getMinusCompensatedIndex((prevPanelIndex + 1) % panelCount - 1, panelCount) : clamp$1(prevPanelIndex, 0, panelCount - 1);
    }
    if (nextPanelIndex >= panelCount) {
      nextPanelIndex = flicking.circularEnabled ? nextPanelIndex % panelCount : clamp$1(nextPanelIndex, 0, panelCount - 1);
    }
    var prevPanel = renderer.panels[prevPanelIndex];
    var nextPanel = renderer.panels[nextPanelIndex];
    var prevPos = Math.max(prevPanel.position, cameraRange.min);
    var nextPos = Math.min(nextPanel.position, cameraRange.max);
    if (prevPos > currentPos) {
      prevPos -= camera.rangeDiff;
    }
    if (nextPos < currentPos) {
      nextPos += camera.rangeDiff;
    }
    controlParams.range = {
      min: prevPos,
      max: nextPos
    };
    if (controlParams.circular) {
      if (controlParams.position < prevPos) {
        controlParams.position += camera.rangeDiff;
      }
      if (controlParams.position > nextPos) {
        controlParams.position -= camera.rangeDiff;
      }
    }
    controlParams.circular = false;
    controller.update(controlParams);
    this._indexRange = {
      min: prevPanel.index,
      max: nextPanel.index
    };
    return this;
  };
  __proto.moveToPanel = function (panel, options) {
    return __awaiter(this, void 0, void 0, function () {
      var flicking, camera, controller;
      return __generator(this, function (_a) {
        flicking = getFlickingAttached(this._flicking);
        camera = flicking.camera;
        controller = this._controller;
        controller.update(camera.controlParams);
        return [2 /*return*/, _super.prototype.moveToPanel.call(this, panel, options)];
      });
    });
  };
  /**
   * Move {@link Camera} to the given position
   * @ko {@link Camera}를 주어진 좌표로 이동합니다
   * @param {number} position The target position to move<ko>이동할 좌표</ko>
   * @param {number} duration Duration of the panel movement animation (unit: ms).<ko>패널 이동 애니메이션 진행 시간 (단위: ms)</ko>
   * @param {object} [axesEvent] {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} event of {@link https://naver.github.io/egjs-axes/ Axes}
   * <ko>{@link https://naver.github.io/egjs-axes/ Axes}의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} 이벤트</ko>
   * @fires Flicking#moveStart
   * @fires Flicking#move
   * @fires Flicking#moveEnd
   * @fires Flicking#willChange
   * @fires Flicking#changed
   * @fires Flicking#willRestore
   * @fires Flicking#restored
   * @fires Flicking#needPanel
   * @fires Flicking#visibleChange
   * @fires Flicking#reachEdge
   * @throws {FlickingError}
   * |code|condition|
   * |---|---|
   * |{@link ERROR_CODE POSITION_NOT_REACHABLE}|When the given panel is already removed or not in the Camera's {@link Camera#range range}|
   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|When {@link Control#init init} is not called before|
   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|When the animation is interrupted by user input|
   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|When the animation is interrupted by user input|
   * <ko>
   *
   * |code|condition|
   * |---|---|
   * |{@link ERROR_CODE POSITION_NOT_REACHABLE}|주어진 패널이 제거되었거나, Camera의 {@link Camera#range range} 밖에 있을 경우|
   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|{@link Control#init init}이 이전에 호출되지 않은 경우|
   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|사용자 입력에 의해 애니메이션이 중단된 경우|
   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|발생된 이벤트들 중 하나라도 `stop()`이 호출된 경우|
   *
   * </ko>
   * @return {Promise<void>} A Promise which will be resolved after reaching the target position<ko>해당 좌표 도달시에 resolve되는 Promise</ko>
   */
  __proto.moveToPosition = function (position, duration, axesEvent) {
    var _a;
    var flicking = getFlickingAttached(this._flicking);
    var camera = flicking.camera;
    var currentPanel = (_a = this._nextPanel) !== null && _a !== void 0 ? _a : this._activePanel;
    var axesRange = this._controller.range;
    var indexRange = this._indexRange;
    var cameraRange = camera.range;
    var state = this._controller.state;
    var clampedPosition = clamp$1(camera.clampToReachablePosition(position), axesRange[0], axesRange[1]);
    var anchorAtPosition = camera.findAnchorIncludePosition(clampedPosition);
    if (!anchorAtPosition || !currentPanel) {
      return Promise.reject(new FlickingError(MESSAGE.POSITION_NOT_REACHABLE(position), CODE.POSITION_NOT_REACHABLE));
    }
    var prevPos = currentPanel.position;
    var posDelta = flicking.animating ? state.delta : position - camera.position;
    var isOverThreshold = Math.abs(posDelta) >= flicking.threshold;
    var adjacentAnchor = position > prevPos ? camera.getNextAnchor(anchorAtPosition) : camera.getPrevAnchor(anchorAtPosition);
    var targetPos;
    var targetPanel;
    var anchors = camera.anchorPoints;
    var firstAnchor = anchors[0];
    var lastAnchor = anchors[anchors.length - 1];
    var shouldBounceToFirst = position <= cameraRange.min && isBetween(firstAnchor.panel.index, indexRange.min, indexRange.max);
    var shouldBounceToLast = position >= cameraRange.max && isBetween(lastAnchor.panel.index, indexRange.min, indexRange.max);
    var isAdjacent = adjacentAnchor && (indexRange.min <= indexRange.max ? isBetween(adjacentAnchor.index, indexRange.min, indexRange.max) : adjacentAnchor.index >= indexRange.min || adjacentAnchor.index <= indexRange.max);
    if (shouldBounceToFirst || shouldBounceToLast) {
      // In bounce area
      var targetAnchor = position < cameraRange.min ? firstAnchor : lastAnchor;
      targetPanel = targetAnchor.panel;
      targetPos = targetAnchor.position;
    } else if (isOverThreshold && anchorAtPosition.position !== currentPanel.position) {
      // Move to anchor at position
      targetPanel = anchorAtPosition.panel;
      targetPos = anchorAtPosition.position;
    } else if (isOverThreshold && isAdjacent) {
      // Move to adjacent anchor
      targetPanel = adjacentAnchor.panel;
      targetPos = adjacentAnchor.position;
    } else {
      // Fallback to nearest panel from current camera
      var anchorAtCamera = camera.findNearestAnchor(camera.position);
      if (!anchorAtCamera) {
        return Promise.reject(new FlickingError(MESSAGE.POSITION_NOT_REACHABLE(position), CODE.POSITION_NOT_REACHABLE));
      }
      return this.moveToPanel(anchorAtCamera.panel, {
        duration: duration,
        axesEvent: axesEvent
      });
    }
    this._triggerIndexChangeEvent(targetPanel, position, axesEvent);
    return this._animateToPosition({
      position: targetPos,
      duration: duration,
      newActivePanel: targetPanel,
      axesEvent: axesEvent
    });
  };
  __proto._resetIndexRange = function () {
    this._indexRange = {
      min: 0,
      max: 0
    };
  };
  return StrictControl;
}(Control);

/**
 * A mode of camera
 */
var CameraMode = /*#__PURE__*/function () {
  /** */
  function CameraMode(flicking) {
    this._flicking = flicking;
  }
  var __proto = CameraMode.prototype;
  __proto.getAnchors = function () {
    var panels = this._flicking.renderer.panels;
    return panels.map(function (panel, index) {
      return new AnchorPoint({
        index: index,
        position: panel.position,
        panel: panel
      });
    });
  };
  __proto.findAnchorIncludePosition = function (position) {
    var anchors = this._flicking.camera.anchorPoints;
    var anchorsIncludingPosition = anchors.filter(function (anchor) {
      return anchor.panel.includePosition(position, true);
    });
    return anchorsIncludingPosition.reduce(function (nearest, anchor) {
      if (!nearest) return anchor;
      return Math.abs(nearest.position - position) < Math.abs(anchor.position - position) ? nearest : anchor;
    }, null);
  };
  __proto.findNearestAnchor = function (position) {
    var anchors = this._flicking.camera.anchorPoints;
    if (anchors.length <= 0) return null;
    var prevDist = Infinity;
    for (var anchorIdx = 0; anchorIdx < anchors.length; anchorIdx++) {
      var anchor = anchors[anchorIdx];
      var dist = Math.abs(anchor.position - position);
      if (dist > prevDist) {
        // Return previous anchor
        return anchors[anchorIdx - 1];
      }
      prevDist = dist;
    }
    // Return last anchor
    return anchors[anchors.length - 1];
  };
  __proto.clampToReachablePosition = function (position) {
    var camera = this._flicking.camera;
    var range = camera.range;
    return clamp$1(position, range.min, range.max);
  };
  __proto.getCircularOffset = function () {
    return 0;
  };
  __proto.canReach = function (panel) {
    var camera = this._flicking.camera;
    var range = camera.range;
    if (panel.removed) return false;
    var panelPos = panel.position;
    return panelPos >= range.min && panelPos <= range.max;
  };
  __proto.canSee = function (panel) {
    var camera = this._flicking.camera;
    var visibleRange = camera.visibleRange;
    // Should not include margin, as we don't declare what the margin is visible as what the panel is visible.
    return panel.isVisibleOnRange(visibleRange.min, visibleRange.max);
  };
  return CameraMode;
}();

var LinearCameraMode = /*#__PURE__*/function (_super) {
  __extends$3(LinearCameraMode, _super);
  function LinearCameraMode() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  var __proto = LinearCameraMode.prototype;
  __proto.checkAvailability = function () {
    // It's always available
    return true;
  };
  __proto.getRange = function () {
    var _a, _b;
    var renderer = this._flicking.renderer;
    var firstPanel = renderer.getPanel(0);
    var lastPanel = renderer.getPanel(renderer.panelCount - 1);
    return {
      min: (_a = firstPanel === null || firstPanel === void 0 ? void 0 : firstPanel.position) !== null && _a !== void 0 ? _a : 0,
      max: (_b = lastPanel === null || lastPanel === void 0 ? void 0 : lastPanel.position) !== null && _b !== void 0 ? _b : 0
    };
  };
  return LinearCameraMode;
}(CameraMode);

/**
 * A {@link Camera} mode that connects the last panel and the first panel, enabling continuous loop
 * @ko 첫번째 패널과 마지막 패널이 이어진 상태로, 무한히 회전할 수 있는 종류의 {@link Camera} 모드
 */
var CircularCameraMode = /*#__PURE__*/function (_super) {
  __extends$3(CircularCameraMode, _super);
  function CircularCameraMode() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  var __proto = CircularCameraMode.prototype;
  __proto.checkAvailability = function () {
    var flicking = this._flicking;
    var renderer = flicking.renderer;
    var panels = renderer.panels;
    if (panels.length <= 0) {
      return false;
    }
    var firstPanel = panels[0];
    var lastPanel = panels[panels.length - 1];
    var firstPanelPrev = firstPanel.range.min - firstPanel.margin.prev;
    var lastPanelNext = lastPanel.range.max + lastPanel.margin.next;
    var visibleSize = flicking.camera.size;
    var panelSizeSum = lastPanelNext - firstPanelPrev;
    var canSetCircularMode = panels.every(function (panel) {
      return panelSizeSum - panel.size >= visibleSize;
    });
    return canSetCircularMode;
  };
  __proto.getRange = function () {
    var flicking = this._flicking;
    var panels = flicking.renderer.panels;
    if (panels.length <= 0) {
      return {
        min: 0,
        max: 0
      };
    }
    var firstPanel = panels[0];
    var lastPanel = panels[panels.length - 1];
    var firstPanelPrev = firstPanel.range.min - firstPanel.margin.prev;
    var lastPanelNext = lastPanel.range.max + lastPanel.margin.next;
    return {
      min: firstPanelPrev,
      max: lastPanelNext
    };
  };
  __proto.getAnchors = function () {
    var flicking = this._flicking;
    var panels = flicking.renderer.panels;
    return panels.map(function (panel, index) {
      return new AnchorPoint({
        index: index,
        position: panel.position,
        panel: panel
      });
    });
  };
  __proto.findNearestAnchor = function (position) {
    var camera = this._flicking.camera;
    var anchors = camera.anchorPoints;
    if (anchors.length <= 0) return null;
    var camRange = camera.range;
    var minDist = Infinity;
    var minDistIndex = -1;
    for (var anchorIdx = 0; anchorIdx < anchors.length; anchorIdx++) {
      var anchor = anchors[anchorIdx];
      var dist = Math.min(Math.abs(anchor.position - position), Math.abs(anchor.position - camRange.min + camRange.max - position), Math.abs(position - camRange.min + camRange.max - anchor.position));
      if (dist < minDist) {
        minDist = dist;
        minDistIndex = anchorIdx;
      }
    }
    // Return last anchor
    return anchors[minDistIndex];
  };
  __proto.findAnchorIncludePosition = function (position) {
    var camera = this._flicking.camera;
    var range = camera.range;
    var anchors = camera.anchorPoints;
    var rangeDiff = camera.rangeDiff;
    var anchorCount = anchors.length;
    var positionInRange = circulatePosition(position, range.min, range.max);
    var anchorInRange = _super.prototype.findAnchorIncludePosition.call(this, positionInRange);
    if (anchorCount > 0 && (position === range.min || position === range.max)) {
      var possibleAnchors = [anchorInRange, new AnchorPoint({
        index: 0,
        position: anchors[0].position + rangeDiff,
        panel: anchors[0].panel
      }), new AnchorPoint({
        index: anchorCount - 1,
        position: anchors[anchorCount - 1].position - rangeDiff,
        panel: anchors[anchorCount - 1].panel
      })].filter(function (anchor) {
        return !!anchor;
      });
      anchorInRange = possibleAnchors.reduce(function (nearest, anchor) {
        if (!nearest) return anchor;
        return Math.abs(nearest.position - position) < Math.abs(anchor.position - position) ? nearest : anchor;
      }, null);
    }
    if (!anchorInRange) return null;
    if (position < range.min) {
      var loopCount = -Math.floor((range.min - position) / rangeDiff) - 1;
      return new AnchorPoint({
        index: anchorInRange.index,
        position: anchorInRange.position + rangeDiff * loopCount,
        panel: anchorInRange.panel
      });
    } else if (position > range.max) {
      var loopCount = Math.floor((position - range.max) / rangeDiff) + 1;
      return new AnchorPoint({
        index: anchorInRange.index,
        position: anchorInRange.position + rangeDiff * loopCount,
        panel: anchorInRange.panel
      });
    }
    return anchorInRange;
  };
  __proto.getCircularOffset = function () {
    var flicking = this._flicking;
    var camera = flicking.camera;
    if (!camera.circularEnabled) return 0;
    var toggled = flicking.panels.filter(function (panel) {
      return panel.toggled;
    });
    var toggledPrev = toggled.filter(function (panel) {
      return panel.toggleDirection === DIRECTION.PREV;
    });
    var toggledNext = toggled.filter(function (panel) {
      return panel.toggleDirection === DIRECTION.NEXT;
    });
    return this._calcPanelAreaSum(toggledPrev) - this._calcPanelAreaSum(toggledNext);
  };
  __proto.clampToReachablePosition = function (position) {
    // Basically all position is reachable for circular camera
    return position;
  };
  __proto.canReach = function (panel) {
    if (panel.removed) return false;
    // Always reachable on circular mode
    return true;
  };
  __proto.canSee = function (panel) {
    var camera = this._flicking.camera;
    var range = camera.range;
    var rangeDiff = camera.rangeDiff;
    var visibleRange = camera.visibleRange;
    var visibleInCurrentRange = _super.prototype.canSee.call(this, panel);
    // Check looped visible area for circular case
    if (visibleRange.min < range.min) {
      return visibleInCurrentRange || panel.isVisibleOnRange(visibleRange.min + rangeDiff, visibleRange.max + rangeDiff);
    } else if (visibleRange.max > range.max) {
      return visibleInCurrentRange || panel.isVisibleOnRange(visibleRange.min - rangeDiff, visibleRange.max - rangeDiff);
    }
    return visibleInCurrentRange;
  };
  __proto._calcPanelAreaSum = function (panels) {
    return panels.reduce(function (sum, panel) {
      return sum + panel.sizeIncludingMargin;
    }, 0);
  };
  return CircularCameraMode;
}(CameraMode);

var BoundCameraMode = /*#__PURE__*/function (_super) {
  __extends$3(BoundCameraMode, _super);
  function BoundCameraMode() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  var __proto = BoundCameraMode.prototype;
  __proto.checkAvailability = function () {
    var flicking = this._flicking;
    var renderer = flicking.renderer;
    var firstPanel = renderer.getPanel(0);
    var lastPanel = renderer.getPanel(renderer.panelCount - 1);
    if (!firstPanel || !lastPanel) {
      return false;
    }
    var viewportSize = flicking.camera.size;
    var firstPanelPrev = firstPanel.range.min;
    var lastPanelNext = lastPanel.range.max;
    var panelAreaSize = lastPanelNext - firstPanelPrev;
    var isBiggerThanViewport = viewportSize < panelAreaSize;
    return isBiggerThanViewport;
  };
  __proto.getRange = function () {
    var flicking = this._flicking;
    var renderer = flicking.renderer;
    var alignPos = flicking.camera.alignPosition;
    var firstPanel = renderer.getPanel(0);
    var lastPanel = renderer.getPanel(renderer.panelCount - 1);
    if (!firstPanel || !lastPanel) {
      return {
        min: 0,
        max: 0
      };
    }
    var viewportSize = flicking.camera.size;
    var firstPanelPrev = firstPanel.range.min;
    var lastPanelNext = lastPanel.range.max;
    var panelAreaSize = lastPanelNext - firstPanelPrev;
    var isBiggerThanViewport = viewportSize < panelAreaSize;
    var firstPos = firstPanelPrev + alignPos;
    var lastPos = lastPanelNext - viewportSize + alignPos;
    if (isBiggerThanViewport) {
      return {
        min: firstPos,
        max: lastPos
      };
    } else {
      var align = flicking.camera.align;
      var alignVal = typeof align === "object" ? align.camera : align;
      var pos = firstPos + parseAlign$1(alignVal, lastPos - firstPos);
      return {
        min: pos,
        max: pos
      };
    }
  };
  __proto.getAnchors = function () {
    var flicking = this._flicking;
    var camera = flicking.camera;
    var panels = flicking.renderer.panels;
    if (panels.length <= 0) {
      return [];
    }
    var range = flicking.camera.range;
    var reachablePanels = panels.filter(function (panel) {
      return camera.canReach(panel);
    });
    if (reachablePanels.length > 0) {
      var shouldPrependBoundAnchor = reachablePanels[0].position !== range.min;
      var shouldAppendBoundAnchor = reachablePanels[reachablePanels.length - 1].position !== range.max;
      var indexOffset_1 = shouldPrependBoundAnchor ? 1 : 0;
      var newAnchors = reachablePanels.map(function (panel, idx) {
        return new AnchorPoint({
          index: idx + indexOffset_1,
          position: panel.position,
          panel: panel
        });
      });
      if (shouldPrependBoundAnchor) {
        newAnchors.splice(0, 0, new AnchorPoint({
          index: 0,
          position: range.min,
          panel: panels[reachablePanels[0].index - 1]
        }));
      }
      if (shouldAppendBoundAnchor) {
        newAnchors.push(new AnchorPoint({
          index: newAnchors.length,
          position: range.max,
          panel: panels[reachablePanels[reachablePanels.length - 1].index + 1]
        }));
      }
      return newAnchors;
    } else if (range.min !== range.max) {
      // There're more than 2 panels
      var nearestPanelAtMin = this._findNearestPanel(range.min, panels);
      var panelAtMin = nearestPanelAtMin.index === panels.length - 1 ? nearestPanelAtMin.prev() : nearestPanelAtMin;
      var panelAtMax = panelAtMin.next();
      return [new AnchorPoint({
        index: 0,
        position: range.min,
        panel: panelAtMin
      }), new AnchorPoint({
        index: 1,
        position: range.max,
        panel: panelAtMax
      })];
    } else {
      return [new AnchorPoint({
        index: 0,
        position: range.min,
        panel: this._findNearestPanel(range.min, panels)
      })];
    }
  };
  __proto.findAnchorIncludePosition = function (position) {
    var camera = this._flicking.camera;
    var range = camera.range;
    var anchors = camera.anchorPoints;
    if (anchors.length <= 0) return null;
    if (position <= range.min) {
      return anchors[0];
    } else if (position >= range.max) {
      return anchors[anchors.length - 1];
    } else {
      return _super.prototype.findAnchorIncludePosition.call(this, position);
    }
  };
  __proto._findNearestPanel = function (pos, panels) {
    var prevDist = Infinity;
    for (var panelIdx = 0; panelIdx < panels.length; panelIdx++) {
      var panel = panels[panelIdx];
      var dist = Math.abs(panel.position - pos);
      if (dist > prevDist) {
        // Return previous anchor
        return panels[panelIdx - 1];
      }
      prevDist = dist;
    }
    // Return last anchor
    return panels[panels.length - 1];
  };
  return BoundCameraMode;
}(CameraMode);

/**
 * A component that manages actual movement inside the viewport
 * @ko 뷰포트 내에서의 실제 움직임을 담당하는 컴포넌트
 */
var Camera = /*#__PURE__*/function () {
  /** */
  function Camera(flicking, _a) {
    var _this = this;
    var _b = (_a === void 0 ? {} : _a).align,
      align = _b === void 0 ? ALIGN.CENTER : _b;
    this._checkTranslateSupport = function () {
      var e_1, _a;
      var transforms = ["webkitTransform", "msTransform", "MozTransform", "OTransform", "transform"];
      var supportedStyle = document.documentElement.style;
      var transformName = "";
      try {
        for (var transforms_1 = __values$1(transforms), transforms_1_1 = transforms_1.next(); !transforms_1_1.done; transforms_1_1 = transforms_1.next()) {
          var prefixedTransform = transforms_1_1.value;
          if (prefixedTransform in supportedStyle) {
            transformName = prefixedTransform;
          }
        }
      } catch (e_1_1) {
        e_1 = {
          error: e_1_1
        };
      } finally {
        try {
          if (transforms_1_1 && !transforms_1_1.done && (_a = transforms_1.return)) _a.call(transforms_1);
        } finally {
          if (e_1) throw e_1.error;
        }
      }
      if (!transformName) {
        throw new FlickingError(MESSAGE.TRANSFORM_NOT_SUPPORTED, CODE.TRANSFORM_NOT_SUPPORTED);
      }
      _this._transform = transformName;
    };
    this._flicking = flicking;
    this._resetInternalValues();
    // Options
    this._align = align;
  }
  var __proto = Camera.prototype;
  Object.defineProperty(__proto, "element", {
    // Internal states getter
    /**
     * The camera element(`.flicking-camera`)
     * @ko 카메라 엘리먼트(`.flicking-camera`)
     * @type {HTMLElement}
     * @readonly
     */
    get: function () {
      return this._el;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "children", {
    /**
     * An array of the child elements of the camera element(`.flicking-camera`)
     * @ko 카메라 엘리먼트(`.flicking-camera`)의 자식 엘리먼트 배열
     * @type {HTMLElement[]}
     * @readonly
     */
    get: function () {
      return toArray$2(this._el.children);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "position", {
    /**
     * Current position of the camera
     * @ko Camera의 현재 좌표
     * @type {number}
     * @readonly
     */
    get: function () {
      return this._position;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "alignPosition", {
    /**
     * Align position inside the viewport where {@link Panel}'s {@link Panel#alignPosition alignPosition} should be located at
     * @ko 패널의 정렬 기준 위치. 뷰포트 내에서 {@link Panel}의 {@link Panel#alignPosition alignPosition}이 위치해야 하는 곳입니다
     * @type {number}
     * @readonly
     */
    get: function () {
      return this._alignPos;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "offset", {
    /**
     * Position offset, used for the {@link Flicking#renderOnlyVisible renderOnlyVisible} option
     * @ko Camera의 좌표 오프셋. {@link Flicking#renderOnlyVisible renderOnlyVisible} 옵션을 위해 사용됩니다.
     * @type {number}
     * @default 0
     * @readonly
     */
    get: function () {
      return this._offset - this._circularOffset;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "circularEnabled", {
    /**
     * Whether the `circular` option is enabled.
     * The {@link Flicking#circular circular} option can't be enabled when sum of the panel sizes are too small.
     * @ko {@link Flicking#circular circular} 옵션이 활성화되었는지 여부를 나타내는 멤버 변수.
     * {@link Flicking#circular circular} 옵션은 패널의 크기의 합이 충분하지 않을 경우 비활성화됩니다.
     * @type {boolean}
     * @default false
     * @readonly
     */
    get: function () {
      return this._circularEnabled;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "mode", {
    /**
     * A current camera mode
     * @type {CameraMode}
     * @readonly
     */
    get: function () {
      return this._mode;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "range", {
    /**
     * A range that Camera's {@link Camera#position position} can reach
     * @ko Camera의 {@link Camera#position position}이 도달 가능한 범위
     * @type {object}
     * @property {number} min A minimum position<ko>최소 위치</ko>
     * @property {number} max A maximum position<ko>최대 위치</ko>
     * @readonly
     */
    get: function () {
      return this._range;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "rangeDiff", {
    /**
     * A difference between Camera's minimum and maximum position that can reach
     * @ko Camera가 도달 가능한 최소/최대 좌표의 차이
     * @type {number}
     * @readonly
     */
    get: function () {
      return this._range.max - this._range.min;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "visiblePanels", {
    /**
     * An array of visible panels from the current position
     * @ko 현재 보이는 패널들의 배열
     * @type {Panel[]}
     * @readonly
     */
    get: function () {
      return this._visiblePanels;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "visibleRange", {
    /**
     * A range of the visible area from the current position
     * @ko 현재 위치에서 보이는 범위
     * @type {object}
     * @property {number} min A minimum position<ko>최소 위치</ko>
     * @property {number} min A maximum position<ko>최대 위치</ko>
     * @readonly
     */
    get: function () {
      return {
        min: this._position - this._alignPos,
        max: this._position - this._alignPos + this.size
      };
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "anchorPoints", {
    /**
     * An array of {@link AnchorPoint}s that Camera can be stopped at
     * @ko 카메라가 도달 가능한 {@link AnchorPoint}의 목록
     * @type {AnchorPoint[]}
     * @readonly
     */
    get: function () {
      return this._anchors;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "controlParams", {
    /**
     * A current parameters of the Camera for updating {@link AxesController}
     * @ko {@link AxesController}를 업데이트하기 위한 현재 Camera 패러미터들
     * @type {ControlParams}
     * @readonly
     */
    get: function () {
      return {
        range: this._range,
        position: this._position,
        circular: this._circularEnabled
      };
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "atEdge", {
    /**
     * A Boolean value indicating whether Camera's over the minimum or maximum position reachable
     * @ko 현재 카메라가 도달 가능한 범위의 최소 혹은 최대점을 넘어섰는지를 나타냅니다
     * @type {boolean}
     * @readonly
     */
    get: function () {
      return this._position <= this._range.min || this._position >= this._range.max;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "size", {
    /**
     * Return the size of the viewport
     * @ko 뷰포트 크기를 반환합니다
     * @type {number}
     * @readonly
     */
    get: function () {
      var flicking = this._flicking;
      return flicking ? flicking.horizontal ? flicking.viewport.width : flicking.viewport.height : 0;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "progress", {
    /**
     * Return the camera's position progress from the first panel to last panel
     * Range is from 0 to last panel's index
     * @ko 첫번째 패널로부터 마지막 패널까지의 카메라 위치의 진행도를 반환합니다
     * 범위는 0부터 마지막 패널의 인덱스까지입니다
     * @type {number}
     * @readonly
     */
    get: function () {
      var flicking = this._flicking;
      var position = this._position + this._offset;
      var nearestAnchor = this.findNearestAnchor(this._position);
      if (!flicking || !nearestAnchor) {
        return NaN;
      }
      var nearestPanel = nearestAnchor.panel;
      var panelPos = nearestPanel.position + nearestPanel.offset;
      var bounceSize = flicking.control.controller.bounce;
      var _a = this.range,
        prevRange = _a.min,
        nextRange = _a.max;
      var rangeDiff = this.rangeDiff;
      if (position === panelPos) {
        return nearestPanel.index;
      }
      if (position < panelPos) {
        var prevPanel = nearestPanel.prev();
        var prevPosition = prevPanel ? prevPanel.position + prevPanel.offset : prevRange - bounceSize[0];
        // Looped
        if (prevPosition > panelPos) {
          prevPosition -= rangeDiff;
        }
        return nearestPanel.index - 1 + getProgress(position, prevPosition, panelPos);
      } else {
        var nextPanel = nearestPanel.next();
        var nextPosition = nextPanel ? nextPanel.position + nextPanel.offset : nextRange + bounceSize[1];
        // Looped
        if (nextPosition < panelPos) {
          nextPosition += rangeDiff;
        }
        return nearestPanel.index + getProgress(position, panelPos, nextPosition);
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "panelOrder", {
    /**
     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/direction direction} CSS property applied to the camera element(`.flicking-camera`)
     * @ko 카메라 엘리먼트(`.flicking-camera`)에 적용된 {@link https://developer.mozilla.org/en-US/docs/Web/CSS/direction direction} CSS 속성
     * @type {string}
     * @readonly
     */
    get: function () {
      return this._panelOrder;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "align", {
    // Options Getter
    /**
     * A value indicating where the {@link Camera#alignPosition alignPosition} should be located at inside the viewport element
     * @ko {@link Camera#alignPosition alignPosition}이 뷰포트 엘리먼트 내의 어디에 위치해야 하는지를 나타내는 값
     * @type {ALIGN | string | number}
     */
    get: function () {
      return this._align;
    },
    // Options Setter
    set: function (val) {
      this._align = val;
    },
    enumerable: false,
    configurable: true
  });
  /**
   * Initialize Camera
   * @ko Camera를 초기화합니다
   * @throws {FlickingError}
   * {@link ERROR_CODE VAL_MUST_NOT_NULL} If the camera element(`.flicking-camera`) does not exist inside viewport element
   * <ko>{@link ERROR_CODE VAL_MUST_NOT_NULL} 뷰포트 엘리먼트 내부에 카메라 엘리먼트(`.flicking-camera`)가 존재하지 않을 경우</ko>
   * @return {this}
   */
  __proto.init = function () {
    var viewportEl = this._flicking.viewport.element;
    checkExistence(viewportEl.firstElementChild, "First element child of the viewport element");
    this._el = viewportEl.firstElementChild;
    this._checkTranslateSupport();
    this._updateMode();
    this.updatePanelOrder();
    return this;
  };
  /**
   * Destroy Camera and return to initial state
   * @ko Camera를 초기 상태로 되돌립니다
   * @return {void}
   */
  __proto.destroy = function () {
    this._resetInternalValues();
    return this;
  };
  /**
   * Move to the given position and apply CSS transform
   * @ko 해당 좌표로 이동하고, CSS transform을 적용합니다
   * @param {number} pos A new position<ko>움직일 위치</ko>
   * @throws {FlickingError}
   * {@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} When {@link Camera#init init} is not called before
   * <ko>{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} {@link Camera#init init}이 이전에 호출되지 않은 경우</ko>
   * @return {this}
   */
  __proto.lookAt = function (pos) {
    var _this = this;
    var flicking = getFlickingAttached(this._flicking);
    var prevPos = this._position;
    this._position = pos;
    var toggled = this._togglePanels(prevPos, pos);
    this._refreshVisiblePanels();
    this._checkNeedPanel();
    this._checkReachEnd(prevPos, pos);
    if (toggled) {
      void flicking.renderer.render().then(function () {
        _this.updateOffset();
      });
    } else {
      this.applyTransform();
    }
  };
  /**
   * Return a previous {@link AnchorPoint} of given {@link AnchorPoint}
   * If it does not exist, return `null` instead
   * @ko 주어진 {@link AnchorPoint}의 이전 {@link AnchorPoint}를 반환합니다
   * 존재하지 않을 경우 `null`을 반환합니다
   * @param {AnchorPoint} anchor A reference {@link AnchorPoint}<ko>기준 {@link AnchorPoint}</ko>
   * @return {AnchorPoint | null} The previous {@link AnchorPoint}<ko>이전 {@link AnchorPoint}</ko>
   */
  __proto.getPrevAnchor = function (anchor) {
    if (!this._circularEnabled || anchor.index !== 0) {
      return this._anchors[anchor.index - 1] || null;
    } else {
      var anchors = this._anchors;
      var rangeDiff = this.rangeDiff;
      var lastAnchor = anchors[anchors.length - 1];
      return new AnchorPoint({
        index: lastAnchor.index,
        position: lastAnchor.position - rangeDiff,
        panel: lastAnchor.panel
      });
    }
  };
  /**
   * Return a next {@link AnchorPoint} of given {@link AnchorPoint}
   * If it does not exist, return `null` instead
   * @ko 주어진 {@link AnchorPoint}의 다음 {@link AnchorPoint}를 반환합니다
   * 존재하지 않을 경우 `null`을 반환합니다
   * @param {AnchorPoint} anchor A reference {@link AnchorPoint}<ko>기준 {@link AnchorPoint}</ko>
   * @return {AnchorPoint | null} The next {@link AnchorPoint}<ko>다음 {@link AnchorPoint}</ko>
   */
  __proto.getNextAnchor = function (anchor) {
    var anchors = this._anchors;
    if (!this._circularEnabled || anchor.index !== anchors.length - 1) {
      return anchors[anchor.index + 1] || null;
    } else {
      var rangeDiff = this.rangeDiff;
      var firstAnchor = anchors[0];
      return new AnchorPoint({
        index: firstAnchor.index,
        position: firstAnchor.position + rangeDiff,
        panel: firstAnchor.panel
      });
    }
  };
  /**
   * Return the camera's position progress in the panel below
   * Value is from 0 to 1 when the camera's inside panel
   * Value can be lower than 0 or bigger than 1 when it's in the margin area
   * @ko 현재 카메라 아래 패널에서의 위치 진행도를 반환합니다
   * 반환값은 카메라가 패널 내부에 있을 경우 0부터 1까지의 값을 갖습니다
   * 패널의 margin 영역에 있을 경우 0보다 작거나 1보다 큰 값을 반환할 수 있습니다
   */
  __proto.getProgressInPanel = function (panel) {
    var panelRange = panel.range;
    return (this._position - panelRange.min) / (panelRange.max - panelRange.min);
  };
  /**
   * Return {@link AnchorPoint} that includes given position
   * If there's no {@link AnchorPoint} that includes the given position, return `null` instead
   * @ko 주어진 좌표를 포함하는 {@link AnchorPoint}를 반환합니다
   * 주어진 좌표를 포함하는 {@link AnchorPoint}가 없을 경우 `null`을 반환합니다
   * @param {number} position A position to check<ko>확인할 좌표</ko>
   * @return {AnchorPoint | null} The {@link AnchorPoint} that includes the given position<ko>해당 좌표를 포함하는 {@link AnchorPoint}</ko>
   */
  __proto.findAnchorIncludePosition = function (position) {
    return this._mode.findAnchorIncludePosition(position);
  };
  /**
   * Return {@link AnchorPoint} nearest to given position
   * If there're no {@link AnchorPoint}s, return `null` instead
   * @ko 해당 좌표에서 가장 가까운 {@link AnchorPoint}를 반환합니다
   * {@link AnchorPoint}가 하나도 없을 경우 `null`을 반환합니다
   * @param {number} position A position to check<ko>확인할 좌표</ko>
   * @return {AnchorPoint | null} The {@link AnchorPoint} nearest to the given position<ko>해당 좌표에 가장 인접한 {@link AnchorPoint}</ko>
   */
  __proto.findNearestAnchor = function (position) {
    return this._mode.findNearestAnchor(position);
  };
  /**
   * Return {@link AnchorPoint} that matches {@link Flicking#currentPanel}
   * @ko 현재 {@link Flicking#currentPanel}에 해당하는 {@link AnchorPoint}를 반환합니다
   * @return {AnchorPoint | null}
   */
  __proto.findActiveAnchor = function () {
    var _a;
    var flicking = getFlickingAttached(this._flicking);
    var activePanel = flicking.control.activePanel;
    if (!activePanel) return null;
    return (_a = find$1(this._anchors, function (anchor) {
      return anchor.panel.index === activePanel.index;
    })) !== null && _a !== void 0 ? _a : this.findNearestAnchor(activePanel.position);
  };
  /**
   * Clamp the given position between camera's range
   * @ko 주어진 좌표를 Camera가 도달 가능한 범위 사이의 값으로 만듭니다
   * @param {number} position A position to clamp<ko>범위를 제한할 좌표</ko>
   * @return {number} A clamped position<ko>범위 제한된 좌표</ko>
   */
  __proto.clampToReachablePosition = function (position) {
    return this._mode.clampToReachablePosition(position);
  };
  /**
   * Check whether the given panel is inside of the Camera's range
   * @ko 해당 {@link Panel}이 Camera가 도달 가능한 범위 내에 있는지를 반환합니다
   * @param panel An instance of {@link Panel} to check<ko>확인할 {@link Panel}의 인스턴스</ko>
   * @return {boolean} Whether the panel's inside Camera's range<ko>도달 가능한 범위 내에 해당 패널이 존재하는지 여부</ko>
   */
  __proto.canReach = function (panel) {
    return this._mode.canReach(panel);
  };
  /**
   * Check whether the given panel element is visible at the current position
   * @ko 현재 좌표에서 해당 패널 엘리먼트를 볼 수 있는지 여부를 반환합니다
   * @param panel An instance of {@link Panel} to check<ko>확인할 {@link Panel}의 인스턴스</ko>
   * @return Whether the panel element is visible at the current position<ko>현재 위치에서 해당 패널 엘리먼트가 보이는지 여부</ko>
   */
  __proto.canSee = function (panel) {
    return this._mode.canSee(panel);
  };
  /**
   * Update {@link Camera#range range} of Camera
   * @ko Camera의 {@link Camera#range range}를 업데이트합니다
   * @method
   * @abstract
   * @memberof Camera
   * @instance
   * @name updateRange
   * @chainable
   * @throws {FlickingError}
   * {@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} When {@link Camera#init init} is not called before
   * <ko>{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} {@link Camera#init init}이 이전에 호출되지 않은 경우</ko>
   * @return {this}
   */
  __proto.updateRange = function () {
    var flicking = getFlickingAttached(this._flicking);
    var renderer = flicking.renderer;
    var panels = renderer.panels;
    this._updateMode();
    this._range = this._mode.getRange();
    panels.forEach(function (panel) {
      return panel.updateCircularToggleDirection();
    });
    return this;
  };
  /**
   * Update Camera's {@link Camera#alignPosition alignPosition}
   * @ko Camera의 {@link Camera#alignPosition alignPosition}을 업데이트합니다
   * @chainable
   * @return {this}
   */
  __proto.updateAlignPos = function () {
    var align = this._align;
    var alignVal = typeof align === "object" ? align.camera : align;
    this._alignPos = parseAlign$1(alignVal, this.size);
    return this;
  };
  /**
   * Update Camera's {@link Camera#anchorPoints anchorPoints}
   * @ko Camera의 {@link Camera#anchorPoints anchorPoints}를 업데이트합니다
   * @throws {FlickingError}
   * {@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} When {@link Camera#init init} is not called before
   * <ko>{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} {@link Camera#init init}이 이전에 호출되지 않은 경우</ko>
   * @chainable
   * @return {this}
   */
  __proto.updateAnchors = function () {
    this._anchors = this._mode.getAnchors();
    return this;
  };
  /**
   * Update Viewport's height to active panel's height
   * @ko 현재 선택된 패널의 높이와 동일하도록 뷰포트의 높이를 업데이트합니다
   * @throws {FlickingError}
   * {@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} When {@link Camera#init init} is not called before
   * <ko>{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} {@link Camera#init init}이 이전에 호출되지 않은 경우</ko>
   * @chainable
   * @return {this}
   */
  __proto.updateAdaptiveHeight = function () {
    var flicking = getFlickingAttached(this._flicking);
    var activePanel = flicking.control.activePanel;
    if (!flicking.horizontal || !flicking.adaptive || !activePanel) return;
    flicking.viewport.setSize({
      height: activePanel.height
    });
  };
  /**
   * Update current offset of the camera
   * @ko 현재 카메라의 오프셋을 업데이트합니다
   * @chainable
   * @return {this}
   */
  __proto.updateOffset = function () {
    var flicking = getFlickingAttached(this._flicking);
    var position = this._position;
    var unRenderedPanels = flicking.panels.filter(function (panel) {
      return !panel.rendered;
    });
    this._offset = unRenderedPanels.filter(function (panel) {
      return panel.position + panel.offset < position;
    }).reduce(function (offset, panel) {
      return offset + panel.sizeIncludingMargin;
    }, 0);
    this._circularOffset = this._mode.getCircularOffset();
    this.applyTransform();
    return this;
  };
  /**
   * Update direction to match the {@link https://developer.mozilla.org/en-US/docs/Web/CSS/direction direction} CSS property applied to the camera element
   * @ko 카메라 엘리먼트에 적용된 {@link https://developer.mozilla.org/en-US/docs/Web/CSS/direction direction} CSS 속성에 맞게 방향을 업데이트합니다
   * @return {this}
   */
  __proto.updatePanelOrder = function () {
    var flicking = getFlickingAttached(this._flicking);
    if (!flicking.horizontal) return this;
    var el = this._el;
    var direction = getStyle(el).direction;
    if (direction !== this._panelOrder) {
      this._panelOrder = direction === ORDER.RTL ? ORDER.RTL : ORDER.LTR;
      if (flicking.initialized) {
        flicking.control.controller.updateDirection();
      }
    }
    return this;
  };
  /**
   * Reset the history of {@link Flicking#event:needPanel needPanel} events so it can be triggered again
   * @ko 발생한 {@link Flicking#event:needPanel needPanel} 이벤트들을 초기화하여 다시 발생할 수 있도록 합니다
   * @chainable
   * @return {this}
   */
  __proto.resetNeedPanelHistory = function () {
    this._needPanelTriggered = {
      prev: false,
      next: false
    };
    return this;
  };
  /**
   * Apply "transform" style with the current position to camera element
   * @ko 현재 위치를 기준으로한 transform 스타일을 카메라 엘리먼트에 적용합니다.
   * @return {this}
   */
  __proto.applyTransform = function () {
    var el = this._el;
    var flicking = getFlickingAttached(this._flicking);
    var renderer = flicking.renderer;
    if (renderer.rendering || !flicking.initialized) return this;
    var actualPosition = this._position - this._alignPos - this._offset + this._circularOffset;
    el.style[this._transform] = flicking.horizontal ? "translate(" + (this._panelOrder === ORDER.RTL ? actualPosition : -actualPosition) + "px)" : "translate(0, " + -actualPosition + "px)";
    return this;
  };
  __proto._resetInternalValues = function () {
    this._position = 0;
    this._alignPos = 0;
    this._offset = 0;
    this._circularOffset = 0;
    this._circularEnabled = false;
    this._range = {
      min: 0,
      max: 0
    };
    this._visiblePanels = [];
    this._anchors = [];
    this._needPanelTriggered = {
      prev: false,
      next: false
    };
  };
  __proto._refreshVisiblePanels = function () {
    var _this = this;
    var flicking = getFlickingAttached(this._flicking);
    var panels = flicking.renderer.panels;
    var newVisiblePanels = panels.filter(function (panel) {
      return _this.canSee(panel);
    });
    var prevVisiblePanels = this._visiblePanels;
    this._visiblePanels = newVisiblePanels;
    var added = newVisiblePanels.filter(function (panel) {
      return !includes(prevVisiblePanels, panel);
    });
    var removed = prevVisiblePanels.filter(function (panel) {
      return !includes(newVisiblePanels, panel);
    });
    if (added.length > 0 || removed.length > 0) {
      void flicking.renderer.render().then(function () {
        flicking.trigger(new ComponentEvent$1(EVENTS.VISIBLE_CHANGE, {
          added: added,
          removed: removed,
          visiblePanels: newVisiblePanels
        }));
      });
    }
  };
  __proto._checkNeedPanel = function () {
    var needPanelTriggered = this._needPanelTriggered;
    if (needPanelTriggered.prev && needPanelTriggered.next) return;
    var flicking = getFlickingAttached(this._flicking);
    var panels = flicking.renderer.panels;
    if (panels.length <= 0) {
      if (!needPanelTriggered.prev) {
        flicking.trigger(new ComponentEvent$1(EVENTS.NEED_PANEL, {
          direction: DIRECTION.PREV
        }));
        needPanelTriggered.prev = true;
      }
      if (!needPanelTriggered.next) {
        flicking.trigger(new ComponentEvent$1(EVENTS.NEED_PANEL, {
          direction: DIRECTION.NEXT
        }));
        needPanelTriggered.next = true;
      }
      return;
    }
    var cameraPosition = this._position;
    var cameraSize = this.size;
    var cameraRange = this._range;
    var needPanelThreshold = flicking.needPanelThreshold;
    var cameraPrev = cameraPosition - this._alignPos;
    var cameraNext = cameraPrev + cameraSize;
    var firstPanel = panels[0];
    var lastPanel = panels[panels.length - 1];
    if (!needPanelTriggered.prev) {
      var firstPanelPrev = firstPanel.range.min;
      if (cameraPrev <= firstPanelPrev + needPanelThreshold || cameraPosition <= cameraRange.min + needPanelThreshold) {
        flicking.trigger(new ComponentEvent$1(EVENTS.NEED_PANEL, {
          direction: DIRECTION.PREV
        }));
        needPanelTriggered.prev = true;
      }
    }
    if (!needPanelTriggered.next) {
      var lastPanelNext = lastPanel.range.max;
      if (cameraNext >= lastPanelNext - needPanelThreshold || cameraPosition >= cameraRange.max - needPanelThreshold) {
        flicking.trigger(new ComponentEvent$1(EVENTS.NEED_PANEL, {
          direction: DIRECTION.NEXT
        }));
        needPanelTriggered.next = true;
      }
    }
  };
  __proto._checkReachEnd = function (prevPos, newPos) {
    var flicking = getFlickingAttached(this._flicking);
    var range = this._range;
    var wasBetweenRange = prevPos > range.min && prevPos < range.max;
    var isBetweenRange = newPos > range.min && newPos < range.max;
    if (!wasBetweenRange || isBetweenRange) return;
    var direction = newPos <= range.min ? DIRECTION.PREV : DIRECTION.NEXT;
    flicking.trigger(new ComponentEvent$1(EVENTS.REACH_EDGE, {
      direction: direction
    }));
  };
  __proto._updateMode = function () {
    var flicking = getFlickingAttached(this._flicking);
    if (flicking.circular) {
      var circularMode = new CircularCameraMode(flicking);
      var canSetCircularMode = circularMode.checkAvailability();
      if (canSetCircularMode) {
        this._mode = circularMode;
      } else {
        var fallbackMode = flicking.circularFallback;
        this._mode = fallbackMode === CIRCULAR_FALLBACK.BOUND ? new BoundCameraMode(flicking) : new LinearCameraMode(flicking);
      }
      this._circularEnabled = canSetCircularMode;
    } else {
      this._mode = flicking.bound ? new BoundCameraMode(flicking) : new LinearCameraMode(flicking);
      this._circularEnabled = false;
    }
  };
  __proto._togglePanels = function (prevPos, pos) {
    if (pos === prevPos) return false;
    var flicking = getFlickingAttached(this._flicking);
    var panels = flicking.renderer.panels;
    var toggled = panels.map(function (panel) {
      return panel.toggle(prevPos, pos);
    });
    return toggled.some(function (isToggled) {
      return isToggled;
    });
  };
  return Camera;
}();

/**
 * A component that manages {@link Panel} and its elements
 * @ko {@link Panel}과 그 엘리먼트들을 관리하는 컴포넌트
 */
var Renderer = /*#__PURE__*/function () {
  /**
   * @param {object} options An options object<ko>옵션 오브젝트</ko>
   * @param {Constants.ALIGN | string | number} [options.align="center"] An {@link Flicking#align align} value that will be applied to all panels<ko>전체 패널에 적용될 {@link Flicking#align align} 값</ko>
   * @param {object} [options.strategy] An instance of RenderingStrategy(internal module)<ko>RenderingStrategy의 인스턴스(내부 모듈)</ko>
   */
  function Renderer(_a) {
    var _b = _a.align,
      align = _b === void 0 ? ALIGN.CENTER : _b,
      strategy = _a.strategy;
    this._flicking = null;
    this._panels = [];
    this._rendering = false;
    // Bind options
    this._align = align;
    this._strategy = strategy;
  }
  var __proto = Renderer.prototype;
  Object.defineProperty(__proto, "panels", {
    // Internal states Getter
    /**
     * Array of panels
     * @ko 전체 패널들의 배열
     * @type {Panel[]}
     * @readonly
     * @see Panel
     */
    get: function () {
      return this._panels;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "rendering", {
    /**
     * A boolean value indicating whether rendering is in progress
     * @ko 현재 렌더링이 시작되어 끝나기 전까지의 상태인지의 여부
     * @type {boolean}
     * @readonly
     * @internal
     */
    get: function () {
      return this._rendering;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "panelCount", {
    /**
     * Count of panels
     * @ko 전체 패널의 개수
     * @type {number}
     * @readonly
     */
    get: function () {
      return this._panels.length;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "strategy", {
    /**
     * @internal
     */
    get: function () {
      return this._strategy;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "align", {
    // Options Getter
    /**
     * A {@link Panel}'s {@link Panel#align align} value that applied to all panels
     * @ko {@link Panel}에 공통적으로 적용할 {@link Panel#align align} 값
     * @type {Constants.ALIGN | string | number}
     */
    get: function () {
      return this._align;
    },
    // Options Setter
    set: function (val) {
      this._align = val;
      var panelAlign = parsePanelAlign(val);
      this._panels.forEach(function (panel) {
        panel.align = panelAlign;
      });
    },
    enumerable: false,
    configurable: true
  });
  /**
   * Initialize Renderer
   * @ko Renderer를 초기화합니다
   * @param {Flicking} flicking An instance of {@link Flicking}<ko>Flicking의 인스턴스</ko>
   * @chainable
   * @return {this}
   */
  __proto.init = function (flicking) {
    this._flicking = flicking;
    this._collectPanels();
    return this;
  };
  /**
   * Destroy Renderer and return to initial state
   * @ko Renderer를 초기 상태로 되돌립니다
   * @return {void}
   */
  __proto.destroy = function () {
    this._flicking = null;
    this._panels = [];
  };
  /**
   * Return the {@link Panel} at the given index. `null` if it doesn't exists.
   * @ko 주어진 인덱스에 해당하는 {@link Panel}을 반환합니다. 주어진 인덱스에 해당하는 패널이 존재하지 않을 경우 `null`을 반환합니다.
   * @return {Panel | null} Panel at the given index<ko>주어진 인덱스에 해당하는 패널</ko>
   * @see Panel
   */
  __proto.getPanel = function (index) {
    return this._panels[index] || null;
  };
  __proto.forceRenderAllPanels = function () {
    this._panels.forEach(function (panel) {
      return panel.markForShow();
    });
    return Promise.resolve();
  };
  /**
   * Update all panel sizes
   * @ko 모든 패널의 크기를 업데이트합니다
   * @chainable
   * @return {this}
   */
  __proto.updatePanelSize = function () {
    var flicking = getFlickingAttached(this._flicking);
    var panels = this._panels;
    if (panels.length <= 0) return this;
    if (flicking.panelsPerView > 0) {
      var firstPanel = panels[0];
      firstPanel.resize();
      this._updatePanelSizeByGrid(firstPanel, panels);
    } else {
      flicking.panels.forEach(function (panel) {
        return panel.resize();
      });
    }
    return this;
  };
  /**
   * Insert new panels at given index
   * This will increase index of panels after by the number of panels added
   * @ko 주어진 인덱스에 새로운 패널들을 추가합니다
   * 해당 인덱스보다 같거나 큰 인덱스를 가진 기존 패널들은 추가한 패널의 개수만큼 인덱스가 증가합니다.
   * @param {Array<object>} items An array of items to insert<ko>추가할 아이템들의 배열</ko>
   * @param {number} [items.index] Index to insert new panels at<ko>새로 패널들을 추가할 인덱스</ko>
   * @param {any[]} [items.elements] An array of element or framework component with element in it<ko>엘리먼트의 배열 혹은 프레임워크에서 엘리먼트를 포함한 컴포넌트들의 배열</ko>
   * @param {boolean} [items.hasDOMInElements] Whether it contains actual DOM elements. If set to true, renderer will add them to the camera element<ko>내부에 실제 DOM 엘리먼트들을 포함하고 있는지 여부. true로 설정할 경우, 렌더러는 해당 엘리먼트들을 카메라 엘리먼트 내부에 추가합니다</ko>
   * @return {Panel[]} An array of prepended panels<ko>추가된 패널들의 배열</ko>
   */
  __proto.batchInsert = function () {
    var items = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      items[_i] = arguments[_i];
    }
    var allPanelsInserted = this.batchInsertDefer.apply(this, __spread$1(items));
    if (allPanelsInserted.length <= 0) return [];
    this.updateAfterPanelChange(allPanelsInserted, []);
    return allPanelsInserted;
  };
  /**
   * Defers update
   * camera position & others will be updated after calling updateAfterPanelChange
   * @internal
   */
  __proto.batchInsertDefer = function () {
    var _this = this;
    var items = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      items[_i] = arguments[_i];
    }
    var panels = this._panels;
    var flicking = getFlickingAttached(this._flicking);
    var prevFirstPanel = panels[0];
    var align = parsePanelAlign(this._align);
    var allPanelsInserted = items.reduce(function (addedPanels, item) {
      var _a;
      var insertingIdx = getMinusCompensatedIndex(item.index, panels.length);
      var panelsPushed = panels.slice(insertingIdx);
      var panelsInserted = item.elements.map(function (el, idx) {
        return _this._createPanel(el, {
          index: insertingIdx + idx,
          align: align,
          flicking: flicking
        });
      });
      panels.splice.apply(panels, __spread$1([insertingIdx, 0], panelsInserted));
      if (item.hasDOMInElements) {
        // Insert the actual elements as camera element's children
        _this._insertPanelElements(panelsInserted, (_a = panelsPushed[0]) !== null && _a !== void 0 ? _a : null);
      }
      // Resize the newly added panels
      if (flicking.panelsPerView > 0) {
        var firstPanel = prevFirstPanel || panelsInserted[0].resize();
        _this._updatePanelSizeByGrid(firstPanel, panelsInserted);
      } else {
        panelsInserted.forEach(function (panel) {
          return panel.resize();
        });
      }
      // Update panel indexes & positions
      panelsPushed.forEach(function (panel) {
        panel.increaseIndex(panelsInserted.length);
        panel.updatePosition();
      });
      return __spread$1(addedPanels, panelsInserted);
    }, []);
    return allPanelsInserted;
  };
  /**
   * Remove the panel at the given index
   * This will decrease index of panels after by the number of panels removed
   * @ko 주어진 인덱스의 패널을 제거합니다
   * 해당 인덱스보다 큰 인덱스를 가진 기존 패널들은 제거한 패널의 개수만큼 인덱스가 감소합니다
   * @param {Array<object>} items An array of items to remove<ko>제거할 아이템들의 배열</ko>
   * @param {number} [items.index] Index of panel to remove<ko>제거할 패널의 인덱스</ko>
   * @param {number} [items.deleteCount=1] Number of panels to remove from index<ko>`index` 이후로 제거할 패널의 개수</ko>
   * @param {boolean} [items.hasDOMInElements=1] Whether it contains actual DOM elements. If set to true, renderer will remove them from the camera element<ko>내부에 실제 DOM 엘리먼트들을 포함하고 있는지 여부. true로 설정할 경우, 렌더러는 해당 엘리먼트들을 카메라 엘리먼트 내부에서 제거합니다</ko>
   * @return An array of removed panels<ko>제거된 패널들의 배열</ko>
   */
  __proto.batchRemove = function () {
    var items = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      items[_i] = arguments[_i];
    }
    var allPanelsRemoved = this.batchRemoveDefer.apply(this, __spread$1(items));
    if (allPanelsRemoved.length <= 0) return [];
    this.updateAfterPanelChange([], allPanelsRemoved);
    return allPanelsRemoved;
  };
  /**
   * Defers update
   * camera position & others will be updated after calling updateAfterPanelChange
   * @internal
   */
  __proto.batchRemoveDefer = function () {
    var _this = this;
    var items = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      items[_i] = arguments[_i];
    }
    var panels = this._panels;
    var flicking = getFlickingAttached(this._flicking);
    var control = flicking.control;
    var activePanel = control.activePanel;
    var allPanelsRemoved = items.reduce(function (removed, item) {
      var index = item.index,
        deleteCount = item.deleteCount;
      var removingIdx = getMinusCompensatedIndex(index, panels.length);
      var panelsPulled = panels.slice(removingIdx + deleteCount);
      var panelsRemoved = panels.splice(removingIdx, deleteCount);
      if (panelsRemoved.length <= 0) return [];
      // Update panel indexes & positions
      panelsPulled.forEach(function (panel) {
        panel.decreaseIndex(panelsRemoved.length);
        panel.updatePosition();
      });
      if (item.hasDOMInElements) {
        _this._removePanelElements(panelsRemoved);
      }
      // Remove panel elements
      panelsRemoved.forEach(function (panel) {
        return panel.destroy();
      });
      if (includes(panelsRemoved, activePanel)) {
        control.resetActive();
      }
      return __spread$1(removed, panelsRemoved);
    }, []);
    return allPanelsRemoved;
  };
  /**
   * @internal
   */
  __proto.updateAfterPanelChange = function (panelsAdded, panelsRemoved) {
    var _a;
    var flicking = getFlickingAttached(this._flicking);
    var camera = flicking.camera,
      control = flicking.control;
    var panels = this._panels;
    var activePanel = control.activePanel;
    // Update camera & control
    this._updateCameraAndControl();
    void this.render();
    if (!flicking.animating) {
      if (!activePanel || activePanel.removed) {
        if (panels.length <= 0) {
          // All panels removed
          camera.lookAt(0);
        } else {
          var targetIndex = (_a = activePanel === null || activePanel === void 0 ? void 0 : activePanel.index) !== null && _a !== void 0 ? _a : 0;
          if (targetIndex > panels.length - 1) {
            targetIndex = panels.length - 1;
          }
          void control.moveToPanel(panels[targetIndex], {
            duration: 0
          }).catch(function () {
            return void 0;
          });
        }
      } else {
        void control.moveToPanel(activePanel, {
          duration: 0
        }).catch(function () {
          return void 0;
        });
      }
    }
    flicking.camera.updateOffset();
    if (panelsAdded.length > 0 || panelsRemoved.length > 0) {
      flicking.trigger(new ComponentEvent$1(EVENTS.PANEL_CHANGE, {
        added: panelsAdded,
        removed: panelsRemoved
      }));
      this.checkPanelContentsReady(__spread$1(panelsAdded, panelsRemoved));
    }
  };
  /**
   * @internal
   */
  __proto.checkPanelContentsReady = function (checkingPanels) {
    var _this = this;
    var flicking = getFlickingAttached(this._flicking);
    var resizeOnContentsReady = flicking.resizeOnContentsReady;
    var panels = this._panels;
    if (!resizeOnContentsReady || flicking.virtualEnabled) return;
    var hasContents = function (panel) {
      return panel.element && !!panel.element.querySelector("img, video");
    };
    checkingPanels = checkingPanels.filter(function (panel) {
      return hasContents(panel);
    });
    if (checkingPanels.length <= 0) return;
    var contentsReadyChecker = new ImReady();
    checkingPanels.forEach(function (panel) {
      panel.loading = true;
    });
    contentsReadyChecker.on("readyElement", function (e) {
      if (!_this._flicking) {
        // Renderer's destroy() is called before
        contentsReadyChecker.destroy();
        return;
      }
      var panel = checkingPanels[e.index];
      var camera = flicking.camera;
      var control = flicking.control;
      var prevProgressInPanel = control.activePanel ? camera.getProgressInPanel(control.activePanel) : 0;
      panel.loading = false;
      panel.resize();
      panels.slice(panel.index + 1).forEach(function (panelBehind) {
        return panelBehind.updatePosition();
      });
      if (!flicking.initialized) return;
      camera.updateRange();
      camera.updateOffset();
      camera.updateAnchors();
      if (control.animating) ; else {
        control.updatePosition(prevProgressInPanel);
        control.updateInput();
      }
    });
    contentsReadyChecker.on("preReady", function (e) {
      if (_this._flicking) {
        void _this.render();
      }
      if (e.readyCount === e.totalCount) {
        contentsReadyChecker.destroy();
      }
    });
    contentsReadyChecker.on("ready", function () {
      if (_this._flicking) {
        void _this.render();
      }
      contentsReadyChecker.destroy();
    });
    contentsReadyChecker.check(checkingPanels.map(function (panel) {
      return panel.element;
    }));
  };
  __proto._updateCameraAndControl = function () {
    var flicking = getFlickingAttached(this._flicking);
    var camera = flicking.camera,
      control = flicking.control;
    camera.updateRange();
    camera.updateOffset();
    camera.updateAnchors();
    camera.resetNeedPanelHistory();
    control.updateInput();
  };
  __proto._showOnlyVisiblePanels = function (flicking) {
    var panels = flicking.renderer.panels;
    var camera = flicking.camera;
    var visibleIndexes = camera.visiblePanels.reduce(function (visibles, panel) {
      visibles[panel.index] = true;
      return visibles;
    }, {});
    panels.forEach(function (panel) {
      if (panel.index in visibleIndexes || panel.loading) {
        panel.markForShow();
      } else if (!flicking.holding) {
        // During the input sequence,
        // Do not remove panel elements as it won't trigger touchend event.
        panel.markForHide();
      }
    });
  };
  __proto._updatePanelSizeByGrid = function (referencePanel, panels) {
    var flicking = getFlickingAttached(this._flicking);
    var panelsPerView = flicking.panelsPerView;
    if (panelsPerView <= 0) {
      throw new FlickingError(MESSAGE.WRONG_OPTION("panelsPerView", panelsPerView), CODE.WRONG_OPTION);
    }
    if (panels.length <= 0) return;
    var viewportSize = flicking.camera.size;
    var gap = referencePanel.margin.prev + referencePanel.margin.next;
    var panelSize = (viewportSize - gap * (panelsPerView - 1)) / panelsPerView;
    var panelSizeObj = flicking.horizontal ? {
      width: panelSize
    } : {
      height: panelSize
    };
    var firstPanelSizeObj = __assign$2({
      size: panelSize,
      margin: referencePanel.margin
    }, !flicking.horizontal && {
      height: referencePanel.height
    });
    if (!flicking.noPanelStyleOverride) {
      this._strategy.updatePanelSizes(flicking, panelSizeObj);
    }
    flicking.panels.forEach(function (panel) {
      return panel.resize(firstPanelSizeObj);
    });
  };
  __proto._removeAllChildsFromCamera = function () {
    var flicking = getFlickingAttached(this._flicking);
    var cameraElement = flicking.camera.element;
    // Remove other elements
    while (cameraElement.firstChild) {
      cameraElement.removeChild(cameraElement.firstChild);
    }
  };
  __proto._insertPanelElements = function (panels, nextSibling) {
    if (nextSibling === void 0) {
      nextSibling = null;
    }
    var flicking = getFlickingAttached(this._flicking);
    var camera = flicking.camera;
    var cameraElement = camera.element;
    var nextSiblingElement = (nextSibling === null || nextSibling === void 0 ? void 0 : nextSibling.element) || null;
    var fragment = document.createDocumentFragment();
    panels.forEach(function (panel) {
      return fragment.appendChild(panel.element);
    });
    cameraElement.insertBefore(fragment, nextSiblingElement);
  };
  __proto._removePanelElements = function (panels) {
    var flicking = getFlickingAttached(this._flicking);
    var cameraElement = flicking.camera.element;
    panels.forEach(function (panel) {
      cameraElement.removeChild(panel.element);
    });
  };
  __proto._afterRender = function () {
    var flicking = getFlickingAttached(this._flicking);
    flicking.camera.applyTransform();
  };
  return Renderer;
}();

/**
 *
 */
var VanillaRenderer = /*#__PURE__*/function (_super) {
  __extends$3(VanillaRenderer, _super);
  function VanillaRenderer() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  // eslint-disable-next-line @typescript-eslint/require-await
  var __proto = VanillaRenderer.prototype;
  __proto.render = function () {
    return __awaiter(this, void 0, void 0, function () {
      var flicking, strategy;
      return __generator(this, function (_a) {
        flicking = getFlickingAttached(this._flicking);
        strategy = this._strategy;
        strategy.updateRenderingPanels(flicking);
        strategy.renderPanels(flicking);
        this._resetPanelElementOrder();
        this._afterRender();
        return [2 /*return*/];
      });
    });
  };

  __proto._collectPanels = function () {
    var flicking = getFlickingAttached(this._flicking);
    var camera = flicking.camera;
    this._removeAllTextNodes();
    this._panels = this._strategy.collectPanels(flicking, camera.children);
  };
  __proto._createPanel = function (el, options) {
    return this._strategy.createPanel(el, options);
  };
  __proto._resetPanelElementOrder = function () {
    var flicking = getFlickingAttached(this._flicking);
    var cameraEl = flicking.camera.element;
    // We're using reversed panels here as last panel should be the last element of camera element
    var reversedElements = this._strategy.getRenderingElementsByOrder(flicking).reverse();
    reversedElements.forEach(function (el, idx) {
      var nextEl = reversedElements[idx - 1] ? reversedElements[idx - 1] : null;
      if (el.nextElementSibling !== nextEl) {
        cameraEl.insertBefore(el, nextEl);
      }
    });
  };
  __proto._removeAllTextNodes = function () {
    var flicking = getFlickingAttached(this._flicking);
    var cameraElement = flicking.camera.element;
    // Remove all text nodes in the camera element
    toArray$2(cameraElement.childNodes).forEach(function (node) {
      if (node.nodeType === Node.TEXT_NODE) {
        cameraElement.removeChild(node);
      }
    });
  };
  return VanillaRenderer;
}(Renderer);

/**
 * @internal
 */
var ExternalRenderer = /*#__PURE__*/function (_super) {
  __extends$3(ExternalRenderer, _super);
  function ExternalRenderer() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  /* eslint-disable @typescript-eslint/no-unused-vars */
  var __proto = ExternalRenderer.prototype;
  __proto._removePanelElements = function (panels) {
    // DO NOTHING, overrided to prevent an unexpected error
  };
  __proto._removeAllChildsFromCamera = function () {
    // DO NOTHING, overrided to prevent an unexpected error
  };
  return ExternalRenderer;
}(Renderer);

/**
 * A slide data component that holds information of a single HTMLElement
 * @ko 슬라이드 데이터 컴포넌트로, 단일 HTMLElement의 정보를 갖고 있습니다
 */
var Panel = /*#__PURE__*/function () {
  /**
   * @param {object} options An options object<ko>옵션 오브젝트</ko>
   * @param {number} [options.index] An initial index of the panel<ko>패널의 초기 인덱스</ko>
   * @param {Constants.ALIGN | string | number} [options.align] An initial {@link Flicking#align align} value of the panel<ko>패널의 초기 {@link Flicking#align align}값</ko>
   * @param {Flicking} [options.flicking] A Flicking instance panel's referencing<ko>패널이 참조하는 {@link Flicking} 인스턴스</ko>
   * @param {Flicking} [options.elementProvider] A provider instance that redirects elements<ko>실제 엘리먼트를 반환하는 엘리먼트 공급자의 인스턴스</ko>
   */
  function Panel(_a) {
    var index = _a.index,
      align = _a.align,
      flicking = _a.flicking,
      elementProvider = _a.elementProvider;
    this._index = index;
    this._flicking = flicking;
    this._elProvider = elementProvider;
    this._align = align;
    this._removed = false;
    this._rendered = true;
    this._loading = false;
    this._resetInternalStates();
  }
  var __proto = Panel.prototype;
  Object.defineProperty(__proto, "element", {
    // Internal States Getter
    /**
     * `HTMLElement` that panel's referencing
     * @ko 패널이 참조하고 있는 `HTMLElement`
     * @type {HTMLElement}
     * @readonly
     */
    get: function () {
      return this._elProvider.element;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "elementProvider", {
    /**
     * @internal
     * @readonly
     */
    get: function () {
      return this._elProvider;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "index", {
    /**
     * Index of the panel
     * @ko 패널의 인덱스
     * @type {number}
     * @readonly
     */
    get: function () {
      return this._index;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "position", {
    /**
     * Position of the panel, including {@link Panel#alignPosition alignPosition}
     * @ko 패널의 현재 좌표, {@link Panel#alignPosition alignPosition}을 포함하고 있습니다
     * @type {number}
     * @readonly
     */
    get: function () {
      return this._pos + this._alignPos;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "size", {
    /**
     * Cached size of the panel element
     * This is equal to {@link Panel#element element}'s `offsetWidth` if {@link Flicking#horizontal horizontal} is `true`, and `offsetHeight` else
     * @ko 패널 엘리먼트의 캐시된 크기
     * 이 값은 {@link Flicking#horizontal horizontal}이 `true`일 경우 {@link Panel#element element}의 `offsetWidth`와 동일하고, `false`일 경우 `offsetHeight`와 동일합니다
     * @type {number}
     * @readonly
     */
    get: function () {
      return this._size;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "sizeIncludingMargin", {
    /**
     * Panel's size including CSS `margin`
     * This value includes {@link Panel#element element}'s margin left/right if {@link Flicking#horizontal horizontal} is `true`, and margin top/bottom else
     * @ko CSS `margin`을 포함한 패널의 크기
     * 이 값은 {@link Flicking#horizontal horizontal}이 `true`일 경우 margin left/right을 포함하고, `false`일 경우 margin top/bottom을 포함합니다
     * @type {number}
     * @readonly
     */
    get: function () {
      return this._size + this._margin.prev + this._margin.next;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "height", {
    /**
     * Height of the panel element
     * @ko 패널 엘리먼트의 높이
     * @type {number}
     * @readonly
     */
    get: function () {
      return this._height;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "margin", {
    /**
     * Cached CSS `margin` value of the panel element
     * @ko 패널 엘리먼트의 CSS `margin` 값
     * @type {object}
     * @property {number} prev CSS `margin-left` when the {@link Flicking#horizontal horizontal} is `true`, and `margin-top` else
     * <ko>{@link Flicking#horizontal horizontal}이 `true`일 경우 `margin-left`, `false`일 경우 `margin-top`에 해당하는 값</ko>
     * @property {number} next CSS `margin-right` when the {@link Flicking#horizontal horizontal} is `true`, and `margin-bottom` else
     * <ko>{@link Flicking#horizontal horizontal}이 `true`일 경우 `margin-right`, `false`일 경우 `margin-bottom`에 해당하는 값</ko>
     * @readonly
     */
    get: function () {
      return this._margin;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "alignPosition", {
    /**
     * Align position inside the panel where {@link Camera}'s {@link Camera#alignPosition alignPosition} inside viewport should be located at
     * @ko 패널의 정렬 기준 위치. {@link Camera}의 뷰포트 내에서의 {@link Camera#alignPosition alignPosition}이 위치해야 하는 곳입니다
     * @type {number}
     * @readonly
     */
    get: function () {
      return this._alignPos;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "removed", {
    /**
     * A value indicating whether the panel's {@link Flicking#remove remove}d
     * @ko 패널이 {@link Flicking#remove remove}되었는지 여부를 나타내는 값
     * @type {boolean}
     * @readonly
     */
    get: function () {
      return this._removed;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "rendered", {
    /**
     * A value indicating whether the panel's element is being rendered on the screen
     * @ko 패널의 엘리먼트가 화면상에 렌더링되고있는지 여부를 나타내는 값
     * @type {boolean}
     * @readonly
     */
    get: function () {
      return this._rendered;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "loading", {
    /**
     * A value indicating whether the panel's image/video is not loaded and waiting for resize
     * @ko 패널 내부의 이미지/비디오가 아직 로드되지 않아 {@link Panel#resize resize}될 것인지를 나타내는 값
     * @type {boolean}
     * @readonly
     */
    get: function () {
      return this._loading;
    },
    set: function (val) {
      this._loading = val;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "range", {
    /**
     * Panel element's range of the bounding box
     * @ko 패널 엘리먼트의 Bounding box 범위
     * @type {object}
     * @property {number} [min] Bounding box's left({@link Flicking#horizontal horizontal}: true) / top({@link Flicking#horizontal horizontal}: false)
     * @property {number} [max] Bounding box's right({@link Flicking#horizontal horizontal}: true) / bottom({@link Flicking#horizontal horizontal}: false)
     * @readonly
     */
    get: function () {
      return {
        min: this._pos,
        max: this._pos + this._size
      };
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "toggled", {
    /**
     * A value indicating whether the panel's position is toggled by circular behavior
     * @ko 패널의 위치가 circular 동작에 의해 토글되었는지 여부를 나타내는 값
     * @type {boolean}
     * @readonly
     */
    get: function () {
      return this._toggled;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "toggleDirection", {
    /**
     * A direction where the panel's position is toggled
     * @ko 패널의 위치가 circular 동작에 의해 토글되는 방향
     * @type {DIRECTION}
     * @readonly
     */
    get: function () {
      return this._toggleDirection;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "offset", {
    /**
     * Actual position offset determined by {@link Panel#order}
     * @ko {@link Panel#order}에 의한 실제 위치 변경값
     * @type {number}
     * @readonly
     */
    get: function () {
      var toggleDirection = this._toggleDirection;
      var cameraRangeDiff = this._flicking.camera.rangeDiff;
      return toggleDirection === DIRECTION.NONE || !this._toggled ? 0 : toggleDirection === DIRECTION.PREV ? -cameraRangeDiff : cameraRangeDiff;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "progress", {
    /**
     * Progress of movement between previous or next panel relative to current panel
     * @ko 이 패널로부터 이전/다음 패널으로의 이동 진행률
     * @type {number}
     * @readonly
     */
    get: function () {
      var flicking = this._flicking;
      return this.index - flicking.camera.progress;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "outsetProgress", {
    /**
     * Progress of movement between points that panel is completely invisible outside of viewport(prev direction: -1, selected point: 0, next direction: 1)
     * @ko 현재 패널이 뷰포트 영역 밖으로 완전히 사라지는 지점을 기준으로 하는 진행도(prev방향: -1, 선택 지점: 0, next방향: 1)
     * @type {number}
     * @readonly
     */
    get: function () {
      var position = this.position + this.offset;
      var alignPosition = this._alignPos;
      var camera = this._flicking.camera;
      var camPos = camera.position;
      if (camPos === position) {
        return 0;
      }
      if (camPos < position) {
        var disappearPosNext = position + (camera.size - camera.alignPosition) + alignPosition;
        return -getProgress(camPos, position, disappearPosNext);
      } else {
        var disappearPosPrev = position - (camera.alignPosition + this._size - alignPosition);
        return 1 - getProgress(camPos, disappearPosPrev, position);
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "visibleRatio", {
    /**
     * Percentage of area where panel is visible in the viewport
     * @ko 뷰포트 안에서 패널이 보이는 영역의 비율
     * @type {number}
     * @readonly
     */
    get: function () {
      var range = this.range;
      var size = this._size;
      var offset = this.offset;
      var visibleRange = this._flicking.camera.visibleRange;
      var checkingRange = {
        min: range.min + offset,
        max: range.max + offset
      };
      if (checkingRange.max <= visibleRange.min || checkingRange.min >= visibleRange.max) {
        return 0;
      }
      var visibleSize = size;
      if (visibleRange.min > checkingRange.min) {
        visibleSize -= visibleRange.min - checkingRange.min;
      }
      if (visibleRange.max < checkingRange.max) {
        visibleSize -= checkingRange.max - visibleRange.max;
      }
      return visibleSize / size;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "align", {
    // Options Getter
    /**
     * A value indicating where the {@link Panel#alignPosition alignPosition} should be located at inside the panel element
     * @ko {@link Panel#alignPosition alignPosition}이 패널 내의 어디에 위치해야 하는지를 나타내는 값
     * @type {Constants.ALIGN | string | number}
     */
    get: function () {
      return this._align;
    },
    // Options Setter
    set: function (val) {
      this._align = val;
      this._updateAlignPos();
    },
    enumerable: false,
    configurable: true
  });
  /**
   * Mark panel element to be appended on the camera element
   * @internal
   */
  __proto.markForShow = function () {
    this._rendered = true;
    this._elProvider.show(this._flicking);
  };
  /**
   * Mark panel element to be removed from the camera element
   * @internal
   */
  __proto.markForHide = function () {
    this._rendered = false;
    this._elProvider.hide(this._flicking);
  };
  /**
   * Update size of the panel
   * @ko 패널의 크기를 갱신합니다
   * @param {object} cached Predefined cached size of the panel<ko>사전에 캐시된 패널의 크기 정보</ko>
   * @chainable
   * @return {this}
   */
  __proto.resize = function (cached) {
    var _a;
    var el = this.element;
    var flicking = this._flicking;
    var horizontal = flicking.horizontal,
      useFractionalSize = flicking.useFractionalSize;
    if (cached) {
      this._size = cached.size;
      this._margin = __assign$2({}, cached.margin);
      this._height = (_a = cached.height) !== null && _a !== void 0 ? _a : getElementSize({
        el: el,
        horizontal: false,
        useFractionalSize: useFractionalSize,
        useOffset: true,
        style: getStyle(el)
      });
    } else {
      var elStyle = getStyle(el);
      this._size = getElementSize({
        el: el,
        horizontal: horizontal,
        useFractionalSize: useFractionalSize,
        useOffset: true,
        style: elStyle
      });
      this._margin = horizontal ? {
        prev: parseFloat(elStyle.marginLeft || "0"),
        next: parseFloat(elStyle.marginRight || "0")
      } : {
        prev: parseFloat(elStyle.marginTop || "0"),
        next: parseFloat(elStyle.marginBottom || "0")
      };
      this._height = horizontal ? getElementSize({
        el: el,
        horizontal: false,
        useFractionalSize: useFractionalSize,
        useOffset: true,
        style: elStyle
      }) : this._size;
    }
    this.updatePosition();
    this._updateAlignPos();
    return this;
  };
  /**
   * Change panel's size. This will change the actual size of the panel element by changing its CSS width/height property
   * @ko 패널 크기를 변경합니다. 패널 엘리먼트에 해당 크기의 CSS width/height를 적용합니다
   * @param {object} [size] New panel size<ko>새 패널 크기</ko>
   * @param {number|string} [size.width] CSS string or number(in px)<ko>CSS 문자열 또는 숫자(px)</ko>
   * @param {number|string} [size.height] CSS string or number(in px)<ko>CSS 문자열 또는 숫자(px)</ko>
   * @chainable
   * @return {this}
   */
  __proto.setSize = function (size) {
    setSize(this.element, size);
    return this;
  };
  /**
   * Check whether the given element is inside of this panel's {@link Panel#element element}
   * @ko 해당 엘리먼트가 이 패널의 {@link Panel#element element} 내에 포함되어 있는지를 반환합니다
   * @param {HTMLElement} element The HTMLElement to check<ko>확인하고자 하는 HTMLElement</ko>
   * @return {boolean} A Boolean value indicating the element is inside of this panel {@link Panel#element element}<ko>패널의 {@link Panel#element element}내에 해당 엘리먼트 포함 여부</ko>
   */
  __proto.contains = function (element) {
    var _a;
    return !!((_a = this.element) === null || _a === void 0 ? void 0 : _a.contains(element));
  };
  /**
   * Reset internal state and set {@link Panel#removed removed} to `true`
   * @ko 내부 상태를 초기화하고 {@link Panel#removed removed}를 `true`로 설정합니다.
   * @return {void}
   */
  __proto.destroy = function () {
    this._resetInternalStates();
    this._removed = true;
  };
  /**
   * Check whether the given position is inside of this panel's {@link Panel#range range}
   * @ko 주어진 좌표가 현재 패널의 {@link Panel#range range}내에 속해있는지를 반환합니다.
   * @param {number} pos A position to check<ko>확인하고자 하는 좌표</ko>
   * @param {boolean} [includeMargin=false] Include {@link Panel#margin margin} to the range<ko>패널 영역에 {@link Panel#margin margin}값을 포함시킵니다</ko>
   * @return {boolean} A Boolean value indicating whether the given position is included in the panel range<ko>해당 좌표가 패널 영역 내에 속해있는지 여부</ko>
   */
  __proto.includePosition = function (pos, includeMargin) {
    if (includeMargin === void 0) {
      includeMargin = false;
    }
    return this.includeRange(pos, pos, includeMargin);
  };
  /**
   * Check whether the given range is fully included in this panel's area (inclusive)
   * @ko 주어진 범위가 이 패널 내부에 완전히 포함되는지를 반환합니다
   * @param {number} min Minimum value of the range to check<ko>확인하고자 하는 최소 범위</ko>
   * @param {number} max Maximum value of the range to check<ko>확인하고자 하는 최대 범위</ko>
   * @param {boolean} [includeMargin=false] Include {@link Panel#margin margin} to the range<ko>패널 영역에 {@link Panel#margin margin}값을 포함시킵니다</ko>
   * @returns {boolean} A Boolean value indicating whether the given range is fully included in the panel range<ko>해당 범위가 패널 영역 내에 완전히 속해있는지 여부</ko>
   */
  __proto.includeRange = function (min, max, includeMargin) {
    if (includeMargin === void 0) {
      includeMargin = false;
    }
    var margin = this._margin;
    var panelRange = this.range;
    if (includeMargin) {
      panelRange.min -= margin.prev;
      panelRange.max += margin.next;
    }
    return max >= panelRange.min && min <= panelRange.max;
  };
  /**
   * Check whether the panel is visble in the given range (exclusive)
   * @ko 주어진 범위 내에서 이 패널의 일부가 보여지는지를 반환합니다
   * @param {number} min Minimum value of the range to check<ko>확인하고자 하는 최소 범위</ko>
   * @param {number} max Maximum value of the range to check<ko>확인하고자 하는 최대 범위</ko>
   * @returns {boolean} A Boolean value indicating whether the panel is visible<ko>해당 범위 내에서 패널을 볼 수 있는지 여부</ko>
   */
  __proto.isVisibleOnRange = function (min, max) {
    var panelRange = this.range;
    return max > panelRange.min && min < panelRange.max;
  };
  /**
   * Move {@link Camera} to this panel
   * @ko {@link Camera}를 이 패널로 이동합니다
   * @param {number} [duration] Duration of the animation (unit: ms)<ko>애니메이션 진행 시간 (단위: ms)</ko>
   * @returns {Promise<void>} A Promise which will be resolved after reaching the panel<ko>패널 도달시에 resolve되는 Promise</ko>
   */
  __proto.focus = function (duration) {
    return this._flicking.moveTo(this._index, duration);
  };
  /**
   * Get previous(`index - 1`) panel. When the previous panel does not exist, this will return `null` instead
   * If the {@link Flicking#circularEnabled circular} is enabled, this will return the last panel if called from the first panel
   * @ko 이전(`index - 1`) 패널을 반환합니다. 이전 패널이 없을 경우 `null`을 반환합니다
   * {@link Flicking#circularEnabled circular} 모드가 활성화되었을 때 첫번째 패널에서 이 메소드를 호출할 경우 마지막 패널을 반환합니다
   * @returns {Panel | null} The previous panel<ko>이전 패널</ko>
   */
  __proto.prev = function () {
    var index = this._index;
    var flicking = this._flicking;
    var renderer = flicking.renderer;
    var panelCount = renderer.panelCount;
    if (panelCount === 1) return null;
    return flicking.circularEnabled ? renderer.getPanel(index === 0 ? panelCount - 1 : index - 1) : renderer.getPanel(index - 1);
  };
  /**
   * Get next(`index + 1`) panel. When the next panel does not exist, this will return `null` instead
   * If the {@link Flicking#circularEnabled circular} is enabled, this will return the first panel if called from the last panel
   * @ko 다음(`index + 1`) 패널을 반환합니다. 다음 패널이 없을 경우 `null`을 반환합니다
   * {@link Flicking#circularEnabled circular} 모드가 활성화되었을 때 마지막 패널에서 이 메소드를 호출할 경우 첫번째 패널을 반환합니다
   * @returns {Panel | null} The previous panel<ko>다음 패널</ko>
   */
  __proto.next = function () {
    var index = this._index;
    var flicking = this._flicking;
    var renderer = flicking.renderer;
    var panelCount = renderer.panelCount;
    if (panelCount === 1) return null;
    return flicking.circularEnabled ? renderer.getPanel(index === panelCount - 1 ? 0 : index + 1) : renderer.getPanel(index + 1);
  };
  /**
   * Increase panel's index by the given value
   * @ko 패널의 인덱스를 주어진 값만큼 증가시킵니다
   * @internal
   * @chainable
   * @param val An integer greater than or equal to 0<ko>0보다 같거나 큰 정수</ko>
   * @returns {this}
   */
  __proto.increaseIndex = function (val) {
    this._index += Math.max(val, 0);
    return this;
  };
  /**
   * Decrease panel's index by the given value
   * @ko 패널의 인덱스를 주어진 값만큼 감소시킵니다
   * @internal
   * @chainable
   * @param val An integer greater than or equal to 0<ko>0보다 같거나 큰 정수</ko>
   * @returns {this}
   */
  __proto.decreaseIndex = function (val) {
    this._index -= Math.max(val, 0);
    return this;
  };
  /**
   * @internal
   */
  __proto.updatePosition = function () {
    var prevPanel = this._flicking.renderer.panels[this._index - 1];
    this._pos = prevPanel ? prevPanel.range.max + prevPanel.margin.next + this._margin.prev : this._margin.prev;
    return this;
  };
  /**
   * @internal
   * @return {boolean} toggled
   */
  __proto.toggle = function (prevPos, newPos) {
    var toggleDirection = this._toggleDirection;
    var togglePosition = this._togglePosition;
    if (toggleDirection === DIRECTION.NONE || newPos === prevPos) return false;
    var prevToggled = this._toggled;
    if (newPos > prevPos) {
      if (togglePosition >= prevPos && togglePosition <= newPos) {
        this._toggled = toggleDirection === DIRECTION.NEXT;
      }
    } else {
      if (togglePosition <= prevPos && togglePosition >= newPos) {
        this._toggled = toggleDirection !== DIRECTION.NEXT;
      }
    }
    return prevToggled !== this._toggled;
  };
  /**
   * @internal
   */
  __proto.updateCircularToggleDirection = function () {
    var flicking = this._flicking;
    if (!flicking.circularEnabled) {
      this._toggleDirection = DIRECTION.NONE;
      this._togglePosition = 0;
      this._toggled = false;
      return this;
    }
    var camera = flicking.camera;
    var camRange = camera.range;
    var camAlignPosition = camera.alignPosition;
    var camVisibleRange = camera.visibleRange;
    var camVisibleSize = camVisibleRange.max - camVisibleRange.min;
    var minimumVisible = camRange.min - camAlignPosition;
    var maximumVisible = camRange.max - camAlignPosition + camVisibleSize;
    var shouldBeVisibleAtMin = this.includeRange(maximumVisible - camVisibleSize, maximumVisible, false);
    var shouldBeVisibleAtMax = this.includeRange(minimumVisible, minimumVisible + camVisibleSize, false);
    this._toggled = false;
    if (shouldBeVisibleAtMin) {
      this._toggleDirection = DIRECTION.PREV;
      this._togglePosition = this.range.max + camRange.min - camRange.max + camAlignPosition;
      this.toggle(Infinity, camera.position);
    } else if (shouldBeVisibleAtMax) {
      this._toggleDirection = DIRECTION.NEXT;
      this._togglePosition = this.range.min + camRange.max - camVisibleSize + camAlignPosition;
      this.toggle(-Infinity, camera.position);
    } else {
      this._toggleDirection = DIRECTION.NONE;
      this._togglePosition = 0;
    }
    return this;
  };
  __proto._updateAlignPos = function () {
    this._alignPos = parseAlign$1(this._align, this._size);
  };
  __proto._resetInternalStates = function () {
    this._size = 0;
    this._pos = 0;
    this._margin = {
      prev: 0,
      next: 0
    };
    this._height = 0;
    this._alignPos = 0;
    this._toggled = false;
    this._togglePosition = 0;
    this._toggleDirection = DIRECTION.NONE;
  };
  return Panel;
}();

var NormalRenderingStrategy = /*#__PURE__*/function () {
  function NormalRenderingStrategy(_a) {
    var providerCtor = _a.providerCtor;
    this._providerCtor = providerCtor;
  }
  var __proto = NormalRenderingStrategy.prototype;
  __proto.renderPanels = function () {
    // DO_NOTHING
  };
  __proto.getRenderingIndexesByOrder = function (flicking) {
    var renderedPanels = flicking.renderer.panels.filter(function (panel) {
      return panel.rendered;
    });
    var toggledPrev = renderedPanels.filter(function (panel) {
      return panel.toggled && panel.toggleDirection === DIRECTION.PREV;
    });
    var toggledNext = renderedPanels.filter(function (panel) {
      return panel.toggled && panel.toggleDirection === DIRECTION.NEXT;
    });
    var notToggled = renderedPanels.filter(function (panel) {
      return !panel.toggled;
    });
    return __spread$1(toggledPrev, notToggled, toggledNext).map(function (panel) {
      return panel.index;
    });
  };
  __proto.getRenderingElementsByOrder = function (flicking) {
    var panels = flicking.panels;
    return this.getRenderingIndexesByOrder(flicking).map(function (index) {
      return panels[index].element;
    });
  };
  __proto.updateRenderingPanels = function (flicking) {
    if (flicking.renderOnlyVisible) {
      this._showOnlyVisiblePanels(flicking);
    } else {
      flicking.panels.forEach(function (panel) {
        return panel.markForShow();
      });
    }
  };
  __proto.collectPanels = function (flicking, elements) {
    var _this = this;
    var align = parsePanelAlign(flicking.renderer.align);
    return elements.map(function (el, index) {
      return new Panel({
        index: index,
        elementProvider: new _this._providerCtor(el),
        align: align,
        flicking: flicking
      });
    });
  };
  __proto.createPanel = function (element, options) {
    return new Panel(__assign$2(__assign$2({}, options), {
      elementProvider: new this._providerCtor(element)
    }));
  };
  __proto.updatePanelSizes = function (flicking, size) {
    flicking.panels.forEach(function (panel) {
      return panel.setSize(size);
    });
  };
  __proto._showOnlyVisiblePanels = function (flicking) {
    var panels = flicking.renderer.panels;
    var camera = flicking.camera;
    var visibleIndexes = camera.visiblePanels.reduce(function (visibles, panel) {
      visibles[panel.index] = true;
      return visibles;
    }, {});
    panels.forEach(function (panel) {
      if (panel.index in visibleIndexes || panel.loading) {
        panel.markForShow();
      } else if (!flicking.holding) {
        // During the input sequence,
        // Do not remove panel elements as it won't trigger touchend event.
        panel.markForHide();
      }
    });
    camera.updateOffset();
  };
  return NormalRenderingStrategy;
}();

/**
 * An slide data component that holds information of a single HTMLElement
 * @ko 슬라이드 데이터 컴포넌트로, 단일 HTMLElement의 정보를 갖고 있습니다
 */
var VirtualPanel = /*#__PURE__*/function (_super) {
  __extends$3(VirtualPanel, _super);
  /**
   * @param {object} options An options object<ko>옵션 오브젝트</ko>
   * @param {number} [options.index] An initial index of the panel<ko>패널의 초기 인덱스</ko>
   * @param {Constants.ALIGN | string | number} [options.align] An initial {@link Flicking#align align} value of the panel<ko>패널의 초기 {@link Flicking#align align}값</ko>
   * @param {Flicking} [options.flicking] A Flicking instance panel's referencing<ko>패널이 참조하는 {@link Flicking} 인스턴스</ko>
   */
  function VirtualPanel(options) {
    var _this = _super.call(this, options) || this;
    options.elementProvider.init(_this);
    _this._elProvider = options.elementProvider;
    _this._cachedInnerHTML = null;
    return _this;
  }
  var __proto = VirtualPanel.prototype;
  Object.defineProperty(__proto, "element", {
    /**
     * `HTMLElement` that panel's referencing
     * @ko 패널이 참조하고 있는 `HTMLElement`
     * @type {HTMLElement}
     * @readonly
     */
    get: function () {
      return this._elProvider.element;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "cachedInnerHTML", {
    /**
     * Cached innerHTML by the previous render function
     * @ko 이전 렌더링에서 캐시된 innerHTML 정보
     * @type {string|null}
     * @readonly
     */
    get: function () {
      return this._cachedInnerHTML;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "elementIndex", {
    /**
     * An number for indexing which element it will be rendered on
     * @ko 몇 번째 엘리먼트에 렌더링될 것인지를 나타내는 숫자
     * @type {number}
     * @readonly
     */
    get: function () {
      var flicking = this._flicking;
      var virtualElCount = flicking.panelsPerView + 1;
      var panelCount = flicking.panelCount;
      var index = this._index;
      if (this._toggled) {
        // To prevent element duplication
        index = this._toggleDirection === DIRECTION.NEXT ? index + panelCount : index - panelCount;
      }
      return circulateIndex(index, virtualElCount);
    },
    enumerable: false,
    configurable: true
  });
  __proto.cacheRenderResult = function (result) {
    this._cachedInnerHTML = result;
  };
  __proto.uncacheRenderResult = function () {
    this._cachedInnerHTML = null;
  };
  __proto.render = function () {
    var flicking = this._flicking;
    var _a = flicking.virtual,
      renderPanel = _a.renderPanel,
      cache = _a.cache;
    var element = this._elProvider.element;
    var newInnerHTML = this._cachedInnerHTML || renderPanel(this, this._index);
    if (newInnerHTML === element.innerHTML) return;
    element.innerHTML = newInnerHTML;
    if (cache) {
      this.cacheRenderResult(newInnerHTML);
    }
  };
  __proto.increaseIndex = function (val) {
    this.uncacheRenderResult();
    return _super.prototype.increaseIndex.call(this, val);
  };
  __proto.decreaseIndex = function (val) {
    this.uncacheRenderResult();
    return _super.prototype.decreaseIndex.call(this, val);
  };
  return VirtualPanel;
}(Panel);

var VirtualRenderingStrategy = /*#__PURE__*/function () {
  function VirtualRenderingStrategy() {}
  var __proto = VirtualRenderingStrategy.prototype;
  __proto.renderPanels = function (flicking) {
    var virtualManager = flicking.virtual;
    var visiblePanels = flicking.visiblePanels;
    var invisibleIndexes = range(flicking.panelsPerView + 1);
    visiblePanels.forEach(function (panel) {
      var elementIndex = panel.elementIndex;
      panel.render();
      virtualManager.show(elementIndex);
      invisibleIndexes[elementIndex] = -1;
    });
    invisibleIndexes.filter(function (val) {
      return val >= 0;
    }).forEach(function (idx) {
      virtualManager.hide(idx);
    });
  };
  __proto.getRenderingIndexesByOrder = function (flicking) {
    var virtualManager = flicking.virtual;
    var visiblePanels = __spread$1(flicking.visiblePanels).filter(function (panel) {
      return panel.rendered;
    }).sort(function (panel1, panel2) {
      return panel1.position + panel1.offset - (panel2.position + panel2.offset);
    });
    if (visiblePanels.length <= 0) return virtualManager.elements.map(function (_, idx) {
      return idx;
    });
    var visibleIndexes = visiblePanels.map(function (panel) {
      return panel.elementIndex;
    });
    var invisibleIndexes = virtualManager.elements.map(function (el, idx) {
      return __assign$2(__assign$2({}, el), {
        idx: idx
      });
    }).filter(function (el) {
      return !el.visible;
    }).map(function (el) {
      return el.idx;
    });
    return __spread$1(visibleIndexes, invisibleIndexes);
  };
  __proto.getRenderingElementsByOrder = function (flicking) {
    var virtualManager = flicking.virtual;
    var elements = virtualManager.elements;
    return this.getRenderingIndexesByOrder(flicking).map(function (index) {
      return elements[index].nativeElement;
    });
  };
  __proto.updateRenderingPanels = function (flicking) {
    var panels = flicking.renderer.panels;
    var camera = flicking.camera;
    var visibleIndexes = camera.visiblePanels.reduce(function (visibles, panel) {
      visibles[panel.index] = true;
      return visibles;
    }, {});
    panels.forEach(function (panel) {
      if (panel.index in visibleIndexes || panel.loading) {
        panel.markForShow();
      } else {
        panel.markForHide();
      }
    });
    camera.updateOffset();
  };
  __proto.collectPanels = function (flicking) {
    var align = parsePanelAlign(flicking.renderer.align);
    return range(flicking.virtual.initialPanelCount).map(function (index) {
      return new VirtualPanel({
        index: index,
        elementProvider: new VirtualElementProvider(flicking),
        align: align,
        flicking: flicking
      });
    });
  };
  __proto.createPanel = function (_el, options) {
    return new VirtualPanel(__assign$2(__assign$2({}, options), {
      elementProvider: new VirtualElementProvider(options.flicking)
    }));
  };
  __proto.updatePanelSizes = function (flicking, size) {
    flicking.virtual.elements.forEach(function (el) {
      setSize(el.nativeElement, size);
    });
    flicking.panels.forEach(function (panel) {
      return panel.setSize(size);
    });
  };
  return VirtualRenderingStrategy;
}();

/**
 * @extends Component
 * @support {"ie": "9+(with polyfill)", "ch" : "latest", "ff" : "latest",  "sf" : "latest", "edge" : "latest", "ios" : "7+", "an" : "4.X+"}
 * @requires {@link https://github.com/naver/egjs-component|@egjs/component}
 * @requires {@link https://github.com/naver/egjs-axes|@egjs/axes}
 */
var Flicking = /*#__PURE__*/function (_super) {
  __extends$3(Flicking, _super);
  /**
   * @param root A root HTMLElement to initialize Flicking on it. When it's a typeof `string`, it should be a css selector string
   * <ko>Flicking을 초기화할 HTMLElement로, `string` 타입으로 지정시 css 선택자 문자열을 지정해야 합니다.</ko>
   * @param {object} [options={}] An options object for Flicking.<ko>Flicking에 적용할 옵션 오브젝트</ko>
   * @throws {FlickingError}
   * |code|condition|
   * |---|---|
   * |{@link ERROR_CODE WRONG_TYPE}|When the root is not either string or HTMLElement|
   * |{@link ERROR_CODE ELEMENT_NOT_FOUND}|When the element with given CSS selector does not exist|
   * <ko>
   *
   * |code|조건|
   * |---|---|
   * |{@link ERROR_CODE WRONG_TYPE}|루트 엘리먼트가 string이나 HTMLElement가 아닐 경우|
   * |{@link ERROR_CODE ELEMENT_NOT_FOUND}|주어진 CSS selector로 엘리먼트를 찾지 못했을 경우|
   *
   * </ko>
   * @example
   * ```ts
   * import Flicking from "@egjs/flicking";
   *
   * // Creating new instance of Flicking with HTMLElement
   * const flicking = new Flicking(document.querySelector(".flicking-viewport"), { circular: true });
   *
   * // Creating new instance of Flicking with CSS selector
   * const flicking2 = new Flicking(".flicking-viewport", { circular: true });
   * ```
   */
  function Flicking(root, _a) {
    var _b = _a === void 0 ? {} : _a,
      _c = _b.align,
      align = _c === void 0 ? ALIGN.CENTER : _c,
      _d = _b.defaultIndex,
      defaultIndex = _d === void 0 ? 0 : _d,
      _e = _b.horizontal,
      horizontal = _e === void 0 ? true : _e,
      _f = _b.circular,
      circular = _f === void 0 ? false : _f,
      _g = _b.circularFallback,
      circularFallback = _g === void 0 ? CIRCULAR_FALLBACK.LINEAR : _g,
      _h = _b.bound,
      bound = _h === void 0 ? false : _h,
      _j = _b.adaptive,
      adaptive = _j === void 0 ? false : _j,
      _k = _b.panelsPerView,
      panelsPerView = _k === void 0 ? -1 : _k,
      _l = _b.noPanelStyleOverride,
      noPanelStyleOverride = _l === void 0 ? false : _l,
      _m = _b.resizeOnContentsReady,
      resizeOnContentsReady = _m === void 0 ? false : _m,
      _o = _b.nested,
      nested = _o === void 0 ? false : _o,
      _p = _b.needPanelThreshold,
      needPanelThreshold = _p === void 0 ? 0 : _p,
      _q = _b.preventEventsBeforeInit,
      preventEventsBeforeInit = _q === void 0 ? true : _q,
      _r = _b.deceleration,
      deceleration = _r === void 0 ? 0.0075 : _r,
      _s = _b.duration,
      duration = _s === void 0 ? 500 : _s,
      _t = _b.easing,
      easing = _t === void 0 ? function (x) {
        return 1 - Math.pow(1 - x, 3);
      } : _t,
      _u = _b.inputType,
      inputType = _u === void 0 ? ["mouse", "touch"] : _u,
      _v = _b.moveType,
      moveType = _v === void 0 ? "snap" : _v,
      _w = _b.threshold,
      threshold = _w === void 0 ? 40 : _w,
      _x = _b.interruptable,
      interruptable = _x === void 0 ? true : _x,
      _y = _b.bounce,
      bounce = _y === void 0 ? "20%" : _y,
      _z = _b.iOSEdgeSwipeThreshold,
      iOSEdgeSwipeThreshold = _z === void 0 ? 30 : _z,
      _0 = _b.preventClickOnDrag,
      preventClickOnDrag = _0 === void 0 ? true : _0,
      _1 = _b.preventDefaultOnDrag,
      preventDefaultOnDrag = _1 === void 0 ? false : _1,
      _2 = _b.disableOnInit,
      disableOnInit = _2 === void 0 ? false : _2,
      _3 = _b.changeOnHold,
      changeOnHold = _3 === void 0 ? false : _3,
      _4 = _b.renderOnlyVisible,
      renderOnlyVisible = _4 === void 0 ? false : _4,
      _5 = _b.virtual,
      virtual = _5 === void 0 ? null : _5,
      _6 = _b.autoInit,
      autoInit = _6 === void 0 ? true : _6,
      _7 = _b.autoResize,
      autoResize = _7 === void 0 ? true : _7,
      _8 = _b.useResizeObserver,
      useResizeObserver = _8 === void 0 ? true : _8,
      _9 = _b.resizeDebounce,
      resizeDebounce = _9 === void 0 ? 0 : _9,
      _10 = _b.maxResizeDebounce,
      maxResizeDebounce = _10 === void 0 ? 100 : _10,
      _11 = _b.useFractionalSize,
      useFractionalSize = _11 === void 0 ? false : _11,
      _12 = _b.externalRenderer,
      externalRenderer = _12 === void 0 ? null : _12,
      _13 = _b.renderExternal,
      renderExternal = _13 === void 0 ? null : _13;
    var _this = _super.call(this) || this;
    // Internal states
    _this._initialized = false;
    _this._plugins = [];
    // Bind options
    _this._align = align;
    _this._defaultIndex = defaultIndex;
    _this._horizontal = horizontal;
    _this._circular = circular;
    _this._circularFallback = circularFallback;
    _this._bound = bound;
    _this._adaptive = adaptive;
    _this._panelsPerView = panelsPerView;
    _this._noPanelStyleOverride = noPanelStyleOverride;
    _this._resizeOnContentsReady = resizeOnContentsReady;
    _this._nested = nested;
    _this._virtual = virtual;
    _this._needPanelThreshold = needPanelThreshold;
    _this._preventEventsBeforeInit = preventEventsBeforeInit;
    _this._deceleration = deceleration;
    _this._duration = duration;
    _this._easing = easing;
    _this._inputType = inputType;
    _this._moveType = moveType;
    _this._threshold = threshold;
    _this._interruptable = interruptable;
    _this._bounce = bounce;
    _this._iOSEdgeSwipeThreshold = iOSEdgeSwipeThreshold;
    _this._preventClickOnDrag = preventClickOnDrag;
    _this._preventDefaultOnDrag = preventDefaultOnDrag;
    _this._disableOnInit = disableOnInit;
    _this._changeOnHold = changeOnHold;
    _this._renderOnlyVisible = renderOnlyVisible;
    _this._autoInit = autoInit;
    _this._autoResize = autoResize;
    _this._useResizeObserver = useResizeObserver;
    _this._resizeDebounce = resizeDebounce;
    _this._maxResizeDebounce = maxResizeDebounce;
    _this._useFractionalSize = useFractionalSize;
    _this._externalRenderer = externalRenderer;
    _this._renderExternal = renderExternal;
    // Create core components
    _this._viewport = new Viewport(_this, getElement(root));
    _this._autoResizer = new AutoResizer(_this);
    _this._renderer = _this._createRenderer();
    _this._camera = _this._createCamera();
    _this._control = _this._createControl();
    _this._virtualManager = new VirtualManager(_this, virtual);
    if (_this._autoInit) {
      void _this.init();
    }
    return _this;
  }
  var __proto = Flicking.prototype;
  Object.defineProperty(__proto, "control", {
    // Components
    /**
     * {@link Control} instance of the Flicking
     * @ko 현재 Flicking에 활성화된 {@link Control} 인스턴스
     * @type {Control}
     * @default SnapControl
     * @readonly
     * @see Control
     * @see SnapControl
     * @see FreeControl
     */
    get: function () {
      return this._control;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "camera", {
    /**
     * {@link Camera} instance of the Flicking
     * @ko 현재 Flicking에 활성화된 {@link Camera} 인스턴스
     * @type {Camera}
     * @default LinearCamera
     * @readonly
     * @see Camera
     * @see LinearCamera
     * @see BoundCamera
     * @see CircularCamera
     */
    get: function () {
      return this._camera;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "renderer", {
    /**
     * {@link Renderer} instance of the Flicking
     * @ko 현재 Flicking에 활성화된 {@link Renderer} 인스턴스
     * @type {Renderer}
     * @default VanillaRenderer
     * @readonly
     * @see Renderer
     * @see VanillaRenderer
     * @see ExternalRenderer
     */
    get: function () {
      return this._renderer;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "viewport", {
    /**
     * A component that manages viewport size
     * @ko 뷰포트 크기 정보를 담당하는 컴포넌트
     * @type {Viewport}
     * @readonly
     * @see Viewport
     */
    get: function () {
      return this._viewport;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "initialized", {
    // Internal States
    /**
     * Whether Flicking's {@link Flicking#init init()} is called.
     * This is `true` when {@link Flicking#init init()} is called, and is `false` after calling {@link Flicking#destroy destroy()}.
     * @ko Flicking의 {@link Flicking#init init()}이 호출되었는지를 나타내는 멤버 변수.
     * 이 값은 {@link Flicking#init init()}이 호출되었으면 `true`로 변하고, {@link Flicking#destroy destroy()}호출 이후에 다시 `false`로 변경됩니다.
     * @type {boolean}
     * @default false
     * @readonly
     */
    get: function () {
      return this._initialized;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "circularEnabled", {
    /**
     * Whether the `circular` option is enabled.
     * The {@link Flicking#circular circular} option can't be enabled when sum of the panel sizes are too small.
     * @ko {@link Flicking#circular circular} 옵션이 활성화되었는지 여부를 나타내는 멤버 변수.
     * {@link Flicking#circular circular} 옵션은 패널의 크기의 합이 충분하지 않을 경우 비활성화됩니다.
     * @type {boolean}
     * @default false
     * @readonly
     */
    get: function () {
      return this._camera.circularEnabled;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "virtualEnabled", {
    /**
     * Whether the `virtual` option is enabled.
     * The {@link Flicking#virtual virtual} option can't be enabled when  {@link Flicking#panelsPerView panelsPerView} is less or equal than zero.
     * @ko {@link Flicking#virtual virtual} 옵션이 활성화되었는지 여부를 나타내는 멤버 변수.
     * {@link Flicking#virtual virtual} 옵션은 {@link Flicking#panelsPerView panelsPerView} 옵션의 값이 0보다 같거나 작으면 비활성화됩니다.
     * @type {boolean}
     * @default false
     * @readonly
     */
    get: function () {
      return this._panelsPerView > 0 && this._virtual != null;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "index", {
    /**
     * Index number of the {@link Flicking#currentPanel currentPanel}
     * @ko {@link Flicking#currentPanel currentPanel}의 인덱스 번호
     * @type {number}
     * @default 0
     * @readonly
     */
    get: function () {
      return this._control.activeIndex;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "element", {
    /**
     * The root(`.flicking-viewport`) element
     * @ko root(`.flicking-viewport`) 엘리먼트
     * @type {HTMLElement}
     * @readonly
     */
    get: function () {
      return this._viewport.element;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "currentPanel", {
    /**
     * Currently active panel
     * @ko 현재 선택된 패널
     * @type {Panel}
     * @readonly
     * @see Panel
     */
    get: function () {
      return this._control.activePanel;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "panels", {
    /**
     * Array of panels
     * @ko 전체 패널들의 배열
     * @type {Panel[]}
     * @readonly
     * @see Panel
     */
    get: function () {
      return this._renderer.panels;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "panelCount", {
    /**
     * Count of panels
     * @ko 전체 패널의 개수
     * @type {number}
     * @readonly
     */
    get: function () {
      return this._renderer.panelCount;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "visiblePanels", {
    /**
     * Array of panels that is visible at the current position
     * @ko 현재 보이는 패널의 배열
     * @type {Panel[]}
     * @readonly
     * @see Panel
     */
    get: function () {
      return this._camera.visiblePanels;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "animating", {
    /**
     * Whether Flicking's animating
     * @ko 현재 애니메이션 동작 여부
     * @type {boolean}
     * @readonly
     */
    get: function () {
      return this._control.animating;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "holding", {
    /**
     * Whether user is clicking or touching
     * @ko 현재 사용자가 클릭/터치중인지 여부
     * @type {boolean}
     * @readonly
     */
    get: function () {
      return this._control.holding;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "activePlugins", {
    /**
     * A current list of activated plugins
     * @ko 현재 활성화된 플러그인 목록
     * @type {Plugin[]}
     * @readonly
     */
    get: function () {
      return this._plugins;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "align", {
    // Options Getter
    // UI / LAYOUT
    /**
     * Align position of the panels within viewport. You can set different values each for the panel and camera
     * @ko 뷰포트 내에서 패널 정렬방식을 설정하는 옵션. 카메라와 패널 개별로 옵션을 설정할 수도 있습니다
     * @type {ALIGN | string | number | { panel: string | number, camera: string | number }}
     * @property {ALIGN | string | number} panel The align value for each {@link Panel}s<ko>개개의 {@link Panel}에 적용할 값</ko>
     * @property {ALIGN | string | number} camera The align value for {@link Camera}<ko>{@link Camera}에 적용할 값</ko>
     * @default "center"
     * @see {@link https://naver.github.io/egjs-flicking/Options#align align ( Options )}
     * @example
     * ```ts
     * const possibleOptions = [
     *   // Literal strings
     *   "prev", "center", "next",
     *   // % values, applied to both panel & camera
     *   "0%", "25%", "42%",
     *   // px values, arithmetic calculation with (+/-) is also allowed.
     *   "0px", "100px", "50% - 25px",
     *   // numbers, same to number + px ("0px", "100px")
     *   0, 100, 1000,
     *   // Setting a different value for panel & camera
     *   { panel: "10%", camera: "25%" }
     * ];
     *
     * possibleOptions.forEach(align => {
     *   new Flicking("#el", { align });
     * });
     * ```
     */
    get: function () {
      return this._align;
    },
    // Options Setter
    // UI / LAYOUT
    set: function (val) {
      this._align = val;
      this._renderer.align = val;
      this._camera.align = val;
      void this.resize();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "defaultIndex", {
    /**
     * Index of the panel to move when Flicking's {@link Flicking#init init()} is called. A zero-based integer
     * @ko Flicking의 {@link Flicking#init init()}이 호출될 때 이동할 디폴트 패널의 인덱스로, 0부터 시작하는 정수입니다
     * @type {number}
     * @default 0
     * @see {@link https://naver.github.io/egjs-flicking/Options#defaultindex defaultIndex ( Options )}
     */
    get: function () {
      return this._defaultIndex;
    },
    set: function (val) {
      this._defaultIndex = val;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "horizontal", {
    /**
     * Direction of panel movement (true: horizontal, false: vertical)
     * @ko 패널 이동 방향 (true: 가로방향, false: 세로방향)
     * @type {boolean}
     * @default true
     * @see {@link https://naver.github.io/egjs-flicking/Options#horizontal horizontal ( Options )}
     */
    get: function () {
      return this._horizontal;
    },
    set: function (val) {
      this._horizontal = val;
      this._control.controller.updateDirection();
      void this.resize();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "circular", {
    /**
     * Enables circular(continuous loop) mode, which connects first/last panel for continuous scrolling.
     * @ko 순환 모드를 활성화합니다. 순환 모드에서는 양 끝의 패널이 서로 연결되어 끊김없는 스크롤이 가능합니다.
     * @type {boolean}
     * @default false
     * @see {@link https://naver.github.io/egjs-flicking/Options#circular circular ( Options )}
     */
    get: function () {
      return this._circular;
    },
    set: function (val) {
      this._circular = val;
      void this.resize();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "circularFallback", {
    /**
     * Set panel control mode for the case when circular cannot be enabled.
     * "linear" will set the view's range from the top of the first panel to the top of the last panel.
     * "bound" will prevent the view from going out of the first/last panel, so it won't show empty spaces before/after the first/last panel.
     * @ko 순환 모드 사용 불가능시 사용할 패널 조작 범위 설정 방식을 변경합니다.
     * "linear" 사용시 시점이 첫번째 엘리먼트 위에서부터 마지막 엘리먼트 위까지 움직일 수 있도록 설정합니다.
     * "bound" 사용시 시점이 첫번째 엘리먼트와 마지막 엘리먼트의 끝과 끝 사이에서 움직일 수 있도록 설정합니다.
     * @see CIRCULAR_FALLBACK
     * @type {string}
     * @default "linear"
     * @see {@link https://naver.github.io/egjs-flicking/Options#circularfallback circularFallback ( Options )}
     */
    get: function () {
      return this._circularFallback;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "bound", {
    /**
     * Prevent the view(camera element) from going out of the first/last panel, so it won't show empty spaces before/after the first/last panel
     * Only can be enabled when `circular=false`
     * @ko 뷰(카메라 엘리먼트)가 첫번째와 마지막 패널 밖으로 넘어가지 못하게 하여, 첫번째/마지막 패널 전/후의 빈 공간을 보이지 않도록 하는 옵션입니다
     * `circular=false`인 경우에만 사용할 수 있습니다
     * @type {boolean}
     * @default false
     * @see {@link https://naver.github.io/egjs-flicking/Options#bound bound ( Options )}
     */
    get: function () {
      return this._bound;
    },
    set: function (val) {
      this._bound = val;
      void this.resize();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "adaptive", {
    /**
     * Update height of the viewport element after movement same to the height of the panel below. This can be only enabled when `horizontal=true`
     * @ko 이동한 후 뷰포트 엘리먼트의 크기를 현재 패널의 높이와 동일하게 설정합니다. `horizontal=true`인 경우에만 사용할 수 있습니다.
     * @type {boolean}
     * @default false
     * @see {@link https://naver.github.io/egjs-flicking/Options#adaptive adaptive ( Options )}
     */
    get: function () {
      return this._adaptive;
    },
    set: function (val) {
      this._adaptive = val;
      void this.resize();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "panelsPerView", {
    /**
     * A visible number of panels on viewport. Enabling this option will automatically resize panel size
     * @ko 한 화면에 보이는 패널의 개수. 이 옵션을 활성화할 경우 패널의 크기를 강제로 재조정합니다
     * @type {number}
     * @default -1
     * @see {@link https://naver.github.io/egjs-flicking/Options#panelsperview panelsPerView ( Options )}
     */
    get: function () {
      return this._panelsPerView;
    },
    set: function (val) {
      this._panelsPerView = val;
      void this.resize();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "noPanelStyleOverride", {
    /**
     * Enabling this option will not change `width/height` style of the panels if {@link Flicking#panelsPerView} is enabled.
     * This behavior can be useful in terms of performance when you're manually managing all panel sizes
     * @ko 이 옵션을 활성화할 경우, {@link Flicking#panelsPerView} 옵션이 활성화되었을 때 패널의 `width/height` 스타일을 변경하지 않도록 설정합니다.
     * 모든 패널들의 크기를 직접 관리하고 있을 경우, 이 옵션을 활성화하면 성능면에서 유리할 수 있습니다
     * @type {boolean}
     * @default false
     */
    get: function () {
      return this._noPanelStyleOverride;
    },
    set: function (val) {
      this._noPanelStyleOverride = val;
      void this.resize();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "resizeOnContentsReady", {
    /**
     * Enabling this option will automatically call {@link Flicking#resize} when all image/video inside panels are loaded.
     * This can be useful when you have contents inside Flicking that changes its size when it's loaded
     * @ko 이 옵션을 활성화할 경우, Flicking 패널 내부의 이미지/비디오들이 로드되었을 때 자동으로 {@link Flicking#resize}를 호출합니다.
     * 이 동작은 Flicking 내부에 로드 전/후로 크기가 변하는 콘텐츠를 포함하고 있을 때 유용하게 사용하실 수 있습니다.
     * @type {boolean}
     * @default false
     * @see {@link https://naver.github.io/egjs-flicking/Options#resizeOnContentsReady resizeOnContentsReady ( Options )}
     */
    get: function () {
      return this._resizeOnContentsReady;
    },
    set: function (val) {
      this._resizeOnContentsReady = val;
      if (val) {
        this._renderer.checkPanelContentsReady(this._renderer.panels);
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "nested", {
    /**
     * If you enable this option on child Flicking when the Flicking is placed inside the Flicking, the parent Flicking will move in the same direction after the child Flicking reaches the first/last panel.
     * If the parent Flicking and child Flicking have different horizontal option, you do not need to set this option.
     * @ko Flicking 내부에 Flicking이 배치될 때 하위 Flicking에서 이 옵션을 활성화하면 하위 Flicking이 첫/마지막 패널에 도달한 뒤부터 같은 방향으로 상위 Flicking이 움직입니다.
     * 만약 상위 Flicking과 하위 Flicking이 서로 다른 horizontal 옵션을 가지고 있다면 이 옵션을 설정할 필요가 없습니다.
     * @type {boolean}
     * @default false
     * @see {@link https://naver.github.io/egjs-flicking/Options#nested nested ( Options )}
     */
    get: function () {
      return this._nested;
    },
    set: function (val) {
      this._nested = val;
      var axes = this._control.controller.axes;
      if (axes) {
        axes.options.nested = val;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "needPanelThreshold", {
    // EVENTS
    /**
     * A Threshold from viewport edge before triggering `needPanel` event
     * @ko `needPanel`이벤트가 발생하기 위한 뷰포트 끝으로부터의 최대 거리
     * @type {number}
     * @default 0
     * @see {@link https://naver.github.io/egjs-flicking/Options#needpanelthreshold needPanelThreshold ( Options )}
     */
    get: function () {
      return this._needPanelThreshold;
    },
    // EVENTS
    set: function (val) {
      this._needPanelThreshold = val;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "preventEventsBeforeInit", {
    /**
     * When enabled, events are not triggered before `ready` when initializing
     * @ko 활성화할 경우 초기화시 `ready` 이벤트 이전의 이벤트가 발생하지 않습니다.
     * @type {boolean}
     * @default true
     * @see {@link https://naver.github.io/egjs-flicking/Options#preventeventsbeforeinit preventEventsBeforeInit ( Options )}
     */
    get: function () {
      return this._preventEventsBeforeInit;
    },
    set: function (val) {
      this._preventEventsBeforeInit = val;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "deceleration", {
    // ANIMATION
    /**
     * Deceleration value for panel movement animation which is triggered by user input. A higher value means a shorter animation time
     * @ko 사용자의 동작으로 가속도가 적용된 패널 이동 애니메이션의 감속도. 값이 높을수록 애니메이션 실행 시간이 짧아집니다
     * @type {number}
     * @default 0.0075
     * @see {@link https://naver.github.io/egjs-flicking/Options#deceleration deceleration ( Options )}
     */
    get: function () {
      return this._deceleration;
    },
    // ANIMATION
    set: function (val) {
      this._deceleration = val;
      var axes = this._control.controller.axes;
      if (axes) {
        axes.options.deceleration = val;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "easing", {
    /**
     * An easing function applied to the panel movement animation. Default value is `easeOutCubic`
     * @ko 패널 이동 애니메이션에 적용할 easing 함수. 기본값은 `easeOutCubic`이다
     * @type {function}
     * @default x => 1 - Math.pow(1 - x, 3)
     * @see Easing Functions Cheat Sheet {@link http://easings.net/} <ko>이징 함수 Cheat Sheet {@link http://easings.net/}</ko>
     * @see {@link https://naver.github.io/egjs-flicking/Options#easing Easing ( Options )}
     */
    get: function () {
      return this._easing;
    },
    set: function (val) {
      this._easing = val;
      var axes = this._control.controller.axes;
      if (axes) {
        axes.options.easing = val;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "duration", {
    /**
     * Default duration of the animation (ms)
     * @ko 디폴트 애니메이션 재생 시간 (ms)
     * @type {number}
     * @default 500
     * @see {@link https://naver.github.io/egjs-flicking/Options#duration duration ( Options )}
     */
    get: function () {
      return this._duration;
    },
    set: function (val) {
      this._duration = val;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "inputType", {
    // INPUT
    /**
     * Types of input devices to enable
     * @ko 활성화할 입력 장치 종류
     * @type {string[]}
     * @default ["touch", "mouse"]
     * @see {@link https://naver.github.io/egjs-axes/Options#paninput-options Possible values (PanInputOption#inputType)}
     * <ko>{@link https://naver.github.io/egjs-axes/Options#paninput-options 가능한 값들 (PanInputOption#inputType)}</ko>
     * @see {@link https://naver.github.io/egjs-flicking/Options#inputtype inputType ( Options )}
     */
    get: function () {
      return this._inputType;
    },
    // INPUT
    set: function (val) {
      this._inputType = val;
      var panInput = this._control.controller.panInput;
      if (panInput) {
        panInput.options.inputType = val;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "moveType", {
    /**
     * Movement style by user input. This will change instance type of {@link Flicking#control}
     * You can use the values of the constant {@link MOVE_TYPE}
     * @ko 사용자 입력에 의한 이동 방식. 이 값에 따라 {@link Flicking#control}의 인스턴스 타입이 결정됩니다
     * 상수 {@link MOVE_TYPE}에 정의된 값들을 이용할 수 있습니다
     * @type {MOVE_TYPE | Pair<string, object>}
     * @default "snap"
     * @see {@link https://naver.github.io/egjs-flicking/Options#movetype moveType ( Options )}
     * @example
     * |moveType|control|options|
     * |:---:|:---:|:---:|
     * |"snap"|{@link SnapControl}||
     * |"freeScroll"|{@link FreeControl}|{@link FreeControlOptions}|
     *
     * ```ts
     * import Flicking, { MOVE_TYPE } from "@egjs/flicking";
     *
     * const flicking = new Flicking({
     *   moveType: MOVE_TYPE.SNAP
     * });
     * ```
     *
     * ```ts
     * const flicking = new Flicking({
     *   // If you want more specific settings for the moveType
     *   // [moveType, options for that moveType]
     *   // In this case, it's ["freeScroll", FreeControlOptions]
     *   moveType: [MOVE_TYPE.FREE_SCROLL, { stopAtEdge: true }]
     * });
     * ```
     */
    get: function () {
      return this._moveType;
    },
    set: function (val) {
      this._moveType = val;
      var prevControl = this._control;
      var newControl = this._createControl();
      var activePanel = prevControl.activePanel;
      newControl.copy(prevControl);
      var prevProgressInPanel = activePanel ? this._camera.getProgressInPanel(activePanel) : 0;
      this._control = newControl;
      this._control.updatePosition(prevProgressInPanel);
      this._control.updateInput();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "threshold", {
    /**
     * Movement threshold to change panel (unit: px). It should be dragged above the threshold to change the current panel.
     * @ko 패널 변경을 위한 이동 임계값 (단위: px). 주어진 값 이상으로 스크롤해야만 패널 변경이 가능하다.
     * @type {number}
     * @default 40
     * @see {@link https://naver.github.io/egjs-flicking/Options#threshold Threshold ( Options )}
     */
    get: function () {
      return this._threshold;
    },
    set: function (val) {
      this._threshold = val;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "interruptable", {
    /**
     * Set animation to be interruptable by click/touch.
     * @ko 사용자의 클릭/터치로 인해 애니메이션을 도중에 멈출 수 있도록 설정합니다.
     * @type {boolean}
     * @default true
     * @see {@link https://naver.github.io/egjs-flicking/Options#interruptable Interruptable ( Options )}
     */
    get: function () {
      return this._interruptable;
    },
    set: function (val) {
      this._interruptable = val;
      var axes = this._control.controller.axes;
      if (axes) {
        axes.options.interruptable = val;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "bounce", {
    /**
     * The size value of the bounce area. Only can be enabled when `circular=false`.
     * You can set different bounce value for prev/next direction by using array.
     * `number` for px value, and `string` for px, and % value relative to viewport size.
     * You have to call {@link Control#updateInput} after changing this to take effect.
     * @ko Flicking이 최대 영역을 넘어서 갈 수 있는 최대 크기. `circular=false`인 경우에만 사용할 수 있습니다.
     * 배열을 통해 prev/next 방향에 대해 서로 다른 바운스 값을 지정할 수 있습니다.
     * `number`를 통해 px값을, `stirng`을 통해 px 혹은 뷰포트 크기 대비 %값을 사용할 수 있습니다.
     * 이 값을 변경시 {@link Control#updateInput}를 호출해야 합니다.
     * @type {string | number | Array<string | number>}
     * @default "20%"
     * @see {@link https://naver.github.io/egjs-flicking/Options#bounce bounce ( Options )}
     * @example
     * ```ts
     * const possibleOptions = [
     *   // % values, relative to viewport element(".flicking-viewport")'s size
     *   "0%", "25%", "42%",
     *   // px values, arithmetic calculation with (+/-) is also allowed.
     *   "0px", "100px", "50% - 25px",
     *   // numbers, same to number + px ("0px", "100px")
     *   0, 100, 1000
     * ];
     * ```
     *
     * @example
     * ```ts
     * const flicking = new Flicking("#el", { bounce: "20%" });
     *
     * flicking.bounce = "100%";
     * flicking.control.updateInput(); // Call this to update!
     * ```
     */
    get: function () {
      return this._bounce;
    },
    set: function (val) {
      this._bounce = val;
      this._control.updateInput();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "iOSEdgeSwipeThreshold", {
    /**
     * Size of the area from the right edge in iOS safari (in px) which enables swipe-back or swipe-forward
     * @ko iOS Safari에서 swipe를 통한 뒤로가기/앞으로가기를 활성화하는 오른쪽 끝으로부터의 영역의 크기 (px)
     * @type {number}
     * @default 30
     * @see {@link https://naver.github.io/egjs-flicking/Options#iosedgeswipethreshold iOSEdgeSwipeThreshold ( Options )}
     */
    get: function () {
      return this._iOSEdgeSwipeThreshold;
    },
    set: function (val) {
      this._iOSEdgeSwipeThreshold = val;
      var panInput = this._control.controller.panInput;
      if (panInput) {
        panInput.options.iOSEdgeSwipeThreshold = val;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "preventClickOnDrag", {
    /**
     * Automatically prevent `click` event if the user has dragged at least a single pixel on the viewport element
     * @ko 사용자가 뷰포트 영역을 1픽셀이라도 드래그했을 경우 자동으로 {@link https://developer.mozilla.org/ko/docs/Web/API/Element/click_event click} 이벤트를 취소합니다
     * @type {boolean}
     * @default true
     * @see {@link https://naver.github.io/egjs-flicking/Options#preventclickondrag preventClickOnDrag ( Options )}
     */
    get: function () {
      return this._preventClickOnDrag;
    },
    set: function (val) {
      var prevVal = this._preventClickOnDrag;
      if (val === prevVal) return;
      var controller = this._control.controller;
      if (val) {
        controller.addPreventClickHandler();
      } else {
        controller.removePreventClickHandler();
      }
      this._preventClickOnDrag = val;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "preventDefaultOnDrag", {
    /**
     * Whether to use the {@link https://developer.mozilla.org/ko/docs/Web/API/Event/preventDefault preventDefault} when the user starts dragging
     * @ko 사용자가 드래그를 시작할 때 {@link https://developer.mozilla.org/ko/docs/Web/API/Event/preventDefault preventDefault} 실행 여부
     * @type {boolean}
     * @default false
     * @see {@link https://naver.github.io/egjs-flicking/Options#preventDefaultOnDrag preventDefaultOnDrag ( Options )}
     */
    get: function () {
      return this._preventDefaultOnDrag;
    },
    set: function (val) {
      this._preventDefaultOnDrag = val;
      var panInput = this._control.controller.panInput;
      if (panInput) {
        panInput.options.preventDefaultOnDrag = val;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "disableOnInit", {
    /**
     * Automatically call {@link Flicking#disableInput disableInput()} on initialization
     * @ko Flicking init시에 {@link Flicking#disableInput disableInput()}을 바로 호출합니다
     * @type {boolean}
     * @default false
     * @see {@link https://naver.github.io/egjs-flicking/Options#disableoninit disableOnInit ( Options )}
     */
    get: function () {
      return this._disableOnInit;
    },
    set: function (val) {
      this._disableOnInit = val;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "changeOnHold", {
    /**
     * Change active panel index on mouse/touch hold while animating.
     * `index` of the `willChange`/`willRestore` event will be used as new index.
     * @ko 애니메이션 도중 마우스/터치 입력시 현재 활성화된 패널의 인덱스를 변경합니다.
     * `willChange`/`willRestore` 이벤트의 `index`값이 새로운 인덱스로 사용될 것입니다.
     * @type {boolean}
     * @default false
     * @see {@link https://naver.github.io/egjs-flicking/Options#changeonhold changeOnHold ( Options )}
     */
    get: function () {
      return this._changeOnHold;
    },
    set: function (val) {
      this._changeOnHold = val;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "renderOnlyVisible", {
    // PERFORMANCE
    /**
     * Whether to render visible panels only. This can dramatically increase performance when there're many panels
     * @ko 보이는 패널만 렌더링할지 여부를 설정합니다. 패널이 많을 경우에 퍼포먼스를 크게 향상시킬 수 있습니다
     * @type {boolean}
     * @default false
     * @see {@link https://naver.github.io/egjs-flicking/Options#renderonlyvisible renderOnlyVisible ( Options )}
     */
    get: function () {
      return this._renderOnlyVisible;
    },
    // PERFORMANCE
    set: function (val) {
      this._renderOnlyVisible = val;
      void this._renderer.render();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "virtual", {
    /**
     * By enabling this option, it will reduce memory consumption by restricting the number of DOM elements to `panelsPerView + 1`
     * Must be used with `panelsPerview`.
     * After Flicking's initialized, this property can be used to add/remove the panel count.
     * @ko 이 옵션을 활성화할 경우 패널 엘리먼트의 개수를 `panelsPerView + 1` 개로 고정함으로써, 메모리 사용량을 줄일 수 있습니다.
     * `panelsPerView` 옵션과 함께 사용되어야만 합니다.
     * Flicking 초기화 이후에, 이 프로퍼티는 렌더링하는 패널의 개수를 추가/제거하기 위해 사용될 수 있습니다.
     * @type {VirtualManager}
     * @property {function} renderPanel A rendering function for the panel element's innerHTML<ko>패널 엘리먼트의 innerHTML을 렌더링하는 함수</ko>
     * @property {number} initialPanelCount Initial panel count to render<ko>최초로 렌더링할 패널의 개수</ko>
     * @property {boolean} [cache=false] Whether to cache rendered panel's innerHTML<ko>렌더링된 패널의 innerHTML 정보를 캐시할지 여부</ko>
     * @property {string} [panelClass="flicking-panel"] The class name that will be applied to rendered panel elements<ko>렌더링되는 패널 엘리먼트에 적용될 클래스 이름</ko>
     * @see {@link https://naver.github.io/egjs-flicking/Options#virtual virtual ( Options )}
     * @example
     * ```ts
     * import Flicking, { VirtualPanel } from "@egjs/flicking";
     *
     * const flicking = new Flicking("#some_el", {
     *   panelsPerView: 3,
     *   virtual: {
     *     renderPanel: (panel: VirtualPanel, index: number) => `Panel ${index}`,
     *     initialPanelCount: 100
     *   }
     * });
     *
     * // Add 100 virtual panels (at the end)
     * flicking.virtual.append(100);
     *
     * // Remove 100 virtual panels from 0 to 100
     * flicking.virtual.remove(0, 100);
     * ```
     */
    get: function () {
      return this._virtualManager;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "autoInit", {
    // OTHERS
    /**
     * Call {@link Flicking#init init()} automatically when creating Flicking's instance
     * @ko Flicking 인스턴스를 생성할 때 자동으로 {@link Flicking#init init()}를 호출합니다
     * @type {boolean}
     * @default true
     * @see {@link https://naver.github.io/egjs-flicking/Options#autoinit autoInit ( Options )}
     * @readonly
     */
    get: function () {
      return this._autoInit;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "autoResize", {
    /**
     * Whether to automatically call {@link Flicking#resize resize()} when the viewport element(.flicking-viewport)'s size is changed
     * @ko 뷰포트 엘리먼트(.flicking-viewport)의 크기 변경시 {@link Flicking#resize resize()} 메소드를 자동으로 호출할지 여부를 설정합니다
     * @type {boolean}
     * @default true
     */
    get: function () {
      return this._autoResize;
    },
    // OTHERS
    set: function (val) {
      this._autoResize = val;
      if (val) {
        this._autoResizer.enable();
      } else {
        this._autoResizer.disable();
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "useResizeObserver", {
    /**
     * Whether to listen {@link https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver ResizeObserver}'s event instead of Window's {@link https://developer.mozilla.org/ko/docs/Web/API/Window/resize_event resize} event when using the `autoResize` option
     * @ko autoResize 옵션 사용시 {@link https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver ResizeObserver}의 이벤트를 Window객체의 {@link https://developer.mozilla.org/ko/docs/Web/API/Window/resize_event resize} 이벤트 대신 수신할지 여부를 설정합니다
     * @type {boolean}
     * @default true
     * @see {@link https://naver.github.io/egjs-flicking/Options#useresizeobserver useResizeObserver ( Options )}
     */
    get: function () {
      return this._useResizeObserver;
    },
    set: function (val) {
      this._useResizeObserver = val;
      if (this._autoResize) {
        this._autoResizer.enable();
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "resizeDebounce", {
    /**
     * Delays size recalculation from `autoResize` by the given time in milisecond.
     * If the size is changed again while being delayed, it cancels the previous one and delays from the beginning again.
     * This can increase performance by preventing `resize` being called too often.
     * @ko `autoResize` 설정시에 호출되는 크기 재계산을 주어진 시간(단위: ms)만큼 지연시킵니다.
     * 지연시키는 도중 크기가 다시 변경되었을 경우, 이전 것을 취소하고 주어진 시간만큼 다시 지연시킵니다.
     * 이를 통해 `resize`가 너무 많이 호출되는 것을 방지하여 성능을 향상시킬 수 있습니다.
     * @type {number}
     * @default 0
     * @see {@link https://naver.github.io/egjs-flicking/Options#resizedebounce resizeDebounce ( Options )}
     */
    get: function () {
      return this._resizeDebounce;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "maxResizeDebounce", {
    /**
     * The maximum time for size recalculation delay when using `resizeDebounce`, in milisecond.
     * This guarantees that size recalculation is performed at least once every (n)ms.
     * @ko `resizeDebounce` 사용시에 크기 재계산이 지연되는 최대 시간을 지정합니다. (단위: ms)
     * 이를 통해, 적어도 (n)ms에 한번은 크기 재계산을 수행하는 것을 보장할 수 있습니다.
     * @type {number}
     * @default 100
     * @see {@link https://naver.github.io/egjs-flicking/Options#maxresizedebounce maxResizeDebounce ( Options )}
     */
    get: function () {
      return this._maxResizeDebounce;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "useFractionalSize", {
    /**
     * By enabling this, Flicking will calculate all internal size with CSS width computed with getComputedStyle.
     * This can prevent 1px offset issue in some cases where panel size has the fractional part.
     * All sizes will have the original size before CSS {@link https://developer.mozilla.org/en-US/docs/Web/CSS/transform transform} is applied on the element.
     * @ko 이 옵션을 활성화할 경우, Flicking은 내부의 모든 크기를 {@link https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect getBoundingClientRect}를 이용하여 계산합니다.
     * 이를 통해, 패널 크기에 소수점을 포함할 경우에 발생할 수 있는 일부 1px 오프셋 이슈를 해결 가능합니다.
     * 모든 크기는 CSS {@link https://developer.mozilla.org/en-US/docs/Web/CSS/transform transform}이 엘리먼트에 적용되기 이전의 크기를 사용할 것입니다.
     * @type {boolean}
     * @default false
     * @see {@link https://naver.github.io/egjs-flicking/Options#usefractionalsize useFractionalSize ( Options )}
     */
    get: function () {
      return this._useFractionalSize;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "externalRenderer", {
    /**
     * This is an option for the frameworks(React, Vue, Angular, ...). Don't set it as it's automatically managed by Flicking.
     * @ko 프레임워크(React, Vue, Angular, ...)에서만 사용하는 옵션으로, 자동으로 설정되므로 따로 사용하실 필요 없습니다!
     * @default null
     * @internal
     * @readonly
     */
    get: function () {
      return this._externalRenderer;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "renderExternal", {
    /**
     * This is an option for the frameworks(React, Vue, Angular, ...). Don't set it as it's automatically managed by Flicking.
     * @ko 프레임워크(React, Vue, Angular, ...)에서만 사용하는 옵션으로, 자동으로 설정되므로 따로 사용하실 필요 없습니다!
     * @default null
     * @internal
     * @readonly
     * @deprecated
     */
    get: function () {
      return this._renderExternal;
    },
    enumerable: false,
    configurable: true
  });
  /**
   * Initialize Flicking and move to the default index
   * This is automatically called on Flicking's constructor when `autoInit` is true(default)
   * @ko Flicking을 초기화하고, 디폴트 인덱스로 이동합니다
   * 이 메소드는 `autoInit` 옵션이 true(default)일 경우 Flicking이 생성될 때 자동으로 호출됩니다
   * @fires Flicking#ready
   * @return {Promise<void>}
   */
  __proto.init = function () {
    var _this = this;
    if (this._initialized) return Promise.resolve();
    var camera = this._camera;
    var renderer = this._renderer;
    var control = this._control;
    var virtualManager = this._virtualManager;
    var originalTrigger = this.trigger;
    var preventEventsBeforeInit = this._preventEventsBeforeInit;
    camera.init();
    virtualManager.init();
    renderer.init(this);
    control.init(this);
    if (preventEventsBeforeInit) {
      this.trigger = function () {
        return _this;
      };
    }
    this._initialResize();
    // Look at initial panel
    this._moveToInitialPanel();
    if (this._autoResize) {
      this._autoResizer.enable();
    }
    if (this._preventClickOnDrag) {
      control.controller.addPreventClickHandler();
    }
    if (this._disableOnInit) {
      this.disableInput();
    }
    renderer.checkPanelContentsReady(renderer.panels);
    this._initialized = true;
    return renderer.render().then(function () {
      // Done initializing & emit ready event
      _this._plugins.forEach(function (plugin) {
        return plugin.init(_this);
      });
      if (preventEventsBeforeInit) {
        _this.trigger = originalTrigger;
      }
      _this.trigger(new ComponentEvent$1(EVENTS.READY));
    });
  };
  /**
   * Destroy Flicking and remove all event handlers
   * @ko Flicking과 하위 컴포넌트들을 초기 상태로 되돌리고, 부착된 모든 이벤트 핸들러를 제거합니다
   * @return {void}
   */
  __proto.destroy = function () {
    this.off();
    this._autoResizer.disable();
    this._control.destroy();
    this._camera.destroy();
    this._renderer.destroy();
    this._plugins.forEach(function (plugin) {
      return plugin.destroy();
    });
    this._initialized = false;
  };
  /**
   * Move to the previous panel (current index - 1)
   * @ko 이전 패널로 이동합니다 (현재 인덱스 - 1)
   * @param {number} [duration={@link Flicking#duration options.duration}] Duration of the panel movement animation (unit: ms)<ko>패널 이동 애니메이션 진행 시간 (단위: ms)</ko>
   * @async
   * @fires Flicking#moveStart
   * @fires Flicking#move
   * @fires Flicking#moveEnd
   * @fires Flicking#willChange
   * @fires Flicking#changed
   * @fires Flicking#willRestore
   * @fires Flicking#restored
   * @fires Flicking#needPanel
   * @fires Flicking#visibleChange
   * @fires Flicking#reachEdge
   * @throws {FlickingError}
   * |code|condition|
   * |---|---|
   * |{@link ERROR_CODE INDEX_OUT_OF_RANGE}|When the previous panel does not exist|
   * |{@link ERROR_CODE ANIMATION_ALREADY_PLAYING}|When the animation is already playing|
   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|When the animation is interrupted by user input|
   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|When the any of the event's `stop()` is called|
   * <ko>
   *
   * |code|condition|
   * |---|---|
   * |{@link ERROR_CODE INDEX_OUT_OF_RANGE}|이전 패널이 존재하지 않을 경우|
   * |{@link ERROR_CODE ANIMATION_ALREADY_PLAYING}|애니메이션이 이미 진행중인 경우|
   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|사용자 입력에 의해 애니메이션이 중단된 경우|
   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|발생된 이벤트들 중 하나라도 `stop()`이 호출된 경우|
   * </ko>
   * @return {Promise<void>} A Promise which will be resolved after reaching the previous panel<ko>이전 패널 도달시에 resolve되는 Promise</ko>
   */
  __proto.prev = function (duration) {
    var _a, _b, _c;
    if (duration === void 0) {
      duration = this._duration;
    }
    return this.moveTo((_c = (_b = (_a = this._control.activePanel) === null || _a === void 0 ? void 0 : _a.prev()) === null || _b === void 0 ? void 0 : _b.index) !== null && _c !== void 0 ? _c : -1, duration, DIRECTION.PREV);
  };
  /**
   * Move to the next panel (current index + 1)
   * @ko 다음 패널로 이동합니다 (현재 인덱스 + 1)
   * @param {number} [duration={@link Flicking#duration options.duration}] Duration of the panel movement animation (unit: ms).<ko>패널 이동 애니메이션 진행 시간 (단위: ms)</ko>
   * @async
   * @fires Flicking#moveStart
   * @fires Flicking#move
   * @fires Flicking#moveEnd
   * @fires Flicking#willChange
   * @fires Flicking#changed
   * @fires Flicking#willRestore
   * @fires Flicking#restored
   * @fires Flicking#needPanel
   * @fires Flicking#visibleChange
   * @fires Flicking#reachEdge
   * @throws {FlickingError}
   * |code|condition|
   * |---|---|
   * |{@link ERROR_CODE INDEX_OUT_OF_RANGE}|When the next panel does not exist|
   * |{@link ERROR_CODE ANIMATION_ALREADY_PLAYING}|When the animation is already playing|
   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|When the animation is interrupted by user input|
   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|When the any of the event's `stop()` is called|
   * <ko>
   *
   * |code|condition|
   * |---|---|
   * |{@link ERROR_CODE INDEX_OUT_OF_RANGE}|다음 패널이 존재하지 않을 경우|
   * |{@link ERROR_CODE ANIMATION_ALREADY_PLAYING}|애니메이션이 이미 진행중인 경우|
   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|사용자 입력에 의해 애니메이션이 중단된 경우|
   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|발생된 이벤트들 중 하나라도 `stop()`이 호출된 경우|
   *
   * </ko>
   * @return {Promise<void>} A Promise which will be resolved after reaching the next panel<ko>다음 패널 도달시에 resolve되는 Promise</ko>
   */
  __proto.next = function (duration) {
    var _a, _b, _c;
    if (duration === void 0) {
      duration = this._duration;
    }
    return this.moveTo((_c = (_b = (_a = this._control.activePanel) === null || _a === void 0 ? void 0 : _a.next()) === null || _b === void 0 ? void 0 : _b.index) !== null && _c !== void 0 ? _c : this._renderer.panelCount, duration, DIRECTION.NEXT);
  };
  /**
   * Move to the panel with given index
   * @ko 주어진 인덱스에 해당하는 패널로 이동합니다
   * @param {number} index The index of the panel to move<ko>이동할 패널의 인덱스</ko>
   * @param {number} [duration={@link Flicking#duration options.duration}] Duration of the animation (unit: ms)<ko>애니메이션 진행 시간 (단위: ms)</ko>
   * @param {DIRECTION} [direction=DIRECTION.NONE] Direction to move, only available in the {@link Flicking#circular circular} mode<ko>이동할 방향. {@link Flicking#circular circular} 옵션 활성화시에만 사용 가능합니다</ko>
   * @async
   * @fires Flicking#moveStart
   * @fires Flicking#move
   * @fires Flicking#moveEnd
   * @fires Flicking#willChange
   * @fires Flicking#changed
   * @fires Flicking#willRestore
   * @fires Flicking#restored
   * @fires Flicking#needPanel
   * @fires Flicking#visibleChange
   * @fires Flicking#reachEdge
   * @throws {FlickingError}
   * |code|condition|
   * |---|---|
   * |{@link ERROR_CODE INDEX_OUT_OF_RANGE}|When the root is not either string or HTMLElement|
   * |{@link ERROR_CODE ANIMATION_ALREADY_PLAYING}|When the animation is already playing|
   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|When the animation is interrupted by user input|
   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|When the any of the event's `stop()` is called|
   * <ko>
   *
   * |code|condition|
   * |---|---|
   * |{@link ERROR_CODE INDEX_OUT_OF_RANGE}|해당 인덱스를 가진 패널이 존재하지 않을 경우|
   * |{@link ERROR_CODE ANIMATION_ALREADY_PLAYING}|애니메이션이 이미 진행중인 경우|
   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|사용자 입력에 의해 애니메이션이 중단된 경우|
   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|발생된 이벤트들 중 하나라도 `stop()`이 호출된 경우|
   *
   * </ko>
   * @return {Promise<void>} A Promise which will be resolved after reaching the target panel<ko>해당 패널 도달시에 resolve되는 Promise</ko>
   */
  __proto.moveTo = function (index, duration, direction) {
    if (duration === void 0) {
      duration = this._duration;
    }
    if (direction === void 0) {
      direction = DIRECTION.NONE;
    }
    var renderer = this._renderer;
    var panelCount = renderer.panelCount;
    var panel = renderer.getPanel(index);
    if (!panel) {
      return Promise.reject(new FlickingError(MESSAGE.INDEX_OUT_OF_RANGE(index, 0, panelCount - 1), CODE.INDEX_OUT_OF_RANGE));
    }
    if (this._control.animating) {
      return Promise.reject(new FlickingError(MESSAGE.ANIMATION_ALREADY_PLAYING, CODE.ANIMATION_ALREADY_PLAYING));
    }
    if (this._control.holding) {
      this._control.controller.release();
    }
    return this._control.moveToPanel(panel, {
      duration: duration,
      direction: direction
    });
  };
  /**
   * Change the destination and duration of the animation currently playing
   * @ko 재생 중인 애니메이션의 목적지와 재생 시간을 변경합니다
   * @param {number} index The index of the panel to move<ko>이동할 패널의 인덱스</ko>
   * @param {number} duration Duration of the animation (unit: ms)<ko>애니메이션 진행 시간 (단위: ms)</ko>
   * @param {DIRECTION} direction Direction to move, only available in the {@link Flicking#circular circular} mode<ko>이동할 방향. {@link Flicking#circular circular} 옵션 활성화시에만 사용 가능합니다</ko>
   * @throws {FlickingError}
   * {@link ERROR_CODE INDEX_OUT_OF_RANGE} When the root is not either string or HTMLElement
   * <ko>{@link ERROR_CODE INDEX_OUT_OF_RANGE} 해당 인덱스를 가진 패널이 존재하지 않을 경우</ko>
   * @return {void}
   */
  __proto.updateAnimation = function (index, duration, direction) {
    if (!this._control.animating) {
      return;
    }
    var renderer = this._renderer;
    var panelCount = renderer.panelCount;
    var panel = renderer.getPanel(index);
    if (!panel) {
      throw new FlickingError(MESSAGE.INDEX_OUT_OF_RANGE(index, 0, panelCount - 1), CODE.INDEX_OUT_OF_RANGE);
    }
    this._control.updateAnimation(panel, duration, direction);
  };
  /**
   * Stops the animation currently playing
   * @ko 재생 중인 애니메이션을 중단시킵니다
   * @fires Flicking#moveEnd
   * @return {void}
   */
  __proto.stopAnimation = function () {
    if (!this._control.animating) {
      return;
    }
    this._control.stopAnimation();
  };
  /**
   * Return the {@link Panel} at the given index. `null` if it doesn't exists.
   * @ko 주어진 인덱스에 해당하는 {@link Panel}을 반환합니다. 주어진 인덱스에 해당하는 패널이 존재하지 않을 경우 `null`을 반환합니다.
   * @return {Panel | null} Panel at the given index<ko>주어진 인덱스에 해당하는 패널</ko>
   * @see Panel
   * @example
   * ```ts
   * const panel = flicking.getPanel(0);
   * // Which is a shorthand to...
   * const samePanel = flicking.panels[0];
   * ```
   */
  __proto.getPanel = function (index) {
    return this._renderer.getPanel(index);
  };
  /**
   * Enable input from the user (mouse/touch)
   * @ko 사용자의 입력(마우스/터치)를 활성화합니다
   * @return {this}
   */
  __proto.enableInput = function () {
    this._control.enable();
    return this;
  };
  /**
   * Disable input from the user (mouse/touch)
   * @ko 사용자의 입력(마우스/터치)를 막습니다
   * @return {this}
   */
  __proto.disableInput = function () {
    this._control.disable();
    return this;
  };
  /**
   * Get current flicking status. You can restore current state by giving returned value to {@link Flicking#setStatus setStatus()}
   * @ko 현재 상태를 반환합니다. 반환받은 값을 {@link Flicking#setStatus setStatus()} 메소드의 인자로 지정하면 현재 상태를 복원할 수 있습니다
   * @param {object} options Status retrieving options<ko>Status 반환 옵션</ko>
   * @param {boolean} [options.index=true] Include current panel index to the returning status. Camera will automatically move to the given index when the {@link Flicking#setStatus setStatus} is called<ko>현재 패널 인덱스를 반환값에 포함시킵니다. {@link Flicking#setStatus setStatus} 호출시 자동으로 해당 인덱스로 카메라를 움직입니다</ko>
   * @param {boolean} [options.position=true] Include camera position to the returning status. This works only when the {@link Flicking#moveType moveType} is `freeScroll`<ko>카메라의 현재 위치를 반환값에 포함시킵니다. 이 옵션은 {@link Flicking#moveType moveType}이 `freeScroll`일 경우에만 동작합니다</ko>
   * @param {boolean} [options.includePanelHTML=false] Include panel's `outerHTML` to the returning status<ko>패널의 `outerHTML`을 반환값에 포함시킵니다</ko>
   * @param {boolean} [options.visiblePanelsOnly=false] Include only {@link Flicking#visiblePanel visiblePanel}'s HTML. This option is available only when the `includePanelHTML` is true
   * <ko>현재 보이는 패널({@link Flicking#visiblePanel visiblePanel})의 HTML만 반환합니다. `includePanelHTML`이 `true`일 경우에만 동작합니다.</ko>
   * @return {Status} An object with current status value information<ko>현재 상태값 정보를 가진 객체.</ko>
   */
  __proto.getStatus = function (_a) {
    var _b, _c;
    var _d = _a === void 0 ? {} : _a,
      _e = _d.index,
      index = _e === void 0 ? true : _e,
      _f = _d.position,
      position = _f === void 0 ? true : _f,
      _g = _d.includePanelHTML,
      includePanelHTML = _g === void 0 ? false : _g,
      _h = _d.visiblePanelsOnly,
      visiblePanelsOnly = _h === void 0 ? false : _h;
    var camera = this._camera;
    var panels = visiblePanelsOnly ? this.visiblePanels : this.panels;
    var status = {
      panels: panels.map(function (panel) {
        var panelInfo = {
          index: panel.index
        };
        if (includePanelHTML) {
          panelInfo.html = panel.element.outerHTML;
        }
        return panelInfo;
      })
    };
    if (index) {
      status.index = this.index;
    }
    if (position) {
      var nearestAnchor = camera.findNearestAnchor(camera.position);
      if (nearestAnchor) {
        status.position = {
          panel: nearestAnchor.panel.index,
          progressInPanel: camera.getProgressInPanel(nearestAnchor.panel)
        };
      }
    }
    if (visiblePanelsOnly) {
      var visiblePanels = this.visiblePanels;
      status.visibleOffset = (_c = (_b = visiblePanels[0]) === null || _b === void 0 ? void 0 : _b.index) !== null && _c !== void 0 ? _c : 0;
    }
    return status;
  };
  /**
   * Restore to the state of the given {@link Status}
   * @ko 주어진 {@link Status}의 상태로 복원합니다
   * @param {Partial<Status>} status Status value to be restored. You should use the return value of the {@link Flicking#getStatus getStatus()} method<ko>복원할 상태 값. {@link Flicking#getStatus getStatus()} 메서드의 반환값을 지정하면 됩니다</ko>
   * @return {void}
   */
  __proto.setStatus = function (status) {
    var _a;
    if (!this._initialized) {
      throw new FlickingError(MESSAGE.NOT_INITIALIZED, CODE.NOT_INITIALIZED);
    }
    var index = status.index,
      position = status.position,
      visibleOffset = status.visibleOffset,
      panels = status.panels;
    var renderer = this._renderer;
    var control = this._control;
    // Can't add/remove panels on external rendering
    if (((_a = panels[0]) === null || _a === void 0 ? void 0 : _a.html) && !this._renderExternal) {
      renderer.batchRemove({
        index: 0,
        deleteCount: this.panels.length,
        hasDOMInElements: true
      });
      renderer.batchInsert({
        index: 0,
        elements: parseElement(panels.map(function (panel) {
          return panel.html;
        })),
        hasDOMInElements: true
      });
    }
    if (index != null) {
      var panelIndex = visibleOffset ? index - visibleOffset : index;
      void this.moveTo(panelIndex, 0).catch(function () {
        return void 0;
      });
    }
    if (position && this._moveType === MOVE_TYPE.FREE_SCROLL) {
      var panel = position.panel,
        progressInPanel = position.progressInPanel;
      var panelIndex = visibleOffset ? panel - visibleOffset : panel;
      var panelRange = renderer.panels[panelIndex].range;
      var newCameraPos = panelRange.min + (panelRange.max - panelRange.min) * progressInPanel;
      void control.moveToPosition(newCameraPos, 0).catch(function () {
        return void 0;
      });
    }
  };
  /**
   * Add plugins that can have different effects on Flicking
   * @ko 플리킹에 다양한 효과를 부여할 수 있는 플러그인을 추가합니다
   * @param {...Plugin} plugins The plugin(s) to add<ko>추가할 플러그인(들)</ko>
   * @return {this}
   * @see https://github.com/naver/egjs-flicking-plugins
   */
  __proto.addPlugins = function () {
    var _a;
    var _this = this;
    var plugins = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      plugins[_i] = arguments[_i];
    }
    if (this._initialized) {
      plugins.forEach(function (item) {
        return item.init(_this);
      });
    }
    (_a = this._plugins).push.apply(_a, __spread$1(plugins));
    return this;
  };
  /**
   * Remove plugins from Flicking.
   * @ko 플리킹으로부터 플러그인들을 제거합니다.
   * @param {...Plugin} plugin The plugin(s) to remove.<ko>제거 플러그인(들).</ko>
   * @return {this}
   * @see https://github.com/naver/egjs-flicking-plugins
   */
  __proto.removePlugins = function () {
    var _this = this;
    var plugins = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      plugins[_i] = arguments[_i];
    }
    plugins.forEach(function (item) {
      var foundIndex = findIndex(_this._plugins, function (val) {
        return val === item;
      });
      if (foundIndex >= 0) {
        item.destroy();
        _this._plugins.splice(foundIndex, 1);
      }
    });
    return this;
  };
  /**
   * Update viewport/panel sizes
   * @ko 패널 및 뷰포트의 크기를 갱신합니다
   * @method
   * @fires Flicking#beforeResize
   * @fires Flicking#afterResize
   * @return {this}
   */
  __proto.resize = function () {
    return __awaiter(this, void 0, void 0, function () {
      var viewport, renderer, camera, control, activePanel, prevWidth, prevHeight, prevProgressInPanel, newWidth, newHeight, sizeChanged;
      return __generator(this, function (_a) {
        switch (_a.label) {
          case 0:
            viewport = this._viewport;
            renderer = this._renderer;
            camera = this._camera;
            control = this._control;
            activePanel = control.activePanel;
            prevWidth = viewport.width;
            prevHeight = viewport.height;
            prevProgressInPanel = activePanel ? camera.getProgressInPanel(activePanel) : 0;
            this.trigger(new ComponentEvent$1(EVENTS.BEFORE_RESIZE, {
              width: prevWidth,
              height: prevHeight,
              element: viewport.element
            }));
            viewport.resize();
            return [4 /*yield*/, renderer.forceRenderAllPanels()];
          case 1:
            _a.sent(); // Render all panel elements, to update sizes
            if (!this._initialized) {
              return [2 /*return*/];
            }

            renderer.updatePanelSize();
            camera.updateAlignPos();
            camera.updateRange();
            camera.updateAnchors();
            camera.updateAdaptiveHeight();
            camera.updatePanelOrder();
            camera.updateOffset();
            return [4 /*yield*/, renderer.render()];
          case 2:
            _a.sent();
            if (!this._initialized) {
              return [2 /*return*/];
            }

            if (control.animating) ; else {
              control.updatePosition(prevProgressInPanel);
              control.updateInput();
            }
            newWidth = viewport.width;
            newHeight = viewport.height;
            sizeChanged = newWidth !== prevWidth || newHeight !== prevHeight;
            this.trigger(new ComponentEvent$1(EVENTS.AFTER_RESIZE, {
              width: viewport.width,
              height: viewport.height,
              prev: {
                width: prevWidth,
                height: prevHeight
              },
              sizeChanged: sizeChanged,
              element: viewport.element
            }));
            return [2 /*return*/];
        }
      });
    });
  };
  /**
   * Add new panels after the last panel
   * @ko 패널 목록의 제일 끝에 새로운 패널들을 추가합니다
   * @param {ElementLike | ElementLike[]} element A new HTMLElement, a outerHTML of element, or an array of both
   * <ko>새로운 HTMLElement, 혹은 엘리먼트의 outerHTML, 혹은 그것들의 배열</ko>
   * @return {Panel[]} An array of appended panels<ko>추가된 패널들의 배열</ko>
   * @see Panel
   * @see ElementLike
   * @throws {FlickingError} {@link ERROR_CODE ERROR_CODE.NOT_ALLOWED_IN_FRAMEWORK} if called on frameworks (React, Angular, Vue...)
   * @example
   * ```ts
   * const flicking = new Flicking("#flick");
   * // These are possible parameters
   * flicking.append(document.createElement("div"));
   * flicking.append("\<div\>Panel\</div\>");
   * flicking.append(["\<div\>Panel\</div\>", document.createElement("div")]);
   * // Even this is possible
   * flicking.append("\<div\>Panel 1\</div\>\<div\>Panel 2\</div\>");
   * ```
   */
  __proto.append = function (element) {
    return this.insert(this._renderer.panelCount, element);
  };
  /**
   * Add new panels before the first panel
   * This will increase index of panels after by the number of panels added
   * @ko 패널 목록의 제일 앞(index 0)에 새로운 패널들을 추가합니다
   * 추가한 패널의 개수만큼 기존 패널들의 인덱스가 증가합니다.
   * @param {ElementLike | ElementLike[]} element A new HTMLElement, a outerHTML of element, or an array of both
   * <ko>새로운 HTMLElement, 혹은 엘리먼트의 outerHTML, 혹은 그것들의 배열</ko>
   * @return {Panel[]} An array of prepended panels<ko>추가된 패널들의 배열</ko>
   * @see Panel
   * @see ElementLike
   * @throws {FlickingError} {@link ERROR_CODE ERROR_CODE.NOT_ALLOWED_IN_FRAMEWORK} if called on frameworks (React, Angular, Vue...)
   * @example
   * ```ts
   * const flicking = new eg.Flicking("#flick");
   * flicking.prepend(document.createElement("div"));
   * flicking.prepend("\<div\>Panel\</div\>");
   * flicking.prepend(["\<div\>Panel\</div\>", document.createElement("div")]);
   * // Even this is possible
   * flicking.prepend("\<div\>Panel 1\</div\>\<div\>Panel 2\</div\>");
   * ```
   */
  __proto.prepend = function (element) {
    return this.insert(0, element);
  };
  /**
   * Insert new panels at given index
   * This will increase index of panels after by the number of panels added
   * @ko 주어진 인덱스에 새로운 패널들을 추가합니다
   * 해당 인덱스보다 같거나 큰 인덱스를 가진 기존 패널들은 추가한 패널의 개수만큼 인덱스가 증가합니다.
   * @param {number} index Index to insert new panels at<ko>새로 패널들을 추가할 인덱스</ko>
   * @param {ElementLike | ElementLike[]} element A new HTMLElement, a outerHTML of element, or an array of both
   * <ko>새로운 HTMLElement, 혹은 엘리먼트의 outerHTML, 혹은 그것들의 배열</ko>
   * @return {Panel[]} An array of prepended panels<ko>추가된 패널들의 배열</ko>
   * @throws {FlickingError} {@link ERROR_CODE ERROR_CODE.NOT_ALLOWED_IN_FRAMEWORK} if called on frameworks (React, Angular, Vue...)
   * @example
   * ```ts
   * const flicking = new eg.Flicking("#flick");
   * flicking.insert(0, document.createElement("div"));
   * flicking.insert(2, "\<div\>Panel\</div\>");
   * flicking.insert(1, ["\<div\>Panel\</div\>", document.createElement("div")]);
   * // Even this is possible
   * flicking.insert(3, "\<div\>Panel 1\</div\>\<div\>Panel 2\</div\>");
   * ```
   */
  __proto.insert = function (index, element) {
    if (this._renderExternal) {
      throw new FlickingError(MESSAGE.NOT_ALLOWED_IN_FRAMEWORK, CODE.NOT_ALLOWED_IN_FRAMEWORK);
    }
    return this._renderer.batchInsert({
      index: index,
      elements: parseElement(element),
      hasDOMInElements: true
    });
  };
  /**
   * Remove the panel at the given index
   * This will decrease index of panels after by the number of panels removed
   * @ko 주어진 인덱스의 패널을 제거합니다
   * 해당 인덱스보다 큰 인덱스를 가진 기존 패널들은 제거한 패널의 개수만큼 인덱스가 감소합니다
   * @param {number} index Index of panel to remove<ko>제거할 패널의 인덱스</ko>
   * @param {number} [deleteCount=1] Number of panels to remove from index<ko>`index` 이후로 제거할 패널의 개수</ko>
   * @return {Panel[]} An array of removed panels<ko>제거된 패널들의 배열</ko>
   */
  __proto.remove = function (index, deleteCount) {
    if (deleteCount === void 0) {
      deleteCount = 1;
    }
    if (this._renderExternal) {
      throw new FlickingError(MESSAGE.NOT_ALLOWED_IN_FRAMEWORK, CODE.NOT_ALLOWED_IN_FRAMEWORK);
    }
    return this._renderer.batchRemove({
      index: index,
      deleteCount: deleteCount,
      hasDOMInElements: true
    });
  };
  __proto._createControl = function () {
    var _a;
    var moveType = this._moveType;
    var moveTypes = Object.keys(MOVE_TYPE).map(function (key) {
      return MOVE_TYPE[key];
    });
    var moveTypeStr = Array.isArray(moveType) ? moveType[0] : moveType;
    var moveTypeOptions = Array.isArray(moveType) ? (_a = moveType[1]) !== null && _a !== void 0 ? _a : {} : {};
    if (!includes(moveTypes, moveTypeStr)) {
      throw new FlickingError(MESSAGE.WRONG_OPTION("moveType", JSON.stringify(moveType)), CODE.WRONG_OPTION);
    }
    switch (moveTypeStr) {
      case MOVE_TYPE.SNAP:
        return new SnapControl(moveTypeOptions);
      case MOVE_TYPE.FREE_SCROLL:
        return new FreeControl(moveTypeOptions);
      case MOVE_TYPE.STRICT:
        return new StrictControl(moveTypeOptions);
    }
  };
  __proto._createCamera = function () {
    if (this._circular && this._bound) {
      // eslint-disable-next-line no-console
      console.warn("\"circular\" and \"bound\" option cannot be used together, ignoring bound.");
    }
    return new Camera(this, {
      align: this._align
    });
  };
  __proto._createRenderer = function () {
    var externalRenderer = this._externalRenderer;
    if (this._virtual && this._panelsPerView <= 0) {
      // eslint-disable-next-line no-console
      console.warn("\"virtual\" and \"panelsPerView\" option should be used together, ignoring virtual.");
    }
    return externalRenderer ? externalRenderer : this._renderExternal ? this._createExternalRenderer() : this._createVanillaRenderer();
  };
  __proto._createExternalRenderer = function () {
    var _a = this._renderExternal,
      renderer = _a.renderer,
      rendererOptions = _a.rendererOptions;
    return new renderer(__assign$2({
      align: this._align
    }, rendererOptions));
  };
  __proto._createVanillaRenderer = function () {
    var virtual = this.virtualEnabled;
    return new VanillaRenderer({
      align: this._align,
      strategy: virtual ? new VirtualRenderingStrategy() : new NormalRenderingStrategy({
        providerCtor: VanillaElementProvider
      })
    });
  };
  __proto._moveToInitialPanel = function () {
    var renderer = this._renderer;
    var control = this._control;
    var camera = this._camera;
    var defaultPanel = renderer.getPanel(this._defaultIndex) || renderer.getPanel(0);
    if (!defaultPanel) return;
    var nearestAnchor = camera.findNearestAnchor(defaultPanel.position);
    var initialPanel = nearestAnchor && defaultPanel.index !== nearestAnchor.panel.index ? nearestAnchor.panel : defaultPanel;
    control.setActive(initialPanel, null, false);
    if (!nearestAnchor) {
      throw new FlickingError(MESSAGE.POSITION_NOT_REACHABLE(initialPanel.position), CODE.POSITION_NOT_REACHABLE);
    }
    var position = initialPanel.position;
    if (!camera.canReach(initialPanel)) {
      position = nearestAnchor.position;
    }
    camera.lookAt(position);
    control.updateInput();
    camera.updateOffset();
  };
  __proto._initialResize = function () {
    var viewport = this._viewport;
    var renderer = this._renderer;
    var camera = this._camera;
    var control = this._control;
    this.trigger(new ComponentEvent$1(EVENTS.BEFORE_RESIZE, {
      width: 0,
      height: 0,
      element: viewport.element
    }));
    viewport.resize();
    renderer.updatePanelSize();
    camera.updateAlignPos();
    camera.updateRange();
    camera.updateAnchors();
    camera.updateOffset();
    control.updateInput();
    var newWidth = viewport.width;
    var newHeight = viewport.height;
    var sizeChanged = newWidth !== 0 || newHeight !== 0;
    this.trigger(new ComponentEvent$1(EVENTS.AFTER_RESIZE, {
      width: viewport.width,
      height: viewport.height,
      prev: {
        width: 0,
        height: 0
      },
      sizeChanged: sizeChanged,
      element: viewport.element
    }));
  };
  /**
   * Version info string
   * @ko 버전정보 문자열
   * @type {string}
   * @readonly
   * @example
   * ```ts
   * Flicking.VERSION;  // ex) 4.0.0
   * ```
   */
  Flicking.VERSION = "4.11.4";
  return Flicking;
}(Component);

/**
 * Decorator that makes the method of flicking available in the framework.
 * @ko 프레임워크에서 플리킹의 메소드를 사용할 수 있게 하는 데코레이터.
 * @memberof eg.Flicking
 * @private
 * @example
 * ```js
 * import Flicking, { withFlickingMethods } from "@egjs/flicking";
 *
 * class Flicking extends React.Component<Partial<FlickingProps & FlickingOptions>> {
 *   &#64;withFlickingMethods
 *   private flicking: Flicking;
 * }
 * ```
 */
var withFlickingMethods = function (prototype, flickingName) {
  [Component.prototype, Flicking.prototype].forEach(function (proto) {
    Object.getOwnPropertyNames(proto).filter(function (name) {
      return !prototype[name] && name.indexOf("_") !== 0 && name !== "constructor";
    }).forEach(function (name) {
      var descriptor = Object.getOwnPropertyDescriptor(proto, name);
      if (descriptor.value) {
        // Public Function
        Object.defineProperty(prototype, name, {
          value: function () {
            var _a;
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            return (_a = descriptor.value).call.apply(_a, __spread$1([this[flickingName]], args));
          }
        });
      } else {
        var getterDescriptor = {};
        if (descriptor.get) {
          getterDescriptor.get = function () {
            var _a;
            var flicking = this[flickingName];
            return flicking && ((_a = descriptor.get) === null || _a === void 0 ? void 0 : _a.call(flicking));
          };
        }
        if (descriptor.set) {
          getterDescriptor.set = function () {
            var _a;
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            return (_a = descriptor.set) === null || _a === void 0 ? void 0 : _a.call.apply(_a, __spread$1([this[flickingName]], args));
          };
        }
        Object.defineProperty(prototype, name, getterDescriptor);
      }
    });
  });
};

var sync = (function (flicking, diffResult, rendered) {
  var renderer = flicking.renderer;
  var panels = renderer.panels;
  var prevList = __spread$1(diffResult.prevList);
  var added = [];
  var removed = [];
  if (diffResult.removed.length > 0) {
    var endIdx_1 = -1;
    var prevIdx_1 = -1;
    diffResult.removed.forEach(function (removedIdx) {
      if (endIdx_1 < 0) {
        endIdx_1 = removedIdx;
      }
      if (prevIdx_1 >= 0 && removedIdx !== prevIdx_1 - 1) {
        removed.push.apply(removed, __spread$1(batchRemove(renderer, prevIdx_1, endIdx_1 + 1)));
        endIdx_1 = removedIdx;
        prevIdx_1 = removedIdx;
      } else {
        prevIdx_1 = removedIdx;
      }
      prevList.splice(removedIdx, 1);
    });
    removed.push.apply(removed, __spread$1(batchRemove(renderer, prevIdx_1, endIdx_1 + 1)));
  }
  diffResult.ordered.forEach(function (_a) {
    var _b = __read$1(_a, 2),
      from = _b[0],
      to = _b[1];
    var prevPanel = panels.splice(from, 1)[0];
    panels.splice(to, 0, prevPanel);
  });
  if (diffResult.ordered.length > 0) {
    panels.forEach(function (panel, idx) {
      var indexDiff = idx - panel.index;
      if (indexDiff > 0) {
        panel.increaseIndex(indexDiff);
      } else {
        panel.decreaseIndex(-indexDiff);
      }
    });
    panels.sort(function (panel1, panel2) {
      return panel1.index - panel2.index;
    });
    panels.forEach(function (panel) {
      panel.updatePosition();
    });
  }
  if (diffResult.added.length > 0) {
    var startIdx_1 = -1;
    var prevIdx_2 = -1;
    var addedElements_1 = rendered.slice(prevList.length);
    diffResult.added.forEach(function (addedIdx, idx) {
      if (startIdx_1 < 0) {
        startIdx_1 = idx;
      }
      if (prevIdx_2 >= 0 && addedIdx !== prevIdx_2 + 1) {
        added.push.apply(added, __spread$1(batchInsert(renderer, diffResult, addedElements_1, startIdx_1, idx + 1)));
        startIdx_1 = -1;
        prevIdx_2 = -1;
      } else {
        prevIdx_2 = addedIdx;
      }
    });
    if (startIdx_1 >= 0) {
      added.push.apply(added, __spread$1(batchInsert(renderer, diffResult, addedElements_1, startIdx_1)));
    }
  }
  if (diffResult.added.length > 0 || diffResult.removed.length > 0) {
    renderer.updateAfterPanelChange(added, removed);
  }
});
var batchInsert = function (renderer, diffResult, addedElements, startIdx, endIdx) {
  return renderer.batchInsertDefer.apply(renderer, __spread$1(diffResult.added.slice(startIdx, endIdx).map(function (index, elIdx) {
    return {
      index: index,
      elements: [addedElements[elIdx]],
      hasDOMInElements: false
    };
  })));
};
var batchRemove = function (renderer, startIdx, endIdx) {
  var removed = renderer.panels.slice(startIdx, endIdx);
  return renderer.batchRemoveDefer({
    index: startIdx,
    deleteCount: removed.length,
    hasDOMInElements: false
  });
};

var getRenderingPanels = (function (flicking, diffResult) {
  var removedPanels = diffResult.removed.reduce(function (map, idx) {
    map[idx] = true;
    return map;
  }, {});
  var maintainedMap = diffResult.maintained.reduce(function (map, _a) {
    var _b = __read$1(_a, 2),
      prev = _b[0],
      current = _b[1];
    map[prev] = current;
    return map;
  }, {});
  return __spread$1(flicking.panels.filter(function (panel) {
    return !removedPanels[panel.index];
  })
  // Sort panels by position
  .sort(function (panel1, panel2) {
    return panel1.position + panel1.offset - (panel2.position + panel2.offset);
  }).map(function (panel) {
    return diffResult.list[maintainedMap[panel.index]];
  }), diffResult.added.map(function (idx) {
    return diffResult.list[idx];
  }));
});

var getDefaultCameraTransform = (function (align, horizontal, firstPanelSize) {
  if (align === void 0) {
    align = ALIGN.CENTER;
  }
  if (horizontal === void 0) {
    horizontal = true;
  }
  var cameraAlign = getCameraAlign(align);
  var panelAlign = getPanelAlign(align);
  if (panelAlign == null) return "";
  var camPosition = "calc(" + cameraAlign + " - (" + (firstPanelSize || "0px") + " * " + panelAlign.percentage + ") - " + panelAlign.absolute + "px)";
  return horizontal ? "translate(" + camPosition + ")" : "translate(0, " + camPosition + ")";
});
var getCameraAlign = function (align) {
  var alignVal = typeof align === "object" ? align.camera : align;
  return parseAlign(alignVal);
};
var getPanelAlign = function (align) {
  var alignVal = typeof align === "object" ? align.panel : align;
  return parseArithmeticExpression(parseAlign(alignVal));
};
var parseAlign = function (alignVal) {
  if (typeof alignVal === "number") {
    return alignVal + "px";
  }
  switch (alignVal) {
    case ALIGN.CENTER:
      return "50%";
    case ALIGN.NEXT:
      return "100%";
    case ALIGN.PREV:
      return "0%";
    default:
      return alignVal;
  }
};

/*
Copyright (c) 2015-present NAVER Corp.
name: @egjs/react-flicking
license: MIT
author: NAVER Corp.
repository: https://github.com/naver/egjs-flicking/tree/master/packages/react-flicking
version: 4.11.4
*/

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics$4 = function (d, b) {
  extendStatics$4 = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
  };
  return extendStatics$4(d, b);
};
function __extends$4(d, b) {
  if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics$4(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign$3 = function () {
  __assign$3 = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign$3.apply(this, arguments);
};
function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
}
function __decorate$1(decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __awaiter$1(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator$1(thisArg, body) {
  var _ = {
      label: 0,
      sent: function () {
        if (t[0] & 1) throw t[1];
        return t[1];
      },
      trys: [],
      ops: []
    },
    f,
    y,
    t,
    g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;
  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return {
            value: op[1],
            done: false
          };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}

var DEFAULT_PROPS = {
  viewportTag: "div",
  cameraTag: "div",
  cameraClass: "",
  renderOnSameKey: false,
  plugins: [],
  useFindDOMNode: false,
  hideBeforeInit: false,
  onReady: function (e) {},
  onBeforeResize: function (e) {},
  onAfterResize: function (e) {},
  onHoldStart: function (e) {},
  onHoldEnd: function (e) {},
  onMoveStart: function (e) {},
  onMove: function (e) {},
  onMoveEnd: function (e) {},
  onWillChange: function (e) {},
  onChanged: function (e) {},
  onWillRestore: function (e) {},
  onRestored: function (e) {},
  onSelect: function (e) {},
  onNeedPanel: function (e) {},
  onVisibleChange: function (e) {},
  onReachEdge: function (e) {},
  onPanelChange: function (e) {}
};

var ReactRenderer = /*#__PURE__*/function (_super) {
  __extends$4(ReactRenderer, _super);
  function ReactRenderer(options) {
    var _this = _super.call(this, options) || this;
    _this._reactFlicking = options.reactFlicking;
    return _this;
  }
  // eslint-disable-next-line @typescript-eslint/require-await
  var __proto = ReactRenderer.prototype;
  __proto.render = function () {
    return __awaiter$1(this, void 0, void 0, function () {
      var flicking, reactFlicking, strategy;
      var _this = this;
      return __generator$1(this, function (_a) {
        flicking = getFlickingAttached(this._flicking);
        reactFlicking = this._reactFlicking;
        strategy = this._strategy;
        this._rendering = true;
        strategy.updateRenderingPanels(flicking);
        strategy.renderPanels(flicking);
        return [2 /*return*/, new Promise(function (resolve) {
          reactFlicking.renderEmitter.once("render", function () {
            _this._rendering = false;
            _this._afterRender();
            resolve();
          });
          reactFlicking.forceUpdate();
        })];
      });
    });
  };
  __proto.forceRenderAllPanels = function () {
    return __awaiter$1(this, void 0, void 0, function () {
      var reactFlicking;
      var _this = this;
      return __generator$1(this, function (_a) {
        switch (_a.label) {
          case 0:
            reactFlicking = this._reactFlicking;
            this._rendering = true;
            return [4 /*yield*/, _super.prototype.forceRenderAllPanels.call(this)];
          case 1:
            _a.sent();
            return [2 /*return*/, new Promise(function (resolve) {
              reactFlicking.renderEmitter.once("render", function () {
                _this._rendering = false;
                resolve();
              });
              reactFlicking.forceUpdate();
            })];
        }
      });
    });
  };
  __proto.destroy = function () {
    _super.prototype.destroy.call(this);
    this._reactFlicking.renderEmitter.off("render");
  };
  __proto._collectPanels = function () {
    var flicking = getFlickingAttached(this._flicking);
    var reactFlicking = this._reactFlicking;
    var reactPanels = reactFlicking.reactPanels;
    this._panels = this._strategy.collectPanels(flicking, reactPanels);
  };
  __proto._createPanel = function (externalComponent, options) {
    return this._strategy.createPanel(externalComponent, options);
  };
  return ReactRenderer;
}(ExternalRenderer);

var StrictPanel = /*#__PURE__*/function (_super) {
  __extends$4(StrictPanel, _super);
  function StrictPanel() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._hide = false;
    _this._elRef = (0,preact__WEBPACK_IMPORTED_MODULE_0__.createRef)();
    return _this;
  }
  var __proto = StrictPanel.prototype;
  Object.defineProperty(__proto, "nativeElement", {
    get: function () {
      return this._elRef.current;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "rendered", {
    get: function () {
      return !this._hide;
    },
    enumerable: false,
    configurable: true
  });
  __proto.render = function () {
    return this._hide ? (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(preact__WEBPACK_IMPORTED_MODULE_0__.Fragment, null) : this._getElement();
  };
  __proto.show = function () {
    this._hide = false;
  };
  __proto.hide = function () {
    this._hide = true;
  };
  __proto._getElement = function () {
    return rn(k$1.only(this.props.children), {
      ref: this._elRef
    });
  };
  return StrictPanel;
}(preact__WEBPACK_IMPORTED_MODULE_0__.Component);

var NonStrictPanel = /*#__PURE__*/function (_super) {
  __extends$4(NonStrictPanel, _super);
  function NonStrictPanel() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._hide = false;
    return _this;
  }
  var __proto = NonStrictPanel.prototype;
  Object.defineProperty(__proto, "nativeElement", {
    get: function () {
      return on(this);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "rendered", {
    get: function () {
      return !this._hide;
    },
    enumerable: false,
    configurable: true
  });
  __proto.render = function () {
    return this._hide ? (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(preact__WEBPACK_IMPORTED_MODULE_0__.Fragment, null) : this.props.children;
  };
  __proto.show = function () {
    this._hide = false;
  };
  __proto.hide = function () {
    this._hide = true;
  };
  return NonStrictPanel;
}(preact__WEBPACK_IMPORTED_MODULE_0__.Component);

/*
 * Copyright (c) 2015 NAVER Corp.
 * egjs projects are licensed under the MIT license
 */
var ViewportSlot = React__default.memo(function (props) {
  return React__default.createElement(React__default.Fragment, null, props.children);
});

var ReactElementProvider = /*#__PURE__*/function () {
  function ReactElementProvider(el) {
    this._el = el;
  }
  var __proto = ReactElementProvider.prototype;
  Object.defineProperty(__proto, "element", {
    get: function () {
      return this._el.nativeElement;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "rendered", {
    get: function () {
      return this._el.rendered;
    },
    enumerable: false,
    configurable: true
  });
  __proto.show = function () {
    this._el.show();
  };
  __proto.hide = function () {
    this._el.hide();
  };
  return ReactElementProvider;
}();

var Flicking$1 = /*#__PURE__*/function (_super) {
  __extends$4(Flicking$1, _super);
  function Flicking$1(props) {
    var _this = _super.call(this, props) || this;
    _this._panels = [];
    _this._renderEmitter = new Component();
    var children = _this._getChildren();
    _this._panels = _this._createPanelRefs(props, children);
    _this._prevChildren = children;
    return _this;
  }
  var __proto = Flicking$1.prototype;
  Object.defineProperty(__proto, "reactPanels", {
    get: function () {
      return this._panels.map(function (panel) {
        return panel.current;
      });
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "renderEmitter", {
    get: function () {
      return this._renderEmitter;
    },
    enumerable: false,
    configurable: true
  });
  __proto.componentDidMount = function () {
    var props = this.props;
    var rendererOptions = {
      reactFlicking: this,
      align: props.align,
      strategy: props.virtual && props.panelsPerView > 0 ? new VirtualRenderingStrategy() : new NormalRenderingStrategy({
        providerCtor: ReactElementProvider
      })
    };
    var flicking = new Flicking(this._viewportElement, __assign$3(__assign$3({}, props), {
      externalRenderer: new ReactRenderer(rendererOptions)
    }));
    this._vanillaFlicking = flicking;
    var children = this._getChildren();
    this._jsxDiffer = new ListDiffer(children, function (panel) {
      return panel.key;
    });
    this._pluginsDiffer = new ListDiffer();
    this._prevChildren = children;
    this._bindEvents();
    this._checkPlugins();
    if (props.status) {
      flicking.setStatus(props.status);
    }
  };
  __proto.componentWillUnmount = function () {
    var _a;
    (_a = this._vanillaFlicking) === null || _a === void 0 ? void 0 : _a.destroy();
  };
  __proto.shouldComponentUpdate = function (nextProps) {
    var vanillaFlicking = this._vanillaFlicking;
    var prevProps = this.props;
    if (!vanillaFlicking || !vanillaFlicking.initialized) return false;
    var children = nextProps.children,
      restProps = __rest(nextProps, ["children"]);
    for (var key in restProps) {
      if (prevProps[key] !== nextProps[key]) {
        return true;
      }
    }
    var prevChildren = this._prevChildren;
    var nextChildren = this._getChildren(children);
    if (nextProps.renderOnSameKey || !this._hasSameChildren(prevChildren, nextChildren)) return true;
    return false;
  };
  __proto.beforeRender = function () {
    var vanillaFlicking = this._vanillaFlicking;
    var props = this.props;
    var prevChildren = this._prevChildren;
    // Ignore updates before init, they will be updated after "ready" event's force update
    // Also, prevent updates when another update is already queued.
    // This usually happens when render() called twice without calling componentDidMount, like in the case of React.StrictMode.
    if (!vanillaFlicking || !vanillaFlicking.initialized || this._diffResult) return;
    var nextChildren = this._getChildren(props.children);
    if (props.renderOnSameKey || !this._hasSameChildren(prevChildren, nextChildren)) {
      this._panels = this._createPanelRefs(props, nextChildren);
      this._diffResult = this._jsxDiffer.update(nextChildren);
      this._prevChildren = nextChildren;
    }
  };
  __proto.componentDidUpdate = function () {
    var flicking = this._vanillaFlicking;
    var renderEmitter = this._renderEmitter;
    var diffResult = this._diffResult;
    this._checkPlugins();
    renderEmitter.trigger("render");
    flicking.camera.updateOffset();
    // Omit 'virtual', as it can't have any setter
    var _a = this.props;
      _a.virtual;
      var props = __rest(_a, ["virtual"]);
    for (var key in props) {
      if (key in flicking && flicking[key] !== props[key]) {
        flicking[key] = props[key];
      }
    }
    if (!diffResult || !flicking.initialized) return;
    sync(flicking, diffResult, this.reactPanels);
    this._diffResult = null;
  };
  __proto.render = function () {
    var _this = this;
    var _a, _b;
    var props = this.props;
    var Viewport = props.viewportTag;
    var Camera = props.cameraTag;
    var attributes = {};
    var flicking = this._vanillaFlicking;
    this.beforeRender();
    for (var name in props) {
      if (!(name in DEFAULT_PROPS) && !(name in Flicking.prototype)) {
        attributes[name] = props[name];
      }
    }
    var initialized = flicking && flicking.initialized;
    var viewportClasses = ["flicking-viewport"];
    var cameraClasses = ["flicking-camera"];
    var isHorizontal = flicking ? flicking.horizontal : (_a = props.horizontal) !== null && _a !== void 0 ? _a : true;
    if (!isHorizontal) {
      viewportClasses.push("vertical");
    }
    if (props.hideBeforeInit && !initialized) {
      viewportClasses.push("flicking-hidden");
    }
    if (attributes.className) {
      viewportClasses.push(attributes.className);
    }
    if (props.cameraClass) {
      cameraClasses.push(props.cameraClass);
    }
    var cameraProps = !initialized && props.firstPanelSize ? {
      style: {
        transform: getDefaultCameraTransform(this.props.align, this.props.horizontal, this.props.firstPanelSize)
      }
    } : {};
    var panels = !!props.virtual && ((_b = props.panelsPerView) !== null && _b !== void 0 ? _b : -1) > 0 ? this._getVirtualPanels() : this._getPanels();
    return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(Viewport, __assign$3({}, attributes, {
      className: viewportClasses.join(" "),
      ref: function (e) {
        e && (_this._viewportElement = e);
      }
    }), (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(Camera, __assign$3({
      className: cameraClasses.join(" ")
    }, cameraProps), panels), this._getViewportSlot());
  };
  __proto._createPanelRefs = function (props, children) {
    var _a;
    var panelsPerView = (_a = props.panelsPerView) !== null && _a !== void 0 ? _a : -1;
    return panelsPerView > 0 && !!props.virtual ? range(panelsPerView + 1).map(function () {
      return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createRef)();
    }) : children.map(function () {
      return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createRef)();
    });
  };
  __proto._bindEvents = function () {
    var _this = this;
    var flicking = this._vanillaFlicking;
    Object.keys(EVENTS).forEach(function (eventKey) {
      var eventName = EVENTS[eventKey];
      var propName = "on".concat(eventName.charAt(0).toUpperCase() + eventName.slice(1));
      flicking.on(eventName, function (e) {
        e.currentTarget = _this;
        var evtHandler = _this.props[propName];
        evtHandler(e);
      });
    });
    flicking.once(EVENTS.READY, function () {
      _this.forceUpdate();
    });
  };
  __proto._checkPlugins = function () {
    var flicking = this._vanillaFlicking;
    var _a = this._pluginsDiffer.update(this.props.plugins),
      list = _a.list,
      added = _a.added,
      removed = _a.removed,
      prevList = _a.prevList;
    flicking.addPlugins.apply(flicking, added.map(function (index) {
      return list[index];
    }));
    flicking.removePlugins.apply(flicking, removed.map(function (index) {
      return prevList[index];
    }));
  };
  __proto._hasSameChildren = function (prevChildren, nextChildren) {
    if (prevChildren.length !== nextChildren.length || prevChildren.length === 0) return false;
    var same = prevChildren.every(function (child, idx) {
      var nextChild = nextChildren[idx];
      if (child.key && nextChild.key) {
        return child.key === nextChild.key;
      } else {
        return child === nextChild;
      }
    });
    return same;
  };
  __proto._getChildren = function (children) {
    var _this = this;
    if (children === void 0) {
      children = this.props.children;
    }
    return k$1.toArray(children).filter(function (child) {
      return child.type !== ViewportSlot;
    }).reduce(function (all, child) {
      return __spreadArray(__spreadArray([], all, true), _this._unpackFragment(child), true);
    }, []);
  };
  __proto._getViewportSlot = function () {
    return k$1.toArray(this.props.children).filter(function (child) {
      return child.type === ViewportSlot;
    });
  };
  __proto._unpackFragment = function (child) {
    var _this = this;
    return this._isFragment(child) ? k$1.toArray(child.props.children).reduce(function (allChilds, fragChild) {
      return __spreadArray(__spreadArray([], allChilds, true), _this._unpackFragment(fragChild), true);
    }, []) : [child];
  };
  __proto._getVirtualPanels = function () {
    var _this = this;
    var _a = this.props.virtual.panelClass,
      panelClass = _a === void 0 ? "flicking-panel" : _a;
    var panelsPerView = this.props.panelsPerView;
    var flicking = this._vanillaFlicking;
    var initialized = flicking && flicking.initialized;
    var renderingIndexes = initialized ? flicking.renderer.strategy.getRenderingIndexesByOrder(flicking) : range(panelsPerView + 1);
    var firstPanel = flicking && flicking.panels[0];
    var size = firstPanel ? flicking.horizontal ? {
      width: firstPanel.size
    } : {
      height: firstPanel.size
    } : {};
    return renderingIndexes.map(function (idx) {
      return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)("div", {
        key: idx,
        "data-element-index": idx,
        ref: _this._panels[idx],
        className: panelClass,
        style: size
      });
    });
  };
  __proto._getPanels = function () {
    var _this = this;
    var origChildren = this._getChildren();
    var vanillaFlicking = this._vanillaFlicking;
    var diffResult = this._diffResult;
    var children = vanillaFlicking && vanillaFlicking.initialized ? diffResult ? getRenderingPanels(vanillaFlicking, diffResult) : getRenderingPanels(vanillaFlicking, diff(origChildren, origChildren)) : origChildren;
    return this.props.useFindDOMNode ? children.map(function (child, idx) {
      return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(NonStrictPanel, {
        key: child.key,
        ref: _this._panels[idx]
      }, child);
    }) : children.map(function (child, idx) {
      return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(StrictPanel, {
        key: child.key,
        ref: _this._panels[idx]
      }, child);
    });
  };
  __proto._isFragment = function (child) {
    if (child.type) {
      return child.type === preact__WEBPACK_IMPORTED_MODULE_0__.Fragment;
    }
    return child === preact__WEBPACK_IMPORTED_MODULE_0__.Fragment;
  };
  Flicking$1.defaultProps = DEFAULT_PROPS;
  __decorate$1([withFlickingMethods], Flicking$1.prototype, "_vanillaFlicking", void 0);
  return Flicking$1;
}(preact__WEBPACK_IMPORTED_MODULE_0__.Component);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Flicking$1);



/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js!./app/static/pages/globals.css":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js!./app/static/pages/globals.css ***!
  \**********************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `/*
! tailwindcss v3.4.7 | MIT License | https://tailwindcss.com
*//*
1. Prevent padding and border from affecting element width. (https://github.com/mozdevs/cssremedy/issues/4)
2. Allow adding a border to an element by just adding a border-width. (https://github.com/tailwindcss/tailwindcss/pull/116)
*/

*,
::before,
::after {
  box-sizing: border-box; /* 1 */
  border-width: 0; /* 2 */
  border-style: solid; /* 2 */
  border-color: #e5e7eb; /* 2 */
}

::before,
::after {
  --tw-content: '';
}

/*
1. Use a consistent sensible line-height in all browsers.
2. Prevent adjustments of font size after orientation changes in iOS.
3. Use a more readable tab size.
4. Use the user's configured \`sans\` font-family by default.
5. Use the user's configured \`sans\` font-feature-settings by default.
6. Use the user's configured \`sans\` font-variation-settings by default.
7. Disable tap highlights on iOS
*/

html,
:host {
  line-height: 1.5; /* 1 */
  -webkit-text-size-adjust: 100%; /* 2 */
  -moz-tab-size: 4; /* 3 */
  -o-tab-size: 4;
     tab-size: 4; /* 3 */
  font-family: ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji"; /* 4 */
  font-feature-settings: normal; /* 5 */
  font-variation-settings: normal; /* 6 */
  -webkit-tap-highlight-color: transparent; /* 7 */
}

/*
1. Remove the margin in all browsers.
2. Inherit line-height from \`html\` so users can set them as a class directly on the \`html\` element.
*/

body {
  margin: 0; /* 1 */
  line-height: inherit; /* 2 */
}

/*
1. Add the correct height in Firefox.
2. Correct the inheritance of border color in Firefox. (https://bugzilla.mozilla.org/show_bug.cgi?id=190655)
3. Ensure horizontal rules are visible by default.
*/

hr {
  height: 0; /* 1 */
  color: inherit; /* 2 */
  border-top-width: 1px; /* 3 */
}

/*
Add the correct text decoration in Chrome, Edge, and Safari.
*/

abbr:where([title]) {
  -webkit-text-decoration: underline dotted;
          text-decoration: underline dotted;
}

/*
Remove the default font size and weight for headings.
*/

h1,
h2,
h3,
h4,
h5,
h6 {
  font-size: inherit;
  font-weight: inherit;
}

/*
Reset links to optimize for opt-in styling instead of opt-out.
*/

a {
  color: inherit;
  text-decoration: inherit;
}

/*
Add the correct font weight in Edge and Safari.
*/

b,
strong {
  font-weight: bolder;
}

/*
1. Use the user's configured \`mono\` font-family by default.
2. Use the user's configured \`mono\` font-feature-settings by default.
3. Use the user's configured \`mono\` font-variation-settings by default.
4. Correct the odd \`em\` font sizing in all browsers.
*/

code,
kbd,
samp,
pre {
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; /* 1 */
  font-feature-settings: normal; /* 2 */
  font-variation-settings: normal; /* 3 */
  font-size: 1em; /* 4 */
}

/*
Add the correct font size in all browsers.
*/

small {
  font-size: 80%;
}

/*
Prevent \`sub\` and \`sup\` elements from affecting the line height in all browsers.
*/

sub,
sup {
  font-size: 75%;
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}

sub {
  bottom: -0.25em;
}

sup {
  top: -0.5em;
}

/*
1. Remove text indentation from table contents in Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=999088, https://bugs.webkit.org/show_bug.cgi?id=201297)
2. Correct table border color inheritance in all Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=935729, https://bugs.webkit.org/show_bug.cgi?id=195016)
3. Remove gaps between table borders by default.
*/

table {
  text-indent: 0; /* 1 */
  border-color: inherit; /* 2 */
  border-collapse: collapse; /* 3 */
}

/*
1. Change the font styles in all browsers.
2. Remove the margin in Firefox and Safari.
3. Remove default padding in all browsers.
*/

button,
input,
optgroup,
select,
textarea {
  font-family: inherit; /* 1 */
  font-feature-settings: inherit; /* 1 */
  font-variation-settings: inherit; /* 1 */
  font-size: 100%; /* 1 */
  font-weight: inherit; /* 1 */
  line-height: inherit; /* 1 */
  letter-spacing: inherit; /* 1 */
  color: inherit; /* 1 */
  margin: 0; /* 2 */
  padding: 0; /* 3 */
}

/*
Remove the inheritance of text transform in Edge and Firefox.
*/

button,
select {
  text-transform: none;
}

/*
1. Correct the inability to style clickable types in iOS and Safari.
2. Remove default button styles.
*/

button,
input:where([type='button']),
input:where([type='reset']),
input:where([type='submit']) {
  -webkit-appearance: button; /* 1 */
  background-color: transparent; /* 2 */
  background-image: none; /* 2 */
}

/*
Use the modern Firefox focus style for all focusable elements.
*/

:-moz-focusring {
  outline: auto;
}

/*
Remove the additional \`:invalid\` styles in Firefox. (https://github.com/mozilla/gecko-dev/blob/2f9eacd9d3d995c937b4251a5557d95d494c9be1/layout/style/res/forms.css#L728-L737)
*/

:-moz-ui-invalid {
  box-shadow: none;
}

/*
Add the correct vertical alignment in Chrome and Firefox.
*/

progress {
  vertical-align: baseline;
}

/*
Correct the cursor style of increment and decrement buttons in Safari.
*/

::-webkit-inner-spin-button,
::-webkit-outer-spin-button {
  height: auto;
}

/*
1. Correct the odd appearance in Chrome and Safari.
2. Correct the outline style in Safari.
*/

[type='search'] {
  -webkit-appearance: textfield; /* 1 */
  outline-offset: -2px; /* 2 */
}

/*
Remove the inner padding in Chrome and Safari on macOS.
*/

::-webkit-search-decoration {
  -webkit-appearance: none;
}

/*
1. Correct the inability to style clickable types in iOS and Safari.
2. Change font properties to \`inherit\` in Safari.
*/

::-webkit-file-upload-button {
  -webkit-appearance: button; /* 1 */
  font: inherit; /* 2 */
}

/*
Add the correct display in Chrome and Safari.
*/

summary {
  display: list-item;
}

/*
Removes the default spacing and border for appropriate elements.
*/

blockquote,
dl,
dd,
h1,
h2,
h3,
h4,
h5,
h6,
hr,
figure,
p,
pre {
  margin: 0;
}

fieldset {
  margin: 0;
  padding: 0;
}

legend {
  padding: 0;
}

ol,
ul,
menu {
  list-style: none;
  margin: 0;
  padding: 0;
}

/*
Reset default styling for dialogs.
*/
dialog {
  padding: 0;
}

/*
Prevent resizing textareas horizontally by default.
*/

textarea {
  resize: vertical;
}

/*
1. Reset the default placeholder opacity in Firefox. (https://github.com/tailwindlabs/tailwindcss/issues/3300)
2. Set the default placeholder color to the user's configured gray 400 color.
*/

input::-moz-placeholder, textarea::-moz-placeholder {
  opacity: 1; /* 1 */
  color: #9ca3af; /* 2 */
}

input::placeholder,
textarea::placeholder {
  opacity: 1; /* 1 */
  color: #9ca3af; /* 2 */
}

/*
Set the default cursor for buttons.
*/

button,
[role="button"] {
  cursor: pointer;
}

/*
Make sure disabled buttons don't get the pointer cursor.
*/
:disabled {
  cursor: default;
}

/*
1. Make replaced elements \`display: block\` by default. (https://github.com/mozdevs/cssremedy/issues/14)
2. Add \`vertical-align: middle\` to align replaced elements more sensibly by default. (https://github.com/jensimmons/cssremedy/issues/14#issuecomment-634934210)
   This can trigger a poorly considered lint error in some tools but is included by design.
*/

img,
svg,
video,
canvas,
audio,
iframe,
embed,
object {
  display: block; /* 1 */
  vertical-align: middle; /* 2 */
}

/*
Constrain images and videos to the parent width and preserve their intrinsic aspect ratio. (https://github.com/mozdevs/cssremedy/issues/14)
*/

img,
video {
  max-width: 100%;
  height: auto;
}

/* Make elements with the HTML hidden attribute stay hidden by default */
[hidden] {
  display: none;
}

*, ::before, ::after {
  --tw-border-spacing-x: 0;
  --tw-border-spacing-y: 0;
  --tw-translate-x: 0;
  --tw-translate-y: 0;
  --tw-rotate: 0;
  --tw-skew-x: 0;
  --tw-skew-y: 0;
  --tw-scale-x: 1;
  --tw-scale-y: 1;
  --tw-pan-x:  ;
  --tw-pan-y:  ;
  --tw-pinch-zoom:  ;
  --tw-scroll-snap-strictness: proximity;
  --tw-gradient-from-position:  ;
  --tw-gradient-via-position:  ;
  --tw-gradient-to-position:  ;
  --tw-ordinal:  ;
  --tw-slashed-zero:  ;
  --tw-numeric-figure:  ;
  --tw-numeric-spacing:  ;
  --tw-numeric-fraction:  ;
  --tw-ring-inset:  ;
  --tw-ring-offset-width: 0px;
  --tw-ring-offset-color: #fff;
  --tw-ring-color: rgb(59 130 246 / 0.5);
  --tw-ring-offset-shadow: 0 0 #0000;
  --tw-ring-shadow: 0 0 #0000;
  --tw-shadow: 0 0 #0000;
  --tw-shadow-colored: 0 0 #0000;
  --tw-blur:  ;
  --tw-brightness:  ;
  --tw-contrast:  ;
  --tw-grayscale:  ;
  --tw-hue-rotate:  ;
  --tw-invert:  ;
  --tw-saturate:  ;
  --tw-sepia:  ;
  --tw-drop-shadow:  ;
  --tw-backdrop-blur:  ;
  --tw-backdrop-brightness:  ;
  --tw-backdrop-contrast:  ;
  --tw-backdrop-grayscale:  ;
  --tw-backdrop-hue-rotate:  ;
  --tw-backdrop-invert:  ;
  --tw-backdrop-opacity:  ;
  --tw-backdrop-saturate:  ;
  --tw-backdrop-sepia:  ;
  --tw-contain-size:  ;
  --tw-contain-layout:  ;
  --tw-contain-paint:  ;
  --tw-contain-style:  ;
}

::backdrop {
  --tw-border-spacing-x: 0;
  --tw-border-spacing-y: 0;
  --tw-translate-x: 0;
  --tw-translate-y: 0;
  --tw-rotate: 0;
  --tw-skew-x: 0;
  --tw-skew-y: 0;
  --tw-scale-x: 1;
  --tw-scale-y: 1;
  --tw-pan-x:  ;
  --tw-pan-y:  ;
  --tw-pinch-zoom:  ;
  --tw-scroll-snap-strictness: proximity;
  --tw-gradient-from-position:  ;
  --tw-gradient-via-position:  ;
  --tw-gradient-to-position:  ;
  --tw-ordinal:  ;
  --tw-slashed-zero:  ;
  --tw-numeric-figure:  ;
  --tw-numeric-spacing:  ;
  --tw-numeric-fraction:  ;
  --tw-ring-inset:  ;
  --tw-ring-offset-width: 0px;
  --tw-ring-offset-color: #fff;
  --tw-ring-color: rgb(59 130 246 / 0.5);
  --tw-ring-offset-shadow: 0 0 #0000;
  --tw-ring-shadow: 0 0 #0000;
  --tw-shadow: 0 0 #0000;
  --tw-shadow-colored: 0 0 #0000;
  --tw-blur:  ;
  --tw-brightness:  ;
  --tw-contrast:  ;
  --tw-grayscale:  ;
  --tw-hue-rotate:  ;
  --tw-invert:  ;
  --tw-saturate:  ;
  --tw-sepia:  ;
  --tw-drop-shadow:  ;
  --tw-backdrop-blur:  ;
  --tw-backdrop-brightness:  ;
  --tw-backdrop-contrast:  ;
  --tw-backdrop-grayscale:  ;
  --tw-backdrop-hue-rotate:  ;
  --tw-backdrop-invert:  ;
  --tw-backdrop-opacity:  ;
  --tw-backdrop-saturate:  ;
  --tw-backdrop-sepia:  ;
  --tw-contain-size:  ;
  --tw-contain-layout:  ;
  --tw-contain-paint:  ;
  --tw-contain-style:  ;
}
.pointer-events-none {
  pointer-events: none;
}
.visible {
  visibility: visible;
}
.invisible {
  visibility: hidden;
}
.collapse {
  visibility: collapse;
}
.static {
  position: static;
}
.\\!fixed {
  position: fixed !important;
}
.fixed {
  position: fixed;
}
.absolute {
  position: absolute;
}
.relative {
  position: relative;
}
.bottom-\\[68px\\] {
  bottom: 68px;
}
.left-0 {
  left: 0px;
}
.left-\\[-67px\\] {
  left: -67px;
}
.right-0 {
  right: 0px;
}
.right-\\[-67px\\] {
  right: -67px;
}
.right-\\[154px\\] {
  right: 154px;
}
.top-\\[186px\\] {
  top: 186px;
}
.top-\\[234px\\] {
  top: 234px;
}
.left-\\[-31px\\] {
  left: -31px;
}
.top-\\[145px\\] {
  top: 145px;
}
.top-\\[210px\\] {
  top: 210px;
}
.top-\\[220px\\] {
  top: 220px;
}
.z-0 {
  z-index: 0;
}
.z-40 {
  z-index: 40;
}
.z-\\[1\\] {
  z-index: 1;
}
.z-\\[2\\] {
  z-index: 2;
}
.mx-auto {
  margin-left: auto;
  margin-right: auto;
}
.mb-\\[115px\\] {
  margin-bottom: 115px;
}
.mb-auto {
  margin-bottom: auto;
}
.ml-\\[-67px\\] {
  margin-left: -67px;
}
.ml-\\[165px\\] {
  margin-left: 165px;
}
.ml-\\[59px\\] {
  margin-left: 59px;
}
.ml-\\[98px\\] {
  margin-left: 98px;
}
.mr-\\[-160px\\] {
  margin-right: -160px;
}
.mt-\\[-200px\\] {
  margin-top: -200px;
}
.mt-\\[120px\\] {
  margin-top: 120px;
}
.mt-\\[200px\\] {
  margin-top: 200px;
}
.mt-\\[44px\\] {
  margin-top: 44px;
}
.mt-\\[77px\\] {
  margin-top: 77px;
}
.mt-\\[-120px\\] {
  margin-top: -120px;
}
.mt-\\[0px\\] {
  margin-top: 0px;
}
.block {
  display: block;
}
.flex {
  display: flex;
}
.table {
  display: table;
}
.grid {
  display: grid;
}
.contents {
  display: contents;
}
.hidden {
  display: none;
}
.size-\\[40px\\] {
  width: 40px;
  height: 40px;
}
.size-full {
  width: 100%;
  height: 100%;
}
.h-\\[1100px\\] {
  height: 1100px;
}
.h-\\[200px\\] {
  height: 200px;
}
.h-\\[233px\\] {
  height: 233px;
}
.h-\\[528px\\] {
  height: 528px;
}
.h-\\[606px\\] {
  height: 606px;
}
.h-\\[608px\\] {
  height: 608px;
}
.h-\\[64px\\] {
  height: 64px;
}
.h-\\[728px\\] {
  height: 728px;
}
.h-\\[72px\\] {
  height: 72px;
}
.h-\\[784px\\] {
  height: 784px;
}
.h-\\[984px\\] {
  height: 984px;
}
.h-fit {
  height: -moz-fit-content;
  height: fit-content;
}
.h-\\[28px\\] {
  height: 28px;
}
.h-\\[538px\\] {
  height: 538px;
}
.h-\\[53\\] {
  height: 53;
}
.h-\\[538ox\\] {
  height: 538ox;
}
.h-\\[648px\\] {
  height: 648px;
}
.h-\\[748px\\] {
  height: 748px;
}
.h-\\[518px\\] {
  height: 518px;
}
.h-\\[438px\\] {
  height: 438px;
}
.h-\\[658px\\] {
  height: 658px;
}
.h-\\[450px\\] {
  height: 450px;
}
.min-h-\\[728px\\] {
  min-height: 728px;
}
.min-h-dvh {
  min-height: 100dvh;
}
.min-h-screen {
  min-height: 100vh;
}
.min-h-\\[784px\\] {
  min-height: 784px;
}
.w-\\[177px\\] {
  width: 177px;
}
.w-\\[199px\\] {
  width: 199px;
}
.w-\\[445px\\] {
  width: 445px;
}
.w-\\[504px\\] {
  width: 504px;
}
.w-\\[705px\\] {
  width: 705px;
}
.w-\\[735px\\] {
  width: 735px;
}
.w-\\[895px\\] {
  width: 895px;
}
.w-fit {
  width: -moz-fit-content;
  width: fit-content;
}
.w-full {
  width: 100%;
}
.w-\\[400px\\] {
  width: 400px;
}
.w-\\[500px\\] {
  width: 500px;
}
.w-\\[540px\\] {
  width: 540px;
}
.w-\\[530px\\] {
  width: 530px;
}
.w-\\[438px\\] {
  width: 438px;
}
.w-\\[62px\\] {
  width: 62px;
}
.w-\\[355px\\] {
  width: 355px;
}
.w-\\[538px\\] {
  width: 538px;
}
.w-\\[638px\\] {
  width: 638px;
}
.w-\\[38px\\] {
  width: 38px;
}
.w-\\[390px\\] {
  width: 390px;
}
.min-w-\\[147px\\] {
  min-width: 147px;
}
.min-w-\\[735px\\] {
  min-width: 735px;
}
.max-w-\\[1342px\\] {
  max-width: 1342px;
}
.max-w-\\[1440px\\] {
  max-width: 1440px;
}
.max-w-\\[190px\\] {
  max-width: 190px;
}
.max-w-\\[398px\\] {
  max-width: 398px;
}
.max-w-\\[438px\\] {
  max-width: 438px;
}
.max-w-\\[540px\\] {
  max-width: 540px;
}
.max-w-\\[635px\\] {
  max-width: 635px;
}
.max-w-\\[730px\\] {
  max-width: 730px;
}
.max-w-\\[calc\\(1275px\\+39px\\)\\] {
  max-width: calc(1275px + 39px);
}
.max-w-full {
  max-width: 100%;
}
.max-w-\\[281px\\] {
  max-width: 281px;
}
.max-w-\\[250px\\] {
  max-width: 250px;
}
.flex-shrink {
  flex-shrink: 1;
}
.border-collapse {
  border-collapse: collapse;
}
.transform {
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.resize {
  resize: both;
}
.flex-col {
  flex-direction: column;
}
.items-start {
  align-items: flex-start;
}
.items-center {
  align-items: center;
}
.justify-start {
  justify-content: flex-start;
}
.justify-end {
  justify-content: flex-end;
}
.justify-center {
  justify-content: center;
}
.justify-between {
  justify-content: space-between;
}
.gap-\\[16px\\] {
  gap: 16px;
}
.gap-\\[24px\\] {
  gap: 24px;
}
.gap-\\[28px\\] {
  gap: 28px;
}
.gap-\\[39px\\] {
  gap: 39px;
}
.gap-\\[43px\\] {
  gap: 43px;
}
.gap-\\[48px\\] {
  gap: 48px;
}
.gap-\\[51px\\] {
  gap: 51px;
}
.gap-\\[56px\\] {
  gap: 56px;
}
.gap-\\[32px\\] {
  gap: 32px;
}
.self-end {
  align-self: flex-end;
}
.overflow-x-clip {
  overflow-x: clip;
}
.rounded {
  border-radius: 0.25rem;
}
.border {
  border-width: 1px;
}
.bg-\\[\\#191921\\] {
  --tw-bg-opacity: 1;
  background-color: rgb(25 25 33 / var(--tw-bg-opacity));
}
.bg-\\[\\#F94F4F\\] {
  --tw-bg-opacity: 1;
  background-color: rgb(249 79 79 / var(--tw-bg-opacity));
}
.stroke-\\[\\#F94F4F\\] {
  stroke: #F94F4F;
}
.stroke-\\[\\#FF9393\\] {
  stroke: #FF9393;
}
.object-cover {
  -o-object-fit: cover;
     object-fit: cover;
}
.object-\\[100\\%_100\\%\\] {
  -o-object-position: 100% 100%;
     object-position: 100% 100%;
}
.object-\\[00\\%_100\\%\\] {
  -o-object-position: 00% 100%;
     object-position: 00% 100%;
}
.object-\\[0\\%_100\\%\\] {
  -o-object-position: 0% 100%;
     object-position: 0% 100%;
}
.object-\\[100\\%_0\\%\\] {
  -o-object-position: 100% 0%;
     object-position: 100% 0%;
}
.object-center {
  -o-object-position: center;
     object-position: center;
}
.px-0 {
  padding-left: 0px;
  padding-right: 0px;
}
.px-\\[43px\\] {
  padding-left: 43px;
  padding-right: 43px;
}
.pl-\\[154px\\] {
  padding-left: 154px;
}
.pl-\\[33px\\] {
  padding-left: 33px;
}
.pl-\\[39px\\] {
  padding-left: 39px;
}
.pr-\\[106px\\] {
  padding-right: 106px;
}
.pr-\\[40px\\] {
  padding-right: 40px;
}
.pr-0 {
  padding-right: 0px;
}
.pl-\\[69px\\] {
  padding-left: 69px;
}
.pr-\\[116px\\] {
  padding-right: 116px;
}
.pr-\\[20px\\] {
  padding-right: 20px;
}
.text-end {
  text-align: end;
}
.font-commissioner {
  font-family: "Commissioner", sans-serif;
}
.text-\\[16px\\] {
  font-size: 16px;
}
.text-\\[18px\\] {
  font-size: 18px;
}
.text-\\[80px\\] {
  font-size: 80px;
}
.text-\\[15px\\] {
  font-size: 15px;
}
.text-\\[20px\\] {
  font-size: 20px;
}
.text-\\[32px\\] {
  font-size: 32px;
}
.text-\\[56px\\] {
  font-size: 56px;
}
.font-extrabold {
  font-weight: 800;
}
.leading-\\[32px\\] {
  line-height: 32px;
}
.leading-\\[88px\\] {
  line-height: 88px;
}
.leading-\\[25px\\] {
  line-height: 25px;
}
.leading-\\[40px\\] {
  line-height: 40px;
}
.leading-\\[56px\\] {
  line-height: 56px;
}
.text-\\[\\#F94F4F\\] {
  --tw-text-opacity: 1;
  color: rgb(249 79 79 / var(--tw-text-opacity));
}
.text-white {
  --tw-text-opacity: 1;
  color: rgb(255 255 255 / var(--tw-text-opacity));
}
.text-white\\/25 {
  color: rgb(255 255 255 / 0.25);
}
.underline {
  text-decoration-line: underline;
}
.overline {
  text-decoration-line: overline;
}
.underline-offset-\\[12px\\] {
  text-underline-offset: 12px;
}
.outline {
  outline-style: solid;
}
.filter {
  filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow);
}
.transition {
  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, -webkit-backdrop-filter;
  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter;
  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter, -webkit-backdrop-filter;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 150ms;
}
.transition-all {
  transition-property: all;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 150ms;
}

h1 {
  font-size: 56px;
  font-weight: 800;
  line-height: 56px;
}

@media (min-width: 1280px) {

  h1 {
    font-size: 80px;
    line-height: 88px;
  }
}

h2 {
  font-size: 32px;
  font-weight: 800;
  line-height: 40px;
}

@media (min-width: 1280px) {

  h2 {
    font-size: 56px;
    line-height: 64px;
  }
}

h3 {
  font-size: 20px;
  font-weight: 800;
  line-height: 32px;
}

p {
  font-size: 15px;
  line-height: 25px;
}

@media (min-width: 1280px) {

  p {
    font-size: 18px;
    line-height: 32px;
  }
}

a {
  font-size: 15px;
}

@media (min-width: 1280px) {

  a {
    font-size: 16px;
  }
}

.previous,
.next {
  stroke: #F94F4F;
  transition-property: all;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 150ms;
}
.previous:hover,
.next:hover {
  stroke: #FF9393;
}

.panel {
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 24px;
}

.image-container {
  position: relative;
}

.image-container::after {
  content: '';
  position: absolute;
  bottom: 0;
  left: 0;
  width: 100%;
  height: 200px;
  background: linear-gradient(to bottom, rgba(0, 0, 0, 0) 0%, rgba(0, 0, 0, 0.5) 100%);
  pointer-events: none;
}

.hover\\:cursor-grab:hover {
  cursor: grab;
}

.hover\\:bg-\\[\\#434356\\]:hover {
  --tw-bg-opacity: 1;
  background-color: rgb(67 67 86 / var(--tw-bg-opacity));
}

.hover\\:bg-\\[\\#FF9393\\]:hover {
  --tw-bg-opacity: 1;
  background-color: rgb(255 147 147 / var(--tw-bg-opacity));
}

.hover\\:font-bold:hover {
  font-weight: 700;
}

.hover\\:text-\\[\\#FF9393\\]:hover {
  --tw-text-opacity: 1;
  color: rgb(255 147 147 / var(--tw-text-opacity));
}

.active\\:cursor-grabbing:active {
  cursor: grabbing;
}

@media (min-width: 768px) {

  .md\\:h-\\[178px\\] {
    height: 178px;
  }

  .md\\:h-\\[606px\\] {
    height: 606px;
  }

  .md\\:min-h-screen {
    min-height: 100vh;
  }
}

@media (min-width: 1024px) {

  .lg\\:mt-\\[200px\\] {
    margin-top: 200px;
  }

  .lg\\:mt-\\[-200px\\] {
    margin-top: -200px;
  }

  .lg\\:h-\\[750px\\] {
    height: 750px;
  }

  .lg\\:h-\\[\\] {
    height: ;
  }

  .lg\\:h-\\[560px\\] {
    height: 560px;
  }

  .lg\\:h-\\[648px\\] {
    height: 648px;
  }

  .lg\\:h-\\[538px\\] {
    height: 538px;
  }

  .lg\\:w-\\[530px\\] {
    width: 530px;
  }

  .lg\\:w-\\[630px\\] {
    width: 630px;
  }

  .lg\\:w-\\[895px\\] {
    width: 895px;
  }

  .lg\\:w-\\[600px\\] {
    width: 600px;
  }

  .lg\\:max-w-\\[530px\\] {
    max-width: 530px;
  }

  .lg\\:max-w-full {
    max-width: 100%;
  }

  .lg\\:max-w-\\[630px\\] {
    max-width: 630px;
  }

  .lg\\:gap-\\[40px\\] {
    gap: 40px;
  }

  .lg\\:gap-\\[60px\\] {
    gap: 60px;
  }

  .lg\\:gap-\\[50px\\] {
    gap: 50px;
  }

  .lg\\:gap-\\[40\\] {
    gap: 40;
  }

  .lg\\:pr-\\[40px\\] {
    padding-right: 40px;
  }

  .lg\\:pr-\\[20px\\] {
    padding-right: 20px;
  }

  .lg\\:pl-\\[80px\\] {
    padding-left: 80px;
  }

  .lg\\:pr-\\[60px\\] {
    padding-right: 60px;
  }

  .lg\\:pl-\\[90px\\] {
    padding-left: 90px;
  }
}

@media (min-width: 1280px) {

  .xl\\:left-\\[-67px\\] {
    left: -67px;
  }

  .xl\\:top-\\[234px\\] {
    top: 234px;
  }

  .xl\\:mt-\\[112px\\] {
    margin-top: 112px;
  }

  .xl\\:mt-\\[-200px\\] {
    margin-top: -200px;
  }

  .xl\\:h-\\[800px\\] {
    height: 800px;
  }

  .xl\\:h-\\[61px\\] {
    height: 61px;
  }

  .xl\\:h-\\[784px\\] {
    height: 784px;
  }

  .xl\\:h-\\[984px\\] {
    height: 984px;
  }

  .xl\\:w-\\[735px\\] {
    width: 735px;
  }

  .xl\\:w-\\[705px\\] {
    width: 705px;
  }

  .xl\\:w-\\[135px\\] {
    width: 135px;
  }

  .xl\\:w-\\[895px\\] {
    width: 895px;
  }

  .xl\\:w-\\[504px\\] {
    width: 504px;
  }

  .xl\\:min-w-\\[199px\\] {
    min-width: 199px;
  }

  .xl\\:max-w-\\[225px\\] {
    max-width: 225px;
  }

  .xl\\:max-w-\\[47vw\\] {
    max-width: 47vw;
  }

  .xl\\:max-w-\\[540px\\] {
    max-width: 540px;
  }

  .xl\\:max-w-\\[680\\] {
    max-width: 680;
  }

  .xl\\:gap-\\[48px\\] {
    gap: 48px;
  }

  .xl\\:gap-\\[43px\\] {
    gap: 43px;
  }

  .xl\\:object-center {
    -o-object-position: center;
       object-position: center;
  }

  .xl\\:px-0 {
    padding-left: 0px;
    padding-right: 0px;
  }

  .xl\\:pl-\\[69px\\] {
    padding-left: 69px;
  }

  .xl\\:pr-0 {
    padding-right: 0px;
  }

  .xl\\:pr-\\[20px\\] {
    padding-right: 20px;
  }

  .xl\\:pr-\\[106px\\] {
    padding-right: 106px;
  }

  .xl\\:pl-\\[154px\\] {
    padding-left: 154px;
  }

  .xl\\:text-\\[16px\\] {
    font-size: 16px;
  }

  .xl\\:text-\\[18px\\] {
    font-size: 18px;
  }

  .xl\\:text-\\[56px\\] {
    font-size: 56px;
  }

  .xl\\:text-\\[80px\\] {
    font-size: 80px;
  }

  .xl\\:leading-\\[32px\\] {
    line-height: 32px;
  }

  .xl\\:leading-\\[64px\\] {
    line-height: 64px;
  }

  .xl\\:leading-\\[88px\\] {
    line-height: 88px;
  }
}

@media (min-width: 1500px) {

  .screen1500\\:max-w-\\[705px\\] {
    max-width: 705px;
  }
}
`, "",{"version":3,"sources":["webpack://./app/static/pages/globals.css"],"names":[],"mappings":"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AAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA,iBAAmB;EAAnB;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA,WAAmB;EAAnB;AAAmB;AAAnB;EAAA,WAAmB;EAAnB;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA,wBAAmB;EAAnB;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA,uBAAmB;EAAnB;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA,kBAAmB;EAAnB;AAAmB;AAAnB;EAAA,kBAAmB;EAAnB;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA,oBAAmB;KAAnB;AAAmB;AAAnB;EAAA,6BAAmB;KAAnB;AAAmB;AAAnB;EAAA,4BAAmB;KAAnB;AAAmB;AAAnB;EAAA,2BAAmB;KAAnB;AAAmB;AAAnB;EAAA,2BAAmB;KAAnB;AAAmB;AAAnB;EAAA,0BAAmB;KAAnB;AAAmB;AAAnB;EAAA,iBAAmB;EAAnB;AAAmB;AAAnB;EAAA,kBAAmB;EAAnB;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA,oBAAmB;EAAnB;AAAmB;AAAnB;EAAA,oBAAmB;EAAnB;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA,gKAAmB;EAAnB,wJAAmB;EAAnB,iLAAmB;EAAnB,wDAAmB;EAAnB;AAAmB;AAAnB;EAAA,wBAAmB;EAAnB,wDAAmB;EAAnB;AAAmB;;AAGjB;EAAA,eAAiF;EAAjF,gBAAiF;EAAjF;AAAiF;;AAAjF;;EAAA;IAAA,eAAiF;IAAjF;EAAiF;AAAA;;AAIjF;EAAA,eAAiF;EAAjF,gBAAiF;EAAjF;AAAiF;;AAAjF;;EAAA;IAAA,eAAiF;IAAjF;EAAiF;AAAA;;AAIjF;EAAA,eAAgD;EAAhD,gBAAgD;EAAhD;AAAgD;;AAIhD;EAAA,eAAkE;EAAlE;AAAkE;;AAAlE;;EAAA;IAAA,eAAkE;IAAlE;EAAkE;AAAA;;AAIlE;EAAA;AAAiC;;AAAjC;;EAAA;IAAA;EAAiC;AAAA;;AAKjC;;EAAA,eAAsC;EAAtC,wBAAsC;EAAtC,wDAAsC;EAAtC;AAAsC;AAItC;;EAAA;AAAuB;;AAGzB;EACE,WAAW;EACX,YAAY;EACZ,aAAa;EACb,mBAAmB;EACnB,uBAAuB;EACvB,eAAe;AACjB;;AAEA;EACE,kBAAkB;AACpB;;AAEA;EACE,WAAW;EACX,kBAAkB;EAClB,SAAS;EACT,OAAO;EACP,WAAW;EACX,aAAa;EACb,oFAAoF;EACpF,oBAAoB;AACtB;;AAvDA;EAAA;AAwDA;;AAxDA;EAAA,kBAwDA;EAxDA;AAwDA;;AAxDA;EAAA,kBAwDA;EAxDA;AAwDA;;AAxDA;EAAA;AAwDA;;AAxDA;EAAA,oBAwDA;EAxDA;AAwDA;;AAxDA;EAAA;AAwDA;;AAxDA;;EAAA;IAAA;EAwDA;;EAxDA;IAAA;EAwDA;;EAxDA;IAAA;EAwDA;AAAA;;AAxDA;;EAAA;IAAA;EAwDA;;EAxDA;IAAA;EAwDA;;EAxDA;IAAA;EAwDA;;EAxDA;IAAA;EAwDA;;EAxDA;IAAA;EAwDA;;EAxDA;IAAA;EAwDA;;EAxDA;IAAA;EAwDA;;EAxDA;IAAA;EAwDA;;EAxDA;IAAA;EAwDA;;EAxDA;IAAA;EAwDA;;EAxDA;IAAA;EAwDA;;EAxDA;IAAA;EAwDA;;EAxDA;IAAA;EAwDA;;EAxDA;IAAA;EAwDA;;EAxDA;IAAA;EAwDA;;EAxDA;IAAA;EAwDA;;EAxDA;IAAA;EAwDA;;EAxDA;IAAA;EAwDA;;EAxDA;IAAA;EAwDA;;EAxDA;IAAA;EAwDA;;EAxDA;IAAA;EAwDA;;EAxDA;IAAA;EAwDA;;EAxDA;IAAA;EAwDA;AAAA;;AAxDA;;EAAA;IAAA;EAwDA;;EAxDA;IAAA;EAwDA;;EAxDA;IAAA;EAwDA;;EAxDA;IAAA;EAwDA;;EAxDA;IAAA;EAwDA;;EAxDA;IAAA;EAwDA;;EAxDA;IAAA;EAwDA;;EAxDA;IAAA;EAwDA;;EAxDA;IAAA;EAwDA;;EAxDA;IAAA;EAwDA;;EAxDA;IAAA;EAwDA;;EAxDA;IAAA;EAwDA;;EAxDA;IAAA;EAwDA;;EAxDA;IAAA;EAwDA;;EAxDA;IAAA;EAwDA;;EAxDA;IAAA;EAwDA;;EAxDA;IAAA;EAwDA;;EAxDA;IAAA;EAwDA;;EAxDA;IAAA;EAwDA;;EAxDA;IAAA;EAwDA;;EAxDA;IAAA,0BAwDA;OAxDA;EAwDA;;EAxDA;IAAA,iBAwDA;IAxDA;EAwDA;;EAxDA;IAAA;EAwDA;;EAxDA;IAAA;EAwDA;;EAxDA;IAAA;EAwDA;;EAxDA;IAAA;EAwDA;;EAxDA;IAAA;EAwDA;;EAxDA;IAAA;EAwDA;;EAxDA;IAAA;EAwDA;;EAxDA;IAAA;EAwDA;;EAxDA;IAAA;EAwDA;;EAxDA;IAAA;EAwDA;;EAxDA;IAAA;EAwDA;;EAxDA;IAAA;EAwDA;AAAA;;AAxDA;;EAAA;IAAA;EAwDA;AAAA","sourcesContent":["@tailwind base;\r\n@tailwind components;\r\n@tailwind utilities;\r\n\r\nh1 {\r\n  @apply text-[56px] font-extrabold leading-[56px] xl:text-[80px] xl:leading-[88px];\r\n}\r\n\r\nh2 {\r\n  @apply text-[32px] xl:text-[56px] font-extrabold leading-[40px] xl:leading-[64px];\r\n}\r\n\r\nh3 {\r\n  @apply text-[20px] font-extrabold leading-[32px];\r\n}\r\n\r\np {\r\n  @apply text-[15px] xl:text-[18px] leading-[25px] xl:leading-[32px];\r\n}\r\n\r\na{\r\n  @apply text-[15px] xl:text-[16px];\r\n}\r\n\r\n.previous,\r\n.next {\r\n  @apply stroke-[#F94F4F] transition-all;\r\n}\r\n.previous:hover,\r\n.next:hover {\r\n  @apply stroke-[#FF9393];\r\n}\r\n\r\n.panel {\r\n  width: 100%;\r\n  height: 100%;\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n  font-size: 24px;\r\n}\r\n\r\n.image-container {\r\n  position: relative;\r\n}\r\n\r\n.image-container::after {\r\n  content: '';\r\n  position: absolute;\r\n  bottom: 0;\r\n  left: 0;\r\n  width: 100%;\r\n  height: 200px;\r\n  background: linear-gradient(to bottom, rgba(0, 0, 0, 0) 0%, rgba(0, 0, 0, 0.5) 100%);\r\n  pointer-events: none;\r\n}\r\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js!./node_modules/@egjs/preact-flicking/dist/flicking.css":
/*!**********************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js!./node_modules/@egjs/preact-flicking/dist/flicking.css ***!
  \**********************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `.flicking-viewport {
  position: relative;
  overflow: hidden;
}

.flicking-viewport.vertical {
  display: inline-flex;
}

.flicking-viewport.vertical > .flicking-camera {
  display: inline-flex;
  flex-direction: column;
}

.flicking-viewport.flicking-hidden > .flicking-camera > * {
  visibility: hidden;
}

.flicking-camera {
  width: 100%;
  height: 100%;
  display: flex;
  position: relative;
  flex-direction: row;
  z-index: 1;
  will-change: transform;
}

.flicking-camera > * {
  flex-shrink: 0;
}
`, "",{"version":3,"sources":["webpack://./node_modules/@egjs/preact-flicking/dist/flicking.css"],"names":[],"mappings":"AAAA;EACE,kBAAkB;EAClB,gBAAgB;AAClB;;AAEA;EAGE,oBAAoB;AACtB;;AAEA;EAGE,oBAAoB;EAIZ,sBAAsB;AAChC;;AAEA;EACE,kBAAkB;AACpB;;AAEA;EACE,WAAW;EACX,YAAY;EAGZ,aAAa;EACb,kBAAkB;EAIV,mBAAmB;EAC3B,UAAU;EACV,sBAAsB;AACxB;;AAEA;EAEM,cAAc;AACpB","sourcesContent":[".flicking-viewport {\n  position: relative;\n  overflow: hidden;\n}\n\n.flicking-viewport.vertical {\n  display: -webkit-inline-box;\n  display: -ms-inline-flexbox;\n  display: inline-flex;\n}\n\n.flicking-viewport.vertical > .flicking-camera {\n  display: -webkit-inline-box;\n  display: -ms-inline-flexbox;\n  display: inline-flex;\n  -webkit-box-orient: vertical;\n  -webkit-box-direction: normal;\n      -ms-flex-direction: column;\n          flex-direction: column;\n}\n\n.flicking-viewport.flicking-hidden > .flicking-camera > * {\n  visibility: hidden;\n}\n\n.flicking-camera {\n  width: 100%;\n  height: 100%;\n  display: -webkit-box;\n  display: -ms-flexbox;\n  display: flex;\n  position: relative;\n  -webkit-box-orient: horizontal;\n  -webkit-box-direction: normal;\n      -ms-flex-direction: row;\n          flex-direction: row;\n  z-index: 1;\n  will-change: transform;\n}\n\n.flicking-camera > * {\n  -ms-flex-negative: 0;\n      flex-shrink: 0;\n}\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {



/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
module.exports = function (cssWithMappingToString) {
  var list = [];

  // return the list of modules as css string
  list.toString = function toString() {
    return this.map(function (item) {
      var content = "";
      var needLayer = typeof item[5] !== "undefined";
      if (item[4]) {
        content += "@supports (".concat(item[4], ") {");
      }
      if (item[2]) {
        content += "@media ".concat(item[2], " {");
      }
      if (needLayer) {
        content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");
      }
      content += cssWithMappingToString(item);
      if (needLayer) {
        content += "}";
      }
      if (item[2]) {
        content += "}";
      }
      if (item[4]) {
        content += "}";
      }
      return content;
    }).join("");
  };

  // import a list of modules into the list
  list.i = function i(modules, media, dedupe, supports, layer) {
    if (typeof modules === "string") {
      modules = [[null, modules, undefined]];
    }
    var alreadyImportedModules = {};
    if (dedupe) {
      for (var k = 0; k < this.length; k++) {
        var id = this[k][0];
        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }
    for (var _k = 0; _k < modules.length; _k++) {
      var item = [].concat(modules[_k]);
      if (dedupe && alreadyImportedModules[item[0]]) {
        continue;
      }
      if (typeof layer !== "undefined") {
        if (typeof item[5] === "undefined") {
          item[5] = layer;
        } else {
          item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");
          item[5] = layer;
        }
      }
      if (media) {
        if (!item[2]) {
          item[2] = media;
        } else {
          item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");
          item[2] = media;
        }
      }
      if (supports) {
        if (!item[4]) {
          item[4] = "".concat(supports);
        } else {
          item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");
          item[4] = supports;
        }
      }
      list.push(item);
    }
  };
  return list;
};

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/sourceMaps.js":
/*!************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/sourceMaps.js ***!
  \************************************************************/
/***/ ((module) => {



module.exports = function (item) {
  var content = item[1];
  var cssMapping = item[3];
  if (!cssMapping) {
    return content;
  }
  if (typeof btoa === "function") {
    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));
    var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
    var sourceMapping = "/*# ".concat(data, " */");
    return [content].concat([sourceMapping]).join("\n");
  }
  return [content].join("\n");
};

/***/ }),

/***/ "./node_modules/preact/dist/preact.module.js":
/*!***************************************************!*\
  !*** ./node_modules/preact/dist/preact.module.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Component: () => (/* binding */ b),
/* harmony export */   Fragment: () => (/* binding */ k),
/* harmony export */   cloneElement: () => (/* binding */ E),
/* harmony export */   createContext: () => (/* binding */ G),
/* harmony export */   createElement: () => (/* binding */ _),
/* harmony export */   createRef: () => (/* binding */ m),
/* harmony export */   h: () => (/* binding */ _),
/* harmony export */   hydrate: () => (/* binding */ D),
/* harmony export */   isValidElement: () => (/* binding */ t),
/* harmony export */   options: () => (/* binding */ l),
/* harmony export */   render: () => (/* binding */ B),
/* harmony export */   toChildArray: () => (/* binding */ H)
/* harmony export */ });
var n,l,u,t,i,o,r,f,e,c,s,a,h={},p=[],v=/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i,y=Array.isArray;function d(n,l){for(var u in l)n[u]=l[u];return n}function w(n){var l=n.parentNode;l&&l.removeChild(n)}function _(l,u,t){var i,o,r,f={};for(r in u)"key"==r?i=u[r]:"ref"==r?o=u[r]:f[r]=u[r];if(arguments.length>2&&(f.children=arguments.length>3?n.call(arguments,2):t),"function"==typeof l&&null!=l.defaultProps)for(r in l.defaultProps)void 0===f[r]&&(f[r]=l.defaultProps[r]);return g(l,f,i,o,null)}function g(n,t,i,o,r){var f={type:n,props:t,key:i,ref:o,__k:null,__:null,__b:0,__e:null,__d:void 0,__c:null,constructor:void 0,__v:null==r?++u:r,__i:-1,__u:0};return null==r&&null!=l.vnode&&l.vnode(f),f}function m(){return{current:null}}function k(n){return n.children}function b(n,l){this.props=n,this.context=l}function x(n,l){if(null==l)return n.__?x(n.__,n.__i+1):null;for(var u;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e)return u.__e;return"function"==typeof n.type?x(n):null}function C(n){var l,u;if(null!=(n=n.__)&&null!=n.__c){for(n.__e=n.__c.base=null,l=0;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e){n.__e=n.__c.base=u.__e;break}return C(n)}}function M(n){(!n.__d&&(n.__d=!0)&&i.push(n)&&!P.__r++||o!==l.debounceRendering)&&((o=l.debounceRendering)||r)(P)}function P(){var n,u,t,o,r,e,c,s;for(i.sort(f);n=i.shift();)n.__d&&(u=i.length,o=void 0,e=(r=(t=n).__v).__e,c=[],s=[],t.__P&&((o=d({},r)).__v=r.__v+1,l.vnode&&l.vnode(o),O(t.__P,o,r,t.__n,t.__P.namespaceURI,32&r.__u?[e]:null,c,null==e?x(r):e,!!(32&r.__u),s),o.__v=r.__v,o.__.__k[o.__i]=o,j(c,o,s),o.__e!=e&&C(o)),i.length>u&&i.sort(f));P.__r=0}function S(n,l,u,t,i,o,r,f,e,c,s){var a,v,y,d,w,_=t&&t.__k||p,g=l.length;for(u.__d=e,$(u,l,_),e=u.__d,a=0;a<g;a++)null!=(y=u.__k[a])&&"boolean"!=typeof y&&"function"!=typeof y&&(v=-1===y.__i?h:_[y.__i]||h,y.__i=a,O(n,y,v,i,o,r,f,e,c,s),d=y.__e,y.ref&&v.ref!=y.ref&&(v.ref&&N(v.ref,null,y),s.push(y.ref,y.__c||d,y)),null==w&&null!=d&&(w=d),65536&y.__u||v.__k===y.__k?e=I(y,e,n):"function"==typeof y.type&&void 0!==y.__d?e=y.__d:d&&(e=d.nextSibling),y.__d=void 0,y.__u&=-196609);u.__d=e,u.__e=w}function $(n,l,u){var t,i,o,r,f,e=l.length,c=u.length,s=c,a=0;for(n.__k=[],t=0;t<e;t++)r=t+a,null!=(i=n.__k[t]=null==(i=l[t])||"boolean"==typeof i||"function"==typeof i?null:"string"==typeof i||"number"==typeof i||"bigint"==typeof i||i.constructor==String?g(null,i,null,null,null):y(i)?g(k,{children:i},null,null,null):void 0===i.constructor&&i.__b>0?g(i.type,i.props,i.key,i.ref?i.ref:null,i.__v):i)?(i.__=n,i.__b=n.__b+1,f=L(i,u,r,s),i.__i=f,o=null,-1!==f&&(s--,(o=u[f])&&(o.__u|=131072)),null==o||null===o.__v?(-1==f&&a--,"function"!=typeof i.type&&(i.__u|=65536)):f!==r&&(f==r-1?a=f-r:f==r+1?a++:f>r?s>e-r?a+=f-r:a--:f<r&&a++,f!==t+a&&(i.__u|=65536))):(o=u[r])&&null==o.key&&o.__e&&0==(131072&o.__u)&&(o.__e==n.__d&&(n.__d=x(o)),V(o,o,!1),u[r]=null,s--);if(s)for(t=0;t<c;t++)null!=(o=u[t])&&0==(131072&o.__u)&&(o.__e==n.__d&&(n.__d=x(o)),V(o,o))}function I(n,l,u){var t,i;if("function"==typeof n.type){for(t=n.__k,i=0;t&&i<t.length;i++)t[i]&&(t[i].__=n,l=I(t[i],l,u));return l}n.__e!=l&&(l&&n.type&&!u.contains(l)&&(l=x(n)),u.insertBefore(n.__e,l||null),l=n.__e);do{l=l&&l.nextSibling}while(null!=l&&8===l.nodeType);return l}function H(n,l){return l=l||[],null==n||"boolean"==typeof n||(y(n)?n.some(function(n){H(n,l)}):l.push(n)),l}function L(n,l,u,t){var i=n.key,o=n.type,r=u-1,f=u+1,e=l[u];if(null===e||e&&i==e.key&&o===e.type&&0==(131072&e.__u))return u;if(t>(null!=e&&0==(131072&e.__u)?1:0))for(;r>=0||f<l.length;){if(r>=0){if((e=l[r])&&0==(131072&e.__u)&&i==e.key&&o===e.type)return r;r--}if(f<l.length){if((e=l[f])&&0==(131072&e.__u)&&i==e.key&&o===e.type)return f;f++}}return-1}function T(n,l,u){"-"===l[0]?n.setProperty(l,null==u?"":u):n[l]=null==u?"":"number"!=typeof u||v.test(l)?u:u+"px"}function A(n,l,u,t,i){var o;n:if("style"===l)if("string"==typeof u)n.style.cssText=u;else{if("string"==typeof t&&(n.style.cssText=t=""),t)for(l in t)u&&l in u||T(n.style,l,"");if(u)for(l in u)t&&u[l]===t[l]||T(n.style,l,u[l])}else if("o"===l[0]&&"n"===l[1])o=l!==(l=l.replace(/(PointerCapture)$|Capture$/i,"$1")),l=l.toLowerCase()in n||"onFocusOut"===l||"onFocusIn"===l?l.toLowerCase().slice(2):l.slice(2),n.l||(n.l={}),n.l[l+o]=u,u?t?u.u=t.u:(u.u=e,n.addEventListener(l,o?s:c,o)):n.removeEventListener(l,o?s:c,o);else{if("http://www.w3.org/2000/svg"==i)l=l.replace(/xlink(H|:h)/,"h").replace(/sName$/,"s");else if("width"!=l&&"height"!=l&&"href"!=l&&"list"!=l&&"form"!=l&&"tabIndex"!=l&&"download"!=l&&"rowSpan"!=l&&"colSpan"!=l&&"role"!=l&&"popover"!=l&&l in n)try{n[l]=null==u?"":u;break n}catch(n){}"function"==typeof u||(null==u||!1===u&&"-"!==l[4]?n.removeAttribute(l):n.setAttribute(l,"popover"==l&&1==u?"":u))}}function F(n){return function(u){if(this.l){var t=this.l[u.type+n];if(null==u.t)u.t=e++;else if(u.t<t.u)return;return t(l.event?l.event(u):u)}}}function O(n,u,t,i,o,r,f,e,c,s){var a,h,p,v,w,_,g,m,x,C,M,P,$,I,H,L,T=u.type;if(void 0!==u.constructor)return null;128&t.__u&&(c=!!(32&t.__u),r=[e=u.__e=t.__e]),(a=l.__b)&&a(u);n:if("function"==typeof T)try{if(m=u.props,x="prototype"in T&&T.prototype.render,C=(a=T.contextType)&&i[a.__c],M=a?C?C.props.value:a.__:i,t.__c?g=(h=u.__c=t.__c).__=h.__E:(x?u.__c=h=new T(m,M):(u.__c=h=new b(m,M),h.constructor=T,h.render=q),C&&C.sub(h),h.props=m,h.state||(h.state={}),h.context=M,h.__n=i,p=h.__d=!0,h.__h=[],h._sb=[]),x&&null==h.__s&&(h.__s=h.state),x&&null!=T.getDerivedStateFromProps&&(h.__s==h.state&&(h.__s=d({},h.__s)),d(h.__s,T.getDerivedStateFromProps(m,h.__s))),v=h.props,w=h.state,h.__v=u,p)x&&null==T.getDerivedStateFromProps&&null!=h.componentWillMount&&h.componentWillMount(),x&&null!=h.componentDidMount&&h.__h.push(h.componentDidMount);else{if(x&&null==T.getDerivedStateFromProps&&m!==v&&null!=h.componentWillReceiveProps&&h.componentWillReceiveProps(m,M),!h.__e&&(null!=h.shouldComponentUpdate&&!1===h.shouldComponentUpdate(m,h.__s,M)||u.__v===t.__v)){for(u.__v!==t.__v&&(h.props=m,h.state=h.__s,h.__d=!1),u.__e=t.__e,u.__k=t.__k,u.__k.forEach(function(n){n&&(n.__=u)}),P=0;P<h._sb.length;P++)h.__h.push(h._sb[P]);h._sb=[],h.__h.length&&f.push(h);break n}null!=h.componentWillUpdate&&h.componentWillUpdate(m,h.__s,M),x&&null!=h.componentDidUpdate&&h.__h.push(function(){h.componentDidUpdate(v,w,_)})}if(h.context=M,h.props=m,h.__P=n,h.__e=!1,$=l.__r,I=0,x){for(h.state=h.__s,h.__d=!1,$&&$(u),a=h.render(h.props,h.state,h.context),H=0;H<h._sb.length;H++)h.__h.push(h._sb[H]);h._sb=[]}else do{h.__d=!1,$&&$(u),a=h.render(h.props,h.state,h.context),h.state=h.__s}while(h.__d&&++I<25);h.state=h.__s,null!=h.getChildContext&&(i=d(d({},i),h.getChildContext())),x&&!p&&null!=h.getSnapshotBeforeUpdate&&(_=h.getSnapshotBeforeUpdate(v,w)),S(n,y(L=null!=a&&a.type===k&&null==a.key?a.props.children:a)?L:[L],u,t,i,o,r,f,e,c,s),h.base=u.__e,u.__u&=-161,h.__h.length&&f.push(h),g&&(h.__E=h.__=null)}catch(n){if(u.__v=null,c||null!=r){for(u.__u|=c?160:32;e&&8===e.nodeType&&e.nextSibling;)e=e.nextSibling;r[r.indexOf(e)]=null,u.__e=e}else u.__e=t.__e,u.__k=t.__k;l.__e(n,u,t)}else null==r&&u.__v===t.__v?(u.__k=t.__k,u.__e=t.__e):u.__e=z(t.__e,u,t,i,o,r,f,c,s);(a=l.diffed)&&a(u)}function j(n,u,t){u.__d=void 0;for(var i=0;i<t.length;i++)N(t[i],t[++i],t[++i]);l.__c&&l.__c(u,n),n.some(function(u){try{n=u.__h,u.__h=[],n.some(function(n){n.call(u)})}catch(n){l.__e(n,u.__v)}})}function z(l,u,t,i,o,r,f,e,c){var s,a,p,v,d,_,g,m=t.props,k=u.props,b=u.type;if("svg"===b?o="http://www.w3.org/2000/svg":"math"===b?o="http://www.w3.org/1998/Math/MathML":o||(o="http://www.w3.org/1999/xhtml"),null!=r)for(s=0;s<r.length;s++)if((d=r[s])&&"setAttribute"in d==!!b&&(b?d.localName===b:3===d.nodeType)){l=d,r[s]=null;break}if(null==l){if(null===b)return document.createTextNode(k);l=document.createElementNS(o,b,k.is&&k),r=null,e=!1}if(null===b)m===k||e&&l.data===k||(l.data=k);else{if(r=r&&n.call(l.childNodes),m=t.props||h,!e&&null!=r)for(m={},s=0;s<l.attributes.length;s++)m[(d=l.attributes[s]).name]=d.value;for(s in m)if(d=m[s],"children"==s);else if("dangerouslySetInnerHTML"==s)p=d;else if("key"!==s&&!(s in k)){if("value"==s&&"defaultValue"in k||"checked"==s&&"defaultChecked"in k)continue;A(l,s,null,d,o)}for(s in k)d=k[s],"children"==s?v=d:"dangerouslySetInnerHTML"==s?a=d:"value"==s?_=d:"checked"==s?g=d:"key"===s||e&&"function"!=typeof d||m[s]===d||A(l,s,d,m[s],o);if(a)e||p&&(a.__html===p.__html||a.__html===l.innerHTML)||(l.innerHTML=a.__html),u.__k=[];else if(p&&(l.innerHTML=""),S(l,y(v)?v:[v],u,t,i,"foreignObject"===b?"http://www.w3.org/1999/xhtml":o,r,f,r?r[0]:t.__k&&x(t,0),e,c),null!=r)for(s=r.length;s--;)null!=r[s]&&w(r[s]);e||(s="value",void 0!==_&&(_!==l[s]||"progress"===b&&!_||"option"===b&&_!==m[s])&&A(l,s,_,m[s],o),s="checked",void 0!==g&&g!==l[s]&&A(l,s,g,m[s],o))}return l}function N(n,u,t){try{if("function"==typeof n){var i="function"==typeof n.__u;i&&n.__u(),i&&null==u||(n.__u=n(u))}else n.current=u}catch(n){l.__e(n,t)}}function V(n,u,t){var i,o;if(l.unmount&&l.unmount(n),(i=n.ref)&&(i.current&&i.current!==n.__e||N(i,null,u)),null!=(i=n.__c)){if(i.componentWillUnmount)try{i.componentWillUnmount()}catch(n){l.__e(n,u)}i.base=i.__P=null}if(i=n.__k)for(o=0;o<i.length;o++)i[o]&&V(i[o],u,t||"function"!=typeof n.type);t||null==n.__e||w(n.__e),n.__c=n.__=n.__e=n.__d=void 0}function q(n,l,u){return this.constructor(n,u)}function B(u,t,i){var o,r,f,e;l.__&&l.__(u,t),r=(o="function"==typeof i)?null:i&&i.__k||t.__k,f=[],e=[],O(t,u=(!o&&i||t).__k=_(k,null,[u]),r||h,h,t.namespaceURI,!o&&i?[i]:r?null:t.firstChild?n.call(t.childNodes):null,f,!o&&i?i:r?r.__e:t.firstChild,o,e),j(f,u,e)}function D(n,l){B(n,l,D)}function E(l,u,t){var i,o,r,f,e=d({},l.props);for(r in l.type&&l.type.defaultProps&&(f=l.type.defaultProps),u)"key"==r?i=u[r]:"ref"==r?o=u[r]:e[r]=void 0===u[r]&&void 0!==f?f[r]:u[r];return arguments.length>2&&(e.children=arguments.length>3?n.call(arguments,2):t),g(l.type,e,i||l.key,o||l.ref,null)}function G(n,l){var u={__c:l="__cC"+a++,__:n,Consumer:function(n,l){return n.children(l)},Provider:function(n){var u,t;return this.getChildContext||(u=[],(t={})[l]=this,this.getChildContext=function(){return t},this.componentWillUnmount=function(){u=null},this.shouldComponentUpdate=function(n){this.props.value!==n.value&&u.some(function(n){n.__e=!0,M(n)})},this.sub=function(n){u.push(n);var l=n.componentWillUnmount;n.componentWillUnmount=function(){u&&u.splice(u.indexOf(n),1),l&&l.call(n)}}),n.children}};return u.Provider.__=u.Consumer.contextType=u}n=p.slice,l={__e:function(n,l,u,t){for(var i,o,r;l=l.__;)if((i=l.__c)&&!i.__)try{if((o=i.constructor)&&null!=o.getDerivedStateFromError&&(i.setState(o.getDerivedStateFromError(n)),r=i.__d),null!=i.componentDidCatch&&(i.componentDidCatch(n,t||{}),r=i.__d),r)return i.__E=i}catch(l){n=l}throw n}},u=0,t=function(n){return null!=n&&null==n.constructor},b.prototype.setState=function(n,l){var u;u=null!=this.__s&&this.__s!==this.state?this.__s:this.__s=d({},this.state),"function"==typeof n&&(n=n(d({},u),this.props)),n&&d(u,n),null!=n&&this.__v&&(l&&this._sb.push(l),M(this))},b.prototype.forceUpdate=function(n){this.__v&&(this.__e=!0,n&&this.__h.push(n),M(this))},b.prototype.render=k,i=[],r="function"==typeof Promise?Promise.prototype.then.bind(Promise.resolve()):setTimeout,f=function(n,l){return n.__v.__b-l.__v.__b},P.__r=0,e=0,c=F(!1),s=F(!0),a=0;
//# sourceMappingURL=preact.module.js.map


/***/ }),

/***/ "./node_modules/preact/hooks/dist/hooks.module.js":
/*!********************************************************!*\
  !*** ./node_modules/preact/hooks/dist/hooks.module.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   useCallback: () => (/* binding */ q),
/* harmony export */   useContext: () => (/* binding */ x),
/* harmony export */   useDebugValue: () => (/* binding */ P),
/* harmony export */   useEffect: () => (/* binding */ y),
/* harmony export */   useErrorBoundary: () => (/* binding */ b),
/* harmony export */   useId: () => (/* binding */ g),
/* harmony export */   useImperativeHandle: () => (/* binding */ F),
/* harmony export */   useLayoutEffect: () => (/* binding */ _),
/* harmony export */   useMemo: () => (/* binding */ T),
/* harmony export */   useReducer: () => (/* binding */ p),
/* harmony export */   useRef: () => (/* binding */ A),
/* harmony export */   useState: () => (/* binding */ h)
/* harmony export */ });
/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.module.js");
var t,r,u,i,o=0,f=[],c=preact__WEBPACK_IMPORTED_MODULE_0__.options,e=c.__b,a=c.__r,v=c.diffed,l=c.__c,m=c.unmount,s=c.__;function d(n,t){c.__h&&c.__h(r,n,o||t),o=0;var u=r.__H||(r.__H={__:[],__h:[]});return n>=u.__.length&&u.__.push({}),u.__[n]}function h(n){return o=1,p(D,n)}function p(n,u,i){var o=d(t++,2);if(o.t=n,!o.__c&&(o.__=[i?i(u):D(void 0,u),function(n){var t=o.__N?o.__N[0]:o.__[0],r=o.t(t,n);t!==r&&(o.__N=[r,o.__[1]],o.__c.setState({}))}],o.__c=r,!r.u)){var f=function(n,t,r){if(!o.__c.__H)return!0;var u=o.__c.__H.__.filter(function(n){return!!n.__c});if(u.every(function(n){return!n.__N}))return!c||c.call(this,n,t,r);var i=!1;return u.forEach(function(n){if(n.__N){var t=n.__[0];n.__=n.__N,n.__N=void 0,t!==n.__[0]&&(i=!0)}}),!(!i&&o.__c.props===n)&&(!c||c.call(this,n,t,r))};r.u=!0;var c=r.shouldComponentUpdate,e=r.componentWillUpdate;r.componentWillUpdate=function(n,t,r){if(this.__e){var u=c;c=void 0,f(n,t,r),c=u}e&&e.call(this,n,t,r)},r.shouldComponentUpdate=f}return o.__N||o.__}function y(n,u){var i=d(t++,3);!c.__s&&C(i.__H,u)&&(i.__=n,i.i=u,r.__H.__h.push(i))}function _(n,u){var i=d(t++,4);!c.__s&&C(i.__H,u)&&(i.__=n,i.i=u,r.__h.push(i))}function A(n){return o=5,T(function(){return{current:n}},[])}function F(n,t,r){o=6,_(function(){return"function"==typeof n?(n(t()),function(){return n(null)}):n?(n.current=t(),function(){return n.current=null}):void 0},null==r?r:r.concat(n))}function T(n,r){var u=d(t++,7);return C(u.__H,r)&&(u.__=n(),u.__H=r,u.__h=n),u.__}function q(n,t){return o=8,T(function(){return n},t)}function x(n){var u=r.context[n.__c],i=d(t++,9);return i.c=n,u?(null==i.__&&(i.__=!0,u.sub(r)),u.props.value):n.__}function P(n,t){c.useDebugValue&&c.useDebugValue(t?t(n):n)}function b(n){var u=d(t++,10),i=h();return u.__=n,r.componentDidCatch||(r.componentDidCatch=function(n,t){u.__&&u.__(n,t),i[1](n)}),[i[0],function(){i[1](void 0)}]}function g(){var n=d(t++,11);if(!n.__){for(var u=r.__v;null!==u&&!u.__m&&null!==u.__;)u=u.__;var i=u.__m||(u.__m=[0,0]);n.__="P"+i[0]+"-"+i[1]++}return n.__}function j(){for(var n;n=f.shift();)if(n.__P&&n.__H)try{n.__H.__h.forEach(z),n.__H.__h.forEach(B),n.__H.__h=[]}catch(t){n.__H.__h=[],c.__e(t,n.__v)}}c.__b=function(n){r=null,e&&e(n)},c.__=function(n,t){n&&t.__k&&t.__k.__m&&(n.__m=t.__k.__m),s&&s(n,t)},c.__r=function(n){a&&a(n),t=0;var i=(r=n.__c).__H;i&&(u===r?(i.__h=[],r.__h=[],i.__.forEach(function(n){n.__N&&(n.__=n.__N),n.i=n.__N=void 0})):(i.__h.forEach(z),i.__h.forEach(B),i.__h=[],t=0)),u=r},c.diffed=function(n){v&&v(n);var t=n.__c;t&&t.__H&&(t.__H.__h.length&&(1!==f.push(t)&&i===c.requestAnimationFrame||((i=c.requestAnimationFrame)||w)(j)),t.__H.__.forEach(function(n){n.i&&(n.__H=n.i),n.i=void 0})),u=r=null},c.__c=function(n,t){t.some(function(n){try{n.__h.forEach(z),n.__h=n.__h.filter(function(n){return!n.__||B(n)})}catch(r){t.some(function(n){n.__h&&(n.__h=[])}),t=[],c.__e(r,n.__v)}}),l&&l(n,t)},c.unmount=function(n){m&&m(n);var t,r=n.__c;r&&r.__H&&(r.__H.__.forEach(function(n){try{z(n)}catch(n){t=n}}),r.__H=void 0,t&&c.__e(t,r.__v))};var k="function"==typeof requestAnimationFrame;function w(n){var t,r=function(){clearTimeout(u),k&&cancelAnimationFrame(t),setTimeout(n)},u=setTimeout(r,100);k&&(t=requestAnimationFrame(r))}function z(n){var t=r,u=n.__c;"function"==typeof u&&(n.__c=void 0,u()),r=t}function B(n){var t=r;n.__c=n.__(),r=t}function C(n,t){return!n||n.length!==t.length||t.some(function(t,r){return t!==n[r]})}function D(n,t){return"function"==typeof t?t(n):t}
//# sourceMappingURL=hooks.module.js.map


/***/ }),

/***/ "./node_modules/preact/jsx-runtime/dist/jsxRuntime.module.js":
/*!*******************************************************************!*\
  !*** ./node_modules/preact/jsx-runtime/dist/jsxRuntime.module.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Fragment: () => (/* reexport safe */ preact__WEBPACK_IMPORTED_MODULE_0__.Fragment),
/* harmony export */   jsx: () => (/* binding */ u),
/* harmony export */   jsxAttr: () => (/* binding */ l),
/* harmony export */   jsxDEV: () => (/* binding */ u),
/* harmony export */   jsxEscape: () => (/* binding */ _),
/* harmony export */   jsxTemplate: () => (/* binding */ a),
/* harmony export */   jsxs: () => (/* binding */ u)
/* harmony export */ });
/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.module.js");
var t=/["&<]/;function n(r){if(0===r.length||!1===t.test(r))return r;for(var e=0,n=0,o="",f="";n<r.length;n++){switch(r.charCodeAt(n)){case 34:f="&quot;";break;case 38:f="&amp;";break;case 60:f="&lt;";break;default:continue}n!==e&&(o+=r.slice(e,n)),o+=f,e=n+1}return n!==e&&(o+=r.slice(e,n)),o}var o=/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i,f=0,i=Array.isArray;function u(e,t,n,o,i,u){t||(t={});var a,c,p=t;if("ref"in p)for(c in p={},t)"ref"==c?a=t[c]:p[c]=t[c];var l={type:e,props:p,key:n,ref:a,__k:null,__:null,__b:0,__e:null,__d:void 0,__c:null,constructor:void 0,__v:--f,__i:-1,__u:0,__source:i,__self:u};if("function"==typeof e&&(a=e.defaultProps))for(c in a)void 0===p[c]&&(p[c]=a[c]);return preact__WEBPACK_IMPORTED_MODULE_0__.options.vnode&&preact__WEBPACK_IMPORTED_MODULE_0__.options.vnode(l),l}function a(r){var t=u(preact__WEBPACK_IMPORTED_MODULE_0__.Fragment,{tpl:r,exprs:[].slice.call(arguments,1)});return t.key=t.__v,t}var c={},p=/[A-Z]/g;function l(e,t){if(preact__WEBPACK_IMPORTED_MODULE_0__.options.attr){var f=preact__WEBPACK_IMPORTED_MODULE_0__.options.attr(e,t);if("string"==typeof f)return f}if("ref"===e||"key"===e)return"";if("style"===e&&"object"==typeof t){var i="";for(var u in t){var a=t[u];if(null!=a&&""!==a){var l="-"==u[0]?u:c[u]||(c[u]=u.replace(p,"-$&").toLowerCase()),_=";";"number"!=typeof a||l.startsWith("--")||o.test(l)||(_="px;"),i=i+l+":"+a+_}}return e+'="'+i+'"'}return null==t||!1===t||"function"==typeof t||"object"==typeof t?"":!0===t?e:e+'="'+n(t)+'"'}function _(r){if(null==r||"boolean"==typeof r||"function"==typeof r)return null;if("object"==typeof r){if(void 0===r.constructor)return r;if(i(r)){for(var e=0;e<r.length;e++)r[e]=_(r[e]);return r}}return n(""+r)}
//# sourceMappingURL=jsxRuntime.module.js.map


/***/ }),

/***/ "./app/static/pages/globals.css":
/*!**************************************!*\
  !*** ./app/static/pages/globals.css ***!
  \**************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_globals_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../../node_modules/css-loader/dist/cjs.js!../../../node_modules/postcss-loader/dist/cjs.js!./globals.css */ "./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js!./app/static/pages/globals.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());

      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
    
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_globals_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);


if (true) {
  if (!_node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_globals_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals || module.hot.invalidate) {
    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {
  if (!a && b || a && !b) {
    return false;
  }
  var p;
  for (p in a) {
    if (isNamedExport && p === "default") {
      // eslint-disable-next-line no-continue
      continue;
    }
    if (a[p] !== b[p]) {
      return false;
    }
  }
  for (p in b) {
    if (isNamedExport && p === "default") {
      // eslint-disable-next-line no-continue
      continue;
    }
    if (!a[p]) {
      return false;
    }
  }
  return true;
};
    var isNamedExport = !_node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_globals_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals;
    var oldLocals = isNamedExport ? _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_globals_css__WEBPACK_IMPORTED_MODULE_6__ : _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_globals_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals;

    module.hot.accept(
      /*! !!../../../node_modules/css-loader/dist/cjs.js!../../../node_modules/postcss-loader/dist/cjs.js!./globals.css */ "./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js!./app/static/pages/globals.css",
      __WEBPACK_OUTDATED_DEPENDENCIES__ => { /* harmony import */ _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_globals_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../../node_modules/css-loader/dist/cjs.js!../../../node_modules/postcss-loader/dist/cjs.js!./globals.css */ "./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js!./app/static/pages/globals.css");
(function () {
        if (!isEqualLocals(oldLocals, isNamedExport ? _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_globals_css__WEBPACK_IMPORTED_MODULE_6__ : _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_globals_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals, isNamedExport)) {
                module.hot.invalidate();

                return;
              }

              oldLocals = isNamedExport ? _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_globals_css__WEBPACK_IMPORTED_MODULE_6__ : _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_globals_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals;

              update(_node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_globals_css__WEBPACK_IMPORTED_MODULE_6__["default"]);
      })(__WEBPACK_OUTDATED_DEPENDENCIES__); }
    )
  }

  module.hot.dispose(function() {
    update();
  });
}



       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_globals_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_globals_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_globals_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./node_modules/@egjs/preact-flicking/dist/flicking.css":
/*!**************************************************************!*\
  !*** ./node_modules/@egjs/preact-flicking/dist/flicking.css ***!
  \**************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../../style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../../style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../../style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../../style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../../style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _css_loader_dist_cjs_js_postcss_loader_dist_cjs_js_flicking_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../../css-loader/dist/cjs.js!../../../postcss-loader/dist/cjs.js!./flicking.css */ "./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js!./node_modules/@egjs/preact-flicking/dist/flicking.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());

      options.insert = _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
    
options.domAPI = (_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_css_loader_dist_cjs_js_postcss_loader_dist_cjs_js_flicking_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);


if (true) {
  if (!_css_loader_dist_cjs_js_postcss_loader_dist_cjs_js_flicking_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals || module.hot.invalidate) {
    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {
  if (!a && b || a && !b) {
    return false;
  }
  var p;
  for (p in a) {
    if (isNamedExport && p === "default") {
      // eslint-disable-next-line no-continue
      continue;
    }
    if (a[p] !== b[p]) {
      return false;
    }
  }
  for (p in b) {
    if (isNamedExport && p === "default") {
      // eslint-disable-next-line no-continue
      continue;
    }
    if (!a[p]) {
      return false;
    }
  }
  return true;
};
    var isNamedExport = !_css_loader_dist_cjs_js_postcss_loader_dist_cjs_js_flicking_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals;
    var oldLocals = isNamedExport ? _css_loader_dist_cjs_js_postcss_loader_dist_cjs_js_flicking_css__WEBPACK_IMPORTED_MODULE_6__ : _css_loader_dist_cjs_js_postcss_loader_dist_cjs_js_flicking_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals;

    module.hot.accept(
      /*! !!../../../css-loader/dist/cjs.js!../../../postcss-loader/dist/cjs.js!./flicking.css */ "./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js!./node_modules/@egjs/preact-flicking/dist/flicking.css",
      __WEBPACK_OUTDATED_DEPENDENCIES__ => { /* harmony import */ _css_loader_dist_cjs_js_postcss_loader_dist_cjs_js_flicking_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../../css-loader/dist/cjs.js!../../../postcss-loader/dist/cjs.js!./flicking.css */ "./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js!./node_modules/@egjs/preact-flicking/dist/flicking.css");
(function () {
        if (!isEqualLocals(oldLocals, isNamedExport ? _css_loader_dist_cjs_js_postcss_loader_dist_cjs_js_flicking_css__WEBPACK_IMPORTED_MODULE_6__ : _css_loader_dist_cjs_js_postcss_loader_dist_cjs_js_flicking_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals, isNamedExport)) {
                module.hot.invalidate();

                return;
              }

              oldLocals = isNamedExport ? _css_loader_dist_cjs_js_postcss_loader_dist_cjs_js_flicking_css__WEBPACK_IMPORTED_MODULE_6__ : _css_loader_dist_cjs_js_postcss_loader_dist_cjs_js_flicking_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals;

              update(_css_loader_dist_cjs_js_postcss_loader_dist_cjs_js_flicking_css__WEBPACK_IMPORTED_MODULE_6__["default"]);
      })(__WEBPACK_OUTDATED_DEPENDENCIES__); }
    )
  }

  module.hot.dispose(function() {
    update();
  });
}



       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_css_loader_dist_cjs_js_postcss_loader_dist_cjs_js_flicking_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _css_loader_dist_cjs_js_postcss_loader_dist_cjs_js_flicking_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _css_loader_dist_cjs_js_postcss_loader_dist_cjs_js_flicking_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {



var stylesInDOM = [];
function getIndexByIdentifier(identifier) {
  var result = -1;
  for (var i = 0; i < stylesInDOM.length; i++) {
    if (stylesInDOM[i].identifier === identifier) {
      result = i;
      break;
    }
  }
  return result;
}
function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];
  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var indexByIdentifier = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3],
      supports: item[4],
      layer: item[5]
    };
    if (indexByIdentifier !== -1) {
      stylesInDOM[indexByIdentifier].references++;
      stylesInDOM[indexByIdentifier].updater(obj);
    } else {
      var updater = addElementStyle(obj, options);
      options.byIndex = i;
      stylesInDOM.splice(i, 0, {
        identifier: identifier,
        updater: updater,
        references: 1
      });
    }
    identifiers.push(identifier);
  }
  return identifiers;
}
function addElementStyle(obj, options) {
  var api = options.domAPI(options);
  api.update(obj);
  var updater = function updater(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {
        return;
      }
      api.update(obj = newObj);
    } else {
      api.remove();
    }
  };
  return updater;
}
module.exports = function (list, options) {
  options = options || {};
  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];
    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDOM[index].references--;
    }
    var newLastIdentifiers = modulesToDom(newList, options);
    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];
      var _index = getIndexByIdentifier(_identifier);
      if (stylesInDOM[_index].references === 0) {
        stylesInDOM[_index].updater();
        stylesInDOM.splice(_index, 1);
      }
    }
    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {



var memo = {};

/* istanbul ignore next  */
function getTarget(target) {
  if (typeof memo[target] === "undefined") {
    var styleTarget = document.querySelector(target);

    // Special case to return head of iframe instead of iframe itself
    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
      try {
        // This will throw an exception if access to iframe is blocked
        // due to cross-origin restrictions
        styleTarget = styleTarget.contentDocument.head;
      } catch (e) {
        // istanbul ignore next
        styleTarget = null;
      }
    }
    memo[target] = styleTarget;
  }
  return memo[target];
}

/* istanbul ignore next  */
function insertBySelector(insert, style) {
  var target = getTarget(insert);
  if (!target) {
    throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
  }
  target.appendChild(style);
}
module.exports = insertBySelector;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {



/* istanbul ignore next  */
function insertStyleElement(options) {
  var element = document.createElement("style");
  options.setAttributes(element, options.attributes);
  options.insert(element, options.options);
  return element;
}
module.exports = insertStyleElement;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



/* istanbul ignore next  */
function setAttributesWithoutAttributes(styleElement) {
  var nonce =  true ? __webpack_require__.nc : 0;
  if (nonce) {
    styleElement.setAttribute("nonce", nonce);
  }
}
module.exports = setAttributesWithoutAttributes;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {



/* istanbul ignore next  */
function apply(styleElement, options, obj) {
  var css = "";
  if (obj.supports) {
    css += "@supports (".concat(obj.supports, ") {");
  }
  if (obj.media) {
    css += "@media ".concat(obj.media, " {");
  }
  var needLayer = typeof obj.layer !== "undefined";
  if (needLayer) {
    css += "@layer".concat(obj.layer.length > 0 ? " ".concat(obj.layer) : "", " {");
  }
  css += obj.css;
  if (needLayer) {
    css += "}";
  }
  if (obj.media) {
    css += "}";
  }
  if (obj.supports) {
    css += "}";
  }
  var sourceMap = obj.sourceMap;
  if (sourceMap && typeof btoa !== "undefined") {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  }

  // For old IE
  /* istanbul ignore if  */
  options.styleTagTransform(css, styleElement, options.options);
}
function removeStyleElement(styleElement) {
  // istanbul ignore if
  if (styleElement.parentNode === null) {
    return false;
  }
  styleElement.parentNode.removeChild(styleElement);
}

/* istanbul ignore next  */
function domAPI(options) {
  if (typeof document === "undefined") {
    return {
      update: function update() {},
      remove: function remove() {}
    };
  }
  var styleElement = options.insertStyleElement(options);
  return {
    update: function update(obj) {
      apply(styleElement, options, obj);
    },
    remove: function remove() {
      removeStyleElement(styleElement);
    }
  };
}
module.exports = domAPI;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {



/* istanbul ignore next  */
function styleTagTransform(css, styleElement) {
  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css;
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild);
    }
    styleElement.appendChild(document.createTextNode(css));
  }
}
module.exports = styleTagTransform;

/***/ }),

/***/ "./app/static/pages/components/Block1.tsx":
/*!************************************************!*\
  !*** ./app/static/pages/components/Block1.tsx ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = Block1;
var jsx_runtime_1 = __webpack_require__(/*! preact/jsx-runtime */ "./node_modules/preact/jsx-runtime/dist/jsxRuntime.module.js");
var preact_router_1 = __webpack_require__(/*! preact-router */ "./node_modules/preact-router/dist/preact-router.mjs");
var image_hero_jpg_1 = __importDefault(__webpack_require__(/*! ../../assets/desktop/image-hero.jpg */ "./app/static/assets/desktop/image-hero.jpg"));
var image_hero_jpg_2 = __importDefault(__webpack_require__(/*! ../../assets/tablet/image-hero.jpg */ "./app/static/assets/tablet/image-hero.jpg"));
var image_hero_jpg_3 = __importDefault(__webpack_require__(/*! ../../assets/mobile/image-hero.jpg */ "./app/static/assets/mobile/image-hero.jpg"));
var items = {
    title: 'Branding & website design agency',
    description: 'We specialize in visual storytelling by creating cohesive brand and website design solutions for small businesses, giving lasting impressions to audiences in a digital world.',
    button: 'Learn More',
};
var linkItems = {
    title: 'Learn More',
    href: '#',
};
function Block1() {
    return ((0, jsx_runtime_1.jsxs)("div", { className: "relative flex h-[606px] w-full max-w-[calc(1275px+39px)] items-start justify-between self-end pl-[39px] xl:h-[800px]", children: [(0, jsx_runtime_1.jsxs)("div", { className: "relative z-[1] mt-[77px] flex w-full max-w-[730px] flex-col gap-[48px] xl:mt-[112px]", children: [(0, jsx_runtime_1.jsxs)("section", { className: "flex flex-col gap-[39px]", children: [(0, jsx_runtime_1.jsx)("h1", { className: "w-full max-w-[398px] xl:max-w-[680]", children: items.title }), (0, jsx_runtime_1.jsx)("p", { className: "w-full max-w-[398px] xl:max-w-[540px]", children: items.description })] }), (0, jsx_runtime_1.jsx)(preact_router_1.Link, { className: "flex h-[72px] w-[177px] items-center justify-center bg-[#F94F4F] text-[18px] font-extrabold text-white transition hover:bg-[#FF9393]", href: linkItems.href, children: linkItems.title })] }), (0, jsx_runtime_1.jsxs)("picture", { className: "absolute right-0 h-[608px] w-fit xl:h-[800px]", children: [(0, jsx_runtime_1.jsx)("source", { media: "(max-width: 640px)", srcSet: image_hero_jpg_3.default }), (0, jsx_runtime_1.jsx)("source", { media: "(max-width: 1024px)", srcSet: image_hero_jpg_2.default }), (0, jsx_runtime_1.jsx)("img", { className: "md:object-fit object-cover md:h-[606px] xl:h-[800px]", src: image_hero_jpg_1.default, alt: "men working on computers" })] })] }));
}


/***/ }),

/***/ "./app/static/pages/components/Block2.tsx":
/*!************************************************!*\
  !*** ./app/static/pages/components/Block2.tsx ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = Block2;
var jsx_runtime_1 = __webpack_require__(/*! preact/jsx-runtime */ "./node_modules/preact/jsx-runtime/dist/jsxRuntime.module.js");
var preact_router_1 = __webpack_require__(/*! preact-router */ "./node_modules/preact-router/dist/preact-router.mjs");
var image_strategic_jpg_1 = __importDefault(__webpack_require__(/*! ../../assets/desktop/image-strategic.jpg */ "./app/static/assets/desktop/image-strategic.jpg"));
var bg_pattern_wave_red_svg_1 = __importDefault(__webpack_require__(/*! ../../assets/desktop/bg-pattern-wave-red.svg */ "./app/static/assets/desktop/bg-pattern-wave-red.svg"));
var items = {
    title: 'Design is strategic.',
    description: '“A well-crafted design strategy consistently produces desired outcomes and brand awareness. We are firm believers that success lies in creative collaboration with our clients.”',
    linkTitle: 'Schedule a Call',
};
function Block2() {
    return ((0, jsx_runtime_1.jsxs)("div", { className: "relative flex h-[648px] w-full  justify-end lg:h-[750px] xl:h-[984px]", children: [(0, jsx_runtime_1.jsx)("img", { className: "absolute left-0 h-[658px] w-[735px] object-cover object-[100%_0%] xl:h-[984px] xl:object-center", height: 984, width: 735, src: image_strategic_jpg_1.default, alt: "strategic" }), (0, jsx_runtime_1.jsx)("div", { className: "relative flex h-[538px] w-[390px] items-center bg-[#191921] pl-[69px] pr-[40px] lg:h-[560px] lg:w-[530px] lg:pl-[90px] lg:pr-[60px] xl:h-[784px] xl:w-[705px] xl:pl-[154px] xl:pr-[106px]", children: (0, jsx_runtime_1.jsxs)("div", { className: "flex flex-col gap-[48px] ", children: [(0, jsx_runtime_1.jsx)("img", { className: "absolute left-[-31px] top-[220px] h-[28px] w-[62px] xl:left-[-67px] xl:top-[234px] xl:h-[61px] xl:w-[135px]", width: 135, height: 61, src: bg_pattern_wave_red_svg_1.default, alt: "pattern" }), (0, jsx_runtime_1.jsxs)("section", { className: "flex max-w-[281px] flex-col gap-[32px] lg:max-w-full xl:gap-[43px]", children: [(0, jsx_runtime_1.jsxs)("h2", { className: "max-w-[250px] text-white lg:max-w-full", children: [(0, jsx_runtime_1.jsx)("span", { className: "text-[#F94F4F]", children: items.title.split(' ')[0] }), " ".concat(items.title.split(' ').slice(1).join(' '))] }), (0, jsx_runtime_1.jsx)("p", { className: "text-white", children: items.description })] }), (0, jsx_runtime_1.jsx)(preact_router_1.Link, { className: "font-extrabold text-[#F94F4F] underline underline-offset-[12px] transition hover:text-[#FF9393]", href: "#", children: items.linkTitle })] }) })] }));
}


/***/ }),

/***/ "./app/static/pages/components/Block3.tsx":
/*!************************************************!*\
  !*** ./app/static/pages/components/Block3.tsx ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = Block3;
var jsx_runtime_1 = __webpack_require__(/*! preact/jsx-runtime */ "./node_modules/preact/jsx-runtime/dist/jsxRuntime.module.js");
var title = 'Our approach for creating a winning brand';
var items = [
    {
        title: 'Brand Strategy',
        description: 'Brand strategy is critical for long-term success. Outshining competitors and capturing the target audience are key.',
    },
    {
        title: 'Brand Design',
        description: 'Keeping the brand design unique and meaningful helps in communicating the brand’s timeless value effectively.',
    },
    {
        title: 'Web Design',
        description: 'A beautifully crafted website is the best tool for brand awareness, and ultimately results in increased revenues. ',
    },
];
function Block3() {
    return ((0, jsx_runtime_1.jsxs)("div", { className: "flex w-full justify-end pl-[39px]", children: [(0, jsx_runtime_1.jsx)("h2", { className: "z-[2] mr-[-160px] mt-[200px] h-fit w-full max-w-[281px] xl:max-w-[540px]", children: title }), (0, jsx_runtime_1.jsx)("div", { className: "z-[1] mt-[-120px] flex h-[1100px] items-center justify-end bg-[#F94F4F] pr-[106px] lg:mt-[-200px] lg:w-[600px] xl:w-[895px]", children: (0, jsx_runtime_1.jsx)("ul", { className: "flex flex-col gap-[56px]", children: items.map(function (item, index) { return ((0, jsx_runtime_1.jsxs)("li", { className: "flex h-[200px] w-[355px] flex-col gap-[24px] xl:w-[504px]", children: [(0, jsx_runtime_1.jsx)("span", { className: "absolute text-[80px] font-extrabold leading-[88px] text-white/25", children: (index + 1).toLocaleString('en-US', {
                                    minimumIntegerDigits: 2,
                                    useGrouping: false,
                                }) }), (0, jsx_runtime_1.jsxs)("section", { className: "ml-[59px] mt-[44px] flex flex-col gap-[24px]", children: [(0, jsx_runtime_1.jsx)("h3", { className: "text-white", children: item.title }), (0, jsx_runtime_1.jsx)("p", { className: "text-white", children: item.description })] })] }, item)); }) }) })] }));
}


/***/ }),

/***/ "./app/static/pages/components/Block4.tsx":
/*!************************************************!*\
  !*** ./app/static/pages/components/Block4.tsx ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = Block4;
var jsx_runtime_1 = __webpack_require__(/*! preact/jsx-runtime */ "./node_modules/preact/jsx-runtime/dist/jsxRuntime.module.js");
var image_slide_1_jpg_1 = __importDefault(__webpack_require__(/*! ../../assets/desktop/image-slide-1.jpg */ "./app/static/assets/desktop/image-slide-1.jpg"));
var image_slide_2_jpg_1 = __importDefault(__webpack_require__(/*! ../../assets/desktop/image-slide-2.jpg */ "./app/static/assets/desktop/image-slide-2.jpg"));
var image_slide_3_jpg_1 = __importDefault(__webpack_require__(/*! ../../assets/desktop/image-slide-3.jpg */ "./app/static/assets/desktop/image-slide-3.jpg"));
var bg_pattern_wavy_white_svg_1 = __importDefault(__webpack_require__(/*! ../../assets/desktop/bg-pattern-wavy-white.svg */ "./app/static/assets/desktop/bg-pattern-wavy-white.svg"));
var hooks_1 = __webpack_require__(/*! preact/hooks */ "./node_modules/preact/hooks/dist/hooks.module.js");
var preact_flicking_1 = __importDefault(__webpack_require__(/*! @egjs/preact-flicking */ "./node_modules/@egjs/preact-flicking/dist/flicking.esm.js"));
__webpack_require__(/*! @egjs/preact-flicking/dist/flicking.css */ "./node_modules/@egjs/preact-flicking/dist/flicking.css");
var TitleKey;
(function (TitleKey) {
    TitleKey[TitleKey["guidelines"] = 0] = "guidelines";
    TitleKey[TitleKey["merchandise"] = 1] = "merchandise";
    TitleKey[TitleKey["design"] = 2] = "design";
})(TitleKey || (TitleKey = {}));
var title = (_a = {},
    _a[TitleKey.guidelines] = {
        mainTitle: 'Brand naming & guidelines',
        title: 'Lean Product Roadmap',
        description: '2019 Project',
    },
    _a[TitleKey.merchandise] = {
        mainTitle: 'Brand identity & merchandise',
        title: 'New Majestic Hotel',
        description: '2018 Project',
    },
    _a[TitleKey.design] = {
        mainTitle: 'Brand identity & web design',
        title: 'Crypto Dashboard',
        description: '2016 Project',
    },
    _a);
var titlesButtons = {
    previous: 'previous slide',
    next: 'next slide',
};
function Block4() {
    var flicking = (0, hooks_1.useRef)();
    var _a = (0, hooks_1.useState)(TitleKey.guidelines), currentSlide = _a[0], setCurrentSlide = _a[1];
    var _b = (0, hooks_1.useState)(false), isPlaying = _b[0], setIsPlaying = _b[1];
    return ((0, jsx_runtime_1.jsxs)("div", { className: "relative flex min-h-[728px] w-full justify-start", children: [(0, jsx_runtime_1.jsxs)("div", { className: "relative z-[1] flex h-[528px] min-w-[735px] items-center bg-[#191921]", children: [(0, jsx_runtime_1.jsx)("img", { alt: "pattern", className: "absolute right-[-67px] top-[186px] z-[2]", src: bg_pattern_wavy_white_svg_1.default, width: 134, height: 60 }), (0, jsx_runtime_1.jsxs)("div", { className: "ml-[165px] flex h-[233px] w-[445px] flex-col gap-[51px]", children: [(0, jsx_runtime_1.jsx)("h2", { className: "text-white", children: title[currentSlide].mainTitle }), (0, jsx_runtime_1.jsxs)("div", { className: "flex gap-[16px]", children: [(0, jsx_runtime_1.jsx)("button", { disabled: isPlaying, onClick: function () {
                                            var _a;
                                            void ((_a = flicking.current) === null || _a === void 0 ? void 0 : _a.prev());
                                        }, title: "previous slide", type: "button", className: "previous relative z-40 size-[40px]", children: (0, jsx_runtime_1.jsxs)("svg", { width: "40", height: "40", xmlns: "http://www.w3.org/2000/svg", children: [(0, jsx_runtime_1.jsx)("title", { children: titlesButtons.previous }), (0, jsx_runtime_1.jsxs)("g", { transform: "matrix(-1 0 0 1 40 0)", fill: "none", fillRule: "evenodd", children: [(0, jsx_runtime_1.jsx)("circle", { cx: "20", cy: "20", r: "19.5" }), (0, jsx_runtime_1.jsx)("path", { strokeWidth: "2", d: "M17.5 15l5 5-5 5" })] })] }) }), (0, jsx_runtime_1.jsx)("button", { disabled: isPlaying, onClick: function () {
                                            var _a;
                                            void ((_a = flicking.current) === null || _a === void 0 ? void 0 : _a.next());
                                        }, title: "next slide", type: "button", className: "previous relative z-40 size-[40px]", children: (0, jsx_runtime_1.jsxs)("svg", { width: "40", height: "40", xmlns: "http://www.w3.org/2000/svg", children: [(0, jsx_runtime_1.jsx)("title", { children: titlesButtons.next }), (0, jsx_runtime_1.jsxs)("g", { fill: "none", fillRule: "evenodd", children: [(0, jsx_runtime_1.jsx)("circle", { cx: "20", cy: "20", r: "19.5" }), (0, jsx_runtime_1.jsx)("path", { strokeWidth: "2", d: "M17.5 15l5 5-5 5" })] })] }) })] })] })] }), (0, jsx_runtime_1.jsxs)("div", { className: "absolute right-0 z-0 h-[728px] w-[895px] ", children: [(0, jsx_runtime_1.jsxs)(preact_flicking_1.default, { onMoveStart: function () {
                            setIsPlaying(true);
                        }, onMoveEnd: function () {
                            setIsPlaying(false);
                        }, ref: flicking, circular: true, onChanged: function (e) {
                            setCurrentSlide(e.index);
                        }, children: [(0, jsx_runtime_1.jsx)("div", { className: "panel image-container hover:cursor-grab active:cursor-grabbing", children: (0, jsx_runtime_1.jsx)("img", { className: "pointer-events-none", src: image_slide_1_jpg_1.default, alt: "Slide 1" }) }, TitleKey.guidelines), (0, jsx_runtime_1.jsx)("div", { className: "panel image-container hover:cursor-grab active:cursor-grabbing", children: (0, jsx_runtime_1.jsx)("img", { className: "pointer-events-none", src: image_slide_2_jpg_1.default, alt: "Slide 2" }) }, TitleKey.merchandise), (0, jsx_runtime_1.jsx)("div", { className: "panel image-container hover:cursor-grab active:cursor-grabbing", children: (0, jsx_runtime_1.jsx)("img", { className: "pointer-events-none", src: image_slide_3_jpg_1.default, alt: "Slide 3" }) }, TitleKey.design)] }), (0, jsx_runtime_1.jsx)("div", { className: "absolute bottom-[68px] right-[154px] z-[1]", children: (0, jsx_runtime_1.jsxs)("section", { className: "flex flex-col text-end", children: [(0, jsx_runtime_1.jsx)("h3", { className: "text-white", children: title[currentSlide].title }), (0, jsx_runtime_1.jsx)("p", { className: "text-white", children: title[currentSlide].description })] }) })] })] }));
}


/***/ }),

/***/ "./app/static/pages/components/Footer.tsx":
/*!************************************************!*\
  !*** ./app/static/pages/components/Footer.tsx ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = Footer;
var jsx_runtime_1 = __webpack_require__(/*! preact/jsx-runtime */ "./node_modules/preact/jsx-runtime/dist/jsxRuntime.module.js");
var bg_pattern_wave_red_svg_1 = __importDefault(__webpack_require__(/*! ../../assets/desktop/bg-pattern-wave-red.svg */ "./app/static/assets/desktop/bg-pattern-wave-red.svg"));
var items = {
    title: 'Let’s build something great together.',
    buttonDescription: 'Schedule a Call',
};
function Footer() {
    return ((0, jsx_runtime_1.jsxs)("footer", { className: "mx-auto mb-[115px] ml-[-67px] mt-[120px] flex w-full max-w-[1342px] items-center", children: [(0, jsx_runtime_1.jsx)("img", { alt: "pattern", src: bg_pattern_wave_red_svg_1.default, width: 134, height: 60 }), (0, jsx_runtime_1.jsxs)("div", { className: "ml-[98px] flex w-full items-center justify-between", children: [(0, jsx_runtime_1.jsx)("h2", { className: "max-w-[635px]", children: items.title }), (0, jsx_runtime_1.jsx)("button", { type: "button", className: "h-[64px] w-[199px] bg-[#F94F4F] text-[16px] font-extrabold text-white transition hover:bg-[#FF9393]", children: items.buttonDescription })] })] }));
}


/***/ }),

/***/ "./app/static/pages/components/Navbar.tsx":
/*!************************************************!*\
  !*** ./app/static/pages/components/Navbar.tsx ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = Navbar;
var jsx_runtime_1 = __webpack_require__(/*! preact/jsx-runtime */ "./node_modules/preact/jsx-runtime/dist/jsxRuntime.module.js");
var logo_svg_1 = __importDefault(__webpack_require__(/*! ../../assets/desktop/logo.svg */ "./app/static/assets/desktop/logo.svg"));
var preact_router_1 = __webpack_require__(/*! preact-router */ "./node_modules/preact-router/dist/preact-router.mjs");
var items = [
    {
        title: 'About',
        href: '#',
    },
    {
        title: 'Service',
        href: '#',
    },
    {
        title: 'Projects',
        href: '#',
    },
];
var buttonTitle = 'Schedule a Call';
function Navbar() {
    return ((0, jsx_runtime_1.jsxs)("nav", { className: "z-[2] flex h-[64px] w-full max-w-[calc(1275px+39px)] items-center justify-between self-end overflow-x-clip pl-[39px] md:h-[178px]", children: [(0, jsx_runtime_1.jsx)("img", { src: logo_svg_1.default, alt: "logo" }), (0, jsx_runtime_1.jsxs)("div", { className: "flex size-full max-w-[438px] items-center gap-[28px] bg-[#F94F4F] pl-[33px] pr-[40px] lg:max-w-[530px] lg:gap-[50px] lg:pr-[20px] xl:max-w-[47vw] xl:gap-[48px] xl:pl-[69px] xl:pr-0 screen1500:max-w-[705px]", children: [(0, jsx_runtime_1.jsx)("ul", { className: "flex w-full max-w-[190px] justify-between xl:max-w-[225px]", children: items.map(function (item) { return ((0, jsx_runtime_1.jsx)("li", { children: (0, jsx_runtime_1.jsx)(preact_router_1.Link, { className: " leading-[32px] text-white transition-all hover:font-bold", href: item.href, children: item.title }) }, item.title)); }) }), (0, jsx_runtime_1.jsx)("button", { type: "button", className: "h-[64px] min-w-[147px] bg-[#191921] text-[16px] font-extrabold text-white transition hover:bg-[#434356] xl:min-w-[199px]", children: buttonTitle })] })] }));
}


/***/ }),

/***/ "./app/static/pages/layout.tsx":
/*!*************************************!*\
  !*** ./app/static/pages/layout.tsx ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var jsx_runtime_1 = __webpack_require__(/*! preact/jsx-runtime */ "./node_modules/preact/jsx-runtime/dist/jsxRuntime.module.js");
var preact_1 = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.module.js");
// import DataContext from './_lib/DataContext'; // placeholder
var Navbar_1 = __importDefault(__webpack_require__(/*! ./components/Navbar */ "./app/static/pages/components/Navbar.tsx"));
var page_1 = __importDefault(__webpack_require__(/*! ./page */ "./app/static/pages/page.tsx"));
var Footer_1 = __importDefault(__webpack_require__(/*! ./components/Footer */ "./app/static/pages/components/Footer.tsx"));
__webpack_require__(/*! ./globals.css */ "./app/static/pages/globals.css");
document.body.className =
    'min-h-dvh mx-auto md:min-h-screen max-w-[1440px] flex flex-col items-center font-commissioner justify-space-between';
function App() {
    return ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsx)(Navbar_1.default, {}), (0, jsx_runtime_1.jsx)("main", { className: "mx-auto mb-auto flex w-full flex-col items-center overflow-x-clip", children: (0, jsx_runtime_1.jsx)(page_1.default, {}) }), (0, jsx_runtime_1.jsx)(Footer_1.default, {})] }));
}
function Body() {
    return (0, jsx_runtime_1.jsx)(App, {});
}
(0, preact_1.render)((0, jsx_runtime_1.jsx)(Body, {}), document.body);


/***/ }),

/***/ "./app/static/pages/page.tsx":
/*!***********************************!*\
  !*** ./app/static/pages/page.tsx ***!
  \***********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var jsx_runtime_1 = __webpack_require__(/*! preact/jsx-runtime */ "./node_modules/preact/jsx-runtime/dist/jsxRuntime.module.js");
var Block1_1 = __importDefault(__webpack_require__(/*! ./components/Block1 */ "./app/static/pages/components/Block1.tsx"));
var Block2_1 = __importDefault(__webpack_require__(/*! ./components/Block2 */ "./app/static/pages/components/Block2.tsx"));
var Block3_1 = __importDefault(__webpack_require__(/*! ./components/Block3 */ "./app/static/pages/components/Block3.tsx"));
var Block4_1 = __importDefault(__webpack_require__(/*! ./components/Block4 */ "./app/static/pages/components/Block4.tsx"));
var Home = function () {
    return ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsx)(Block1_1.default, {}), (0, jsx_runtime_1.jsx)(Block2_1.default, {}), (0, jsx_runtime_1.jsx)(Block3_1.default, {}), (0, jsx_runtime_1.jsx)(Block4_1.default, {})] }));
};
exports["default"] = Home;


/***/ }),

/***/ "./app/static/assets/desktop/bg-pattern-wave-red.svg":
/*!***********************************************************!*\
  !*** ./app/static/assets/desktop/bg-pattern-wave-red.svg ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "images/8c3a13227cedc28ff49f.svg";

/***/ }),

/***/ "./app/static/assets/desktop/bg-pattern-wavy-white.svg":
/*!*************************************************************!*\
  !*** ./app/static/assets/desktop/bg-pattern-wavy-white.svg ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "images/549bc30aec22dc2bfd51.svg";

/***/ }),

/***/ "./app/static/assets/desktop/image-hero.jpg":
/*!**************************************************!*\
  !*** ./app/static/assets/desktop/image-hero.jpg ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "images/68589f1496e97e711702.jpg";

/***/ }),

/***/ "./app/static/assets/desktop/image-slide-1.jpg":
/*!*****************************************************!*\
  !*** ./app/static/assets/desktop/image-slide-1.jpg ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "images/61ea577f93a852703ca3.jpg";

/***/ }),

/***/ "./app/static/assets/desktop/image-slide-2.jpg":
/*!*****************************************************!*\
  !*** ./app/static/assets/desktop/image-slide-2.jpg ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "images/c02dc940dc3a5899ab81.jpg";

/***/ }),

/***/ "./app/static/assets/desktop/image-slide-3.jpg":
/*!*****************************************************!*\
  !*** ./app/static/assets/desktop/image-slide-3.jpg ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "images/e232c4ceebf129242018.jpg";

/***/ }),

/***/ "./app/static/assets/desktop/image-strategic.jpg":
/*!*******************************************************!*\
  !*** ./app/static/assets/desktop/image-strategic.jpg ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "images/1da0fbce3beeacea8ba8.jpg";

/***/ }),

/***/ "./app/static/assets/desktop/logo.svg":
/*!********************************************!*\
  !*** ./app/static/assets/desktop/logo.svg ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "images/bd6256eaed9209fe195a.svg";

/***/ }),

/***/ "./app/static/assets/mobile/image-hero.jpg":
/*!*************************************************!*\
  !*** ./app/static/assets/mobile/image-hero.jpg ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "images/71252dd8e56f810bab8b.jpg";

/***/ }),

/***/ "./app/static/assets/tablet/image-hero.jpg":
/*!*************************************************!*\
  !*** ./app/static/assets/tablet/image-hero.jpg ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "images/d854e8adff55c325467b.jpg";

/***/ }),

/***/ "./node_modules/preact-router/dist/preact-router.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/preact-router/dist/preact-router.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Link: () => (/* binding */ E),
/* harmony export */   Route: () => (/* binding */ L),
/* harmony export */   Router: () => (/* binding */ D),
/* harmony export */   "default": () => (/* binding */ D),
/* harmony export */   exec: () => (/* binding */ s),
/* harmony export */   getCurrentUrl: () => (/* binding */ R),
/* harmony export */   route: () => (/* binding */ $),
/* harmony export */   useRouter: () => (/* binding */ C)
/* harmony export */ });
/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.module.js");
/* harmony import */ var preact_hooks__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! preact/hooks */ "./node_modules/preact/hooks/dist/hooks.module.js");
var a={};function c(n,t){for(var r in t)n[r]=t[r];return n}function s(n,t,r){var i,o=/(?:\?([^#]*))?(#.*)?$/,e=n.match(o),u={};if(e&&e[1])for(var f=e[1].split("&"),c=0;c<f.length;c++){var s=f[c].split("=");u[decodeURIComponent(s[0])]=decodeURIComponent(s.slice(1).join("="))}n=d(n.replace(o,"")),t=d(t||"");for(var h=Math.max(n.length,t.length),v=0;v<h;v++)if(t[v]&&":"===t[v].charAt(0)){var l=t[v].replace(/(^:|[+*?]+$)/g,""),p=(t[v].match(/[+*?]+$/)||a)[0]||"",m=~p.indexOf("+"),y=~p.indexOf("*"),U=n[v]||"";if(!U&&!y&&(p.indexOf("?")<0||m)){i=!1;break}if(u[l]=decodeURIComponent(U),m||y){u[l]=n.slice(v).map(decodeURIComponent).join("/");break}}else if(t[v]!==n[v]){i=!1;break}return(!0===r.default||!1!==i)&&u}function h(n,t){return n.rank<t.rank?1:n.rank>t.rank?-1:n.index-t.index}function v(n,t){return n.index=t,n.rank=function(n){return n.props.default?0:d(n.props.path).map(l).join("")}(n),n.props}function d(n){return n.replace(/(^\/+|\/+$)/g,"").split("/")}function l(n){return":"==n.charAt(0)?1+"*+?".indexOf(n.charAt(n.length-1))||4:5}var p={},m=[],y=[],U=null,g={url:R()},k=(0,preact__WEBPACK_IMPORTED_MODULE_0__.createContext)(g);function C(){var n=(0,preact_hooks__WEBPACK_IMPORTED_MODULE_1__.useContext)(k);if(n===g){var t=(0,preact_hooks__WEBPACK_IMPORTED_MODULE_1__.useState)()[1];(0,preact_hooks__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function(){return y.push(t),function(){return y.splice(y.indexOf(t),1)}},[])}return[n,$]}function R(){var n;return""+((n=U&&U.location?U.location:U&&U.getCurrentLocation?U.getCurrentLocation():"undefined"!=typeof location?location:p).pathname||"")+(n.search||"")}function $(n,t){return void 0===t&&(t=!1),"string"!=typeof n&&n.url&&(t=n.replace,n=n.url),function(n){for(var t=m.length;t--;)if(m[t].canRoute(n))return!0;return!1}(n)&&function(n,t){void 0===t&&(t="push"),U&&U[t]?U[t](n):"undefined"!=typeof history&&history[t+"State"]&&history[t+"State"](null,null,n)}(n,t?"replace":"push"),I(n)}function I(n){for(var t=!1,r=0;r<m.length;r++)m[r].routeTo(n)&&(t=!0);return t}function M(n){if(n&&n.getAttribute){var t=n.getAttribute("href"),r=n.getAttribute("target");if(t&&t.match(/^\//g)&&(!r||r.match(/^_?self$/i)))return $(t)}}function b(n){return n.stopImmediatePropagation&&n.stopImmediatePropagation(),n.stopPropagation&&n.stopPropagation(),n.preventDefault(),!1}function W(n){if(!(n.ctrlKey||n.metaKey||n.altKey||n.shiftKey||n.button)){var t=n.target;do{if("a"===t.localName&&t.getAttribute("href")){if(t.hasAttribute("data-native")||t.hasAttribute("native"))return;if(M(t))return b(n)}}while(t=t.parentNode)}}var w=!1;function D(n){n.history&&(U=n.history),this.state={url:n.url||R()}}c(D.prototype=new preact__WEBPACK_IMPORTED_MODULE_0__.Component,{shouldComponentUpdate:function(n){return!0!==n.static||n.url!==this.props.url||n.onChange!==this.props.onChange},canRoute:function(n){var t=(0,preact__WEBPACK_IMPORTED_MODULE_0__.toChildArray)(this.props.children);return void 0!==this.g(t,n)},routeTo:function(n){this.setState({url:n});var t=this.canRoute(n);return this.p||this.forceUpdate(),t},componentWillMount:function(){this.p=!0},componentDidMount:function(){var n=this;w||(w=!0,U||addEventListener("popstate",function(){I(R())}),addEventListener("click",W)),m.push(this),U&&(this.u=U.listen(function(t){var r=t.location||t;n.routeTo(""+(r.pathname||"")+(r.search||""))})),this.p=!1},componentWillUnmount:function(){"function"==typeof this.u&&this.u(),m.splice(m.indexOf(this),1)},componentWillUpdate:function(){this.p=!0},componentDidUpdate:function(){this.p=!1},g:function(n,t){n=n.filter(v).sort(h);for(var r=0;r<n.length;r++){var i=n[r],o=s(t,i.props.path,i.props);if(o)return[i,o]}},render:function(n,t){var e,u,f=n.onChange,a=t.url,s=this.c,h=this.g((0,preact__WEBPACK_IMPORTED_MODULE_0__.toChildArray)(n.children),a);if(h&&(u=(0,preact__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(h[0],c(c({url:a,matches:e=h[1]},e),{key:void 0,ref:void 0}))),a!==(s&&s.url)){c(g,s=this.c={url:a,previous:s&&s.url,current:u,path:u?u.props.path:null,matches:e}),s.router=this,s.active=u?[u]:[];for(var v=y.length;v--;)y[v]({});"function"==typeof f&&f(s)}return (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(k.Provider,{value:s},u)}});var E=function(n){return (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)("a",c({onClick:W},n))},L=function(n){return (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(n.component,n)};
//# sourceMappingURL=preact-router.module.js.map


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			if (cachedModule.error !== undefined) throw cachedModule.error;
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		try {
/******/ 			var execOptions = { id: moduleId, module: module, factory: __webpack_modules__[moduleId], require: __webpack_require__ };
/******/ 			__webpack_require__.i.forEach(function(handler) { handler(execOptions); });
/******/ 			module = execOptions.module;
/******/ 			execOptions.factory.call(module.exports, module, module.exports, execOptions.require);
/******/ 		} catch(e) {
/******/ 			module.error = e;
/******/ 			throw e;
/******/ 		}
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = __webpack_module_cache__;
/******/ 	
/******/ 	// expose the module execution interceptor
/******/ 	__webpack_require__.i = [];
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript update chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference all chunks
/******/ 		__webpack_require__.hu = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + "." + __webpack_require__.h() + ".hot-update.js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get update manifest filename */
/******/ 	(() => {
/******/ 		__webpack_require__.hmrF = () => ("main." + __webpack_require__.h() + ".hot-update.json");
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/getFullHash */
/******/ 	(() => {
/******/ 		__webpack_require__.h = () => ("5c3c49663acab6ce01f0")
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/load script */
/******/ 	(() => {
/******/ 		var inProgress = {};
/******/ 		var dataWebpackPrefix = "flask-preact-typescript-tailwind-template:";
/******/ 		// loadScript function to load a script via script tag
/******/ 		__webpack_require__.l = (url, done, key, chunkId) => {
/******/ 			if(inProgress[url]) { inProgress[url].push(done); return; }
/******/ 			var script, needAttach;
/******/ 			if(key !== undefined) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				for(var i = 0; i < scripts.length; i++) {
/******/ 					var s = scripts[i];
/******/ 					if(s.getAttribute("src") == url || s.getAttribute("data-webpack") == dataWebpackPrefix + key) { script = s; break; }
/******/ 				}
/******/ 			}
/******/ 			if(!script) {
/******/ 				needAttach = true;
/******/ 				script = document.createElement('script');
/******/ 		
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.setAttribute("data-webpack", dataWebpackPrefix + key);
/******/ 		
/******/ 				script.src = url;
/******/ 			}
/******/ 			inProgress[url] = [done];
/******/ 			var onScriptComplete = (prev, event) => {
/******/ 				// avoid mem leaks in IE.
/******/ 				script.onerror = script.onload = null;
/******/ 				clearTimeout(timeout);
/******/ 				var doneFns = inProgress[url];
/******/ 				delete inProgress[url];
/******/ 				script.parentNode && script.parentNode.removeChild(script);
/******/ 				doneFns && doneFns.forEach((fn) => (fn(event)));
/******/ 				if(prev) return prev(event);
/******/ 			}
/******/ 			var timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);
/******/ 			script.onerror = onScriptComplete.bind(null, script.onerror);
/******/ 			script.onload = onScriptComplete.bind(null, script.onload);
/******/ 			needAttach && document.head.appendChild(script);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hot module replacement */
/******/ 	(() => {
/******/ 		var currentModuleData = {};
/******/ 		var installedModules = __webpack_require__.c;
/******/ 		
/******/ 		// module and require creation
/******/ 		var currentChildModule;
/******/ 		var currentParents = [];
/******/ 		
/******/ 		// status
/******/ 		var registeredStatusHandlers = [];
/******/ 		var currentStatus = "idle";
/******/ 		
/******/ 		// while downloading
/******/ 		var blockingPromises = 0;
/******/ 		var blockingPromisesWaiting = [];
/******/ 		
/******/ 		// The update info
/******/ 		var currentUpdateApplyHandlers;
/******/ 		var queuedInvalidatedModules;
/******/ 		
/******/ 		__webpack_require__.hmrD = currentModuleData;
/******/ 		
/******/ 		__webpack_require__.i.push(function (options) {
/******/ 			var module = options.module;
/******/ 			var require = createRequire(options.require, options.id);
/******/ 			module.hot = createModuleHotObject(options.id, module);
/******/ 			module.parents = currentParents;
/******/ 			module.children = [];
/******/ 			currentParents = [];
/******/ 			options.require = require;
/******/ 		});
/******/ 		
/******/ 		__webpack_require__.hmrC = {};
/******/ 		__webpack_require__.hmrI = {};
/******/ 		
/******/ 		function createRequire(require, moduleId) {
/******/ 			var me = installedModules[moduleId];
/******/ 			if (!me) return require;
/******/ 			var fn = function (request) {
/******/ 				if (me.hot.active) {
/******/ 					if (installedModules[request]) {
/******/ 						var parents = installedModules[request].parents;
/******/ 						if (parents.indexOf(moduleId) === -1) {
/******/ 							parents.push(moduleId);
/******/ 						}
/******/ 					} else {
/******/ 						currentParents = [moduleId];
/******/ 						currentChildModule = request;
/******/ 					}
/******/ 					if (me.children.indexOf(request) === -1) {
/******/ 						me.children.push(request);
/******/ 					}
/******/ 				} else {
/******/ 					console.warn(
/******/ 						"[HMR] unexpected require(" +
/******/ 							request +
/******/ 							") from disposed module " +
/******/ 							moduleId
/******/ 					);
/******/ 					currentParents = [];
/******/ 				}
/******/ 				return require(request);
/******/ 			};
/******/ 			var createPropertyDescriptor = function (name) {
/******/ 				return {
/******/ 					configurable: true,
/******/ 					enumerable: true,
/******/ 					get: function () {
/******/ 						return require[name];
/******/ 					},
/******/ 					set: function (value) {
/******/ 						require[name] = value;
/******/ 					}
/******/ 				};
/******/ 			};
/******/ 			for (var name in require) {
/******/ 				if (Object.prototype.hasOwnProperty.call(require, name) && name !== "e") {
/******/ 					Object.defineProperty(fn, name, createPropertyDescriptor(name));
/******/ 				}
/******/ 			}
/******/ 			fn.e = function (chunkId, fetchPriority) {
/******/ 				return trackBlockingPromise(require.e(chunkId, fetchPriority));
/******/ 			};
/******/ 			return fn;
/******/ 		}
/******/ 		
/******/ 		function createModuleHotObject(moduleId, me) {
/******/ 			var _main = currentChildModule !== moduleId;
/******/ 			var hot = {
/******/ 				// private stuff
/******/ 				_acceptedDependencies: {},
/******/ 				_acceptedErrorHandlers: {},
/******/ 				_declinedDependencies: {},
/******/ 				_selfAccepted: false,
/******/ 				_selfDeclined: false,
/******/ 				_selfInvalidated: false,
/******/ 				_disposeHandlers: [],
/******/ 				_main: _main,
/******/ 				_requireSelf: function () {
/******/ 					currentParents = me.parents.slice();
/******/ 					currentChildModule = _main ? undefined : moduleId;
/******/ 					__webpack_require__(moduleId);
/******/ 				},
/******/ 		
/******/ 				// Module API
/******/ 				active: true,
/******/ 				accept: function (dep, callback, errorHandler) {
/******/ 					if (dep === undefined) hot._selfAccepted = true;
/******/ 					else if (typeof dep === "function") hot._selfAccepted = dep;
/******/ 					else if (typeof dep === "object" && dep !== null) {
/******/ 						for (var i = 0; i < dep.length; i++) {
/******/ 							hot._acceptedDependencies[dep[i]] = callback || function () {};
/******/ 							hot._acceptedErrorHandlers[dep[i]] = errorHandler;
/******/ 						}
/******/ 					} else {
/******/ 						hot._acceptedDependencies[dep] = callback || function () {};
/******/ 						hot._acceptedErrorHandlers[dep] = errorHandler;
/******/ 					}
/******/ 				},
/******/ 				decline: function (dep) {
/******/ 					if (dep === undefined) hot._selfDeclined = true;
/******/ 					else if (typeof dep === "object" && dep !== null)
/******/ 						for (var i = 0; i < dep.length; i++)
/******/ 							hot._declinedDependencies[dep[i]] = true;
/******/ 					else hot._declinedDependencies[dep] = true;
/******/ 				},
/******/ 				dispose: function (callback) {
/******/ 					hot._disposeHandlers.push(callback);
/******/ 				},
/******/ 				addDisposeHandler: function (callback) {
/******/ 					hot._disposeHandlers.push(callback);
/******/ 				},
/******/ 				removeDisposeHandler: function (callback) {
/******/ 					var idx = hot._disposeHandlers.indexOf(callback);
/******/ 					if (idx >= 0) hot._disposeHandlers.splice(idx, 1);
/******/ 				},
/******/ 				invalidate: function () {
/******/ 					this._selfInvalidated = true;
/******/ 					switch (currentStatus) {
/******/ 						case "idle":
/******/ 							currentUpdateApplyHandlers = [];
/******/ 							Object.keys(__webpack_require__.hmrI).forEach(function (key) {
/******/ 								__webpack_require__.hmrI[key](
/******/ 									moduleId,
/******/ 									currentUpdateApplyHandlers
/******/ 								);
/******/ 							});
/******/ 							setStatus("ready");
/******/ 							break;
/******/ 						case "ready":
/******/ 							Object.keys(__webpack_require__.hmrI).forEach(function (key) {
/******/ 								__webpack_require__.hmrI[key](
/******/ 									moduleId,
/******/ 									currentUpdateApplyHandlers
/******/ 								);
/******/ 							});
/******/ 							break;
/******/ 						case "prepare":
/******/ 						case "check":
/******/ 						case "dispose":
/******/ 						case "apply":
/******/ 							(queuedInvalidatedModules = queuedInvalidatedModules || []).push(
/******/ 								moduleId
/******/ 							);
/******/ 							break;
/******/ 						default:
/******/ 							// ignore requests in error states
/******/ 							break;
/******/ 					}
/******/ 				},
/******/ 		
/******/ 				// Management API
/******/ 				check: hotCheck,
/******/ 				apply: hotApply,
/******/ 				status: function (l) {
/******/ 					if (!l) return currentStatus;
/******/ 					registeredStatusHandlers.push(l);
/******/ 				},
/******/ 				addStatusHandler: function (l) {
/******/ 					registeredStatusHandlers.push(l);
/******/ 				},
/******/ 				removeStatusHandler: function (l) {
/******/ 					var idx = registeredStatusHandlers.indexOf(l);
/******/ 					if (idx >= 0) registeredStatusHandlers.splice(idx, 1);
/******/ 				},
/******/ 		
/******/ 				//inherit from previous dispose call
/******/ 				data: currentModuleData[moduleId]
/******/ 			};
/******/ 			currentChildModule = undefined;
/******/ 			return hot;
/******/ 		}
/******/ 		
/******/ 		function setStatus(newStatus) {
/******/ 			currentStatus = newStatus;
/******/ 			var results = [];
/******/ 		
/******/ 			for (var i = 0; i < registeredStatusHandlers.length; i++)
/******/ 				results[i] = registeredStatusHandlers[i].call(null, newStatus);
/******/ 		
/******/ 			return Promise.all(results).then(function () {});
/******/ 		}
/******/ 		
/******/ 		function unblock() {
/******/ 			if (--blockingPromises === 0) {
/******/ 				setStatus("ready").then(function () {
/******/ 					if (blockingPromises === 0) {
/******/ 						var list = blockingPromisesWaiting;
/******/ 						blockingPromisesWaiting = [];
/******/ 						for (var i = 0; i < list.length; i++) {
/******/ 							list[i]();
/******/ 						}
/******/ 					}
/******/ 				});
/******/ 			}
/******/ 		}
/******/ 		
/******/ 		function trackBlockingPromise(promise) {
/******/ 			switch (currentStatus) {
/******/ 				case "ready":
/******/ 					setStatus("prepare");
/******/ 				/* fallthrough */
/******/ 				case "prepare":
/******/ 					blockingPromises++;
/******/ 					promise.then(unblock, unblock);
/******/ 					return promise;
/******/ 				default:
/******/ 					return promise;
/******/ 			}
/******/ 		}
/******/ 		
/******/ 		function waitForBlockingPromises(fn) {
/******/ 			if (blockingPromises === 0) return fn();
/******/ 			return new Promise(function (resolve) {
/******/ 				blockingPromisesWaiting.push(function () {
/******/ 					resolve(fn());
/******/ 				});
/******/ 			});
/******/ 		}
/******/ 		
/******/ 		function hotCheck(applyOnUpdate) {
/******/ 			if (currentStatus !== "idle") {
/******/ 				throw new Error("check() is only allowed in idle status");
/******/ 			}
/******/ 			return setStatus("check")
/******/ 				.then(__webpack_require__.hmrM)
/******/ 				.then(function (update) {
/******/ 					if (!update) {
/******/ 						return setStatus(applyInvalidatedModules() ? "ready" : "idle").then(
/******/ 							function () {
/******/ 								return null;
/******/ 							}
/******/ 						);
/******/ 					}
/******/ 		
/******/ 					return setStatus("prepare").then(function () {
/******/ 						var updatedModules = [];
/******/ 						currentUpdateApplyHandlers = [];
/******/ 		
/******/ 						return Promise.all(
/******/ 							Object.keys(__webpack_require__.hmrC).reduce(function (
/******/ 								promises,
/******/ 								key
/******/ 							) {
/******/ 								__webpack_require__.hmrC[key](
/******/ 									update.c,
/******/ 									update.r,
/******/ 									update.m,
/******/ 									promises,
/******/ 									currentUpdateApplyHandlers,
/******/ 									updatedModules
/******/ 								);
/******/ 								return promises;
/******/ 							}, [])
/******/ 						).then(function () {
/******/ 							return waitForBlockingPromises(function () {
/******/ 								if (applyOnUpdate) {
/******/ 									return internalApply(applyOnUpdate);
/******/ 								} else {
/******/ 									return setStatus("ready").then(function () {
/******/ 										return updatedModules;
/******/ 									});
/******/ 								}
/******/ 							});
/******/ 						});
/******/ 					});
/******/ 				});
/******/ 		}
/******/ 		
/******/ 		function hotApply(options) {
/******/ 			if (currentStatus !== "ready") {
/******/ 				return Promise.resolve().then(function () {
/******/ 					throw new Error(
/******/ 						"apply() is only allowed in ready status (state: " +
/******/ 							currentStatus +
/******/ 							")"
/******/ 					);
/******/ 				});
/******/ 			}
/******/ 			return internalApply(options);
/******/ 		}
/******/ 		
/******/ 		function internalApply(options) {
/******/ 			options = options || {};
/******/ 		
/******/ 			applyInvalidatedModules();
/******/ 		
/******/ 			var results = currentUpdateApplyHandlers.map(function (handler) {
/******/ 				return handler(options);
/******/ 			});
/******/ 			currentUpdateApplyHandlers = undefined;
/******/ 		
/******/ 			var errors = results
/******/ 				.map(function (r) {
/******/ 					return r.error;
/******/ 				})
/******/ 				.filter(Boolean);
/******/ 		
/******/ 			if (errors.length > 0) {
/******/ 				return setStatus("abort").then(function () {
/******/ 					throw errors[0];
/******/ 				});
/******/ 			}
/******/ 		
/******/ 			// Now in "dispose" phase
/******/ 			var disposePromise = setStatus("dispose");
/******/ 		
/******/ 			results.forEach(function (result) {
/******/ 				if (result.dispose) result.dispose();
/******/ 			});
/******/ 		
/******/ 			// Now in "apply" phase
/******/ 			var applyPromise = setStatus("apply");
/******/ 		
/******/ 			var error;
/******/ 			var reportError = function (err) {
/******/ 				if (!error) error = err;
/******/ 			};
/******/ 		
/******/ 			var outdatedModules = [];
/******/ 			results.forEach(function (result) {
/******/ 				if (result.apply) {
/******/ 					var modules = result.apply(reportError);
/******/ 					if (modules) {
/******/ 						for (var i = 0; i < modules.length; i++) {
/******/ 							outdatedModules.push(modules[i]);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 			});
/******/ 		
/******/ 			return Promise.all([disposePromise, applyPromise]).then(function () {
/******/ 				// handle errors in accept handlers and self accepted module load
/******/ 				if (error) {
/******/ 					return setStatus("fail").then(function () {
/******/ 						throw error;
/******/ 					});
/******/ 				}
/******/ 		
/******/ 				if (queuedInvalidatedModules) {
/******/ 					return internalApply(options).then(function (list) {
/******/ 						outdatedModules.forEach(function (moduleId) {
/******/ 							if (list.indexOf(moduleId) < 0) list.push(moduleId);
/******/ 						});
/******/ 						return list;
/******/ 					});
/******/ 				}
/******/ 		
/******/ 				return setStatus("idle").then(function () {
/******/ 					return outdatedModules;
/******/ 				});
/******/ 			});
/******/ 		}
/******/ 		
/******/ 		function applyInvalidatedModules() {
/******/ 			if (queuedInvalidatedModules) {
/******/ 				if (!currentUpdateApplyHandlers) currentUpdateApplyHandlers = [];
/******/ 				Object.keys(__webpack_require__.hmrI).forEach(function (key) {
/******/ 					queuedInvalidatedModules.forEach(function (moduleId) {
/******/ 						__webpack_require__.hmrI[key](
/******/ 							moduleId,
/******/ 							currentUpdateApplyHandlers
/******/ 						);
/******/ 					});
/******/ 				});
/******/ 				queuedInvalidatedModules = undefined;
/******/ 				return true;
/******/ 			}
/******/ 		}
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src;
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) {
/******/ 					var i = scripts.length - 1;
/******/ 					while (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = __webpack_require__.hmrS_jsonp = __webpack_require__.hmrS_jsonp || {
/******/ 			"main": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		var currentUpdatedModulesList;
/******/ 		var waitingUpdateResolves = {};
/******/ 		function loadUpdateChunk(chunkId, updatedModulesList) {
/******/ 			currentUpdatedModulesList = updatedModulesList;
/******/ 			return new Promise((resolve, reject) => {
/******/ 				waitingUpdateResolves[chunkId] = resolve;
/******/ 				// start update chunk loading
/******/ 				var url = __webpack_require__.p + __webpack_require__.hu(chunkId);
/******/ 				// create error before stack unwound to get useful stacktrace later
/******/ 				var error = new Error();
/******/ 				var loadingEnded = (event) => {
/******/ 					if(waitingUpdateResolves[chunkId]) {
/******/ 						waitingUpdateResolves[chunkId] = undefined
/******/ 						var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 						var realSrc = event && event.target && event.target.src;
/******/ 						error.message = 'Loading hot update chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 						error.name = 'ChunkLoadError';
/******/ 						error.type = errorType;
/******/ 						error.request = realSrc;
/******/ 						reject(error);
/******/ 					}
/******/ 				};
/******/ 				__webpack_require__.l(url, loadingEnded);
/******/ 			});
/******/ 		}
/******/ 		
/******/ 		self["webpackHotUpdateflask_preact_typescript_tailwind_template"] = (chunkId, moreModules, runtime) => {
/******/ 			for(var moduleId in moreModules) {
/******/ 				if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 					currentUpdate[moduleId] = moreModules[moduleId];
/******/ 					if(currentUpdatedModulesList) currentUpdatedModulesList.push(moduleId);
/******/ 				}
/******/ 			}
/******/ 			if(runtime) currentUpdateRuntime.push(runtime);
/******/ 			if(waitingUpdateResolves[chunkId]) {
/******/ 				waitingUpdateResolves[chunkId]();
/******/ 				waitingUpdateResolves[chunkId] = undefined;
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		var currentUpdateChunks;
/******/ 		var currentUpdate;
/******/ 		var currentUpdateRemovedChunks;
/******/ 		var currentUpdateRuntime;
/******/ 		function applyHandler(options) {
/******/ 			if (__webpack_require__.f) delete __webpack_require__.f.jsonpHmr;
/******/ 			currentUpdateChunks = undefined;
/******/ 			function getAffectedModuleEffects(updateModuleId) {
/******/ 				var outdatedModules = [updateModuleId];
/******/ 				var outdatedDependencies = {};
/******/ 		
/******/ 				var queue = outdatedModules.map(function (id) {
/******/ 					return {
/******/ 						chain: [id],
/******/ 						id: id
/******/ 					};
/******/ 				});
/******/ 				while (queue.length > 0) {
/******/ 					var queueItem = queue.pop();
/******/ 					var moduleId = queueItem.id;
/******/ 					var chain = queueItem.chain;
/******/ 					var module = __webpack_require__.c[moduleId];
/******/ 					if (
/******/ 						!module ||
/******/ 						(module.hot._selfAccepted && !module.hot._selfInvalidated)
/******/ 					)
/******/ 						continue;
/******/ 					if (module.hot._selfDeclined) {
/******/ 						return {
/******/ 							type: "self-declined",
/******/ 							chain: chain,
/******/ 							moduleId: moduleId
/******/ 						};
/******/ 					}
/******/ 					if (module.hot._main) {
/******/ 						return {
/******/ 							type: "unaccepted",
/******/ 							chain: chain,
/******/ 							moduleId: moduleId
/******/ 						};
/******/ 					}
/******/ 					for (var i = 0; i < module.parents.length; i++) {
/******/ 						var parentId = module.parents[i];
/******/ 						var parent = __webpack_require__.c[parentId];
/******/ 						if (!parent) continue;
/******/ 						if (parent.hot._declinedDependencies[moduleId]) {
/******/ 							return {
/******/ 								type: "declined",
/******/ 								chain: chain.concat([parentId]),
/******/ 								moduleId: moduleId,
/******/ 								parentId: parentId
/******/ 							};
/******/ 						}
/******/ 						if (outdatedModules.indexOf(parentId) !== -1) continue;
/******/ 						if (parent.hot._acceptedDependencies[moduleId]) {
/******/ 							if (!outdatedDependencies[parentId])
/******/ 								outdatedDependencies[parentId] = [];
/******/ 							addAllToSet(outdatedDependencies[parentId], [moduleId]);
/******/ 							continue;
/******/ 						}
/******/ 						delete outdatedDependencies[parentId];
/******/ 						outdatedModules.push(parentId);
/******/ 						queue.push({
/******/ 							chain: chain.concat([parentId]),
/******/ 							id: parentId
/******/ 						});
/******/ 					}
/******/ 				}
/******/ 		
/******/ 				return {
/******/ 					type: "accepted",
/******/ 					moduleId: updateModuleId,
/******/ 					outdatedModules: outdatedModules,
/******/ 					outdatedDependencies: outdatedDependencies
/******/ 				};
/******/ 			}
/******/ 		
/******/ 			function addAllToSet(a, b) {
/******/ 				for (var i = 0; i < b.length; i++) {
/******/ 					var item = b[i];
/******/ 					if (a.indexOf(item) === -1) a.push(item);
/******/ 				}
/******/ 			}
/******/ 		
/******/ 			// at begin all updates modules are outdated
/******/ 			// the "outdated" status can propagate to parents if they don't accept the children
/******/ 			var outdatedDependencies = {};
/******/ 			var outdatedModules = [];
/******/ 			var appliedUpdate = {};
/******/ 		
/******/ 			var warnUnexpectedRequire = function warnUnexpectedRequire(module) {
/******/ 				console.warn(
/******/ 					"[HMR] unexpected require(" + module.id + ") to disposed module"
/******/ 				);
/******/ 			};
/******/ 		
/******/ 			for (var moduleId in currentUpdate) {
/******/ 				if (__webpack_require__.o(currentUpdate, moduleId)) {
/******/ 					var newModuleFactory = currentUpdate[moduleId];
/******/ 					/** @type {TODO} */
/******/ 					var result;
/******/ 					if (newModuleFactory) {
/******/ 						result = getAffectedModuleEffects(moduleId);
/******/ 					} else {
/******/ 						result = {
/******/ 							type: "disposed",
/******/ 							moduleId: moduleId
/******/ 						};
/******/ 					}
/******/ 					/** @type {Error|false} */
/******/ 					var abortError = false;
/******/ 					var doApply = false;
/******/ 					var doDispose = false;
/******/ 					var chainInfo = "";
/******/ 					if (result.chain) {
/******/ 						chainInfo = "\nUpdate propagation: " + result.chain.join(" -> ");
/******/ 					}
/******/ 					switch (result.type) {
/******/ 						case "self-declined":
/******/ 							if (options.onDeclined) options.onDeclined(result);
/******/ 							if (!options.ignoreDeclined)
/******/ 								abortError = new Error(
/******/ 									"Aborted because of self decline: " +
/******/ 										result.moduleId +
/******/ 										chainInfo
/******/ 								);
/******/ 							break;
/******/ 						case "declined":
/******/ 							if (options.onDeclined) options.onDeclined(result);
/******/ 							if (!options.ignoreDeclined)
/******/ 								abortError = new Error(
/******/ 									"Aborted because of declined dependency: " +
/******/ 										result.moduleId +
/******/ 										" in " +
/******/ 										result.parentId +
/******/ 										chainInfo
/******/ 								);
/******/ 							break;
/******/ 						case "unaccepted":
/******/ 							if (options.onUnaccepted) options.onUnaccepted(result);
/******/ 							if (!options.ignoreUnaccepted)
/******/ 								abortError = new Error(
/******/ 									"Aborted because " + moduleId + " is not accepted" + chainInfo
/******/ 								);
/******/ 							break;
/******/ 						case "accepted":
/******/ 							if (options.onAccepted) options.onAccepted(result);
/******/ 							doApply = true;
/******/ 							break;
/******/ 						case "disposed":
/******/ 							if (options.onDisposed) options.onDisposed(result);
/******/ 							doDispose = true;
/******/ 							break;
/******/ 						default:
/******/ 							throw new Error("Unexception type " + result.type);
/******/ 					}
/******/ 					if (abortError) {
/******/ 						return {
/******/ 							error: abortError
/******/ 						};
/******/ 					}
/******/ 					if (doApply) {
/******/ 						appliedUpdate[moduleId] = newModuleFactory;
/******/ 						addAllToSet(outdatedModules, result.outdatedModules);
/******/ 						for (moduleId in result.outdatedDependencies) {
/******/ 							if (__webpack_require__.o(result.outdatedDependencies, moduleId)) {
/******/ 								if (!outdatedDependencies[moduleId])
/******/ 									outdatedDependencies[moduleId] = [];
/******/ 								addAllToSet(
/******/ 									outdatedDependencies[moduleId],
/******/ 									result.outdatedDependencies[moduleId]
/******/ 								);
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 					if (doDispose) {
/******/ 						addAllToSet(outdatedModules, [result.moduleId]);
/******/ 						appliedUpdate[moduleId] = warnUnexpectedRequire;
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 			currentUpdate = undefined;
/******/ 		
/******/ 			// Store self accepted outdated modules to require them later by the module system
/******/ 			var outdatedSelfAcceptedModules = [];
/******/ 			for (var j = 0; j < outdatedModules.length; j++) {
/******/ 				var outdatedModuleId = outdatedModules[j];
/******/ 				var module = __webpack_require__.c[outdatedModuleId];
/******/ 				if (
/******/ 					module &&
/******/ 					(module.hot._selfAccepted || module.hot._main) &&
/******/ 					// removed self-accepted modules should not be required
/******/ 					appliedUpdate[outdatedModuleId] !== warnUnexpectedRequire &&
/******/ 					// when called invalidate self-accepting is not possible
/******/ 					!module.hot._selfInvalidated
/******/ 				) {
/******/ 					outdatedSelfAcceptedModules.push({
/******/ 						module: outdatedModuleId,
/******/ 						require: module.hot._requireSelf,
/******/ 						errorHandler: module.hot._selfAccepted
/******/ 					});
/******/ 				}
/******/ 			}
/******/ 		
/******/ 			var moduleOutdatedDependencies;
/******/ 		
/******/ 			return {
/******/ 				dispose: function () {
/******/ 					currentUpdateRemovedChunks.forEach(function (chunkId) {
/******/ 						delete installedChunks[chunkId];
/******/ 					});
/******/ 					currentUpdateRemovedChunks = undefined;
/******/ 		
/******/ 					var idx;
/******/ 					var queue = outdatedModules.slice();
/******/ 					while (queue.length > 0) {
/******/ 						var moduleId = queue.pop();
/******/ 						var module = __webpack_require__.c[moduleId];
/******/ 						if (!module) continue;
/******/ 		
/******/ 						var data = {};
/******/ 		
/******/ 						// Call dispose handlers
/******/ 						var disposeHandlers = module.hot._disposeHandlers;
/******/ 						for (j = 0; j < disposeHandlers.length; j++) {
/******/ 							disposeHandlers[j].call(null, data);
/******/ 						}
/******/ 						__webpack_require__.hmrD[moduleId] = data;
/******/ 		
/******/ 						// disable module (this disables requires from this module)
/******/ 						module.hot.active = false;
/******/ 		
/******/ 						// remove module from cache
/******/ 						delete __webpack_require__.c[moduleId];
/******/ 		
/******/ 						// when disposing there is no need to call dispose handler
/******/ 						delete outdatedDependencies[moduleId];
/******/ 		
/******/ 						// remove "parents" references from all children
/******/ 						for (j = 0; j < module.children.length; j++) {
/******/ 							var child = __webpack_require__.c[module.children[j]];
/******/ 							if (!child) continue;
/******/ 							idx = child.parents.indexOf(moduleId);
/******/ 							if (idx >= 0) {
/******/ 								child.parents.splice(idx, 1);
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					// remove outdated dependency from module children
/******/ 					var dependency;
/******/ 					for (var outdatedModuleId in outdatedDependencies) {
/******/ 						if (__webpack_require__.o(outdatedDependencies, outdatedModuleId)) {
/******/ 							module = __webpack_require__.c[outdatedModuleId];
/******/ 							if (module) {
/******/ 								moduleOutdatedDependencies =
/******/ 									outdatedDependencies[outdatedModuleId];
/******/ 								for (j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 									dependency = moduleOutdatedDependencies[j];
/******/ 									idx = module.children.indexOf(dependency);
/******/ 									if (idx >= 0) module.children.splice(idx, 1);
/******/ 								}
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 				},
/******/ 				apply: function (reportError) {
/******/ 					// insert new code
/******/ 					for (var updateModuleId in appliedUpdate) {
/******/ 						if (__webpack_require__.o(appliedUpdate, updateModuleId)) {
/******/ 							__webpack_require__.m[updateModuleId] = appliedUpdate[updateModuleId];
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					// run new runtime modules
/******/ 					for (var i = 0; i < currentUpdateRuntime.length; i++) {
/******/ 						currentUpdateRuntime[i](__webpack_require__);
/******/ 					}
/******/ 		
/******/ 					// call accept handlers
/******/ 					for (var outdatedModuleId in outdatedDependencies) {
/******/ 						if (__webpack_require__.o(outdatedDependencies, outdatedModuleId)) {
/******/ 							var module = __webpack_require__.c[outdatedModuleId];
/******/ 							if (module) {
/******/ 								moduleOutdatedDependencies =
/******/ 									outdatedDependencies[outdatedModuleId];
/******/ 								var callbacks = [];
/******/ 								var errorHandlers = [];
/******/ 								var dependenciesForCallbacks = [];
/******/ 								for (var j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 									var dependency = moduleOutdatedDependencies[j];
/******/ 									var acceptCallback =
/******/ 										module.hot._acceptedDependencies[dependency];
/******/ 									var errorHandler =
/******/ 										module.hot._acceptedErrorHandlers[dependency];
/******/ 									if (acceptCallback) {
/******/ 										if (callbacks.indexOf(acceptCallback) !== -1) continue;
/******/ 										callbacks.push(acceptCallback);
/******/ 										errorHandlers.push(errorHandler);
/******/ 										dependenciesForCallbacks.push(dependency);
/******/ 									}
/******/ 								}
/******/ 								for (var k = 0; k < callbacks.length; k++) {
/******/ 									try {
/******/ 										callbacks[k].call(null, moduleOutdatedDependencies);
/******/ 									} catch (err) {
/******/ 										if (typeof errorHandlers[k] === "function") {
/******/ 											try {
/******/ 												errorHandlers[k](err, {
/******/ 													moduleId: outdatedModuleId,
/******/ 													dependencyId: dependenciesForCallbacks[k]
/******/ 												});
/******/ 											} catch (err2) {
/******/ 												if (options.onErrored) {
/******/ 													options.onErrored({
/******/ 														type: "accept-error-handler-errored",
/******/ 														moduleId: outdatedModuleId,
/******/ 														dependencyId: dependenciesForCallbacks[k],
/******/ 														error: err2,
/******/ 														originalError: err
/******/ 													});
/******/ 												}
/******/ 												if (!options.ignoreErrored) {
/******/ 													reportError(err2);
/******/ 													reportError(err);
/******/ 												}
/******/ 											}
/******/ 										} else {
/******/ 											if (options.onErrored) {
/******/ 												options.onErrored({
/******/ 													type: "accept-errored",
/******/ 													moduleId: outdatedModuleId,
/******/ 													dependencyId: dependenciesForCallbacks[k],
/******/ 													error: err
/******/ 												});
/******/ 											}
/******/ 											if (!options.ignoreErrored) {
/******/ 												reportError(err);
/******/ 											}
/******/ 										}
/******/ 									}
/******/ 								}
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					// Load self accepted modules
/******/ 					for (var o = 0; o < outdatedSelfAcceptedModules.length; o++) {
/******/ 						var item = outdatedSelfAcceptedModules[o];
/******/ 						var moduleId = item.module;
/******/ 						try {
/******/ 							item.require(moduleId);
/******/ 						} catch (err) {
/******/ 							if (typeof item.errorHandler === "function") {
/******/ 								try {
/******/ 									item.errorHandler(err, {
/******/ 										moduleId: moduleId,
/******/ 										module: __webpack_require__.c[moduleId]
/******/ 									});
/******/ 								} catch (err2) {
/******/ 									if (options.onErrored) {
/******/ 										options.onErrored({
/******/ 											type: "self-accept-error-handler-errored",
/******/ 											moduleId: moduleId,
/******/ 											error: err2,
/******/ 											originalError: err
/******/ 										});
/******/ 									}
/******/ 									if (!options.ignoreErrored) {
/******/ 										reportError(err2);
/******/ 										reportError(err);
/******/ 									}
/******/ 								}
/******/ 							} else {
/******/ 								if (options.onErrored) {
/******/ 									options.onErrored({
/******/ 										type: "self-accept-errored",
/******/ 										moduleId: moduleId,
/******/ 										error: err
/******/ 									});
/******/ 								}
/******/ 								if (!options.ignoreErrored) {
/******/ 									reportError(err);
/******/ 								}
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					return outdatedModules;
/******/ 				}
/******/ 			};
/******/ 		}
/******/ 		__webpack_require__.hmrI.jsonp = function (moduleId, applyHandlers) {
/******/ 			if (!currentUpdate) {
/******/ 				currentUpdate = {};
/******/ 				currentUpdateRuntime = [];
/******/ 				currentUpdateRemovedChunks = [];
/******/ 				applyHandlers.push(applyHandler);
/******/ 			}
/******/ 			if (!__webpack_require__.o(currentUpdate, moduleId)) {
/******/ 				currentUpdate[moduleId] = __webpack_require__.m[moduleId];
/******/ 			}
/******/ 		};
/******/ 		__webpack_require__.hmrC.jsonp = function (
/******/ 			chunkIds,
/******/ 			removedChunks,
/******/ 			removedModules,
/******/ 			promises,
/******/ 			applyHandlers,
/******/ 			updatedModulesList
/******/ 		) {
/******/ 			applyHandlers.push(applyHandler);
/******/ 			currentUpdateChunks = {};
/******/ 			currentUpdateRemovedChunks = removedChunks;
/******/ 			currentUpdate = removedModules.reduce(function (obj, key) {
/******/ 				obj[key] = false;
/******/ 				return obj;
/******/ 			}, {});
/******/ 			currentUpdateRuntime = [];
/******/ 			chunkIds.forEach(function (chunkId) {
/******/ 				if (
/******/ 					__webpack_require__.o(installedChunks, chunkId) &&
/******/ 					installedChunks[chunkId] !== undefined
/******/ 				) {
/******/ 					promises.push(loadUpdateChunk(chunkId, updatedModulesList));
/******/ 					currentUpdateChunks[chunkId] = true;
/******/ 				} else {
/******/ 					currentUpdateChunks[chunkId] = false;
/******/ 				}
/******/ 			});
/******/ 			if (__webpack_require__.f) {
/******/ 				__webpack_require__.f.jsonpHmr = function (chunkId, promises) {
/******/ 					if (
/******/ 						currentUpdateChunks &&
/******/ 						__webpack_require__.o(currentUpdateChunks, chunkId) &&
/******/ 						!currentUpdateChunks[chunkId]
/******/ 					) {
/******/ 						promises.push(loadUpdateChunk(chunkId));
/******/ 						currentUpdateChunks[chunkId] = true;
/******/ 					}
/******/ 				};
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.hmrM = () => {
/******/ 			if (typeof fetch === "undefined") throw new Error("No browser support: need fetch API");
/******/ 			return fetch(__webpack_require__.p + __webpack_require__.hmrF()).then((response) => {
/******/ 				if(response.status === 404) return; // no update available
/******/ 				if(!response.ok) throw new Error("Failed to fetch update manifest " + response.statusText);
/******/ 				return response.json();
/******/ 			});
/******/ 		};
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// no jsonp function
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// module cache are used so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	var __webpack_exports__ = __webpack_require__("./app/static/pages/layout.tsx");
/******/ 	
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxHQUFHOztBQUVOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUNBQXlDOztBQUV6QywyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRyxHQUFHOztBQUVOO0FBQ0EscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUcsR0FBRzs7QUFFTjtBQUNBLDZDQUE2Qzs7QUFFN0M7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxHQUFHOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDLEdBQUc7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QscURBQXFEO0FBQ3JEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0NBQXNDOztBQUV0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHdCQUF3QjtBQUNoQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw2QkFBNkI7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQSxtQkFBbUIsdUJBQXVCO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDZCQUE2Qjs7QUFFdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxPQUFPO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpSUFBaUkseUNBQXlDLFFBQVE7QUFDbEw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFNBQVM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0MsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsSUFBSTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsT0FBTztBQUNwRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFFBQVE7O0FBRXhELHVDQUF1QyxRQUFRLHNEQUFzRCxRQUFROztBQUU3RztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7OztBQUdSOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsUUFBUTtBQUNSO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsK0NBQStDOzs7QUFHL0M7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkM7QUFDM0M7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw4QkFBOEI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHVCQUF1QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDJCQUEyQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxPQUFPO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNB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Q2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxrQkFBa0I7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSxrQ0FBa0MscURBQXFEO0FBQ3ZGLFFBQVEsb0RBQW9EO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDREQUE0RDtBQUN2RSxZQUFZLDJEQUEyRDtBQUN2RSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxXQUFXLG9FQUFvRTtBQUMvRSxZQUFZLG1FQUFtRTtBQUMvRSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7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cUNBQXFDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyx3Q0FBd0MsMEJBQTBCLDBCQUEwQjtBQUNuRyxPQUFPLDBDQUEwQyxFQUFFLHdCQUF3QjtBQUMzRSxPQUFPLHVDQUF1QztBQUM5QyxPQUFPLHFDQUFxQztBQUM1QztBQUNBO0FBQ0EsY0FBYyxlQUFlO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDRCQUE0QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSxNQUFNLGNBQWM7QUFDcEIsa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsNEJBQTRCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwwQkFBMEI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEZBQThGLHNCQUFzQjtBQUNwSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxpREFBaUQsWUFBWSxJQUFJLHlDQUF5QztBQUMxRyxrQ0FBa0MsWUFBWSxHQUFHLHdDQUF3QztBQUN6RixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esc0NBQXNDLG9EQUFvRDtBQUMxRiw0QkFBNEIsb0RBQW9EO0FBQ2hGLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrQ0FBa0M7QUFDOUMsWUFBWSxrQ0FBa0M7QUFDOUMsUUFBUSxrQ0FBa0M7QUFDMUMsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsOEJBQThCLGdDQUFnQztBQUM5RCxvQkFBb0IsK0JBQStCO0FBQ25ELGNBQWM7QUFDZCxrQkFBa0IsUUFBUTtBQUMxQixrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxrQkFBa0IsUUFBUTtBQUMxQixrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDLHdCQUF3QixrQkFBa0I7QUFDMUMsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RCxZQUFZLHFCQUFxQjtBQUNqQyxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxRQUFRLDRFQUE0RTtBQUNwRiw4Q0FBOEMsNEVBQTRFO0FBQzFILGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQywwQ0FBMEM7QUFDL0UsWUFBWSx5Q0FBeUM7QUFDckQsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsTUFBTSxvQ0FBb0M7QUFDMUMsVUFBVSxvQ0FBb0M7QUFDOUMsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYztBQUNkLE1BQU0sMkNBQTJDLE1BQU0sd0JBQXdCO0FBQy9FLFVBQVUsNENBQTRDLHVCQUF1QjtBQUM3RSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQixVQUFVO0FBQ3JEO0FBQ0EsY0FBYyxrQkFBa0IsTUFBTSxrQkFBa0I7QUFDeEQ7QUFDQSxhQUFhLGFBQWEsb0JBQW9CLGtCQUFrQixRQUFRLGtCQUFrQjtBQUMxRixjQUFjLG9CQUFvQixjQUFjLGtCQUFrQixRQUFRLGtCQUFrQjtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CLFVBQVU7QUFDakQ7QUFDQSxjQUFjLGtCQUFrQixNQUFNLGtCQUFrQjtBQUN4RDtBQUNBLGFBQWEsYUFBYSxvQkFBb0Isa0JBQWtCLFFBQVEsa0JBQWtCO0FBQzFGLGNBQWMsb0JBQW9CLFVBQVUsa0JBQWtCLFFBQVEsa0JBQWtCO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUJBQW1CO0FBQ2hDLG9CQUFvQixtQkFBbUI7QUFDdkMsdUJBQXVCLGtCQUFrQjtBQUN6QyxtQkFBbUIsa0JBQWtCO0FBQ3JDLGFBQWEsUUFBUTtBQUNyQixjQUFjLG9CQUFvQixLQUFLLG1CQUFtQixpREFBaUQsa0JBQWtCO0FBQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFtQjtBQUNoQyxxQkFBcUIsa0JBQWtCO0FBQ3ZDLHlCQUF5QixrQkFBa0I7QUFDM0MsTUFBTSxrQkFBa0I7QUFDeEIsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsb0JBQW9CLEtBQUssbUJBQW1CLGdEQUFnRCxrQkFBa0I7QUFDNUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUJBQW1CLGNBQWM7QUFDOUMsYUFBYSw0QkFBNEIsUUFBUSxrQkFBa0I7QUFDbkUsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QixrQ0FBa0MsYUFBYSxpQkFBaUIsWUFBWTtBQUM1RSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsYUFBYSxpQkFBaUIsWUFBWTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDBCQUEwQjtBQUN2QyxrQkFBa0IseUJBQXlCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxNQUFNLDJDQUEyQyxNQUFNLHdCQUF3QjtBQUMvRSxVQUFVLDRDQUE0Qyx1QkFBdUI7QUFDN0UsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsa0JBQWtCLHlDQUF5QztBQUMzRDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLGtCQUFrQix1Q0FBdUM7QUFDekQsY0FBYztBQUNkLE1BQU0sMkNBQTJDLE1BQU0sd0JBQXdCO0FBQy9FLFVBQVUsNENBQTRDLHVCQUF1QjtBQUM3RTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLE1BQU0sMkNBQTJDLE1BQU0sd0JBQXdCO0FBQy9FLFVBQVUsNENBQTRDLHVCQUF1QjtBQUM3RTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsNEVBQTRFO0FBQ2hILHdCQUF3Qiw0RUFBNEU7QUFDcEcsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwwQ0FBMEM7QUFDckUsY0FBYywwQ0FBMEM7QUFDeEQ7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0EsNkJBQTZCLGFBQWE7QUFDMUMsUUFBUSxZQUFZO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLG1DQUFtQyw2QkFBNkIsNEJBQTRCLHdEQUF3RCw0QkFBNEI7QUFDN0wsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsVUFBVSxZQUFZLElBQUkseUJBQXlCO0FBQ25ELFlBQVksWUFBWSxhQUFhLHlCQUF5QjtBQUM5RCxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVUseUJBQXlCLGVBQWU7QUFDL0Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixhQUFhO0FBQzlCLHdCQUF3QixZQUFZO0FBQ3BDLGNBQWMsY0FBYztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCLGFBQWEsUUFBUTtBQUNyQixhQUFhLE9BQU87QUFDcEIsYUFBYSxTQUFTO0FBQ3RCLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix1QkFBdUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHVCQUF1QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssSUFBSTtBQUNUO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxJQUFJO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxJQUFJO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxJQUFJO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLFdBQVcscURBQWEsd0JBQXdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxHQUFHLHFEQUFhO0FBQ3JCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGlEQUFTO0FBQ3RCLEtBQUs7QUFDTCxhQUFhLGlEQUFTO0FBQ3RCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7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QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDO0FBQ2pDLHdCQUF3QjtBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkLGtCQUFrQjtBQUNsQjs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkLGtCQUFrQjtBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQiwwQkFBMEI7QUFDMUI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sZ0dBQWdHLFlBQVksTUFBTSxPQUFPLHFCQUFxQixvQkFBb0IscUJBQXFCLHFCQUFxQixNQUFNLE1BQU0sV0FBVyxNQUFNLFlBQVksTUFBTSxNQUFNLHFCQUFxQixxQkFBcUIscUJBQXFCLFVBQVUsb0JBQW9CLHFCQUFxQixxQkFBcUIscUJBQXFCLHFCQUFxQixNQUFNLE9BQU8sTUFBTSxLQUFLLG9CQUFvQixxQkFBcUIsTUFBTSxRQUFRLE1BQU0sS0FBSyxvQkFBb0Isb0JBQW9CLHFCQUFxQixNQUFNLE1BQU0sTUFBTSxLQUFLLFdBQVcsV0FBVyxNQUFNLE1BQU0sTUFBTSxVQUFVLFdBQVcsV0FBVyxNQUFNLE1BQU0sTUFBTSxLQUFLLFVBQVUsV0FBVyxNQUFNLE1BQU0sTUFBTSxNQUFNLFdBQVcsTUFBTSxTQUFTLE1BQU0sUUFBUSxxQkFBcUIscUJBQXFCLHFCQUFxQixvQkFBb0IsTUFBTSxNQUFNLE1BQU0sS0FBSyxVQUFVLE1BQU0sTUFBTSxNQUFNLE1BQU0sVUFBVSxVQUFVLFdBQVcsV0FBVyxNQUFNLEtBQUssVUFBVSxNQUFNLEtBQUssVUFBVSxNQUFNLFFBQVEsTUFBTSxLQUFLLG9CQUFvQixxQkFBcUIscUJBQXFCLE1BQU0sUUFBUSxNQUFNLFNBQVMscUJBQXFCLHFCQUFxQixxQkFBcUIsb0JBQW9CLHFCQUFxQixxQkFBcUIscUJBQXFCLG9CQUFvQixvQkFBb0Isb0JBQW9CLE1BQU0sTUFBTSxNQUFNLE1BQU0sV0FBVyxNQUFNLE9BQU8sTUFBTSxRQUFRLHFCQUFxQixxQkFBcUIscUJBQXFCLE1BQU0sTUFBTSxNQUFNLEtBQUssVUFBVSxNQUFNLE1BQU0sTUFBTSxLQUFLLFdBQVcsTUFBTSxNQUFNLE1BQU0sS0FBSyxXQUFXLE1BQU0sTUFBTSxNQUFNLE1BQU0sVUFBVSxNQUFNLE9BQU8sTUFBTSxLQUFLLHFCQUFxQixxQkFBcUIsTUFBTSxNQUFNLE1BQU0sS0FBSyxXQUFXLE1BQU0sT0FBTyxNQUFNLEtBQUsscUJBQXFCLG9CQUFvQixNQUFNLE1BQU0sTUFBTSxLQUFLLFdBQVcsTUFBTSxNQUFNLE1BQU0saUJBQWlCLFVBQVUsTUFBTSxLQUFLLFVBQVUsVUFBVSxNQUFNLEtBQUssVUFBVSxNQUFNLE9BQU8sV0FBVyxVQUFVLFVBQVUsTUFBTSxNQUFNLEtBQUssS0FBSyxVQUFVLE1BQU0sTUFBTSxNQUFNLEtBQUssV0FBVyxNQUFNLE9BQU8sTUFBTSxLQUFLLG9CQUFvQixvQkFBb0IsTUFBTSxNQUFNLG9CQUFvQixvQkFBb0IsTUFBTSxNQUFNLE1BQU0sTUFBTSxVQUFVLE1BQU0sTUFBTSxLQUFLLEtBQUssVUFBVSxNQUFNLFFBQVEsTUFBTSxZQUFZLG9CQUFvQixxQkFBcUIsTUFBTSxNQUFNLE1BQU0sTUFBTSxVQUFVLFVBQVUsTUFBTSxXQUFXLEtBQUssVUFBVSxNQUFNLEtBQUssV0FBVyxXQUFXLFdBQVcsV0FBVyxVQUFVLFVBQVUsVUFBVSxVQUFVLFVBQVUsVUFBVSxVQUFVLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxVQUFVLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFVBQVUsV0FBVyxXQUFXLFdBQVcsV0FBVyxVQUFVLFdBQVcsVUFBVSxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLEtBQUssTUFBTSxLQUFLLFdBQVcsV0FBVyxXQUFXLFdBQVcsVUFBVSxVQUFVLFVBQVUsVUFBVSxVQUFVLFVBQVUsVUFBVSxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsVUFBVSxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxVQUFVLFdBQVcsV0FBVyxXQUFXLFdBQVcsVUFBVSxXQUFXLFVBQVUsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxLQUFLLEtBQUssS0FBSyxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLFdBQVcsTUFBTSxNQUFNLE1BQU0sV0FBVyxNQUFNLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sWUFBWSxhQUFhLGFBQWEsYUFBYSxNQUFNLE1BQU0sTUFBTSxZQUFZLGFBQWEsTUFBTSxPQUFPLE1BQU0sV0FBVyxhQUFhLE1BQU0sT0FBTyxPQUFPLEtBQUssV0FBVyxNQUFNLE1BQU0sTUFBTSxNQUFNLFdBQVcsYUFBYSxNQUFNLE9BQU8sT0FBTyxLQUFLLFdBQVcsTUFBTSxNQUFNLE1BQU0sTUFBTSxXQUFXLGFBQWEsTUFBTSxPQUFPLE1BQU0sV0FBVyxNQUFNLE9BQU8sT0FBTyxLQUFLLFdBQVcsTUFBTSxNQUFNLE1BQU0sTUFBTSxLQUFLLE9BQU8sT0FBTyxLQUFLLEtBQUssTUFBTSxNQUFNLE9BQU8sV0FBVyxhQUFhLGFBQWEsTUFBTSxNQUFNLE9BQU8sS0FBSyxPQUFPLE1BQU0sVUFBVSxVQUFVLFVBQVUsWUFBWSxhQUFhLFdBQVcsT0FBTyxLQUFLLFlBQVksT0FBTyxLQUFLLFVBQVUsWUFBWSxXQUFXLFVBQVUsVUFBVSxVQUFVLFlBQVksYUFBYSxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sWUFBWSxNQUFNLE9BQU8sTUFBTSxZQUFZLE1BQU0sT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLFlBQVksTUFBTSxPQUFPLE1BQU0sS0FBSyxPQUFPLE9BQU8sS0FBSyxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE1BQU0sTUFBTSxPQUFPLEtBQUssS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxNQUFNLE1BQU0sT0FBTyxLQUFLLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLFlBQVksTUFBTSxPQUFPLE1BQU0sWUFBWSxNQUFNLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFL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RUE7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLEVBQUU7V0FDRjs7V0FFQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTs7V0FFQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTs7V0FFQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsR0FBRztXQUNIO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLG1CQUFtQiwyQkFBMkI7V0FDOUM7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLEtBQUs7V0FDTDtXQUNBOztXQUVBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBOztXQUVBO1dBQ0Esa0JBQWtCLGNBQWM7V0FDaEM7V0FDQTtXQUNBO1dBQ0E7O1dBRUE7V0FDQTtXQUNBO1dBQ0E7V0FDQTs7V0FFQTtXQUNBO1dBQ0E7V0FDQTtXQUNBOztXQUVBO1dBQ0E7V0FDQTtXQUNBLGNBQWMsTUFBTTtXQUNwQjtXQUNBO1dBQ0E7V0FDQSxLQUFLO1dBQ0w7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLGNBQWMsYUFBYTtXQUMzQjtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7O1dBRUE7V0FDQTtXQUNBLGlCQUFpQiw0QkFBNEI7V0FDN0M7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLElBQUk7V0FDSjtXQUNBOztXQUVBOztXQUVBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsSUFBSTtXQUNKOztXQUVBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTs7V0FFQTs7V0FFQTtXQUNBO1dBQ0EsZ0JBQWdCLDRCQUE0QjtXQUM1QztXQUNBO1dBQ0E7O1dBRUE7V0FDQTs7V0FFQTtXQUNBOztXQUVBO1dBQ0E7O1dBRUE7V0FDQSxnQkFBZ0IsNEJBQTRCO1dBQzVDO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7O1dBRUE7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLGtCQUFrQix1Q0FBdUM7V0FDekQ7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxHQUFHO1dBQ0g7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7O1dBRUE7V0FDQSxtQkFBbUIsaUNBQWlDO1dBQ3BEO1dBQ0E7O1dBRUE7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxzQkFBc0IsdUNBQXVDO1dBQzdEO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLHNCQUFzQixzQkFBc0I7V0FDNUM7V0FDQTtXQUNBLFNBQVM7V0FDVDtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsV0FBVztXQUNYLFdBQVc7V0FDWDtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLFlBQVk7V0FDWjtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxVQUFVO1dBQ1Y7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsV0FBVztXQUNYO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBOztXQUVBO1dBQ0EsbUJBQW1CLHdDQUF3QztXQUMzRDtXQUNBO1dBQ0E7V0FDQTtXQUNBLE1BQU07V0FDTjtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsUUFBUTtXQUNSLFFBQVE7V0FDUjtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxTQUFTO1dBQ1Q7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsT0FBTztXQUNQO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxRQUFRO1dBQ1I7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7O1dBRUE7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLEVBQUUsSUFBSTtXQUNOO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxJQUFJO1dBQ0o7V0FDQTtXQUNBLEVBQUU7V0FDRjtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTs7V0FFQTtXQUNBO1dBQ0E7V0FDQSxzQ0FBc0M7V0FDdEM7V0FDQTtXQUNBLEVBQUU7V0FDRjs7V0FFQTs7V0FFQTs7Ozs7V0M5ZkE7Ozs7O1VFQUE7VUFDQTtVQUNBO1VBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mbGFzay1wcmVhY3QtdHlwZXNjcmlwdC10YWlsd2luZC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9AZWdqcy9wcmVhY3QtZmxpY2tpbmcvZGlzdC9mbGlja2luZy5lc20uanMiLCJ3ZWJwYWNrOi8vZmxhc2stcHJlYWN0LXR5cGVzY3JpcHQtdGFpbHdpbmQtdGVtcGxhdGUvLi9hcHAvc3RhdGljL3BhZ2VzL2dsb2JhbHMuY3NzIiwid2VicGFjazovL2ZsYXNrLXByZWFjdC10eXBlc2NyaXB0LXRhaWx3aW5kLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0BlZ2pzL3ByZWFjdC1mbGlja2luZy9kaXN0L2ZsaWNraW5nLmNzcyIsIndlYnBhY2s6Ly9mbGFzay1wcmVhY3QtdHlwZXNjcmlwdC10YWlsd2luZC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanMiLCJ3ZWJwYWNrOi8vZmxhc2stcHJlYWN0LXR5cGVzY3JpcHQtdGFpbHdpbmQtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvc291cmNlTWFwcy5qcyIsIndlYnBhY2s6Ly9mbGFzay1wcmVhY3QtdHlwZXNjcmlwdC10YWlsd2luZC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9wcmVhY3QvZGlzdC9wcmVhY3QubW9kdWxlLmpzIiwid2VicGFjazovL2ZsYXNrLXByZWFjdC10eXBlc2NyaXB0LXRhaWx3aW5kLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ByZWFjdC9ob29rcy9kaXN0L2hvb2tzLm1vZHVsZS5qcyIsIndlYnBhY2s6Ly9mbGFzay1wcmVhY3QtdHlwZXNjcmlwdC10YWlsd2luZC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9wcmVhY3QvanN4LXJ1bnRpbWUvZGlzdC9qc3hSdW50aW1lLm1vZHVsZS5qcyIsIndlYnBhY2s6Ly9mbGFzay1wcmVhY3QtdHlwZXNjcmlwdC10YWlsd2luZC10ZW1wbGF0ZS8uL2FwcC9zdGF0aWMvcGFnZXMvZ2xvYmFscy5jc3M/NTQxZiIsIndlYnBhY2s6Ly9mbGFzay1wcmVhY3QtdHlwZXNjcmlwdC10YWlsd2luZC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9AZWdqcy9wcmVhY3QtZmxpY2tpbmcvZGlzdC9mbGlja2luZy5jc3M/M2ZjNyIsIndlYnBhY2s6Ly9mbGFzay1wcmVhY3QtdHlwZXNjcmlwdC10YWlsd2luZC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcyIsIndlYnBhY2s6Ly9mbGFzay1wcmVhY3QtdHlwZXNjcmlwdC10YWlsd2luZC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydEJ5U2VsZWN0b3IuanMiLCJ3ZWJwYWNrOi8vZmxhc2stcHJlYWN0LXR5cGVzY3JpcHQtdGFpbHdpbmQtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRTdHlsZUVsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vZmxhc2stcHJlYWN0LXR5cGVzY3JpcHQtdGFpbHdpbmQtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXMuanMiLCJ3ZWJwYWNrOi8vZmxhc2stcHJlYWN0LXR5cGVzY3JpcHQtdGFpbHdpbmQtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZURvbUFQSS5qcyIsIndlYnBhY2s6Ly9mbGFzay1wcmVhY3QtdHlwZXNjcmlwdC10YWlsd2luZC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3N0eWxlVGFnVHJhbnNmb3JtLmpzIiwid2VicGFjazovL2ZsYXNrLXByZWFjdC10eXBlc2NyaXB0LXRhaWx3aW5kLXRlbXBsYXRlLy4vYXBwL3N0YXRpYy9wYWdlcy9jb21wb25lbnRzL0Jsb2NrMS50c3giLCJ3ZWJwYWNrOi8vZmxhc2stcHJlYWN0LXR5cGVzY3JpcHQtdGFpbHdpbmQtdGVtcGxhdGUvLi9hcHAvc3RhdGljL3BhZ2VzL2NvbXBvbmVudHMvQmxvY2syLnRzeCIsIndlYnBhY2s6Ly9mbGFzay1wcmVhY3QtdHlwZXNjcmlwdC10YWlsd2luZC10ZW1wbGF0ZS8uL2FwcC9zdGF0aWMvcGFnZXMvY29tcG9uZW50cy9CbG9jazMudHN4Iiwid2VicGFjazovL2ZsYXNrLXByZWFjdC10eXBlc2NyaXB0LXRhaWx3aW5kLXRlbXBsYXRlLy4vYXBwL3N0YXRpYy9wYWdlcy9jb21wb25lbnRzL0Jsb2NrNC50c3giLCJ3ZWJwYWNrOi8vZmxhc2stcHJlYWN0LXR5cGVzY3JpcHQtdGFpbHdpbmQtdGVtcGxhdGUvLi9hcHAvc3RhdGljL3BhZ2VzL2NvbXBvbmVudHMvRm9vdGVyLnRzeCIsIndlYnBhY2s6Ly9mbGFzay1wcmVhY3QtdHlwZXNjcmlwdC10YWlsd2luZC10ZW1wbGF0ZS8uL2FwcC9zdGF0aWMvcGFnZXMvY29tcG9uZW50cy9OYXZiYXIudHN4Iiwid2VicGFjazovL2ZsYXNrLXByZWFjdC10eXBlc2NyaXB0LXRhaWx3aW5kLXRlbXBsYXRlLy4vYXBwL3N0YXRpYy9wYWdlcy9sYXlvdXQudHN4Iiwid2VicGFjazovL2ZsYXNrLXByZWFjdC10eXBlc2NyaXB0LXRhaWx3aW5kLXRlbXBsYXRlLy4vYXBwL3N0YXRpYy9wYWdlcy9wYWdlLnRzeCIsIndlYnBhY2s6Ly9mbGFzay1wcmVhY3QtdHlwZXNjcmlwdC10YWlsd2luZC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9wcmVhY3Qtcm91dGVyL2Rpc3QvcHJlYWN0LXJvdXRlci5tanMiLCJ3ZWJwYWNrOi8vZmxhc2stcHJlYWN0LXR5cGVzY3JpcHQtdGFpbHdpbmQtdGVtcGxhdGUvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vZmxhc2stcHJlYWN0LXR5cGVzY3JpcHQtdGFpbHdpbmQtdGVtcGxhdGUvd2VicGFjay9ydW50aW1lL2NvbXBhdCBnZXQgZGVmYXVsdCBleHBvcnQiLCJ3ZWJwYWNrOi8vZmxhc2stcHJlYWN0LXR5cGVzY3JpcHQtdGFpbHdpbmQtdGVtcGxhdGUvd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzIiwid2VicGFjazovL2ZsYXNrLXByZWFjdC10eXBlc2NyaXB0LXRhaWx3aW5kLXRlbXBsYXRlL3dlYnBhY2svcnVudGltZS9nZXQgamF2YXNjcmlwdCB1cGRhdGUgY2h1bmsgZmlsZW5hbWUiLCJ3ZWJwYWNrOi8vZmxhc2stcHJlYWN0LXR5cGVzY3JpcHQtdGFpbHdpbmQtdGVtcGxhdGUvd2VicGFjay9ydW50aW1lL2dldCB1cGRhdGUgbWFuaWZlc3QgZmlsZW5hbWUiLCJ3ZWJwYWNrOi8vZmxhc2stcHJlYWN0LXR5cGVzY3JpcHQtdGFpbHdpbmQtdGVtcGxhdGUvd2VicGFjay9ydW50aW1lL2dldEZ1bGxIYXNoIiwid2VicGFjazovL2ZsYXNrLXByZWFjdC10eXBlc2NyaXB0LXRhaWx3aW5kLXRlbXBsYXRlL3dlYnBhY2svcnVudGltZS9nbG9iYWwiLCJ3ZWJwYWNrOi8vZmxhc2stcHJlYWN0LXR5cGVzY3JpcHQtdGFpbHdpbmQtdGVtcGxhdGUvd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly9mbGFzay1wcmVhY3QtdHlwZXNjcmlwdC10YWlsd2luZC10ZW1wbGF0ZS93ZWJwYWNrL3J1bnRpbWUvbG9hZCBzY3JpcHQiLCJ3ZWJwYWNrOi8vZmxhc2stcHJlYWN0LXR5cGVzY3JpcHQtdGFpbHdpbmQtdGVtcGxhdGUvd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly9mbGFzay1wcmVhY3QtdHlwZXNjcmlwdC10YWlsd2luZC10ZW1wbGF0ZS93ZWJwYWNrL3J1bnRpbWUvaG90IG1vZHVsZSByZXBsYWNlbWVudCIsIndlYnBhY2s6Ly9mbGFzay1wcmVhY3QtdHlwZXNjcmlwdC10YWlsd2luZC10ZW1wbGF0ZS93ZWJwYWNrL3J1bnRpbWUvcHVibGljUGF0aCIsIndlYnBhY2s6Ly9mbGFzay1wcmVhY3QtdHlwZXNjcmlwdC10YWlsd2luZC10ZW1wbGF0ZS93ZWJwYWNrL3J1bnRpbWUvanNvbnAgY2h1bmsgbG9hZGluZyIsIndlYnBhY2s6Ly9mbGFzay1wcmVhY3QtdHlwZXNjcmlwdC10YWlsd2luZC10ZW1wbGF0ZS93ZWJwYWNrL3J1bnRpbWUvbm9uY2UiLCJ3ZWJwYWNrOi8vZmxhc2stcHJlYWN0LXR5cGVzY3JpcHQtdGFpbHdpbmQtdGVtcGxhdGUvd2VicGFjay9iZWZvcmUtc3RhcnR1cCIsIndlYnBhY2s6Ly9mbGFzay1wcmVhY3QtdHlwZXNjcmlwdC10YWlsd2luZC10ZW1wbGF0ZS93ZWJwYWNrL3N0YXJ0dXAiLCJ3ZWJwYWNrOi8vZmxhc2stcHJlYWN0LXR5cGVzY3JpcHQtdGFpbHdpbmQtdGVtcGxhdGUvd2VicGFjay9hZnRlci1zdGFydHVwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG5Db3B5cmlnaHQgKGMpIDIwMjEtcHJlc2VudCBOQVZFUiBDb3JwLlxubmFtZTogQGVnanMvcHJlYWN0LWZsaWNraW5nXG5saWNlbnNlOiBNSVRcbmF1dGhvcjogTkFWRVIgQ29ycC5cbnJlcG9zaXRvcnk6IGh0dHBzOi8vZ2l0aHViLmNvbS9uYXZlci9lZ2pzLWZsaWNraW5nL2Jsb2IvbWFzdGVyL3BhY2thZ2VzL3ByZWFjdC1mbGlja2luZ1xudmVyc2lvbjogNC4xMS40XG4qL1xuaW1wb3J0IHsgb3B0aW9ucywgQ29tcG9uZW50IGFzIENvbXBvbmVudCQxLCBjcmVhdGVFbGVtZW50LCBGcmFnbWVudCwgdG9DaGlsZEFycmF5LCBjcmVhdGVDb250ZXh0LCBjcmVhdGVSZWYsIHJlbmRlciwgaHlkcmF0ZSwgY2xvbmVFbGVtZW50IH0gZnJvbSAncHJlYWN0JztcblxudmFyIHQsdSxyLG89MCxpPVtdLGM9b3B0aW9ucy5fX2IsZj1vcHRpb25zLl9fcixlPW9wdGlvbnMuZGlmZmVkLGE9b3B0aW9ucy5fX2Msdj1vcHRpb25zLnVubW91bnQ7ZnVuY3Rpb24gbSh0LHIpe29wdGlvbnMuX19oJiZvcHRpb25zLl9faCh1LHQsb3x8ciksbz0wO3ZhciBpPXUuX19IfHwodS5fX0g9e19fOltdLF9faDpbXX0pO3JldHVybiB0Pj1pLl9fLmxlbmd0aCYmaS5fXy5wdXNoKHt9KSxpLl9fW3RdfWZ1bmN0aW9uIGwobil7cmV0dXJuIG89MSxwKHcsbil9ZnVuY3Rpb24gcChuLHIsbyl7dmFyIGk9bSh0KyssMik7cmV0dXJuIGkudD1uLGkuX19jfHwoaS5fXz1bbz9vKHIpOncodm9pZCAwLHIpLGZ1bmN0aW9uKG4pe3ZhciB0PWkudChpLl9fWzBdLG4pO2kuX19bMF0hPT10JiYoaS5fXz1bdCxpLl9fWzFdXSxpLl9fYy5zZXRTdGF0ZSh7fSkpO31dLGkuX19jPXUpLGkuX199ZnVuY3Rpb24geShyLG8pe3ZhciBpPW0odCsrLDMpOyFvcHRpb25zLl9fcyYmayhpLl9fSCxvKSYmKGkuX189cixpLl9fSD1vLHUuX19ILl9faC5wdXNoKGkpKTt9ZnVuY3Rpb24gaChyLG8pe3ZhciBpPW0odCsrLDQpOyFvcHRpb25zLl9fcyYmayhpLl9fSCxvKSYmKGkuX189cixpLl9fSD1vLHUuX19oLnB1c2goaSkpO31mdW5jdGlvbiBzKG4pe3JldHVybiBvPTUsZChmdW5jdGlvbigpe3JldHVybiB7Y3VycmVudDpufX0sW10pfWZ1bmN0aW9uIF8obix0LHUpe289NixoKGZ1bmN0aW9uKCl7XCJmdW5jdGlvblwiPT10eXBlb2Ygbj9uKHQoKSk6biYmKG4uY3VycmVudD10KCkpO30sbnVsbD09dT91OnUuY29uY2F0KG4pKTt9ZnVuY3Rpb24gZChuLHUpe3ZhciByPW0odCsrLDcpO3JldHVybiBrKHIuX19ILHUpJiYoci5fXz1uKCksci5fX0g9dSxyLl9faD1uKSxyLl9ffWZ1bmN0aW9uIEEobix0KXtyZXR1cm4gbz04LGQoZnVuY3Rpb24oKXtyZXR1cm4gbn0sdCl9ZnVuY3Rpb24gRihuKXt2YXIgcj11LmNvbnRleHRbbi5fX2NdLG89bSh0KyssOSk7cmV0dXJuIG8uYz1uLHI/KG51bGw9PW8uX18mJihvLl9fPSEwLHIuc3ViKHUpKSxyLnByb3BzLnZhbHVlKTpuLl9ffWZ1bmN0aW9uIFQodCx1KXtvcHRpb25zLnVzZURlYnVnVmFsdWUmJm9wdGlvbnMudXNlRGVidWdWYWx1ZSh1P3UodCk6dCk7fWZ1bmN0aW9uIHgoKXt2YXIgdDtmb3IoaS5zb3J0KGZ1bmN0aW9uKG4sdCl7cmV0dXJuIG4uX192Ll9fYi10Ll9fdi5fX2J9KTt0PWkucG9wKCk7KWlmKHQuX19QKXRyeXt0Ll9fSC5fX2guZm9yRWFjaChnKSx0Ll9fSC5fX2guZm9yRWFjaChqKSx0Ll9fSC5fX2g9W107fWNhdGNoKHUpe3QuX19ILl9faD1bXSxvcHRpb25zLl9fZSh1LHQuX192KTt9fW9wdGlvbnMuX19iPWZ1bmN0aW9uKG4pe3U9bnVsbCxjJiZjKG4pO30sb3B0aW9ucy5fX3I9ZnVuY3Rpb24obil7ZiYmZihuKSx0PTA7dmFyIHI9KHU9bi5fX2MpLl9fSDtyJiYoci5fX2guZm9yRWFjaChnKSxyLl9faC5mb3JFYWNoKGopLHIuX19oPVtdKTt9LG9wdGlvbnMuZGlmZmVkPWZ1bmN0aW9uKHQpe2UmJmUodCk7dmFyIG89dC5fX2M7byYmby5fX0gmJm8uX19ILl9faC5sZW5ndGgmJigxIT09aS5wdXNoKG8pJiZyPT09b3B0aW9ucy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWV8fCgocj1vcHRpb25zLnJlcXVlc3RBbmltYXRpb25GcmFtZSl8fGZ1bmN0aW9uKG4pe3ZhciB0LHU9ZnVuY3Rpb24oKXtjbGVhclRpbWVvdXQociksYiYmY2FuY2VsQW5pbWF0aW9uRnJhbWUodCksc2V0VGltZW91dChuKTt9LHI9c2V0VGltZW91dCh1LDEwMCk7YiYmKHQ9cmVxdWVzdEFuaW1hdGlvbkZyYW1lKHUpKTt9KSh4KSksdT1udWxsO30sb3B0aW9ucy5fX2M9ZnVuY3Rpb24odCx1KXt1LnNvbWUoZnVuY3Rpb24odCl7dHJ5e3QuX19oLmZvckVhY2goZyksdC5fX2g9dC5fX2guZmlsdGVyKGZ1bmN0aW9uKG4pe3JldHVybiAhbi5fX3x8aihuKX0pO31jYXRjaChyKXt1LnNvbWUoZnVuY3Rpb24obil7bi5fX2gmJihuLl9faD1bXSk7fSksdT1bXSxvcHRpb25zLl9fZShyLHQuX192KTt9fSksYSYmYSh0LHUpO30sb3B0aW9ucy51bm1vdW50PWZ1bmN0aW9uKHQpe3YmJnYodCk7dmFyIHUscj10Ll9fYztyJiZyLl9fSCYmKHIuX19ILl9fLmZvckVhY2goZnVuY3Rpb24obil7dHJ5e2cobik7fWNhdGNoKG4pe3U9bjt9fSksdSYmb3B0aW9ucy5fX2UodSxyLl9fdikpO307dmFyIGI9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lO2Z1bmN0aW9uIGcobil7dmFyIHQ9dSxyPW4uX19jO1wiZnVuY3Rpb25cIj09dHlwZW9mIHImJihuLl9fYz12b2lkIDAscigpKSx1PXQ7fWZ1bmN0aW9uIGoobil7dmFyIHQ9dTtuLl9fYz1uLl9fKCksdT10O31mdW5jdGlvbiBrKG4sdCl7cmV0dXJuICFufHxuLmxlbmd0aCE9PXQubGVuZ3RofHx0LnNvbWUoZnVuY3Rpb24odCx1KXtyZXR1cm4gdCE9PW5bdV19KX1mdW5jdGlvbiB3KG4sdCl7cmV0dXJuIFwiZnVuY3Rpb25cIj09dHlwZW9mIHQ/dChuKTp0fVxuXG5mdW5jdGlvbiBTKG4sdCl7Zm9yKHZhciBlIGluIHQpbltlXT10W2VdO3JldHVybiBufWZ1bmN0aW9uIEMobix0KXtmb3IodmFyIGUgaW4gbilpZihcIl9fc291cmNlXCIhPT1lJiYhKGUgaW4gdCkpcmV0dXJuICEwO2Zvcih2YXIgciBpbiB0KWlmKFwiX19zb3VyY2VcIiE9PXImJm5bcl0hPT10W3JdKXJldHVybiAhMDtyZXR1cm4gITF9ZnVuY3Rpb24gRShuKXt0aGlzLnByb3BzPW47fWZ1bmN0aW9uIGckMShuLHQpe2Z1bmN0aW9uIGUobil7dmFyIGU9dGhpcy5wcm9wcy5yZWYscj1lPT1uLnJlZjtyZXR1cm4gIXImJmUmJihlLmNhbGw/ZShudWxsKTplLmN1cnJlbnQ9bnVsbCksdD8hdCh0aGlzLnByb3BzLG4pfHwhcjpDKHRoaXMucHJvcHMsbil9ZnVuY3Rpb24gcih0KXtyZXR1cm4gdGhpcy5zaG91bGRDb21wb25lbnRVcGRhdGU9ZSxjcmVhdGVFbGVtZW50KG4sdCl9cmV0dXJuIHIuZGlzcGxheU5hbWU9XCJNZW1vKFwiKyhuLmRpc3BsYXlOYW1lfHxuLm5hbWUpK1wiKVwiLHIucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQ9ITAsci5fX2Y9ITAscn0oRS5wcm90b3R5cGU9bmV3IENvbXBvbmVudCQxKS5pc1B1cmVSZWFjdENvbXBvbmVudD0hMCxFLnByb3RvdHlwZS5zaG91bGRDb21wb25lbnRVcGRhdGU9ZnVuY3Rpb24obix0KXtyZXR1cm4gQyh0aGlzLnByb3BzLG4pfHxDKHRoaXMuc3RhdGUsdCl9O3ZhciB3JDE9b3B0aW9ucy5fX2I7b3B0aW9ucy5fX2I9ZnVuY3Rpb24obil7bi50eXBlJiZuLnR5cGUuX19mJiZuLnJlZiYmKG4ucHJvcHMucmVmPW4ucmVmLG4ucmVmPW51bGwpLHckMSYmdyQxKG4pO307dmFyIFI9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmU3ltYm9sLmZvciYmU3ltYm9sLmZvcihcInJlYWN0LmZvcndhcmRfcmVmXCIpfHwzOTExO2Z1bmN0aW9uIHgkMShuKXtmdW5jdGlvbiB0KHQsZSl7dmFyIHI9Uyh7fSx0KTtyZXR1cm4gZGVsZXRlIHIucmVmLG4ociwoZT10LnJlZnx8ZSkmJihcIm9iamVjdFwiIT10eXBlb2YgZXx8XCJjdXJyZW50XCJpbiBlKT9lOm51bGwpfXJldHVybiB0LiQkdHlwZW9mPVIsdC5yZW5kZXI9dCx0LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50PXQuX19mPSEwLHQuZGlzcGxheU5hbWU9XCJGb3J3YXJkUmVmKFwiKyhuLmRpc3BsYXlOYW1lfHxuLm5hbWUpK1wiKVwiLHR9dmFyIE49ZnVuY3Rpb24obix0KXtyZXR1cm4gbnVsbD09bj9udWxsOnRvQ2hpbGRBcnJheSh0b0NoaWxkQXJyYXkobikubWFwKHQpKX0sayQxPXttYXA6Tixmb3JFYWNoOk4sY291bnQ6ZnVuY3Rpb24obil7cmV0dXJuIG4/dG9DaGlsZEFycmF5KG4pLmxlbmd0aDowfSxvbmx5OmZ1bmN0aW9uKG4pe3ZhciB0PXRvQ2hpbGRBcnJheShuKTtpZigxIT09dC5sZW5ndGgpdGhyb3cgXCJDaGlsZHJlbi5vbmx5XCI7cmV0dXJuIHRbMF19LHRvQXJyYXk6dG9DaGlsZEFycmF5fSxBJDE9b3B0aW9ucy5fX2U7b3B0aW9ucy5fX2U9ZnVuY3Rpb24obix0LGUpe2lmKG4udGhlbilmb3IodmFyIHIsdT10O3U9dS5fXzspaWYoKHI9dS5fX2MpJiZyLl9fYylyZXR1cm4gbnVsbD09dC5fX2UmJih0Ll9fZT1lLl9fZSx0Ll9faz1lLl9fayksci5fX2Mobix0KTtBJDEobix0LGUpO307dmFyIE89b3B0aW9ucy51bm1vdW50O2Z1bmN0aW9uIEwoKXt0aGlzLl9fdT0wLHRoaXMudD1udWxsLHRoaXMuX19iPW51bGw7fWZ1bmN0aW9uIFUobil7dmFyIHQ9bi5fXy5fX2M7cmV0dXJuIHQmJnQuX19lJiZ0Ll9fZShuKX1mdW5jdGlvbiBGJDEobil7dmFyIHQsZSxyO2Z1bmN0aW9uIHUodSl7aWYodHx8KHQ9bigpKS50aGVuKGZ1bmN0aW9uKG4pe2U9bi5kZWZhdWx0fHxuO30sZnVuY3Rpb24obil7cj1uO30pLHIpdGhyb3cgcjtpZighZSl0aHJvdyB0O3JldHVybiBjcmVhdGVFbGVtZW50KGUsdSl9cmV0dXJuIHUuZGlzcGxheU5hbWU9XCJMYXp5XCIsdS5fX2Y9ITAsdX1mdW5jdGlvbiBNKCl7dGhpcy51PW51bGwsdGhpcy5vPW51bGw7fW9wdGlvbnMudW5tb3VudD1mdW5jdGlvbihuKXt2YXIgdD1uLl9fYzt0JiZ0Ll9fUiYmdC5fX1IoKSx0JiYhMD09PW4uX19oJiYobi50eXBlPW51bGwpLE8mJk8obik7fSwoTC5wcm90b3R5cGU9bmV3IENvbXBvbmVudCQxKS5fX2M9ZnVuY3Rpb24obix0KXt2YXIgZT10Ll9fYyxyPXRoaXM7bnVsbD09ci50JiYoci50PVtdKSxyLnQucHVzaChlKTt2YXIgdT1VKHIuX192KSxvPSExLGk9ZnVuY3Rpb24oKXtvfHwobz0hMCxlLl9fUj1udWxsLHU/dShsKTpsKCkpO307ZS5fX1I9aTt2YXIgbD1mdW5jdGlvbigpe2lmKCEtLXIuX191KXtpZihyLnN0YXRlLl9fZSl7dmFyIG49ci5zdGF0ZS5fX2U7ci5fX3YuX19rWzBdPWZ1bmN0aW9uIG4odCxlLHIpe3JldHVybiB0JiYodC5fX3Y9bnVsbCx0Ll9faz10Ll9fayYmdC5fX2subWFwKGZ1bmN0aW9uKHQpe3JldHVybiBuKHQsZSxyKX0pLHQuX19jJiZ0Ll9fYy5fX1A9PT1lJiYodC5fX2UmJnIuaW5zZXJ0QmVmb3JlKHQuX19lLHQuX19kKSx0Ll9fYy5fX2U9ITAsdC5fX2MuX19QPXIpKSx0fShuLG4uX19jLl9fUCxuLl9fYy5fX08pO312YXIgdDtmb3Ioci5zZXRTdGF0ZSh7X19lOnIuX19iPW51bGx9KTt0PXIudC5wb3AoKTspdC5mb3JjZVVwZGF0ZSgpO319LGM9ITA9PT10Ll9faDtyLl9fdSsrfHxjfHxyLnNldFN0YXRlKHtfX2U6ci5fX2I9ci5fX3YuX19rWzBdfSksbi50aGVuKGksaSk7fSxMLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudD1mdW5jdGlvbigpe3RoaXMudD1bXTt9LEwucHJvdG90eXBlLnJlbmRlcj1mdW5jdGlvbihuLHQpe2lmKHRoaXMuX19iKXtpZih0aGlzLl9fdi5fX2spe3ZhciBlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikscj10aGlzLl9fdi5fX2tbMF0uX19jO3RoaXMuX192Ll9fa1swXT1mdW5jdGlvbiBuKHQsZSxyKXtyZXR1cm4gdCYmKHQuX19jJiZ0Ll9fYy5fX0gmJih0Ll9fYy5fX0guX18uZm9yRWFjaChmdW5jdGlvbihuKXtcImZ1bmN0aW9uXCI9PXR5cGVvZiBuLl9fYyYmbi5fX2MoKTt9KSx0Ll9fYy5fX0g9bnVsbCksbnVsbCE9KHQ9Uyh7fSx0KSkuX19jJiYodC5fX2MuX19QPT09ciYmKHQuX19jLl9fUD1lKSx0Ll9fYz1udWxsKSx0Ll9faz10Ll9fayYmdC5fX2subWFwKGZ1bmN0aW9uKHQpe3JldHVybiBuKHQsZSxyKX0pKSx0fSh0aGlzLl9fYixlLHIuX19PPXIuX19QKTt9dGhpcy5fX2I9bnVsbDt9dmFyIHU9dC5fX2UmJmNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsbnVsbCxuLmZhbGxiYWNrKTtyZXR1cm4gdSYmKHUuX19oPW51bGwpLFtjcmVhdGVFbGVtZW50KEZyYWdtZW50LG51bGwsdC5fX2U/bnVsbDpuLmNoaWxkcmVuKSx1XX07dmFyIFQkMT1mdW5jdGlvbihuLHQsZSl7aWYoKytlWzFdPT09ZVswXSYmbi5vLmRlbGV0ZSh0KSxuLnByb3BzLnJldmVhbE9yZGVyJiYoXCJ0XCIhPT1uLnByb3BzLnJldmVhbE9yZGVyWzBdfHwhbi5vLnNpemUpKWZvcihlPW4udTtlOyl7Zm9yKDtlLmxlbmd0aD4zOyllLnBvcCgpKCk7aWYoZVsxXTxlWzBdKWJyZWFrO24udT1lPWVbMl07fX07ZnVuY3Rpb24gRChuKXtyZXR1cm4gdGhpcy5nZXRDaGlsZENvbnRleHQ9ZnVuY3Rpb24oKXtyZXR1cm4gbi5jb250ZXh0fSxuLmNoaWxkcmVufWZ1bmN0aW9uIEkobil7dmFyIHQ9dGhpcyxlPW4uaTt0LmNvbXBvbmVudFdpbGxVbm1vdW50PWZ1bmN0aW9uKCl7cmVuZGVyKG51bGwsdC5sKSx0Lmw9bnVsbCx0Lmk9bnVsbDt9LHQuaSYmdC5pIT09ZSYmdC5jb21wb25lbnRXaWxsVW5tb3VudCgpLG4uX192Pyh0Lmx8fCh0Lmk9ZSx0Lmw9e25vZGVUeXBlOjEscGFyZW50Tm9kZTplLGNoaWxkTm9kZXM6W10sYXBwZW5kQ2hpbGQ6ZnVuY3Rpb24obil7dGhpcy5jaGlsZE5vZGVzLnB1c2gobiksdC5pLmFwcGVuZENoaWxkKG4pO30saW5zZXJ0QmVmb3JlOmZ1bmN0aW9uKG4sZSl7dGhpcy5jaGlsZE5vZGVzLnB1c2gobiksdC5pLmFwcGVuZENoaWxkKG4pO30scmVtb3ZlQ2hpbGQ6ZnVuY3Rpb24obil7dGhpcy5jaGlsZE5vZGVzLnNwbGljZSh0aGlzLmNoaWxkTm9kZXMuaW5kZXhPZihuKT4+PjEsMSksdC5pLnJlbW92ZUNoaWxkKG4pO319KSxyZW5kZXIoY3JlYXRlRWxlbWVudChELHtjb250ZXh0OnQuY29udGV4dH0sbi5fX3YpLHQubCkpOnQubCYmdC5jb21wb25lbnRXaWxsVW5tb3VudCgpO31mdW5jdGlvbiBXKG4sdCl7cmV0dXJuIGNyZWF0ZUVsZW1lbnQoSSx7X192Om4saTp0fSl9KE0ucHJvdG90eXBlPW5ldyBDb21wb25lbnQkMSkuX19lPWZ1bmN0aW9uKG4pe3ZhciB0PXRoaXMsZT1VKHQuX192KSxyPXQuby5nZXQobik7cmV0dXJuIHJbMF0rKyxmdW5jdGlvbih1KXt2YXIgbz1mdW5jdGlvbigpe3QucHJvcHMucmV2ZWFsT3JkZXI/KHIucHVzaCh1KSxUJDEodCxuLHIpKTp1KCk7fTtlP2Uobyk6bygpO319LE0ucHJvdG90eXBlLnJlbmRlcj1mdW5jdGlvbihuKXt0aGlzLnU9bnVsbCx0aGlzLm89bmV3IE1hcDt2YXIgdD10b0NoaWxkQXJyYXkobi5jaGlsZHJlbik7bi5yZXZlYWxPcmRlciYmXCJiXCI9PT1uLnJldmVhbE9yZGVyWzBdJiZ0LnJldmVyc2UoKTtmb3IodmFyIGU9dC5sZW5ndGg7ZS0tOyl0aGlzLm8uc2V0KHRbZV0sdGhpcy51PVsxLDAsdGhpcy51XSk7cmV0dXJuIG4uY2hpbGRyZW59LE0ucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZT1NLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudD1mdW5jdGlvbigpe3ZhciBuPXRoaXM7dGhpcy5vLmZvckVhY2goZnVuY3Rpb24odCxlKXtUJDEobixlLHQpO30pO307dmFyIGokMT1cInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sJiZTeW1ib2wuZm9yJiZTeW1ib2wuZm9yKFwicmVhY3QuZWxlbWVudFwiKXx8NjAxMDMsUD0vXig/OmFjY2VudHxhbGlnbm1lbnR8YXJhYmljfGJhc2VsaW5lfGNhcHxjbGlwKD8hUGF0aFUpfGNvbG9yfGRvbWluYW50fGZpbGx8Zmxvb2R8Zm9udHxnbHlwaCg/IVIpfGhvcml6fG1hcmtlcig/IUh8V3xVKXxvdmVybGluZXxwYWludHxzdG9wfHN0cmlrZXRocm91Z2h8c3Ryb2tlfHRleHQoPyFMKXx1bmRlcmxpbmV8dW5pY29kZXx1bml0c3x2fHZlY3Rvcnx2ZXJ0fHdvcmR8d3JpdGluZ3x4KD8hQykpW0EtWl0vLFY9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGRvY3VtZW50LHo9ZnVuY3Rpb24obil7cmV0dXJuIChcInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sKCk/L2ZpbHxjaGV8cmFkL2k6L2ZpbHxjaGV8cmEvaSkudGVzdChuKX07ZnVuY3Rpb24gQihuLHQsZSl7cmV0dXJuIG51bGw9PXQuX19rJiYodC50ZXh0Q29udGVudD1cIlwiKSxyZW5kZXIobix0KSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBlJiZlKCksbj9uLl9fYzpudWxsfWZ1bmN0aW9uICQobix0LGUpe3JldHVybiBoeWRyYXRlKG4sdCksXCJmdW5jdGlvblwiPT10eXBlb2YgZSYmZSgpLG4/bi5fX2M6bnVsbH1Db21wb25lbnQkMS5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudD17fSxbXCJjb21wb25lbnRXaWxsTW91bnRcIixcImNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNcIixcImNvbXBvbmVudFdpbGxVcGRhdGVcIl0uZm9yRWFjaChmdW5jdGlvbihuKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcG9uZW50JDEucHJvdG90eXBlLG4se2NvbmZpZ3VyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc1tcIlVOU0FGRV9cIituXX0sc2V0OmZ1bmN0aW9uKHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLG4se2NvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp0fSk7fX0pO30pO3ZhciBIPW9wdGlvbnMuZXZlbnQ7ZnVuY3Rpb24gWigpe31mdW5jdGlvbiBZKCl7cmV0dXJuIHRoaXMuY2FuY2VsQnViYmxlfWZ1bmN0aW9uIHEoKXtyZXR1cm4gdGhpcy5kZWZhdWx0UHJldmVudGVkfW9wdGlvbnMuZXZlbnQ9ZnVuY3Rpb24obil7cmV0dXJuIEgmJihuPUgobikpLG4ucGVyc2lzdD1aLG4uaXNQcm9wYWdhdGlvblN0b3BwZWQ9WSxuLmlzRGVmYXVsdFByZXZlbnRlZD1xLG4ubmF0aXZlRXZlbnQ9bn07dmFyIEcsSj17Y29uZmlndXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNsYXNzfX0sSz1vcHRpb25zLnZub2RlO29wdGlvbnMudm5vZGU9ZnVuY3Rpb24obil7dmFyIHQ9bi50eXBlLGU9bi5wcm9wcyxyPWU7aWYoXCJzdHJpbmdcIj09dHlwZW9mIHQpe3ZhciB1PS0xPT09dC5pbmRleE9mKFwiLVwiKTtmb3IodmFyIG8gaW4gcj17fSxlKXt2YXIgaT1lW29dO1YmJlwiY2hpbGRyZW5cIj09PW8mJlwibm9zY3JpcHRcIj09PXR8fFwidmFsdWVcIj09PW8mJlwiZGVmYXVsdFZhbHVlXCJpbiBlJiZudWxsPT1pfHwoXCJkZWZhdWx0VmFsdWVcIj09PW8mJlwidmFsdWVcImluIGUmJm51bGw9PWUudmFsdWU/bz1cInZhbHVlXCI6XCJkb3dubG9hZFwiPT09byYmITA9PT1pP2k9XCJcIjovb25kb3VibGVjbGljay9pLnRlc3Qobyk/bz1cIm9uZGJsY2xpY2tcIjovXm9uY2hhbmdlKHRleHRhcmVhfGlucHV0KS9pLnRlc3Qobyt0KSYmIXooZS50eXBlKT9vPVwib25pbnB1dFwiOi9eb25mb2N1cyQvaS50ZXN0KG8pP289XCJvbmZvY3VzaW5cIjovXm9uYmx1ciQvaS50ZXN0KG8pP289XCJvbmZvY3Vzb3V0XCI6L15vbihBbml8VHJhfFRvdXxCZWZvcmVJbnApLy50ZXN0KG8pP289by50b0xvd2VyQ2FzZSgpOnUmJlAudGVzdChvKT9vPW8ucmVwbGFjZSgvW0EtWjAtOV0vLFwiLSQmXCIpLnRvTG93ZXJDYXNlKCk6bnVsbD09PWkmJihpPXZvaWQgMCkscltvXT1pKTt9XCJzZWxlY3RcIj09dCYmci5tdWx0aXBsZSYmQXJyYXkuaXNBcnJheShyLnZhbHVlKSYmKHIudmFsdWU9dG9DaGlsZEFycmF5KGUuY2hpbGRyZW4pLmZvckVhY2goZnVuY3Rpb24obil7bi5wcm9wcy5zZWxlY3RlZD0tMSE9ci52YWx1ZS5pbmRleE9mKG4ucHJvcHMudmFsdWUpO30pKSxcInNlbGVjdFwiPT10JiZudWxsIT1yLmRlZmF1bHRWYWx1ZSYmKHIudmFsdWU9dG9DaGlsZEFycmF5KGUuY2hpbGRyZW4pLmZvckVhY2goZnVuY3Rpb24obil7bi5wcm9wcy5zZWxlY3RlZD1yLm11bHRpcGxlPy0xIT1yLmRlZmF1bHRWYWx1ZS5pbmRleE9mKG4ucHJvcHMudmFsdWUpOnIuZGVmYXVsdFZhbHVlPT1uLnByb3BzLnZhbHVlO30pKSxuLnByb3BzPXIsZS5jbGFzcyE9ZS5jbGFzc05hbWUmJihKLmVudW1lcmFibGU9XCJjbGFzc05hbWVcImluIGUsbnVsbCE9ZS5jbGFzc05hbWUmJihyLmNsYXNzPWUuY2xhc3NOYW1lKSxPYmplY3QuZGVmaW5lUHJvcGVydHkocixcImNsYXNzTmFtZVwiLEopKTt9bi4kJHR5cGVvZj1qJDEsSyYmSyhuKTt9O3ZhciBRPW9wdGlvbnMuX19yO29wdGlvbnMuX19yPWZ1bmN0aW9uKG4pe1EmJlEobiksRz1uLl9fYzt9O3ZhciBYPXtSZWFjdEN1cnJlbnREaXNwYXRjaGVyOntjdXJyZW50OntyZWFkQ29udGV4dDpmdW5jdGlvbihuKXtyZXR1cm4gRy5fX25bbi5fX2NdLnByb3BzLnZhbHVlfX19fTtmdW5jdGlvbiB0bihuKXtyZXR1cm4gY3JlYXRlRWxlbWVudC5iaW5kKG51bGwsbil9ZnVuY3Rpb24gZW4obil7cmV0dXJuICEhbiYmbi4kJHR5cGVvZj09PWokMX1mdW5jdGlvbiBybihuKXtyZXR1cm4gZW4obik/Y2xvbmVFbGVtZW50LmFwcGx5KG51bGwsYXJndW1lbnRzKTpufWZ1bmN0aW9uIHVuKG4pe3JldHVybiAhIW4uX19rJiYocmVuZGVyKG51bGwsbiksITApfWZ1bmN0aW9uIG9uKG4pe3JldHVybiBuJiYobi5iYXNlfHwxPT09bi5ub2RlVHlwZSYmbil8fG51bGx9dmFyIGxuPWZ1bmN0aW9uKG4sdCl7cmV0dXJuIG4odCl9LGNuPWZ1bmN0aW9uKG4sdCl7cmV0dXJuIG4odCl9O3ZhciBSZWFjdF9fZGVmYXVsdCA9IHt1c2VTdGF0ZTpsLHVzZVJlZHVjZXI6cCx1c2VFZmZlY3Q6eSx1c2VMYXlvdXRFZmZlY3Q6aCx1c2VSZWY6cyx1c2VJbXBlcmF0aXZlSGFuZGxlOl8sdXNlTWVtbzpkLHVzZUNhbGxiYWNrOkEsdXNlQ29udGV4dDpGLHVzZURlYnVnVmFsdWU6VCx2ZXJzaW9uOlwiMTcuMC4yXCIsQ2hpbGRyZW46ayQxLHJlbmRlcjpCLGh5ZHJhdGU6JCx1bm1vdW50Q29tcG9uZW50QXROb2RlOnVuLGNyZWF0ZVBvcnRhbDpXLGNyZWF0ZUVsZW1lbnQ6Y3JlYXRlRWxlbWVudCxjcmVhdGVDb250ZXh0OmNyZWF0ZUNvbnRleHQsY3JlYXRlRmFjdG9yeTp0bixjbG9uZUVsZW1lbnQ6cm4sY3JlYXRlUmVmOmNyZWF0ZVJlZixGcmFnbWVudDpGcmFnbWVudCxpc1ZhbGlkRWxlbWVudDplbixmaW5kRE9NTm9kZTpvbixDb21wb25lbnQ6Q29tcG9uZW50JDEsUHVyZUNvbXBvbmVudDpFLG1lbW86ZyQxLGZvcndhcmRSZWY6eCQxLGZsdXNoU3luYzpjbix1bnN0YWJsZV9iYXRjaGVkVXBkYXRlczpsbixTdHJpY3RNb2RlOkZyYWdtZW50LFN1c3BlbnNlOkwsU3VzcGVuc2VMaXN0Ok0sbGF6eTpGJDEsX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ6WH07XG5cbi8qXG5Db3B5cmlnaHQgKGMpIE5BVkVSIENvcnAuXG5uYW1lOiBAZWdqcy9jb21wb25lbnRcbmxpY2Vuc2U6IE1JVFxuYXV0aG9yOiBOQVZFUiBDb3JwLlxucmVwb3NpdG9yeTogaHR0cHM6Ly9naXRodWIuY29tL25hdmVyL2VnanMtY29tcG9uZW50XG52ZXJzaW9uOiAzLjAuNFxuKi9cbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG5mdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XG4gIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvcixcbiAgICBtID0gcyAmJiBvW3NdLFxuICAgIGkgPSAwO1xuICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xuICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogbyAmJiBvW2krK10sXG4gICAgICAgIGRvbmU6ICFvXG4gICAgICB9O1xuICAgIH1cbiAgfTtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xufVxuZnVuY3Rpb24gX19yZWFkKG8sIG4pIHtcbiAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICBpZiAoIW0pIHJldHVybiBvO1xuICB2YXIgaSA9IG0uY2FsbChvKSxcbiAgICByLFxuICAgIGFyID0gW10sXG4gICAgZTtcbiAgdHJ5IHtcbiAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBlID0ge1xuICAgICAgZXJyb3I6IGVycm9yXG4gICAgfTtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChlKSB0aHJvdyBlLmVycm9yO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYXI7XG59XG5mdW5jdGlvbiBfX3NwcmVhZCgpIHtcbiAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIGFyID0gYXIuY29uY2F0KF9fcmVhZChhcmd1bWVudHNbaV0pKTtcbiAgcmV0dXJuIGFyO1xufVxuXG4vKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IE5BVkVSIENvcnAuXG4gKiBlZ2pzIHByb2plY3RzIGFyZSBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xudmFyIGlzVW5kZWZpbmVkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCI7XG59O1xuXG4vLyBUaGlzIGNsYXNzIG5hbWUgaXMgbm90IG1hdGNoZWQgdG8gZmlsZSBuYW1lIGludGVudGlvbmFsbHlcbi8qKlxuICogRXZlbnQgY2xhc3MgdG8gcHJvdmlkZSBhZGRpdGlvbmFsIHByb3BlcnRpZXNcbiAqIEBrbyBDb21wb25lbnTsl5DshJwg7LaU6rCA7KCB7J24IO2UhOuhnO2NvO2LsOulvCDsoJzqs7XtlZjripQg7J2067Kk7Yq4IO2BtOuemOyKpFxuICovXG52YXIgQ29tcG9uZW50RXZlbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIENvbXBvbmVudEV2ZW50LlxuICAgKiBAa28gQ29tcG9uZW50RXZlbnTsnZgg7IOI66Gc7Jq0IOyduOyKpO2EtOyKpOulvCDsg53shLHtlZzri6QuXG4gICAqIEBwYXJhbSBldmVudFR5cGUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50Ljxrbz7snbTrsqTtirgg7J2066aELjwva28+XG4gICAqIEBwYXJhbSBwcm9wcyBBbiBvYmplY3QgdGhhdCBjb250YWlucyBhZGRpdGlvbmFsIGV2ZW50IHByb3BlcnRpZXMuPGtvPuy2lOqwgOyggeyduCDsnbTrsqTtirgg7ZSE66Gc7Y287YuwIOyYpOu4jOygne2KuC48L2tvPlxuICAgKi9cbiAgZnVuY3Rpb24gQ29tcG9uZW50RXZlbnQoZXZlbnRUeXBlLCBwcm9wcykge1xuICAgIHZhciBlXzEsIF9hO1xuICAgIHRoaXMuX2NhbmNlbGVkID0gZmFsc2U7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfYiA9IF9fdmFsdWVzKE9iamVjdC5rZXlzKHByb3BzKSksIF9jID0gX2IubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYi5uZXh0KCkpIHtcbiAgICAgICAgICB2YXIga2V5ID0gX2MudmFsdWU7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudFxuICAgICAgICAgIHRoaXNba2V5XSA9IHByb3BzW2tleV07XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVfMV8xKSB7XG4gICAgICAgIGVfMSA9IHtcbiAgICAgICAgICBlcnJvcjogZV8xXzFcbiAgICAgICAgfTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmV2ZW50VHlwZSA9IGV2ZW50VHlwZTtcbiAgfVxuICAvKipcbiAgICogU3RvcCB0aGUgZXZlbnQuIHtAbGluayBDb21wb25lbnRFdmVudCNpc0NhbmNlbGVkfSB3aWxsIHJldHVybiBgdHJ1ZWAgYWZ0ZXIuXG4gICAqIEBrbyDsnbTrsqTtirjrpbwg7KSR64uo7ZWc64ukLiDsnbTtm4Qge0BsaW5rIENvbXBvbmVudEV2ZW50I2lzQ2FuY2VsZWR96rCAIGB0cnVlYOulvCDrsJjtmZjtlZzri6QuXG4gICAqL1xuICB2YXIgX19wcm90byA9IENvbXBvbmVudEV2ZW50LnByb3RvdHlwZTtcbiAgX19wcm90by5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2NhbmNlbGVkID0gdHJ1ZTtcbiAgfTtcbiAgLyoqXG4gICAqIFJldHVybnMgYSBib29sZWFuIHZhbHVlIHRoYXQgaW5kaWNhdGVzIHdoZXRoZXIge0BsaW5rIENvbXBvbmVudEV2ZW50I3N0b3B9IGlzIGNhbGxlZCBiZWZvcmUuXG4gICAqIEBrbyB7QGxpbmsgQ29tcG9uZW50RXZlbnQjc3RvcH3snbQg7Zi47Lac65CY7JeI64qU7KeAIOyXrOu2gOulvCDrsJjtmZjtlZzri6QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IEEgYm9vbGVhbiB2YWx1ZSB0aGF0IGluZGljYXRlcyB3aGV0aGVyIHtAbGluayBDb21wb25lbnRFdmVudCNzdG9wfSBpcyBjYWxsZWQgYmVmb3JlLjxrbz7snbTsoITsl5Age0BsaW5rIENvbXBvbmVudEV2ZW50I3N0b3B97J20IOu2iOugpOyhjOuKlOyngCDsl6zrtoDrpbwg67CY7ZmY7ZWc64ukLjwva28+XG4gICAqL1xuICBfX3Byb3RvLmlzQ2FuY2VsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbmNlbGVkO1xuICB9O1xuICByZXR1cm4gQ29tcG9uZW50RXZlbnQ7XG59KCk7XG5cbi8qKlxuICogQSBjbGFzcyB1c2VkIHRvIG1hbmFnZSBldmVudHMgaW4gYSBjb21wb25lbnRcbiAqIEBrbyDsu7Ttj6zrhIztirjsnZgg7J2067Kk7Yq47J2EIOq0gOumrO2VoCDsiJgg7J6I6rKMIO2VmOuKlCDtgbTrnpjsiqRcbiAqL1xudmFyIENvbXBvbmVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAc3VwcG9ydCB7XCJpZVwiOiBcIjcrXCIsIFwiY2hcIiA6IFwibGF0ZXN0XCIsIFwiZmZcIiA6IFwibGF0ZXN0XCIsICBcInNmXCIgOiBcImxhdGVzdFwiLCBcImVkZ2VcIiA6IFwibGF0ZXN0XCIsIFwiaW9zXCIgOiBcIjcrXCIsIFwiYW5cIiA6IFwiMi4xKyAoZXhjZXB0IDMueClcIn1cbiAgICovXG4gIGZ1bmN0aW9uIENvbXBvbmVudCgpIHtcbiAgICB0aGlzLl9ldmVudEhhbmRsZXIgPSB7fTtcbiAgfVxuICAvKipcbiAgICogVHJpZ2dlciBhIGN1c3RvbSBldmVudC5cbiAgICogQGtvIOy7pOyKpO2FgCDsnbTrsqTtirjrpbwg67Cc7IOd7Iuc7YKo64ukXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgQ29tcG9uZW50RXZlbnR9IGV2ZW50IFRoZSBuYW1lIG9mIHRoZSBjdXN0b20gZXZlbnQgdG8gYmUgdHJpZ2dlcmVkIG9yIGFuIGluc3RhbmNlIG9mIHRoZSBDb21wb25lbnRFdmVudDxrbz7rsJzsg53tlaAg7Luk7Iqk7YWAIOydtOuypO2KuOydmCDsnbTrpoQg65iQ64qUIENvbXBvbmVudEV2ZW507J2YIOyduOyKpO2EtOyKpDwva28+XG4gICAqIEBwYXJhbSB7YW55W119IHBhcmFtcyBFdmVudCBkYXRhIHRvIGJlIHNlbnQgd2hlbiB0cmlnZ2VyaW5nIGEgY3VzdG9tIGV2ZW50IDxrbz7su6TsiqTthYAg7J2067Kk7Yq46rCAIOuwnOyDne2VoCDrlYwg7KCE64us7ZWgIOuNsOydtO2EsDwva28+XG4gICAqIEByZXR1cm4gQW4gaW5zdGFuY2Ugb2YgdGhlIGNvbXBvbmVudCBpdHNlbGY8a28+7Lu07Y+s64SM7Yq4IOyekOyLoOydmCDsnbjsiqTthLTsiqQ8L2tvPlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c1xuICAgKiBpbXBvcnQgQ29tcG9uZW50LCB7IENvbXBvbmVudEV2ZW50IH0gZnJvbSBcIkBlZ2pzL2NvbXBvbmVudFwiO1xuICAgKlxuICAgKiBjbGFzcyBTb21lIGV4dGVuZHMgQ29tcG9uZW50PHtcbiAgICogICBiZWZvcmVIaTogQ29tcG9uZW50RXZlbnQ8eyBmb286IG51bWJlcjsgYmFyOiBzdHJpbmcgfT47XG4gICAqICAgaGk6IHsgZm9vOiB7IGE6IG51bWJlcjsgYjogYm9vbGVhbiB9IH07XG4gICAqICAgc29tZUV2ZW50OiAoZm9vOiBudW1iZXIsIGJhcjogc3RyaW5nKSA9PiB2b2lkO1xuICAgKiAgIHNvbWVPdGhlckV2ZW50OiB2b2lkOyAvLyBXaGVuIHRoZXJlJ3Mgbm8gZXZlbnQgYXJndW1lbnRcbiAgICogfT4ge1xuICAgKiAgIHNvbWUoKXtcbiAgICogICAgIGlmKHRoaXMudHJpZ2dlcihcImJlZm9yZUhpXCIpKXsgLy8gV2hlbiBldmVudCBjYWxsIHRvIHN0b3AgcmV0dXJuIGZhbHNlLlxuICAgKiAgICAgICB0aGlzLnRyaWdnZXIoXCJoaVwiKTsvLyBmaXJlIGhpIGV2ZW50LlxuICAgKiAgICAgfVxuICAgKiAgIH1cbiAgICogfVxuICAgKlxuICAgKiBjb25zdCBzb21lID0gbmV3IFNvbWUoKTtcbiAgICogc29tZS5vbihcImJlZm9yZUhpXCIsIGUgPT4ge1xuICAgKiAgIGlmKGNvbmRpdGlvbil7XG4gICAqICAgICBlLnN0b3AoKTsgLy8gV2hlbiBldmVudCBjYWxsIHRvIHN0b3AsIGBoaWAgZXZlbnQgbm90IGNhbGwuXG4gICAqICAgfVxuICAgKiAgIC8vIGBjdXJyZW50VGFyZ2V0YCBpcyBjb21wb25lbnQgaW5zdGFuY2UuXG4gICAqICAgY29uc29sZS5sb2coc29tZSA9PT0gZS5jdXJyZW50VGFyZ2V0KTsgLy8gdHJ1ZVxuICAgKlxuICAgKiAgIHR5cGVvZiBlLmZvbzsgLy8gbnVtYmVyXG4gICAqICAgdHlwZW9mIGUuYmFyOyAvLyBzdHJpbmdcbiAgICogfSk7XG4gICAqIHNvbWUub24oXCJoaVwiLCBlID0+IHtcbiAgICogICB0eXBlb2YgZS5mb28uYjsgLy8gYm9vbGVhblxuICAgKiB9KTtcbiAgICogLy8gSWYgeW91IHdhbnQgdG8gbW9yZSBrbm93IGV2ZW50IGRlc2lnbi4gWW91IGNhbiBzZWUgYXJ0aWNsZS5cbiAgICogLy8gaHR0cHM6Ly9naXRodWIuY29tL25hdmVyL2VnanMtY29tcG9uZW50L3dpa2kvSG93LXRvLW1ha2UtQ29tcG9uZW50LWV2ZW50LWRlc2lnbiUzRlxuICAgKiBgYGBcbiAgICovXG4gIHZhciBfX3Byb3RvID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbiAgX19wcm90by50cmlnZ2VyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIHBhcmFtcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICBwYXJhbXNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciBldmVudE5hbWUgPSBldmVudCBpbnN0YW5jZW9mIENvbXBvbmVudEV2ZW50ID8gZXZlbnQuZXZlbnRUeXBlIDogZXZlbnQ7XG4gICAgdmFyIGhhbmRsZXJzID0gX19zcHJlYWQodGhpcy5fZXZlbnRIYW5kbGVyW2V2ZW50TmFtZV0gfHwgW10pO1xuICAgIGlmIChoYW5kbGVycy5sZW5ndGggPD0gMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmIChldmVudCBpbnN0YW5jZW9mIENvbXBvbmVudEV2ZW50KSB7XG4gICAgICBldmVudC5jdXJyZW50VGFyZ2V0ID0gdGhpcztcbiAgICAgIGhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICAgICAgaGFuZGxlcihldmVudCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1jYWxsXG4gICAgICAgIGhhbmRsZXIuYXBwbHkodm9pZCAwLCBfX3NwcmVhZChwYXJhbXMpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXG4gICAqIEV4ZWN1dGVkIGV2ZW50IGp1c3Qgb25lIHRpbWUuXG4gICAqIEBrbyDsnbTrsqTtirjqsIAg7ZWc67KI66eMIOyLpO2WieuQnOuLpC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gYmUgYXR0YWNoZWQgb3IgYW4gZXZlbnQgbmFtZSAtIGV2ZW50IGhhbmRsZXIgbWFwcGVkIG9iamVjdC48a28+65Ox66Gd7ZWgIOydtOuypO2KuOydmCDsnbTrpoQg65iQ64qUIOydtOuypO2KuCDsnbTrpoQt7ZW465Ok65+sIOyYpOu4jOygne2KuDwva28+XG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGhhbmRsZXJUb0F0dGFjaCBUaGUgaGFuZGxlciBmdW5jdGlvbiBvZiB0aGUgZXZlbnQgdG8gYmUgYXR0YWNoZWQgPGtvPuuTseuhne2VoCDsnbTrsqTtirjsnZgg7ZW465Ok65+sIO2VqOyImDwva28+XG4gICAqIEByZXR1cm4gQW4gaW5zdGFuY2Ugb2YgdGhlIGNvbXBvbmVudCBpdHNlbGY8a28+7Lu07Y+s64SM7Yq4IOyekOyLoOydmCDsnbjsiqTthLTsiqQ8L2tvPlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c1xuICAgKiBpbXBvcnQgQ29tcG9uZW50LCB7IENvbXBvbmVudEV2ZW50IH0gZnJvbSBcIkBlZ2pzL2NvbXBvbmVudFwiO1xuICAgKlxuICAgKiBjbGFzcyBTb21lIGV4dGVuZHMgQ29tcG9uZW50PHtcbiAgICogICBoaTogQ29tcG9uZW50RXZlbnQ7XG4gICAqIH0+IHtcbiAgICogICBoaSgpIHtcbiAgICogICAgIGFsZXJ0KFwiaGlcIik7XG4gICAqICAgfVxuICAgKiAgIHRoaW5nKCkge1xuICAgKiAgICAgdGhpcy5vbmNlKFwiaGlcIiwgdGhpcy5oaSk7XG4gICAqICAgfVxuICAgKiB9XG4gICAqXG4gICAqIHZhciBzb21lID0gbmV3IFNvbWUoKTtcbiAgICogc29tZS50aGluZygpO1xuICAgKiBzb21lLnRyaWdnZXIobmV3IENvbXBvbmVudEV2ZW50KFwiaGlcIikpO1xuICAgKiAvLyBmaXJlIGFsZXJ0KFwiaGlcIik7XG4gICAqIHNvbWUudHJpZ2dlcihuZXcgQ29tcG9uZW50RXZlbnQoXCJoaVwiKSk7XG4gICAqIC8vIE5vdGhpbmcgaGFwcGVuc1xuICAgKiBgYGBcbiAgICovXG4gIF9fcHJvdG8ub25jZSA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGhhbmRsZXJUb0F0dGFjaCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgaWYgKHR5cGVvZiBldmVudE5hbWUgPT09IFwib2JqZWN0XCIgJiYgaXNVbmRlZmluZWQoaGFuZGxlclRvQXR0YWNoKSkge1xuICAgICAgdmFyIGV2ZW50SGFzaCA9IGV2ZW50TmFtZTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBldmVudEhhc2gpIHtcbiAgICAgICAgdGhpcy5vbmNlKGtleSwgZXZlbnRIYXNoW2tleV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXZlbnROYW1lID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiBoYW5kbGVyVG9BdHRhY2ggPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdmFyIGxpc3RlbmVyXzEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWNhbGxcbiAgICAgICAgaGFuZGxlclRvQXR0YWNoLmFwcGx5KHZvaWQgMCwgX19zcHJlYWQoYXJncykpO1xuICAgICAgICBfdGhpcy5vZmYoZXZlbnROYW1lLCBsaXN0ZW5lcl8xKTtcbiAgICAgIH07XG4gICAgICB0aGlzLm9uKGV2ZW50TmFtZSwgbGlzdGVuZXJfMSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgYW4gZXZlbnQgaGFzIGJlZW4gYXR0YWNoZWQgdG8gYSBjb21wb25lbnQuXG4gICAqIEBrbyDsu7Ttj6zrhIztirjsl5Ag7J2067Kk7Yq46rCAIOuTseuhneuQkOuKlOyngCDtmZXsnbjtlZzri6QuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIGJlIGF0dGFjaGVkIDxrbz7rk7HroZ0g7Jes67aA66W8IO2ZleyduO2VoCDsnbTrsqTtirjsnZgg7J2066aEPC9rbz5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGV2ZW50IGlzIGF0dGFjaGVkLiA8a28+7J2067Kk7Yq4IOuTseuhnSDsl6zrtoA8L2tvPlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c1xuICAgKiBpbXBvcnQgQ29tcG9uZW50IGZyb20gXCJAZWdqcy9jb21wb25lbnRcIjtcbiAgICpcbiAgICogY2xhc3MgU29tZSBleHRlbmRzIENvbXBvbmVudDx7XG4gICAqICAgaGk6IHZvaWQ7XG4gICAqIH0+IHtcbiAgICogICBzb21lKCkge1xuICAgKiAgICAgdGhpcy5oYXNPbihcImhpXCIpOy8vIGNoZWNrIGhpIGV2ZW50LlxuICAgKiAgIH1cbiAgICogfVxuICAgKiBgYGBcbiAgICovXG4gIF9fcHJvdG8uaGFzT24gPSBmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fZXZlbnRIYW5kbGVyW2V2ZW50TmFtZV07XG4gIH07XG4gIC8qKlxuICAgKiBBdHRhY2hlcyBhbiBldmVudCB0byBhIGNvbXBvbmVudC5cbiAgICogQGtvIOy7tO2PrOuEjO2KuOyXkCDsnbTrsqTtirjrpbwg65Ox66Gd7ZWc64ukLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBiZSBhdHRhY2hlZCBvciBhbiBldmVudCBuYW1lIC0gZXZlbnQgaGFuZGxlciBtYXBwZWQgb2JqZWN0Ljxrbz7rk7HroZ3tlaAg7J2067Kk7Yq47J2YIOydtOumhCDrmJDripQg7J2067Kk7Yq4IOydtOumhC3tlbjrk6Trn6wg7Jik67iM7KCd7Yq4PC9rbz5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gaGFuZGxlclRvQXR0YWNoIFRoZSBoYW5kbGVyIGZ1bmN0aW9uIG9mIHRoZSBldmVudCB0byBiZSBhdHRhY2hlZCA8a28+65Ox66Gd7ZWgIOydtOuypO2KuOydmCDtlbjrk6Trn6wg7ZWo7IiYPC9rbz5cbiAgICogQHJldHVybiBBbiBpbnN0YW5jZSBvZiBhIGNvbXBvbmVudCBpdHNlbGY8a28+7Lu07Y+s64SM7Yq4IOyekOyLoOydmCDsnbjsiqTthLTsiqQ8L2tvPlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c1xuICAgKiBpbXBvcnQgQ29tcG9uZW50LCB7IENvbXBvbmVudEV2ZW50IH0gZnJvbSBcIkBlZ2pzL2NvbXBvbmVudFwiO1xuICAgKlxuICAgKiBjbGFzcyBTb21lIGV4dGVuZHMgQ29tcG9uZW50PHtcbiAgICogICBoaTogdm9pZDtcbiAgICogfT4ge1xuICAgKiAgIGhpKCkge1xuICAgKiAgICAgY29uc29sZS5sb2coXCJoaVwiKTtcbiAgICogICB9XG4gICAqICAgc29tZSgpIHtcbiAgICogICAgIHRoaXMub24oXCJoaVwiLHRoaXMuaGkpOyAvL2F0dGFjaCBldmVudFxuICAgKiAgIH1cbiAgICogfVxuICAgKiBgYGBcbiAgICovXG4gIF9fcHJvdG8ub24gPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBoYW5kbGVyVG9BdHRhY2gpIHtcbiAgICBpZiAodHlwZW9mIGV2ZW50TmFtZSA9PT0gXCJvYmplY3RcIiAmJiBpc1VuZGVmaW5lZChoYW5kbGVyVG9BdHRhY2gpKSB7XG4gICAgICB2YXIgZXZlbnRIYXNoID0gZXZlbnROYW1lO1xuICAgICAgZm9yICh2YXIgbmFtZSBpbiBldmVudEhhc2gpIHtcbiAgICAgICAgdGhpcy5vbihuYW1lLCBldmVudEhhc2hbbmFtZV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXZlbnROYW1lID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiBoYW5kbGVyVG9BdHRhY2ggPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdmFyIGhhbmRsZXJMaXN0ID0gdGhpcy5fZXZlbnRIYW5kbGVyW2V2ZW50TmFtZV07XG4gICAgICBpZiAoaXNVbmRlZmluZWQoaGFuZGxlckxpc3QpKSB7XG4gICAgICAgIHRoaXMuX2V2ZW50SGFuZGxlcltldmVudE5hbWVdID0gW107XG4gICAgICAgIGhhbmRsZXJMaXN0ID0gdGhpcy5fZXZlbnRIYW5kbGVyW2V2ZW50TmFtZV07XG4gICAgICB9XG4gICAgICBoYW5kbGVyTGlzdC5wdXNoKGhhbmRsZXJUb0F0dGFjaCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogRGV0YWNoZXMgYW4gZXZlbnQgZnJvbSB0aGUgY29tcG9uZW50Ljxici8+SWYgdGhlIGBldmVudE5hbWVgIGlzIG5vdCBnaXZlbiB0aGlzIHdpbGwgZGV0YWNoIGFsbCBldmVudCBoYW5kbGVycyBhdHRhY2hlZC48YnIvPklmIHRoZSBgaGFuZGxlclRvRGV0YWNoYCBpcyBub3QgZ2l2ZW4sIHRoaXMgd2lsbCBkZXRhY2ggYWxsIGV2ZW50IGhhbmRsZXJzIGZvciBgZXZlbnROYW1lYC5cbiAgICogQGtvIOy7tO2PrOuEjO2KuOyXkCDrk7HroZ3rkJwg7J2067Kk7Yq466W8IO2VtOygnO2VnOuLpC48YnIvPmBldmVudE5hbWVg7J20IOyjvOyWtOyngOyngCDslYrslZjsnYQg6rK97JqwIOuqqOuToCDsnbTrsqTtirgg7ZW465Ok65+s66W8IOygnOqxsO2VnOuLpC48YnIvPmBoYW5kbGVyVG9BdHRhY2hg6rCAIOyjvOyWtOyngOyngCDslYrslZjsnYQg6rK97JqwIGBldmVudE5hbWVg7JeQIO2VtOuLue2VmOuKlCDrqqjrk6Ag7J2067Kk7Yq4IO2VuOuTpOufrOulvCDsoJzqsbDtlZzri6QuXG4gICAqIEBwYXJhbSB7c3RyaW5nP30gZXZlbnROYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBiZSBkZXRhY2hlZCA8a28+7ZW07KCc7ZWgIOydtOuypO2KuOydmCDsnbTrpoQ8L2tvPlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uP30gaGFuZGxlclRvRGV0YWNoIFRoZSBoYW5kbGVyIGZ1bmN0aW9uIG9mIHRoZSBldmVudCB0byBiZSBkZXRhY2hlZCA8a28+7ZW07KCc7ZWgIOydtOuypO2KuOydmCDtlbjrk6Trn6wg7ZWo7IiYPC9rbz5cbiAgICogQHJldHVybiBBbiBpbnN0YW5jZSBvZiBhIGNvbXBvbmVudCBpdHNlbGYgPGtvPuy7tO2PrOuEjO2KuCDsnpDsi6DsnZgg7J247Iqk7YS07IqkPC9rbz5cbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHNcbiAgICogaW1wb3J0IENvbXBvbmVudCwgeyBDb21wb25lbnRFdmVudCB9IGZyb20gXCJAZWdqcy9jb21wb25lbnRcIjtcbiAgICpcbiAgICogY2xhc3MgU29tZSBleHRlbmRzIENvbXBvbmVudDx7XG4gICAqICAgaGk6IHZvaWQ7XG4gICAqIH0+IHtcbiAgICogICBoaSgpIHtcbiAgICogICAgIGNvbnNvbGUubG9nKFwiaGlcIik7XG4gICAqICAgfVxuICAgKiAgIHNvbWUoKSB7XG4gICAqICAgICB0aGlzLm9mZihcImhpXCIsdGhpcy5oaSk7IC8vZGV0YWNoIGV2ZW50XG4gICAqICAgfVxuICAgKiB9XG4gICAqIGBgYFxuICAgKi9cbiAgX19wcm90by5vZmYgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBoYW5kbGVyVG9EZXRhY2gpIHtcbiAgICB2YXIgZV8xLCBfYTtcbiAgICAvLyBEZXRhY2ggYWxsIGV2ZW50IGhhbmRsZXJzLlxuICAgIGlmIChpc1VuZGVmaW5lZChldmVudE5hbWUpKSB7XG4gICAgICB0aGlzLl9ldmVudEhhbmRsZXIgPSB7fTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBEZXRhY2ggYWxsIGhhbmRsZXJzIGZvciBldmVudG5hbWUgb3IgZGV0YWNoIGV2ZW50IGhhbmRsZXJzIGJ5IG9iamVjdC5cbiAgICBpZiAoaXNVbmRlZmluZWQoaGFuZGxlclRvRGV0YWNoKSkge1xuICAgICAgaWYgKHR5cGVvZiBldmVudE5hbWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50SGFuZGxlcltldmVudE5hbWVdO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBldmVudEhhc2ggPSBldmVudE5hbWU7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gZXZlbnRIYXNoKSB7XG4gICAgICAgICAgdGhpcy5vZmYobmFtZSwgZXZlbnRIYXNoW25hbWVdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gRGV0YWNoIHNpbmdsZSBldmVudCBoYW5kbGVyXG4gICAgdmFyIGhhbmRsZXJMaXN0ID0gdGhpcy5fZXZlbnRIYW5kbGVyW2V2ZW50TmFtZV07XG4gICAgaWYgKGhhbmRsZXJMaXN0KSB7XG4gICAgICB2YXIgaWR4ID0gMDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIGhhbmRsZXJMaXN0XzEgPSBfX3ZhbHVlcyhoYW5kbGVyTGlzdCksIGhhbmRsZXJMaXN0XzFfMSA9IGhhbmRsZXJMaXN0XzEubmV4dCgpOyAhaGFuZGxlckxpc3RfMV8xLmRvbmU7IGhhbmRsZXJMaXN0XzFfMSA9IGhhbmRsZXJMaXN0XzEubmV4dCgpKSB7XG4gICAgICAgICAgdmFyIGhhbmRsZXJGdW5jdGlvbiA9IGhhbmRsZXJMaXN0XzFfMS52YWx1ZTtcbiAgICAgICAgICBpZiAoaGFuZGxlckZ1bmN0aW9uID09PSBoYW5kbGVyVG9EZXRhY2gpIHtcbiAgICAgICAgICAgIGhhbmRsZXJMaXN0LnNwbGljZShpZHgsIDEpO1xuICAgICAgICAgICAgaWYgKGhhbmRsZXJMaXN0Lmxlbmd0aCA8PSAwKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudEhhbmRsZXJbZXZlbnROYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZHgrKztcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZV8xXzEpIHtcbiAgICAgICAgZV8xID0ge1xuICAgICAgICAgIGVycm9yOiBlXzFfMVxuICAgICAgICB9O1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoaGFuZGxlckxpc3RfMV8xICYmICFoYW5kbGVyTGlzdF8xXzEuZG9uZSAmJiAoX2EgPSBoYW5kbGVyTGlzdF8xLnJldHVybikpIF9hLmNhbGwoaGFuZGxlckxpc3RfMSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogVmVyc2lvbiBpbmZvIHN0cmluZ1xuICAgKiBAa28g67KE7KCE7KCV67O0IOusuOyekOyXtFxuICAgKiBAbmFtZSBWRVJTSU9OXG4gICAqIEBzdGF0aWNcbiAgICogQGV4YW1wbGVcbiAgICogQ29tcG9uZW50LlZFUlNJT047ICAvLyBleCkgMy4wLjBcbiAgICogQG1lbWJlcm9mIENvbXBvbmVudFxuICAgKi9cbiAgQ29tcG9uZW50LlZFUlNJT04gPSBcIjMuMC40XCI7XG4gIHJldHVybiBDb21wb25lbnQ7XG59KCk7XG5cbi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgTkFWRVIgQ29ycC5cbiAqIGVnanMgcHJvamVjdHMgYXJlIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnRcbnZhciBDb21wb25lbnRFdmVudCQxID0gQ29tcG9uZW50RXZlbnQ7XG5cbi8qXG5Db3B5cmlnaHQgKGMpIDIwMTktcHJlc2VudCBOQVZFUiBDb3JwLlxubmFtZTogQGVnanMvbGlzdC1kaWZmZXJcbmxpY2Vuc2U6IE1JVFxuYXV0aG9yOiBOQVZFUiBDb3JwLlxucmVwb3NpdG9yeTogaHR0cHM6Ly9naXRodWIuY29tL25hdmVyL2VnanMtbGlzdC1kaWZmZXJcbnZlcnNpb246IDEuMC4xXG4qL1xuLypcbmVnanMtbGlzdC1kaWZmZXJcbkNvcHlyaWdodCAoYykgMjAxOS1wcmVzZW50IE5BVkVSIENvcnAuXG5NSVQgbGljZW5zZVxuKi9cbnZhciBQb2x5TWFwID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUG9seU1hcCgpIHtcbiAgICB0aGlzLmtleXMgPSBbXTtcbiAgICB0aGlzLnZhbHVlcyA9IFtdO1xuICB9XG5cbiAgdmFyIF9fcHJvdG8gPSBQb2x5TWFwLnByb3RvdHlwZTtcblxuICBfX3Byb3RvLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZXNbdGhpcy5rZXlzLmluZGV4T2Yoa2V5KV07XG4gIH07XG5cbiAgX19wcm90by5zZXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIHZhciBrZXlzID0gdGhpcy5rZXlzO1xuICAgIHZhciB2YWx1ZXMgPSB0aGlzLnZhbHVlcztcbiAgICB2YXIgcHJldkluZGV4ID0ga2V5cy5pbmRleE9mKGtleSk7XG4gICAgdmFyIGluZGV4ID0gcHJldkluZGV4ID09PSAtMSA/IGtleXMubGVuZ3RoIDogcHJldkluZGV4O1xuICAgIGtleXNbaW5kZXhdID0ga2V5O1xuICAgIHZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcbiAgfTtcblxuICByZXR1cm4gUG9seU1hcDtcbn0oKTtcblxuLypcbmVnanMtbGlzdC1kaWZmZXJcbkNvcHlyaWdodCAoYykgMjAxOS1wcmVzZW50IE5BVkVSIENvcnAuXG5NSVQgbGljZW5zZVxuKi9cbnZhciBIYXNoTWFwID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gSGFzaE1hcCgpIHtcbiAgICB0aGlzLm9iamVjdCA9IHt9O1xuICB9XG5cbiAgdmFyIF9fcHJvdG8gPSBIYXNoTWFwLnByb3RvdHlwZTtcblxuICBfX3Byb3RvLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5vYmplY3Rba2V5XTtcbiAgfTtcblxuICBfX3Byb3RvLnNldCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgdGhpcy5vYmplY3Rba2V5XSA9IHZhbHVlO1xuICB9O1xuXG4gIHJldHVybiBIYXNoTWFwO1xufSgpO1xuXG4vKlxuZWdqcy1saXN0LWRpZmZlclxuQ29weXJpZ2h0IChjKSAyMDE5LXByZXNlbnQgTkFWRVIgQ29ycC5cbk1JVCBsaWNlbnNlXG4qL1xudmFyIFNVUFBPUlRfTUFQID0gdHlwZW9mIE1hcCA9PT0gXCJmdW5jdGlvblwiO1xuXG4vKlxuZWdqcy1saXN0LWRpZmZlclxuQ29weXJpZ2h0IChjKSAyMDE5LXByZXNlbnQgTkFWRVIgQ29ycC5cbk1JVCBsaWNlbnNlXG4qL1xudmFyIExpbmsgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBMaW5rKCkge31cblxuICB2YXIgX19wcm90byA9IExpbmsucHJvdG90eXBlO1xuXG4gIF9fcHJvdG8uY29ubmVjdCA9IGZ1bmN0aW9uIChwcmV2TGluaywgbmV4dExpbmspIHtcbiAgICB0aGlzLnByZXYgPSBwcmV2TGluaztcbiAgICB0aGlzLm5leHQgPSBuZXh0TGluaztcbiAgICBwcmV2TGluayAmJiAocHJldkxpbmsubmV4dCA9IHRoaXMpO1xuICAgIG5leHRMaW5rICYmIChuZXh0TGluay5wcmV2ID0gdGhpcyk7XG4gIH07XG5cbiAgX19wcm90by5kaXNjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIEluIGRvdWJsZSBsaW5rZWQgbGlzdCwgZGljb25uZWN0IHRoZSBpbnRlcmNvbm5lY3RlZCByZWxhdGlvbnNoaXAuXG4gICAgdmFyIHByZXZMaW5rID0gdGhpcy5wcmV2O1xuICAgIHZhciBuZXh0TGluayA9IHRoaXMubmV4dDtcbiAgICBwcmV2TGluayAmJiAocHJldkxpbmsubmV4dCA9IG5leHRMaW5rKTtcbiAgICBuZXh0TGluayAmJiAobmV4dExpbmsucHJldiA9IHByZXZMaW5rKTtcbiAgfTtcblxuICBfX3Byb3RvLmdldEluZGV4ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBsaW5rID0gdGhpcztcbiAgICB2YXIgaW5kZXggPSAtMTtcblxuICAgIHdoaWxlIChsaW5rKSB7XG4gICAgICBsaW5rID0gbGluay5wcmV2O1xuICAgICAgKytpbmRleDtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5kZXg7XG4gIH07XG5cbiAgcmV0dXJuIExpbms7XG59KCk7XG5cbi8qXG5lZ2pzLWxpc3QtZGlmZmVyXG5Db3B5cmlnaHQgKGMpIDIwMTktcHJlc2VudCBOQVZFUiBDb3JwLlxuTUlUIGxpY2Vuc2VcbiovXG5cbmZ1bmN0aW9uIG9yZGVyQ2hhbmdlZChjaGFuZ2VkLCBmaXhlZCkge1xuICAvLyBJdCBpcyByb3VnaGx5IGluIHRoZSBvcmRlciBvZiB0aGVzZSBleGFtcGxlcy5cbiAgLy8gNCwgNiwgMCwgMiwgMSwgMywgNSwgN1xuICB2YXIgZnJvbUxpbmtzID0gW107IC8vIDAsIDEsIDIsIDMsIDQsIDUsIDYsIDdcblxuICB2YXIgdG9MaW5rcyA9IFtdO1xuICBjaGFuZ2VkLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIGZyb20gPSBfYVswXSxcbiAgICAgICAgdG8gPSBfYVsxXTtcbiAgICB2YXIgbGluayA9IG5ldyBMaW5rKCk7XG4gICAgZnJvbUxpbmtzW2Zyb21dID0gbGluaztcbiAgICB0b0xpbmtzW3RvXSA9IGxpbms7XG4gIH0pOyAvLyBgZnJvbUxpbmtzYCBhcmUgY29ubmVjdGVkIHRvIGVhY2ggb3RoZXIgYnkgZG91YmxlIGxpbmtlZCBsaXN0LlxuXG4gIGZyb21MaW5rcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5rLCBpKSB7XG4gICAgbGluay5jb25uZWN0KGZyb21MaW5rc1tpIC0gMV0pO1xuICB9KTtcbiAgcmV0dXJuIGNoYW5nZWQuZmlsdGVyKGZ1bmN0aW9uIChfLCBpKSB7XG4gICAgcmV0dXJuICFmaXhlZFtpXTtcbiAgfSkubWFwKGZ1bmN0aW9uIChfYSwgaSkge1xuICAgIHZhciBmcm9tID0gX2FbMF0sXG4gICAgICAgIHRvID0gX2FbMV07XG5cbiAgICBpZiAoZnJvbSA9PT0gdG8pIHtcbiAgICAgIHJldHVybiBbMCwgMF07XG4gICAgfVxuXG4gICAgdmFyIGZyb21MaW5rID0gZnJvbUxpbmtzW2Zyb21dO1xuICAgIHZhciB0b0xpbmsgPSB0b0xpbmtzW3RvIC0gMV07XG4gICAgdmFyIGZyb21JbmRleCA9IGZyb21MaW5rLmdldEluZGV4KCk7IC8vIERpc2Nvbm5lY3QgdGhlIGxpbmsgY29ubmVjdGVkIHRvIGBmcm9tTGlua2AuXG5cbiAgICBmcm9tTGluay5kaXNjb25uZWN0KCk7IC8vIENvbm5lY3QgYGZyb21MaW5rYCB0byB0aGUgcmlnaHQgb2YgYHRvTGlua2AuXG5cbiAgICBpZiAoIXRvTGluaykge1xuICAgICAgZnJvbUxpbmsuY29ubmVjdCh1bmRlZmluZWQsIGZyb21MaW5rc1swXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZyb21MaW5rLmNvbm5lY3QodG9MaW5rLCB0b0xpbmsubmV4dCk7XG4gICAgfVxuXG4gICAgdmFyIHRvSW5kZXggPSBmcm9tTGluay5nZXRJbmRleCgpO1xuICAgIHJldHVybiBbZnJvbUluZGV4LCB0b0luZGV4XTtcbiAgfSk7XG59XG5cbnZhciBSZXN1bHQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBSZXN1bHQocHJldkxpc3QsIGxpc3QsIGFkZGVkLCByZW1vdmVkLCBjaGFuZ2VkLCBtYWludGFpbmVkLCBjaGFuZ2VkQmVmb3JlQWRkZWQsIGZpeGVkKSB7XG4gICAgdGhpcy5wcmV2TGlzdCA9IHByZXZMaXN0O1xuICAgIHRoaXMubGlzdCA9IGxpc3Q7XG4gICAgdGhpcy5hZGRlZCA9IGFkZGVkO1xuICAgIHRoaXMucmVtb3ZlZCA9IHJlbW92ZWQ7XG4gICAgdGhpcy5jaGFuZ2VkID0gY2hhbmdlZDtcbiAgICB0aGlzLm1haW50YWluZWQgPSBtYWludGFpbmVkO1xuICAgIHRoaXMuY2hhbmdlZEJlZm9yZUFkZGVkID0gY2hhbmdlZEJlZm9yZUFkZGVkO1xuICAgIHRoaXMuZml4ZWQgPSBmaXhlZDtcbiAgfVxuXG4gIHZhciBfX3Byb3RvID0gUmVzdWx0LnByb3RvdHlwZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwib3JkZXJlZFwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXRoaXMuY2FjaGVPcmRlcmVkKSB7XG4gICAgICAgIHRoaXMuY2FjdWxhdGVPcmRlcmVkKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmNhY2hlT3JkZXJlZDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJwdXJlQ2hhbmdlZFwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXRoaXMuY2FjaGVQdXJlQ2hhbmdlZCkge1xuICAgICAgICB0aGlzLmNhY3VsYXRlT3JkZXJlZCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jYWNoZVB1cmVDaGFuZ2VkO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG5cbiAgX19wcm90by5jYWN1bGF0ZU9yZGVyZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9yZGVyZWQgPSBvcmRlckNoYW5nZWQodGhpcy5jaGFuZ2VkQmVmb3JlQWRkZWQsIHRoaXMuZml4ZWQpO1xuICAgIHZhciBjaGFuZ2VkID0gdGhpcy5jaGFuZ2VkO1xuICAgIHZhciBwdXJlQ2hhbmdlZCA9IFtdO1xuICAgIHRoaXMuY2FjaGVPcmRlcmVkID0gb3JkZXJlZC5maWx0ZXIoZnVuY3Rpb24gKF9hLCBpKSB7XG4gICAgICB2YXIgZnJvbSA9IF9hWzBdLFxuICAgICAgICAgIHRvID0gX2FbMV07XG4gICAgICB2YXIgX2IgPSBjaGFuZ2VkW2ldLFxuICAgICAgICAgIGZyb21CZWZvcmUgPSBfYlswXSxcbiAgICAgICAgICB0b0JlZm9yZSA9IF9iWzFdO1xuXG4gICAgICBpZiAoZnJvbSAhPT0gdG8pIHtcbiAgICAgICAgcHVyZUNoYW5nZWQucHVzaChbZnJvbUJlZm9yZSwgdG9CZWZvcmVdKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5jYWNoZVB1cmVDaGFuZ2VkID0gcHVyZUNoYW5nZWQ7XG4gIH07XG5cbiAgcmV0dXJuIFJlc3VsdDtcbn0oKTtcblxuLyoqXG4gKlxuICogQG1lbWJlcm9mIGVnLkxpc3REaWZmZXJcbiAqIEBzdGF0aWNcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIC0gUHJldmlvdXMgTGlzdCA8a28+IOydtOyghCDrqqnroZ0gPC9rbz5cbiAqIEBwYXJhbSAtIExpc3QgdG8gVXBkYXRlIDxrbz4g7JeF642w7J207Yq4IO2VoCDrqqnroZ0gPC9rbz5cbiAqIEBwYXJhbSAtIFRoaXMgY2FsbGJhY2sgZnVuY3Rpb24gcmV0dXJucyB0aGUga2V5IG9mIHRoZSBpdGVtLiA8a28+IOyVhOydtO2FnOydmCDtgqTrpbwg67CY7ZmY7ZWY64qUIOy9nOuwsSDtlajsiJjsnoXri4jri6QuPC9rbz5cbiAqIEByZXR1cm4gLSBSZXR1cm5zIHRoZSBkaWZmIGJldHdlZW4gYHByZXZMaXN0YCBhbmQgYGxpc3RgIDxrbz4gYHByZXZMaXN0YOyZgCBgbGlzdGDsnZgg64uk66W4IOygkOydhCDrsJjtmZjtlZzri6QuPC9rbz5cbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBkaWZmIH0gZnJvbSBcIkBlZ2pzL2xpc3QtZGlmZmVyXCI7XG4gKiAvLyBzY3JpcHQgPT4gZWcuTGlzdERpZmZlci5kaWZmXG4gKiBjb25zdCByZXN1bHQgPSBkaWZmKFswLCAxLCAyLCAzLCA0LCA1XSwgWzcsIDgsIDAsIDQsIDMsIDYsIDIsIDFdLCBlID0+IGUpO1xuICogLy8gTGlzdCBiZWZvcmUgdXBkYXRlXG4gKiAvLyBbMSwgMiwgMywgNCwgNV1cbiAqIGNvbnNvbGUubG9nKHJlc3VsdC5wcmV2TGlzdCk7XG4gKiAvLyBVcGRhdGVkIGxpc3RcbiAqIC8vIFs0LCAzLCA2LCAyLCAxXVxuICogY29uc29sZS5sb2cocmVzdWx0Lmxpc3QpO1xuICogLy8gSW5kZXggYXJyYXkgb2YgdmFsdWVzIGFkZGVkIHRvIGBsaXN0YFxuICogLy8gWzAsIDEsIDVdXG4gKiBjb25zb2xlLmxvZyhyZXN1bHQuYWRkZWQpO1xuICogLy8gSW5kZXggYXJyYXkgb2YgdmFsdWVzIHJlbW92ZWQgaW4gYHByZXZMaXN0YFxuICogLy8gWzVdXG4gKiBjb25zb2xlLmxvZyhyZXN1bHQucmVtb3ZlZCk7XG4gKiAvLyBBbiBhcnJheSBvZiBpbmRleCBwYWlycyBvZiBgcHJldkxpc3RgIGFuZCBgbGlzdGAgd2l0aCBkaWZmZXJlbnQgaW5kZXhlcyBmcm9tIGBwcmV2TGlzdGAgYW5kIGBsaXN0YFxuICogLy8gW1swLCAyXSwgWzQsIDNdLCBbMywgNF0sIFsyLCA2XSwgWzEsIDddXVxuICogY29uc29sZS5sb2cocmVzdWx0LmNoYW5nZWQpO1xuICogLy8gVGhlIHN1YnNldCBvZiBgY2hhbmdlZGAgYW5kIGFuIGFycmF5IG9mIGluZGV4IHBhaXJzIHRoYXQgbW92ZWQgZGF0YSBkaXJlY3RseS4gSW5kaWNhdGUgYW4gYXJyYXkgb2YgYWJzb2x1dGUgaW5kZXggcGFpcnMgb2YgYG9yZGVyZWRgLihGb3JtYXR0ZWQgYnk6IEFycmF5PFtpbmRleCBvZiBwcmV2TGlzdCwgaW5kZXggb2YgbGlzdF0+KVxuICogLy8gW1s0LCAzXSwgWzMsIDRdLCBbMiwgNl1dXG4gKiBjb25zb2xlLmxvZyhyZXN1bHQucHVyZUNoYW5nZWQpO1xuICogLy8gQW4gYXJyYXkgb2YgaW5kZXggcGFpcnMgdG8gYmUgYG9yZGVyZWRgIHRoYXQgY2FuIHN5bmNocm9uaXplIGBsaXN0YCBiZWZvcmUgYWRkaW5nIGRhdGEuIChGb3JtYXR0ZWQgYnk6IEFycmF5PFtwcmV2SW5kZXgsIG5leHRJbmRleF0+KVxuICogLy8gW1s0LCAxXSwgWzQsIDJdLCBbNCwgM11dXG4gKiBjb25zb2xlLmxvZyhyZXN1bHQub3JkZXJlZCk7XG4gKiAvLyBBbiBhcnJheSBvZiBpbmRleCBwYWlycyBvZiBgcHJldkxpc3RgIGFuZCBgbGlzdGAgdGhhdCBoYXZlIG5vdCBiZWVuIGFkZGVkL3JlbW92ZWQgc28gZGF0YSBpcyBwcmVzZXJ2ZWRcbiAqIC8vIFtbMCwgMl0sIFs0LCAzXSwgWzMsIDRdLCBbMiwgNl0sIFsxLCA3XV1cbiAqIGNvbnNvbGUubG9nKHJlc3VsdC5tYWludGFpbmVkKTtcbiAqL1xuXG5mdW5jdGlvbiBkaWZmKHByZXZMaXN0LCBsaXN0LCBmaW5kS2V5Q2FsbGJhY2spIHtcbiAgdmFyIG1hcENsYXNzID0gU1VQUE9SVF9NQVAgPyBNYXAgOiBmaW5kS2V5Q2FsbGJhY2sgPyBIYXNoTWFwIDogUG9seU1hcDtcblxuICB2YXIgY2FsbGJhY2sgPSBmaW5kS2V5Q2FsbGJhY2sgfHwgZnVuY3Rpb24gKGUpIHtcbiAgICByZXR1cm4gZTtcbiAgfTtcblxuICB2YXIgYWRkZWQgPSBbXTtcbiAgdmFyIHJlbW92ZWQgPSBbXTtcbiAgdmFyIG1haW50YWluZWQgPSBbXTtcbiAgdmFyIHByZXZLZXlzID0gcHJldkxpc3QubWFwKGNhbGxiYWNrKTtcbiAgdmFyIGtleXMgPSBsaXN0Lm1hcChjYWxsYmFjayk7XG4gIHZhciBwcmV2S2V5TWFwID0gbmV3IG1hcENsYXNzKCk7XG4gIHZhciBrZXlNYXAgPSBuZXcgbWFwQ2xhc3MoKTtcbiAgdmFyIGNoYW5nZWRCZWZvcmVBZGRlZCA9IFtdO1xuICB2YXIgZml4ZWQgPSBbXTtcbiAgdmFyIHJlbW92ZWRNYXAgPSB7fTtcbiAgdmFyIGNoYW5nZWQgPSBbXTtcbiAgdmFyIGFkZGVkQ291bnQgPSAwO1xuICB2YXIgcmVtb3ZlZENvdW50ID0gMDsgLy8gQWRkIHByZXZLZXlzIGFuZCBrZXlzIHRvIHRoZSBoYXNobWFwLlxuXG4gIHByZXZLZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSwgcHJldkxpc3RJbmRleCkge1xuICAgIHByZXZLZXlNYXAuc2V0KGtleSwgcHJldkxpc3RJbmRleCk7XG4gIH0pO1xuICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSwgbGlzdEluZGV4KSB7XG4gICAga2V5TWFwLnNldChrZXksIGxpc3RJbmRleCk7XG4gIH0pOyAvLyBDb21wYXJlIGBwcmV2S2V5c2AgYW5kIGBrZXlzYCBhbmQgYWRkIHRoZW0gdG8gYHJlbW92ZWRgIGlmIHRoZXkgYXJlIG5vdCBpbiBga2V5c2AuXG5cbiAgcHJldktleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5LCBwcmV2TGlzdEluZGV4KSB7XG4gICAgdmFyIGxpc3RJbmRleCA9IGtleU1hcC5nZXQoa2V5KTsgLy8gSW4gcHJldkxpc3QsIGJ1dCBub3QgaW4gbGlzdCwgaXQgaXMgcmVtb3ZlZC5cblxuICAgIGlmICh0eXBlb2YgbGlzdEluZGV4ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICArK3JlbW92ZWRDb3VudDtcbiAgICAgIHJlbW92ZWQucHVzaChwcmV2TGlzdEluZGV4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlZE1hcFtsaXN0SW5kZXhdID0gcmVtb3ZlZENvdW50O1xuICAgIH1cbiAgfSk7IC8vIENvbXBhcmUgYHByZXZLZXlzYCBhbmQgYGtleXNgIGFuZCBhZGQgdGhlbSB0byBgYWRkZWRgIGlmIHRoZXkgYXJlIG5vdCBpbiBgcHJldktleXNgLlxuXG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5LCBsaXN0SW5kZXgpIHtcbiAgICB2YXIgcHJldkxpc3RJbmRleCA9IHByZXZLZXlNYXAuZ2V0KGtleSk7IC8vIEluIGxpc3QsIGJ1dCBub3QgaW4gcHJldkxpc3QsIGl0IGlzIGFkZGVkLlxuXG4gICAgaWYgKHR5cGVvZiBwcmV2TGlzdEluZGV4ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBhZGRlZC5wdXNoKGxpc3RJbmRleCk7XG4gICAgICArK2FkZGVkQ291bnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1haW50YWluZWQucHVzaChbcHJldkxpc3RJbmRleCwgbGlzdEluZGV4XSk7XG4gICAgICByZW1vdmVkQ291bnQgPSByZW1vdmVkTWFwW2xpc3RJbmRleF0gfHwgMDtcbiAgICAgIGNoYW5nZWRCZWZvcmVBZGRlZC5wdXNoKFtwcmV2TGlzdEluZGV4IC0gcmVtb3ZlZENvdW50LCBsaXN0SW5kZXggLSBhZGRlZENvdW50XSk7XG4gICAgICBmaXhlZC5wdXNoKGxpc3RJbmRleCA9PT0gcHJldkxpc3RJbmRleCk7XG5cbiAgICAgIGlmIChwcmV2TGlzdEluZGV4ICE9PSBsaXN0SW5kZXgpIHtcbiAgICAgICAgY2hhbmdlZC5wdXNoKFtwcmV2TGlzdEluZGV4LCBsaXN0SW5kZXhdKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pOyAvLyBTb3J0IGJ5IGFzY2VuZGluZyBvcmRlciBvZiAndG8obGlzdCdzIGluZGV4KS5cblxuICByZW1vdmVkLnJldmVyc2UoKTtcbiAgcmV0dXJuIG5ldyBSZXN1bHQocHJldkxpc3QsIGxpc3QsIGFkZGVkLCByZW1vdmVkLCBjaGFuZ2VkLCBtYWludGFpbmVkLCBjaGFuZ2VkQmVmb3JlQWRkZWQsIGZpeGVkKTtcbn1cblxuLyoqXG4gKiBBIG1vZHVsZSB0aGF0IGNoZWNrcyBkaWZmIHdoZW4gdmFsdWVzIGFyZSBhZGRlZCwgcmVtb3ZlZCwgb3IgY2hhbmdlZCBpbiBhbiBhcnJheS5cbiAqIEBrbyDrsLDsl7Qg65iQ64qUIOyYpOu4jOygne2KuOyXkOyEnCDqsJLsnbQg7LaU6rCA65CY6rGw64KYIOyCreygnOuQmOqxsOuCmCDsiJzshJzqsIAg67OA6rK97IKs7ZWt7J2EIOyytO2BrO2VmOuKlCDrqqjrk4jsnoXri4jri6QuXG4gKiBAbWVtYmVyb2YgZWdcbiAqL1xuXG52YXIgTGlzdERpZmZlciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0gLSBJbml0aWFsaXppbmcgRGF0YSBBcnJheS4gPGtvPiDstIjquLAg7ISk7KCV7ZWgIOuNsOydtO2EsCDrsLDsl7QuPC9rbz5cbiAgICogQHBhcmFtIC0gVGhpcyBjYWxsYmFjayBmdW5jdGlvbiByZXR1cm5zIHRoZSBrZXkgb2YgdGhlIGl0ZW0uIDxrbz4g7JWE7J207YWc7J2YIO2CpOulvCDrsJjtmZjtlZjripQg7L2c67CxIO2VqOyImOyeheuLiOuLpC48L2tvPlxuICAgKiBAZXhhbXBsZVxuICAgKiBpbXBvcnQgTGlzdERpZmZlciBmcm9tIFwiQGVnanMvbGlzdC1kaWZmZXJcIjtcbiAgICogLy8gc2NyaXB0ID0+IGVnLkxpc3REaWZmZXJcbiAgICogY29uc3QgZGlmZmVyID0gbmV3IExpc3REaWZmZXIoWzAsIDEsIDIsIDMsIDQsIDVdLCBlID0+IGUpO1xuICAgKiBjb25zdCByZXN1bHQgPSBkaWZmZXIudXBkYXRlKFs3LCA4LCAwLCA0LCAzLCA2LCAyLCAxXSk7XG4gICAqIC8vIExpc3QgYmVmb3JlIHVwZGF0ZVxuICAgKiAvLyBbMSwgMiwgMywgNCwgNV1cbiAgICogY29uc29sZS5sb2cocmVzdWx0LnByZXZMaXN0KTtcbiAgICogLy8gVXBkYXRlZCBsaXN0XG4gICAqIC8vIFs0LCAzLCA2LCAyLCAxXVxuICAgKiBjb25zb2xlLmxvZyhyZXN1bHQubGlzdCk7XG4gICAqIC8vIEluZGV4IGFycmF5IG9mIHZhbHVlcyBhZGRlZCB0byBgbGlzdGAuXG4gICAqIC8vIFswLCAxLCA1XVxuICAgKiBjb25zb2xlLmxvZyhyZXN1bHQuYWRkZWQpO1xuICAgKiAvLyBJbmRleCBhcnJheSBvZiB2YWx1ZXMgcmVtb3ZlZCBpbiBgcHJldkxpc3RgLlxuICAgKiAvLyBbNV1cbiAgICogY29uc29sZS5sb2cocmVzdWx0LnJlbW92ZWQpO1xuICAgKiAvLyBBbiBhcnJheSBvZiBpbmRleCBwYWlycyBvZiBgcHJldkxpc3RgIGFuZCBgbGlzdGAgd2l0aCBkaWZmZXJlbnQgaW5kZXhlcyBmcm9tIGBwcmV2TGlzdGAgYW5kIGBsaXN0YC5cbiAgICogLy8gW1swLCAyXSwgWzQsIDNdLCBbMywgNF0sIFsyLCA2XSwgWzEsIDddXVxuICAgKiBjb25zb2xlLmxvZyhyZXN1bHQuY2hhbmdlZCk7XG4gICAqIC8vIFRoZSBzdWJzZXQgb2YgYGNoYW5nZWRgIGFuZCBhbiBhcnJheSBvZiBpbmRleCBwYWlycyB0aGF0IG1vdmVkIGRhdGEgZGlyZWN0bHkuIEluZGljYXRlIGFuIGFycmF5IG9mIGFic29sdXRlIGluZGV4IHBhaXJzIG9mIGBvcmRlcmVkYC4oRm9ybWF0dGVkIGJ5OiBBcnJheTxbaW5kZXggb2YgcHJldkxpc3QsIGluZGV4IG9mIGxpc3RdPilcbiAgICogLy8gW1s0LCAzXSwgWzMsIDRdLCBbMiwgNl1dXG4gICAqIGNvbnNvbGUubG9nKHJlc3VsdC5wdXJlQ2hhbmdlZCk7XG4gICAqIC8vIEFuIGFycmF5IG9mIGluZGV4IHBhaXJzIHRvIGJlIGBvcmRlcmVkYCB0aGF0IGNhbiBzeW5jaHJvbml6ZSBgbGlzdGAgYmVmb3JlIGFkZGluZyBkYXRhLiAoRm9ybWF0dGVkIGJ5OiBBcnJheTxbcHJldkluZGV4LCBuZXh0SW5kZXhdPilcbiAgICogLy8gW1s0LCAxXSwgWzQsIDJdLCBbNCwgM11dXG4gICAqIGNvbnNvbGUubG9nKHJlc3VsdC5vcmRlcmVkKTtcbiAgICogLy8gQW4gYXJyYXkgb2YgaW5kZXggcGFpcnMgb2YgYHByZXZMaXN0YCBhbmQgYGxpc3RgIHRoYXQgaGF2ZSBub3QgYmVlbiBhZGRlZC9yZW1vdmVkIHNvIGRhdGEgaXMgcHJlc2VydmVkLlxuICAgKiAvLyBbWzAsIDJdLCBbNCwgM10sIFszLCA0XSwgWzIsIDZdLCBbMSwgN11dXG4gICAqIGNvbnNvbGUubG9nKHJlc3VsdC5tYWludGFpbmVkKTtcbiAgICovXG4gIGZ1bmN0aW9uIExpc3REaWZmZXIobGlzdCwgZmluZEtleUNhbGxiYWNrKSB7XG4gICAgaWYgKGxpc3QgPT09IHZvaWQgMCkge1xuICAgICAgbGlzdCA9IFtdO1xuICAgIH1cblxuICAgIHRoaXMuZmluZEtleUNhbGxiYWNrID0gZmluZEtleUNhbGxiYWNrO1xuICAgIHRoaXMubGlzdCA9IFtdLnNsaWNlLmNhbGwobGlzdCk7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZSBsaXN0LlxuICAgKiBAa28g66as7Iqk7Yq466W8IOyXheuNsOydtO2KuOulvCDtlanri4jri6QuXG4gICAqIEBwYXJhbSAtIExpc3QgdG8gdXBkYXRlIDxrbz4g7JeF642w7J207Yq47ZWgIOumrOyKpO2KuCA8L2tvPlxuICAgKiBAcmV0dXJuIC0gUmV0dXJucyB0aGUgcmVzdWx0cyBvZiBhbiB1cGRhdGUgZnJvbSBgcHJldkxpc3RgIHRvIGBsaXN0YC48a28+IGBwcmV2TGlzdGDsl5DshJwgYGxpc3Rg66GcIOyXheuNsOydtO2KuO2VnCDqsrDqs7zrpbwg67CY7ZmY7ZWc64ukLiA8L2tvPlxuICAgKi9cblxuXG4gIHZhciBfX3Byb3RvID0gTGlzdERpZmZlci5wcm90b3R5cGU7XG5cbiAgX19wcm90by51cGRhdGUgPSBmdW5jdGlvbiAobGlzdCkge1xuICAgIHZhciBuZXdEYXRhID0gW10uc2xpY2UuY2FsbChsaXN0KTtcbiAgICB2YXIgcmVzdWx0ID0gZGlmZih0aGlzLmxpc3QsIG5ld0RhdGEsIHRoaXMuZmluZEtleUNhbGxiYWNrKTtcbiAgICB0aGlzLmxpc3QgPSBuZXdEYXRhO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgcmV0dXJuIExpc3REaWZmZXI7XG59KCk7XG5cbi8qXG5Db3B5cmlnaHQgKGMpIDIwMTUgTkFWRVIgQ29ycC5cbm5hbWU6IEBlZ2pzL2FnZW50XG5saWNlbnNlOiBNSVRcbmF1dGhvcjogTkFWRVIgQ29ycC5cbnJlcG9zaXRvcnk6IGdpdCtodHRwczovL2dpdGh1Yi5jb20vbmF2ZXIvYWdlbnQuZ2l0XG52ZXJzaW9uOiAyLjQuM1xuKi9cbmZ1bmN0aW9uIHNvbWUoYXJyLCBjYWxsYmFjaykge1xuICB2YXIgbGVuZ3RoID0gYXJyLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGNhbGxiYWNrKGFycltpXSwgaSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGZpbmQoYXJyLCBjYWxsYmFjaykge1xuICB2YXIgbGVuZ3RoID0gYXJyLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGNhbGxiYWNrKGFycltpXSwgaSkpIHtcbiAgICAgIHJldHVybiBhcnJbaV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBnZXRVc2VyQWdlbnRTdHJpbmcoYWdlbnQpIHtcbiAgdmFyIHVzZXJBZ2VudCA9IGFnZW50O1xuXG4gIGlmICh0eXBlb2YgdXNlckFnZW50ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPT09IFwidW5kZWZpbmVkXCIgfHwgIW5hdmlnYXRvcikge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuXG4gICAgdXNlckFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudCB8fCBcIlwiO1xuICB9XG5cbiAgcmV0dXJuIHVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xufVxuZnVuY3Rpb24gZXhlY1JlZ0V4cChwYXR0ZXJuLCB0ZXh0KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAocGF0dGVybiwgXCJnXCIpLmV4ZWModGV4dCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuZnVuY3Rpb24gaGFzVXNlckFnZW50RGF0YSgpIHtcbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPT09IFwidW5kZWZpbmVkXCIgfHwgIW5hdmlnYXRvciB8fCAhbmF2aWdhdG9yLnVzZXJBZ2VudERhdGEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgdXNlckFnZW50RGF0YSA9IG5hdmlnYXRvci51c2VyQWdlbnREYXRhO1xuICB2YXIgYnJhbmRzID0gdXNlckFnZW50RGF0YS5icmFuZHMgfHwgdXNlckFnZW50RGF0YS51YUxpc3Q7XG4gIHJldHVybiAhIShicmFuZHMgJiYgYnJhbmRzLmxlbmd0aCk7XG59XG5mdW5jdGlvbiBmaW5kVmVyc2lvbih2ZXJzaW9uVGVzdCwgdXNlckFnZW50KSB7XG4gIHZhciByZXN1bHQgPSBleGVjUmVnRXhwKFwiKFwiICsgdmVyc2lvblRlc3QgKyBcIikoKD86XFxcXC98XFxcXHN8OikoWzAtOXxcXFxcLnxfXSspKVwiLCB1c2VyQWdlbnQpO1xuICByZXR1cm4gcmVzdWx0ID8gcmVzdWx0WzNdIDogXCJcIjtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRWZXJzaW9uKHRleHQpIHtcbiAgcmV0dXJuIHRleHQucmVwbGFjZSgvXy9nLCBcIi5cIik7XG59XG5mdW5jdGlvbiBmaW5kUHJlc2V0KHByZXNldHMsIHVzZXJBZ2VudCkge1xuICB2YXIgdXNlclByZXNldCA9IG51bGw7XG4gIHZhciB2ZXJzaW9uID0gXCItMVwiO1xuICBzb21lKHByZXNldHMsIGZ1bmN0aW9uIChwcmVzZXQpIHtcbiAgICB2YXIgcmVzdWx0ID0gZXhlY1JlZ0V4cChcIihcIiArIHByZXNldC50ZXN0ICsgXCIpKCg/OlxcXFwvfFxcXFxzfDopKFswLTl8XFxcXC58X10rKSk/XCIsIHVzZXJBZ2VudCk7XG5cbiAgICBpZiAoIXJlc3VsdCB8fCBwcmVzZXQuYnJhbmQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB1c2VyUHJlc2V0ID0gcHJlc2V0O1xuICAgIHZlcnNpb24gPSByZXN1bHRbM10gfHwgXCItMVwiO1xuXG4gICAgaWYgKHByZXNldC52ZXJzaW9uQWxpYXMpIHtcbiAgICAgIHZlcnNpb24gPSBwcmVzZXQudmVyc2lvbkFsaWFzO1xuICAgIH0gZWxzZSBpZiAocHJlc2V0LnZlcnNpb25UZXN0KSB7XG4gICAgICB2ZXJzaW9uID0gZmluZFZlcnNpb24ocHJlc2V0LnZlcnNpb25UZXN0LnRvTG93ZXJDYXNlKCksIHVzZXJBZ2VudCkgfHwgdmVyc2lvbjtcbiAgICB9XG5cbiAgICB2ZXJzaW9uID0gY29udmVydFZlcnNpb24odmVyc2lvbik7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHByZXNldDogdXNlclByZXNldCxcbiAgICB2ZXJzaW9uOiB2ZXJzaW9uXG4gIH07XG59XG5mdW5jdGlvbiBmaW5kUHJlc2V0QnJhbmQocHJlc2V0cywgYnJhbmRzKSB7XG4gIHZhciBicmFuZEluZm8gPSB7XG4gICAgYnJhbmQ6IFwiXCIsXG4gICAgdmVyc2lvbjogXCItMVwiXG4gIH07XG4gIHNvbWUocHJlc2V0cywgZnVuY3Rpb24gKHByZXNldCkge1xuICAgIHZhciByZXN1bHQgPSBmaW5kQnJhbmQoYnJhbmRzLCBwcmVzZXQpO1xuXG4gICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBicmFuZEluZm8uYnJhbmQgPSBwcmVzZXQuaWQ7XG4gICAgYnJhbmRJbmZvLnZlcnNpb24gPSBwcmVzZXQudmVyc2lvbkFsaWFzIHx8IHJlc3VsdC52ZXJzaW9uO1xuICAgIHJldHVybiBicmFuZEluZm8udmVyc2lvbiAhPT0gXCItMVwiO1xuICB9KTtcbiAgcmV0dXJuIGJyYW5kSW5mbztcbn1cbmZ1bmN0aW9uIGZpbmRCcmFuZChicmFuZHMsIHByZXNldCkge1xuICByZXR1cm4gZmluZChicmFuZHMsIGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBicmFuZCA9IF9hLmJyYW5kO1xuICAgIHJldHVybiBleGVjUmVnRXhwKFwiXCIgKyBwcmVzZXQudGVzdCwgYnJhbmQudG9Mb3dlckNhc2UoKSk7XG4gIH0pO1xufVxuXG52YXIgQlJPV1NFUl9QUkVTRVRTID0gW3tcbiAgdGVzdDogXCJwaGFudG9tanNcIixcbiAgaWQ6IFwicGhhbnRvbWpzXCJcbn0sIHtcbiAgdGVzdDogXCJ3aGFsZVwiLFxuICBpZDogXCJ3aGFsZVwiXG59LCB7XG4gIHRlc3Q6IFwiZWRnaW9zfGVkZ2V8ZWRnXCIsXG4gIGlkOiBcImVkZ2VcIlxufSwge1xuICB0ZXN0OiBcIm1zaWV8dHJpZGVudHx3aW5kb3dzIHBob25lXCIsXG4gIGlkOiBcImllXCIsXG4gIHZlcnNpb25UZXN0OiBcImllbW9iaWxlfG1zaWV8cnZcIlxufSwge1xuICB0ZXN0OiBcIm1pdWlicm93c2VyXCIsXG4gIGlkOiBcIm1pdWkgYnJvd3NlclwiXG59LCB7XG4gIHRlc3Q6IFwic2Ftc3VuZ2Jyb3dzZXJcIixcbiAgaWQ6IFwic2Ftc3VuZyBpbnRlcm5ldFwiXG59LCB7XG4gIHRlc3Q6IFwic2Ftc3VuZ1wiLFxuICBpZDogXCJzYW1zdW5nIGludGVybmV0XCIsXG4gIHZlcnNpb25UZXN0OiBcInZlcnNpb25cIlxufSwge1xuICB0ZXN0OiBcImNocm9tZXxjcmlvc1wiLFxuICBpZDogXCJjaHJvbWVcIlxufSwge1xuICB0ZXN0OiBcImZpcmVmb3h8Znhpb3NcIixcbiAgaWQ6IFwiZmlyZWZveFwiXG59LCB7XG4gIHRlc3Q6IFwiYW5kcm9pZFwiLFxuICBpZDogXCJhbmRyb2lkIGJyb3dzZXJcIixcbiAgdmVyc2lvblRlc3Q6IFwidmVyc2lvblwiXG59LCB7XG4gIHRlc3Q6IFwic2FmYXJpfGlwaG9uZXxpcGFkfGlwb2RcIixcbiAgaWQ6IFwic2FmYXJpXCIsXG4gIHZlcnNpb25UZXN0OiBcInZlcnNpb25cIlxufV07IC8vIGNocm9taXVtJ3MgZW5naW5lKGJsaW5rKSBpcyBiYXNlZCBvbiBhcHBsZXdlYmtpdCA1MzcuMzYuXG5cbnZhciBDSFJPTUlVTV9QUkVTRVRTID0gW3tcbiAgdGVzdDogXCIoPz0uKmFwcGxld2Via2l0Lyg1M1swLTddfDVbMC0yXXxbMC00XSkpKD89LipcXFxcc2Nocm9tZSlcIixcbiAgaWQ6IFwiY2hyb21lXCIsXG4gIHZlcnNpb25UZXN0OiBcImNocm9tZVwiXG59LCB7XG4gIHRlc3Q6IFwiY2hyb21pdW1cIixcbiAgaWQ6IFwiY2hyb21lXCJcbn0sIHtcbiAgdGVzdDogXCJ3aGFsZVwiLFxuICBpZDogXCJjaHJvbWVcIixcbiAgdmVyc2lvbkFsaWFzOiBcIi0xXCIsXG4gIGJyYW5kOiB0cnVlXG59XTtcbnZhciBXRUJLSVRfUFJFU0VUUyA9IFt7XG4gIHRlc3Q6IFwiYXBwbGV3ZWJraXRcIixcbiAgaWQ6IFwid2Via2l0XCIsXG4gIHZlcnNpb25UZXN0OiBcImFwcGxld2Via2l0fHNhZmFyaVwiXG59XTtcbnZhciBXRUJWSUVXX1BSRVNFVFMgPSBbe1xuICB0ZXN0OiBcIig/PShpcGhvbmV8aXBhZCkpKD8hKC4qdmVyc2lvbikpXCIsXG4gIGlkOiBcIndlYnZpZXdcIlxufSwge1xuICB0ZXN0OiBcIig/PShhbmRyb2lkfGlwaG9uZXxpcGFkKSkoPz0uKihuYXZlcnxkYXVtfDsgd3YpKVwiLFxuICBpZDogXCJ3ZWJ2aWV3XCJcbn0sIHtcbiAgLy8gdGVzdCB3ZWJ2aWV3XG4gIHRlc3Q6IFwid2Vidmlld1wiLFxuICBpZDogXCJ3ZWJ2aWV3XCJcbn1dO1xudmFyIE9TX1BSRVNFVFMgPSBbe1xuICB0ZXN0OiBcIndpbmRvd3MgcGhvbmVcIixcbiAgaWQ6IFwid2luZG93cyBwaG9uZVwiXG59LCB7XG4gIHRlc3Q6IFwid2luZG93cyAyMDAwXCIsXG4gIGlkOiBcIndpbmRvd1wiLFxuICB2ZXJzaW9uQWxpYXM6IFwiNS4wXCJcbn0sIHtcbiAgdGVzdDogXCJ3aW5kb3dzIG50XCIsXG4gIGlkOiBcIndpbmRvd1wiXG59LCB7XG4gIHRlc3Q6IFwid2luMzJ8d2luZG93c1wiLFxuICBpZDogXCJ3aW5kb3dcIlxufSwge1xuICB0ZXN0OiBcImlwaG9uZXxpcGFkfGlwb2RcIixcbiAgaWQ6IFwiaW9zXCIsXG4gIHZlcnNpb25UZXN0OiBcImlwaG9uZSBvc3xjcHUgb3NcIlxufSwge1xuICB0ZXN0OiBcIm1hY29zfG1hY2ludGVsfG1hYyBvcyB4XCIsXG4gIGlkOiBcIm1hY1wiXG59LCB7XG4gIHRlc3Q6IFwiYW5kcm9pZHxsaW51eCBhcm12ODFcIixcbiAgaWQ6IFwiYW5kcm9pZFwiXG59LCB7XG4gIHRlc3Q6IFwidGl6ZW5cIixcbiAgaWQ6IFwidGl6ZW5cIlxufSwge1xuICB0ZXN0OiBcIndlYm9zfHdlYjBzXCIsXG4gIGlkOiBcIndlYm9zXCJcbn1dO1xuXG5mdW5jdGlvbiBpc1dlYlZpZXcodXNlckFnZW50KSB7XG4gIHJldHVybiAhIWZpbmRQcmVzZXQoV0VCVklFV19QUkVTRVRTLCB1c2VyQWdlbnQpLnByZXNldDtcbn1cbmZ1bmN0aW9uIGdldExlZ2FjeUFnZW50KHVzZXJBZ2VudCkge1xuICB2YXIgbmV4dEFnZW50ID0gZ2V0VXNlckFnZW50U3RyaW5nKHVzZXJBZ2VudCk7XG4gIHZhciBpc01vYmlsZSA9ICEhL21vYmkvZy5leGVjKG5leHRBZ2VudCk7XG4gIHZhciBicm93c2VyID0ge1xuICAgIG5hbWU6IFwidW5rbm93blwiLFxuICAgIHZlcnNpb246IFwiLTFcIixcbiAgICBtYWpvclZlcnNpb246IC0xLFxuICAgIHdlYnZpZXc6IGlzV2ViVmlldyhuZXh0QWdlbnQpLFxuICAgIGNocm9taXVtOiBmYWxzZSxcbiAgICBjaHJvbWl1bVZlcnNpb246IFwiLTFcIixcbiAgICB3ZWJraXQ6IGZhbHNlLFxuICAgIHdlYmtpdFZlcnNpb246IFwiLTFcIlxuICB9O1xuICB2YXIgb3MgPSB7XG4gICAgbmFtZTogXCJ1bmtub3duXCIsXG4gICAgdmVyc2lvbjogXCItMVwiLFxuICAgIG1ham9yVmVyc2lvbjogLTFcbiAgfTtcblxuICB2YXIgX2EgPSBmaW5kUHJlc2V0KEJST1dTRVJfUFJFU0VUUywgbmV4dEFnZW50KSxcbiAgICAgIGJyb3dzZXJQcmVzZXQgPSBfYS5wcmVzZXQsXG4gICAgICBicm93c2VyVmVyc2lvbiA9IF9hLnZlcnNpb247XG5cbiAgdmFyIF9iID0gZmluZFByZXNldChPU19QUkVTRVRTLCBuZXh0QWdlbnQpLFxuICAgICAgb3NQcmVzZXQgPSBfYi5wcmVzZXQsXG4gICAgICBvc1ZlcnNpb24gPSBfYi52ZXJzaW9uO1xuXG4gIHZhciBjaHJvbWl1bVByZXNldCA9IGZpbmRQcmVzZXQoQ0hST01JVU1fUFJFU0VUUywgbmV4dEFnZW50KTtcbiAgYnJvd3Nlci5jaHJvbWl1bSA9ICEhY2hyb21pdW1QcmVzZXQucHJlc2V0O1xuICBicm93c2VyLmNocm9taXVtVmVyc2lvbiA9IGNocm9taXVtUHJlc2V0LnZlcnNpb247XG5cbiAgaWYgKCFicm93c2VyLmNocm9taXVtKSB7XG4gICAgdmFyIHdlYmtpdFByZXNldCA9IGZpbmRQcmVzZXQoV0VCS0lUX1BSRVNFVFMsIG5leHRBZ2VudCk7XG4gICAgYnJvd3Nlci53ZWJraXQgPSAhIXdlYmtpdFByZXNldC5wcmVzZXQ7XG4gICAgYnJvd3Nlci53ZWJraXRWZXJzaW9uID0gd2Via2l0UHJlc2V0LnZlcnNpb247XG4gIH1cblxuICBpZiAob3NQcmVzZXQpIHtcbiAgICBvcy5uYW1lID0gb3NQcmVzZXQuaWQ7XG4gICAgb3MudmVyc2lvbiA9IG9zVmVyc2lvbjtcbiAgICBvcy5tYWpvclZlcnNpb24gPSBwYXJzZUludChvc1ZlcnNpb24sIDEwKTtcbiAgfVxuXG4gIGlmIChicm93c2VyUHJlc2V0KSB7XG4gICAgYnJvd3Nlci5uYW1lID0gYnJvd3NlclByZXNldC5pZDtcbiAgICBicm93c2VyLnZlcnNpb24gPSBicm93c2VyVmVyc2lvbjsgLy8gRWFybHkgd2hhbGUgYnVnc1xuXG4gICAgaWYgKGJyb3dzZXIud2VidmlldyAmJiBvcy5uYW1lID09PSBcImlvc1wiICYmIGJyb3dzZXIubmFtZSAhPT0gXCJzYWZhcmlcIikge1xuICAgICAgYnJvd3Nlci53ZWJ2aWV3ID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgYnJvd3Nlci5tYWpvclZlcnNpb24gPSBwYXJzZUludChicm93c2VyLnZlcnNpb24sIDEwKTtcbiAgcmV0dXJuIHtcbiAgICBicm93c2VyOiBicm93c2VyLFxuICAgIG9zOiBvcyxcbiAgICBpc01vYmlsZTogaXNNb2JpbGUsXG4gICAgaXNIaW50czogZmFsc2VcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0Q2xpZW50SGludHNBZ2VudChvc0RhdGEpIHtcbiAgdmFyIHVzZXJBZ2VudERhdGEgPSBuYXZpZ2F0b3IudXNlckFnZW50RGF0YTtcbiAgdmFyIGJyYW5kcyA9ICh1c2VyQWdlbnREYXRhLnVhTGlzdCB8fCB1c2VyQWdlbnREYXRhLmJyYW5kcykuc2xpY2UoKTtcbiAgdmFyIGZ1bGxWZXJzaW9uTGlzdCA9IG9zRGF0YSAmJiBvc0RhdGEuZnVsbFZlcnNpb25MaXN0O1xuICB2YXIgaXNNb2JpbGUgPSB1c2VyQWdlbnREYXRhLm1vYmlsZSB8fCBmYWxzZTtcbiAgdmFyIGZpcnN0QnJhbmQgPSBicmFuZHNbMF07XG4gIHZhciBwbGF0Zm9ybSA9IChvc0RhdGEgJiYgb3NEYXRhLnBsYXRmb3JtIHx8IHVzZXJBZ2VudERhdGEucGxhdGZvcm0gfHwgbmF2aWdhdG9yLnBsYXRmb3JtKS50b0xvd2VyQ2FzZSgpO1xuICB2YXIgYnJvd3NlciA9IHtcbiAgICBuYW1lOiBmaXJzdEJyYW5kLmJyYW5kLFxuICAgIHZlcnNpb246IGZpcnN0QnJhbmQudmVyc2lvbixcbiAgICBtYWpvclZlcnNpb246IC0xLFxuICAgIHdlYmtpdDogZmFsc2UsXG4gICAgd2Via2l0VmVyc2lvbjogXCItMVwiLFxuICAgIGNocm9taXVtOiBmYWxzZSxcbiAgICBjaHJvbWl1bVZlcnNpb246IFwiLTFcIixcbiAgICB3ZWJ2aWV3OiAhIWZpbmRQcmVzZXRCcmFuZChXRUJWSUVXX1BSRVNFVFMsIGJyYW5kcykuYnJhbmQgfHwgaXNXZWJWaWV3KGdldFVzZXJBZ2VudFN0cmluZygpKVxuICB9O1xuICB2YXIgb3MgPSB7XG4gICAgbmFtZTogXCJ1bmtub3duXCIsXG4gICAgdmVyc2lvbjogXCItMVwiLFxuICAgIG1ham9yVmVyc2lvbjogLTFcbiAgfTtcbiAgYnJvd3Nlci53ZWJraXQgPSAhYnJvd3Nlci5jaHJvbWl1bSAmJiBzb21lKFdFQktJVF9QUkVTRVRTLCBmdW5jdGlvbiAocHJlc2V0KSB7XG4gICAgcmV0dXJuIGZpbmRCcmFuZChicmFuZHMsIHByZXNldCk7XG4gIH0pO1xuICB2YXIgY2hyb21pdW1CcmFuZCA9IGZpbmRQcmVzZXRCcmFuZChDSFJPTUlVTV9QUkVTRVRTLCBicmFuZHMpO1xuICBicm93c2VyLmNocm9taXVtID0gISFjaHJvbWl1bUJyYW5kLmJyYW5kO1xuICBicm93c2VyLmNocm9taXVtVmVyc2lvbiA9IGNocm9taXVtQnJhbmQudmVyc2lvbjtcblxuICBpZiAoIWJyb3dzZXIuY2hyb21pdW0pIHtcbiAgICB2YXIgd2Via2l0QnJhbmQgPSBmaW5kUHJlc2V0QnJhbmQoV0VCS0lUX1BSRVNFVFMsIGJyYW5kcyk7XG4gICAgYnJvd3Nlci53ZWJraXQgPSAhIXdlYmtpdEJyYW5kLmJyYW5kO1xuICAgIGJyb3dzZXIud2Via2l0VmVyc2lvbiA9IHdlYmtpdEJyYW5kLnZlcnNpb247XG4gIH1cblxuICB2YXIgcGxhdGZvbVJlc3VsdCA9IGZpbmQoT1NfUFJFU0VUUywgZnVuY3Rpb24gKHByZXNldCkge1xuICAgIHJldHVybiBuZXcgUmVnRXhwKFwiXCIgKyBwcmVzZXQudGVzdCwgXCJnXCIpLmV4ZWMocGxhdGZvcm0pO1xuICB9KTtcbiAgb3MubmFtZSA9IHBsYXRmb21SZXN1bHQgPyBwbGF0Zm9tUmVzdWx0LmlkIDogXCJcIjtcblxuICBpZiAob3NEYXRhKSB7XG4gICAgb3MudmVyc2lvbiA9IG9zRGF0YS5wbGF0Zm9ybVZlcnNpb247XG4gIH1cblxuICBpZiAoZnVsbFZlcnNpb25MaXN0ICYmIGZ1bGxWZXJzaW9uTGlzdC5sZW5ndGgpIHtcbiAgICB2YXIgYnJvd3NlckJyYW5kQnlGdWxsVmVyc2lvbkxpc3QgPSBmaW5kUHJlc2V0QnJhbmQoQlJPV1NFUl9QUkVTRVRTLCBmdWxsVmVyc2lvbkxpc3QpO1xuICAgIGJyb3dzZXIubmFtZSA9IGJyb3dzZXJCcmFuZEJ5RnVsbFZlcnNpb25MaXN0LmJyYW5kIHx8IGJyb3dzZXIubmFtZTtcbiAgICBicm93c2VyLnZlcnNpb24gPSBicm93c2VyQnJhbmRCeUZ1bGxWZXJzaW9uTGlzdC52ZXJzaW9uIHx8IGJyb3dzZXIudmVyc2lvbjtcbiAgfSBlbHNlIHtcbiAgICB2YXIgYnJvd3NlckJyYW5kID0gZmluZFByZXNldEJyYW5kKEJST1dTRVJfUFJFU0VUUywgYnJhbmRzKTtcbiAgICBicm93c2VyLm5hbWUgPSBicm93c2VyQnJhbmQuYnJhbmQgfHwgYnJvd3Nlci5uYW1lO1xuICAgIGJyb3dzZXIudmVyc2lvbiA9IGJyb3dzZXJCcmFuZC5icmFuZCAmJiBvc0RhdGEgPyBvc0RhdGEudWFGdWxsVmVyc2lvbiA6IGJyb3dzZXJCcmFuZC52ZXJzaW9uO1xuICB9XG5cbiAgaWYgKGJyb3dzZXIud2Via2l0KSB7XG4gICAgb3MubmFtZSA9IGlzTW9iaWxlID8gXCJpb3NcIiA6IFwibWFjXCI7XG4gIH1cblxuICBpZiAob3MubmFtZSA9PT0gXCJpb3NcIiAmJiBicm93c2VyLndlYnZpZXcpIHtcbiAgICBicm93c2VyLnZlcnNpb24gPSBcIi0xXCI7XG4gIH1cblxuICBvcy52ZXJzaW9uID0gY29udmVydFZlcnNpb24ob3MudmVyc2lvbik7XG4gIGJyb3dzZXIudmVyc2lvbiA9IGNvbnZlcnRWZXJzaW9uKGJyb3dzZXIudmVyc2lvbik7XG4gIG9zLm1ham9yVmVyc2lvbiA9IHBhcnNlSW50KG9zLnZlcnNpb24sIDEwKTtcbiAgYnJvd3Nlci5tYWpvclZlcnNpb24gPSBwYXJzZUludChicm93c2VyLnZlcnNpb24sIDEwKTtcbiAgcmV0dXJuIHtcbiAgICBicm93c2VyOiBicm93c2VyLFxuICAgIG9zOiBvcyxcbiAgICBpc01vYmlsZTogaXNNb2JpbGUsXG4gICAgaXNIaW50czogdHJ1ZVxuICB9O1xufVxuLyoqXG4gKiBFeHRyYWN0cyBicm93c2VyIGFuZCBvcGVyYXRpbmcgc3lzdGVtIGluZm9ybWF0aW9uIGZyb20gdGhlIHVzZXIgYWdlbnQgc3RyaW5nLlxuICogQGtvIOycoOyggCDsl5DsnbTsoITtirgg66y47J6Q7Je07JeQ7IScIOu4jOudvOyasOyggOyZgCDsmrTsmIHssrTsoJwg7KCV67O066W8IOy2lOy2nO2VnOuLpC5cbiAqIEBmdW5jdGlvbiBlZy5hZ2VudCNhZ2VudFxuICogQHBhcmFtIC0gdXNlciBhZ2VudCBzdHJpbmcgdG8gcGFyc2UgPGtvPu2MjOyLse2VoCDsnKDsoIDsl5DsnbTsoITtirgg66y47J6Q7Je0PC9rbz5cbiAqIEByZXR1cm4gLSBhZ2VudCBJbmZvIDxrbz4g7JeQ7J207KCE7Yq4IOygleuztCA8L2tvPlxuICogQGV4YW1wbGVcbmltcG9ydCBhZ2VudCBmcm9tIFwiQGVnanMvYWdlbnRcIjtcbi8vIGVnLmFnZW50KCk7XG5jb25zdCB7IG9zLCBicm93c2VyLCBpc01vYmlsZSB9ID0gYWdlbnQoKTtcbiAqL1xuXG5mdW5jdGlvbiBhZ2VudCh1c2VyQWdlbnQpIHtcbiAgaWYgKHR5cGVvZiB1c2VyQWdlbnQgPT09IFwidW5kZWZpbmVkXCIgJiYgaGFzVXNlckFnZW50RGF0YSgpKSB7XG4gICAgcmV0dXJuIGdldENsaWVudEhpbnRzQWdlbnQoKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZ2V0TGVnYWN5QWdlbnQodXNlckFnZW50KTtcbiAgfVxufVxuXG4vKlxuQ29weXJpZ2h0IChjKSAyMDIyLXByZXNlbnQgTkFWRVIgQ29ycC5cbm5hbWU6IEBjZmNzL2NvcmVcbmxpY2Vuc2U6IE1JVFxuYXV0aG9yOiBOQVZFUiBDcm9wLlxucmVwb3NpdG9yeTogaHR0cHM6Ly9naXRodWIuY29tL25hdmVyL2NmY3MvdHJlZS9tYWluL3BhY2thZ2VzL2NvcmVcbnZlcnNpb246IDAuMS4wXG4qL1xuXG4vKipcbiAqIGNmY3NcbiAqIENvcHlyaWdodCAoYykgMjAyMi1wcmVzZW50IE5BVkVSIENvcnAuXG4gKiBNSVQgbGljZW5zZVxuICovXG5cbi8qKlxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiBrZXlzKG9iaikge1xuICByZXR1cm4gT2JqZWN0LmtleXMob2JqKTtcbn1cblxuLyoqXG4gKiBjZmNzXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjItcHJlc2VudCBOQVZFUiBDb3JwLlxuICogTUlUIGxpY2Vuc2VcbiAqL1xudmFyIE9CU0VSVkVSU19QQVRIID0gXCJfX29ic2VydmVyc19fXCI7XG52YXIgQ09NUFVURURfUEFUSCA9IFwiX19jb21wdXRlZF9fXCI7XG52YXIgQ0ZDU19ERVRFQ1RFRF9ERVBFTkRFTkNJRVNfVkVSU0lPTiA9IDE7XG52YXIgQ0ZDU19ERVRFQ1RFRF9ERVBFTkRFTkNJRVMgPSBcIl9fQ0ZDU19ERVRFQ1RFRF9ERVBFTkRFTkNJRVNfX1wiO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cblxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCB7XG4gICAgX19wcm90b19fOiBbXVxuICB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBkLl9fcHJvdG9fXyA9IGI7XG4gIH0gfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdO1xuICB9O1xuXG4gIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xufTtcblxuZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcbiAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbCkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXG4gIGZ1bmN0aW9uIF9fKCkge1xuICAgIHRoaXMuY29uc3RydWN0b3IgPSBkO1xuICB9XG5cbiAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufVxuXG4vKipcbiAqIGNmY3NcbiAqIENvcHlyaWdodCAoYykgMjAyMi1wcmVzZW50IE5BVkVSIENvcnAuXG4gKiBNSVQgbGljZW5zZVxuICovXG5mdW5jdGlvbiBnZXREZXRlY3RlZFN0YWNrKCkge1xuICAvLyBWZXJzaW9uIGlzc3VlcyBkbyBub3Qgb2NjdXIgd2hlbiB5b3UgYWNjZXNzIHRoZSBuYXRpdmUgb2JqZWN0IGluIHRoZSBnbG9iYWwuXG4gIE9iamVjdFtDRkNTX0RFVEVDVEVEX0RFUEVOREVOQ0lFU10gPSBPYmplY3RbQ0ZDU19ERVRFQ1RFRF9ERVBFTkRFTkNJRVNdIHx8IHt9O1xuICB2YXIgdmVyc2lvbkxpc3QgPSBPYmplY3RbQ0ZDU19ERVRFQ1RFRF9ERVBFTkRFTkNJRVNdO1xuICB2ZXJzaW9uTGlzdFtDRkNTX0RFVEVDVEVEX0RFUEVOREVOQ0lFU19WRVJTSU9OXSA9IHZlcnNpb25MaXN0W0NGQ1NfREVURUNURURfREVQRU5ERU5DSUVTX1ZFUlNJT05dIHx8IFtdO1xuICByZXR1cm4gdmVyc2lvbkxpc3RbQ0ZDU19ERVRFQ1RFRF9ERVBFTkRFTkNJRVNfVkVSU0lPTl07XG59XG5mdW5jdGlvbiBnZXRDdXJyZW50RGV0ZWN0ZWQoKSB7XG4gIHZhciBzdGFjayA9IGdldERldGVjdGVkU3RhY2soKTtcbiAgcmV0dXJuIHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xufVxuZnVuY3Rpb24gZGV0ZWN0RGVwZW5kZW5jaWVzKGhvc3QpIHtcbiAgdmFyIHN0YWNrID0gZ2V0RGV0ZWN0ZWRTdGFjaygpO1xuICB2YXIgb2JzZXJ2ZXJzID0gW107XG4gIHZhciBkZXRlY3RlZCA9IHtcbiAgICBob3N0OiBob3N0LFxuICAgIG9ic2VydmVyczogb2JzZXJ2ZXJzLFxuICAgIHB1c2g6IGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgaWYgKGhvc3QgIT09IG9ic2VydmVyICYmIG9ic2VydmVycy5pbmRleE9mKG9ic2VydmVyKSA9PT0gLTEpIHtcbiAgICAgICAgb2JzZXJ2ZXJzLnB1c2gob2JzZXJ2ZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgc3RhY2sucHVzaChkZXRlY3RlZCk7XG4gIHJldHVybiBkZXRlY3RlZDtcbn1cbmZ1bmN0aW9uIGVuZERldGVjdERlcGVuZGVuY2llcygpIHtcbiAgdmFyIHN0YWNrID0gZ2V0RGV0ZWN0ZWRTdGFjaygpO1xuICByZXR1cm4gc3RhY2sucG9wKCk7XG59XG5cbi8qKlxuICogY2Zjc1xuICogQ29weXJpZ2h0IChjKSAyMDIyLXByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIE1JVCBsaWNlbnNlXG4gKi9cbi8qKlxuICogQ3JlYXRlcyBhIG11dGFibGUgcmVmIG9iamVjdC4gWW91IGNhbiBhY2Nlc3MgdGhlIGAuY3VycmVudGAgdmFsdWUgYW5kIGRldGVjdCB0aGUgdmFsdWUgY2hhbmdlIHRocm91Z2ggYC5zdWJzY3JpYmVgLlxuICogQGNhdGVnb3J5IFJlYWN0aXZlXG4gKiBAc2VlIG9ic2VydmVcbiAqL1xuXG52YXIgT2JzZXJ2ZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICpcbiAgICovXG4gIGZ1bmN0aW9uIE9ic2VydmVyKHZhbHVlKSB7XG4gICAgdGhpcy5fZW1pdHRlciA9IG5ldyBDb21wb25lbnQoKTtcbiAgICB0aGlzLl9jdXJyZW50ID0gdmFsdWU7XG4gIH1cblxuICB2YXIgX19wcm90byA9IE9ic2VydmVyLnByb3RvdHlwZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwiY3VycmVudFwiLCB7XG4gICAgLyoqXG4gICAgICogcmV0dXJuIHRoZSBjdXJyZW50IHZhbHVlLlxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGN1cnJlbnREZXRlY3RlZCA9IGdldEN1cnJlbnREZXRlY3RlZCgpO1xuICAgICAgY3VycmVudERldGVjdGVkID09PSBudWxsIHx8IGN1cnJlbnREZXRlY3RlZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VycmVudERldGVjdGVkLnB1c2godGhpcyk7XG4gICAgICByZXR1cm4gdGhpcy5fY3VycmVudDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICB0aGlzLl9zZXRDdXJyZW50KHZhbHVlKTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgLyoqXG4gICAqIFdoZW4gdGhlIGN1cnJlbnQgdmFsdWUgY2hhbmdlcywgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGlzIGNhbGxlZC5cbiAgICovXG5cbiAgX19wcm90by5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICB0aGlzLmN1cnJlbnQ7XG5cbiAgICB0aGlzLl9lbWl0dGVyLm9uKFwidXBkYXRlXCIsIGNhbGxiYWNrKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogQ2FuY2VsIHRoZSByZWdpc3RlcmVkIHN1YnNjcmlwdGlvbiB0aHJvdWdoIGNhbGxiYWNrLlxuICAgKi9cblxuXG4gIF9fcHJvdG8udW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICB0aGlzLl9lbWl0dGVyLm9mZihcInVwZGF0ZVwiLCBjYWxsYmFjayk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfX3Byb3RvLl9zZXRDdXJyZW50ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFyIHByZXZWYWx1ZSA9IHRoaXMuX2N1cnJlbnQ7XG4gICAgdmFyIGlzVXBkYXRlID0gdmFsdWUgIT09IHByZXZWYWx1ZTtcbiAgICB0aGlzLl9jdXJyZW50ID0gdmFsdWU7XG5cbiAgICBpZiAoaXNVcGRhdGUpIHtcbiAgICAgIHRoaXMuX2VtaXR0ZXIudHJpZ2dlcihcInVwZGF0ZVwiLCB2YWx1ZSwgcHJldlZhbHVlKTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBAaGlkZGVuXG4gICAqL1xuXG5cbiAgX19wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gXCJcIi5jb25jYXQodGhpcy5jdXJyZW50KTtcbiAgfTtcbiAgLyoqXG4gICAqIEBoaWRkZW5cbiAgICovXG5cblxuICBfX3Byb3RvLnZhbHVlT2YgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudDtcbiAgfTtcblxuICByZXR1cm4gT2JzZXJ2ZXI7XG59KCk7XG5cbi8qKlxuICogQGNhdGVnb3J5IFJlYWN0aXZlXG4gKiBAaGlkZGVuXG4gKi9cblxudmFyIENvbXB1dGVkT2JzZXJ2ZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoQ29tcHV0ZWRPYnNlcnZlciwgX3N1cGVyKTtcbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvbiBDcmVhdGVzIGEgbmV3IGNvbXB1dGVkIG9ic2VydmVyIGZyb20gdGhlIHZhbHVlcyBvZiBvdGhlciBvYnNlcnZlcnMuXG4gICAqIEl0IGlzIHJlYWQtb25seSBhbmQgaWYgeW91IGNoYW5nZSB0aGUgdmFsdWUgb2YgdGhlIG9ic2VydmVyIHVzZWQgaW5zaWRlIHRoZSBjYWxsYmFjaywgaXRzIHZhbHVlIHdpbGwgYmUgYXV0b21hdGljYWxseSB1cGRhdGVkLlxuICAgKiBAcGFyYW0gX2NvbXB1dGVkQ2FsbGJhY2sgQSBmdW5jdGlvbiBmb3Igb2JzZXJ2ZXJzIHRvIGJlIGNvbXB1dGVkLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIENvbXB1dGVkT2JzZXJ2ZXIoX2NvbXB1dGVkQ2FsbGJhY2spIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMuX2NvbXB1dGVkQ2FsbGJhY2sgPSBfY29tcHV0ZWRDYWxsYmFjaztcbiAgICBfdGhpcy5fcmVnaXN0ZXJlZCA9IFtdO1xuXG4gICAgX3RoaXMuX29uQ2hlY2tVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5fc2V0Q3VycmVudChfdGhpcy5jdXJyZW50KTtcbiAgICB9O1xuXG4gICAgX3RoaXMuX2N1cnJlbnQgPSBfdGhpcy5jdXJyZW50O1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfX3Byb3RvID0gQ29tcHV0ZWRPYnNlcnZlci5wcm90b3R5cGU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcImN1cnJlbnRcIiwge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgZGV0ZWN0RGVwZW5kZW5jaWVzKHRoaXMpO1xuXG4gICAgICB2YXIgdmFsdWUgPSB0aGlzLl9jb21wdXRlZENhbGxiYWNrKCk7XG5cbiAgICAgIHZhciByZXN1bHRzID0gZW5kRGV0ZWN0RGVwZW5kZW5jaWVzKCk7XG5cbiAgICAgIHRoaXMuX3JlZ2lzdGVyZWQuZm9yRWFjaChmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgb2JzZXJ2ZXIudW5zdWJzY3JpYmUoX3RoaXMuX29uQ2hlY2tVcGRhdGUpO1xuICAgICAgfSk7XG5cbiAgICAgIHJlc3VsdHMub2JzZXJ2ZXJzLmZvckVhY2goZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICAgIG9ic2VydmVyLnN1YnNjcmliZShfdGhpcy5fb25DaGVja1VwZGF0ZSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX3JlZ2lzdGVyZWQgPSByZXN1bHRzLm9ic2VydmVycztcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgcmV0dXJuIENvbXB1dGVkT2JzZXJ2ZXI7XG59KE9ic2VydmVyKTtcblxuLyoqXG4gKiBjZmNzXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjItcHJlc2VudCBOQVZFUiBDb3JwLlxuICogTUlUIGxpY2Vuc2VcbiAqL1xuXG5mdW5jdGlvbiBpbmplY3RPYnNlcnZlKHByb3RvdHlwZSwgbWVtYmVyTmFtZSwgcHVibGljTmFtZSkge1xuICBpZiAocHVibGljTmFtZSA9PT0gdm9pZCAwKSB7XG4gICAgcHVibGljTmFtZSA9IG1lbWJlck5hbWU7XG4gIH1cblxuICB2YXIgbmV4dEF0dHJpYnV0ZXMgPSB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGdldE9ic2VydmVyKHRoaXMsIHB1YmxpY05hbWUpLmN1cnJlbnQ7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgZ2V0T2JzZXJ2ZXIodGhpcywgcHVibGljTmFtZSwgdmFsdWUpLmN1cnJlbnQgPSB2YWx1ZTtcbiAgICB9XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90b3R5cGUsIG1lbWJlck5hbWUsIG5leHRBdHRyaWJ1dGVzKTtcblxuICBpZiAocHVibGljTmFtZSAhPT0gbWVtYmVyTmFtZSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90b3R5cGUsIHB1YmxpY05hbWUsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZ2V0T2JzZXJ2ZXIodGhpcywgcHVibGljTmFtZSkuY3VycmVudDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuLyoqXG4gKiBAZGVzY3JpcHRpb24gYE9ic2VydmVgIGlzIGEgcHJvcGVydHkgZGVjb3JhdG9yIGFuZCBjb252ZXJ0cyB0aGUgcHJvcGVydHkgaW50byBhIGByZWFjdGl2ZSBzdGF0ZWAuIFlvdSBjYW4gZGV0ZWN0IGl0cyBzdGF0dXMgdGhyb3VnaCBgLnN1YnNjcmliZWAuXG4gKiBAY2F0ZWdvcnkgUmVhY3RpdmUtRGVjb3JhdG9yXG4gKiBAc2VlIFJlYWN0aXZlU3Vic2NyaWJlXG4gKiBAZXhhbXBsZVxuKiBgYGB0c1xuaW1wb3J0IHsgUmVhY3RpdmVTdWJzY3JpYmUsIE9ic2VydmUgfSBmcm9tIFwiQGNmY3MvY29yZVwiO1xuXG5AUmVhY3RpdmVTdWJzY3JpYmVcbmNsYXNzIENvbXBvbmVudCB7XG4gIC8vIFRoZSBwdWJsaWMgbmFtZSBhbmQgc3RhdGUgbmFtZSBhcmUgdGhlIHNhbWUuXG4gIEBPYnNlcnZlIHZhbHVlMSA9IDE7XG4gIC8vIElmIHlvdSB3YW50IHRvIHNldCBwdWJsaWMgbmFtZSBhbmQgcHJpdmF0ZSBwcm9wZXJ0aWVzIHNlcGFyYXRlbHlcbiAgQE9ic2VydmUoXCJ2YWx1ZTJcIikgX3ZhbHVlMiA9IDE7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIHRoaXMudmFsdWUxID0gMjtcbiAgICB9KTtcbiAgfVxufVxuaW50ZXJmYWNlIENcbmBgYFxuICovXG5cblxuZnVuY3Rpb24gT2JzZXJ2ZSgpIHtcbiAgdmFyIGFyZ3MgPSBbXTtcblxuICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgfVxuXG4gIGlmIChhcmdzLmxlbmd0aCA+IDEpIHtcbiAgICByZXR1cm4gaW5qZWN0T2JzZXJ2ZShhcmdzWzBdLCBhcmdzWzFdKTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAocHJvdG90eXBlLCBtZW1iZXJOYW1lKSB7XG4gICAgcmV0dXJuIGluamVjdE9ic2VydmUocHJvdG90eXBlLCBtZW1iZXJOYW1lLCBhcmdzWzBdKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBjZmNzXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjItcHJlc2VudCBOQVZFUiBDb3JwLlxuICogTUlUIGxpY2Vuc2VcbiAqL1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cblxuZnVuY3Rpb24gaW5qZWN0UmVhY3RpdmVTdWJzY3JpYmUob2JqZWN0KSB7XG4gIG9iamVjdFtcInN1YnNjcmliZVwiXSA9IGZ1bmN0aW9uIChuYW1lLCBjYWxsYmFjaykge1xuICAgIHRoaXNbbmFtZV07XG4gICAgZ2V0T2JzZXJ2ZXIodGhpcywgbmFtZSkuc3Vic2NyaWJlKGNhbGxiYWNrKTtcbiAgfTtcblxuICBvYmplY3RbXCJ1bnN1YnNjcmliZVwiXSA9IGZ1bmN0aW9uIChuYW1lLCBjYWxsYmFjaykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBpZiAoIW5hbWUpIHtcbiAgICAgIGtleXMoZ2V0T2JzZXJ2ZXJzKHRoaXMpKS5mb3JFYWNoKGZ1bmN0aW9uIChvYnNlcnZlck5hbWUpIHtcbiAgICAgICAgX3RoaXMudW5zdWJzY3JpYmUob2JzZXJ2ZXJOYW1lKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghKG5hbWUgaW4gdGhpcykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBnZXRPYnNlcnZlcih0aGlzLCBuYW1lKS51bnN1YnNjcmliZShjYWxsYmFjayk7XG4gIH07XG59XG4vKipcbiAqIEBkZXNjcmlwdGlvbiBgUmVhY3RpdmVTdWJzY3JpYmVgIGlzIGEgY2xhc3MgZGVjb3JhdG9yIGFuZCBhZGRzIGAuc3Vic2NyaWJlYCBhbmQgYC51bnN1YnNjcmliZWAgbWV0aG9kcy5cbiAqIEBjYXRlZ29yeSBSZWFjdGl2ZS1EZWNvcmF0b3JcbiAqIEBzZWUgT2JzZXJ2ZVxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG5pbXBvcnQgeyBSZWFjdGl2ZVN1YnNjcmliZSwgT2JzZXJ2ZSB9IGZyb20gXCJAY2Zjcy9jb3JlXCI7XG5cbkBSZWFjdGl2ZVN1YnNjcmliZVxuY2xhc3MgQ29tcG9uZW50IHtcbiAgQE9ic2VydmUgdmFsdWUxID0gMTtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgdGhpcy52YWx1ZTEgPSAyO1xuICAgIH0pO1xuICB9XG59XG5cbmludGVyZmFjZSBDb21wb25lbnQgZXh0ZW5kcyBSZWFjdGl2ZVN1YnNjcmliZTx7XG4gIHZhbHVlMTogbnVtYmVyO1xuICB2YWx1ZTI6IG51bWJlcjtcbn0+IHt9XG5cbmNvbnN0IGNvbXBvbmVudCA9IG5ldyBDb21wb25lbnQoKTtcblxuLy8gMVxuY29uc29sZS5sb2coY29tcG9uZW50LnZhbHVlMSk7XG5cbmNvbXBvbmVudC5zdWJzY3JpYmUoXCJ2YWx1ZTFcIiwgbmV4dFZhbHVlID0+IHtcbiAgLy8gV2hlbiB0aGUgY2hhbmdlIGV2ZW50IG9jY3VycyA9PiAoMiwgMilcbiAgY29uc29sZS5sb2cobmV4dFZhbHVlLCBjb21wb25lbnQudmFsdWUyKTtcbn0pO1xuYGBgXG4gKi9cblxuZnVuY3Rpb24gUmVhY3RpdmVTdWJzY3JpYmUoQ29uc3RydWN0b3IpIHtcbiAgdmFyIHByb3RvdHlwZSA9IENvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgaW5qZWN0UmVhY3RpdmVTdWJzY3JpYmUocHJvdG90eXBlKTtcbn1cbi8qKlxuICogQGRlc2NyaXB0aW9uIENyZWF0ZXMgYSBtdXRhYmxlIHJlZiBvYmplY3QuIFlvdSBjYW4gYWNjZXNzIHRoZSBgLmN1cnJlbnRgIHZhbHVlIGFuZCBkZXRlY3QgdGhlIHZhbHVlIGNoYW5nZSB0aHJvdWdoIGAuc3Vic2NyaWJlYC5cbiAqIEBjYXRlZ29yeSBSZWFjdGl2ZVxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBvYnNlcnZlIH0gZnJvbSBcIkBjZmNzL2NvcmVcIjtcbiAqXG4gKiBjb25zdCBvYjEgPSBvYnNlcnZlKDEpO1xuICpcbiAqIG9iMS5zdWJzY3JpYmUobmV4dFZhbHVlID0+IHtcbiAqICAgY29uc29sZS5sb2cobmV4dFZhbHVlKTtcbiAqIH0pO1xuICpcbiAqIG9iMS5jdXJyZW50ID0gMjtcbiAqIGBgYFxuICovXG5cbmZ1bmN0aW9uIG9ic2VydmUoZGVmYXVsdFZhbHVlKSB7XG4gIHJldHVybiBuZXcgT2JzZXJ2ZXIoZGVmYXVsdFZhbHVlKTtcbn1cbi8qKlxuICogQGhpZGRlblxuICovXG5cbmZ1bmN0aW9uIGNvbXB1dGVkKGNvbXB1dGVkQ2FsbGJhY2spIHtcbiAgcmV0dXJuIG5ldyBDb21wdXRlZE9ic2VydmVyKGNvbXB1dGVkQ2FsbGJhY2spO1xufVxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cblxuZnVuY3Rpb24gZGVmaW5lT2JzZXJ2ZXJzKGluc3RhbmNlKSB7XG4gIHZhciBvYnNlcnZlcnMgPSB7fTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGluc3RhbmNlLCBPQlNFUlZFUlNfUEFUSCwge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG9ic2VydmVycztcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb2JzZXJ2ZXJzO1xufVxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cblxuZnVuY3Rpb24gZ2V0T2JzZXJ2ZXJzKGluc3RhbmNlLCBpc0NvbXB1dGVkKSB7XG4gIHZhciBfYSwgX2I7XG5cbiAgaWYgKCFpbnN0YW5jZVtPQlNFUlZFUlNfUEFUSF0pIHtcbiAgICBkZWZpbmVPYnNlcnZlcnMoaW5zdGFuY2UpO1xuICB9XG5cbiAgdmFyIG9ic2VydmVycyA9IGluc3RhbmNlW09CU0VSVkVSU19QQVRIXTtcblxuICBpZiAoIWlzQ29tcHV0ZWQpIHtcbiAgICB2YXIgY29tcHV0ZWRMaXN0ID0gKF9iID0gKF9hID0gaW5zdGFuY2UgPT09IG51bGwgfHwgaW5zdGFuY2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGluc3RhbmNlLmNvbnN0cnVjdG9yKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucHJvdG90eXBlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbQ09NUFVURURfUEFUSF07XG5cbiAgICBpZiAoY29tcHV0ZWRMaXN0KSB7XG4gICAgICBjb21wdXRlZExpc3QuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBpZiAoIShuYW1lIGluIG9ic2VydmVycykgJiYgbmFtZSBpbiBpbnN0YW5jZSkge1xuICAgICAgICAgIGluc3RhbmNlW25hbWVdO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JzZXJ2ZXJzO1xufVxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cblxuZnVuY3Rpb24gZ2V0T2JzZXJ2ZXIoaW5zdGFuY2UsIG5hbWUsIGRlZmF1bHRWYWx1ZSkge1xuICB2YXIgb2JzZXJ2ZXJzID0gZ2V0T2JzZXJ2ZXJzKGluc3RhbmNlKTtcblxuICBpZiAoIW9ic2VydmVyc1tuYW1lXSkge1xuICAgIG9ic2VydmVyc1tuYW1lXSA9IG9ic2VydmUoZGVmYXVsdFZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiBvYnNlcnZlcnNbbmFtZV07XG59XG5cbi8qKlxuICogY2Zjc1xuICogQ29weXJpZ2h0IChjKSAyMDIyLXByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIE1JVCBsaWNlbnNlXG4gKi9cbi8qKlxuICogQGRlc2NyaXB0aW9uIGBDb21wdXRlZGAgaXMgYSBwcm9wZXJ0eSBkZWNvcmF0b3IuXG4gKiBDaGFuZ2VzIGluIGNvbXB1dGVkIHN0YXRlIHZhbHVlcyBhcmUgYWxzbyByZWNvZ25pemVkIGFjY29yZGluZyB0byBjaGFuZ2VzIGluIG9ic2VydmVycyB1c2VkIHdpdGhpbiB0aGUgZ2V0dGVyIGZ1bmN0aW9uLlxuICogWW91IGNhbiBkZXRlY3QgaXRzIHN0YXR1cyB0aHJvdWdoIGAuc3Vic2NyaWJlYC5cbiAqIEBoaWRkZW5cbiAqIEBjYXRlZ29yeSBSZWFjdGl2ZS1EZWNvcmF0b3JcbiAqIEBzZWUgUmVhY3RpdmVTdWJzY3JpYmVcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuY29uc3Qgb2IxID0gb2JzZXJ2ZSgwKTtcbmNvbnN0IG9iMiA9IG9ic2VydmUoMSk7XG5cbi8vIFdoZW5cbkBSZWFjdGl2ZVN1YnNjcmliZVxuY2xhc3MgVGVzdENvbXB1dGVkIHtcbiAgQENvbXB1dGVkXG4gIGdldCBvYjMoKSB7XG4gICAgcmV0dXJuIG9iMS5jdXJyZW50ICsgb2IyLmN1cnJlbnQ7XG4gIH1cbn1cbmNvbnN0IGluc3QgPSBuZXcgVGVzdENvbXB1dGVkKCk7XG5cbmluc3Quc3Vic2NyaWJlKFwib2IzXCIsIG9iMyA9PiB7XG4gIGNvbnNvbGUubG9nKG9iMyk7XG59KTtcblxub2IxLmN1cnJlbnQgPSAxO1xuYGBgXG4gKi9cblxuZnVuY3Rpb24gQ29tcHV0ZWQocHJvdG90eXBlLCBtZW1iZXJOYW1lLCBhdHRyaWJ1dGVzKSB7XG4gIHZhciBnZXQgPSBhdHRyaWJ1dGVzLmdldDtcblxuICBmdW5jdGlvbiBnZXRDb21wdXRlZCgpIHtcbiAgICB2YXIgb2JzZXJ2ZXJzID0gZ2V0T2JzZXJ2ZXJzKHRoaXMsIHRydWUpO1xuXG4gICAgaWYgKCEobWVtYmVyTmFtZSBpbiBvYnNlcnZlcnMpKSB7XG4gICAgICBvYnNlcnZlcnNbbWVtYmVyTmFtZV0gPSBjb21wdXRlZChnZXQuYmluZCh0aGlzKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdldE9ic2VydmVyKHRoaXMsIG1lbWJlck5hbWUpLmN1cnJlbnQ7XG4gIH1cblxuICB2YXIgbmV4dEF0dHJpYnV0ZXMgPSB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZ2V0Q29tcHV0ZWRcbiAgfTtcbiAgcHJvdG90eXBlW0NPTVBVVEVEX1BBVEhdIHx8IChwcm90b3R5cGVbQ09NUFVURURfUEFUSF0gPSBbXSk7XG4gIHZhciBjb21wdXRlZExpc3QgPSBwcm90b3R5cGVbQ09NUFVURURfUEFUSF07XG5cbiAgaWYgKGNvbXB1dGVkTGlzdC5pbmRleE9mKG1lbWJlck5hbWUpID09PSAtMSkge1xuICAgIGNvbXB1dGVkTGlzdC5wdXNoKG1lbWJlck5hbWUpO1xuICB9XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvdHlwZSwgbWVtYmVyTmFtZSwgbmV4dEF0dHJpYnV0ZXMpO1xuICByZXR1cm4gbmV4dEF0dHJpYnV0ZXM7XG59XG5cbi8qXG5Db3B5cmlnaHQgKGMpIE5BVkVSIENvcnAuXG5uYW1lOiBAZWdqcy9heGVzXG5saWNlbnNlOiBNSVRcbmF1dGhvcjogTkFWRVIgQ29ycC5cbnJlcG9zaXRvcnk6IGh0dHBzOi8vZ2l0aHViLmNvbS9uYXZlci9lZ2pzLWF4ZXNcbnZlcnNpb246IDMuOS4xXG4qL1xuXG4vKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZVxyXG50aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZVxyXG5MaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVEhJUyBDT0RFIElTIFBST1ZJREVEIE9OIEFOICpBUyBJUyogQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG5LSU5ELCBFSVRIRVIgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgV0lUSE9VVCBMSU1JVEFUSU9OIEFOWSBJTVBMSUVEXHJcbldBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBUSVRMRSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UsXHJcbk1FUkNIQU5UQUJMSVRZIE9SIE5PTi1JTkZSSU5HRU1FTlQuXHJcblxyXG5TZWUgdGhlIEFwYWNoZSBWZXJzaW9uIDIuMCBMaWNlbnNlIGZvciBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnNcclxuYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cblxudmFyIGV4dGVuZFN0YXRpY3MkMSA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gIGV4dGVuZFN0YXRpY3MkMSA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCB7XG4gICAgX19wcm90b19fOiBbXVxuICB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBkLl9fcHJvdG9fXyA9IGI7XG4gIH0gfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgfTtcbiAgcmV0dXJuIGV4dGVuZFN0YXRpY3MkMShkLCBiKTtcbn07XG5mdW5jdGlvbiBfX2V4dGVuZHMkMShkLCBiKSB7XG4gIGV4dGVuZFN0YXRpY3MkMShkLCBiKTtcbiAgZnVuY3Rpb24gX18oKSB7XG4gICAgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7XG4gIH1cbiAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufVxudmFyIF9fYXNzaWduID0gZnVuY3Rpb24gKCkge1xuICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xuICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XG4gICAgfVxuICAgIHJldHVybiB0O1xuICB9O1xuICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5mdW5jdGlvbiBfX2RlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYyxcbiAgICBkO1xuICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO2Vsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59XG5cbi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgTkFWRVIgQ29ycC5cbiAqIGVnanMgcHJvamVjdHMgYXJlIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1uZXctZnVuYywgbm8tbmVzdGVkLXRlcm5hcnkgKi9cbnZhciB3aW47XG5pZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAvLyB3aW5kb3cgaXMgdW5kZWZpbmVkIGluIG5vZGUuanNcbiAgd2luID0ge1xuICAgIG5hdmlnYXRvcjoge1xuICAgICAgdXNlckFnZW50OiBcIlwiXG4gICAgfVxuICB9O1xufSBlbHNlIHtcbiAgd2luID0gd2luZG93O1xufVxuXG4vKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IE5BVkVSIENvcnAuXG4gKiBlZ2pzIHByb2plY3RzIGFyZSBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xudmFyIERJUkVDVElPTl9OT05FID0gMTtcbnZhciBESVJFQ1RJT05fTEVGVCA9IDI7XG52YXIgRElSRUNUSU9OX1JJR0hUID0gNDtcbnZhciBESVJFQ1RJT05fSE9SSVpPTlRBTCA9IDIgfCA0O1xudmFyIERJUkVDVElPTl9VUCA9IDg7XG52YXIgRElSRUNUSU9OX0RPV04gPSAxNjtcbnZhciBESVJFQ1RJT05fVkVSVElDQUwgPSA4IHwgMTY7XG52YXIgRElSRUNUSU9OX0FMTCA9IDIgfCA0IHwgOCB8IDE2O1xudmFyIE1PVVNFX0xFRlQgPSBcImxlZnRcIjtcbnZhciBNT1VTRV9SSUdIVCA9IFwicmlnaHRcIjtcbnZhciBNT1VTRV9NSURETEUgPSBcIm1pZGRsZVwiO1xudmFyIE1PVVNFX0JVVFRPTl9DT0RFX01BUCA9IHtcbiAgMTogTU9VU0VfTEVGVCxcbiAgMjogTU9VU0VfTUlERExFLFxuICAzOiBNT1VTRV9SSUdIVFxufTtcbnZhciBBTlkgPSBcImFueVwiO1xudmFyIE5PTkUgPSBcIm5vbmVcIjtcbnZhciBTSElGVCA9IFwic2hpZnRcIjtcbnZhciBDVFJMID0gXCJjdHJsXCI7XG52YXIgQUxUID0gXCJhbHRcIjtcbnZhciBNRVRBID0gXCJtZXRhXCI7XG52YXIgVkVMT0NJVFlfSU5URVJWQUwgPSAxNjtcbnZhciBJT1NfRURHRV9USFJFU0hPTEQgPSAzMDtcbnZhciBJU19JT1NfU0FGQVJJID0gXCJvbnRvdWNoc3RhcnRcIiBpbiB3aW4gJiYgYWdlbnQoKS5icm93c2VyLm5hbWUgPT09IFwic2FmYXJpXCI7XG52YXIgVFJBTlNGT1JNID0gZnVuY3Rpb24gKCkge1xuICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbiAgdmFyIGJvZHlTdHlsZSA9IChkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXSkuc3R5bGU7XG4gIHZhciB0YXJnZXQgPSBbXCJ0cmFuc2Zvcm1cIiwgXCJ3ZWJraXRUcmFuc2Zvcm1cIiwgXCJtc1RyYW5zZm9ybVwiLCBcIm1velRyYW5zZm9ybVwiXTtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRhcmdldC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmICh0YXJnZXRbaV0gaW4gYm9keVN0eWxlKSB7XG4gICAgICByZXR1cm4gdGFyZ2V0W2ldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gXCJcIjtcbn0oKTtcbnZhciBQUkVWRU5UX0RSQUdfQ1NTUFJPUFMgPSB7XG4gIFwiLXdlYmtpdC11c2VyLXNlbGVjdFwiOiBcIm5vbmVcIixcbiAgXCItbXMtdXNlci1zZWxlY3RcIjogXCJub25lXCIsXG4gIFwiLW1vei11c2VyLXNlbGVjdFwiOiBcIm5vbmVcIixcbiAgXCJ1c2VyLXNlbGVjdFwiOiBcIm5vbmVcIixcbiAgXCItd2Via2l0LXVzZXItZHJhZ1wiOiBcIm5vbmVcIlxufTtcblxudmFyIHRvQXJyYXkgPSBmdW5jdGlvbiAobm9kZXMpIHtcbiAgLy8gY29uc3QgZWwgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChub2Rlcyk7XG4gIC8vIGZvciBJRThcbiAgdmFyIGVsID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBub2Rlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGVsLnB1c2gobm9kZXNbaV0pO1xuICB9XG4gIHJldHVybiBlbDtcbn07XG52YXIgJCQxID0gZnVuY3Rpb24gKHBhcmFtLCBtdWx0aSkge1xuICBpZiAobXVsdGkgPT09IHZvaWQgMCkge1xuICAgIG11bHRpID0gZmFsc2U7XG4gIH1cbiAgdmFyIGVsO1xuICBpZiAodHlwZW9mIHBhcmFtID09PSBcInN0cmluZ1wiKSB7XG4gICAgLy8gU3RyaW5nIChIVE1MLCBTZWxlY3RvcilcbiAgICAvLyBjaGVjayBpZiBzdHJpbmcgaXMgSFRNTCB0YWcgZm9ybWF0XG4gICAgdmFyIG1hdGNoID0gcGFyYW0ubWF0Y2goL148KFthLXpdKylcXHMqKFtePl0qKT4vKTtcbiAgICAvLyBjcmVhdGluZyBlbGVtZW50XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICAvLyBIVE1MXG4gICAgICB2YXIgZHVtbXkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgZHVtbXkuaW5uZXJIVE1MID0gcGFyYW07XG4gICAgICBlbCA9IHRvQXJyYXkoZHVtbXkuY2hpbGROb2Rlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFNlbGVjdG9yXG4gICAgICBlbCA9IHRvQXJyYXkoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChwYXJhbSkpO1xuICAgIH1cbiAgICBpZiAoIW11bHRpKSB7XG4gICAgICBlbCA9IGVsLmxlbmd0aCA+PSAxID8gZWxbMF0gOiB1bmRlZmluZWQ7XG4gICAgfVxuICB9IGVsc2UgaWYgKHBhcmFtID09PSB3aW4pIHtcbiAgICAvLyB3aW5kb3dcbiAgICBlbCA9IHBhcmFtO1xuICB9IGVsc2UgaWYgKFwidmFsdWVcIiBpbiBwYXJhbSB8fCBcImN1cnJlbnRcIiBpbiBwYXJhbSkge1xuICAgIGVsID0gcGFyYW0udmFsdWUgfHwgcGFyYW0uY3VycmVudDtcbiAgfSBlbHNlIGlmIChwYXJhbS5ub2RlTmFtZSAmJiAocGFyYW0ubm9kZVR5cGUgPT09IDEgfHwgcGFyYW0ubm9kZVR5cGUgPT09IDkpKSB7XG4gICAgLy8gSFRNTEVsZW1lbnQsIERvY3VtZW50XG4gICAgZWwgPSBwYXJhbTtcbiAgfSBlbHNlIGlmIChcImpRdWVyeVwiIGluIHdpbiAmJiBwYXJhbSBpbnN0YW5jZW9mIGpRdWVyeSB8fCBwYXJhbS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUuanF1ZXJ5KSB7XG4gICAgLy8galF1ZXJ5XG4gICAgZWwgPSBtdWx0aSA/IHBhcmFtLnRvQXJyYXkoKSA6IHBhcmFtLmdldCgwKTtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHBhcmFtKSkge1xuICAgIGVsID0gcGFyYW0ubWFwKGZ1bmN0aW9uICh2KSB7XG4gICAgICByZXR1cm4gJCQxKHYpO1xuICAgIH0pO1xuICAgIGlmICghbXVsdGkpIHtcbiAgICAgIGVsID0gZWwubGVuZ3RoID49IDEgPyBlbFswXSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGVsO1xufTtcbnZhciByYWYgPSB3aW4ucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbi53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG52YXIgY2FmID0gd2luLmNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IHdpbi53ZWJraXRDYW5jZWxBbmltYXRpb25GcmFtZTtcbmlmIChyYWYgJiYgIWNhZikge1xuICB2YXIga2V5SW5mb18xID0ge307XG4gIHZhciBvbGRyYWZfMSA9IHJhZjtcbiAgcmFmID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgdmFyIHdyYXBDYWxsYmFjayA9IGZ1bmN0aW9uICh0aW1lc3RhbXApIHtcbiAgICAgIGlmIChrZXlJbmZvXzFba2V5XSkge1xuICAgICAgICBjYWxsYmFjayh0aW1lc3RhbXApO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIGtleSA9IG9sZHJhZl8xKHdyYXBDYWxsYmFjayk7XG4gICAga2V5SW5mb18xW2tleV0gPSB0cnVlO1xuICAgIHJldHVybiBrZXk7XG4gIH07XG4gIGNhZiA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICBkZWxldGUga2V5SW5mb18xW2tleV07XG4gIH07XG59IGVsc2UgaWYgKCEocmFmICYmIGNhZikpIHtcbiAgcmFmID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHdpbi5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGNhbGxiYWNrKHdpbi5wZXJmb3JtYW5jZSAmJiB3aW4ucGVyZm9ybWFuY2Uubm93ICYmIHdpbi5wZXJmb3JtYW5jZS5ub3coKSB8fCBuZXcgRGF0ZSgpLmdldFRpbWUoKSk7XG4gICAgfSwgMTYpO1xuICB9O1xuICBjYWYgPSB3aW4uY2xlYXJUaW1lb3V0O1xufVxuLyoqXG4gKiBBIHBvbHlmaWxsIGZvciB0aGUgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgpIG1ldGhvZC5cbiAqIEBzZWUgIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS93aW5kb3cvcmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgcmVxdWVzdEFuaW1hdGlvbkZyYW1lJDEgPSBmdW5jdGlvbiAoZnApIHtcbiAgcmV0dXJuIHJhZihmcCk7XG59O1xuLyoqXG4gKiBBIHBvbHlmaWxsIGZvciB0aGUgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKCkgbWV0aG9kLiBJdCBjYW5jZWxzIGFuIGFuaW1hdGlvbiBleGVjdXRlZCB0aHJvdWdoIGEgY2FsbCB0byB0aGUgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCkgbWV0aG9kLlxuICogQHBhcmFtIHtOdW1iZXJ9IGtleSDiiJIgIFRoZSBJRCB2YWx1ZSByZXR1cm5lZCB0aHJvdWdoIGEgY2FsbCB0byB0aGUgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCkgbWV0aG9kLiA8a28+cmVxdWVzdEFuaW1hdGlvbkZyYW1lKCkg66mU7ISc65Oc6rCAIOuwmO2ZmO2VnCDslYTsnbTrlJQg6rCSPC9rbz5cbiAqIEBzZWUgIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XaW5kb3cvY2FuY2VsQW5pbWF0aW9uRnJhbWVcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBjYW5jZWxBbmltYXRpb25GcmFtZSQxID0gZnVuY3Rpb24gKGtleSkge1xuICBjYWYoa2V5KTtcbn07XG52YXIgbWFwID0gZnVuY3Rpb24gKG9iaiwgY2FsbGJhY2spIHtcbiAgdmFyIHRyYW5mb3JtZWQgPSB7fTtcbiAgZm9yICh2YXIgayBpbiBvYmopIHtcbiAgICBpZiAoaykge1xuICAgICAgdHJhbmZvcm1lZFtrXSA9IGNhbGxiYWNrKG9ialtrXSwgayk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cmFuZm9ybWVkO1xufTtcbnZhciBmaWx0ZXIgPSBmdW5jdGlvbiAob2JqLCBjYWxsYmFjaykge1xuICB2YXIgZmlsdGVyZWQgPSB7fTtcbiAgZm9yICh2YXIgayBpbiBvYmopIHtcbiAgICBpZiAoayAmJiBjYWxsYmFjayhvYmpba10sIGspKSB7XG4gICAgICBmaWx0ZXJlZFtrXSA9IG9ialtrXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZpbHRlcmVkO1xufTtcbnZhciBldmVyeSA9IGZ1bmN0aW9uIChvYmosIGNhbGxiYWNrKSB7XG4gIGZvciAodmFyIGsgaW4gb2JqKSB7XG4gICAgaWYgKGsgJiYgIWNhbGxiYWNrKG9ialtrXSwgaykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xudmFyIGVxdWFsID0gZnVuY3Rpb24gKHRhcmdldCwgYmFzZSkge1xuICByZXR1cm4gZXZlcnkodGFyZ2V0LCBmdW5jdGlvbiAodiwgaykge1xuICAgIHJldHVybiB2ID09PSBiYXNlW2tdO1xuICB9KTtcbn07XG52YXIgcm91bmROdW1GdW5jID0ge307XG52YXIgcm91bmROdW1iZXIgPSBmdW5jdGlvbiAobnVtLCByb3VuZFVuaXQpIHtcbiAgLy8gQ2FjaGUgZm9yIHBlcmZvcm1hbmNlXG4gIGlmICghcm91bmROdW1GdW5jW3JvdW5kVW5pdF0pIHtcbiAgICByb3VuZE51bUZ1bmNbcm91bmRVbml0XSA9IGdldFJvdW5kRnVuYyhyb3VuZFVuaXQpO1xuICB9XG4gIHJldHVybiByb3VuZE51bUZ1bmNbcm91bmRVbml0XShudW0pO1xufTtcbnZhciByb3VuZE51bWJlcnMgPSBmdW5jdGlvbiAobnVtLCByb3VuZFVuaXQpIHtcbiAgaWYgKCFudW0gfHwgIXJvdW5kVW5pdCkge1xuICAgIHJldHVybiBudW07XG4gIH1cbiAgcmV0dXJuIG1hcChudW0sIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgcmV0dXJuIHJvdW5kTnVtYmVyKHZhbHVlLCB0eXBlb2Ygcm91bmRVbml0ID09PSBcIm51bWJlclwiID8gcm91bmRVbml0IDogcm91bmRVbml0W2tleV0pO1xuICB9KTtcbn07XG52YXIgZ2V0RGVjaW1hbFBsYWNlID0gZnVuY3Rpb24gKHZhbCkge1xuICBpZiAoIWlzRmluaXRlKHZhbCkpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICB2YXIgdiA9IFwiXCIuY29uY2F0KHZhbCk7XG4gIGlmICh2LmluZGV4T2YoXCJlXCIpID49IDApIHtcbiAgICAvLyBFeHBvbmVudGlhbCBGb3JtYXRcbiAgICAvLyAxZS0xMCwgMWUtMTJcbiAgICB2YXIgcCA9IDA7XG4gICAgdmFyIGUgPSAxO1xuICAgIHdoaWxlIChNYXRoLnJvdW5kKHZhbCAqIGUpIC8gZSAhPT0gdmFsKSB7XG4gICAgICBlICo9IDEwO1xuICAgICAgcCsrO1xuICAgIH1cbiAgICByZXR1cm4gcDtcbiAgfVxuICAvLyBJbiBnZW5lcmFsLCBmb2xsb3dpbmcgaGFzIHBlcmZvcm1hbmNlIGJlbmVmaXQuXG4gIC8vIGh0dHBzOi8vanNwZXJmLmNvbS9wcmVjaXNpb24tY2FsY3VsYXRpb25cbiAgcmV0dXJuIHYuaW5kZXhPZihcIi5cIikgPj0gMCA/IHYubGVuZ3RoIC0gdi5pbmRleE9mKFwiLlwiKSAtIDEgOiAwO1xufTtcbnZhciBpbnZlcnNlUG93ID0gZnVuY3Rpb24gKG4pIHtcbiAgLy8gcmVwbGFjZSBNYXRoLnBvdygxMCwgLW4pIHRvIHNvbHZlIGZsb2F0aW5nIHBvaW50IGlzc3VlLlxuICAvLyBlZy4gTWF0aC5wb3coMTAsIC00KSA9PiAwLjAwMDA5OTk5OTk5OTk5OTk5OTk5XG4gIHJldHVybiAxIC8gTWF0aC5wb3coMTAsIG4pO1xufTtcbnZhciBnZXRSb3VuZEZ1bmMgPSBmdW5jdGlvbiAodikge1xuICB2YXIgcCA9IHYgPCAxID8gTWF0aC5wb3coMTAsIGdldERlY2ltYWxQbGFjZSh2KSkgOiAxO1xuICByZXR1cm4gZnVuY3Rpb24gKG4pIHtcbiAgICBpZiAodiA9PT0gMCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiBNYXRoLnJvdW5kKE1hdGgucm91bmQobiAvIHYpICogdiAqIHApIC8gcDtcbiAgfTtcbn07XG52YXIgZ2V0QW5nbGUgPSBmdW5jdGlvbiAocG9zWCwgcG9zWSkge1xuICByZXR1cm4gTWF0aC5hdGFuMihwb3NZLCBwb3NYKSAqIDE4MCAvIE1hdGguUEk7XG59O1xudmFyIGlzQ3NzUHJvcHNGcm9tQXhlcyA9IGZ1bmN0aW9uIChvcmlnaW5hbENzc1Byb3BzKSB7XG4gIHZhciBzYW1lID0gdHJ1ZTtcbiAgT2JqZWN0LmtleXMoUFJFVkVOVF9EUkFHX0NTU1BST1BTKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgaWYgKCFvcmlnaW5hbENzc1Byb3BzIHx8IG9yaWdpbmFsQ3NzUHJvcHNbcHJvcF0gIT09IFBSRVZFTlRfRFJBR19DU1NQUk9QU1twcm9wXSkge1xuICAgICAgc2FtZSA9IGZhbHNlO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBzYW1lO1xufTtcbnZhciBnZXREaXJlY3Rpb24gPSBmdW5jdGlvbiAodXNlSG9yaXpvbnRhbCwgdXNlVmVydGljYWwpIHtcbiAgaWYgKHVzZUhvcml6b250YWwgJiYgdXNlVmVydGljYWwpIHtcbiAgICByZXR1cm4gRElSRUNUSU9OX0FMTDtcbiAgfSBlbHNlIGlmICh1c2VIb3Jpem9udGFsKSB7XG4gICAgcmV0dXJuIERJUkVDVElPTl9IT1JJWk9OVEFMO1xuICB9IGVsc2UgaWYgKHVzZVZlcnRpY2FsKSB7XG4gICAgcmV0dXJuIERJUkVDVElPTl9WRVJUSUNBTDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gRElSRUNUSU9OX05PTkU7XG4gIH1cbn07XG52YXIgdXNlRGlyZWN0aW9uID0gZnVuY3Rpb24gKGNoZWNrVHlwZSwgZGlyZWN0aW9uLCB1c2VyRGlyZWN0aW9uKSB7XG4gIGlmICh1c2VyRGlyZWN0aW9uKSB7XG4gICAgcmV0dXJuICEhKGRpcmVjdGlvbiA9PT0gRElSRUNUSU9OX0FMTCB8fCBkaXJlY3Rpb24gJiBjaGVja1R5cGUgJiYgdXNlckRpcmVjdGlvbiAmIGNoZWNrVHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICEhKGRpcmVjdGlvbiAmIGNoZWNrVHlwZSk7XG4gIH1cbn07XG52YXIgc2V0Q3NzUHJvcHMgPSBmdW5jdGlvbiAoZWxlbWVudCwgb3B0aW9uLCBkaXJlY3Rpb24pIHtcbiAgdmFyIF9hO1xuICB2YXIgdG91Y2hBY3Rpb25NYXAgPSAoX2EgPSB7fSwgX2FbRElSRUNUSU9OX05PTkVdID0gXCJhdXRvXCIsIF9hW0RJUkVDVElPTl9BTExdID0gXCJub25lXCIsIF9hW0RJUkVDVElPTl9WRVJUSUNBTF0gPSBcInBhbi14XCIsIF9hW0RJUkVDVElPTl9IT1JJWk9OVEFMXSA9IFwicGFuLXlcIiwgX2EpO1xuICB2YXIgb2xkQ3NzUHJvcHMgPSB7fTtcbiAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5zdHlsZSkge1xuICAgIHZhciB0b3VjaEFjdGlvbiA9IG9wdGlvbi50b3VjaEFjdGlvbiA/IG9wdGlvbi50b3VjaEFjdGlvbiA6IHRvdWNoQWN0aW9uTWFwW2RpcmVjdGlvbl07XG4gICAgdmFyIG5ld0Nzc1Byb3BzXzEgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgUFJFVkVOVF9EUkFHX0NTU1BST1BTKSwge1xuICAgICAgXCJ0b3VjaC1hY3Rpb25cIjogZWxlbWVudC5zdHlsZVtcInRvdWNoLWFjdGlvblwiXSA9PT0gXCJub25lXCIgPyBcIm5vbmVcIiA6IHRvdWNoQWN0aW9uXG4gICAgfSk7XG4gICAgT2JqZWN0LmtleXMobmV3Q3NzUHJvcHNfMSkuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgb2xkQ3NzUHJvcHNbcHJvcF0gPSBlbGVtZW50LnN0eWxlW3Byb3BdO1xuICAgIH0pO1xuICAgIC8vIE9sZCBzdHlsZSBwcm9wcyBsaWtlIHVzZXItc2VsZWN0IGNhbiBiZSBjb3JydXB0ZWQgaWYgeW91IGNoYW5nZSB0aGUgc3R5bGUgZGlyZWN0bHkgaW4gdGhlIGxvZ2ljIGFib3ZlLlxuICAgIE9iamVjdC5rZXlzKG5ld0Nzc1Byb3BzXzEpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgIGVsZW1lbnQuc3R5bGVbcHJvcF0gPSBuZXdDc3NQcm9wc18xW3Byb3BdO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBvbGRDc3NQcm9wcztcbn07XG52YXIgcmV2ZXJ0Q3NzUHJvcHMgPSBmdW5jdGlvbiAoZWxlbWVudCwgb3JpZ2luYWxDc3NQcm9wcykge1xuICBpZiAoZWxlbWVudCAmJiBlbGVtZW50LnN0eWxlICYmIG9yaWdpbmFsQ3NzUHJvcHMpIHtcbiAgICBPYmplY3Qua2V5cyhvcmlnaW5hbENzc1Byb3BzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICBlbGVtZW50LnN0eWxlW3Byb3BdID0gb3JpZ2luYWxDc3NQcm9wc1twcm9wXTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm47XG59O1xuXG52YXIgRXZlbnRNYW5hZ2VyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRXZlbnRNYW5hZ2VyKF9heGVzKSB7XG4gICAgdGhpcy5fYXhlcyA9IF9heGVzO1xuICAgIHRoaXMuaG9sZGluZ0NvdW50ID0gMDtcbiAgfVxuICAvKipcbiAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIGEgdXNlciBob2xkcyBhbiBlbGVtZW50IG9uIHRoZSBzY3JlZW4gb2YgdGhlIGRldmljZS5cbiAgICogQGtvIOyCrOyaqeyekOqwgCDquLDquLDsnZgg7ZmU66m07JeQIOyGkOydhCDrjIDqs6Ag7J6I7J2EIOuVjCDrsJzsg53tlZjripQg7J2067Kk7Yq4XG4gICAqIEBldmVudCBBeGVzI2hvbGRcbiAgICogQHR5cGUge29iamVjdH1cbiAgICogQHByb3BlcnR5IHtPYmplY3QuPHN0cmluZywgbnVtYmVyPn0gcG9zIGNvb3JkaW5hdGUgPGtvPuyijO2RnCDsoJXrs7Q8L2tvPlxuICAgKiBAcHJvcGVydHkge09iamVjdH0gaW5wdXQgVGhlIGluc3RhbmNlIG9mIGlucHV0VHlwZSB3aGVyZSB0aGUgZXZlbnQgb2NjdXJyZWQ8a28+7J2067Kk7Yq46rCAIOuwnOyDne2VnCBpbnB1dFR5cGUg7J247Iqk7YS07IqkPC9rbz5cbiAgICogQHByb3BlcnR5IHtPYmplY3R9IGlucHV0RXZlbnQgVGhlIGV2ZW50IG9iamVjdCByZWNlaXZlZCBmcm9tIGlucHV0VHlwZSA8a28+aW5wdXRUeXBl7Jy866GcIOu2gO2EsCDrsJvsnYAg7J2067Kk7Yq4IOqwneyytDwva28+XG4gICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gaXNUcnVzdGVkIFJldHVybnMgdHJ1ZSBpZiBhbiBldmVudCB3YXMgZ2VuZXJhdGVkIGJ5IHRoZSB1c2VyIGFjdGlvbiwgb3IgZmFsc2UgaWYgaXQgd2FzIGNhdXNlZCBieSBhIHNjcmlwdCBvciBBUEkgY2FsbCA8a28+7IKs7Jqp7J6Q7J2YIOyVoeyFmOyXkCDsnZjtlbQg7J2067Kk7Yq46rCAIOuwnOyDne2VmOyYgOycvOuptCB0cnVlLCDsiqTtgazrpr3tirjrgpggQVBJ7Zi47Lac7JeQIOydmO2VtCDrsJzsg53tlZjsmIDsnYQg6rK97Jqw7JeQ64qUIGZhbHNl66W8IOuwmO2ZmO2VnOuLpC48L2tvPlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBjb25zdCBheGVzID0gbmV3IGVnLkF4ZXMoe1xuICAgKiAgIFwieFwiOiB7XG4gICAqICAgICAgcmFuZ2U6IFswLCAxMDBdXG4gICAqICAgfSxcbiAgICogICBcInpvb21cIjoge1xuICAgKiAgICAgIHJhbmdlOiBbNTAsIDMwXVxuICAgKiAgIH1cbiAgICogfSkub24oXCJob2xkXCIsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAqICAgLy8gZXZlbnQucG9zXG4gICAqICAgLy8gZXZlbnQuaW5wdXRcbiAgICogICAvLyBldmVudC5pbnB1dEV2ZW50XG4gICAqICAgLy8gaXNUcnVzdGVkXG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICovXG4gIHZhciBfX3Byb3RvID0gRXZlbnRNYW5hZ2VyLnByb3RvdHlwZTtcbiAgX19wcm90by5ob2xkID0gZnVuY3Rpb24gKHBvcywgb3B0aW9uKSB7XG4gICAgdmFyIHJvdW5kUG9zID0gdGhpcy5fZ2V0Um91bmRQb3MocG9zKS5yb3VuZFBvcztcbiAgICB0aGlzLl9heGVzLnRyaWdnZXIobmV3IENvbXBvbmVudEV2ZW50JDEoXCJob2xkXCIsIHtcbiAgICAgIHBvczogcm91bmRQb3MsXG4gICAgICBpbnB1dDogb3B0aW9uLmlucHV0IHx8IG51bGwsXG4gICAgICBpbnB1dEV2ZW50OiBvcHRpb24uZXZlbnQgfHwgbnVsbCxcbiAgICAgIGlzVHJ1c3RlZDogdHJ1ZVxuICAgIH0pKTtcbiAgfTtcbiAgLyoqXG4gICAqIFNwZWNpZmllcyB0aGUgY29vcmRpbmF0ZXMgdG8gbW92ZSBhZnRlciB0aGUgJ2NoYW5nZScgZXZlbnQuIEl0IHdvcmtzIHdoZW4gdGhlIGhvbGRpbmcgdmFsdWUgb2YgdGhlIGNoYW5nZSBldmVudCBpcyB0cnVlLlxuICAgKiBAa28gJ2NoYW5nZScg7J2067Kk7Yq4IOydtO2bhCDsnbTrj5ntlaAg7KKM7ZGc66W8IOyngOygle2VnOuLpC4gY2hhbmdl7J2067Kk7Yq47J2YIGhvbGRpbmcg6rCS7J20IHRydWXsnbwg6rK97Jqw7JeQIOuPmeyeke2VnOuLpFxuICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCBudW1iZXI+fSBwb3MgVGhlIGNvb3JkaW5hdGUgdG8gbW92ZSB0byA8a28+7J2064+Z7ZWgIOyijO2RnDwva28+XG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IGF4ZXMgPSBuZXcgZWcuQXhlcyh7XG4gICAqICAgXCJ4XCI6IHtcbiAgICogICAgICByYW5nZTogWzAsIDEwMF1cbiAgICogICB9LFxuICAgKiAgIFwiem9vbVwiOiB7XG4gICAqICAgICAgcmFuZ2U6IFs1MCwgMzBdXG4gICAqICAgfVxuICAgKiB9KS5vbihcImNoYW5nZVwiLCBmdW5jdGlvbihldmVudCkge1xuICAgKiAgIGV2ZW50LmhvbGRpbmcgJiYgZXZlbnQuc2V0KHt4OiAxMH0pO1xuICAgKiB9KTtcbiAgICogYGBgXG4gICAqL1xuICAvKiogU3BlY2lmaWVzIHRoZSBhbmltYXRpb24gY29vcmRpbmF0ZXMgdG8gbW92ZSBhZnRlciB0aGUgJ3JlbGVhc2UnIG9yICdhbmltYXRpb25TdGFydCcgZXZlbnRzLlxuICAgKiBAa28gJ3JlbGVhc2UnIOuYkOuKlCAnYW5pbWF0aW9uU3RhcnQnIOydtOuypO2KuCDsnbTtm4Qg7J2064+Z7ZWgIOyijO2RnOulvCDsp4DsoJXtlZzri6QuXG4gICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsIG51bWJlcj59IHBvcyBUaGUgY29vcmRpbmF0ZSB0byBtb3ZlIHRvIDxrbz7snbTrj5ntlaAg7KKM7ZGcPC9rbz5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtkdXJhdGlvbj0wXSBEdXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uICh1bml0OiBtcykgPGtvPuyVoOuLiOuplOydtOyFmCDsp4Ttlokg7Iuc6rCEKOuLqOychDogbXMpPC9rbz5cbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogY29uc3QgYXhlcyA9IG5ldyBlZy5BeGVzKHtcbiAgICogICBcInhcIjoge1xuICAgKiAgICAgIHJhbmdlOiBbMCwgMTAwXVxuICAgKiAgIH0sXG4gICAqICAgXCJ6b29tXCI6IHtcbiAgICogICAgICByYW5nZTogWzUwLCAzMF1cbiAgICogICB9XG4gICAqIH0pLm9uKFwiYW5pbWF0aW9uU3RhcnRcIiwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICogICBldmVudC5zZXRUbyh7eDogMTB9LCAyMDAwKTtcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKi9cbiAgLyoqXG4gICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiBhIHVzZXIgcmVsZWFzZSBhbiBlbGVtZW50IG9uIHRoZSBzY3JlZW4gb2YgdGhlIGRldmljZS5cbiAgICogQGtvIOyCrOyaqeyekOqwgCDquLDquLDsnZgg7ZmU66m07JeQ7IScIOyGkOydhCDrl5DsnYQg65WMIOuwnOyDne2VmOuKlCDsnbTrsqTtirhcbiAgICogQGV2ZW50IEF4ZXMjcmVsZWFzZVxuICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgKiBAcHJvcGVydHkge09iamVjdC48c3RyaW5nLCBudW1iZXI+fSBkZXBhUG9zIFRoZSBjb29yZGluYXRlcyB3aGVuIHJlbGVhc2luZyBhbiBlbGVtZW50PGtvPuyGkOydhCDrl5DsnYQg65WM7J2YIOyijO2RnCA8L2tvPlxuICAgKiBAcHJvcGVydHkge09iamVjdC48c3RyaW5nLCBudW1iZXI+fSBkZXN0UG9zIFRoZSBjb29yZGluYXRlcyB0byBtb3ZlIHRvIGFmdGVyIHJlbGVhc2luZyBhbiBlbGVtZW50PGtvPuyGkOydhCDrl4Ag65Kk7JeQIOydtOuPme2VoCDsooztkZw8L2tvPlxuICAgKiBAcHJvcGVydHkge09iamVjdC48c3RyaW5nLCBudW1iZXI+fSBkZWx0YSAgVGhlIG1vdmVtZW50IHZhcmlhdGlvbiBvZiBjb29yZGluYXRlIDxrbz7sooztkZzsnZgg67OA7ZmU65+JPC9rbz5cbiAgICogQHByb3BlcnR5IHtPYmplY3QuPHN0cmluZywgbnVtYmVyPn0gYm91bmNlUmF0aW8gSWYgdGhlIGNvb3JkaW5hdGVzIGF0IHRoZSB0aW1lIG9mIHJlbGVhc2UgYXJlIGluIHRoZSBib3VuY2UgYXJlYSwgdGhlIGN1cnJlbnQgYm91bmNlIHZhbHVlIGRpdmlkZWQgYnkgdGhlIG1heGltdW0gYm91bmNlIHZhbHVlIDxrbz7shpDsnYQg65eQ7J2EIOuVjOydmCDsooztkZzqsIAgYm91bmNlIOyYgeyXreyXkCDsnojripQg6rK97JqwIO2YhOyerCBib3VuY2XrkJwg6rCS7J2EIOy1nOuMgCBib3VuY2Ug6rCS7Jy866GcIOuCmOuIiCDsiJjsuZguPC9rbz5cbiAgICogQHByb3BlcnR5IHtPYmplY3R9IGlucHV0RXZlbnQgVGhlIGV2ZW50IG9iamVjdCByZWNlaXZlZCBmcm9tIGlucHV0VHlwZSA8a28+aW5wdXRUeXBl7Jy866GcIOu2gO2EsCDrsJvsnYAg7J2067Kk7Yq4IOqwneyytDwva28+XG4gICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBpbnB1dCBUaGUgaW5zdGFuY2Ugb2YgaW5wdXRUeXBlIHdoZXJlIHRoZSBldmVudCBvY2N1cnJlZDxrbz7snbTrsqTtirjqsIAg67Cc7IOd7ZWcIGlucHV0VHlwZSDsnbjsiqTthLTsiqQ8L2tvPlxuICAgKiBAcHJvcGVydHkge3NldFRvfSBzZXRUbyBTcGVjaWZpZXMgdGhlIGFuaW1hdGlvbiBjb29yZGluYXRlcyB0byBtb3ZlIGFmdGVyIHRoZSBldmVudCA8a28+7J2067Kk7Yq4IOydtO2bhCDsnbTrj5ntlaAg7JWg64uI66mU7J207IWYIOyijO2RnOulvCDsp4DsoJXtlZzri6Q8L2tvPlxuICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGlzVHJ1c3RlZCBSZXR1cm5zIHRydWUgaWYgYW4gZXZlbnQgd2FzIGdlbmVyYXRlZCBieSB0aGUgdXNlciBhY3Rpb24sIG9yIGZhbHNlIGlmIGl0IHdhcyBjYXVzZWQgYnkgYSBzY3JpcHQgb3IgQVBJIGNhbGwgPGtvPuyCrOyaqeyekOydmCDslaHshZjsl5Ag7J2Y7ZW0IOydtOuypO2KuOqwgCDrsJzsg53tlZjsmIDsnLzrqbQgdHJ1ZSwg7Iqk7YGs66a97Yq464KYIEFQSe2YuOy2nOyXkCDsnZjtlbQg67Cc7IOd7ZWY7JiA7J2EIOqyveyasOyXkOuKlCBmYWxzZeulvCDrsJjtmZjtlZzri6QuPC9rbz5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogY29uc3QgYXhlcyA9IG5ldyBlZy5BeGVzKHtcbiAgICogICBcInhcIjoge1xuICAgKiAgICAgIHJhbmdlOiBbMCwgMTAwXVxuICAgKiAgIH0sXG4gICAqICAgXCJ6b29tXCI6IHtcbiAgICogICAgICByYW5nZTogWzUwLCAzMF1cbiAgICogICB9XG4gICAqIH0pLm9uKFwicmVsZWFzZVwiLCBmdW5jdGlvbihldmVudCkge1xuICAgKiAgIC8vIGV2ZW50LmRlcGFQb3NcbiAgICogICAvLyBldmVudC5kZXN0UG9zXG4gICAqICAgLy8gZXZlbnQuZGVsdGFcbiAgICogICAvLyBldmVudC5pbnB1dFxuICAgKiAgIC8vIGV2ZW50LmlucHV0RXZlbnRcbiAgICogICAvLyBldmVudC5zZXRUb1xuICAgKiAgIC8vIGV2ZW50LmlzVHJ1c3RlZFxuICAgKlxuICAgKiAgIC8vIGlmIHlvdSB3YW50IHRvIGNoYW5nZSB0aGUgYW5pbWF0aW9uIGNvb3JkaW5hdGVzIHRvIG1vdmUgYWZ0ZXIgdGhlICdyZWxlYXNlJyBldmVudC5cbiAgICogICBldmVudC5zZXRUbyh7eDogMTB9LCAyMDAwKTtcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKi9cbiAgX19wcm90by50cmlnZ2VyUmVsZWFzZSA9IGZ1bmN0aW9uIChwYXJhbSkge1xuICAgIHZhciBfYSA9IHRoaXMuX2dldFJvdW5kUG9zKHBhcmFtLmRlc3RQb3MsIHBhcmFtLmRlcGFQb3MpLFxuICAgICAgcm91bmRQb3MgPSBfYS5yb3VuZFBvcyxcbiAgICAgIHJvdW5kRGVwYSA9IF9hLnJvdW5kRGVwYTtcbiAgICBwYXJhbS5kZXN0UG9zID0gcm91bmRQb3M7XG4gICAgcGFyYW0uZGVwYVBvcyA9IHJvdW5kRGVwYTtcbiAgICBwYXJhbS5zZXRUbyA9IHRoaXMuX2NyZWF0ZVVzZXJDb250cm9sbChwYXJhbS5kZXN0UG9zLCBwYXJhbS5kdXJhdGlvbik7XG4gICAgdGhpcy5fYXhlcy50cmlnZ2VyKG5ldyBDb21wb25lbnRFdmVudCQxKFwicmVsZWFzZVwiLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcGFyYW0pLCB7XG4gICAgICBib3VuY2VSYXRpbzogdGhpcy5fZ2V0Qm91bmNlUmF0aW8ocm91bmRQb3MpXG4gICAgfSkpKTtcbiAgfTtcbiAgLyoqXG4gICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiBjb29yZGluYXRlIGNoYW5nZXMuXG4gICAqIEBrbyDsooztkZzqsIAg67OA6rK965CQ7J2EIOuVjCDrsJzsg53tlZjripQg7J2067Kk7Yq4XG4gICAqIEBldmVudCBBeGVzI2NoYW5nZVxuICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgKiBAcHJvcGVydHkge09iamVjdC48c3RyaW5nLCBudW1iZXI+fSBwb3MgIFRoZSBjb29yZGluYXRlIDxrbz7sooztkZw8L2tvPlxuICAgKiBAcHJvcGVydHkge09iamVjdC48c3RyaW5nLCBudW1iZXI+fSBkZWx0YSAgVGhlIG1vdmVtZW50IHZhcmlhdGlvbiBvZiBjb29yZGluYXRlIDxrbz7sooztkZzsnZgg67OA7ZmU65+JPC9rbz5cbiAgICogQHByb3BlcnR5IHtPYmplY3QuPHN0cmluZywgbnVtYmVyPn0gYm91bmNlUmF0aW8gSWYgdGhlIGN1cnJlbnQgY29vcmRpbmF0ZXMgYXJlIGluIHRoZSBib3VuY2UgYXJlYSwgdGhlIGN1cnJlbnQgYm91bmNlIHZhbHVlIGRpdmlkZWQgYnkgdGhlIG1heGltdW0gYm91bmNlIHZhbHVlIDxrbz7tmITsnqwg7KKM7ZGc6rCAIGJvdW5jZSDsmIHsl63sl5Ag7J6I64qUIOqyveyasCDtmITsnqwgYm91bmNl65CcIOqwkuydhCDstZzrjIAgYm91bmNlIOqwkuycvOuhnCDrgpjriIgg7IiY7LmYLjwva28+XG4gICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gaG9sZGluZyBJbmRpY2F0ZXMgd2hldGhlciBhIHVzZXIgaG9sZHMgYW4gZWxlbWVudCBvbiB0aGUgc2NyZWVuIG9mIHRoZSBkZXZpY2UuPGtvPuyCrOyaqeyekOqwgCDquLDquLDsnZgg7ZmU66m07J2EIOuIhOultOqzoCDsnojripTsp4Ag7Jes67aAPC9rbz5cbiAgICogQHByb3BlcnR5IHtPYmplY3R9IGlucHV0IFRoZSBpbnN0YW5jZSBvZiBpbnB1dFR5cGUgd2hlcmUgdGhlIGV2ZW50IG9jY3VycmVkLiBJZiB0aGUgdmFsdWUgaXMgY2hhbmdlZCBieSBhbmltYXRpb24sIGl0IHJldHVybnMgJ251bGwnLjxrbz7snbTrsqTtirjqsIAg67Cc7IOd7ZWcIGlucHV0VHlwZSDsnbjsiqTthLTsiqQuIOyVoOuLiOuplOydtOyFmOyXkCDsnZjtlbQg6rCS7J20IOuzgOqyveuQoCDqsr3smrDsl5DripQgJ251bGwn7J2EIOuwmO2ZmO2VnOuLpC48L2tvPlxuICAgKiBAcHJvcGVydHkge09iamVjdH0gaW5wdXRFdmVudCBUaGUgZXZlbnQgb2JqZWN0IHJlY2VpdmVkIGZyb20gaW5wdXRUeXBlLiBJZiB0aGUgdmFsdWUgaXMgY2hhbmdlZCBieSBhbmltYXRpb24sIGl0IHJldHVybnMgJ251bGwnLjxrbz5pbnB1dFR5cGXsnLzroZwg67aA7YSwIOuwm+ydgCDsnbTrsqTtirgg6rCd7LK0LiDslaDri4jrqZTsnbTshZjsl5Ag7J2Y7ZW0IOqwkuydtCDrs4Dqsr3rkKAg6rK97Jqw7JeQ64qUICdudWxsJ+ydhCDrsJjtmZjtlZzri6QuPC9rbz5cbiAgICogQHByb3BlcnR5IHtzZXR9IHNldCBTcGVjaWZpZXMgdGhlIGNvb3JkaW5hdGVzIHRvIG1vdmUgYWZ0ZXIgdGhlIGV2ZW50LiBJdCB3b3JrcyB3aGVuIHRoZSBob2xkaW5nIHZhbHVlIGlzIHRydWUgPGtvPuydtOuypO2KuCDsnbTtm4Qg7J2064+Z7ZWgIOyijO2RnOulvCDsp4DsoJXtlZzri6QuIGhvbGRpbmcg6rCS7J20IHRydWXsnbwg6rK97Jqw7JeQIOuPmeyeke2VnOuLpC48L2tvPlxuICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGlzVHJ1c3RlZCBSZXR1cm5zIHRydWUgaWYgYW4gZXZlbnQgd2FzIGdlbmVyYXRlZCBieSB0aGUgdXNlciBhY3Rpb24sIG9yIGZhbHNlIGlmIGl0IHdhcyBjYXVzZWQgYnkgYSBzY3JpcHQgb3IgQVBJIGNhbGwgPGtvPuyCrOyaqeyekOydmCDslaHshZjsl5Ag7J2Y7ZW0IOydtOuypO2KuOqwgCDrsJzsg53tlZjsmIDsnLzrqbQgdHJ1ZSwg7Iqk7YGs66a97Yq464KYIEFQSe2YuOy2nOyXkCDsnZjtlbQg67Cc7IOd7ZWY7JiA7J2EIOqyveyasOyXkOuKlCBmYWxzZeulvCDrsJjtmZjtlZzri6QuPC9rbz5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogY29uc3QgYXhlcyA9IG5ldyBlZy5BeGVzKHtcbiAgICogICBcInhcIjoge1xuICAgKiAgICAgIHJhbmdlOiBbMCwgMTAwXVxuICAgKiAgIH0sXG4gICAqICAgXCJ6b29tXCI6IHtcbiAgICogICAgICByYW5nZTogWzUwLCAzMF1cbiAgICogICB9XG4gICAqIH0pLm9uKFwiY2hhbmdlXCIsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAqICAgLy8gZXZlbnQucG9zXG4gICAqICAgLy8gZXZlbnQuZGVsdGFcbiAgICogICAvLyBldmVudC5pbnB1dFxuICAgKiAgIC8vIGV2ZW50LmlucHV0RXZlbnRcbiAgICogICAvLyBldmVudC5ob2xkaW5nXG4gICAqICAgLy8gZXZlbnQuc2V0XG4gICAqICAgLy8gZXZlbnQuaXNUcnVzdGVkXG4gICAqXG4gICAqICAgLy8gaWYgeW91IHdhbnQgdG8gY2hhbmdlIHRoZSBjb29yZGluYXRlcyB0byBtb3ZlIGFmdGVyIHRoZSAnY2hhbmdlJyBldmVudC5cbiAgICogICAvLyBpdCB3b3JrcyB3aGVuIHRoZSBob2xkaW5nIHZhbHVlIG9mIHRoZSBjaGFuZ2UgZXZlbnQgaXMgdHJ1ZS5cbiAgICogICBldmVudC5ob2xkaW5nICYmIGV2ZW50LnNldCh7eDogMTB9KTtcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKi9cbiAgX19wcm90by50cmlnZ2VyQ2hhbmdlID0gZnVuY3Rpb24gKHBvcywgZGVwYVBvcywgb3B0aW9uLCBob2xkaW5nKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBpZiAoaG9sZGluZyA9PT0gdm9pZCAwKSB7XG4gICAgICBob2xkaW5nID0gZmFsc2U7XG4gICAgfVxuICAgIHZhciBhbmltYXRpb25NYW5hZ2VyID0gdGhpcy5hbmltYXRpb25NYW5hZ2VyO1xuICAgIHZhciBheGlzTWFuYWdlciA9IGFuaW1hdGlvbk1hbmFnZXIuYXhpc01hbmFnZXI7XG4gICAgdmFyIGV2ZW50SW5mbyA9IGFuaW1hdGlvbk1hbmFnZXIuZ2V0RXZlbnRJbmZvKCk7XG4gICAgdmFyIF9hID0gdGhpcy5fZ2V0Um91bmRQb3MocG9zLCBkZXBhUG9zKSxcbiAgICAgIHJvdW5kUG9zID0gX2Eucm91bmRQb3MsXG4gICAgICByb3VuZERlcGEgPSBfYS5yb3VuZERlcGE7XG4gICAgdmFyIG1vdmVUbyA9IGF4aXNNYW5hZ2VyLm1vdmVUbyhyb3VuZFBvcywgcm91bmREZXBhKTtcbiAgICB2YXIgaW5wdXRFdmVudCA9IChvcHRpb24gPT09IG51bGwgfHwgb3B0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb24uZXZlbnQpIHx8IChldmVudEluZm8gPT09IG51bGwgfHwgZXZlbnRJbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBldmVudEluZm8uZXZlbnQpIHx8IG51bGw7XG4gICAgdmFyIHBhcmFtID0ge1xuICAgICAgcG9zOiBtb3ZlVG8ucG9zLFxuICAgICAgZGVsdGE6IG1vdmVUby5kZWx0YSxcbiAgICAgIGJvdW5jZVJhdGlvOiB0aGlzLl9nZXRCb3VuY2VSYXRpbyhtb3ZlVG8ucG9zKSxcbiAgICAgIGhvbGRpbmc6IGhvbGRpbmcsXG4gICAgICBpbnB1dEV2ZW50OiBpbnB1dEV2ZW50LFxuICAgICAgaXNUcnVzdGVkOiAhIWlucHV0RXZlbnQsXG4gICAgICBpbnB1dDogKG9wdGlvbiA9PT0gbnVsbCB8fCBvcHRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbi5pbnB1dCkgfHwgKGV2ZW50SW5mbyA9PT0gbnVsbCB8fCBldmVudEluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGV2ZW50SW5mby5pbnB1dCkgfHwgbnVsbCxcbiAgICAgIHNldDogaW5wdXRFdmVudCA/IHRoaXMuX2NyZWF0ZVVzZXJDb250cm9sbChtb3ZlVG8ucG9zKSA6IGZ1bmN0aW9uICgpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWVtcHR5LWZ1bmN0aW9uXG4gICAgfTtcblxuICAgIHZhciBldmVudCA9IG5ldyBDb21wb25lbnRFdmVudCQxKFwiY2hhbmdlXCIsIHBhcmFtKTtcbiAgICB0aGlzLl9heGVzLnRyaWdnZXIoZXZlbnQpO1xuICAgIE9iamVjdC5rZXlzKG1vdmVUby5wb3MpLmZvckVhY2goZnVuY3Rpb24gKGF4aXMpIHtcbiAgICAgIHZhciBwID0gbW92ZVRvLnBvc1theGlzXTtcbiAgICAgIGdldE9ic2VydmVyKF90aGlzLl9heGVzLCBheGlzLCBwKS5jdXJyZW50ID0gcDtcbiAgICB9KTtcbiAgICBpZiAoaW5wdXRFdmVudCkge1xuICAgICAgYXhpc01hbmFnZXIuc2V0KHBhcmFtLnNldCgpLmRlc3RQb3MpO1xuICAgIH1cbiAgICByZXR1cm4gIWV2ZW50LmlzQ2FuY2VsZWQoKTtcbiAgfTtcbiAgLyoqXG4gICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiBhbmltYXRpb24gc3RhcnRzLlxuICAgKiBAa28g7JeQ64uI66mU7J207IWY7J20IOyLnOyeke2VoCDrlYwg67Cc7IOd7ZWc64ukLlxuICAgKiBAZXZlbnQgQXhlcyNhbmltYXRpb25TdGFydFxuICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgKiBAcHJvcGVydHkge09iamVjdC48c3RyaW5nLCBudW1iZXI+fSBkZXBhUG9zIFRoZSBjb29yZGluYXRlcyB3aGVuIGFuaW1hdGlvbiBzdGFydHM8a28+7JWg64uI66mU7J207IWY7J20IOyLnOyekSDrkJjsl4jsnYQg65WM7J2YIOyijO2RnCA8L2tvPlxuICAgKiBAcHJvcGVydHkge09iamVjdC48c3RyaW5nLCBudW1iZXI+fSBkZXN0UG9zIFRoZSBjb29yZGluYXRlcyB0byBtb3ZlIHRvLiBJZiB5b3UgY2hhbmdlIHRoaXMgdmFsdWUsIHlvdSBjYW4gcnVuIHRoZSBhbmltYXRpb248a28+7J2064+Z7ZWgIOyijO2RnC4g7J206rCS7J2EIOuzgOqyve2VmOyXrCDslaDri4jrqZTsnbTshZjsnYQg64+Z7J6R7Iuc7YKs7IiYIOyeiOuLpDwva28+XG4gICAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsIG51bWJlcj59IGRlbHRhICBUaGUgbW92ZW1lbnQgdmFyaWF0aW9uIG9mIGNvb3JkaW5hdGUgPGtvPuyijO2RnOydmCDrs4DtmZTrn4k8L2tvPlxuICAgKiBAcHJvcGVydHkge051bWJlcn0gZHVyYXRpb24gRHVyYXRpb24gb2YgdGhlIGFuaW1hdGlvbiAodW5pdDogbXMpLiBJZiB5b3UgY2hhbmdlIHRoaXMgdmFsdWUsIHlvdSBjYW4gY29udHJvbCB0aGUgYW5pbWF0aW9uIGR1cmF0aW9uIHRpbWUuPGtvPuyVoOuLiOuplOydtOyFmCDsp4Ttlokg7Iuc6rCEKOuLqOychDogbXMpLiDsnbTqsJLsnYQg67OA6rK97ZWY7JesIOyVoOuLiOuplOydtOyFmOydmCDsnbTrj5nsi5zqsITsnYQg7KGw7KCI7ZWgIOyImCDsnojri6QuPC9rbz5cbiAgICogQHByb3BlcnR5IHtPYmplY3R9IGlucHV0IFRoZSBpbnN0YW5jZSBvZiBpbnB1dFR5cGUgd2hlcmUgdGhlIGV2ZW50IG9jY3VycmVkLiBJZiB0aGUgdmFsdWUgaXMgY2hhbmdlZCBieSBhbmltYXRpb24sIGl0IHJldHVybnMgJ251bGwnLjxrbz7snbTrsqTtirjqsIAg67Cc7IOd7ZWcIGlucHV0VHlwZSDsnbjsiqTthLTsiqQuIOyVoOuLiOuplOydtOyFmOyXkCDsnZjtlbQg6rCS7J20IOuzgOqyveuQoCDqsr3smrDsl5DripQgJ251bGwn7J2EIOuwmO2ZmO2VnOuLpC48L2tvPlxuICAgKiBAcHJvcGVydHkge09iamVjdH0gaW5wdXRFdmVudCBUaGUgZXZlbnQgb2JqZWN0IHJlY2VpdmVkIGZyb20gaW5wdXRUeXBlIDxrbz5pbnB1dFR5cGXsnLzroZwg67aA7YSwIOuwm+ydgCDsnbTrsqTtirgg6rCd7LK0PC9rbz5cbiAgICogQHByb3BlcnR5IHtzZXRUb30gc2V0VG8gU3BlY2lmaWVzIHRoZSBhbmltYXRpb24gY29vcmRpbmF0ZXMgdG8gbW92ZSBhZnRlciB0aGUgZXZlbnQgPGtvPuydtOuypO2KuCDsnbTtm4Qg7J2064+Z7ZWgIOyVoOuLiOuplOydtOyFmCDsooztkZzrpbwg7KeA7KCV7ZWc64ukPC9rbz5cbiAgICogQHByb3BlcnR5IHtCb29sZWFufSBpc1RydXN0ZWQgUmV0dXJucyB0cnVlIGlmIGFuIGV2ZW50IHdhcyBnZW5lcmF0ZWQgYnkgdGhlIHVzZXIgYWN0aW9uLCBvciBmYWxzZSBpZiBpdCB3YXMgY2F1c2VkIGJ5IGEgc2NyaXB0IG9yIEFQSSBjYWxsIDxrbz7sgqzsmqnsnpDsnZgg7JWh7IWY7JeQIOydmO2VtCDsnbTrsqTtirjqsIAg67Cc7IOd7ZWY7JiA7Jy866m0IHRydWUsIOyKpO2BrOumve2KuOuCmCBBUEntmLjstpzsl5Ag7J2Y7ZW0IOuwnOyDne2VmOyYgOydhCDqsr3smrDsl5DripQgZmFsc2Xrpbwg67CY7ZmY7ZWc64ukLjwva28+XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IGF4ZXMgPSBuZXcgZWcuQXhlcyh7XG4gICAqICAgXCJ4XCI6IHtcbiAgICogICAgICByYW5nZTogWzAsIDEwMF1cbiAgICogICB9LFxuICAgKiAgIFwiem9vbVwiOiB7XG4gICAqICAgICAgcmFuZ2U6IFs1MCwgMzBdXG4gICAqICAgfVxuICAgKiB9KS5vbihcInJlbGVhc2VcIiwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICogICAvLyBldmVudC5kZXBhUG9zXG4gICAqICAgLy8gZXZlbnQuZGVzdFBvc1xuICAgKiAgIC8vIGV2ZW50LmRlbHRhXG4gICAqICAgLy8gZXZlbnQuaW5wdXRcbiAgICogICAvLyBldmVudC5pbnB1dEV2ZW50XG4gICAqICAgLy8gZXZlbnQuc2V0VG9cbiAgICogICAvLyBldmVudC5pc1RydXN0ZWRcbiAgICpcbiAgICogICAvLyBpZiB5b3Ugd2FudCB0byBjaGFuZ2UgdGhlIGFuaW1hdGlvbiBjb29yZGluYXRlcyB0byBtb3ZlIGFmdGVyIHRoZSAnYW5pbWF0aW9uU3RhcnQnIGV2ZW50LlxuICAgKiAgIGV2ZW50LnNldFRvKHt4OiAxMH0sIDIwMDApO1xuICAgKiB9KTtcbiAgICogYGBgXG4gICAqL1xuICBfX3Byb3RvLnRyaWdnZXJBbmltYXRpb25TdGFydCA9IGZ1bmN0aW9uIChwYXJhbSkge1xuICAgIHZhciBfYSA9IHRoaXMuX2dldFJvdW5kUG9zKHBhcmFtLmRlc3RQb3MsIHBhcmFtLmRlcGFQb3MpLFxuICAgICAgcm91bmRQb3MgPSBfYS5yb3VuZFBvcyxcbiAgICAgIHJvdW5kRGVwYSA9IF9hLnJvdW5kRGVwYTtcbiAgICBwYXJhbS5kZXN0UG9zID0gcm91bmRQb3M7XG4gICAgcGFyYW0uZGVwYVBvcyA9IHJvdW5kRGVwYTtcbiAgICBwYXJhbS5zZXRUbyA9IHRoaXMuX2NyZWF0ZVVzZXJDb250cm9sbChwYXJhbS5kZXN0UG9zLCBwYXJhbS5kdXJhdGlvbik7XG4gICAgdmFyIGV2ZW50ID0gbmV3IENvbXBvbmVudEV2ZW50JDEoXCJhbmltYXRpb25TdGFydFwiLCBwYXJhbSk7XG4gICAgdGhpcy5fYXhlcy50cmlnZ2VyKGV2ZW50KTtcbiAgICByZXR1cm4gIWV2ZW50LmlzQ2FuY2VsZWQoKTtcbiAgfTtcbiAgLyoqXG4gICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiBhbmltYXRpb24gZW5kcy5cbiAgICogQGtvIOyXkOuLiOuplOydtOyFmOydtCDrgZ3rgqzsnYQg65WMIOuwnOyDne2VnOuLpC5cbiAgICogQGV2ZW50IEF4ZXMjYW5pbWF0aW9uRW5kXG4gICAqIEB0eXBlIHtvYmplY3R9XG4gICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gaXNUcnVzdGVkIFJldHVybnMgdHJ1ZSBpZiBhbiBldmVudCB3YXMgZ2VuZXJhdGVkIGJ5IHRoZSB1c2VyIGFjdGlvbiwgb3IgZmFsc2UgaWYgaXQgd2FzIGNhdXNlZCBieSBhIHNjcmlwdCBvciBBUEkgY2FsbCA8a28+7IKs7Jqp7J6Q7J2YIOyVoeyFmOyXkCDsnZjtlbQg7J2067Kk7Yq46rCAIOuwnOyDne2VmOyYgOycvOuptCB0cnVlLCDsiqTtgazrpr3tirjrgpggQVBJ7Zi47Lac7JeQIOydmO2VtCDrsJzsg53tlZjsmIDsnYQg6rK97Jqw7JeQ64qUIGZhbHNl66W8IOuwmO2ZmO2VnOuLpC48L2tvPlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBjb25zdCBheGVzID0gbmV3IGVnLkF4ZXMoe1xuICAgKiAgIFwieFwiOiB7XG4gICAqICAgICAgcmFuZ2U6IFswLCAxMDBdXG4gICAqICAgfSxcbiAgICogICBcInpvb21cIjoge1xuICAgKiAgICAgIHJhbmdlOiBbNTAsIDMwXVxuICAgKiAgIH1cbiAgICogfSkub24oXCJhbmltYXRpb25FbmRcIiwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICogICAvLyBldmVudC5pc1RydXN0ZWRcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKi9cbiAgX19wcm90by50cmlnZ2VyQW5pbWF0aW9uRW5kID0gZnVuY3Rpb24gKGlzVHJ1c3RlZCkge1xuICAgIGlmIChpc1RydXN0ZWQgPT09IHZvaWQgMCkge1xuICAgICAgaXNUcnVzdGVkID0gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuX2F4ZXMudHJpZ2dlcihuZXcgQ29tcG9uZW50RXZlbnQkMShcImFuaW1hdGlvbkVuZFwiLCB7XG4gICAgICBpc1RydXN0ZWQ6IGlzVHJ1c3RlZFxuICAgIH0pKTtcbiAgfTtcbiAgLyoqXG4gICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiBhbGwgYWN0aW9ucyBoYXZlIGJlZW4gY29tcGxldGVkLlxuICAgKiBAa28g7JeQ64uI66mU7J207IWY7J20IOuBneuCrOydhCDrlYwg67Cc7IOd7ZWc64ukLlxuICAgKiBAZXZlbnQgQXhlcyNmaW5pc2hcbiAgICogQHR5cGUge29iamVjdH1cbiAgICogQHByb3BlcnR5IHtCb29sZWFufSBpc1RydXN0ZWQgUmV0dXJucyB0cnVlIGlmIGFuIGV2ZW50IHdhcyBnZW5lcmF0ZWQgYnkgdGhlIHVzZXIgYWN0aW9uLCBvciBmYWxzZSBpZiBpdCB3YXMgY2F1c2VkIGJ5IGEgc2NyaXB0IG9yIEFQSSBjYWxsIDxrbz7sgqzsmqnsnpDsnZgg7JWh7IWY7JeQIOydmO2VtCDsnbTrsqTtirjqsIAg67Cc7IOd7ZWY7JiA7Jy866m0IHRydWUsIOyKpO2BrOumve2KuOuCmCBBUEntmLjstpzsl5Ag7J2Y7ZW0IOuwnOyDne2VmOyYgOydhCDqsr3smrDsl5DripQgZmFsc2Xrpbwg67CY7ZmY7ZWc64ukLjwva28+XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IGF4ZXMgPSBuZXcgZWcuQXhlcyh7XG4gICAqICAgXCJ4XCI6IHtcbiAgICogICAgICByYW5nZTogWzAsIDEwMF1cbiAgICogICB9LFxuICAgKiAgIFwiem9vbVwiOiB7XG4gICAqICAgICAgcmFuZ2U6IFs1MCwgMzBdXG4gICAqICAgfVxuICAgKiB9KS5vbihcImZpbmlzaFwiLCBmdW5jdGlvbihldmVudCkge1xuICAgKiAgIC8vIGV2ZW50LmlzVHJ1c3RlZFxuICAgKiB9KTtcbiAgICogYGBgXG4gICAqL1xuICBfX3Byb3RvLnRyaWdnZXJGaW5pc2ggPSBmdW5jdGlvbiAoaXNUcnVzdGVkKSB7XG4gICAgaWYgKGlzVHJ1c3RlZCA9PT0gdm9pZCAwKSB7XG4gICAgICBpc1RydXN0ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5fYXhlcy50cmlnZ2VyKG5ldyBDb21wb25lbnRFdmVudCQxKFwiZmluaXNoXCIsIHtcbiAgICAgIGlzVHJ1c3RlZDogaXNUcnVzdGVkXG4gICAgfSkpO1xuICB9O1xuICBfX3Byb3RvLnNldEFuaW1hdGlvbk1hbmFnZXIgPSBmdW5jdGlvbiAoYW5pbWF0aW9uTWFuYWdlcikge1xuICAgIHRoaXMuYW5pbWF0aW9uTWFuYWdlciA9IGFuaW1hdGlvbk1hbmFnZXI7XG4gIH07XG4gIF9fcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9heGVzLm9mZigpO1xuICB9O1xuICBfX3Byb3RvLl9jcmVhdGVVc2VyQ29udHJvbGwgPSBmdW5jdGlvbiAocG9zLCBkdXJhdGlvbikge1xuICAgIGlmIChkdXJhdGlvbiA9PT0gdm9pZCAwKSB7XG4gICAgICBkdXJhdGlvbiA9IDA7XG4gICAgfVxuICAgIC8vIHRvIGNvbnRyb2xsXG4gICAgdmFyIHVzZXJDb250cm9sID0ge1xuICAgICAgZGVzdFBvczogX19hc3NpZ24oe30sIHBvcyksXG4gICAgICBkdXJhdGlvbjogZHVyYXRpb25cbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAodG9Qb3MsIHVzZXJEdXJhdGlvbikge1xuICAgICAgaWYgKHRvUG9zKSB7XG4gICAgICAgIHVzZXJDb250cm9sLmRlc3RQb3MgPSBfX2Fzc2lnbih7fSwgdG9Qb3MpO1xuICAgICAgfVxuICAgICAgaWYgKHVzZXJEdXJhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHVzZXJDb250cm9sLmR1cmF0aW9uID0gdXNlckR1cmF0aW9uO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHVzZXJDb250cm9sO1xuICAgIH07XG4gIH07XG4gIF9fcHJvdG8uX2dldFJvdW5kUG9zID0gZnVuY3Rpb24gKHBvcywgZGVwYVBvcykge1xuICAgIC8vIHJvdW5kIHZhbHVlIGlmIHJvdW5kIGV4aXN0XG4gICAgdmFyIHJvdW5kVW5pdCA9IHRoaXMuX2F4ZXMub3B0aW9ucy5yb3VuZDtcbiAgICAvLyBpZiAocm91bmQgPT0gbnVsbCkge1xuICAgIC8vICAgcmV0dXJuIHtwb3MsIGRlcGFQb3N9OyAvLyB1bmRlZmluZWQsIHVuZGVmaW5lZFxuICAgIC8vIH1cbiAgICByZXR1cm4ge1xuICAgICAgcm91bmRQb3M6IHJvdW5kTnVtYmVycyhwb3MsIHJvdW5kVW5pdCksXG4gICAgICByb3VuZERlcGE6IHJvdW5kTnVtYmVycyhkZXBhUG9zLCByb3VuZFVuaXQpXG4gICAgfTtcbiAgfTtcbiAgX19wcm90by5fZ2V0Qm91bmNlUmF0aW8gPSBmdW5jdGlvbiAocG9zKSB7XG4gICAgcmV0dXJuIHRoaXMuX2F4ZXMuYXhpc01hbmFnZXIubWFwKHBvcywgZnVuY3Rpb24gKHYsIG9wdCkge1xuICAgICAgaWYgKHYgPCBvcHQucmFuZ2VbMF0gJiYgb3B0LmJvdW5jZVswXSAhPT0gMCkge1xuICAgICAgICByZXR1cm4gKG9wdC5yYW5nZVswXSAtIHYpIC8gb3B0LmJvdW5jZVswXTtcbiAgICAgIH0gZWxzZSBpZiAodiA+IG9wdC5yYW5nZVsxXSAmJiBvcHQuYm91bmNlWzFdICE9PSAwKSB7XG4gICAgICAgIHJldHVybiAodiAtIG9wdC5yYW5nZVsxXSkgLyBvcHQuYm91bmNlWzFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIF9fZGVjb3JhdGUoW09ic2VydmVdLCBFdmVudE1hbmFnZXIucHJvdG90eXBlLCBcImhvbGRpbmdDb3VudFwiLCB2b2lkIDApO1xuICByZXR1cm4gRXZlbnRNYW5hZ2VyO1xufSgpO1xuXG52YXIgSW50ZXJydXB0TWFuYWdlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEludGVycnVwdE1hbmFnZXIoX29wdGlvbnMpIHtcbiAgICB0aGlzLl9vcHRpb25zID0gX29wdGlvbnM7XG4gICAgdGhpcy5fcHJldmVudGVkID0gZmFsc2U7IC8vICBjaGVjayB3aGV0aGVyIHRoZSBhbmltYXRpb24gZXZlbnQgd2FzIHByZXZlbnRlZFxuICB9XG4gIHZhciBfX3Byb3RvID0gSW50ZXJydXB0TWFuYWdlci5wcm90b3R5cGU7XG4gIF9fcHJvdG8uaXNJbnRlcnJ1cHRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gd2hlbiBpbnRlcnJ1cHRhYmxlIGlzICd0cnVlJywgcmV0dXJuIHZhbHVlIGlzIGFsd2F5cyAndHJ1ZScuXG4gICAgcmV0dXJuIHRoaXMuX29wdGlvbnMuaW50ZXJydXB0YWJsZSB8fCB0aGlzLl9wcmV2ZW50ZWQ7XG4gIH07XG4gIF9fcHJvdG8uaXNJbnRlcnJ1cHRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gIXRoaXMuX29wdGlvbnMuaW50ZXJydXB0YWJsZSAmJiB0aGlzLl9wcmV2ZW50ZWQ7XG4gIH07XG4gIF9fcHJvdG8uc2V0SW50ZXJydXB0ID0gZnVuY3Rpb24gKHByZXZlbnRlZCkge1xuICAgIGlmICghdGhpcy5fb3B0aW9ucy5pbnRlcnJ1cHRhYmxlKSB7XG4gICAgICB0aGlzLl9wcmV2ZW50ZWQgPSBwcmV2ZW50ZWQ7XG4gICAgfVxuICB9O1xuICByZXR1cm4gSW50ZXJydXB0TWFuYWdlcjtcbn0oKTtcblxuLypcbiAqIENvcHlyaWdodCAoYykgMjAxNSBOQVZFUiBDb3JwLlxuICogZWdqcyBwcm9qZWN0cyBhcmUgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbnZhciBnZXRJbnNpZGVQb3NpdGlvbiA9IGZ1bmN0aW9uIChkZXN0UG9zLCByYW5nZSwgY2lyY3VsYXIsIGJvdW5jZSkge1xuICB2YXIgdG9EZXN0UG9zID0gZGVzdFBvcztcbiAgdmFyIHRhcmdldFJhbmdlID0gW2NpcmN1bGFyWzBdID8gcmFuZ2VbMF0gOiBib3VuY2UgPyByYW5nZVswXSAtIGJvdW5jZVswXSA6IHJhbmdlWzBdLCBjaXJjdWxhclsxXSA/IHJhbmdlWzFdIDogYm91bmNlID8gcmFuZ2VbMV0gKyBib3VuY2VbMV0gOiByYW5nZVsxXV07XG4gIHRvRGVzdFBvcyA9IE1hdGgubWF4KHRhcmdldFJhbmdlWzBdLCB0b0Rlc3RQb3MpO1xuICB0b0Rlc3RQb3MgPSBNYXRoLm1pbih0YXJnZXRSYW5nZVsxXSwgdG9EZXN0UG9zKTtcbiAgcmV0dXJuIHRvRGVzdFBvcztcbn07XG4vLyBkZXRlcm1pbmUgb3V0c2lkZVxudmFyIGlzT3V0c2lkZSA9IGZ1bmN0aW9uIChwb3MsIHJhbmdlKSB7XG4gIHJldHVybiBwb3MgPCByYW5nZVswXSB8fCBwb3MgPiByYW5nZVsxXTtcbn07XG4vLyBkZXRlcm1pbmUgd2hldGhlciBwb3NpdGlvbiBoYXMgcmVhY2hlZCB0aGUgbWF4aW11bSBtb3ZlYWJsZSBhcmVhXG52YXIgaXNFbmRvZkJvdW5jZSA9IGZ1bmN0aW9uIChwb3MsIHJhbmdlLCBib3VuY2UsIGNpcmN1bGFyKSB7XG4gIHJldHVybiAhY2lyY3VsYXJbMF0gJiYgcG9zID09PSByYW5nZVswXSAtIGJvdW5jZVswXSB8fCAhY2lyY3VsYXJbMV0gJiYgcG9zID09PSByYW5nZVsxXSArIGJvdW5jZVsxXTtcbn07XG52YXIgZ2V0RHVyYXRpb24gPSBmdW5jdGlvbiAoZGlzdGFuY2UsIGRlY2VsZXJhdGlvbikge1xuICB2YXIgZHVyYXRpb24gPSBNYXRoLnNxcnQoZGlzdGFuY2UgLyBkZWNlbGVyYXRpb24gKiAyKTtcbiAgLy8gd2hlbiBkdXJhdGlvbiBpcyB1bmRlciAxMDAsIHRoZW4gdmFsdWUgaXMgemVyb1xuICByZXR1cm4gZHVyYXRpb24gPCAxMDAgPyAwIDogZHVyYXRpb247XG59O1xudmFyIGlzQ2lyY3VsYXJhYmxlID0gZnVuY3Rpb24gKGRlc3RQb3MsIHJhbmdlLCBjaXJjdWxhcikge1xuICByZXR1cm4gY2lyY3VsYXJbMV0gJiYgZGVzdFBvcyA+IHJhbmdlWzFdIHx8IGNpcmN1bGFyWzBdICYmIGRlc3RQb3MgPCByYW5nZVswXTtcbn07XG52YXIgZ2V0Q2lyY3VsYXRlZFBvcyA9IGZ1bmN0aW9uIChwb3MsIHJhbmdlLCBjaXJjdWxhcikge1xuICB2YXIgdG9Qb3MgPSBwb3M7XG4gIHZhciBtaW4gPSByYW5nZVswXTtcbiAgdmFyIG1heCA9IHJhbmdlWzFdO1xuICB2YXIgbGVuZ3RoID0gbWF4IC0gbWluO1xuICBpZiAoY2lyY3VsYXJbMV0gJiYgcG9zID4gbWF4KSB7XG4gICAgLy8gcmlnaHRcbiAgICB0b1BvcyA9ICh0b1BvcyAtIG1heCkgJSBsZW5ndGggKyBtaW47XG4gIH1cbiAgaWYgKGNpcmN1bGFyWzBdICYmIHBvcyA8IG1pbikge1xuICAgIC8vIGxlZnRcbiAgICB0b1BvcyA9ICh0b1BvcyAtIG1pbikgJSBsZW5ndGggKyBtYXg7XG4gIH1cbiAgcmV0dXJuIHRvUG9zO1xufTtcblxudmFyIEF4aXNNYW5hZ2VyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQXhpc01hbmFnZXIoX2F4aXMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHRoaXMuX2F4aXMgPSBfYXhpcztcbiAgICB0aGlzLl9jb21wbGVtZW50T3B0aW9ucygpO1xuICAgIHRoaXMuX3BvcyA9IE9iamVjdC5rZXlzKHRoaXMuX2F4aXMpLnJlZHVjZShmdW5jdGlvbiAocG9zLCB2KSB7XG4gICAgICBwb3Nbdl0gPSBfdGhpcy5fYXhpc1t2XS5zdGFydFBvcztcbiAgICAgIHJldHVybiBwb3M7XG4gICAgfSwge30pO1xuICB9XG4gIHZhciBfX3Byb3RvID0gQXhpc01hbmFnZXIucHJvdG90eXBlO1xuICBfX3Byb3RvLmdldERlbHRhID0gZnVuY3Rpb24gKGRlcGFQb3MsIGRlc3RQb3MpIHtcbiAgICB2YXIgZnVsbERlcGFQb3MgPSB0aGlzLmdldChkZXBhUG9zKTtcbiAgICByZXR1cm4gbWFwKHRoaXMuZ2V0KGRlc3RQb3MpLCBmdW5jdGlvbiAodiwgaykge1xuICAgICAgcmV0dXJuIHYgLSBmdWxsRGVwYVBvc1trXTtcbiAgICB9KTtcbiAgfTtcbiAgX19wcm90by5nZXQgPSBmdW5jdGlvbiAoYXhlcykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgaWYgKGF4ZXMgJiYgQXJyYXkuaXNBcnJheShheGVzKSkge1xuICAgICAgcmV0dXJuIGF4ZXMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHYpIHtcbiAgICAgICAgaWYgKHYgJiYgdiBpbiBfdGhpcy5fcG9zKSB7XG4gICAgICAgICAgYWNjW3ZdID0gX3RoaXMuX3Bvc1t2XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfSwge30pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIHRoaXMuX3BvcyksIGF4ZXMgfHwge30pO1xuICAgIH1cbiAgfTtcbiAgX19wcm90by5tb3ZlVG8gPSBmdW5jdGlvbiAocG9zLCBkZXBhUG9zKSB7XG4gICAgaWYgKGRlcGFQb3MgPT09IHZvaWQgMCkge1xuICAgICAgZGVwYVBvcyA9IHRoaXMuX3BvcztcbiAgICB9XG4gICAgdmFyIGRlbHRhID0gbWFwKHRoaXMuX3BvcywgZnVuY3Rpb24gKHYsIGtleSkge1xuICAgICAgcmV0dXJuIGtleSBpbiBwb3MgJiYga2V5IGluIGRlcGFQb3MgPyBwb3Nba2V5XSAtIGRlcGFQb3Nba2V5XSA6IDA7XG4gICAgfSk7XG4gICAgdGhpcy5zZXQodGhpcy5tYXAocG9zLCBmdW5jdGlvbiAodiwgb3B0KSB7XG4gICAgICByZXR1cm4gb3B0ID8gZ2V0Q2lyY3VsYXRlZFBvcyh2LCBvcHQucmFuZ2UsIG9wdC5jaXJjdWxhcikgOiAwO1xuICAgIH0pKTtcbiAgICByZXR1cm4ge1xuICAgICAgcG9zOiBfX2Fzc2lnbih7fSwgdGhpcy5fcG9zKSxcbiAgICAgIGRlbHRhOiBkZWx0YVxuICAgIH07XG4gIH07XG4gIF9fcHJvdG8uc2V0ID0gZnVuY3Rpb24gKHBvcykge1xuICAgIGZvciAodmFyIGsgaW4gcG9zKSB7XG4gICAgICBpZiAoayAmJiBrIGluIHRoaXMuX3Bvcykge1xuICAgICAgICB0aGlzLl9wb3Nba10gPSBwb3Nba107XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBfX3Byb3RvLmV2ZXJ5ID0gZnVuY3Rpb24gKHBvcywgY2FsbGJhY2spIHtcbiAgICB2YXIgYXhpc09wdGlvbnMgPSB0aGlzLl9heGlzO1xuICAgIHJldHVybiBldmVyeShwb3MsIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2sodmFsdWUsIGF4aXNPcHRpb25zW2tleV0sIGtleSk7XG4gICAgfSk7XG4gIH07XG4gIF9fcHJvdG8uZmlsdGVyID0gZnVuY3Rpb24gKHBvcywgY2FsbGJhY2spIHtcbiAgICB2YXIgYXhpc09wdGlvbnMgPSB0aGlzLl9heGlzO1xuICAgIHJldHVybiBmaWx0ZXIocG9zLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKHZhbHVlLCBheGlzT3B0aW9uc1trZXldLCBrZXkpO1xuICAgIH0pO1xuICB9O1xuICBfX3Byb3RvLm1hcCA9IGZ1bmN0aW9uIChwb3MsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGF4aXNPcHRpb25zID0gdGhpcy5fYXhpcztcbiAgICByZXR1cm4gbWFwKHBvcywgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayh2YWx1ZSwgYXhpc09wdGlvbnNba2V5XSwga2V5KTtcbiAgICB9KTtcbiAgfTtcbiAgX19wcm90by5pc091dHNpZGUgPSBmdW5jdGlvbiAoYXhlcykge1xuICAgIHJldHVybiAhdGhpcy5ldmVyeShheGVzID8gdGhpcy5nZXQoYXhlcykgOiB0aGlzLl9wb3MsIGZ1bmN0aW9uICh2LCBvcHQpIHtcbiAgICAgIHJldHVybiAhaXNPdXRzaWRlKHYsIG9wdC5yYW5nZSk7XG4gICAgfSk7XG4gIH07XG4gIF9fcHJvdG8uZ2V0QXhpc09wdGlvbnMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuX2F4aXNba2V5XTtcbiAgfTtcbiAgX19wcm90by5zZXRBeGlzID0gZnVuY3Rpb24gKGF4aXMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIE9iamVjdC5rZXlzKGF4aXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgaWYgKCFfdGhpcy5fYXhpc1trZXldKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkF4aXMgXCIuY29uY2F0KGtleSwgXCIgZG9lcyBub3QgZXhpc3QgaW4gQXhlcyBpbnN0YW5jZVwiKSk7XG4gICAgICB9XG4gICAgICBfdGhpcy5fYXhpc1trZXldID0gX19hc3NpZ24oX19hc3NpZ24oe30sIF90aGlzLl9heGlzW2tleV0pLCBheGlzW2tleV0pO1xuICAgIH0pO1xuICAgIHRoaXMuX2NvbXBsZW1lbnRPcHRpb25zKCk7XG4gIH07XG4gIC8qKlxuICAgKiBzZXQgdXAgJ2NzcycgZXhwcmVzc2lvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX19wcm90by5fY29tcGxlbWVudE9wdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBPYmplY3Qua2V5cyh0aGlzLl9heGlzKS5mb3JFYWNoKGZ1bmN0aW9uIChheGlzKSB7XG4gICAgICBfdGhpcy5fYXhpc1theGlzXSA9IF9fYXNzaWduKHtcbiAgICAgICAgcmFuZ2U6IFswLCAxMDBdLFxuICAgICAgICBzdGFydFBvczogX3RoaXMuX2F4aXNbYXhpc10ucmFuZ2VbMF0sXG4gICAgICAgIGJvdW5jZTogWzAsIDBdLFxuICAgICAgICBjaXJjdWxhcjogW2ZhbHNlLCBmYWxzZV1cbiAgICAgIH0sIF90aGlzLl9heGlzW2F4aXNdKTtcbiAgICAgIFtcImJvdW5jZVwiLCBcImNpcmN1bGFyXCJdLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgdmFyIGF4aXNPcHRpb24gPSBfdGhpcy5fYXhpcztcbiAgICAgICAgdmFyIGtleSA9IGF4aXNPcHRpb25bYXhpc11bdl07XG4gICAgICAgIGlmICgvc3RyaW5nfG51bWJlcnxib29sZWFuLy50ZXN0KHR5cGVvZiBrZXkpKSB7XG4gICAgICAgICAgYXhpc09wdGlvbltheGlzXVt2XSA9IFtrZXksIGtleV07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuICByZXR1cm4gQXhpc01hbmFnZXI7XG59KCk7XG5cbnZhciBTVVBQT1JUX1RPVUNIID0gKFwib250b3VjaHN0YXJ0XCIgaW4gd2luKTtcbnZhciBTVVBQT1JUX1BPSU5URVIgPSAoXCJQb2ludGVyRXZlbnRcIiBpbiB3aW4pO1xudmFyIFNVUFBPUlRfTVNQT0lOVEVSID0gKFwiTVNQb2ludGVyRXZlbnRcIiBpbiB3aW4pO1xudmFyIFNVUFBPUlRfUE9JTlRFUl9FVkVOVFMgPSBTVVBQT1JUX1BPSU5URVIgfHwgU1VQUE9SVF9NU1BPSU5URVI7XG52YXIgaXNWYWxpZEtleSA9IGZ1bmN0aW9uIChldmVudCwgaW5wdXRLZXkpIHtcbiAgaWYgKCFpbnB1dEtleSB8fCBpbnB1dEtleS5pbmRleE9mKEFOWSkgPiAtMSB8fCBpbnB1dEtleS5pbmRleE9mKE5PTkUpID4gLTEgJiYgIWV2ZW50LnNoaWZ0S2V5ICYmICFldmVudC5jdHJsS2V5ICYmICFldmVudC5hbHRLZXkgJiYgIWV2ZW50Lm1ldGFLZXkgfHwgaW5wdXRLZXkuaW5kZXhPZihTSElGVCkgPiAtMSAmJiBldmVudC5zaGlmdEtleSB8fCBpbnB1dEtleS5pbmRleE9mKENUUkwpID4gLTEgJiYgZXZlbnQuY3RybEtleSB8fCBpbnB1dEtleS5pbmRleE9mKEFMVCkgPiAtMSAmJiBldmVudC5hbHRLZXkgfHwgaW5wdXRLZXkuaW5kZXhPZihNRVRBKSA+IC0xICYmIGV2ZW50Lm1ldGFLZXkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xudmFyIEV2ZW50SW5wdXQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBFdmVudElucHV0KCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdGhpcy5fc3RvcENvbnRleHRNZW51ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgd2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjb250ZXh0bWVudVwiLCBfdGhpcy5fc3RvcENvbnRleHRNZW51KTtcbiAgICB9O1xuICB9XG4gIHZhciBfX3Byb3RvID0gRXZlbnRJbnB1dC5wcm90b3R5cGU7XG4gIF9fcHJvdG8uZXh0ZW5kRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgX2E7XG4gICAgdmFyIHByZXZFdmVudCA9IHRoaXMucHJldkV2ZW50O1xuICAgIHZhciBjZW50ZXIgPSB0aGlzLl9nZXRDZW50ZXIoZXZlbnQpO1xuICAgIHZhciBtb3ZlbWVudCA9IHByZXZFdmVudCA/IHRoaXMuX2dldE1vdmVtZW50KGV2ZW50KSA6IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfTtcbiAgICB2YXIgc2NhbGUgPSBwcmV2RXZlbnQgPyB0aGlzLl9nZXRTY2FsZShldmVudCkgOiAxO1xuICAgIHZhciBhbmdsZSA9IHByZXZFdmVudCA/IGdldEFuZ2xlKGNlbnRlci54IC0gcHJldkV2ZW50LmNlbnRlci54LCBjZW50ZXIueSAtIHByZXZFdmVudC5jZW50ZXIueSkgOiAwO1xuICAgIHZhciBkZWx0YVggPSBwcmV2RXZlbnQgPyBwcmV2RXZlbnQuZGVsdGFYICsgbW92ZW1lbnQueCA6IG1vdmVtZW50Lng7XG4gICAgdmFyIGRlbHRhWSA9IHByZXZFdmVudCA/IHByZXZFdmVudC5kZWx0YVkgKyBtb3ZlbWVudC55IDogbW92ZW1lbnQueTtcbiAgICB2YXIgb2Zmc2V0WCA9IG1vdmVtZW50Lng7XG4gICAgdmFyIG9mZnNldFkgPSBtb3ZlbWVudC55O1xuICAgIHZhciBsYXRlc3RJbnRlcnZhbCA9IHRoaXMuX2xhdGVzdEludGVydmFsO1xuICAgIHZhciB0aW1lU3RhbXAgPSBEYXRlLm5vdygpO1xuICAgIHZhciBkZWx0YVRpbWUgPSBsYXRlc3RJbnRlcnZhbCA/IHRpbWVTdGFtcCAtIGxhdGVzdEludGVydmFsLnRpbWVzdGFtcCA6IDA7XG4gICAgdmFyIHZlbG9jaXR5WCA9IHByZXZFdmVudCA/IHByZXZFdmVudC52ZWxvY2l0eVggOiAwO1xuICAgIHZhciB2ZWxvY2l0eVkgPSBwcmV2RXZlbnQgPyBwcmV2RXZlbnQudmVsb2NpdHlZIDogMDtcbiAgICBpZiAoIWxhdGVzdEludGVydmFsIHx8IGRlbHRhVGltZSA+PSBWRUxPQ0lUWV9JTlRFUlZBTCkge1xuICAgICAgaWYgKGxhdGVzdEludGVydmFsKSB7XG4gICAgICAgIF9hID0gWyhkZWx0YVggLSBsYXRlc3RJbnRlcnZhbC5kZWx0YVgpIC8gZGVsdGFUaW1lLCAoZGVsdGFZIC0gbGF0ZXN0SW50ZXJ2YWwuZGVsdGFZKSAvIGRlbHRhVGltZV0sIHZlbG9jaXR5WCA9IF9hWzBdLCB2ZWxvY2l0eVkgPSBfYVsxXTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2xhdGVzdEludGVydmFsID0ge1xuICAgICAgICB0aW1lc3RhbXA6IHRpbWVTdGFtcCxcbiAgICAgICAgZGVsdGFYOiBkZWx0YVgsXG4gICAgICAgIGRlbHRhWTogZGVsdGFZXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgc3JjRXZlbnQ6IGV2ZW50LFxuICAgICAgc2NhbGU6IHNjYWxlLFxuICAgICAgYW5nbGU6IGFuZ2xlLFxuICAgICAgY2VudGVyOiBjZW50ZXIsXG4gICAgICBkZWx0YVg6IGRlbHRhWCxcbiAgICAgIGRlbHRhWTogZGVsdGFZLFxuICAgICAgb2Zmc2V0WDogb2Zmc2V0WCxcbiAgICAgIG9mZnNldFk6IG9mZnNldFksXG4gICAgICB2ZWxvY2l0eVg6IHZlbG9jaXR5WCxcbiAgICAgIHZlbG9jaXR5WTogdmVsb2NpdHlZLFxuICAgICAgcHJldmVudFN5c3RlbUV2ZW50OiB0cnVlXG4gICAgfTtcbiAgfTtcbiAgX19wcm90by5fZ2V0RGlzdGFuY2UgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgIHZhciB4ID0gZW5kLmNsaWVudFggLSBzdGFydC5jbGllbnRYO1xuICAgIHZhciB5ID0gZW5kLmNsaWVudFkgLSBzdGFydC5jbGllbnRZO1xuICAgIHJldHVybiBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XG4gIH07XG4gIF9fcHJvdG8uX2dldEJ1dHRvbiA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciBidXR0b25Db2RlTWFwID0ge1xuICAgICAgMTogTU9VU0VfTEVGVCxcbiAgICAgIDI6IE1PVVNFX1JJR0hULFxuICAgICAgNDogTU9VU0VfTUlERExFXG4gICAgfTtcbiAgICB2YXIgYnV0dG9uID0gdGhpcy5faXNUb3VjaEV2ZW50KGV2ZW50KSA/IE1PVVNFX0xFRlQgOiBidXR0b25Db2RlTWFwW2V2ZW50LmJ1dHRvbnNdO1xuICAgIHJldHVybiBidXR0b24gPyBidXR0b24gOiBudWxsO1xuICB9O1xuICBfX3Byb3RvLl9pc1RvdWNoRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQudHlwZSAmJiBldmVudC50eXBlLmluZGV4T2YoXCJ0b3VjaFwiKSA+IC0xO1xuICB9O1xuICBfX3Byb3RvLl9pc1ZhbGlkQnV0dG9uID0gZnVuY3Rpb24gKGJ1dHRvbiwgaW5wdXRCdXR0b24pIHtcbiAgICByZXR1cm4gaW5wdXRCdXR0b24uaW5kZXhPZihidXR0b24pID4gLTE7XG4gIH07XG4gIF9fcHJvdG8uX2lzVmFsaWRFdmVudCA9IGZ1bmN0aW9uIChldmVudCwgaW5wdXRLZXksIGlucHV0QnV0dG9uKSB7XG4gICAgcmV0dXJuICghaW5wdXRLZXkgfHwgaXNWYWxpZEtleShldmVudCwgaW5wdXRLZXkpKSAmJiAoIWlucHV0QnV0dG9uIHx8IHRoaXMuX2lzVmFsaWRCdXR0b24odGhpcy5fZ2V0QnV0dG9uKGV2ZW50KSwgaW5wdXRCdXR0b24pKTtcbiAgfTtcbiAgX19wcm90by5fcHJldmVudE1vdXNlQnV0dG9uID0gZnVuY3Rpb24gKGV2ZW50LCBidXR0b24pIHtcbiAgICBpZiAoYnV0dG9uID09PSBNT1VTRV9SSUdIVCkge1xuICAgICAgd2luLmFkZEV2ZW50TGlzdGVuZXIoXCJjb250ZXh0bWVudVwiLCB0aGlzLl9zdG9wQ29udGV4dE1lbnUpO1xuICAgIH0gZWxzZSBpZiAoYnV0dG9uID09PSBNT1VTRV9NSURETEUpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gRXZlbnRJbnB1dDtcbn0oKTtcblxudmFyIE1vdXNlRXZlbnRJbnB1dCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyQxKE1vdXNlRXZlbnRJbnB1dCwgX3N1cGVyKTtcbiAgZnVuY3Rpb24gTW91c2VFdmVudElucHV0KCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIF90aGlzLnN0YXJ0ID0gW1wibW91c2Vkb3duXCJdO1xuICAgIF90aGlzLm1vdmUgPSBbXCJtb3VzZW1vdmVcIl07XG4gICAgX3RoaXMuZW5kID0gW1wibW91c2V1cFwiXTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgdmFyIF9fcHJvdG8gPSBNb3VzZUV2ZW50SW5wdXQucHJvdG90eXBlO1xuICBfX3Byb3RvLm9uRXZlbnRTdGFydCA9IGZ1bmN0aW9uIChldmVudCwgaW5wdXRLZXksIGlucHV0QnV0dG9uKSB7XG4gICAgdmFyIGJ1dHRvbiA9IHRoaXMuX2dldEJ1dHRvbihldmVudCk7XG4gICAgaWYgKCF0aGlzLl9pc1ZhbGlkRXZlbnQoZXZlbnQsIGlucHV0S2V5LCBpbnB1dEJ1dHRvbikpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB0aGlzLl9wcmV2ZW50TW91c2VCdXR0b24oZXZlbnQsIGJ1dHRvbik7XG4gICAgcmV0dXJuIHRoaXMuZXh0ZW5kRXZlbnQoZXZlbnQpO1xuICB9O1xuICBfX3Byb3RvLm9uRXZlbnRNb3ZlID0gZnVuY3Rpb24gKGV2ZW50LCBpbnB1dEtleSwgaW5wdXRCdXR0b24pIHtcbiAgICBpZiAoIXRoaXMuX2lzVmFsaWRFdmVudChldmVudCwgaW5wdXRLZXksIGlucHV0QnV0dG9uKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmV4dGVuZEV2ZW50KGV2ZW50KTtcbiAgfTtcbiAgX19wcm90by5vbkV2ZW50RW5kID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybjtcbiAgfTtcbiAgX19wcm90by5vblJlbGVhc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5wcmV2RXZlbnQgPSBudWxsO1xuICAgIHJldHVybjtcbiAgfTtcbiAgX19wcm90by5nZXRUb3VjaGVzID0gZnVuY3Rpb24gKGV2ZW50LCBpbnB1dEJ1dHRvbikge1xuICAgIGlmIChpbnB1dEJ1dHRvbikge1xuICAgICAgcmV0dXJuIHRoaXMuX2lzVmFsaWRCdXR0b24oTU9VU0VfQlVUVE9OX0NPREVfTUFQW2V2ZW50LndoaWNoXSwgaW5wdXRCdXR0b24pICYmIHRoaXMuZW5kLmluZGV4T2YoZXZlbnQudHlwZSkgPT09IC0xID8gMSA6IDA7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9O1xuICBfX3Byb3RvLl9nZXRTY2FsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gMTtcbiAgfTtcbiAgX19wcm90by5fZ2V0Q2VudGVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGV2ZW50LmNsaWVudFgsXG4gICAgICB5OiBldmVudC5jbGllbnRZXG4gICAgfTtcbiAgfTtcbiAgX19wcm90by5fZ2V0TW92ZW1lbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgcHJldiA9IHRoaXMucHJldkV2ZW50LnNyY0V2ZW50O1xuICAgIHJldHVybiB7XG4gICAgICB4OiBldmVudC5jbGllbnRYIC0gcHJldi5jbGllbnRYLFxuICAgICAgeTogZXZlbnQuY2xpZW50WSAtIHByZXYuY2xpZW50WVxuICAgIH07XG4gIH07XG4gIHJldHVybiBNb3VzZUV2ZW50SW5wdXQ7XG59KEV2ZW50SW5wdXQpO1xuXG52YXIgVG91Y2hFdmVudElucHV0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzJDEoVG91Y2hFdmVudElucHV0LCBfc3VwZXIpO1xuICBmdW5jdGlvbiBUb3VjaEV2ZW50SW5wdXQoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgX3RoaXMuc3RhcnQgPSBbXCJ0b3VjaHN0YXJ0XCJdO1xuICAgIF90aGlzLm1vdmUgPSBbXCJ0b3VjaG1vdmVcIl07XG4gICAgX3RoaXMuZW5kID0gW1widG91Y2hlbmRcIiwgXCJ0b3VjaGNhbmNlbFwiXTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgdmFyIF9fcHJvdG8gPSBUb3VjaEV2ZW50SW5wdXQucHJvdG90eXBlO1xuICBfX3Byb3RvLm9uRXZlbnRTdGFydCA9IGZ1bmN0aW9uIChldmVudCwgaW5wdXRLZXkpIHtcbiAgICB0aGlzLl9iYXNlVG91Y2hlcyA9IGV2ZW50LnRvdWNoZXM7XG4gICAgaWYgKCF0aGlzLl9pc1ZhbGlkRXZlbnQoZXZlbnQsIGlucHV0S2V5KSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmV4dGVuZEV2ZW50KGV2ZW50KTtcbiAgfTtcbiAgX19wcm90by5vbkV2ZW50TW92ZSA9IGZ1bmN0aW9uIChldmVudCwgaW5wdXRLZXkpIHtcbiAgICBpZiAoIXRoaXMuX2lzVmFsaWRFdmVudChldmVudCwgaW5wdXRLZXkpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZXh0ZW5kRXZlbnQoZXZlbnQpO1xuICB9O1xuICBfX3Byb3RvLm9uRXZlbnRFbmQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB0aGlzLl9iYXNlVG91Y2hlcyA9IGV2ZW50LnRvdWNoZXM7XG4gICAgcmV0dXJuO1xuICB9O1xuICBfX3Byb3RvLm9uUmVsZWFzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnByZXZFdmVudCA9IG51bGw7XG4gICAgdGhpcy5fYmFzZVRvdWNoZXMgPSBudWxsO1xuICAgIHJldHVybjtcbiAgfTtcbiAgX19wcm90by5nZXRUb3VjaGVzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50LnRvdWNoZXMubGVuZ3RoO1xuICB9O1xuICBfX3Byb3RvLl9nZXRTY2FsZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmIChldmVudC50b3VjaGVzLmxlbmd0aCAhPT0gMiB8fCB0aGlzLl9iYXNlVG91Y2hlcy5sZW5ndGggPCAyKSB7XG4gICAgICByZXR1cm4gbnVsbDsgLy8gVE9ETzogY29uc2lkZXIgY2FsY3VsYXRpbmcgbm9uLXBpbmNoIGdlc3R1cmUgc2NhbGVcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fZ2V0RGlzdGFuY2UoZXZlbnQudG91Y2hlc1swXSwgZXZlbnQudG91Y2hlc1sxXSkgLyB0aGlzLl9nZXREaXN0YW5jZSh0aGlzLl9iYXNlVG91Y2hlc1swXSwgdGhpcy5fYmFzZVRvdWNoZXNbMV0pO1xuICB9O1xuICBfX3Byb3RvLl9nZXRDZW50ZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogZXZlbnQudG91Y2hlc1swXS5jbGllbnRYLFxuICAgICAgeTogZXZlbnQudG91Y2hlc1swXS5jbGllbnRZXG4gICAgfTtcbiAgfTtcbiAgX19wcm90by5fZ2V0TW92ZW1lbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgcHJldiA9IHRoaXMucHJldkV2ZW50LnNyY0V2ZW50O1xuICAgIGlmIChldmVudC50b3VjaGVzWzBdLmlkZW50aWZpZXIgIT09IHByZXYudG91Y2hlc1swXS5pZGVudGlmaWVyKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgeDogZXZlbnQudG91Y2hlc1swXS5jbGllbnRYIC0gcHJldi50b3VjaGVzWzBdLmNsaWVudFgsXG4gICAgICB5OiBldmVudC50b3VjaGVzWzBdLmNsaWVudFkgLSBwcmV2LnRvdWNoZXNbMF0uY2xpZW50WVxuICAgIH07XG4gIH07XG4gIHJldHVybiBUb3VjaEV2ZW50SW5wdXQ7XG59KEV2ZW50SW5wdXQpO1xuXG52YXIgUG9pbnRlckV2ZW50SW5wdXQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMkMShQb2ludGVyRXZlbnRJbnB1dCwgX3N1cGVyKTtcbiAgZnVuY3Rpb24gUG9pbnRlckV2ZW50SW5wdXQoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgX3RoaXMuc3RhcnQgPSBTVVBQT1JUX1BPSU5URVIgPyBbXCJwb2ludGVyZG93blwiXSA6IFtcIk1TUG9pbnRlckRvd25cIl07XG4gICAgX3RoaXMubW92ZSA9IFNVUFBPUlRfUE9JTlRFUiA/IFtcInBvaW50ZXJtb3ZlXCJdIDogW1wiTVNQb2ludGVyTW92ZVwiXTtcbiAgICBfdGhpcy5lbmQgPSBTVVBQT1JUX1BPSU5URVIgPyBbXCJwb2ludGVydXBcIiwgXCJwb2ludGVyY2FuY2VsXCJdIDogW1wiTVNQb2ludGVyVXBcIiwgXCJNU1BvaW50ZXJDYW5jZWxcIl07XG4gICAgLy8gc3RvcmUgZmlyc3QsIHJlY2VudCBpbnB1dHMgZm9yIGVhY2ggZXZlbnQgaWRcbiAgICBfdGhpcy5fZmlyc3RJbnB1dHMgPSBbXTtcbiAgICBfdGhpcy5fcmVjZW50SW5wdXRzID0gW107XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIHZhciBfX3Byb3RvID0gUG9pbnRlckV2ZW50SW5wdXQucHJvdG90eXBlO1xuICBfX3Byb3RvLm9uRXZlbnRTdGFydCA9IGZ1bmN0aW9uIChldmVudCwgaW5wdXRLZXksIGlucHV0QnV0dG9uKSB7XG4gICAgdmFyIGJ1dHRvbiA9IHRoaXMuX2dldEJ1dHRvbihldmVudCk7XG4gICAgaWYgKCF0aGlzLl9pc1ZhbGlkRXZlbnQoZXZlbnQsIGlucHV0S2V5LCBpbnB1dEJ1dHRvbikpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB0aGlzLl9wcmV2ZW50TW91c2VCdXR0b24oZXZlbnQsIGJ1dHRvbik7XG4gICAgdGhpcy5fdXBkYXRlUG9pbnRlckV2ZW50KGV2ZW50KTtcbiAgICByZXR1cm4gdGhpcy5leHRlbmRFdmVudChldmVudCk7XG4gIH07XG4gIF9fcHJvdG8ub25FdmVudE1vdmUgPSBmdW5jdGlvbiAoZXZlbnQsIGlucHV0S2V5LCBpbnB1dEJ1dHRvbikge1xuICAgIGlmICghdGhpcy5faXNWYWxpZEV2ZW50KGV2ZW50LCBpbnB1dEtleSwgaW5wdXRCdXR0b24pKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5fdXBkYXRlUG9pbnRlckV2ZW50KGV2ZW50KTtcbiAgICByZXR1cm4gdGhpcy5leHRlbmRFdmVudChldmVudCk7XG4gIH07XG4gIF9fcHJvdG8ub25FdmVudEVuZCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHRoaXMuX3JlbW92ZVBvaW50ZXJFdmVudChldmVudCk7XG4gIH07XG4gIF9fcHJvdG8ub25SZWxlYXNlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucHJldkV2ZW50ID0gbnVsbDtcbiAgICB0aGlzLl9maXJzdElucHV0cyA9IFtdO1xuICAgIHRoaXMuX3JlY2VudElucHV0cyA9IFtdO1xuICAgIHJldHVybjtcbiAgfTtcbiAgX19wcm90by5nZXRUb3VjaGVzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9yZWNlbnRJbnB1dHMubGVuZ3RoO1xuICB9O1xuICBfX3Byb3RvLl9nZXRTY2FsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fcmVjZW50SW5wdXRzLmxlbmd0aCAhPT0gMikge1xuICAgICAgcmV0dXJuIG51bGw7IC8vIFRPRE86IGNvbnNpZGVyIGNhbGN1bGF0aW5nIG5vbi1waW5jaCBnZXN0dXJlIHNjYWxlXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2dldERpc3RhbmNlKHRoaXMuX3JlY2VudElucHV0c1swXSwgdGhpcy5fcmVjZW50SW5wdXRzWzFdKSAvIHRoaXMuX2dldERpc3RhbmNlKHRoaXMuX2ZpcnN0SW5wdXRzWzBdLCB0aGlzLl9maXJzdElucHV0c1sxXSk7XG4gIH07XG4gIF9fcHJvdG8uX2dldENlbnRlciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiBldmVudC5jbGllbnRYLFxuICAgICAgeTogZXZlbnQuY2xpZW50WVxuICAgIH07XG4gIH07XG4gIF9fcHJvdG8uX2dldE1vdmVtZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIHByZXYgPSB0aGlzLnByZXZFdmVudC5zcmNFdmVudDtcbiAgICBpZiAoZXZlbnQucG9pbnRlcklkICE9PSBwcmV2LnBvaW50ZXJJZCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMFxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGV2ZW50LmNsaWVudFggLSBwcmV2LmNsaWVudFgsXG4gICAgICB5OiBldmVudC5jbGllbnRZIC0gcHJldi5jbGllbnRZXG4gICAgfTtcbiAgfTtcbiAgX19wcm90by5fdXBkYXRlUG9pbnRlckV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB2YXIgYWRkRmxhZyA9IGZhbHNlO1xuICAgIHRoaXMuX3JlY2VudElucHV0cy5mb3JFYWNoKGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICBpZiAoZS5wb2ludGVySWQgPT09IGV2ZW50LnBvaW50ZXJJZCkge1xuICAgICAgICBhZGRGbGFnID0gdHJ1ZTtcbiAgICAgICAgX3RoaXMuX3JlY2VudElucHV0c1tpXSA9IGV2ZW50O1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghYWRkRmxhZykge1xuICAgICAgdGhpcy5fZmlyc3RJbnB1dHMucHVzaChldmVudCk7XG4gICAgICB0aGlzLl9yZWNlbnRJbnB1dHMucHVzaChldmVudCk7XG4gICAgfVxuICB9O1xuICBfX3Byb3RvLl9yZW1vdmVQb2ludGVyRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB0aGlzLl9maXJzdElucHV0cyA9IHRoaXMuX2ZpcnN0SW5wdXRzLmZpbHRlcihmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHgucG9pbnRlcklkICE9PSBldmVudC5wb2ludGVySWQ7XG4gICAgfSk7XG4gICAgdGhpcy5fcmVjZW50SW5wdXRzID0gdGhpcy5fcmVjZW50SW5wdXRzLmZpbHRlcihmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHgucG9pbnRlcklkICE9PSBldmVudC5wb2ludGVySWQ7XG4gICAgfSk7XG4gIH07XG4gIHJldHVybiBQb2ludGVyRXZlbnRJbnB1dDtcbn0oRXZlbnRJbnB1dCk7XG5cbnZhciBUb3VjaE1vdXNlRXZlbnRJbnB1dCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyQxKFRvdWNoTW91c2VFdmVudElucHV0LCBfc3VwZXIpO1xuICBmdW5jdGlvbiBUb3VjaE1vdXNlRXZlbnRJbnB1dCgpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICBfdGhpcy5zdGFydCA9IFtcIm1vdXNlZG93blwiLCBcInRvdWNoc3RhcnRcIl07XG4gICAgX3RoaXMubW92ZSA9IFtcIm1vdXNlbW92ZVwiLCBcInRvdWNobW92ZVwiXTtcbiAgICBfdGhpcy5lbmQgPSBbXCJtb3VzZXVwXCIsIFwidG91Y2hlbmRcIiwgXCJ0b3VjaGNhbmNlbFwiXTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgdmFyIF9fcHJvdG8gPSBUb3VjaE1vdXNlRXZlbnRJbnB1dC5wcm90b3R5cGU7XG4gIF9fcHJvdG8ub25FdmVudFN0YXJ0ID0gZnVuY3Rpb24gKGV2ZW50LCBpbnB1dEtleSwgaW5wdXRCdXR0b24pIHtcbiAgICB2YXIgYnV0dG9uID0gdGhpcy5fZ2V0QnV0dG9uKGV2ZW50KTtcbiAgICBpZiAodGhpcy5faXNUb3VjaEV2ZW50KGV2ZW50KSkge1xuICAgICAgdGhpcy5fYmFzZVRvdWNoZXMgPSBldmVudC50b3VjaGVzO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX2lzVmFsaWRFdmVudChldmVudCwgaW5wdXRLZXksIGlucHV0QnV0dG9uKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHRoaXMuX3ByZXZlbnRNb3VzZUJ1dHRvbihldmVudCwgYnV0dG9uKTtcbiAgICByZXR1cm4gdGhpcy5leHRlbmRFdmVudChldmVudCk7XG4gIH07XG4gIF9fcHJvdG8ub25FdmVudE1vdmUgPSBmdW5jdGlvbiAoZXZlbnQsIGlucHV0S2V5LCBpbnB1dEJ1dHRvbikge1xuICAgIGlmICghdGhpcy5faXNWYWxpZEV2ZW50KGV2ZW50LCBpbnB1dEtleSwgaW5wdXRCdXR0b24pKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZXh0ZW5kRXZlbnQoZXZlbnQpO1xuICB9O1xuICBfX3Byb3RvLm9uRXZlbnRFbmQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAodGhpcy5faXNUb3VjaEV2ZW50KGV2ZW50KSkge1xuICAgICAgdGhpcy5fYmFzZVRvdWNoZXMgPSBldmVudC50b3VjaGVzO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH07XG4gIF9fcHJvdG8ub25SZWxlYXNlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucHJldkV2ZW50ID0gbnVsbDtcbiAgICB0aGlzLl9iYXNlVG91Y2hlcyA9IG51bGw7XG4gICAgcmV0dXJuO1xuICB9O1xuICBfX3Byb3RvLmdldFRvdWNoZXMgPSBmdW5jdGlvbiAoZXZlbnQsIGlucHV0QnV0dG9uKSB7XG4gICAgaWYgKHRoaXMuX2lzVG91Y2hFdmVudChldmVudCkpIHtcbiAgICAgIHJldHVybiBldmVudC50b3VjaGVzLmxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX2lzVmFsaWRCdXR0b24oTU9VU0VfQlVUVE9OX0NPREVfTUFQW2V2ZW50LndoaWNoXSwgaW5wdXRCdXR0b24pICYmIHRoaXMuZW5kLmluZGV4T2YoZXZlbnQudHlwZSkgPT09IC0xID8gMSA6IDA7XG4gICAgfVxuICB9O1xuICBfX3Byb3RvLl9nZXRTY2FsZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmICh0aGlzLl9pc1RvdWNoRXZlbnQoZXZlbnQpKSB7XG4gICAgICBpZiAoZXZlbnQudG91Y2hlcy5sZW5ndGggIT09IDIgfHwgdGhpcy5fYmFzZVRvdWNoZXMubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gMTsgLy8gVE9ETzogY29uc2lkZXIgY2FsY3VsYXRpbmcgbm9uLXBpbmNoIGdlc3R1cmUgc2NhbGVcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX2dldERpc3RhbmNlKGV2ZW50LnRvdWNoZXNbMF0sIGV2ZW50LnRvdWNoZXNbMV0pIC8gdGhpcy5fZ2V0RGlzdGFuY2UodGhpcy5fYmFzZVRvdWNoZXNbMF0sIHRoaXMuX2Jhc2VUb3VjaGVzWzFdKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucHJldkV2ZW50LnNjYWxlO1xuICB9O1xuICBfX3Byb3RvLl9nZXRDZW50ZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAodGhpcy5faXNUb3VjaEV2ZW50KGV2ZW50KSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogZXZlbnQudG91Y2hlc1swXS5jbGllbnRYLFxuICAgICAgICB5OiBldmVudC50b3VjaGVzWzBdLmNsaWVudFlcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB4OiBldmVudC5jbGllbnRYLFxuICAgICAgeTogZXZlbnQuY2xpZW50WVxuICAgIH07XG4gIH07XG4gIF9fcHJvdG8uX2dldE1vdmVtZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB2YXIgcHJldiA9IHRoaXMucHJldkV2ZW50LnNyY0V2ZW50O1xuICAgIHZhciBfYSA9IFtldmVudCwgcHJldl0ubWFwKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChfdGhpcy5faXNUb3VjaEV2ZW50KGUpKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkOiBlLnRvdWNoZXNbMF0uaWRlbnRpZmllcixcbiAgICAgICAgICAgIHg6IGUudG91Y2hlc1swXS5jbGllbnRYLFxuICAgICAgICAgICAgeTogZS50b3VjaGVzWzBdLmNsaWVudFlcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaWQ6IG51bGwsXG4gICAgICAgICAgeDogZS5jbGllbnRYLFxuICAgICAgICAgIHk6IGUuY2xpZW50WVxuICAgICAgICB9O1xuICAgICAgfSksXG4gICAgICBuZXh0U3BvdCA9IF9hWzBdLFxuICAgICAgcHJldlNwb3QgPSBfYVsxXTtcbiAgICByZXR1cm4gbmV4dFNwb3QuaWQgPT09IHByZXZTcG90LmlkID8ge1xuICAgICAgeDogbmV4dFNwb3QueCAtIHByZXZTcG90LngsXG4gICAgICB5OiBuZXh0U3BvdC55IC0gcHJldlNwb3QueVxuICAgIH0gOiB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMFxuICAgIH07XG4gIH07XG4gIHJldHVybiBUb3VjaE1vdXNlRXZlbnRJbnB1dDtcbn0oRXZlbnRJbnB1dCk7XG5cbnZhciB0b0F4aXMgPSBmdW5jdGlvbiAoc291cmNlLCBvZmZzZXQpIHtcbiAgcmV0dXJuIG9mZnNldC5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgdiwgaSkge1xuICAgIGlmIChzb3VyY2VbaV0pIHtcbiAgICAgIGFjY1tzb3VyY2VbaV1dID0gdjtcbiAgICB9XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xufTtcbnZhciBjb252ZXJ0SW5wdXRUeXBlID0gZnVuY3Rpb24gKGlucHV0VHlwZSkge1xuICBpZiAoaW5wdXRUeXBlID09PSB2b2lkIDApIHtcbiAgICBpbnB1dFR5cGUgPSBbXTtcbiAgfVxuICB2YXIgaGFzVG91Y2ggPSBmYWxzZTtcbiAgdmFyIGhhc01vdXNlID0gZmFsc2U7XG4gIHZhciBoYXNQb2ludGVyID0gZmFsc2U7XG4gIGlucHV0VHlwZS5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgc3dpdGNoICh2KSB7XG4gICAgICBjYXNlIFwibW91c2VcIjpcbiAgICAgICAgaGFzTW91c2UgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJ0b3VjaFwiOlxuICAgICAgICBoYXNUb3VjaCA9IFNVUFBPUlRfVE9VQ0g7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInBvaW50ZXJcIjpcbiAgICAgICAgaGFzUG9pbnRlciA9IFNVUFBPUlRfUE9JTlRFUl9FVkVOVFM7XG4gICAgICAvLyBubyBkZWZhdWx0XG4gICAgfVxuICB9KTtcblxuICBpZiAoaGFzUG9pbnRlcikge1xuICAgIHJldHVybiBuZXcgUG9pbnRlckV2ZW50SW5wdXQoKTtcbiAgfSBlbHNlIGlmIChoYXNUb3VjaCAmJiBoYXNNb3VzZSkge1xuICAgIHJldHVybiBuZXcgVG91Y2hNb3VzZUV2ZW50SW5wdXQoKTtcbiAgfSBlbHNlIGlmIChoYXNUb3VjaCkge1xuICAgIHJldHVybiBuZXcgVG91Y2hFdmVudElucHV0KCk7XG4gIH0gZWxzZSBpZiAoaGFzTW91c2UpIHtcbiAgICByZXR1cm4gbmV3IE1vdXNlRXZlbnRJbnB1dCgpO1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcbmZ1bmN0aW9uIGdldEFkZEV2ZW50T3B0aW9ucyhldmVudE5hbWUpIHtcbiAgLy8gVGhlIHBhc3NpdmUgZGVmYXVsdCB2YWx1ZSBvZiB0aGUgdG91Y2ggZXZlbnQgaXMgdHJ1ZS5cbiAgLy8gSWYgbm90IGEgdG91Y2ggZXZlbnQsIHJldHVybiBmYWxzZSB0byBzdXBwb3J0IGllMTFcbiAgcmV0dXJuIGV2ZW50TmFtZS5pbmRleE9mKFwidG91Y2hcIikgPiAtMSA/IHtcbiAgICBwYXNzaXZlOiBmYWxzZVxuICB9IDogZmFsc2U7XG59XG5cbnZhciBJbnB1dE9ic2VydmVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gSW5wdXRPYnNlcnZlcihfYSkge1xuICAgIHZhciBvcHRpb25zID0gX2Eub3B0aW9ucyxcbiAgICAgIGludGVycnVwdE1hbmFnZXIgPSBfYS5pbnRlcnJ1cHRNYW5hZ2VyLFxuICAgICAgZXZlbnRNYW5hZ2VyID0gX2EuZXZlbnRNYW5hZ2VyLFxuICAgICAgYXhpc01hbmFnZXIgPSBfYS5heGlzTWFuYWdlcixcbiAgICAgIGFuaW1hdGlvbk1hbmFnZXIgPSBfYS5hbmltYXRpb25NYW5hZ2VyO1xuICAgIHRoaXMuX2lzT3V0c2lkZSA9IGZhbHNlO1xuICAgIHRoaXMuX21vdmVEaXN0YW5jZSA9IG51bGw7XG4gICAgdGhpcy5faXNTdG9wcGVkID0gZmFsc2U7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLl9pbnRlcnJ1cHRNYW5hZ2VyID0gaW50ZXJydXB0TWFuYWdlcjtcbiAgICB0aGlzLl9ldmVudE1hbmFnZXIgPSBldmVudE1hbmFnZXI7XG4gICAgdGhpcy5fYXhpc01hbmFnZXIgPSBheGlzTWFuYWdlcjtcbiAgICB0aGlzLl9hbmltYXRpb25NYW5hZ2VyID0gYW5pbWF0aW9uTWFuYWdlcjtcbiAgfVxuICB2YXIgX19wcm90byA9IElucHV0T2JzZXJ2ZXIucHJvdG90eXBlO1xuICBfX3Byb3RvLmdldCA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIHJldHVybiB0aGlzLl9heGlzTWFuYWdlci5nZXQoaW5wdXQuYXhlcyk7XG4gIH07XG4gIF9fcHJvdG8uaG9sZCA9IGZ1bmN0aW9uIChpbnB1dCwgZXZlbnQpIHtcbiAgICBpZiAodGhpcy5faW50ZXJydXB0TWFuYWdlci5pc0ludGVycnVwdGVkKCkgfHwgIWlucHV0LmF4ZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBjaGFuZ2VPcHRpb24gPSB7XG4gICAgICBpbnB1dDogaW5wdXQsXG4gICAgICBldmVudDogZXZlbnRcbiAgICB9O1xuICAgIHRoaXMuX2lzU3RvcHBlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2ludGVycnVwdE1hbmFnZXIuc2V0SW50ZXJydXB0KHRydWUpO1xuICAgIHRoaXMuX2FuaW1hdGlvbk1hbmFnZXIuc3RvcEFuaW1hdGlvbihjaGFuZ2VPcHRpb24pO1xuICAgICsrdGhpcy5fZXZlbnRNYW5hZ2VyLmhvbGRpbmdDb3VudDtcbiAgICBpZiAoIXRoaXMuX21vdmVEaXN0YW5jZSkge1xuICAgICAgdGhpcy5fZXZlbnRNYW5hZ2VyLmhvbGQodGhpcy5fYXhpc01hbmFnZXIuZ2V0KCksIGNoYW5nZU9wdGlvbik7XG4gICAgfVxuICAgIHRoaXMuX2lzT3V0c2lkZSA9IHRoaXMuX2F4aXNNYW5hZ2VyLmlzT3V0c2lkZShpbnB1dC5heGVzKTtcbiAgICB0aGlzLl9tb3ZlRGlzdGFuY2UgPSB0aGlzLl9heGlzTWFuYWdlci5nZXQoaW5wdXQuYXhlcyk7XG4gIH07XG4gIF9fcHJvdG8uY2hhbmdlID0gZnVuY3Rpb24gKGlucHV0LCBldmVudCwgb2Zmc2V0LCB1c2VBbmltYXRpb24pIHtcbiAgICBpZiAodGhpcy5faXNTdG9wcGVkIHx8ICF0aGlzLl9pbnRlcnJ1cHRNYW5hZ2VyLmlzSW50ZXJydXB0aW5nKCkgfHwgdGhpcy5fYXhpc01hbmFnZXIuZXZlcnkob2Zmc2V0LCBmdW5jdGlvbiAodikge1xuICAgICAgcmV0dXJuIHYgPT09IDA7XG4gICAgfSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG5hdGl2ZUV2ZW50ID0gZXZlbnQuc3JjRXZlbnQgPyBldmVudC5zcmNFdmVudCA6IGV2ZW50O1xuICAgIGlmIChuYXRpdmVFdmVudC5fX2NoaWxkcmVuQXhlc0FscmVhZHlDaGFuZ2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBkZXBhUG9zID0gdGhpcy5fbW92ZURpc3RhbmNlIHx8IHRoaXMuX2F4aXNNYW5hZ2VyLmdldChpbnB1dC5heGVzKTtcbiAgICB2YXIgZGVzdFBvcztcbiAgICAvLyBmb3Igb3V0c2lkZSBsb2dpY1xuICAgIGRlc3RQb3MgPSBtYXAoZGVwYVBvcywgZnVuY3Rpb24gKHYsIGspIHtcbiAgICAgIHJldHVybiB2ICsgKG9mZnNldFtrXSB8fCAwKTtcbiAgICB9KTtcbiAgICBpZiAodGhpcy5fbW92ZURpc3RhbmNlKSB7XG4gICAgICB0aGlzLl9tb3ZlRGlzdGFuY2UgPSB0aGlzLl9heGlzTWFuYWdlci5tYXAoZGVzdFBvcywgZnVuY3Rpb24gKHYsIF9hKSB7XG4gICAgICAgIHZhciBjaXJjdWxhciA9IF9hLmNpcmN1bGFyLFxuICAgICAgICAgIHJhbmdlID0gX2EucmFuZ2U7XG4gICAgICAgIHJldHVybiBjaXJjdWxhciAmJiAoY2lyY3VsYXJbMF0gfHwgY2lyY3VsYXJbMV0pID8gZ2V0Q2lyY3VsYXRlZFBvcyh2LCByYW5nZSwgY2lyY3VsYXIpIDogdjtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBmcm9tIG91dHNpZGUgdG8gaW5zaWRlXG4gICAgaWYgKHRoaXMuX2lzT3V0c2lkZSAmJiB0aGlzLl9heGlzTWFuYWdlci5ldmVyeShkZXBhUG9zLCBmdW5jdGlvbiAodiwgb3B0KSB7XG4gICAgICByZXR1cm4gIWlzT3V0c2lkZSh2LCBvcHQucmFuZ2UpO1xuICAgIH0pKSB7XG4gICAgICB0aGlzLl9pc091dHNpZGUgPSBmYWxzZTtcbiAgICB9XG4gICAgZGVwYVBvcyA9IHRoaXMuX2F0T3V0c2lkZShkZXBhUG9zKTtcbiAgICBkZXN0UG9zID0gdGhpcy5fYXRPdXRzaWRlKGRlc3RQb3MpO1xuICAgIGlmICghdGhpcy5vcHRpb25zLm5lc3RlZCB8fCAhdGhpcy5faXNFbmRvZkF4aXMob2Zmc2V0LCBkZXBhUG9zLCBkZXN0UG9zKSkge1xuICAgICAgbmF0aXZlRXZlbnQuX19jaGlsZHJlbkF4ZXNBbHJlYWR5Q2hhbmdlZCA9IHRydWU7XG4gICAgfVxuICAgIHZhciBjaGFuZ2VPcHRpb24gPSB7XG4gICAgICBpbnB1dDogaW5wdXQsXG4gICAgICBldmVudDogZXZlbnRcbiAgICB9O1xuICAgIGlmICh1c2VBbmltYXRpb24pIHtcbiAgICAgIHZhciBkdXJhdGlvbiA9IHRoaXMuX2FuaW1hdGlvbk1hbmFnZXIuZ2V0RHVyYXRpb24oZGVzdFBvcywgZGVwYVBvcyk7XG4gICAgICB0aGlzLl9hbmltYXRpb25NYW5hZ2VyLmFuaW1hdGVUbyhkZXN0UG9zLCBkdXJhdGlvbiwgY2hhbmdlT3B0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGlzQ2FuY2VsZWQgPSAhdGhpcy5fZXZlbnRNYW5hZ2VyLnRyaWdnZXJDaGFuZ2UoZGVzdFBvcywgZGVwYVBvcywgY2hhbmdlT3B0aW9uLCB0cnVlKTtcbiAgICAgIGlmIChpc0NhbmNlbGVkKSB7XG4gICAgICAgIHRoaXMuX2lzU3RvcHBlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX21vdmVEaXN0YW5jZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2FuaW1hdGlvbk1hbmFnZXIuZmluaXNoKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIF9fcHJvdG8ucmVsZWFzZSA9IGZ1bmN0aW9uIChpbnB1dCwgZXZlbnQsIHZlbG9jaXR5LCBpbnB1dER1cmF0aW9uKSB7XG4gICAgaWYgKHRoaXMuX2lzU3RvcHBlZCB8fCAhdGhpcy5faW50ZXJydXB0TWFuYWdlci5pc0ludGVycnVwdGluZygpIHx8ICF0aGlzLl9tb3ZlRGlzdGFuY2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG5hdGl2ZUV2ZW50ID0gZXZlbnQuc3JjRXZlbnQgPyBldmVudC5zcmNFdmVudCA6IGV2ZW50O1xuICAgIGlmIChuYXRpdmVFdmVudC5fX2NoaWxkcmVuQXhlc0FscmVhZHlSZWxlYXNlZCkge1xuICAgICAgdmVsb2NpdHkgPSB2ZWxvY2l0eS5tYXAoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgcG9zID0gdGhpcy5fYXhpc01hbmFnZXIuZ2V0KGlucHV0LmF4ZXMpO1xuICAgIHZhciBkZXBhUG9zID0gdGhpcy5fYXhpc01hbmFnZXIuZ2V0KCk7XG4gICAgdmFyIGRpc3BsYWNlbWVudCA9IHRoaXMuX2FuaW1hdGlvbk1hbmFnZXIuZ2V0RGlzcGxhY2VtZW50KHZlbG9jaXR5KTtcbiAgICB2YXIgb2Zmc2V0ID0gdG9BeGlzKGlucHV0LmF4ZXMsIGRpc3BsYWNlbWVudCk7XG4gICAgdmFyIGRlc3RQb3MgPSB0aGlzLl9heGlzTWFuYWdlci5nZXQodGhpcy5fYXhpc01hbmFnZXIubWFwKG9mZnNldCwgZnVuY3Rpb24gKHYsIG9wdCwgaykge1xuICAgICAgaWYgKG9wdC5jaXJjdWxhciAmJiAob3B0LmNpcmN1bGFyWzBdIHx8IG9wdC5jaXJjdWxhclsxXSkpIHtcbiAgICAgICAgcmV0dXJuIHBvc1trXSArIHY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZ2V0SW5zaWRlUG9zaXRpb24ocG9zW2tdICsgdiwgb3B0LnJhbmdlLCBvcHQuY2lyY3VsYXIsIG9wdC5ib3VuY2UpO1xuICAgICAgfVxuICAgIH0pKTtcbiAgICBuYXRpdmVFdmVudC5fX2NoaWxkcmVuQXhlc0FscmVhZHlSZWxlYXNlZCA9IHRydWU7XG4gICAgdmFyIGR1cmF0aW9uID0gdGhpcy5fYW5pbWF0aW9uTWFuYWdlci5nZXREdXJhdGlvbihkZXN0UG9zLCBwb3MsIGlucHV0RHVyYXRpb24pO1xuICAgIGlmIChkdXJhdGlvbiA9PT0gMCkge1xuICAgICAgZGVzdFBvcyA9IF9fYXNzaWduKHt9LCBkZXBhUG9zKTtcbiAgICB9XG4gICAgLy8gcHJlcGFyZSBwYXJhbXNcbiAgICB2YXIgcGFyYW0gPSB7XG4gICAgICBkZXBhUG9zOiBkZXBhUG9zLFxuICAgICAgZGVzdFBvczogZGVzdFBvcyxcbiAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbixcbiAgICAgIGRlbHRhOiB0aGlzLl9heGlzTWFuYWdlci5nZXREZWx0YShkZXBhUG9zLCBkZXN0UG9zKSxcbiAgICAgIGlucHV0RXZlbnQ6IGV2ZW50LFxuICAgICAgaW5wdXQ6IGlucHV0LFxuICAgICAgaXNUcnVzdGVkOiB0cnVlXG4gICAgfTtcbiAgICAtLXRoaXMuX2V2ZW50TWFuYWdlci5ob2xkaW5nQ291bnQ7XG4gICAgdGhpcy5fZXZlbnRNYW5hZ2VyLnRyaWdnZXJSZWxlYXNlKHBhcmFtKTtcbiAgICBpZiAodGhpcy5fZXZlbnRNYW5hZ2VyLmhvbGRpbmdDb3VudCA9PT0gMCkge1xuICAgICAgdGhpcy5fbW92ZURpc3RhbmNlID0gbnVsbDtcbiAgICB9XG4gICAgLy8gdG8gY29udG9sXG4gICAgdmFyIHVzZXJXaXNoID0gdGhpcy5fYW5pbWF0aW9uTWFuYWdlci5nZXRVc2VyQ29udHJvbChwYXJhbSk7XG4gICAgdmFyIGlzRXF1YWwgPSBlcXVhbCh1c2VyV2lzaC5kZXN0UG9zLCBkZXBhUG9zKTtcbiAgICB2YXIgY2hhbmdlT3B0aW9uID0ge1xuICAgICAgaW5wdXQ6IGlucHV0LFxuICAgICAgZXZlbnQ6IGV2ZW50XG4gICAgfTtcbiAgICBpZiAoaXNFcXVhbCB8fCB1c2VyV2lzaC5kdXJhdGlvbiA9PT0gMCkge1xuICAgICAgaWYgKCFpc0VxdWFsKSB7XG4gICAgICAgIHRoaXMuX2V2ZW50TWFuYWdlci50cmlnZ2VyQ2hhbmdlKHVzZXJXaXNoLmRlc3RQb3MsIGRlcGFQb3MsIGNoYW5nZU9wdGlvbiwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9pbnRlcnJ1cHRNYW5hZ2VyLnNldEludGVycnVwdChmYWxzZSk7XG4gICAgICBpZiAodGhpcy5fYXhpc01hbmFnZXIuaXNPdXRzaWRlKCkpIHtcbiAgICAgICAgdGhpcy5fYW5pbWF0aW9uTWFuYWdlci5yZXN0b3JlKGNoYW5nZU9wdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9ldmVudE1hbmFnZXIudHJpZ2dlckZpbmlzaCh0cnVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fYW5pbWF0aW9uTWFuYWdlci5hbmltYXRlVG8odXNlcldpc2guZGVzdFBvcywgdXNlcldpc2guZHVyYXRpb24sIGNoYW5nZU9wdGlvbik7XG4gICAgfVxuICB9O1xuICAvLyB3aGVuIG1vdmUgcG9pbnRlciBpcyBoZWxkIGluIG91dHNpZGVcbiAgX19wcm90by5fYXRPdXRzaWRlID0gZnVuY3Rpb24gKHBvcykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgaWYgKHRoaXMuX2lzT3V0c2lkZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2F4aXNNYW5hZ2VyLm1hcChwb3MsIGZ1bmN0aW9uICh2LCBvcHQpIHtcbiAgICAgICAgdmFyIHRuID0gb3B0LnJhbmdlWzBdIC0gb3B0LmJvdW5jZVswXTtcbiAgICAgICAgdmFyIHR4ID0gb3B0LnJhbmdlWzFdICsgb3B0LmJvdW5jZVsxXTtcbiAgICAgICAgcmV0dXJuIHYgPiB0eCA/IHR4IDogdiA8IHRuID8gdG4gOiB2O1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9heGlzTWFuYWdlci5tYXAocG9zLCBmdW5jdGlvbiAodiwgb3B0KSB7XG4gICAgICAgIHZhciBtaW4gPSBvcHQucmFuZ2VbMF07XG4gICAgICAgIHZhciBtYXggPSBvcHQucmFuZ2VbMV07XG4gICAgICAgIHZhciBvdXQgPSBvcHQuYm91bmNlO1xuICAgICAgICB2YXIgY2lyY3VsYXIgPSBvcHQuY2lyY3VsYXI7XG4gICAgICAgIGlmIChjaXJjdWxhclswXSAmJiB2IDwgbWluIHx8IGNpcmN1bGFyWzFdICYmIHYgPiBtYXgpIHtcbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgfSBlbHNlIGlmICh2IDwgbWluKSB7XG4gICAgICAgICAgLy8gbGVmdFxuICAgICAgICAgIHJldHVybiBtaW4gLSBfdGhpcy5fYW5pbWF0aW9uTWFuYWdlci5pbnRlcnBvbGF0ZShtaW4gLSB2LCBvdXRbMF0pO1xuICAgICAgICB9IGVsc2UgaWYgKHYgPiBtYXgpIHtcbiAgICAgICAgICAvLyByaWdodFxuICAgICAgICAgIHJldHVybiBtYXggKyBfdGhpcy5fYW5pbWF0aW9uTWFuYWdlci5pbnRlcnBvbGF0ZSh2IC0gbWF4LCBvdXRbMV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2O1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICBfX3Byb3RvLl9pc0VuZG9mQXhpcyA9IGZ1bmN0aW9uIChvZmZzZXQsIGRlcGFQb3MsIGRlc3RQb3MpIHtcbiAgICByZXR1cm4gdGhpcy5fYXhpc01hbmFnZXIuZXZlcnkoZGVwYVBvcywgZnVuY3Rpb24gKHZhbHVlLCBvcHRpb24sIGtleSkge1xuICAgICAgcmV0dXJuIG9mZnNldFtrZXldID09PSAwIHx8IGRlcGFQb3Nba2V5XSA9PT0gZGVzdFBvc1trZXldICYmIGlzRW5kb2ZCb3VuY2UodmFsdWUsIG9wdGlvbi5yYW5nZSwgb3B0aW9uLmJvdW5jZSwgb3B0aW9uLmNpcmN1bGFyKTtcbiAgICB9KTtcbiAgfTtcbiAgcmV0dXJuIElucHV0T2JzZXJ2ZXI7XG59KCk7XG5cbnZhciBjbGFtcCA9IGZ1bmN0aW9uICh2YWx1ZSwgbWluLCBtYXgpIHtcbiAgcmV0dXJuIE1hdGgubWF4KE1hdGgubWluKHZhbHVlLCBtYXgpLCBtaW4pO1xufTtcbnZhciBBbmltYXRpb25NYW5hZ2VyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQW5pbWF0aW9uTWFuYWdlcihfYSkge1xuICAgIHZhciBvcHRpb25zID0gX2Eub3B0aW9ucyxcbiAgICAgIGludGVycnVwdE1hbmFnZXIgPSBfYS5pbnRlcnJ1cHRNYW5hZ2VyLFxuICAgICAgZXZlbnRNYW5hZ2VyID0gX2EuZXZlbnRNYW5hZ2VyLFxuICAgICAgYXhpc01hbmFnZXIgPSBfYS5heGlzTWFuYWdlcjtcbiAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmludGVycnVwdE1hbmFnZXIgPSBpbnRlcnJ1cHRNYW5hZ2VyO1xuICAgIHRoaXMuZXZlbnRNYW5hZ2VyID0gZXZlbnRNYW5hZ2VyO1xuICAgIHRoaXMuYXhpc01hbmFnZXIgPSBheGlzTWFuYWdlcjtcbiAgICB0aGlzLmFuaW1hdGlvbkVuZCA9IHRoaXMuYW5pbWF0aW9uRW5kLmJpbmQodGhpcyk7XG4gIH1cbiAgdmFyIF9fcHJvdG8gPSBBbmltYXRpb25NYW5hZ2VyLnByb3RvdHlwZTtcbiAgX19wcm90by5nZXREdXJhdGlvbiA9IGZ1bmN0aW9uIChkZXBhUG9zLCBkZXN0UG9zLCB3aXNoRHVyYXRpb24pIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHZhciBkdXJhdGlvbjtcbiAgICBpZiAodHlwZW9mIHdpc2hEdXJhdGlvbiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgZHVyYXRpb24gPSB3aXNoRHVyYXRpb247XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBkdXJhdGlvbnNfMSA9IG1hcChkZXN0UG9zLCBmdW5jdGlvbiAodiwgaykge1xuICAgICAgICByZXR1cm4gZ2V0RHVyYXRpb24oTWF0aC5hYnModiAtIGRlcGFQb3Nba10pLCBfdGhpcy5fb3B0aW9ucy5kZWNlbGVyYXRpb24pO1xuICAgICAgfSk7XG4gICAgICBkdXJhdGlvbiA9IE9iamVjdC5rZXlzKGR1cmF0aW9uc18xKS5yZWR1Y2UoZnVuY3Rpb24gKG1heCwgdikge1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgobWF4LCBkdXJhdGlvbnNfMVt2XSk7XG4gICAgICB9LCAtSW5maW5pdHkpO1xuICAgIH1cbiAgICByZXR1cm4gY2xhbXAoZHVyYXRpb24sIHRoaXMuX29wdGlvbnMubWluaW11bUR1cmF0aW9uLCB0aGlzLl9vcHRpb25zLm1heGltdW1EdXJhdGlvbik7XG4gIH07XG4gIF9fcHJvdG8uZ2V0RGlzcGxhY2VtZW50ID0gZnVuY3Rpb24gKHZlbG9jaXR5KSB7XG4gICAgdmFyIHRvdGFsVmVsb2NpdHkgPSBNYXRoLnBvdyh2ZWxvY2l0eS5yZWR1Y2UoZnVuY3Rpb24gKHRvdGFsLCB2KSB7XG4gICAgICByZXR1cm4gdG90YWwgKyB2ICogdjtcbiAgICB9LCAwKSwgMSAvIHZlbG9jaXR5Lmxlbmd0aCk7XG4gICAgdmFyIGR1cmF0aW9uID0gTWF0aC5hYnModG90YWxWZWxvY2l0eSAvIC10aGlzLl9vcHRpb25zLmRlY2VsZXJhdGlvbik7XG4gICAgcmV0dXJuIHZlbG9jaXR5Lm1hcChmdW5jdGlvbiAodikge1xuICAgICAgcmV0dXJuIHYgLyAyICogZHVyYXRpb247XG4gICAgfSk7XG4gIH07XG4gIF9fcHJvdG8uc3RvcEFuaW1hdGlvbiA9IGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICBpZiAodGhpcy5fYW5pbWF0ZVBhcmFtKSB7XG4gICAgICB2YXIgb3JnUG9zXzEgPSB0aGlzLmF4aXNNYW5hZ2VyLmdldCgpO1xuICAgICAgdmFyIHBvcyA9IHRoaXMuYXhpc01hbmFnZXIubWFwKG9yZ1Bvc18xLCBmdW5jdGlvbiAodiwgb3B0KSB7XG4gICAgICAgIHJldHVybiBnZXRDaXJjdWxhdGVkUG9zKHYsIG9wdC5yYW5nZSwgb3B0LmNpcmN1bGFyKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKCFldmVyeShwb3MsIGZ1bmN0aW9uICh2LCBrKSB7XG4gICAgICAgIHJldHVybiBvcmdQb3NfMVtrXSA9PT0gdjtcbiAgICAgIH0pKSB7XG4gICAgICAgIHRoaXMuZXZlbnRNYW5hZ2VyLnRyaWdnZXJDaGFuZ2UocG9zLCBvcmdQb3NfMSwgb3B0aW9uLCAhIW9wdGlvbik7XG4gICAgICB9XG4gICAgICB0aGlzLl9hbmltYXRlUGFyYW0gPSBudWxsO1xuICAgICAgaWYgKHRoaXMuX3JhZikge1xuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSQxKHRoaXMuX3JhZik7XG4gICAgICB9XG4gICAgICB0aGlzLl9yYWYgPSBudWxsO1xuICAgICAgdGhpcy5ldmVudE1hbmFnZXIudHJpZ2dlckFuaW1hdGlvbkVuZCghIShvcHRpb24gPT09IG51bGwgfHwgb3B0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb24uZXZlbnQpKTtcbiAgICB9XG4gIH07XG4gIF9fcHJvdG8uZ2V0RXZlbnRJbmZvID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9hbmltYXRlUGFyYW0gJiYgdGhpcy5fYW5pbWF0ZVBhcmFtLmlucHV0ICYmIHRoaXMuX2FuaW1hdGVQYXJhbS5pbnB1dEV2ZW50KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpbnB1dDogdGhpcy5fYW5pbWF0ZVBhcmFtLmlucHV0LFxuICAgICAgICBldmVudDogdGhpcy5fYW5pbWF0ZVBhcmFtLmlucHV0RXZlbnRcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfTtcbiAgX19wcm90by5yZXN0b3JlID0gZnVuY3Rpb24gKG9wdGlvbikge1xuICAgIHZhciBwb3MgPSB0aGlzLmF4aXNNYW5hZ2VyLmdldCgpO1xuICAgIHZhciBkZXN0UG9zID0gdGhpcy5heGlzTWFuYWdlci5tYXAocG9zLCBmdW5jdGlvbiAodiwgb3B0KSB7XG4gICAgICByZXR1cm4gTWF0aC5taW4ob3B0LnJhbmdlWzFdLCBNYXRoLm1heChvcHQucmFuZ2VbMF0sIHYpKTtcbiAgICB9KTtcbiAgICB0aGlzLnN0b3BBbmltYXRpb24oKTtcbiAgICB0aGlzLmFuaW1hdGVUbyhkZXN0UG9zLCB0aGlzLmdldER1cmF0aW9uKHBvcywgZGVzdFBvcyksIG9wdGlvbik7XG4gIH07XG4gIF9fcHJvdG8uYW5pbWF0aW9uRW5kID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBiZWZvcmVQYXJhbSA9IHRoaXMuZ2V0RXZlbnRJbmZvKCk7XG4gICAgdGhpcy5fYW5pbWF0ZVBhcmFtID0gbnVsbDtcbiAgICAvLyBmb3IgQ2lyY3VsYXJcbiAgICB2YXIgY2lyY3VsYXJUYXJnZXRzID0gdGhpcy5heGlzTWFuYWdlci5maWx0ZXIodGhpcy5heGlzTWFuYWdlci5nZXQoKSwgZnVuY3Rpb24gKHYsIG9wdCkge1xuICAgICAgcmV0dXJuIGlzQ2lyY3VsYXJhYmxlKHYsIG9wdC5yYW5nZSwgb3B0LmNpcmN1bGFyKTtcbiAgICB9KTtcbiAgICBpZiAoT2JqZWN0LmtleXMoY2lyY3VsYXJUYXJnZXRzKS5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLnNldFRvKHRoaXMuYXhpc01hbmFnZXIubWFwKGNpcmN1bGFyVGFyZ2V0cywgZnVuY3Rpb24gKHYsIG9wdCkge1xuICAgICAgICByZXR1cm4gZ2V0Q2lyY3VsYXRlZFBvcyh2LCBvcHQucmFuZ2UsIG9wdC5jaXJjdWxhcik7XG4gICAgICB9KSk7XG4gICAgfVxuICAgIHRoaXMuaW50ZXJydXB0TWFuYWdlci5zZXRJbnRlcnJ1cHQoZmFsc2UpO1xuICAgIHRoaXMuZXZlbnRNYW5hZ2VyLnRyaWdnZXJBbmltYXRpb25FbmQoISFiZWZvcmVQYXJhbSk7XG4gICAgaWYgKHRoaXMuYXhpc01hbmFnZXIuaXNPdXRzaWRlKCkpIHtcbiAgICAgIHRoaXMucmVzdG9yZShiZWZvcmVQYXJhbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZmluaXNoKCEhYmVmb3JlUGFyYW0pO1xuICAgIH1cbiAgfTtcbiAgX19wcm90by5maW5pc2ggPSBmdW5jdGlvbiAoaXNUcnVzdGVkKSB7XG4gICAgdGhpcy5fYW5pbWF0ZVBhcmFtID0gbnVsbDtcbiAgICB0aGlzLmludGVycnVwdE1hbmFnZXIuc2V0SW50ZXJydXB0KGZhbHNlKTtcbiAgICB0aGlzLmV2ZW50TWFuYWdlci50cmlnZ2VyRmluaXNoKGlzVHJ1c3RlZCk7XG4gIH07XG4gIF9fcHJvdG8uZ2V0VXNlckNvbnRyb2wgPSBmdW5jdGlvbiAocGFyYW0pIHtcbiAgICB2YXIgdXNlcldpc2ggPSBwYXJhbS5zZXRUbygpO1xuICAgIHVzZXJXaXNoLmRlc3RQb3MgPSB0aGlzLmF4aXNNYW5hZ2VyLmdldCh1c2VyV2lzaC5kZXN0UG9zKTtcbiAgICB1c2VyV2lzaC5kdXJhdGlvbiA9IGNsYW1wKHVzZXJXaXNoLmR1cmF0aW9uLCB0aGlzLl9vcHRpb25zLm1pbmltdW1EdXJhdGlvbiwgdGhpcy5fb3B0aW9ucy5tYXhpbXVtRHVyYXRpb24pO1xuICAgIHJldHVybiB1c2VyV2lzaDtcbiAgfTtcbiAgX19wcm90by5hbmltYXRlVG8gPSBmdW5jdGlvbiAoZGVzdFBvcywgZHVyYXRpb24sIG9wdGlvbikge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdGhpcy5zdG9wQW5pbWF0aW9uKCk7XG4gICAgdmFyIHBhcmFtID0gdGhpcy5fY3JlYXRlQW5pbWF0aW9uUGFyYW0oZGVzdFBvcywgZHVyYXRpb24sIG9wdGlvbik7XG4gICAgdmFyIGRlcGFQb3MgPSBfX2Fzc2lnbih7fSwgcGFyYW0uZGVwYVBvcyk7XG4gICAgdmFyIHJldFRyaWdnZXIgPSB0aGlzLmV2ZW50TWFuYWdlci50cmlnZ2VyQW5pbWF0aW9uU3RhcnQocGFyYW0pO1xuICAgIC8vIHRvIGNvbnRyb2xcbiAgICB2YXIgdXNlcldpc2ggPSB0aGlzLmdldFVzZXJDb250cm9sKHBhcmFtKTtcbiAgICAvLyBZb3UgY2FuJ3Qgc3RvcCB0aGUgJ2FuaW1hdGlvblN0YXJ0JyBldmVudCB3aGVuICdjaXJjdWxhcicgaXMgdHJ1ZS5cbiAgICBpZiAoIXJldFRyaWdnZXIgJiYgdGhpcy5heGlzTWFuYWdlci5ldmVyeSh1c2VyV2lzaC5kZXN0UG9zLCBmdW5jdGlvbiAodiwgb3B0KSB7XG4gICAgICByZXR1cm4gaXNDaXJjdWxhcmFibGUodiwgb3B0LnJhbmdlLCBvcHQuY2lyY3VsYXIpO1xuICAgIH0pKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJZb3UgY2FuJ3Qgc3RvcCB0aGUgJ2FuaW1hdGlvbicgZXZlbnQgd2hlbiAnY2lyY3VsYXInIGlzIHRydWUuXCIpO1xuICAgIH1cbiAgICBpZiAocmV0VHJpZ2dlciAmJiAhZXF1YWwodXNlcldpc2guZGVzdFBvcywgZGVwYVBvcykpIHtcbiAgICAgIHZhciBpbnB1dEV2ZW50ID0gKG9wdGlvbiA9PT0gbnVsbCB8fCBvcHRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbi5ldmVudCkgfHwgbnVsbDtcbiAgICAgIHRoaXMuX2FuaW1hdGVMb29wKHtcbiAgICAgICAgZGVwYVBvczogZGVwYVBvcyxcbiAgICAgICAgZGVzdFBvczogdXNlcldpc2guZGVzdFBvcyxcbiAgICAgICAgZHVyYXRpb246IHVzZXJXaXNoLmR1cmF0aW9uLFxuICAgICAgICBkZWx0YTogdGhpcy5heGlzTWFuYWdlci5nZXREZWx0YShkZXBhUG9zLCB1c2VyV2lzaC5kZXN0UG9zKSxcbiAgICAgICAgaXNUcnVzdGVkOiAhIWlucHV0RXZlbnQsXG4gICAgICAgIGlucHV0RXZlbnQ6IGlucHV0RXZlbnQsXG4gICAgICAgIGlucHV0OiAob3B0aW9uID09PSBudWxsIHx8IG9wdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9uLmlucHV0KSB8fCBudWxsXG4gICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5hbmltYXRpb25FbmQoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgX19wcm90by5zZXRUbyA9IGZ1bmN0aW9uIChwb3MsIGR1cmF0aW9uKSB7XG4gICAgaWYgKGR1cmF0aW9uID09PSB2b2lkIDApIHtcbiAgICAgIGR1cmF0aW9uID0gMDtcbiAgICB9XG4gICAgdmFyIGF4ZXMgPSBPYmplY3Qua2V5cyhwb3MpO1xuICAgIHZhciBvcmdQb3MgPSB0aGlzLmF4aXNNYW5hZ2VyLmdldChheGVzKTtcbiAgICBpZiAoZXF1YWwocG9zLCBvcmdQb3MpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdGhpcy5pbnRlcnJ1cHRNYW5hZ2VyLnNldEludGVycnVwdCh0cnVlKTtcbiAgICB2YXIgbW92ZWRQb3MgPSBmaWx0ZXIocG9zLCBmdW5jdGlvbiAodiwgaykge1xuICAgICAgcmV0dXJuIG9yZ1Bvc1trXSAhPT0gdjtcbiAgICB9KTtcbiAgICBpZiAoIU9iamVjdC5rZXlzKG1vdmVkUG9zKS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBtb3ZlZFBvcyA9IHRoaXMuYXhpc01hbmFnZXIubWFwKG1vdmVkUG9zLCBmdW5jdGlvbiAodiwgb3B0KSB7XG4gICAgICB2YXIgcmFuZ2UgPSBvcHQucmFuZ2UsXG4gICAgICAgIGNpcmN1bGFyID0gb3B0LmNpcmN1bGFyO1xuICAgICAgaWYgKGNpcmN1bGFyICYmIChjaXJjdWxhclswXSB8fCBjaXJjdWxhclsxXSkpIHtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZ2V0SW5zaWRlUG9zaXRpb24odiwgcmFuZ2UsIGNpcmN1bGFyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoZXF1YWwobW92ZWRQb3MsIG9yZ1BvcykpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZiAoZHVyYXRpb24gPiAwKSB7XG4gICAgICB0aGlzLmFuaW1hdGVUbyhtb3ZlZFBvcywgZHVyYXRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0b3BBbmltYXRpb24oKTtcbiAgICAgIHRoaXMuZXZlbnRNYW5hZ2VyLnRyaWdnZXJDaGFuZ2UobW92ZWRQb3MpO1xuICAgICAgdGhpcy5maW5pc2goZmFsc2UpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgX19wcm90by5zZXRCeSA9IGZ1bmN0aW9uIChwb3MsIGR1cmF0aW9uKSB7XG4gICAgaWYgKGR1cmF0aW9uID09PSB2b2lkIDApIHtcbiAgICAgIGR1cmF0aW9uID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc2V0VG8obWFwKHRoaXMuYXhpc01hbmFnZXIuZ2V0KE9iamVjdC5rZXlzKHBvcykpLCBmdW5jdGlvbiAodiwgaykge1xuICAgICAgcmV0dXJuIHYgKyBwb3Nba107XG4gICAgfSksIGR1cmF0aW9uKTtcbiAgfTtcbiAgX19wcm90by5zZXRPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB0aGlzLl9vcHRpb25zID0gX19hc3NpZ24oX19hc3NpZ24oe30sIHRoaXMuX29wdGlvbnMpLCBvcHRpb25zKTtcbiAgfTtcbiAgX19wcm90by5fY3JlYXRlQW5pbWF0aW9uUGFyYW0gPSBmdW5jdGlvbiAocG9zLCBkdXJhdGlvbiwgb3B0aW9uKSB7XG4gICAgdmFyIGRlcGFQb3MgPSB0aGlzLmF4aXNNYW5hZ2VyLmdldCgpO1xuICAgIHZhciBkZXN0UG9zID0gcG9zO1xuICAgIHZhciBpbnB1dEV2ZW50ID0gKG9wdGlvbiA9PT0gbnVsbCB8fCBvcHRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbi5ldmVudCkgfHwgbnVsbDtcbiAgICByZXR1cm4ge1xuICAgICAgZGVwYVBvczogZGVwYVBvcyxcbiAgICAgIGRlc3RQb3M6IGRlc3RQb3MsXG4gICAgICBkdXJhdGlvbjogY2xhbXAoZHVyYXRpb24sIHRoaXMuX29wdGlvbnMubWluaW11bUR1cmF0aW9uLCB0aGlzLl9vcHRpb25zLm1heGltdW1EdXJhdGlvbiksXG4gICAgICBkZWx0YTogdGhpcy5heGlzTWFuYWdlci5nZXREZWx0YShkZXBhUG9zLCBkZXN0UG9zKSxcbiAgICAgIGlucHV0RXZlbnQ6IGlucHV0RXZlbnQsXG4gICAgICBpbnB1dDogKG9wdGlvbiA9PT0gbnVsbCB8fCBvcHRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbi5pbnB1dCkgfHwgbnVsbCxcbiAgICAgIGlzVHJ1c3RlZDogISFpbnB1dEV2ZW50LFxuICAgICAgZG9uZTogdGhpcy5hbmltYXRpb25FbmRcbiAgICB9O1xuICB9O1xuICBfX3Byb3RvLl9hbmltYXRlTG9vcCA9IGZ1bmN0aW9uIChwYXJhbSwgY29tcGxldGUpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIGlmIChwYXJhbS5kdXJhdGlvbikge1xuICAgICAgdGhpcy5fYW5pbWF0ZVBhcmFtID0gX19hc3NpZ24oX19hc3NpZ24oe30sIHBhcmFtKSwge1xuICAgICAgICBzdGFydFRpbWU6IG5ldyBEYXRlKCkuZ2V0VGltZSgpXG4gICAgICB9KTtcbiAgICAgIHZhciBvcmlnaW5hbEludGVuZGVkUG9zXzEgPSBtYXAocGFyYW0uZGVzdFBvcywgZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgICB9KTtcbiAgICAgIHZhciBzdGF0ZV8xID0gdGhpcy5faW5pdFN0YXRlKHRoaXMuX2FuaW1hdGVQYXJhbSk7XG4gICAgICB2YXIgbG9vcF8xID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5fcmFmID0gbnVsbDtcbiAgICAgICAgdmFyIGFuaW1hdGVQYXJhbSA9IF90aGlzLl9hbmltYXRlUGFyYW07XG4gICAgICAgIHZhciBuZXh0U3RhdGUgPSBfdGhpcy5fZ2V0TmV4dFN0YXRlKHN0YXRlXzEpO1xuICAgICAgICB2YXIgaXNDYW5jZWxlZCA9ICFfdGhpcy5ldmVudE1hbmFnZXIudHJpZ2dlckNoYW5nZShuZXh0U3RhdGUucG9zLCBzdGF0ZV8xLnBvcyk7XG4gICAgICAgIHN0YXRlXzEgPSBuZXh0U3RhdGU7XG4gICAgICAgIGlmIChuZXh0U3RhdGUuZmluaXNoZWQpIHtcbiAgICAgICAgICBhbmltYXRlUGFyYW0uZGVzdFBvcyA9IF90aGlzLl9nZXRGaW5hbFBvcyhhbmltYXRlUGFyYW0uZGVzdFBvcywgb3JpZ2luYWxJbnRlbmRlZFBvc18xKTtcbiAgICAgICAgICBpZiAoIWVxdWFsKGFuaW1hdGVQYXJhbS5kZXN0UG9zLCBfdGhpcy5heGlzTWFuYWdlci5nZXQoT2JqZWN0LmtleXMoYW5pbWF0ZVBhcmFtLmRlc3RQb3MpKSkpIHtcbiAgICAgICAgICAgIF90aGlzLmV2ZW50TWFuYWdlci50cmlnZ2VyQ2hhbmdlKGFuaW1hdGVQYXJhbS5kZXN0UG9zLCBuZXh0U3RhdGUucG9zKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29tcGxldGUoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSBpZiAoaXNDYW5jZWxlZCkge1xuICAgICAgICAgIF90aGlzLmZpbmlzaChmYWxzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3RoaXMuX3JhZiA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSQxKGxvb3BfMSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBsb29wXzEoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ldmVudE1hbmFnZXIudHJpZ2dlckNoYW5nZShwYXJhbS5kZXN0UG9zKTtcbiAgICAgIGNvbXBsZXRlKCk7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogR2V0IGVzdGltYXRlZCBmaW5hbCB2YWx1ZS5cbiAgICpcbiAgICogSWYgZGVzdFBvcyBpcyB3aXRoaW4gdGhlICdlcnJvciByYW5nZScgb2YgdGhlIG9yaWdpbmFsIGludGVuZGVkIHBvc2l0aW9uLCB0aGUgaW5pdGlhbCBpbnRlbmRlZCBwb3NpdGlvbiBpcyByZXR1cm5lZC5cbiAgICogICAtIGVnLiBvcmlnaW5hbCBpbnRlbmRlZCBwb3M6IDEwMCwgZGVzdFBvczogMTAwLjAwMDAwMDAwMDQgPT0+IHJldHVybiAxMDA7XG4gICAqIElmIGRlc3QgUG9zIGlzIG91dHNpZGUgdGhlICdyYW5nZSBvZiBlcnJvcicgY29tcGFyZWQgdG8gdGhlIG9yaWdpbmFsbHkgaW50ZW5kZWQgcG9zLCBpdCBpcyByZXR1cm5lZCByb3VuZGVkIGJhc2VkIG9uIHRoZSBvcmlnaW5hbGx5IGludGVuZGVkIHBvcy5cbiAgICogICAtIGVnLiBvcmlnaW5hbCBpbnRlbmRlZCBwb3M6IDEwMC4xMjMgZGVzdFBvczogNTAuMTIzNDUgPT4gcmV0dXJuIDUwLjEyM1xuICAgKiBAcGFyYW0gb3JpZ2luYWxJbnRlbmRlZFBvc1xuICAgKiBAcGFyYW0gZGVzdFBvc1xuICAgKi9cbiAgX19wcm90by5fZ2V0RmluYWxQb3MgPSBmdW5jdGlvbiAoZGVzdFBvcywgb3JpZ2luYWxJbnRlbmRlZFBvcykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgLy8gY29tcGFyZSBkZXN0UG9zIGFuZCBvcmlnaW5hbEludGVuZGVkUG9zXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuICAgIHZhciBFUlJPUl9MSU1JVCA9IDAuMDAwMDAxO1xuICAgIHZhciBmaW5hbFBvcyA9IG1hcChkZXN0UG9zLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgaWYgKHZhbHVlID49IG9yaWdpbmFsSW50ZW5kZWRQb3Nba2V5XSAtIEVSUk9SX0xJTUlUICYmIHZhbHVlIDw9IG9yaWdpbmFsSW50ZW5kZWRQb3Nba2V5XSArIEVSUk9SX0xJTUlUKSB7XG4gICAgICAgIC8vIEluIGVycm9yIHJhbmdlLCByZXR1cm4gb3JpZ2luYWwgaW50ZW5kZWRcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsSW50ZW5kZWRQb3Nba2V5XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE91dCBvZiBlcnJvciByYW5nZSwgcmV0dXJuIHJvdW5kZWQgcG9zLlxuICAgICAgICB2YXIgcm91bmRVbml0ID0gX3RoaXMuX2dldFJvdW5kVW5pdCh2YWx1ZSwga2V5KTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJvdW5kTnVtYmVyKHZhbHVlLCByb3VuZFVuaXQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBmaW5hbFBvcztcbiAgfTtcbiAgX19wcm90by5fZ2V0Um91bmRVbml0ID0gZnVuY3Rpb24gKHZhbCwga2V5KSB7XG4gICAgdmFyIHJvdW5kVW5pdCA9IHRoaXMuX29wdGlvbnMucm91bmQ7IC8vIG1hbnVhbCBtb2RlXG4gICAgdmFyIG1pblJvdW5kVW5pdCA9IG51bGw7IC8vIGF1dG8gbW9kZVxuICAgIC8vIGF1dG8gbW9kZVxuICAgIGlmICghcm91bmRVbml0KSB7XG4gICAgICAvLyBHZXQgbWluaW11bSByb3VuZCB1bml0XG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuYXhpc01hbmFnZXIuZ2V0QXhpc09wdGlvbnMoa2V5KTtcbiAgICAgIG1pblJvdW5kVW5pdCA9IGludmVyc2VQb3coTWF0aC5tYXgoZ2V0RGVjaW1hbFBsYWNlKG9wdGlvbnMucmFuZ2VbMF0pLCBnZXREZWNpbWFsUGxhY2Uob3B0aW9ucy5yYW5nZVsxXSksIGdldERlY2ltYWxQbGFjZSh2YWwpKSk7XG4gICAgfVxuICAgIHJldHVybiBtaW5Sb3VuZFVuaXQgfHwgcm91bmRVbml0O1xuICB9O1xuICByZXR1cm4gQW5pbWF0aW9uTWFuYWdlcjtcbn0oKTtcblxudmFyIEVhc2luZ01hbmFnZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMkMShFYXNpbmdNYW5hZ2VyLCBfc3VwZXIpO1xuICBmdW5jdGlvbiBFYXNpbmdNYW5hZ2VyKCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIF90aGlzLl91c2VEdXJhdGlvbiA9IHRydWU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIHZhciBfX3Byb3RvID0gRWFzaW5nTWFuYWdlci5wcm90b3R5cGU7XG4gIF9fcHJvdG8uaW50ZXJwb2xhdGUgPSBmdW5jdGlvbiAoZGlzcGxhY2VtZW50LCB0aHJlc2hvbGQpIHtcbiAgICB2YXIgaW5pdFNsb3BlID0gdGhpcy5fZWFzaW5nKDAuMDAwMDEpIC8gMC4wMDAwMTtcbiAgICByZXR1cm4gdGhpcy5fZWFzaW5nKGRpc3BsYWNlbWVudCAvICh0aHJlc2hvbGQgKiBpbml0U2xvcGUpKSAqIHRocmVzaG9sZDtcbiAgfTtcbiAgX19wcm90by51cGRhdGVBbmltYXRpb24gPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciBfYTtcbiAgICB2YXIgYW5pbWF0ZVBhcmFtID0gdGhpcy5fYW5pbWF0ZVBhcmFtO1xuICAgIGlmICghYW5pbWF0ZVBhcmFtKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBkaWZmVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gYW5pbWF0ZVBhcmFtLnN0YXJ0VGltZTtcbiAgICB2YXIgcG9zID0gKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kZXN0UG9zKSB8fCBhbmltYXRlUGFyYW0uZGVzdFBvcztcbiAgICB2YXIgZHVyYXRpb24gPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZHVyYXRpb24pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGFuaW1hdGVQYXJhbS5kdXJhdGlvbjtcbiAgICBpZiAoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5yZXN0YXJ0KSB8fCBkdXJhdGlvbiA8PSBkaWZmVGltZSkge1xuICAgICAgdGhpcy5zZXRUbyhwb3MsIGR1cmF0aW9uIC0gZGlmZlRpbWUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmRlc3RQb3MpIHtcbiAgICAgIHZhciBjdXJyZW50UG9zID0gdGhpcy5heGlzTWFuYWdlci5nZXQoKTtcbiAgICAgIC8vIFdoZW4gZGVzdGluYXRpb24gaXMgY2hhbmdlZCwgbmV3IGRlbHRhIHNob3VsZCBiZSBjYWxjdWxhdGVkIGFzIHJlbWFpbmluZyBwZXJjZW50LlxuICAgICAgLy8gRm9yIGV4YW1wbGUsIG1vdmluZyB4OjAsIHk6MCB0byB4OjIwMCwgeToyMDAgYW5kIGl0IGhhcyBjdXJyZW50IGVhc2luZyBwZXJjZW50IG9mIDkyJS4gY29vcmRpbmF0ZSBpcyB4OjE4NCBhbmQgeToxODRcbiAgICAgIC8vIElmIGRlc3RpbmF0aW9uIGNoYW5nZXMgdG8geDozMDAsIHk6MzAwLiB4ZGVsdGE6MjAwLCB5ZGVsdGE6MjAwIGNoYW5nZXMgdG8geGRlbHRhOjExNiwgeWRlbHRhOjExNiBhbmQgdXNlIHJlbWFpbmluZyBlYXNpbmdQZXIgYXMgMTAwJSwgbm90IDglIGFzIHByZXZpb3VzLlxuICAgICAgLy8gVGhlcmVmb3JlLCBvcmlnaW5hbCBlYXNpbmdQZXIgYnkgdGltZSBpcyBrZXB0LiBBbmQgZGl2aWRlZCBieSAoMSAtIHNlbGYuX2luaXRpYWxFYXNpbmdQZXIpIHdoaWNoIG1lYW5zIG5ldyB0b3RhbCBlYXNpbmcgcGVyY2VudC4gTGlrZSBjYWxjdWxhdGluZyA4JSBhcyAxMDAlLlxuICAgICAgdGhpcy5faW5pdGlhbEVhc2luZ1BlciA9IHRoaXMuX3ByZXZFYXNpbmdQZXI7XG4gICAgICBhbmltYXRlUGFyYW0uZGVsdGEgPSB0aGlzLmF4aXNNYW5hZ2VyLmdldERlbHRhKGN1cnJlbnRQb3MsIHBvcyk7XG4gICAgICBhbmltYXRlUGFyYW0uZGVzdFBvcyA9IHBvcztcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kdXJhdGlvbikge1xuICAgICAgdmFyIHJhdGlvID0gKGRpZmZUaW1lICsgdGhpcy5fZHVyYXRpb25PZmZzZXQpIC8gYW5pbWF0ZVBhcmFtLmR1cmF0aW9uO1xuICAgICAgLy8gVXNlIGR1cmF0aW9uT2Zmc2V0IGZvciBrZWVwaW5nIGFuaW1hdGlvbiByYXRpbyBhZnRlciBkdXJhdGlvbiBpcyBjaGFuZ2VkLlxuICAgICAgLy8gbmV3UmF0aW8gPSAoZGlmZlRpbWUgKyBuZXdEdXJhdGlvbk9mZnNldCkgLyBuZXdEdXJhdGlvbiA9IG9sZFJhdGlvXG4gICAgICAvLyBuZXdEdXJhdGlvbk9mZnNldCA9IG9sZFJhdGlvICogbmV3RHVyYXRpb24gLSBkaWZmVGltZVxuICAgICAgdGhpcy5fZHVyYXRpb25PZmZzZXQgPSByYXRpbyAqIGR1cmF0aW9uIC0gZGlmZlRpbWU7XG4gICAgICBhbmltYXRlUGFyYW0uZHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICB9XG4gIH07XG4gIF9fcHJvdG8uX2luaXRTdGF0ZSA9IGZ1bmN0aW9uIChpbmZvKSB7XG4gICAgdGhpcy5faW5pdGlhbEVhc2luZ1BlciA9IDA7XG4gICAgdGhpcy5fcHJldkVhc2luZ1BlciA9IDA7XG4gICAgdGhpcy5fZHVyYXRpb25PZmZzZXQgPSAwO1xuICAgIHJldHVybiB7XG4gICAgICBwb3M6IGluZm8uZGVwYVBvcyxcbiAgICAgIGVhc2luZ1BlcjogMCxcbiAgICAgIGZpbmlzaGVkOiBmYWxzZVxuICAgIH07XG4gIH07XG4gIF9fcHJvdG8uX2dldE5leHRTdGF0ZSA9IGZ1bmN0aW9uIChwcmV2U3RhdGUpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHZhciBhbmltYXRlUGFyYW0gPSB0aGlzLl9hbmltYXRlUGFyYW07XG4gICAgdmFyIHByZXZQb3MgPSBwcmV2U3RhdGUucG9zO1xuICAgIHZhciBkZXN0UG9zID0gYW5pbWF0ZVBhcmFtLmRlc3RQb3M7XG4gICAgdmFyIGRpcmVjdGlvbnMgPSBtYXAocHJldlBvcywgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA8PSBkZXN0UG9zW2tleV0gPyAxIDogLTE7XG4gICAgfSk7XG4gICAgdmFyIGRpZmZUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSBhbmltYXRlUGFyYW0uc3RhcnRUaW1lO1xuICAgIHZhciByYXRpbyA9IChkaWZmVGltZSArIHRoaXMuX2R1cmF0aW9uT2Zmc2V0KSAvIGFuaW1hdGVQYXJhbS5kdXJhdGlvbjtcbiAgICB2YXIgZWFzaW5nUGVyID0gdGhpcy5fZWFzaW5nKHJhdGlvKTtcbiAgICB2YXIgdG9Qb3MgPSB0aGlzLmF4aXNNYW5hZ2VyLm1hcChwcmV2UG9zLCBmdW5jdGlvbiAocG9zLCBvcHRpb25zLCBrZXkpIHtcbiAgICAgIHZhciBuZXh0UG9zID0gcmF0aW8gPj0gMSA/IGRlc3RQb3Nba2V5XSA6IHBvcyArIGFuaW1hdGVQYXJhbS5kZWx0YVtrZXldICogKGVhc2luZ1BlciAtIF90aGlzLl9wcmV2RWFzaW5nUGVyKSAvICgxIC0gX3RoaXMuX2luaXRpYWxFYXNpbmdQZXIpO1xuICAgICAgLy8gU3VidHJhY3QgZGlzdGFuY2UgZnJvbSBkaXN0YW5jZSBhbHJlYWR5IG1vdmVkLlxuICAgICAgLy8gUmVjYWxjdWxhdGUgdGhlIHJlbWFpbmluZyBkaXN0YW5jZS5cbiAgICAgIC8vIEZpeCB0aGUgYm91bmNpbmcgcGhlbm9tZW5vbiBieSBjaGFuZ2luZyB0aGUgcmFuZ2UuXG4gICAgICB2YXIgY2lyY3VsYXRlZFBvcyA9IGdldENpcmN1bGF0ZWRQb3MobmV4dFBvcywgb3B0aW9ucy5yYW5nZSwgb3B0aW9ucy5jaXJjdWxhcik7XG4gICAgICBpZiAobmV4dFBvcyAhPT0gY2lyY3VsYXRlZFBvcykge1xuICAgICAgICAvLyBjaXJjdWxhclxuICAgICAgICB2YXIgcmFuZ2VPZmZzZXQgPSBkaXJlY3Rpb25zW2tleV0gKiAob3B0aW9ucy5yYW5nZVsxXSAtIG9wdGlvbnMucmFuZ2VbMF0pO1xuICAgICAgICBkZXN0UG9zW2tleV0gLT0gcmFuZ2VPZmZzZXQ7XG4gICAgICAgIHByZXZQb3Nba2V5XSAtPSByYW5nZU9mZnNldDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjaXJjdWxhdGVkUG9zO1xuICAgIH0pO1xuICAgIHRoaXMuX3ByZXZFYXNpbmdQZXIgPSBlYXNpbmdQZXI7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvczogdG9Qb3MsXG4gICAgICBlYXNpbmdQZXI6IGVhc2luZ1BlcixcbiAgICAgIGZpbmlzaGVkOiBlYXNpbmdQZXIgPj0gMVxuICAgIH07XG4gIH07XG4gIF9fcHJvdG8uX2Vhc2luZyA9IGZ1bmN0aW9uIChwKSB7XG4gICAgcmV0dXJuIHAgPiAxID8gMSA6IHRoaXMuX29wdGlvbnMuZWFzaW5nKHApO1xuICB9O1xuICByZXR1cm4gRWFzaW5nTWFuYWdlcjtcbn0oQW5pbWF0aW9uTWFuYWdlcik7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gQXhpc09wdGlvbiBUaGUgQXhpcyBpbmZvcm1hdGlvbi4gVGhlIGtleSBvZiB0aGUgYXhpcyBzcGVjaWZpZXMgdGhlIG5hbWUgdG8gdXNlIGFzIHRoZSBsb2dpY2FsIHZpcnR1YWwgY29vcmRpbmF0ZSBzeXN0ZW0uXG4gKiBAa28g7LaVIOygleuztC4g7LaV7J2YIO2CpOuKlCDrhbzrpqzsoIHsnbgg6rCA7IOBIOyijO2RnOqzhOuhnCDsgqzsmqntlaAg7J2066aE7J2EIOyngOygle2VnOuLpC5cbiAqIEBwYXJhbSB7TnVtYmVyW119IFtyYW5nZV0gVGhlIHJhbmdlIG9mIGNvb3JkaW5hdGUgPGtvPuyijO2RnCDrspTsnIQ8L2tvPlxuICogQHBhcmFtIHtOdW1iZXJ9IFtyYW5nZVswXT0wXSBUaGUgY29vcmRpbmF0ZSBvZiB0aGUgbWluaW11bSA8a28+7LWc7IaMIOyijO2RnDwva28+XG4gKiBAcGFyYW0ge051bWJlcn0gW3JhbmdlWzFdPTBdIFRoZSBjb29yZGluYXRlIG9mIHRoZSBtYXhpbXVtIDxrbz7stZzrjIAg7KKM7ZGcPC9rbz5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbc3RhcnRQb3M9cmFuZ2VbMF1dIFRoZSBjb29yZGluYXRlcyB0byBiZSBtb3ZlZCB3aGVuIGNyZWF0aW5nIGFuIGluc3RhbmNlIDxrbz7snbjsiqTthLTsiqQg7IOd7ISx7IucIOydtOuPme2VoCDsooztkZw8L2tvPlxuICogQHBhcmFtIHtOdW1iZXJbXX0gW2JvdW5jZV0gVGhlIHNpemUgb2YgYm91bmNpbmcgYXJlYS4gVGhlIGNvb3JkaW5hdGVzIGNhbiBleGNlZWQgdGhlIGNvb3JkaW5hdGUgYXJlYSBhcyBtdWNoIGFzIHRoZSBib3VuY2luZyBhcmVhIGJhc2VkIG9uIHVzZXIgYWN0aW9uLiBJZiB0aGUgY29vcmRpbmF0ZXMgZG9lcyBub3QgZXhjZWVkIHRoZSBib3VuY2luZyBhcmVhIHdoZW4gYW4gZWxlbWVudCBpcyBkcmFnZ2VkLCB0aGUgY29vcmRpbmF0ZXMgd2hlcmUgYm91bmNpbmcgZWZmZWN0cyBhcmUgYXBwbGllZCBhcmUgcmV0dW5lZCBiYWNrIGludG8gdGhlIGNvb3JkaW5hdGUgYXJlYTxrbz7rsJTsmrTsiqQg7JiB7Jet7J2YIO2BrOq4sC4g7IKs7Jqp7J6Q7J2YIOuPmeyekeyXkCDrlLDrnbwg7KKM7ZGc6rCAIOyijO2RnCDsmIHsl63snYQg64SY7Ja0IOuwlOyatOyKpCDsmIHsl63snZgg7YGs6riw66eM7YG8IOuNlCDsnbTrj5ntlaAg7IiYIOyeiOuLpC4g7IKs7Jqp7J6Q6rCAIOuBjOyWtOuLpCDrhpPripQg64+Z7J6R7J2EIO2WiOydhCDrlYwg7KKM7ZGc6rCAIOuwlOyatOyKpCDsmIHsl63sl5Ag7J6I7Jy866m0LCDrsJTsmrTsiqQg7Zqo6rO86rCAIOyggeyaqeuQnCDsooztkZzqsIAg64uk7IucIOyijO2RnCDsmIHsl60g7JWI7Jy866GcIOuTpOyWtOyYqOuLpDwva28+XG4gKiBAcGFyYW0ge051bWJlcn0gW2JvdW5jZVswXT0wXSBUaGUgc2l6ZSBvZiBjb29yZGluYXRlIG9mIHRoZSBtaW5pbXVtIGFyZWEgPGtvPuy1nOyGjCDsooztkZwg67CU7Jq07IqkIOyYgeyXreydmCDtgazquLA8L2tvPlxuICogQHBhcmFtIHtOdW1iZXJ9IFtib3VuY2VbMV09MF0gVGhlIHNpemUgb2YgY29vcmRpbmF0ZSBvZiB0aGUgbWF4aW11bSBhcmVhIDxrbz7stZzrjIAg7KKM7ZGcIOuwlOyatOyKpCDsmIHsl63snZgg7YGs6riwPC9rbz5cbiAqIEBwYXJhbSB7Qm9vbGVhbltdfSBbY2lyY3VsYXJdIEluZGljYXRlcyB3aGV0aGVyIGEgY2lyY3VsYXIgZWxlbWVudCBpcyBhdmFpbGFibGUuIElmIGl0IGlzIHNldCB0byBcInRydWVcIiBhbmQgYW4gZWxlbWVudCBpcyBkcmFnZ2VkIG91dHNpZGUgdGhlIGNvb3JkaW5hdGUgYXJlYSwgdGhlIGVsZW1lbnQgd2lsbCBhcHBlYXIgb24gdGhlIG90aGVyIHNpZGUuPGtvPuyInO2ZmCDsl6zrtoAuICd0cnVlJ+uhnCDshKTsoJXtlZwg67Cp7Zal7J2YIOyijO2RnCDsmIHsl60g67CW7Jy866GcIOyXmOumrOuovO2KuOqwgCDsnbTrj5ntlZjrqbQg67CY64yAIOuwqe2WpeyXkOyEnCDsl5jrpqzrqLztirjqsIAg64KY7YOA64Kc64ukPC9rbz5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NpcmN1bGFyWzBdPWZhbHNlXSBJbmRpY2F0ZXMgd2hldGhlciB0byBjaXJjdWxhdGUgdG8gdGhlIGNvb3JkaW5hdGUgb2YgdGhlIG1pbmltdW0gPGtvPuy1nOyGjCDsooztkZwg67Cp7Zal7J2YIOyInO2ZmCDsl6zrtoA8L2tvPlxuICogQHBhcmFtIHtCb29sZWFufSBbY2lyY3VsYXJbMV09ZmFsc2VdIEluZGljYXRlcyB3aGV0aGVyIHRvIGNpcmN1bGF0ZSB0byB0aGUgY29vcmRpbmF0ZSBvZiB0aGUgbWF4aW11bSA8a28+7LWc64yAIOyijO2RnCDrsKntlqXsnZgg7Iic7ZmYIOyXrOu2gDwva28+XG4gKiovXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEF4ZXNPcHRpb24gVGhlIG9wdGlvbiBvYmplY3Qgb2YgdGhlIGVnLkF4ZXMgbW9kdWxlXG4gKiBAa28gZWcuQXhlcyDrqqjrk4jsnZgg7Ji17IWYIOqwneyytFxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vhc2luZz1lYXNpbmcuZWFzZU91dEN1YmljXSBUaGUgZWFzaW5nIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGFuIGFuaW1hdGlvbiA8a28+7JWg64uI66mU7J207IWY7JeQIOyggeyaqe2VoCBlYXNpbmcg7ZWo7IiYPC9rbz5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbbWF4aW11bUR1cmF0aW9uPUluZmluaXR5XSBNYXhpbXVtIGR1cmF0aW9uIG9mIHRoZSBhbmltYXRpb24gPGtvPuqwgOyGjeuPhOyXkCDsnZjtlbQg7JWg64uI66mU7J207IWY7J20IOuPmeyeke2VoCDrlYzsnZgg7LWc64yAIOyijO2RnCDsnbTrj5kg7Iuc6rCEPC9rbz5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbbWluaW11bUR1cmF0aW9uPTBdIE1pbmltdW0gZHVyYXRpb24gb2YgdGhlIGFuaW1hdGlvbiA8a28+6rCA7IaN64+E7JeQIOydmO2VtCDslaDri4jrqZTsnbTshZjsnbQg64+Z7J6R7ZWgIOuVjOydmCDstZzshowg7KKM7ZGcIOydtOuPmSDsi5zqsIQ8L2tvPlxuICogQHBhcmFtIHtOdW1iZXJ9IFtkZWNlbGVyYXRpb249MC4wMDA2XSBEZWNlbGVyYXRpb24gb2YgdGhlIGFuaW1hdGlvbiB3aGVyZSBhY2NlbGVyYXRpb24gaXMgbWFudWFsbHkgZW5hYmxlZCBieSB1c2VyLiBBIGhpZ2hlciB2YWx1ZSBpbmRpY2F0ZXMgc2hvcnRlciBydW5uaW5nIHRpbWUuIDxrbz7sgqzsmqnsnpDsnZgg64+Z7J6R7Jy866GcIOqwgOyGjeuPhOqwgCDsoIHsmqnrkJwg7JWg64uI66mU7J207IWY7J2YIOqwkOyGjeuPhC4g6rCS7J20IOuGkuydhOyImOuhnSDslaDri4jrqZTsnbTshZgg7Iuk7ZaJIOyLnOqwhOydtCDsp6fslYTsp4Tri6Q8L2tvPlxuICogQHBhcmFtIHtCb29sZWFufSBbaW50ZXJydXB0YWJsZT10cnVlXSBJbmRpY2F0ZXMgd2hldGhlciBhbiBhbmltYXRpb24gaXMgaW50ZXJydXB0aWJsZS5cbiAqIC0gdHJ1ZTogSXQgY2FuIGJlIHBhdXNlZCBvciBzdG9wcGVkIGJ5IHVzZXIgYWN0aW9uIG9yIHRoZSBBUEkuXG4gKiAtIGZhbHNlOiBJdCBjYW5ub3QgYmUgcGF1c2VkIG9yIHN0b3BwZWQgYnkgdXNlciBhY3Rpb24gb3IgdGhlIEFQSSB3aGlsZSBpdCBpcyBydW5uaW5nLlxuICogPGtvPuynhO2WiSDspJHsnbgg7JWg64uI66mU7J207IWYIOykkeyngCDqsIDriqUg7Jes67aALlxuICogLSB0cnVlOiDsgqzsmqnsnpDsnZgg64+Z7J6R7J2064KYIEFQSeuhnCDslaDri4jrqZTsnbTshZjsnYQg7KSR7KeA7ZWgIOyImCDsnojri6QuXG4gKiAtIGZhbHNlOiDslaDri4jrqZTsnbTshZjsnbQg7KeE7ZaJIOykkeydvCDrlYzripQg7IKs7Jqp7J6Q7J2YIOuPmeyekeydtOuCmCBBUEnqsIAg7KCB7Jqp65CY7KeAIOyViuuKlOuLpDwva28+XG4gKiBAcGFyYW0ge051bWJlcn0gW3JvdW5kPW51bGxdIFJvdW5kaW5nIHVuaXQuIEZvciBleGFtcGxlLCAwLjEgcm91bmRzIHRvIDAuMSBkZWNpbWFsIHBvaW50KDYuMTIzNCA9PiA2LjEpLCA1IHJvdW5kcyB0byA1ICg5MyA9PiA5NSlcbiAqIFtEZXRhaWxzXShodHRwczovL2dpdGh1Yi5jb20vbmF2ZXIvZWdqcy1heGVzL3dpa2kvcm91bmQtb3B0aW9uKTxrbz7rsJjsmKzrprwg64uo7JyELiDsmIjrpbwg65Ok7Ja0IDAuMSDsnYAg7IaM7Iir7KCQIDAuMSDquYzsp4Ag67CY7Jis66a8KDYuMTIzNCA9PiA2LjEpLCA1IOuKlCA1IOuLqOychOuhnCDrsJjsmKzrprwoOTMgPT4gOTUpLlxuICogW+yDgeyEuOuCtOyaqV0oaHR0cHM6Ly9naXRodWIuY29tL25hdmVyL2VnanMtYXhlcy93aWtpL3JvdW5kLW9wdGlvbik8L2tvPlxuICogQHBhcmFtIHtCb29sZWFufSBbbmVzdGVkPWZhbHNlXSBXaGV0aGVyIHRoZSBldmVudCBwcm9wYWdhdGVzIHRvIG90aGVyIGluc3RhbmNlcyB3aGVuIHRoZSBjb29yZGluYXRlcyByZWFjaCB0aGUgZW5kIG9mIHRoZSBtb3ZhYmxlIGFyZWEgPGtvPuyijO2RnOqwgCDsnbTrj5kg6rCA64ql7ZWcIOyYgeyXreydmCDrgZ3quYzsp4Ag64+E64us7ZaI7J2EIOuVjCDri6Trpbgg7J247Iqk7YS07Iqk65Ok66Gc7J2YIOydtOuypO2KuCDsoITtjIwg7Jes67aAPC9rbz5cbiAqKi9cbi8qKlxuICogQSBtb2R1bGUgdXNlZCB0byBjaGFuZ2UgdGhlIGluZm9ybWF0aW9uIG9mIHVzZXIgYWN0aW9uIGVudGVyZWQgYnkgdmFyaW91cyBpbnB1dCBkZXZpY2VzIHN1Y2ggYXMgdG91Y2ggc2NyZWVuIG9yIG1vdXNlIGludG8gdGhlIGxvZ2ljYWwgdmlydHVhbCBjb29yZGluYXRlcy4gWW91IGNhbiBlYXNpbHkgY3JlYXRlIGEgVUkgdGhhdCByZXNwb25kcyB0byB1c2VyIGFjdGlvbnMuXG4gKiBAa28g7YSw7LmYIOyeheugpSDsnqXsuZjrgpgg66eI7Jqw7Iqk7JmAIOqwmeydgCDri6TslpHtlZwg7J6F66ClIOyepey5mOulvCDthrXtlbQg7KCE64usIOuwm+ydgCDsgqzsmqnsnpDsnZgg64+Z7J6R7J2EIOuFvOumrOyggeyduCDqsIDsg4Eg7KKM7ZGc66GcIOuzgOqyve2VmOuKlCDrqqjrk4jsnbTri6QuIOyCrOyaqeyekCDrj5nsnpHsl5Ag67CY7J2R7ZWY64qUIFVJ66W8IOyGkOyJveqyjCDrp4zrk6TsiJgg7J6I64ukLlxuICogQGV4dGVuZHMgZWcuQ29tcG9uZW50XG4gKlxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgQXhpc09wdGlvbj59IGF4aXMgQXhpcyBpbmZvcm1hdGlvbiBtYW5hZ2VkIGJ5IGVnLkF4ZXMuIFRoZSBrZXkgb2YgdGhlIGF4aXMgc3BlY2lmaWVzIHRoZSBuYW1lIHRvIHVzZSBhcyB0aGUgbG9naWNhbCB2aXJ0dWFsIGNvb3JkaW5hdGUgc3lzdGVtLiAgPGtvPmVnLkF4ZXPqsIAg6rSA66as7ZWY64qUIOy2lSDsoJXrs7QuIOy2leydmCDtgqTripQg64W866as7KCB7J24IOqwgOyDgSDsooztkZzqs4TroZwg7IKs7Jqp7ZWgIOydtOumhOydhCDsp4DsoJXtlZzri6QuPC9rbz5cbiAqIEBwYXJhbSB7QXhlc09wdGlvbn0gW29wdGlvbnM9e31dIFRoZSBvcHRpb24gb2JqZWN0IG9mIHRoZSBlZy5BeGVzIG1vZHVsZTxrbz5lZy5BeGVzIOuqqOuTiOydmCDsmLXshZgg6rCd7LK0PC9rbz5cbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsIG51bWJlcj59IFtzdGFydFBvcz17fV0gVGhlIGNvb3JkaW5hdGVzIHRvIGJlIG1vdmVkIHdoZW4gY3JlYXRpbmcgYW4gaW5zdGFuY2UuIEl0IGlzIGFwcGxpZWQgd2l0aCBoaWdoZXIgcHJpb3JpdHkgdGhhbiBzdGFydFBvcyBvZiBheGlzT3B0aW9uLjxrbz7snbjsiqTthLTsiqQg7IOd7ISx7IucIOydtOuPme2VoCDsooztkZwsIGF4aXNPcHRpb27snZggc3RhcnRQb3Prs7Tri6Qg64aS7J2AIOyasOyEoOyInOychOuhnCDsoIHsmqnrkJzri6QuPC9rbz5cbiAqXG4gKiBAc3VwcG9ydCB7XCJpZVwiOiBcIjEwK1wiLCBcImNoXCIgOiBcImxhdGVzdFwiLCBcImZmXCIgOiBcImxhdGVzdFwiLCAgXCJzZlwiIDogXCJsYXRlc3RcIiwgXCJlZGdlXCIgOiBcImxhdGVzdFwiLCBcImlvc1wiIDogXCI3K1wiLCBcImFuXCIgOiBcIjIuMysgKGV4Y2VwdCAzLngpXCJ9XG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIC8vIDEuIEluaXRpYWxpemUgZWcuQXhlc1xuICogY29uc3QgYXhlcyA9IG5ldyBlZy5BeGVzKHtcbiAqICBzb21ldGhpbmcxOiB7XG4gKiAgICByYW5nZTogWzAsIDE1MF0sXG4gKiAgICBib3VuY2U6IDUwXG4gKiAgfSxcbiAqICBzb21ldGhpbmcyOiB7XG4gKiAgICByYW5nZTogWzAsIDIwMF0sXG4gKiAgICBib3VuY2U6IDEwMFxuICogIH0sXG4gKiAgc29tZXRoaW5nTjoge1xuICogICAgcmFuZ2U6IFsxLCAxMF0sXG4gKiAgfVxuICogfSwge1xuICogIGRlY2VsZXJhdGlvbiA6IDAuMDAyNFxuICogfSk7XG4gKlxuICogLy8gMi4gYXR0YWNoIGV2ZW50IGhhbmRsZXJcbiAqIGF4ZXMub24oe1xuICogIFwiaG9sZFwiIDogZnVuY3Rpb24oZXZ0KSB7XG4gKiAgfSxcbiAqICBcInJlbGVhc2VcIiA6IGZ1bmN0aW9uKGV2dCkge1xuICogIH0sXG4gKiAgXCJhbmltYXRpb25TdGFydFwiIDogZnVuY3Rpb24oZXZ0KSB7XG4gKiAgfSxcbiAqICBcImFuaW1hdGlvbkVuZFwiIDogZnVuY3Rpb24oZXZ0KSB7XG4gKiAgfSxcbiAqICBcImNoYW5nZVwiIDogZnVuY3Rpb24oZXZ0KSB7XG4gKiAgfVxuICogfSk7XG4gKlxuICogLy8gMy4gSW5pdGlhbGl6ZSBpbnB1dFR5cGVzXG4gKiBjb25zdCBwYW5JbnB1dEFyZWEgPSBuZXcgZWcuQXhlcy5QYW5JbnB1dChcIiNhcmVhXCIsIHtcbiAqICBzY2FsZTogWzAuNSwgMV1cbiAqIH0pO1xuICogY29uc3QgcGFuSW5wdXRIbW92ZSA9IG5ldyBlZy5BeGVzLlBhbklucHV0KFwiI2htb3ZlXCIpO1xuICogY29uc3QgcGFuSW5wdXRWbW92ZSA9IG5ldyBlZy5BeGVzLlBhbklucHV0KFwiI3Ztb3ZlXCIpO1xuICogY29uc3QgcGluY2hJbnB1dEFyZWEgPSBuZXcgZWcuQXhlcy5QaW5jaElucHV0KFwiI2FyZWFcIiwge1xuICogIHNjYWxlOiAxLjVcbiAqIH0pO1xuICpcbiAqIC8vIDQuIENvbm5lY3QgZWcuQXhlcyBhbmQgSW5wdXRUeXBlc1xuICogLy8gW1BhbklucHV0XSBXaGVuIHRoZSBtb3VzZSBvciB0b3VjaHNjcmVlbiBpcyBkb3duIGFuZCBtb3ZlZC5cbiAqIC8vIENvbm5lY3QgdGhlICdzb21ldGhpbmcyJyBheGlzIHRvIHRoZSBtb3VzZSBvciB0b3VjaHNjcmVlbiB4IHBvc2l0aW9uIGFuZFxuICogLy8gY29ubmVjdCB0aGUgJ3NvbWV0aGluZ04nIGF4aXMgdG8gdGhlIG1vdXNlIG9yIHRvdWNoc2NyZWVuIHkgcG9zaXRpb24uXG4gKiBheGVzLmNvbm5lY3QoW1wic29tZXRoaW5nMlwiLCBcInNvbWV0aGluZ05cIl0sIHBhbklucHV0QXJlYSk7IC8vIG9yIGF4ZXMuY29ubmVjdChcInNvbWV0aGluZzIgc29tZXRoaW5nTlwiLCBwYW5JbnB1dEFyZWEpO1xuICpcbiAqIC8vIENvbm5lY3Qgb25seSBvbmUgJ3NvbWV0aGluZzEnIGF4aXMgdG8gdGhlIG1vdXNlIG9yIHRvdWNoc2NyZWVuIHggcG9zaXRpb24uXG4gKiBheGVzLmNvbm5lY3QoW1wic29tZXRoaW5nMVwiXSwgcGFuSW5wdXRIbW92ZSk7IC8vIG9yIGF4ZXMuY29ubmVjdChcInNvbWV0aGluZzFcIiwgcGFuSW5wdXRIbW92ZSk7XG4gKlxuICogLy8gQ29ubmVjdCBvbmx5IG9uZSAnc29tZXRoaW5nMicgYXhpcyB0byB0aGUgbW91c2Ugb3IgdG91Y2hzY3JlZW4geSBwb3NpdGlvbi5cbiAqIGF4ZXMuY29ubmVjdChbXCJcIiwgXCJzb21ldGhpbmcyXCJdLCBwYW5JbnB1dFZtb3ZlKTsgLy8gb3IgYXhlcy5jb25uZWN0KFwiIHNvbWV0aGluZzJcIiwgcGFuSW5wdXRWbW92ZSk7XG4gKlxuICogLy8gW1BpbmNoSW5wdXRdIENvbm5lY3QgJ3NvbWV0aGluZzInIGF4aXMgd2hlbiB0d28gcG9pbnRlcnMgYXJlIG1vdmluZyB0b3dhcmQgKHpvb20taW4pIG9yIGF3YXkgZnJvbSBlYWNoIG90aGVyICh6b29tLW91dCkuXG4gKiBheGVzLmNvbm5lY3QoXCJzb21ldGhpbmcyXCIsIHBpbmNoSW5wdXRBcmVhKTtcbiAqIGBgYFxuICovXG52YXIgQXhlcyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyQxKEF4ZXMsIF9zdXBlcik7XG4gIC8qKlxuICAgKlxuICAgKi9cbiAgZnVuY3Rpb24gQXhlcyhheGlzLCBvcHRpb25zLCBzdGFydFBvcykge1xuICAgIGlmIChheGlzID09PSB2b2lkIDApIHtcbiAgICAgIGF4aXMgPSB7fTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICBpZiAoc3RhcnRQb3MgPT09IHZvaWQgMCkge1xuICAgICAgc3RhcnRQb3MgPSB7fTtcbiAgICB9XG4gICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICBfdGhpcy5heGlzID0gYXhpcztcbiAgICBfdGhpcy5faW5wdXRzID0gW107XG4gICAgX3RoaXMub3B0aW9ucyA9IF9fYXNzaWduKHtcbiAgICAgIGVhc2luZzogZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIDEgLSBNYXRoLnBvdygxIC0geCwgMyk7XG4gICAgICB9LFxuICAgICAgaW50ZXJydXB0YWJsZTogdHJ1ZSxcbiAgICAgIG1heGltdW1EdXJhdGlvbjogSW5maW5pdHksXG4gICAgICBtaW5pbXVtRHVyYXRpb246IDAsXG4gICAgICBkZWNlbGVyYXRpb246IDAuMDAwNixcbiAgICAgIHJvdW5kOiBudWxsLFxuICAgICAgbmVzdGVkOiBmYWxzZVxuICAgIH0sIG9wdGlvbnMpO1xuICAgIE9iamVjdC5rZXlzKHN0YXJ0UG9zKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIF90aGlzLmF4aXNba2V5XS5zdGFydFBvcyA9IHN0YXJ0UG9zW2tleV07XG4gICAgfSk7XG4gICAgX3RoaXMuaW50ZXJydXB0TWFuYWdlciA9IG5ldyBJbnRlcnJ1cHRNYW5hZ2VyKF90aGlzLm9wdGlvbnMpO1xuICAgIF90aGlzLmF4aXNNYW5hZ2VyID0gbmV3IEF4aXNNYW5hZ2VyKF90aGlzLmF4aXMpO1xuICAgIF90aGlzLmV2ZW50TWFuYWdlciA9IG5ldyBFdmVudE1hbmFnZXIoX3RoaXMpO1xuICAgIF90aGlzLmFuaW1hdGlvbk1hbmFnZXIgPSBuZXcgRWFzaW5nTWFuYWdlcihfdGhpcyk7XG4gICAgX3RoaXMuaW5wdXRPYnNlcnZlciA9IG5ldyBJbnB1dE9ic2VydmVyKF90aGlzKTtcbiAgICBfdGhpcy5ldmVudE1hbmFnZXIuc2V0QW5pbWF0aW9uTWFuYWdlcihfdGhpcy5hbmltYXRpb25NYW5hZ2VyKTtcbiAgICBfdGhpcy5ldmVudE1hbmFnZXIudHJpZ2dlckNoYW5nZShfdGhpcy5heGlzTWFuYWdlci5nZXQoKSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIHZhciBfX3Byb3RvID0gQXhlcy5wcm90b3R5cGU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcImhvbGRpbmdcIiwge1xuICAgIC8qKlxuICAgICAqIEBuYW1lIEF4ZXMjaG9sZGluZ1xuICAgICAqIEBkZXNjIFJldHVybnMgdHJ1ZSBpZiBhdCBsZWFzdCBvbmUgaW5wdXQgaXMgaW4gcHJvZ3Jlc3MuXG4gICAgICogQGtvIOyeheugpeydtCDtlZjrgpgg7J207IOBIOynhO2WiSDspJHsnbjsp4Ag7Jes67aA66W8IOuwmO2ZmO2VnOuLpC5cbiAgICAgKlxuICAgICAqIEByZWFkb25seVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiBjb25zdCBheGVzID0gbmV3IGVnLkF4ZXMoe1xuICAgICAqICB4OiB7XG4gICAgICogICAgcmFuZ2U6IFswLCAxMDBdLFxuICAgICAqICB9LFxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogYXhlcy5ob2xkaW5nXG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5ldmVudE1hbmFnZXIuaG9sZGluZ0NvdW50ID4gMDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgLyoqXG4gICAqIENvbm5lY3QgdGhlIGF4aXMgb2YgZWcuQXhlcyB0byB0aGUgaW5wdXRUeXBlLlxuICAgKiBAa28gZWcuQXhlc+ydmCDstpXqs7wgaW5wdXRUeXBl7J2EIOyXsOqysO2VnOuLpFxuICAgKiBAcGFyYW0geyhTdHJpbmdbXXxTdHJpbmcpfSBheGVzIFRoZSBuYW1lIG9mIHRoZSBheGlzIHRvIGFzc29jaWF0ZSB3aXRoIGlucHV0VHlwZSA8a28+aW5wdXRUeXBl6rO8IOyXsOqysO2VoCDstpXsnZgg7J2066aEPC9rbz5cbiAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0VHlwZSBUaGUgaW5wdXRUeXBlIGluc3RhbmNlIHRvIGFzc29jaWF0ZSB3aXRoIHRoZSBheGlzIG9mIGVnLkF4ZXMgPGtvPmVnLkF4ZXPsnZgg7LaV6rO8IOyXsOqysO2VoCBpbnB1dFR5cGUg7J247Iqk7YS07IqkPC9rbz5cbiAgICogQHJldHVybiB7ZWcuQXhlc30gQW4gaW5zdGFuY2Ugb2YgYSBtb2R1bGUgaXRzZWxmIDxrbz7rqqjrk4gg7J6Q7Iug7J2YIOyduOyKpO2EtOyKpDwva28+XG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IGF4ZXMgPSBuZXcgZWcuQXhlcyh7XG4gICAqICAgXCJ4XCI6IHtcbiAgICogICAgICByYW5nZTogWzAsIDEwMF1cbiAgICogICB9LFxuICAgKiAgIFwieE90aGVyXCI6IHtcbiAgICogICAgICByYW5nZTogWy0xMDAsIDEwMF1cbiAgICogICB9XG4gICAqIH0pO1xuICAgKlxuICAgKiBheGVzLmNvbm5lY3QoXCJ4XCIsIG5ldyBlZy5BeGVzLlBhbklucHV0KFwiI2FyZWExXCIpKVxuICAgKiAgICAuY29ubmVjdChcInggeE90aGVyXCIsIG5ldyBlZy5BeGVzLlBhbklucHV0KFwiI2FyZWEyXCIpKVxuICAgKiAgICAuY29ubmVjdChcIiB4T3RoZXJcIiwgbmV3IGVnLkF4ZXMuUGFuSW5wdXQoXCIjYXJlYTNcIikpXG4gICAqICAgIC5jb25uZWN0KFtcInhcIl0sIG5ldyBlZy5BeGVzLlBhbklucHV0KFwiI2FyZWE0XCIpKVxuICAgKiAgICAuY29ubmVjdChbXCJ4T3RoZXJcIiwgXCJ4XCJdLCBuZXcgZWcuQXhlcy5QYW5JbnB1dChcIiNhcmVhNVwiKSlcbiAgICogICAgLmNvbm5lY3QoW1wiXCIsIFwieE90aGVyXCJdLCBuZXcgZWcuQXhlcy5QYW5JbnB1dChcIiNhcmVhNlwiKSk7XG4gICAqIGBgYFxuICAgKi9cbiAgX19wcm90by5jb25uZWN0ID0gZnVuY3Rpb24gKGF4ZXMsIGlucHV0VHlwZSkge1xuICAgIHZhciBtYXBwZWQ7XG4gICAgaWYgKHR5cGVvZiBheGVzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBtYXBwZWQgPSBheGVzLnNwbGl0KFwiIFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWFwcGVkID0gYXhlcy5jb25jYXQoKTtcbiAgICB9XG4gICAgLy8gY2hlY2sgc2FtZSBpbnN0YW5jZVxuICAgIGlmICh+dGhpcy5faW5wdXRzLmluZGV4T2YoaW5wdXRUeXBlKSkge1xuICAgICAgdGhpcy5kaXNjb25uZWN0KGlucHV0VHlwZSk7XG4gICAgfVxuICAgIGlucHV0VHlwZS5tYXBBeGVzKG1hcHBlZCk7XG4gICAgaW5wdXRUeXBlLmNvbm5lY3QodGhpcy5pbnB1dE9ic2VydmVyKTtcbiAgICB0aGlzLl9pbnB1dHMucHVzaChpbnB1dFR5cGUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogRGlzY29ubmVjdCB0aGUgYXhpcyBvZiBlZy5BeGVzIGZyb20gdGhlIGlucHV0VHlwZS5cbiAgICogQGtvIGVnLkF4ZXPsnZgg7LaV6rO8IGlucHV0VHlwZeydmCDsl7DqsrDsnYQg64GK64qU64ukLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW2lucHV0VHlwZV0gQW4gaW5wdXRUeXBlIGluc3RhbmNlIGFzc29jaWF0ZWQgd2l0aCB0aGUgYXhpcyBvZiBlZy5BeGVzIDxrbz5lZy5BeGVz7J2YIOy2leqzvCDsl7DqsrDtlZwgaW5wdXRUeXBlIOyduOyKpO2EtOyKpDwva28+XG4gICAqIEByZXR1cm4ge2VnLkF4ZXN9IEFuIGluc3RhbmNlIG9mIGEgbW9kdWxlIGl0c2VsZiA8a28+66qo65OIIOyekOyLoOydmCDsnbjsiqTthLTsiqQ8L2tvPlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBjb25zdCBheGVzID0gbmV3IGVnLkF4ZXMoe1xuICAgKiAgIFwieFwiOiB7XG4gICAqICAgICAgcmFuZ2U6IFswLCAxMDBdXG4gICAqICAgfSxcbiAgICogICBcInhPdGhlclwiOiB7XG4gICAqICAgICAgcmFuZ2U6IFstMTAwLCAxMDBdXG4gICAqICAgfVxuICAgKiB9KTtcbiAgICpcbiAgICogY29uc3QgaW5wdXQxID0gbmV3IGVnLkF4ZXMuUGFuSW5wdXQoXCIjYXJlYTFcIik7XG4gICAqIGNvbnN0IGlucHV0MiA9IG5ldyBlZy5BeGVzLlBhbklucHV0KFwiI2FyZWEyXCIpO1xuICAgKiBjb25zdCBpbnB1dDMgPSBuZXcgZWcuQXhlcy5QYW5JbnB1dChcIiNhcmVhM1wiKTtcbiAgICpcbiAgICogYXhlcy5jb25uZWN0KFwieFwiLCBpbnB1dDEpO1xuICAgKiAgICAuY29ubmVjdChcInggeE90aGVyXCIsIGlucHV0MilcbiAgICogICAgLmNvbm5lY3QoW1wieE90aGVyXCIsIFwieFwiXSwgaW5wdXQzKTtcbiAgICpcbiAgICogYXhlcy5kaXNjb25uZWN0KGlucHV0MSk7IC8vIGRpc2Nvbm5lY3RzIGlucHV0MVxuICAgKiBheGVzLmRpc2Nvbm5lY3QoKTsgLy8gZGlzY29ubmVjdHMgYWxsIG9mIHRoZW1cbiAgICogYGBgXG4gICAqL1xuICBfX3Byb3RvLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoaW5wdXRUeXBlKSB7XG4gICAgaWYgKGlucHV0VHlwZSkge1xuICAgICAgdmFyIGluZGV4ID0gdGhpcy5faW5wdXRzLmluZGV4T2YoaW5wdXRUeXBlKTtcbiAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgIHRoaXMuX2lucHV0c1tpbmRleF0uZGlzY29ubmVjdCgpO1xuICAgICAgICB0aGlzLl9pbnB1dHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5faW5wdXRzLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgcmV0dXJuIHYuZGlzY29ubmVjdCgpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLl9pbnB1dHMgPSBbXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHBvc2l0aW9uIG9mIHRoZSBjb29yZGluYXRlcy5cbiAgICogQGtvIOyijO2RnOydmCDtmITsnqwg7JyE7LmY66W8IOuwmO2ZmO2VnOuLpFxuICAgKiBAcGFyYW0ge09iamVjdH0gW2F4ZXNdIFRoZSBuYW1lcyBvZiB0aGUgYXhpcyA8a28+7LaVIOydtOumhOuTpDwva28+XG4gICAqIEByZXR1cm4ge09iamVjdC48c3RyaW5nLCBudW1iZXI+fSBBeGlzIGNvb3JkaW5hdGUgaW5mb3JtYXRpb24gPGtvPuy2lSDsooztkZwg7KCV67O0PC9rbz5cbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogY29uc3QgYXhlcyA9IG5ldyBlZy5BeGVzKHtcbiAgICogICBcInhcIjoge1xuICAgKiAgICAgIHJhbmdlOiBbMCwgMTAwXVxuICAgKiAgIH0sXG4gICAqICAgXCJ4T3RoZXJcIjoge1xuICAgKiAgICAgIHJhbmdlOiBbLTEwMCwgMTAwXVxuICAgKiAgIH0sXG4gICAqICAgIFwiem9vbVwiOiB7XG4gICAqICAgICAgcmFuZ2U6IFs1MCwgMzBdXG4gICAqICAgfVxuICAgKiB9KTtcbiAgICpcbiAgICogYXhlcy5nZXQoKTsgLy8ge1wieFwiOiAwLCBcInhPdGhlclwiOiAtMTAwLCBcInpvb21cIjogNTB9XG4gICAqIGF4ZXMuZ2V0KFtcInhcIiwgXCJ6b29tXCJdKTsgLy8ge1wieFwiOiAwLCBcInpvb21cIjogNTB9XG4gICAqIGBgYFxuICAgKi9cbiAgX19wcm90by5nZXQgPSBmdW5jdGlvbiAoYXhlcykge1xuICAgIHJldHVybiB0aGlzLmF4aXNNYW5hZ2VyLmdldChheGVzKTtcbiAgfTtcbiAgLyoqXG4gICAqIE1vdmVzIGFuIGF4aXMgdG8gc3BlY2lmaWMgY29vcmRpbmF0ZXMuXG4gICAqIEBrbyDsooztkZzrpbwg7J2064+Z7ZWc64ukLlxuICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCBudW1iZXI+fSBwb3MgVGhlIGNvb3JkaW5hdGUgdG8gbW92ZSB0byA8a28+7J2064+Z7ZWgIOyijO2RnDwva28+XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZHVyYXRpb249MF0gRHVyYXRpb24gb2YgdGhlIGFuaW1hdGlvbiAodW5pdDogbXMpIDxrbz7slaDri4jrqZTsnbTshZgg7KeE7ZaJIOyLnOqwhCjri6jsnIQ6IG1zKTwva28+XG4gICAqIEByZXR1cm4ge2VnLkF4ZXN9IEFuIGluc3RhbmNlIG9mIGEgbW9kdWxlIGl0c2VsZiA8a28+66qo65OIIOyekOyLoOydmCDsnbjsiqTthLTsiqQ8L2tvPlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBjb25zdCBheGVzID0gbmV3IGVnLkF4ZXMoe1xuICAgKiAgIFwieFwiOiB7XG4gICAqICAgICAgcmFuZ2U6IFswLCAxMDBdXG4gICAqICAgfSxcbiAgICogICBcInhPdGhlclwiOiB7XG4gICAqICAgICAgcmFuZ2U6IFstMTAwLCAxMDBdXG4gICAqICAgfSxcbiAgICogICAgXCJ6b29tXCI6IHtcbiAgICogICAgICByYW5nZTogWzUwLCAzMF1cbiAgICogICB9XG4gICAqIH0pO1xuICAgKlxuICAgKiBheGVzLnNldFRvKHtcInhcIjogMzAsIFwiem9vbVwiOiA2MH0pO1xuICAgKiBheGVzLmdldCgpOyAvLyB7XCJ4XCI6IDMwLCBcInhPdGhlclwiOiAtMTAwLCBcInpvb21cIjogNjB9XG4gICAqXG4gICAqIGF4ZXMuc2V0VG8oe1wieFwiOiAxMDAsIFwieE90aGVyXCI6IDYwfSwgMTAwMCk7IC8vIGFuaW1hdGF0aW9uXG4gICAqXG4gICAqIC8vIGFmdGVyIDEwMDAgbXNcbiAgICogYXhlcy5nZXQoKTsgLy8ge1wieFwiOiAxMDAsIFwieE90aGVyXCI6IDYwLCBcInpvb21cIjogNjB9XG4gICAqIGBgYFxuICAgKi9cbiAgX19wcm90by5zZXRUbyA9IGZ1bmN0aW9uIChwb3MsIGR1cmF0aW9uKSB7XG4gICAgaWYgKGR1cmF0aW9uID09PSB2b2lkIDApIHtcbiAgICAgIGR1cmF0aW9uID0gMDtcbiAgICB9XG4gICAgdGhpcy5hbmltYXRpb25NYW5hZ2VyLnNldFRvKHBvcywgZHVyYXRpb24pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogTW92ZXMgYW4gYXhpcyBmcm9tIHRoZSBjdXJyZW50IGNvb3JkaW5hdGVzIHRvIHNwZWNpZmljIGNvb3JkaW5hdGVzLlxuICAgKiBAa28g7ZiE7J6sIOyijO2RnOulvCDquLDspIDsnLzroZwg7KKM7ZGc66W8IOydtOuPme2VnOuLpC5cbiAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgbnVtYmVyPn0gcG9zIFRoZSBjb29yZGluYXRlIHRvIG1vdmUgdG8gPGtvPuydtOuPme2VoCDsooztkZw8L2tvPlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2R1cmF0aW9uPTBdIER1cmF0aW9uIG9mIHRoZSBhbmltYXRpb24gKHVuaXQ6IG1zKSA8a28+7JWg64uI66mU7J207IWYIOynhO2WiSDsi5zqsIQo64uo7JyEOiBtcyk8L2tvPlxuICAgKiBAcmV0dXJuIHtlZy5BeGVzfSBBbiBpbnN0YW5jZSBvZiBhIG1vZHVsZSBpdHNlbGYgPGtvPuuqqOuTiCDsnpDsi6DsnZgg7J247Iqk7YS07IqkPC9rbz5cbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogY29uc3QgYXhlcyA9IG5ldyBlZy5BeGVzKHtcbiAgICogICBcInhcIjoge1xuICAgKiAgICAgIHJhbmdlOiBbMCwgMTAwXVxuICAgKiAgIH0sXG4gICAqICAgXCJ4T3RoZXJcIjoge1xuICAgKiAgICAgIHJhbmdlOiBbLTEwMCwgMTAwXVxuICAgKiAgIH0sXG4gICAqICAgIFwiem9vbVwiOiB7XG4gICAqICAgICAgcmFuZ2U6IFs1MCwgMzBdXG4gICAqICAgfVxuICAgKiB9KTtcbiAgICpcbiAgICogYXhlcy5zZXRCeSh7XCJ4XCI6IDMwLCBcInpvb21cIjogMTB9KTtcbiAgICogYXhlcy5nZXQoKTsgLy8ge1wieFwiOiAzMCwgXCJ4T3RoZXJcIjogLTEwMCwgXCJ6b29tXCI6IDYwfVxuICAgKlxuICAgKiBheGVzLnNldEJ5KHtcInhcIjogNzAsIFwieE90aGVyXCI6IDYwfSwgMTAwMCk7IC8vIGFuaW1hdGF0aW9uXG4gICAqXG4gICAqIC8vIGFmdGVyIDEwMDAgbXNcbiAgICogYXhlcy5nZXQoKTsgLy8ge1wieFwiOiAxMDAsIFwieE90aGVyXCI6IC00MCwgXCJ6b29tXCI6IDYwfVxuICAgKiBgYGBcbiAgICovXG4gIF9fcHJvdG8uc2V0QnkgPSBmdW5jdGlvbiAocG9zLCBkdXJhdGlvbikge1xuICAgIGlmIChkdXJhdGlvbiA9PT0gdm9pZCAwKSB7XG4gICAgICBkdXJhdGlvbiA9IDA7XG4gICAgfVxuICAgIHRoaXMuYW5pbWF0aW9uTWFuYWdlci5zZXRCeShwb3MsIGR1cmF0aW9uKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXG4gICAqIENoYW5nZSB0aGUgb3B0aW9ucyBvZiBBeGVzIGluc3RhbmNlLlxuICAgKiBAa28g7J247Iqk7YS07Iqk7J2YIOyYteyFmOydhCDrs4Dqsr3tlZzri6QuXG4gICAqIEBwYXJhbSB7QXhlc09wdGlvbn0gb3B0aW9ucyBBeGVzIG9wdGlvbnMgdG8gY2hhbmdlIDxrbz7rs4Dqsr3tlaAg7Ji17IWYIOuqqeuhnTwva28+XG4gICAqIEByZXR1cm4ge2VnLkF4ZXN9IEFuIGluc3RhbmNlIG9mIGEgbW9kdWxlIGl0c2VsZiA8a28+66qo65OIIOyekOyLoOydmCDsnbjsiqTthLTsiqQ8L2tvPlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBjb25zdCBheGVzID0gbmV3IGVnLkF4ZXMoe1xuICAgKiAgIFwieFwiOiB7XG4gICAqICAgICAgcmFuZ2U6IFswLCAxMDBdXG4gICAqICAgfSxcbiAgICogfSwge1xuICAgKiAgIHJvdW5kOiAxMCxcbiAgICogfSk7XG4gICAqXG4gICAqIGF4ZXMuc2V0VG8oe1wieFwiOiA0OH0pO1xuICAgKiBheGVzLmdldCgpOyAvLyB7XCJ4XCI6IDUwfVxuICAgKlxuICAgKiBheGVzLnNldE9wdGlvbnMoe1xuICAgKiAgIHJvdW5kOiAxLFxuICAgKiB9KTtcbiAgICpcbiAgICogYXhlcy5zZXRUbyh7XCJ4XCI6IDQ4fSk7XG4gICAqIGF4ZXMuZ2V0KCk7IC8vIHtcInhcIjogNDh9XG4gICAqIGBgYFxuICAgKi9cbiAgX19wcm90by5zZXRPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgdGhpcy5vcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgdGhpcy5hbmltYXRpb25NYW5hZ2VyLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxuICAgKiBDaGFuZ2UgdGhlIGluZm9ybWF0aW9uIG9mIGFuIGV4aXN0aW5nIGF4aXMuXG4gICAqIEBrbyDsobTsnqztlZjripQg7LaV7J2YIOygleuztOulvCDrs4Dqsr3tlZzri6QuXG4gICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsIEF4aXNPcHRpb24+fSBheGlzIEF4aXMgb3B0aW9ucyB0byBjaGFuZ2UgPGtvPuuzgOqyve2VoCDstpXsnZgg7KCV67O0PC9rbz5cbiAgICogQHJldHVybiB7ZWcuQXhlc30gQW4gaW5zdGFuY2Ugb2YgYSBtb2R1bGUgaXRzZWxmIDxrbz7rqqjrk4gg7J6Q7Iug7J2YIOyduOyKpO2EtOyKpDwva28+XG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IGF4ZXMgPSBuZXcgZWcuQXhlcyh7XG4gICAqICAgXCJ4XCI6IHtcbiAgICogICAgICByYW5nZTogWzAsIDEwMF1cbiAgICogICB9LFxuICAgKiB9KTtcbiAgICpcbiAgICogYXhlcy5zZXRUbyh7XCJ4XCI6IDE1MH0pO1xuICAgKiBheGVzLmdldCgpOyAvLyB7XCJ4XCI6IDEwMH1cbiAgICpcbiAgICogYXhlcy5zZXRBeGlzKHtcbiAgICogICBcInhcIjoge1xuICAgKiAgICAgIHJhbmdlOiBbMCwgMjAwXVxuICAgKiAgIH0sXG4gICAqIH0pO1xuICAgKlxuICAgKiBheGVzLnNldFRvKHtcInhcIjogMTUwfSk7XG4gICAqIGF4ZXMuZ2V0KCk7IC8vIHtcInhcIjogMTUwfVxuICAgKiBgYGBcbiAgICovXG4gIF9fcHJvdG8uc2V0QXhpcyA9IGZ1bmN0aW9uIChheGlzKSB7XG4gICAgdGhpcy5heGlzTWFuYWdlci5zZXRBeGlzKGF4aXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogU3RvcCBhbiBhbmltYXRpb24gaW4gcHJvZ3Jlc3MuXG4gICAqIEBrbyDsnqzsg50g7KSR7J24IOyVoOuLiOuplOydtOyFmOydhCDsoJXsp4DtlZzri6QuXG4gICAqIEByZXR1cm4ge2VnLkF4ZXN9IEFuIGluc3RhbmNlIG9mIGEgbW9kdWxlIGl0c2VsZiA8a28+66qo65OIIOyekOyLoOydmCDsnbjsiqTthLTsiqQ8L2tvPlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBjb25zdCBheGVzID0gbmV3IGVnLkF4ZXMoe1xuICAgKiAgIFwieFwiOiB7XG4gICAqICAgICAgcmFuZ2U6IFswLCAxMDBdXG4gICAqICAgfSxcbiAgICogfSk7XG4gICAqXG4gICAqIGF4ZXMuc2V0VG8oe1wieFwiOiAxMH0sIDEwMDApOyAvLyBzdGFydCBhbmltYXRhdGlvblxuICAgKlxuICAgKiAvLyBhZnRlciA1MDAgbXNcbiAgICogYXhlcy5zdG9wQW5pbWF0aW9uKCk7IC8vIHN0b3AgYW5pbWF0aW9uIGR1cmluZyBtb3ZlbWVudC5cbiAgICogYGBgXG4gICAqL1xuICBfX3Byb3RvLnN0b3BBbmltYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5hbmltYXRpb25NYW5hZ2VyLnN0b3BBbmltYXRpb24oKTtcbiAgICB0aGlzLmFuaW1hdGlvbk1hbmFnZXIuZmluaXNoKGZhbHNlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXG4gICAqIENoYW5nZSB0aGUgZGVzdGluYXRpb24gb2YgYW4gYW5pbWF0aW9uIGluIHByb2dyZXNzLlxuICAgKiBAa28g7J6s7IOdIOykkeyduCDslaDri4jrqZTsnbTshZjsnZgg66qp7KCB7KeA7JmAIOynhO2WiSDsi5zqsITsnYQg67OA6rK97ZWc64ukLlxuICAgKiBAcGFyYW0ge1VwZGF0ZUFuaW1hdGlvbk9wdGlvbn0gcG9zIFRoZSBjb29yZGluYXRlIHRvIG1vdmUgdG8gPGtvPuydtOuPme2VoCDsooztkZw8L2tvPlxuICAgKiBAcmV0dXJuIHtlZy5BeGVzfSBBbiBpbnN0YW5jZSBvZiBhIG1vZHVsZSBpdHNlbGYgPGtvPuuqqOuTiCDsnpDsi6DsnZgg7J247Iqk7YS07IqkPC9rbz5cbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogY29uc3QgYXhlcyA9IG5ldyBlZy5BeGVzKHtcbiAgICogICBcInhcIjoge1xuICAgKiAgICAgIHJhbmdlOiBbMCwgMjAwXVxuICAgKiAgIH0sXG4gICAqICAgXCJ5XCI6IHtcbiAgICogICAgICByYW5nZTogWzAsIDIwMF1cbiAgICogICB9XG4gICAqIH0pO1xuICAgKlxuICAgKiBheGVzLnNldFRvKHtcInhcIjogNTAsIFwieVwiOiA1MH0sIDEwMDApOyAvLyB0cmlnZ2VyIGFuaW1hdGlvbiBieSBzZXRUb1xuICAgKlxuICAgKiAvLyBhZnRlciA1MDAgbXNcbiAgICogYXhlcy51cGRhdGVBbmltYXRpb24oe2Rlc3RQb3M6IHtcInhcIjogMTAwLCBcInlcIjogMTAwfX0pOyAvLyBhbmltYXRpb24gd2lsbCBlbmQgYWZ0ZXIgNTAwIG1zLCBhdCB7XCJ4XCI6IDEwMCwgXCJ5XCI6IDEwMH1cbiAgICpcbiAgICogLy8gYWZ0ZXIgNTAwIG1zXG4gICAqIGF4ZXMuc2V0VG8oe1wieFwiOiA1MCwgXCJ5XCI6IDUwfSwgMTAwMCk7IC8vIHRyaWdnZXIgYW5pbWF0aW9uIGJ5IHNldFRvXG4gICAqXG4gICAqIC8vIGFmdGVyIDcwMCBtc1xuICAgKiBheGVzLnVwZGF0ZUFuaW1hdGlvbih7ZGVzdFBvczoge1wieFwiOiAxMDAsIFwieVwiOiAxMDB9LCBkdXJhdGlvbjogMTUwMCwgcmVzdGFydDogdHJ1ZX0pOyAvLyB0aGlzIHdvcmtzIHNhbWUgYXMgYXhlcy5zZXRUbyh7XCJ4XCI6IDEwMCwgXCJ5XCI6IDEwMH0sIDgwMCkgc2luY2UgcmVzdGFydCBpcyB0cnVlLlxuICAgKiBgYGBcbiAgICovXG4gIF9fcHJvdG8udXBkYXRlQW5pbWF0aW9uID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB0aGlzLmFuaW1hdGlvbk1hbmFnZXIudXBkYXRlQW5pbWF0aW9uKG9wdGlvbnMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZXJlIGlzIGEgY29vcmRpbmF0ZSBpbiB0aGUgYm91bmNlIGFyZWEgb2Yg4oCL4oCLdGhlIHRhcmdldCBheGlzLlxuICAgKiBAa28g64yA7IOBIOy2lSDspJEgYm91bmNl7JiB7Jet7JeQIOyijO2RnOqwgCDsobTsnqztlZjripTsp4Drpbwg67CY7ZmY7ZWc64ukXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbYXhlc10gVGhlIG5hbWVzIG9mIHRoZSBheGlzIDxrbz7stpUg7J2066aE65OkPC9rbz5cbiAgICogQHJldHVybiB7Qm9vbGVufSBXaGV0aGVyIHRoZSBib3VuY2UgYXJlYSBleGlzdHMuIDxrbz5ib3VuY2Ug7JiB7JetIOyhtOyerCDsl6zrtoA8L2tvPlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBjb25zdCBheGVzID0gbmV3IGVnLkF4ZXMoe1xuICAgKiAgIFwieFwiOiB7XG4gICAqICAgICAgcmFuZ2U6IFswLCAxMDBdXG4gICAqICAgfSxcbiAgICogICBcInhPdGhlclwiOiB7XG4gICAqICAgICAgcmFuZ2U6IFstMTAwLCAxMDBdXG4gICAqICAgfSxcbiAgICogICAgXCJ6b29tXCI6IHtcbiAgICogICAgICByYW5nZTogWzUwLCAzMF1cbiAgICogICB9XG4gICAqIH0pO1xuICAgKlxuICAgKiBheGVzLmlzQm91bmNlQXJlYShbXCJ4XCJdKTtcbiAgICogYXhlcy5pc0JvdW5jZUFyZWEoW1wieFwiLCBcInpvb21cIl0pO1xuICAgKiBheGVzLmlzQm91bmNlQXJlYSgpO1xuICAgKiBgYGBcbiAgICovXG4gIF9fcHJvdG8uaXNCb3VuY2VBcmVhID0gZnVuY3Rpb24gKGF4ZXMpIHtcbiAgICByZXR1cm4gdGhpcy5heGlzTWFuYWdlci5pc091dHNpZGUoYXhlcyk7XG4gIH07XG4gIC8qKlxuICAgKiBEZXN0cm95cyBwcm9wZXJ0aWVzLCBhbmQgZXZlbnRzIHVzZWQgaW4gYSBtb2R1bGUgYW5kIGRpc2Nvbm5lY3QgYWxsIGNvbm5lY3Rpb25zIHRvIGlucHV0VHlwZXMuXG4gICAqIEBrbyDrqqjrk4jsl5Ag7IKs7Jqp7ZWcIOyGjeyEsSwg7J2067Kk7Yq466W8IO2VtOygnO2VnOuLpC4g66qo65OgIGlucHV0VHlwZeqzvOydmCDsl7DqsrDsnYQg64GK64qU64ukLlxuICAgKi9cbiAgX19wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZGlzY29ubmVjdCgpO1xuICAgIHRoaXMuZXZlbnRNYW5hZ2VyLmRlc3Ryb3koKTtcbiAgfTtcbiAgLyoqXG4gICAqIEBuYW1lIFZFUlNJT05cbiAgICogQGRlc2MgVmVyc2lvbiBpbmZvIHN0cmluZ1xuICAgKiBAa28g67KE7KCE7KCV67O0IOusuOyekOyXtFxuICAgKlxuICAgKiBAY29uc3RhbnRcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogZWcuQXhlcy5WRVJTSU9OOyAgLy8gZXgpIDMuMy4zXG4gICAqIGBgYFxuICAgKi9cbiAgQXhlcy5WRVJTSU9OID0gXCIzLjkuMVwiO1xuICAvKiBlc2xpbnQtZW5hYmxlICovXG4gIC8qKlxuICAgKiBAbmFtZSBUUkFOU0ZPUk1cbiAgICogQGRlc2MgUmV0dXJucyB0aGUgdHJhbnNmb3JtIGF0dHJpYnV0ZSB3aXRoIENTUyB2ZW5kb3IgcHJlZml4ZXMuXG4gICAqIEBrbyBDU1MgdmVuZG9yIHByZWZpeGVz66W8IOu2meyduCB0cmFuc2Zvcm0g7IaN7ISx7J2EIOuwmO2ZmO2VnOuLpC5cbiAgICpcbiAgICogQGNvbnN0YW50XG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGVnLkF4ZXMuVFJBTlNGT1JNOyAvLyBcInRyYW5zZm9ybVwiIG9yIFwid2Via2l0VHJhbnNmb3JtXCJcbiAgICogYGBgXG4gICAqL1xuICBBeGVzLlRSQU5TRk9STSA9IFRSQU5TRk9STTtcbiAgLyoqXG4gICAqIEBuYW1lIERJUkVDVElPTl9OT05FXG4gICAqIEBjb25zdGFudFxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgQXhlcy5ESVJFQ1RJT05fTk9ORSA9IERJUkVDVElPTl9OT05FO1xuICAvKipcbiAgICogQG5hbWUgRElSRUNUSU9OX0xFRlRcbiAgICogQGNvbnN0YW50XG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBBeGVzLkRJUkVDVElPTl9MRUZUID0gRElSRUNUSU9OX0xFRlQ7XG4gIC8qKlxuICAgKiBAbmFtZSBESVJFQ1RJT05fUklHSFRcbiAgICogQGNvbnN0YW50XG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBBeGVzLkRJUkVDVElPTl9SSUdIVCA9IERJUkVDVElPTl9SSUdIVDtcbiAgLyoqXG4gICAqIEBuYW1lIERJUkVDVElPTl9VUFxuICAgKiBAY29uc3RhbnRcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIEF4ZXMuRElSRUNUSU9OX1VQID0gRElSRUNUSU9OX1VQO1xuICAvKipcbiAgICogQG5hbWUgRElSRUNUSU9OX0RPV05cbiAgICogQGNvbnN0YW50XG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBBeGVzLkRJUkVDVElPTl9ET1dOID0gRElSRUNUSU9OX0RPV047XG4gIC8qKlxuICAgKiBAbmFtZSBESVJFQ1RJT05fSE9SSVpPTlRBTFxuICAgKiBAY29uc3RhbnRcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIEF4ZXMuRElSRUNUSU9OX0hPUklaT05UQUwgPSBESVJFQ1RJT05fSE9SSVpPTlRBTDtcbiAgLyoqXG4gICAqIEBuYW1lIERJUkVDVElPTl9WRVJUSUNBTFxuICAgKiBAY29uc3RhbnRcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIEF4ZXMuRElSRUNUSU9OX1ZFUlRJQ0FMID0gRElSRUNUSU9OX1ZFUlRJQ0FMO1xuICAvKipcbiAgICogQG5hbWUgRElSRUNUSU9OX0FMTFxuICAgKiBAY29uc3RhbnRcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIEF4ZXMuRElSRUNUSU9OX0FMTCA9IERJUkVDVElPTl9BTEw7XG4gIF9fZGVjb3JhdGUoW0NvbXB1dGVkXSwgQXhlcy5wcm90b3R5cGUsIFwiaG9sZGluZ1wiLCBudWxsKTtcbiAgQXhlcyA9IF9fZGVjb3JhdGUoW1JlYWN0aXZlU3Vic2NyaWJlXSwgQXhlcyk7XG4gIHJldHVybiBBeGVzO1xufShDb21wb25lbnQpO1xuXG4vKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IE5BVkVSIENvcnAuXG4gKiBlZ2pzIHByb2plY3RzIGFyZSBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuLy8gZ2V0IHVzZXIncyBkaXJlY3Rpb25cbnZhciBnZXREaXJlY3Rpb25CeUFuZ2xlID0gZnVuY3Rpb24gKGFuZ2xlLCB0aHJlc2hvbGRBbmdsZSkge1xuICBpZiAodGhyZXNob2xkQW5nbGUgPCAwIHx8IHRocmVzaG9sZEFuZ2xlID4gOTApIHtcbiAgICByZXR1cm4gRElSRUNUSU9OX05PTkU7XG4gIH1cbiAgdmFyIHRvQW5nbGUgPSBNYXRoLmFicyhhbmdsZSk7XG4gIHJldHVybiB0b0FuZ2xlID4gdGhyZXNob2xkQW5nbGUgJiYgdG9BbmdsZSA8IDE4MCAtIHRocmVzaG9sZEFuZ2xlID8gRElSRUNUSU9OX1ZFUlRJQ0FMIDogRElSRUNUSU9OX0hPUklaT05UQUw7XG59O1xuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBQYW5JbnB1dE9wdGlvbiBUaGUgb3B0aW9uIG9iamVjdCBvZiB0aGUgZWcuQXhlcy5QYW5JbnB1dCBtb2R1bGUuXG4gKiBAa28gZWcuQXhlcy5QYW5JbnB1dCDrqqjrk4jsnZgg7Ji17IWYIOqwneyytFxuICogQHBhcmFtIHtTdHJpbmdbXX0gW2lucHV0VHlwZT1bXCJ0b3VjaFwiLCBcIm1vdXNlXCIsIFwicG9pbnRlclwiXV0gVHlwZXMgb2YgaW5wdXQgZGV2aWNlc1xuICogLSB0b3VjaDogVG91Y2ggc2NyZWVuXG4gKiAtIG1vdXNlOiBNb3VzZVxuICogLSBwb2ludGVyOiBNb3VzZSBhbmQgdG91Y2ggPGtvPuyeheugpSDsnqXsuZgg7KKF66WYXG4gKiAtIHRvdWNoOiDthLDsuZgg7J6F66ClIOyepey5mFxuICogLSBtb3VzZTog66eI7Jqw7IqkXG4gKiAtIHBvaW50ZXI6IOuniOyasOyKpCDrsI8g7YSw7LmYPC9rbz5cbiAqIEBwYXJhbSB7U3RyaW5nW119IFtpbnB1dEtleT1bXCJhbnlcIl1dIExpc3Qgb2Yga2V5IGNvbWJpbmF0aW9ucyB0byBhbGxvdyBpbnB1dFxuICogLSBhbnk6IGFueSBrZXlcbiAqIC0gc2hpZnQ6IHNoaWZ0IGtleVxuICogLSBjdHJsOiBjdHJsIGtleSBhbmQgcGluY2ggZ2VzdHVyZSBvbiB0aGUgdHJhY2twYWRcbiAqIC0gYWx0OiBhbHQga2V5XG4gKiAtIG1ldGE6IG1ldGEga2V5XG4gKiAtIG5vbmU6IG5vbmUgb2YgdGhlc2Uga2V5cyBhcmUgcHJlc3NlZCA8a28+7J6F66Cl7J2EIO2XiOyaqe2VoCDtgqQg7KGw7ZWpIOuqqeuhnVxuICogLSBhbnk6IOyVhOustCDtgqRcbiAqIC0gc2hpZnQ6IHNoaWZ0IO2CpFxuICogLSBjdHJsOiBjdHJsIO2CpCDrsI8g7Yq4656Z7Yyo65Oc7J2YIHBpbmNoIOygnOyKpOyzkFxuICogLSBhbHQ6IGFsdCDtgqRcbiAqIC0gbWV0YTogbWV0YSDtgqRcbiAqIC0gbm9uZTog7JWE66y0IO2CpOuPhCDriIzrpqzsp4Ag7JWK7J2AIOyDge2DnCA8L2tvPlxuICogQHBhcmFtIHtTdHJpbmdbXX0gW2lucHV0QnV0dG9uPVtcImxlZnRcIl1dIExpc3Qgb2YgYnV0dG9ucyB0byBhbGxvdyBpbnB1dFxuICogLSBsZWZ0OiBMZWZ0IG1vdXNlIGJ1dHRvbiBhbmQgbm9ybWFsIHRvdWNoXG4gKiAtIG1pZGRsZTogTW91c2Ugd2hlZWwgcHJlc3NcbiAqIC0gcmlnaHQ6IFJpZ2h0IG1vdXNlIGJ1dHRvbiA8a28+7J6F66Cl7J2EIO2XiOyaqe2VoCDrsoTtirwg66qp66GdXG4gKiAtIGxlZnQ6IOuniOyasOyKpCDsmbzsqr0g67KE7Yq8XG4gKiAtIG1pZGRsZTog66eI7Jqw7IqkIO2coCDriIzrprxcbiAqIC0gcmlnaHQ6IOuniOyasOyKpCDsmKTrpbjsqr0g67KE7Yq8IDwva28+XG4gKiBAcGFyYW0ge051bWJlcltdfSBbc2NhbGVdIENvb3JkaW5hdGUgc2NhbGUgdGhhdCBhIHVzZXIgY2FuIG1vdmU8a28+7IKs7Jqp7J6Q7J2YIOuPmeyekeycvOuhnCDsnbTrj5ntlZjripQg7KKM7ZGc7J2YIOuwsOycqDwva28+XG4gKiBAcGFyYW0ge051bWJlcn0gW3NjYWxlWzBdPTFdIGhvcml6b250YWwgYXhpcyBzY2FsZSA8a28+7IiY7Y+J7LaVIOuwsOycqDwva28+XG4gKiBAcGFyYW0ge051bWJlcn0gW3NjYWxlWzFdPTFdIHZlcnRpY2FsIGF4aXMgc2NhbGUgPGtvPuyImOyngey2lSDrsLDsnKg8L2tvPlxuICogQHBhcmFtIHtOdW1iZXJ9IFt0aHJlc2hvbGRBbmdsZT00NV0gVGhlIHRocmVzaG9sZCB2YWx1ZSB0aGF0IGRldGVybWluZXMgd2hldGhlciB1c2VyIGFjdGlvbiBpcyBob3Jpem9udGFsIG9yIHZlcnRpY2FsICgwfjkwKSA8a28+7IKs7Jqp7J6Q7J2YIOuPmeyekeydtCDqsIDroZwg67Cp7Zal7J247KeAIOyEuOuhnCDrsKntlqXsnbjsp4Ag7YyQ64uo7ZWY64qUIOq4sOykgCDqsIHrj4QoMH45MCk8L2tvPlxuICogQHBhcmFtIHtOdW1iZXJ9IFt0aHJlc2hvbGQ9MF0gTWluaW1hbCBwYW4gZGlzdGFuY2UgcmVxdWlyZWQgYmVmb3JlIHJlY29nbml6aW5nIDxrbz7sgqzsmqnsnpDsnZggUGFuIOuPmeyekeydhCDsnbjsi53tlZjquLAg7JyE7ZW07IKwIOy1nOyGjO2VnOydmCDqsbDrpqw8L2tvPlxuICogQHBhcmFtIHtCb29sZWFufSBbcHJldmVudENsaWNrT25EcmFnPWZhbHNlXSBXaGV0aGVyIHRvIGNhbmNlbCB0aGUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9FbGVtZW50L2NsaWNrX2V2ZW50IGNsaWNrfSBldmVudCB3aGVuIHRoZSB1c2VyIGZpbmlzaGVzIGRyYWdnaW5nIG1vcmUgdGhhbiAxIHBpeGVsIDxrbz7sgqzsmqnsnpDqsIAgMe2UveyFgCDsnbTsg4Eg65Oc656Y6re466W8IOuniOyzpOydhCDrlYwge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2tvL2RvY3MvV2ViL0FQSS9FbGVtZW50L2NsaWNrX2V2ZW50IGNsaWNrfSDsnbTrsqTtirgg7Leo7IaMIOyXrOu2gDwva28+XG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtwcmV2ZW50RGVmYXVsdE9uRHJhZz1mYWxzZV0gV2hldGhlciB0byB1c2UgdGhlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9rby9kb2NzL1dlYi9BUEkvRXZlbnQvcHJldmVudERlZmF1bHQgcHJldmVudERlZmF1bHR9IHdoZW4gdGhlIHVzZXIgc3RhcnRzIGRyYWdnaW5nIDxrbz7sgqzsmqnsnpDqsIAg65Oc656Y6re466W8IOyLnOyeke2VoCDrlYwge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2tvL2RvY3MvV2ViL0FQSS9FdmVudC9wcmV2ZW50RGVmYXVsdCBwcmV2ZW50RGVmYXVsdH0g7Iuk7ZaJIOyXrOu2gDwva28+XG4gKiBAcGFyYW0ge051bWJlcn0gW2lPU0VkZ2VTd2lwZVRocmVzaG9sZD0zMF0gQXJlYSAocHgpIHRoYXQgY2FuIGdvIHRvIHRoZSBuZXh0IHBhZ2Ugd2hlbiBzd2lwaW5nIHRoZSByaWdodCBlZGdlIGluIGlPUyBzYWZhcmkgPGtvPmlPUyBTYWZhcmnsl5DshJwg7Jik66W47Kq9IOyXo+yngOulvCDsiqTsmYDsnbTtlIQg7ZWY64qUIOqyveyasCDri6TsnYwg7Y6Y7J207KeA66GcIOuEmOyWtOqwiCDsiJgg7J6I64qUIOyYgeyXrShweCk8L2tvPlxuICogQHBhcmFtIHtTdHJpbmd9IFt0b3VjaEFjdGlvbj1udWxsXSBWYWx1ZSB0aGF0IG92ZXJyaWRlcyB0aGUgZWxlbWVudCdzIFwidG91Y2gtYWN0aW9uXCIgY3NzIHByb3BlcnR5LiBJZiBzZXQgdG8gbnVsbCwgaXQgaXMgYXV0b21hdGljYWxseSBzZXQgdG8gcHJldmVudCBzY3JvbGxpbmcgaW4gdGhlIGRpcmVjdGlvbiBvZiB0aGUgY29ubmVjdGVkIGF4aXMuIDxrbz7sl5jrpqzrqLztirjsnZggXCJ0b3VjaC1hY3Rpb25cIiBDU1Mg7IaN7ISx7J2EIOuNruyWtOyTsOuKlCDqsJIuIOunjOyVvSBudWxs66GcIOyEpOygleuQnCDqsr3smrAsIOyXsOqysOuQnCDstpUg67Cp7Zal7Jy866Gc7J2YIOyKpO2BrOuhpOydhCDrsKnsp4DtlZjqsozrgZQg7J6Q64+Z7Jy866GcIOyEpOygleuQnOuLpC48L2tvPlxuICoqL1xuLyoqXG4gKiBBIG1vZHVsZSB0aGF0IHBhc3NlcyB0aGUgYW1vdW50IG9mIGNoYW5nZSB0byBlZy5BeGVzIHdoZW4gdGhlIG1vdXNlIG9yIHRvdWNoc2NyZWVuIGlzIGRvd24gYW5kIG1vdmVkLiB1c2UgbGVzcyB0aGFuIHR3byBheGVzLlxuICogQGtvIOuniOyasOyKpOuCmCDthLDsuZgg7Iqk7YGs66aw7J2EIOuIhOultOqzoCDsm4Dsp4HsnbzrlYzsnZgg67OA7ZmU65+J7J2EIGVnLkF4ZXPsl5Ag7KCE64us7ZWY64qUIOuqqOuTiC4g65GQ6rCcIOydtO2VmOydmCDstpXsnYQg7IKs7Jqp7ZWc64ukLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogY29uc3QgcGFuID0gbmV3IGVnLkF4ZXMuUGFuSW5wdXQoXCIjYXJlYVwiLCB7XG4gKiAgICAgaW5wdXRUeXBlOiBbXCJ0b3VjaFwiXSxcbiAqICAgICBzY2FsZTogWzEsIDEuM10sXG4gKiB9KTtcbiAqXG4gKiAvLyBDb25uZWN0IHRoZSAnc29tZXRoaW5nMicgYXhpcyB0byB0aGUgbW91c2Ugb3IgdG91Y2hzY3JlZW4geCBwb3NpdGlvbiB3aGVuIHRoZSBtb3VzZSBvciB0b3VjaHNjcmVlbiBpcyBkb3duIGFuZCBtb3ZlZC5cbiAqIC8vIENvbm5lY3QgdGhlICdzb21ldGhpbmdOJyBheGlzIHRvIHRoZSBtb3VzZSBvciB0b3VjaHNjcmVlbiB5IHBvc2l0aW9uIHdoZW4gdGhlIG1vdXNlIG9yIHRvdWNoc2NyZWVuIGlzIGRvd24gYW5kIG1vdmVkLlxuICogYXhlcy5jb25uZWN0KFtcInNvbWV0aGluZzJcIiwgXCJzb21ldGhpbmdOXCJdLCBwYW4pOyAvLyBvciBheGVzLmNvbm5lY3QoXCJzb21ldGhpbmcyIHNvbWV0aGluZ05cIiwgcGFuKTtcbiAqXG4gKiAvLyBDb25uZWN0IG9ubHkgb25lICdzb21ldGhpbmcxJyBheGlzIHRvIHRoZSBtb3VzZSBvciB0b3VjaHNjcmVlbiB4IHBvc2l0aW9uIHdoZW4gdGhlIG1vdXNlIG9yIHRvdWNoc2NyZWVuIGlzIGRvd24gYW5kIG1vdmVkLlxuICogYXhlcy5jb25uZWN0KFtcInNvbWV0aGluZzFcIl0sIHBhbik7IC8vIG9yIGF4ZXMuY29ubmVjdChcInNvbWV0aGluZzFcIiwgcGFuKTtcbiAqXG4gKiAvLyBDb25uZWN0IG9ubHkgb25lICdzb21ldGhpbmcyJyBheGlzIHRvIHRoZSBtb3VzZSBvciB0b3VjaHNjcmVlbiB5IHBvc2l0aW9uIHdoZW4gdGhlIG1vdXNlIG9yIHRvdWNoc2NyZWVuIGlzIGRvd24gYW5kIG1vdmVkLlxuICogYXhlcy5jb25uZWN0KFtcIlwiLCBcInNvbWV0aGluZzJcIl0sIHBhbik7IC8vIG9yIGF4ZXMuY29ubmVjdChcIiBzb21ldGhpbmcyXCIsIHBhbik7XG4gKiBgYGBcbiAqIEBwYXJhbSB7U3RyaW5nfEhUTUxFbGVtZW50fFJlZjxIVE1MRWxlbWVudD58alF1ZXJ5fSBlbGVtZW50IEFuIGVsZW1lbnQgdG8gdXNlIHRoZSBlZy5BeGVzLlBhbklucHV0IG1vZHVsZSA8a28+ZWcuQXhlcy5QYW5JbnB1dCDrqqjrk4jsnYQg7IKs7Jqp7ZWgIOyXmOumrOuovO2KuDwva28+XG4gKiBAcGFyYW0ge1BhbklucHV0T3B0aW9ufSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbiBvYmplY3Qgb2YgdGhlIGVnLkF4ZXMuUGFuSW5wdXQgbW9kdWxlPGtvPmVnLkF4ZXMuUGFuSW5wdXQg66qo65OI7J2YIOyYteyFmCDqsJ3ssrQ8L2tvPlxuICovXG52YXIgUGFuSW5wdXQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICpcbiAgICovXG4gIGZ1bmN0aW9uIFBhbklucHV0KGVsLCBvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB0aGlzLmF4ZXMgPSBbXTtcbiAgICB0aGlzLmVsZW1lbnQgPSBudWxsO1xuICAgIHRoaXMuX2VuYWJsZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9hY3RpdmVFdmVudCA9IG51bGw7XG4gICAgdGhpcy5fYXRSaWdodEVkZ2UgPSBmYWxzZTtcbiAgICB0aGlzLl9yaWdodEVkZ2VUaW1lciA9IDA7XG4gICAgdGhpcy5fZHJhZ2dlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2lzT3ZlclRocmVzaG9sZCA9IGZhbHNlO1xuICAgIHRoaXMuX3ByZXZlbnRDbGlja1doZW5EcmFnZ2VkID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChfdGhpcy5fZHJhZ2dlZCkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB9XG4gICAgICBfdGhpcy5fZHJhZ2dlZCA9IGZhbHNlO1xuICAgIH07XG4gICAgdGhpcy5fdm9pZEZ1bmN0aW9uID0gZnVuY3Rpb24gKCkge307XG4gICAgdGhpcy5lbGVtZW50ID0gJCQxKGVsKTtcbiAgICB0aGlzLm9wdGlvbnMgPSBfX2Fzc2lnbih7XG4gICAgICBpbnB1dFR5cGU6IFtcInRvdWNoXCIsIFwibW91c2VcIiwgXCJwb2ludGVyXCJdLFxuICAgICAgaW5wdXRLZXk6IFtBTlldLFxuICAgICAgaW5wdXRCdXR0b246IFtNT1VTRV9MRUZUXSxcbiAgICAgIHNjYWxlOiBbMSwgMV0sXG4gICAgICB0aHJlc2hvbGRBbmdsZTogNDUsXG4gICAgICB0aHJlc2hvbGQ6IDAsXG4gICAgICBwcmV2ZW50Q2xpY2tPbkRyYWc6IGZhbHNlLFxuICAgICAgcHJldmVudERlZmF1bHRPbkRyYWc6IGZhbHNlLFxuICAgICAgaU9TRWRnZVN3aXBlVGhyZXNob2xkOiBJT1NfRURHRV9USFJFU0hPTEQsXG4gICAgICByZWxlYXNlT25TY3JvbGw6IGZhbHNlLFxuICAgICAgdG91Y2hBY3Rpb246IG51bGxcbiAgICB9LCBvcHRpb25zKTtcbiAgICB0aGlzLl9vblBhbnN0YXJ0ID0gdGhpcy5fb25QYW5zdGFydC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uUGFubW92ZSA9IHRoaXMuX29uUGFubW92ZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uUGFuZW5kID0gdGhpcy5fb25QYW5lbmQuYmluZCh0aGlzKTtcbiAgfVxuICB2YXIgX19wcm90byA9IFBhbklucHV0LnByb3RvdHlwZTtcbiAgX19wcm90by5tYXBBeGVzID0gZnVuY3Rpb24gKGF4ZXMpIHtcbiAgICB0aGlzLl9kaXJlY3Rpb24gPSBnZXREaXJlY3Rpb24oISFheGVzWzBdLCAhIWF4ZXNbMV0pO1xuICAgIHRoaXMuYXhlcyA9IGF4ZXM7XG4gIH07XG4gIF9fcHJvdG8uY29ubmVjdCA9IGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgIGlmICh0aGlzLl9hY3RpdmVFdmVudCkge1xuICAgICAgdGhpcy5fZGV0YWNoRWxlbWVudEV2ZW50KCk7XG4gICAgICB0aGlzLl9kZXRhY2hXaW5kb3dFdmVudCh0aGlzLl9hY3RpdmVFdmVudCk7XG4gICAgfVxuICAgIHRoaXMuX2F0dGFjaEVsZW1lbnRFdmVudChvYnNlcnZlcik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIF9fcHJvdG8uZGlzY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9kZXRhY2hFbGVtZW50RXZlbnQoKTtcbiAgICB0aGlzLl9kZXRhY2hXaW5kb3dFdmVudCh0aGlzLl9hY3RpdmVFdmVudCk7XG4gICAgdGhpcy5fZGlyZWN0aW9uID0gRElSRUNUSU9OX05PTkU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxuICAgKiBEZXN0cm95cyBlbGVtZW50cywgcHJvcGVydGllcywgYW5kIGV2ZW50cyB1c2VkIGluIGEgbW9kdWxlLlxuICAgKiBAa28g66qo65OI7JeQIOyCrOyaqe2VnCDsl5jrpqzrqLztirjsmYAg7IaN7ISxLCDsnbTrsqTtirjrpbwg7ZW07KCc7ZWc64ukLlxuICAgKi9cbiAgX19wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZGlzY29ubmVjdCgpO1xuICAgIHRoaXMuZWxlbWVudCA9IG51bGw7XG4gIH07XG4gIC8qKlxuICAgKiBFbmFibGVzIGlucHV0IGRldmljZXNcbiAgICogQGtvIOyeheugpSDsnqXsuZjrpbwg7IKs7Jqp7ZWgIOyImCDsnojqsowg7ZWc64ukXG4gICAqIEByZXR1cm4ge1BhbklucHV0fSBBbiBpbnN0YW5jZSBvZiBhIG1vZHVsZSBpdHNlbGYgPGtvPuuqqOuTiCDsnpDsi6DsnZgg7J247Iqk7YS07IqkPC9rbz5cbiAgICovXG4gIF9fcHJvdG8uZW5hYmxlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5fZW5hYmxlZCkge1xuICAgICAgdGhpcy5fZW5hYmxlZCA9IHRydWU7XG4gICAgICB0aGlzLl9vcmlnaW5hbENzc1Byb3BzID0gc2V0Q3NzUHJvcHModGhpcy5lbGVtZW50LCB0aGlzLm9wdGlvbnMsIHRoaXMuX2RpcmVjdGlvbik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogRGlzYWJsZXMgaW5wdXQgZGV2aWNlc1xuICAgKiBAa28g7J6F66ClIOyepey5mOulvCDsgqzsmqntlaAg7IiYIOyXhuqyjCDtlZzri6QuXG4gICAqIEByZXR1cm4ge1BhbklucHV0fSBBbiBpbnN0YW5jZSBvZiBhIG1vZHVsZSBpdHNlbGYgPGtvPuuqqOuTiCDsnpDsi6DsnZgg7J247Iqk7YS07IqkPC9rbz5cbiAgICovXG4gIF9fcHJvdG8uZGlzYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fZW5hYmxlZCkge1xuICAgICAgdGhpcy5fZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgaWYgKCFpc0Nzc1Byb3BzRnJvbUF4ZXModGhpcy5fb3JpZ2luYWxDc3NQcm9wcykpIHtcbiAgICAgICAgcmV2ZXJ0Q3NzUHJvcHModGhpcy5lbGVtZW50LCB0aGlzLl9vcmlnaW5hbENzc1Byb3BzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdG8gdXNlIGFuIGlucHV0IGRldmljZVxuICAgKiBAa28g7J6F66ClIOyepey5mCDsgqzsmqkg7Jes67aA66W8IOuwmO2ZmO2VnOuLpC5cbiAgICogQHJldHVybiB7Qm9vbGVhbn0gV2hldGhlciB0byB1c2UgYW4gaW5wdXQgZGV2aWNlIDxrbz7snoXroKXsnqXsuZgg7IKs7Jqp7Jes67aAPC9rbz5cbiAgICovXG4gIF9fcHJvdG8uaXNFbmFibGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9lbmFibGVkO1xuICB9O1xuICAvKipcbiAgICogUmVsZWFzZXMgY3VycmVudCB1c2VyIGlucHV0LlxuICAgKiBAa28g7IKs7Jqp7J6Q7J2YIOyeheugpeydhCDqsJXsoJzroZwg7KSR64uo7Iuc7YKo64ukLlxuICAgKiBAcmV0dXJuIHtQYW5JbnB1dH0gQW4gaW5zdGFuY2Ugb2YgYSBtb2R1bGUgaXRzZWxmIDxrbz7rqqjrk4gg7J6Q7Iug7J2YIOyduOyKpO2EtOyKpDwva28+XG4gICAqL1xuICBfX3Byb3RvLnJlbGVhc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFjdGl2ZUV2ZW50ID0gdGhpcy5fYWN0aXZlRXZlbnQ7XG4gICAgdmFyIHByZXZFdmVudCA9IGFjdGl2ZUV2ZW50LnByZXZFdmVudDtcbiAgICBhY3RpdmVFdmVudC5vblJlbGVhc2UoKTtcbiAgICB0aGlzLl9vYnNlcnZlci5yZWxlYXNlKHRoaXMsIHByZXZFdmVudCwgWzAsIDBdKTtcbiAgICB0aGlzLl9kZXRhY2hXaW5kb3dFdmVudChhY3RpdmVFdmVudCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIF9fcHJvdG8uX29uUGFuc3RhcnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgX2EgPSB0aGlzLm9wdGlvbnMsXG4gICAgICBpbnB1dEtleSA9IF9hLmlucHV0S2V5LFxuICAgICAgaW5wdXRCdXR0b24gPSBfYS5pbnB1dEJ1dHRvbixcbiAgICAgIHByZXZlbnREZWZhdWx0T25EcmFnID0gX2EucHJldmVudERlZmF1bHRPbkRyYWc7XG4gICAgdmFyIGFjdGl2ZUV2ZW50ID0gdGhpcy5fYWN0aXZlRXZlbnQ7XG4gICAgdmFyIHBhbkV2ZW50ID0gYWN0aXZlRXZlbnQub25FdmVudFN0YXJ0KGV2ZW50LCBpbnB1dEtleSwgaW5wdXRCdXR0b24pO1xuICAgIGlmICghcGFuRXZlbnQgfHwgIXRoaXMuX2VuYWJsZWQgfHwgYWN0aXZlRXZlbnQuZ2V0VG91Y2hlcyhldmVudCwgaW5wdXRCdXR0b24pID4gMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocGFuRXZlbnQuc3JjRXZlbnQuY2FuY2VsYWJsZSAhPT0gZmFsc2UpIHtcbiAgICAgIHZhciBlZGdlVGhyZXNob2xkID0gdGhpcy5vcHRpb25zLmlPU0VkZ2VTd2lwZVRocmVzaG9sZDtcbiAgICAgIHRoaXMuX2RyYWdnZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2lzT3ZlclRocmVzaG9sZCA9IGZhbHNlO1xuICAgICAgdGhpcy5fb2JzZXJ2ZXIuaG9sZCh0aGlzLCBwYW5FdmVudCk7XG4gICAgICB0aGlzLl9hdFJpZ2h0RWRnZSA9IElTX0lPU19TQUZBUkkgJiYgcGFuRXZlbnQuY2VudGVyLnggPiB3aW5kb3cuaW5uZXJXaWR0aCAtIGVkZ2VUaHJlc2hvbGQ7XG4gICAgICB0aGlzLl9hdHRhY2hXaW5kb3dFdmVudChhY3RpdmVFdmVudCk7XG4gICAgICBwcmV2ZW50RGVmYXVsdE9uRHJhZyAmJiBwYW5FdmVudC5zcmNFdmVudC50eXBlICE9PSBcInRvdWNoc3RhcnRcIiAmJiBwYW5FdmVudC5zcmNFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgYWN0aXZlRXZlbnQucHJldkV2ZW50ID0gcGFuRXZlbnQ7XG4gICAgfVxuICB9O1xuICBfX3Byb3RvLl9vblBhbm1vdmUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHZhciBfYSA9IHRoaXMub3B0aW9ucyxcbiAgICAgIGlPU0VkZ2VTd2lwZVRocmVzaG9sZCA9IF9hLmlPU0VkZ2VTd2lwZVRocmVzaG9sZCxcbiAgICAgIHByZXZlbnRDbGlja09uRHJhZyA9IF9hLnByZXZlbnRDbGlja09uRHJhZyxcbiAgICAgIHJlbGVhc2VPblNjcm9sbCA9IF9hLnJlbGVhc2VPblNjcm9sbCxcbiAgICAgIGlucHV0S2V5ID0gX2EuaW5wdXRLZXksXG4gICAgICBpbnB1dEJ1dHRvbiA9IF9hLmlucHV0QnV0dG9uLFxuICAgICAgdGhyZXNob2xkID0gX2EudGhyZXNob2xkLFxuICAgICAgdGhyZXNob2xkQW5nbGUgPSBfYS50aHJlc2hvbGRBbmdsZTtcbiAgICB2YXIgYWN0aXZlRXZlbnQgPSB0aGlzLl9hY3RpdmVFdmVudDtcbiAgICB2YXIgcGFuRXZlbnQgPSBhY3RpdmVFdmVudC5vbkV2ZW50TW92ZShldmVudCwgaW5wdXRLZXksIGlucHV0QnV0dG9uKTtcbiAgICB2YXIgdG91Y2hlcyA9IGFjdGl2ZUV2ZW50LmdldFRvdWNoZXMoZXZlbnQsIGlucHV0QnV0dG9uKTtcbiAgICBpZiAodG91Y2hlcyA9PT0gMCB8fCByZWxlYXNlT25TY3JvbGwgJiYgcGFuRXZlbnQgJiYgIXBhbkV2ZW50LnNyY0V2ZW50LmNhbmNlbGFibGUpIHtcbiAgICAgIHRoaXMuX29uUGFuZW5kKGV2ZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFwYW5FdmVudCB8fCAhdGhpcy5fZW5hYmxlZCB8fCB0b3VjaGVzID4gMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdXNlckRpcmVjdGlvbiA9IGdldERpcmVjdGlvbkJ5QW5nbGUocGFuRXZlbnQuYW5nbGUsIHRocmVzaG9sZEFuZ2xlKTtcbiAgICB2YXIgdXNlSG9yaXpvbnRhbCA9IHVzZURpcmVjdGlvbihESVJFQ1RJT05fSE9SSVpPTlRBTCwgdGhpcy5fZGlyZWN0aW9uLCB1c2VyRGlyZWN0aW9uKTtcbiAgICB2YXIgdXNlVmVydGljYWwgPSB1c2VEaXJlY3Rpb24oRElSRUNUSU9OX1ZFUlRJQ0FMLCB0aGlzLl9kaXJlY3Rpb24sIHVzZXJEaXJlY3Rpb24pO1xuICAgIGlmIChhY3RpdmVFdmVudC5wcmV2RXZlbnQgJiYgSVNfSU9TX1NBRkFSSSkge1xuICAgICAgdmFyIHN3aXBlTGVmdFRvUmlnaHQgPSBwYW5FdmVudC5jZW50ZXIueCA8IDA7XG4gICAgICBpZiAoc3dpcGVMZWZ0VG9SaWdodCkge1xuICAgICAgICAvLyBpT1Mgc3dpcGUgbGVmdCA9PiByaWdodFxuICAgICAgICB0aGlzLnJlbGVhc2UoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9hdFJpZ2h0RWRnZSkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fcmlnaHRFZGdlVGltZXIpO1xuICAgICAgICAvLyAtIGlzIHJpZ2h0IHRvIGxlZnRcbiAgICAgICAgdmFyIHN3aXBlUmlnaHRUb0xlZnQgPSBwYW5FdmVudC5kZWx0YVggPCAtaU9TRWRnZVN3aXBlVGhyZXNob2xkO1xuICAgICAgICBpZiAoc3dpcGVSaWdodFRvTGVmdCkge1xuICAgICAgICAgIHRoaXMuX2F0UmlnaHRFZGdlID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gaU9TIHN3aXBlIHJpZ2h0ID0+IGxlZnRcbiAgICAgICAgICB0aGlzLl9yaWdodEVkZ2VUaW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5yZWxlYXNlKCk7XG4gICAgICAgICAgfSwgMTAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB2YXIgZGlzdGFuY2UgPSB0aGlzLl9nZXREaXN0YW5jZShbcGFuRXZlbnQuZGVsdGFYLCBwYW5FdmVudC5kZWx0YVldLCBbdXNlSG9yaXpvbnRhbCwgdXNlVmVydGljYWxdKTtcbiAgICB2YXIgb2Zmc2V0ID0gdGhpcy5fZ2V0T2Zmc2V0KFtwYW5FdmVudC5vZmZzZXRYLCBwYW5FdmVudC5vZmZzZXRZXSwgW3VzZUhvcml6b250YWwsIHVzZVZlcnRpY2FsXSk7XG4gICAgdmFyIHByZXZlbnQgPSBvZmZzZXQuc29tZShmdW5jdGlvbiAodikge1xuICAgICAgcmV0dXJuIHYgIT09IDA7XG4gICAgfSk7XG4gICAgaWYgKHByZXZlbnQpIHtcbiAgICAgIGlmIChwYW5FdmVudC5zcmNFdmVudC5jYW5jZWxhYmxlICE9PSBmYWxzZSkge1xuICAgICAgICBwYW5FdmVudC5zcmNFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgICAgcGFuRXZlbnQuc3JjRXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuICAgIHBhbkV2ZW50LnByZXZlbnRTeXN0ZW1FdmVudCA9IHByZXZlbnQ7XG4gICAgaWYgKHByZXZlbnQgJiYgKHRoaXMuX2lzT3ZlclRocmVzaG9sZCB8fCBkaXN0YW5jZSA+PSB0aHJlc2hvbGQpKSB7XG4gICAgICB0aGlzLl9kcmFnZ2VkID0gcHJldmVudENsaWNrT25EcmFnO1xuICAgICAgdGhpcy5faXNPdmVyVGhyZXNob2xkID0gdHJ1ZTtcbiAgICAgIHRoaXMuX29ic2VydmVyLmNoYW5nZSh0aGlzLCBwYW5FdmVudCwgdG9BeGlzKHRoaXMuYXhlcywgb2Zmc2V0KSk7XG4gICAgfVxuICAgIGFjdGl2ZUV2ZW50LnByZXZFdmVudCA9IHBhbkV2ZW50O1xuICB9O1xuICBfX3Byb3RvLl9vblBhbmVuZCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciBpbnB1dEJ1dHRvbiA9IHRoaXMub3B0aW9ucy5pbnB1dEJ1dHRvbjtcbiAgICB2YXIgYWN0aXZlRXZlbnQgPSB0aGlzLl9hY3RpdmVFdmVudDtcbiAgICBhY3RpdmVFdmVudC5vbkV2ZW50RW5kKGV2ZW50KTtcbiAgICBpZiAoIXRoaXMuX2VuYWJsZWQgfHwgYWN0aXZlRXZlbnQuZ2V0VG91Y2hlcyhldmVudCwgaW5wdXRCdXR0b24pICE9PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2RldGFjaFdpbmRvd0V2ZW50KGFjdGl2ZUV2ZW50KTtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5fcmlnaHRFZGdlVGltZXIpO1xuICAgIHZhciBwcmV2RXZlbnQgPSBhY3RpdmVFdmVudC5wcmV2RXZlbnQ7XG4gICAgdmFyIHZlbG9jaXR5ID0gdGhpcy5faXNPdmVyVGhyZXNob2xkID8gdGhpcy5fZ2V0T2Zmc2V0KFtNYXRoLmFicyhwcmV2RXZlbnQudmVsb2NpdHlYKSAqIChwcmV2RXZlbnQub2Zmc2V0WCA8IDAgPyAtMSA6IDEpLCBNYXRoLmFicyhwcmV2RXZlbnQudmVsb2NpdHlZKSAqIChwcmV2RXZlbnQub2Zmc2V0WSA8IDAgPyAtMSA6IDEpXSwgW3VzZURpcmVjdGlvbihESVJFQ1RJT05fSE9SSVpPTlRBTCwgdGhpcy5fZGlyZWN0aW9uKSwgdXNlRGlyZWN0aW9uKERJUkVDVElPTl9WRVJUSUNBTCwgdGhpcy5fZGlyZWN0aW9uKV0pIDogWzAsIDBdO1xuICAgIGFjdGl2ZUV2ZW50Lm9uUmVsZWFzZSgpO1xuICAgIHRoaXMuX29ic2VydmVyLnJlbGVhc2UodGhpcywgcHJldkV2ZW50LCB2ZWxvY2l0eSk7XG4gIH07XG4gIF9fcHJvdG8uX2F0dGFjaFdpbmRvd0V2ZW50ID0gZnVuY3Rpb24gKGFjdGl2ZUV2ZW50KSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBhY3RpdmVFdmVudCA9PT0gbnVsbCB8fCBhY3RpdmVFdmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWN0aXZlRXZlbnQubW92ZS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIF90aGlzLl9vblBhbm1vdmUsIGdldEFkZEV2ZW50T3B0aW9ucyhldmVudCkpO1xuICAgIH0pO1xuICAgIGFjdGl2ZUV2ZW50ID09PSBudWxsIHx8IGFjdGl2ZUV2ZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhY3RpdmVFdmVudC5lbmQuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBfdGhpcy5fb25QYW5lbmQsIGdldEFkZEV2ZW50T3B0aW9ucyhldmVudCkpO1xuICAgIH0pO1xuICB9O1xuICBfX3Byb3RvLl9kZXRhY2hXaW5kb3dFdmVudCA9IGZ1bmN0aW9uIChhY3RpdmVFdmVudCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgYWN0aXZlRXZlbnQgPT09IG51bGwgfHwgYWN0aXZlRXZlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFjdGl2ZUV2ZW50Lm1vdmUuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBfdGhpcy5fb25QYW5tb3ZlKTtcbiAgICB9KTtcbiAgICBhY3RpdmVFdmVudCA9PT0gbnVsbCB8fCBhY3RpdmVFdmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWN0aXZlRXZlbnQuZW5kLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgX3RoaXMuX29uUGFuZW5kKTtcbiAgICB9KTtcbiAgfTtcbiAgX19wcm90by5fZ2V0T2Zmc2V0ID0gZnVuY3Rpb24gKHByb3BlcnRpZXMsIGRpcmVjdGlvbikge1xuICAgIHZhciBzY2FsZSA9IHRoaXMub3B0aW9ucy5zY2FsZTtcbiAgICByZXR1cm4gW2RpcmVjdGlvblswXSA/IHByb3BlcnRpZXNbMF0gKiBzY2FsZVswXSA6IDAsIGRpcmVjdGlvblsxXSA/IHByb3BlcnRpZXNbMV0gKiBzY2FsZVsxXSA6IDBdO1xuICB9O1xuICBfX3Byb3RvLl9nZXREaXN0YW5jZSA9IGZ1bmN0aW9uIChkZWx0YSwgZGlyZWN0aW9uKSB7XG4gICAgcmV0dXJuIE1hdGguc3FydChOdW1iZXIoZGlyZWN0aW9uWzBdKSAqIE1hdGgucG93KGRlbHRhWzBdLCAyKSArIE51bWJlcihkaXJlY3Rpb25bMV0pICogTWF0aC5wb3coZGVsdGFbMV0sIDIpKTtcbiAgfTtcbiAgX19wcm90by5fYXR0YWNoRWxlbWVudEV2ZW50ID0gZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB2YXIgYWN0aXZlRXZlbnQgPSBjb252ZXJ0SW5wdXRUeXBlKHRoaXMub3B0aW9ucy5pbnB1dFR5cGUpO1xuICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuICAgIGlmICghYWN0aXZlRXZlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbGVtZW50IHRvIGNvbm5lY3QgaW5wdXQgZG9lcyBub3QgZXhpc3QuXCIpO1xuICAgIH1cbiAgICB0aGlzLl9vYnNlcnZlciA9IG9ic2VydmVyO1xuICAgIHRoaXMuZW5hYmxlKCk7XG4gICAgdGhpcy5fYWN0aXZlRXZlbnQgPSBhY3RpdmVFdmVudDtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9wcmV2ZW50Q2xpY2tXaGVuRHJhZ2dlZCwgdHJ1ZSk7XG4gICAgYWN0aXZlRXZlbnQuc3RhcnQuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgX3RoaXMuX29uUGFuc3RhcnQpO1xuICAgIH0pO1xuICAgIC8vIGFkZGluZyBldmVudCBsaXN0ZW5lciB0byBlbGVtZW50IHByZXZlbnRzIGludmFsaWQgYmVoYXZpb3IgaW4gaU9TIFNhZmFyaVxuICAgIGFjdGl2ZUV2ZW50Lm1vdmUuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgX3RoaXMuX3ZvaWRGdW5jdGlvbik7XG4gICAgfSk7XG4gIH07XG4gIF9fcHJvdG8uX2RldGFjaEVsZW1lbnRFdmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHZhciBhY3RpdmVFdmVudCA9IHRoaXMuX2FjdGl2ZUV2ZW50O1xuICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9wcmV2ZW50Q2xpY2tXaGVuRHJhZ2dlZCwgdHJ1ZSk7XG4gICAgICBhY3RpdmVFdmVudCA9PT0gbnVsbCB8fCBhY3RpdmVFdmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWN0aXZlRXZlbnQuc3RhcnQuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBfdGhpcy5fb25QYW5zdGFydCk7XG4gICAgICB9KTtcbiAgICAgIGFjdGl2ZUV2ZW50ID09PSBudWxsIHx8IGFjdGl2ZUV2ZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhY3RpdmVFdmVudC5tb3ZlLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgX3RoaXMuX3ZvaWRGdW5jdGlvbik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5kaXNhYmxlKCk7XG4gICAgdGhpcy5fb2JzZXJ2ZXIgPSBudWxsO1xuICB9O1xuICByZXR1cm4gUGFuSW5wdXQ7XG59KCk7XG5cbi8qXG5Db3B5cmlnaHQgKGMpIDIwMjAtcHJlc2VudCBOQVZFUiBDb3JwLlxubmFtZTogQGVnanMvaW1yZWFkeVxubGljZW5zZTogTUlUXG5hdXRob3I6IE5BVkVSIENvcnAuXG5yZXBvc2l0b3J5OiBodHRwczovL2dpdGh1Yi5jb20vbmF2ZXIvZWdqcy1pbXJlYWR5XG52ZXJzaW9uOiAxLjMuMVxuKi9cblxuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cblxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cbnZhciBleHRlbmRTdGF0aWNzJDIgPSBmdW5jdGlvbiAoZCwgYikge1xuICBleHRlbmRTdGF0aWNzJDIgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwge1xuICAgIF9fcHJvdG9fXzogW11cbiAgfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZC5fX3Byb3RvX18gPSBiO1xuICB9IHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTtcbiAgfTtcblxuICByZXR1cm4gZXh0ZW5kU3RhdGljcyQyKGQsIGIpO1xufTtcblxuZnVuY3Rpb24gX19leHRlbmRzJDIoZCwgYikge1xuICBleHRlbmRTdGF0aWNzJDIoZCwgYik7XG5cbiAgZnVuY3Rpb24gX18oKSB7XG4gICAgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7XG4gIH1cblxuICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59XG52YXIgX19hc3NpZ24kMSA9IGZ1bmN0aW9uICgpIHtcbiAgX19hc3NpZ24kMSA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xuICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdDtcbiAgfTtcblxuICByZXR1cm4gX19hc3NpZ24kMS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbmZ1bmN0aW9uIF9fc3ByZWFkQXJyYXlzKCkge1xuICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcblxuICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspIGZvciAodmFyIGEgPSBhcmd1bWVudHNbaV0sIGogPSAwLCBqbCA9IGEubGVuZ3RoOyBqIDwgamw7IGorKywgaysrKSByW2tdID0gYVtqXTtcblxuICByZXR1cm4gcjtcbn1cblxuLypcbmVnanMtaW1yZWFkeVxuQ29weXJpZ2h0IChjKSAyMDIwLXByZXNlbnQgTkFWRVIgQ29ycC5cbk1JVCBsaWNlbnNlXG4qL1xudmFyIGlzV2luZG93ID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIjtcbnZhciB1YSA9IGlzV2luZG93ID8gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQgOiBcIlwiO1xudmFyIFNVUFBPUlRfQ09NUFVURURTVFlMRSA9IGlzV2luZG93ID8gISEoXCJnZXRDb21wdXRlZFN0eWxlXCIgaW4gd2luZG93KSA6IGZhbHNlO1xudmFyIElTX0lFID0gL01TSUV8VHJpZGVudHxXaW5kb3dzIFBob25lfEVkZ2UvLnRlc3QodWEpO1xudmFyIFNVUFBPUlRfQURERVZFTlRMSVNURU5FUiA9IGlzV2luZG93ID8gISEoXCJhZGRFdmVudExpc3RlbmVyXCIgaW4gZG9jdW1lbnQpIDogZmFsc2U7XG52YXIgV0lEVEggPSBcIndpZHRoXCI7XG52YXIgSEVJR0hUID0gXCJoZWlnaHRcIjtcblxuZnVuY3Rpb24gZ2V0QXR0cmlidXRlKGVsLCBuYW1lKSB7XG4gIHJldHVybiBlbC5nZXRBdHRyaWJ1dGUobmFtZSkgfHwgXCJcIjtcbn1cbmZ1bmN0aW9uIHRvQXJyYXkkMShhcnIpIHtcbiAgcmV0dXJuIFtdLnNsaWNlLmNhbGwoYXJyKTtcbn1cbmZ1bmN0aW9uIGhhc1NpemVBdHRyaWJ1dGUodGFyZ2V0LCBwcmVmaXgpIHtcbiAgaWYgKHByZWZpeCA9PT0gdm9pZCAwKSB7XG4gICAgcHJlZml4ID0gXCJkYXRhLVwiO1xuICB9XG5cbiAgcmV0dXJuICEhdGFyZ2V0LmdldEF0dHJpYnV0ZShwcmVmaXggKyBcIndpZHRoXCIpO1xufVxuZnVuY3Rpb24gaGFzTG9hZGluZ0F0dHJpYnV0ZSh0YXJnZXQsIHByZWZpeCkge1xuICBpZiAocHJlZml4ID09PSB2b2lkIDApIHtcbiAgICBwcmVmaXggPSBcImRhdGEtXCI7XG4gIH1cblxuICByZXR1cm4gXCJsb2FkaW5nXCIgaW4gdGFyZ2V0ICYmIHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJsb2FkaW5nXCIpID09PSBcImxhenlcIiB8fCAhIXRhcmdldC5nZXRBdHRyaWJ1dGUocHJlZml4ICsgXCJsYXp5XCIpO1xufVxuZnVuY3Rpb24gaGFzU2tpcEF0dHJpYnV0ZSh0YXJnZXQsIHByZWZpeCkge1xuICBpZiAocHJlZml4ID09PSB2b2lkIDApIHtcbiAgICBwcmVmaXggPSBcImRhdGEtXCI7XG4gIH1cblxuICByZXR1cm4gISF0YXJnZXQuZ2V0QXR0cmlidXRlKHByZWZpeCArIFwic2tpcFwiKTtcbn1cbmZ1bmN0aW9uIGFkZEV2ZW50KGVsZW1lbnQsIHR5cGUsIGhhbmRsZXIpIHtcbiAgaWYgKFNVUFBPUlRfQURERVZFTlRMSVNURU5FUikge1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XG4gIH0gZWxzZSBpZiAoZWxlbWVudC5hdHRhY2hFdmVudCkge1xuICAgIGVsZW1lbnQuYXR0YWNoRXZlbnQoXCJvblwiICsgdHlwZSwgaGFuZGxlcik7XG4gIH0gZWxzZSB7XG4gICAgZWxlbWVudFtcIm9uXCIgKyB0eXBlXSA9IGhhbmRsZXI7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlbW92ZUV2ZW50KGVsZW1lbnQsIHR5cGUsIGhhbmRsZXIpIHtcbiAgaWYgKGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XG4gIH0gZWxzZSBpZiAoZWxlbWVudC5kZXRhY2hFdmVudCkge1xuICAgIGVsZW1lbnQuZGV0YWNoRXZlbnQoXCJvblwiICsgdHlwZSwgaGFuZGxlcik7XG4gIH0gZWxzZSB7XG4gICAgZWxlbWVudFtcIm9uXCIgKyB0eXBlXSA9IG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIGlubmVyV2lkdGgoZWwpIHtcbiAgcmV0dXJuIGdldFNpemUoZWwsIFwiV2lkdGhcIik7XG59XG5mdW5jdGlvbiBpbm5lckhlaWdodChlbCkge1xuICByZXR1cm4gZ2V0U2l6ZShlbCwgXCJIZWlnaHRcIik7XG59XG5mdW5jdGlvbiBnZXRTdHlsZXMoZWwpIHtcbiAgcmV0dXJuIChTVVBQT1JUX0NPTVBVVEVEU1RZTEUgPyB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCkgOiBlbC5jdXJyZW50U3R5bGUpIHx8IHt9O1xufVxuXG5mdW5jdGlvbiBnZXRTaXplKGVsLCBuYW1lKSB7XG4gIHZhciBzaXplID0gZWxbXCJjbGllbnRcIiArIG5hbWVdIHx8IGVsW1wib2Zmc2V0XCIgKyBuYW1lXTtcbiAgcmV0dXJuIHBhcnNlRmxvYXQoc2l6ZSB8fCBnZXRTdHlsZXMoZWwpW25hbWUudG9Mb3dlckNhc2UoKV0pIHx8IDA7XG59XG5cbmZ1bmN0aW9uIGdldENvbnRlbnRFbGVtZW50cyhlbGVtZW50LCB0YWdzLCBwcmVmaXgpIHtcbiAgdmFyIHNraXBFbGVtZW50cyA9IHRvQXJyYXkkMShlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoX19zcHJlYWRBcnJheXMoW1wiW1wiICsgcHJlZml4ICsgXCJza2lwXSBbXCIgKyBwcmVmaXggKyBcIndpZHRoXVwiXSwgdGFncy5tYXAoZnVuY3Rpb24gKHRhZykge1xuICAgIHJldHVybiBbXCJbXCIgKyBwcmVmaXggKyBcInNraXBdIFwiICsgdGFnLCB0YWcgKyBcIltcIiArIHByZWZpeCArIFwic2tpcF1cIiwgXCJbXCIgKyBwcmVmaXggKyBcIndpZHRoXSBcIiArIHRhZ10uam9pbihcIiwgXCIpO1xuICB9KSkuam9pbihcIiwgXCIpKSk7XG4gIHJldHVybiB0b0FycmF5JDEoZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiW1wiICsgcHJlZml4ICsgXCJ3aWR0aF0sIFwiICsgdGFncy5qb2luKFwiLCBcIikpKS5maWx0ZXIoZnVuY3Rpb24gKGVsKSB7XG4gICAgcmV0dXJuIHNraXBFbGVtZW50cy5pbmRleE9mKGVsKSA9PT0gLTE7XG4gIH0pO1xufVxuXG4vKlxuZWdqcy1pbXJlYWR5XG5Db3B5cmlnaHQgKGMpIDIwMjAtcHJlc2VudCBOQVZFUiBDb3JwLlxuTUlUIGxpY2Vuc2VcbiovXG52YXIgZWxlbWVudHMgPSBbXTtcbmZ1bmN0aW9uIGFkZEF1dG9TaXplcihlbGVtZW50LCBwcmVmaXgpIHtcbiAgIWVsZW1lbnRzLmxlbmd0aCAmJiBhZGRFdmVudCh3aW5kb3csIFwicmVzaXplXCIsIHJlc2l6ZUFsbEF1dG9TaXplcnMpO1xuICBlbGVtZW50Ll9fUFJFRklYX18gPSBwcmVmaXg7XG4gIGVsZW1lbnRzLnB1c2goZWxlbWVudCk7XG4gIHJlc2l6ZShlbGVtZW50KTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUF1dG9TaXplcihlbGVtZW50LCBwcmVmaXgpIHtcbiAgdmFyIGluZGV4ID0gZWxlbWVudHMuaW5kZXhPZihlbGVtZW50KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGZpeGVkID0gZ2V0QXR0cmlidXRlKGVsZW1lbnQsIHByZWZpeCArIFwiZml4ZWRcIik7XG4gIGRlbGV0ZSBlbGVtZW50Ll9fUFJFRklYX187XG4gIGVsZW1lbnQuc3R5bGVbZml4ZWQgPT09IEhFSUdIVCA/IFdJRFRIIDogSEVJR0hUXSA9IFwiXCI7XG4gIGVsZW1lbnRzLnNwbGljZShpbmRleCwgMSk7XG4gICFlbGVtZW50cy5sZW5ndGggJiYgcmVtb3ZlRXZlbnQod2luZG93LCBcInJlc2l6ZVwiLCByZXNpemVBbGxBdXRvU2l6ZXJzKTtcbn1cblxuZnVuY3Rpb24gcmVzaXplKGVsZW1lbnQsIHByZWZpeCkge1xuICBpZiAocHJlZml4ID09PSB2b2lkIDApIHtcbiAgICBwcmVmaXggPSBcImRhdGEtXCI7XG4gIH1cblxuICB2YXIgZWxlbWVudFByZWZpeCA9IGVsZW1lbnQuX19QUkVGSVhfXyB8fCBwcmVmaXg7XG4gIHZhciBkYXRhV2lkdGggPSBwYXJzZUludChnZXRBdHRyaWJ1dGUoZWxlbWVudCwgXCJcIiArIGVsZW1lbnRQcmVmaXggKyBXSURUSCksIDEwKSB8fCAwO1xuICB2YXIgZGF0YUhlaWdodCA9IHBhcnNlSW50KGdldEF0dHJpYnV0ZShlbGVtZW50LCBcIlwiICsgZWxlbWVudFByZWZpeCArIEhFSUdIVCksIDEwKSB8fCAwO1xuICB2YXIgZml4ZWQgPSBnZXRBdHRyaWJ1dGUoZWxlbWVudCwgZWxlbWVudFByZWZpeCArIFwiZml4ZWRcIik7XG5cbiAgaWYgKGZpeGVkID09PSBIRUlHSFQpIHtcbiAgICB2YXIgc2l6ZSA9IGlubmVySGVpZ2h0KGVsZW1lbnQpIHx8IGRhdGFIZWlnaHQ7XG4gICAgZWxlbWVudC5zdHlsZVtXSURUSF0gPSBkYXRhV2lkdGggLyBkYXRhSGVpZ2h0ICogc2l6ZSArIFwicHhcIjtcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2l6ZSA9IGlubmVyV2lkdGgoZWxlbWVudCkgfHwgZGF0YVdpZHRoO1xuICAgIGVsZW1lbnQuc3R5bGVbSEVJR0hUXSA9IGRhdGFIZWlnaHQgLyBkYXRhV2lkdGggKiBzaXplICsgXCJweFwiO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc2l6ZUFsbEF1dG9TaXplcnMoKSB7XG4gIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICByZXNpemUoZWxlbWVudCk7XG4gIH0pO1xufVxuXG52YXIgTG9hZGVyID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzJDIoTG9hZGVyLCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIExvYWRlcihlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy5pc1JlYWR5ID0gZmFsc2U7XG4gICAgX3RoaXMuaXNQcmVSZWFkeSA9IGZhbHNlO1xuICAgIF90aGlzLmhhc0RhdGFTaXplID0gZmFsc2U7XG4gICAgX3RoaXMuaGFzTG9hZGluZyA9IGZhbHNlO1xuICAgIF90aGlzLmlzU2tpcCA9IGZhbHNlO1xuXG4gICAgX3RoaXMub25DaGVjayA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBfdGhpcy5jbGVhcigpO1xuXG4gICAgICBpZiAoZSAmJiBlLnR5cGUgPT09IFwiZXJyb3JcIikge1xuICAgICAgICBfdGhpcy5vbkVycm9yKF90aGlzLmVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoX3RoaXMuaGFzTG9hZGluZyAmJiBfdGhpcy5jaGVja0VsZW1lbnQoKSkge1xuICAgICAgICAvLyBJJ20gbm90IHJlYWR5XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gSSdtIHByZS1yZWFkeSBhbmQgcmVhZHkhXG5cblxuICAgICAgdmFyIHdpdGhQcmVSZWFkeSA9ICFfdGhpcy5oYXNEYXRhU2l6ZSAmJiAhX3RoaXMuaGFzTG9hZGluZztcblxuICAgICAgX3RoaXMub25SZWFkeSh3aXRoUHJlUmVhZHkpO1xuICAgIH07XG5cbiAgICBfdGhpcy5vcHRpb25zID0gX19hc3NpZ24kMSh7XG4gICAgICBwcmVmaXg6IFwiZGF0YS1cIlxuICAgIH0sIG9wdGlvbnMpO1xuICAgIF90aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHZhciBwcmVmaXggPSBfdGhpcy5vcHRpb25zLnByZWZpeDtcbiAgICBfdGhpcy5oYXNEYXRhU2l6ZSA9IGhhc1NpemVBdHRyaWJ1dGUoZWxlbWVudCwgcHJlZml4KTtcbiAgICBfdGhpcy5pc1NraXAgPSBoYXNTa2lwQXR0cmlidXRlKGVsZW1lbnQsIHByZWZpeCk7XG4gICAgX3RoaXMuaGFzTG9hZGluZyA9IGhhc0xvYWRpbmdBdHRyaWJ1dGUoZWxlbWVudCwgcHJlZml4KTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX19wcm90byA9IExvYWRlci5wcm90b3R5cGU7XG5cbiAgX19wcm90by5jaGVjayA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5pc1NraXAgfHwgIXRoaXMuY2hlY2tFbGVtZW50KCkpIHtcbiAgICAgIC8vIEknbSBSZWFkeVxuICAgICAgdGhpcy5vbkFscmVhZHlSZWFkeSh0cnVlKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5oYXNEYXRhU2l6ZSkge1xuICAgICAgYWRkQXV0b1NpemVyKHRoaXMuZWxlbWVudCwgdGhpcy5vcHRpb25zLnByZWZpeCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaGFzRGF0YVNpemUgfHwgdGhpcy5oYXNMb2FkaW5nKSB7XG4gICAgICAvLyBJJ20gUHJlIFJlYWR5XG4gICAgICB0aGlzLm9uQWxyZWFkeVByZVJlYWR5KCk7XG4gICAgfSAvLyBXYXRpIFByZSBSZWFkeSwgUmVhZHlcblxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgX19wcm90by5hZGRFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuICAgIHRoaXMuY29uc3RydWN0b3IuRVZFTlRTLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIGFkZEV2ZW50KGVsZW1lbnQsIG5hbWUsIF90aGlzLm9uQ2hlY2spO1xuICAgIH0pO1xuICB9O1xuXG4gIF9fcHJvdG8uY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuICAgIHRoaXMuY29uc3RydWN0b3IuRVZFTlRTLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHJlbW92ZUV2ZW50KGVsZW1lbnQsIG5hbWUsIF90aGlzLm9uQ2hlY2spO1xuICAgIH0pO1xuICAgIHRoaXMucmVtb3ZlQXV0b1NpemVyKCk7XG4gIH07XG5cbiAgX19wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuY2xlYXIoKTtcbiAgICB0aGlzLm9mZigpO1xuICB9O1xuXG4gIF9fcHJvdG8ucmVtb3ZlQXV0b1NpemVyID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmhhc0RhdGFTaXplKSB7XG4gICAgICAvLyBJJ20gYWxyZWFkeSByZWFkeS5cbiAgICAgIHZhciBwcmVmaXggPSB0aGlzLm9wdGlvbnMucHJlZml4O1xuICAgICAgcmVtb3ZlQXV0b1NpemVyKHRoaXMuZWxlbWVudCwgcHJlZml4KTtcbiAgICB9XG4gIH07XG5cbiAgX19wcm90by5vbkVycm9yID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIHRoaXMudHJpZ2dlcihcImVycm9yXCIsIHtcbiAgICAgIGVsZW1lbnQ6IHRoaXMuZWxlbWVudCxcbiAgICAgIHRhcmdldDogdGFyZ2V0XG4gICAgfSk7XG4gIH07XG5cbiAgX19wcm90by5vblByZVJlYWR5ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmlzUHJlUmVhZHkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmlzUHJlUmVhZHkgPSB0cnVlO1xuICAgIHRoaXMudHJpZ2dlcihcInByZVJlYWR5XCIsIHtcbiAgICAgIGVsZW1lbnQ6IHRoaXMuZWxlbWVudCxcbiAgICAgIGhhc0xvYWRpbmc6IHRoaXMuaGFzTG9hZGluZyxcbiAgICAgIGlzU2tpcDogdGhpcy5pc1NraXBcbiAgICB9KTtcbiAgfTtcblxuICBfX3Byb3RvLm9uUmVhZHkgPSBmdW5jdGlvbiAod2l0aFByZVJlYWR5KSB7XG4gICAgaWYgKHRoaXMuaXNSZWFkeSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdpdGhQcmVSZWFkeSA9ICF0aGlzLmlzUHJlUmVhZHkgJiYgd2l0aFByZVJlYWR5O1xuXG4gICAgaWYgKHdpdGhQcmVSZWFkeSkge1xuICAgICAgdGhpcy5pc1ByZVJlYWR5ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB0aGlzLnJlbW92ZUF1dG9TaXplcigpO1xuICAgIHRoaXMuaXNSZWFkeSA9IHRydWU7XG4gICAgdGhpcy50cmlnZ2VyKFwicmVhZHlcIiwge1xuICAgICAgZWxlbWVudDogdGhpcy5lbGVtZW50LFxuICAgICAgd2l0aFByZVJlYWR5OiB3aXRoUHJlUmVhZHksXG4gICAgICBoYXNMb2FkaW5nOiB0aGlzLmhhc0xvYWRpbmcsXG4gICAgICBpc1NraXA6IHRoaXMuaXNTa2lwXG4gICAgfSk7XG4gIH07XG5cbiAgX19wcm90by5vbkFscmVhZHlFcnJvciA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5vbkVycm9yKHRhcmdldCk7XG4gICAgfSk7XG4gIH07XG5cbiAgX19wcm90by5vbkFscmVhZHlQcmVSZWFkeSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5vblByZVJlYWR5KCk7XG4gICAgfSk7XG4gIH07XG5cbiAgX19wcm90by5vbkFscmVhZHlSZWFkeSA9IGZ1bmN0aW9uICh3aXRoUHJlUmVhZHkpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5vblJlYWR5KHdpdGhQcmVSZWFkeSk7XG4gICAgfSk7XG4gIH07XG5cbiAgTG9hZGVyLkVWRU5UUyA9IFtdO1xuICByZXR1cm4gTG9hZGVyO1xufShDb21wb25lbnQpO1xuXG52YXIgRWxlbWVudExvYWRlciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyQyKEVsZW1lbnRMb2FkZXIsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gRWxlbWVudExvYWRlcigpIHtcbiAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX19wcm90byA9IEVsZW1lbnRMb2FkZXIucHJvdG90eXBlO1xuXG4gIF9fcHJvdG8uc2V0SGFzTG9hZGluZyA9IGZ1bmN0aW9uIChoYXNMb2FkaW5nKSB7XG4gICAgdGhpcy5oYXNMb2FkaW5nID0gaGFzTG9hZGluZztcbiAgfTtcblxuICBfX3Byb3RvLmNoZWNrID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmlzU2tpcCkge1xuICAgICAgLy8gSSdtIFJlYWR5XG4gICAgICB0aGlzLm9uQWxyZWFkeVJlYWR5KHRydWUpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmhhc0RhdGFTaXplKSB7XG4gICAgICBhZGRBdXRvU2l6ZXIodGhpcy5lbGVtZW50LCB0aGlzLm9wdGlvbnMucHJlZml4KTtcbiAgICAgIHRoaXMub25BbHJlYWR5UHJlUmVhZHkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaGFzIG5vdCBkYXRhIHNpemVcbiAgICAgIHRoaXMudHJpZ2dlcihcInJlcXVlc3RDaGlsZHJlblwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBfX3Byb3RvLmNoZWNrRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBfX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jbGVhcigpO1xuICAgIHRoaXMudHJpZ2dlcihcInJlcXVlc3REZXN0cm95XCIpO1xuICAgIHRoaXMub2ZmKCk7XG4gIH07XG5cbiAgX19wcm90by5vbkFscmVhZHlQcmVSZWFkeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBoYXMgZGF0YSBzaXplXG4gICAgX3N1cGVyLnByb3RvdHlwZS5vbkFscmVhZHlQcmVSZWFkeS5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy50cmlnZ2VyKFwicmVxZXVzdFJlYWR5Q2hpbGRyZW5cIik7XG4gIH07XG5cbiAgRWxlbWVudExvYWRlci5FVkVOVFMgPSBbXTtcbiAgcmV0dXJuIEVsZW1lbnRMb2FkZXI7XG59KExvYWRlcik7XG5cbi8qKlxuICogQGFsaWFzIGVnLkltUmVhZHlcbiAqIEBleHRlbmRzIGVnLkNvbXBvbmVudFxuICovXG5cbnZhciBJbVJlYWR5TWFuYWdlciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyQyKEltUmVhZHlNYW5hZ2VyLCBfc3VwZXIpO1xuICAvKipcbiAgICogQHBhcmFtIC0gSW1SZWFkeSdzIG9wdGlvbnNcbiAgICovXG5cblxuICBmdW5jdGlvbiBJbVJlYWR5TWFuYWdlcihvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy5yZWFkeUNvdW50ID0gMDtcbiAgICBfdGhpcy5wcmVSZWFkeUNvdW50ID0gMDtcbiAgICBfdGhpcy50b3RhbENvdW50ID0gMDtcbiAgICBfdGhpcy50b3RhbEVycm9yQ291bnQgPSAwO1xuICAgIF90aGlzLmlzUHJlUmVhZHlPdmVyID0gdHJ1ZTtcbiAgICBfdGhpcy5lbGVtZW50SW5mb3MgPSBbXTtcbiAgICBfdGhpcy5vcHRpb25zID0gX19hc3NpZ24kMSh7XG4gICAgICBsb2FkZXJzOiB7fSxcbiAgICAgIHByZWZpeDogXCJkYXRhLVwiXG4gICAgfSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBlbGVtZW50cyBhcmUgaW4gdGhlIHJlYWR5IHN0YXRlLlxuICAgKiBAa28g7JeY66as66i87Yq46rCAIOykgOu5hCDsg4Htg5zsnbjsp4Ag7LK07YGs7ZWc64ukLlxuICAgKiBAZWxlbWVudHMgLSBFbGVtZW50cyB0byBjaGVjayByZWFkeSBzdGF0dXMuIDxrbz4g7KSA67mEIOyDge2DnOulvCDssrTtgaztlaAg7JeY66as66i87Yq465OkLjwva28+XG4gICAqIEBleGFtcGxlXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXY+XG4gICAgICogICAgPGltZyBzcmM9XCIuLzEuanBnXCIgZGF0YS13aWR0aD1cIjEyODBcIiBkYXRhLWhlaWdodD1cIjg1M1wiIHN0eWxlPVwid2lkdGg6MTAwJVwiLz5cbiAgICAgKiAgICA8aW1nIHNyYz1cIi4vMi5qcGdcIiBkYXRhLXdpZHRoPVwiMTI4MFwiIGRhdGEtaGVpZ2h0PVwiODUzXCIvPlxuICAgICAqICAgIDxpbWcgc3JjPVwiRVJSXCIgZGF0YS13aWR0aD1cIjEyODBcIiBkYXRhLWhlaWdodD1cIjg1M1wiLz5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKiAjIyBKYXZhc2NyaXB0XG4gICAgICogYGBganNcbiAgICAgKiBpbXBvcnQgSW1SZWFkeSBmcm9tIFwiQGVnanMvaW1yZWFkeVwiO1xuICAgICAqXG4gICAgICogY29uc3QgaW0gPSBuZXcgSW1SZWFkeSgpOyAvLyB1bWQ6IGVnLkltUmVhZHlcbiAgICAgKiBpbS5jaGVjayhkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiaW1nXCIpKS5vbih7XG4gICAgICogICBwcmVSZWFkeUVsZW1lbnQ6IGUgPT4ge1xuICAgICAqICAgICAvLyAxLCAzXG4gICAgICogICAgIC8vIDIsIDNcbiAgICAgKiAgICAgLy8gMywgM1xuICAgICAqICAgICBjb25zb2xlLmxvZyhlLnByZVJlYWR5Q291bnQsIGUudG90YWxDb3VudCksXG4gICAgICogICB9LFxuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgKi9cblxuXG4gIHZhciBfX3Byb3RvID0gSW1SZWFkeU1hbmFnZXIucHJvdG90eXBlO1xuXG4gIF9fcHJvdG8uY2hlY2sgPSBmdW5jdGlvbiAoZWxlbWVudHMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIHByZWZpeCA9IHRoaXMub3B0aW9ucy5wcmVmaXg7XG4gICAgdGhpcy5jbGVhcigpO1xuICAgIHRoaXMuZWxlbWVudEluZm9zID0gdG9BcnJheSQxKGVsZW1lbnRzKS5tYXAoZnVuY3Rpb24gKGVsZW1lbnQsIGluZGV4KSB7XG4gICAgICB2YXIgbG9hZGVyID0gX3RoaXMuZ2V0TG9hZGVyKGVsZW1lbnQsIHtcbiAgICAgICAgcHJlZml4OiBwcmVmaXhcbiAgICAgIH0pO1xuXG4gICAgICBsb2FkZXIuY2hlY2soKTtcbiAgICAgIGxvYWRlci5vbihcImVycm9yXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIF90aGlzLm9uRXJyb3IoaW5kZXgsIGUudGFyZ2V0KTtcbiAgICAgIH0pLm9uKFwicHJlUmVhZHlcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIGluZm8gPSBfdGhpcy5lbGVtZW50SW5mb3NbaW5kZXhdO1xuICAgICAgICBpbmZvLmhhc0xvYWRpbmcgPSBlLmhhc0xvYWRpbmc7XG4gICAgICAgIGluZm8uaXNTa2lwID0gZS5pc1NraXA7XG5cbiAgICAgICAgdmFyIGlzUHJlUmVhZHkgPSBfdGhpcy5jaGVja1ByZVJlYWR5KGluZGV4KTtcblxuICAgICAgICBfdGhpcy5vblByZVJlYWR5RWxlbWVudChpbmRleCk7XG5cbiAgICAgICAgaXNQcmVSZWFkeSAmJiBfdGhpcy5vblByZVJlYWR5KCk7XG4gICAgICB9KS5vbihcInJlYWR5XCIsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgd2l0aFByZVJlYWR5ID0gX2Eud2l0aFByZVJlYWR5LFxuICAgICAgICAgICAgaGFzTG9hZGluZyA9IF9hLmhhc0xvYWRpbmcsXG4gICAgICAgICAgICBpc1NraXAgPSBfYS5pc1NraXA7XG4gICAgICAgIHZhciBpbmZvID0gX3RoaXMuZWxlbWVudEluZm9zW2luZGV4XTtcbiAgICAgICAgaW5mby5oYXNMb2FkaW5nID0gaGFzTG9hZGluZztcbiAgICAgICAgaW5mby5pc1NraXAgPSBpc1NraXA7XG5cbiAgICAgICAgdmFyIGlzUHJlUmVhZHkgPSB3aXRoUHJlUmVhZHkgJiYgX3RoaXMuY2hlY2tQcmVSZWFkeShpbmRleCk7XG5cbiAgICAgICAgdmFyIGlzUmVhZHkgPSBfdGhpcy5jaGVja1JlYWR5KGluZGV4KTsgLy8gUHJlLXJlYWR5IGFuZCByZWFkeSBvY2N1ciBzaW11bHRhbmVvdXNseVxuXG5cbiAgICAgICAgd2l0aFByZVJlYWR5ICYmIF90aGlzLm9uUHJlUmVhZHlFbGVtZW50KGluZGV4KTtcblxuICAgICAgICBfdGhpcy5vblJlYWR5RWxlbWVudChpbmRleCk7XG5cbiAgICAgICAgaXNQcmVSZWFkeSAmJiBfdGhpcy5vblByZVJlYWR5KCk7XG4gICAgICAgIGlzUmVhZHkgJiYgX3RoaXMub25SZWFkeSgpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsb2FkZXI6IGxvYWRlcixcbiAgICAgICAgZWxlbWVudDogZWxlbWVudCxcbiAgICAgICAgaGFzTG9hZGluZzogZmFsc2UsXG4gICAgICAgIGhhc0Vycm9yOiBmYWxzZSxcbiAgICAgICAgaXNQcmVSZWFkeTogZmFsc2UsXG4gICAgICAgIGlzUmVhZHk6IGZhbHNlLFxuICAgICAgICBpc1NraXA6IGZhbHNlXG4gICAgICB9O1xuICAgIH0pO1xuICAgIHZhciBsZW5ndGggPSB0aGlzLmVsZW1lbnRJbmZvcy5sZW5ndGg7XG4gICAgdGhpcy50b3RhbENvdW50ID0gbGVuZ3RoO1xuXG4gICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5vblByZVJlYWR5KCk7XG5cbiAgICAgICAgX3RoaXMub25SZWFkeSgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxuICAgKiBHZXRzIHRoZSB0b3RhbCBjb3VudCBvZiBlbGVtZW50cyB0byBiZSBjaGVja2VkLlxuICAgKiBAa28g7LK07YGs7ZWY64qUIGVsZW1lbnTsnZgg7LSdIOqwnOyImOulvCDqsIDsoLjsmKjri6QuXG4gICAqL1xuXG5cbiAgX19wcm90by5nZXRUb3RhbENvdW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnRvdGFsQ291bnQ7XG4gIH07XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBlbGVtZW50cyBhcmUgYWxsIHByZS1yZWFkeS4gKGFsbCBzaXplcyBhcmUga25vd24pXG4gICAqIEBrbyDsl5jrpqzrqLztirjrk6TsnbQg66qo65GQIOyCrOyghCDspIDruYTqsIAg65CQ64qU7KeAICjsgqzsnbTspojrpbwg7KCE67aAIOyVjCDsiJgg7J6I64qU7KeAKSDsl6zrtoAuXG4gICAqL1xuXG5cbiAgX19wcm90by5pc1ByZVJlYWR5ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnRJbmZvcy5ldmVyeShmdW5jdGlvbiAoaW5mbykge1xuICAgICAgcmV0dXJuIGluZm8uaXNQcmVSZWFkeTtcbiAgICB9KTtcbiAgfTtcbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIGVsZW1lbnRzIGFyZSBhbGwgcmVhZHkuXG4gICAqIEBrbyDsl5jrpqzrqLztirjrk6TsnbQg66qo65GQIOykgOu5hOqwgCDrkJDripTsp4Ag7Jes67aALlxuICAgKi9cblxuXG4gIF9fcHJvdG8uaXNSZWFkeSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50SW5mb3MuZXZlcnkoZnVuY3Rpb24gKGluZm8pIHtcbiAgICAgIHJldHVybiBpbmZvLmlzUmVhZHk7XG4gICAgfSk7XG4gIH07XG4gIC8qKlxuICAgKiBXaGV0aGVyIGFuIGVycm9yIGhhcyBvY2N1cnJlZCBpbiB0aGUgZWxlbWVudHMgaW4gdGhlIGN1cnJlbnQgc3RhdGUuXG4gICAqIEBrbyDtmITsnqwg7IOB7YOc7JeQ7IScIOyXmOumrOuovO2KuOuTpOydtCDsl5Drn6zqsIAg67Cc7IOd7ZaI64qU7KeAIOyXrOu2gC5cbiAgICovXG5cblxuICBfX3Byb3RvLmhhc0Vycm9yID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnRvdGFsRXJyb3JDb3VudCA+IDA7XG4gIH07XG4gIC8qKlxuICAgKiBDbGVhcnMgZXZlbnRzIG9mIGVsZW1lbnRzIGJlaW5nIGNoZWNrZWQuXG4gICAqIEBrbyDssrTtgawg7KSR7J24IOyXmOumrOuovO2KuOuTpOydmCDsnbTrsqTtirjrpbwg7ZW07KCcIO2VnOuLpC5cbiAgICovXG5cblxuICBfX3Byb3RvLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaXNQcmVSZWFkeU92ZXIgPSBmYWxzZTtcbiAgICB0aGlzLnRvdGFsQ291bnQgPSAwO1xuICAgIHRoaXMucHJlUmVhZHlDb3VudCA9IDA7XG4gICAgdGhpcy5yZWFkeUNvdW50ID0gMDtcbiAgICB0aGlzLnRvdGFsRXJyb3JDb3VudCA9IDA7XG4gICAgdGhpcy5lbGVtZW50SW5mb3MuZm9yRWFjaChmdW5jdGlvbiAoaW5mbykge1xuICAgICAgaWYgKGluZm8ubG9hZGVyKSB7XG4gICAgICAgIGluZm8ubG9hZGVyLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmVsZW1lbnRJbmZvcyA9IFtdO1xuICB9O1xuICAvKipcbiAgICogRGVzdG9yeSBhbGwgZXZlbnRzLlxuICAgKiBAa28g66qo65OgIOydtOuypO2KuOulvCDtlbTsoJwg7ZWc64ukLlxuICAgKi9cblxuXG4gIF9fcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNsZWFyKCk7XG4gICAgdGhpcy5vZmYoKTtcbiAgfTtcblxuICBfX3Byb3RvLmdldExvYWRlciA9IGZ1bmN0aW9uIChlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciB0YWdOYW1lID0gZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFyIGxvYWRlcnMgPSB0aGlzLm9wdGlvbnMubG9hZGVycztcbiAgICB2YXIgcHJlZml4ID0gb3B0aW9ucy5wcmVmaXg7XG4gICAgdmFyIHRhZ3MgPSBPYmplY3Qua2V5cyhsb2FkZXJzKTtcblxuICAgIGlmIChsb2FkZXJzW3RhZ05hbWVdKSB7XG4gICAgICByZXR1cm4gbmV3IGxvYWRlcnNbdGFnTmFtZV0oZWxlbWVudCwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgdmFyIGxvYWRlciA9IG5ldyBFbGVtZW50TG9hZGVyKGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgIHZhciBjaGlsZHJlbiA9IHRvQXJyYXkkMShlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwodGFncy5qb2luKFwiLCBcIikpKTtcbiAgICBsb2FkZXIuc2V0SGFzTG9hZGluZyhjaGlsZHJlbi5zb21lKGZ1bmN0aW9uIChlbCkge1xuICAgICAgcmV0dXJuIGhhc0xvYWRpbmdBdHRyaWJ1dGUoZWwsIHByZWZpeCk7XG4gICAgfSkpO1xuICAgIHZhciB3aXRoUHJlUmVhZHkgPSBmYWxzZTtcbiAgICB2YXIgY2hpbGRyZW5JbVJlYWR5ID0gdGhpcy5jbG9uZSgpLm9uKFwiZXJyb3JcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGxvYWRlci5vbkVycm9yKGUudGFyZ2V0KTtcbiAgICB9KS5vbihcInJlYWR5XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGxvYWRlci5vblJlYWR5KHdpdGhQcmVSZWFkeSk7XG4gICAgfSk7XG4gICAgbG9hZGVyLm9uKFwicmVxdWVzdENoaWxkcmVuXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIGhhcyBub3QgZGF0YSBzaXplXG4gICAgICB2YXIgY29udGVudEVsZW1lbnRzID0gZ2V0Q29udGVudEVsZW1lbnRzKGVsZW1lbnQsIHRhZ3MsIF90aGlzLm9wdGlvbnMucHJlZml4KTtcbiAgICAgIGNoaWxkcmVuSW1SZWFkeS5jaGVjayhjb250ZW50RWxlbWVudHMpLm9uKFwicHJlUmVhZHlcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgd2l0aFByZVJlYWR5ID0gZS5pc1JlYWR5O1xuXG4gICAgICAgIGlmICghd2l0aFByZVJlYWR5KSB7XG4gICAgICAgICAgbG9hZGVyLm9uUHJlUmVhZHkoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSkub24oXCJyZXFldXN0UmVhZHlDaGlsZHJlblwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBoYXMgZGF0YSBzaXplXG4gICAgICAvLyBsb2FkZXIgY2FsbCBwcmVSZWFkeVxuICAgICAgLy8gY2hlY2sgb25seSB2aWRlbywgaW1hZ2UgZWxlbWVudHNcbiAgICAgIGNoaWxkcmVuSW1SZWFkeS5jaGVjayhjaGlsZHJlbik7XG4gICAgfSkub24oXCJyZXF1ZXN0RGVzdHJveVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBjaGlsZHJlbkltUmVhZHkuZGVzdHJveSgpO1xuICAgIH0pO1xuICAgIHJldHVybiBsb2FkZXI7XG4gIH07XG5cbiAgX19wcm90by5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IEltUmVhZHlNYW5hZ2VyKF9fYXNzaWduJDEoe30sIHRoaXMub3B0aW9ucykpO1xuICB9O1xuXG4gIF9fcHJvdG8uY2hlY2tQcmVSZWFkeSA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgIHRoaXMuZWxlbWVudEluZm9zW2luZGV4XS5pc1ByZVJlYWR5ID0gdHJ1ZTtcbiAgICArK3RoaXMucHJlUmVhZHlDb3VudDtcblxuICAgIGlmICh0aGlzLnByZVJlYWR5Q291bnQgPCB0aGlzLnRvdGFsQ291bnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBfX3Byb3RvLmNoZWNrUmVhZHkgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICB0aGlzLmVsZW1lbnRJbmZvc1tpbmRleF0uaXNSZWFkeSA9IHRydWU7XG4gICAgKyt0aGlzLnJlYWR5Q291bnQ7XG5cbiAgICBpZiAodGhpcy5yZWFkeUNvdW50IDwgdGhpcy50b3RhbENvdW50KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgX19wcm90by5vbkVycm9yID0gZnVuY3Rpb24gKGluZGV4LCB0YXJnZXQpIHtcbiAgICB2YXIgaW5mbyA9IHRoaXMuZWxlbWVudEluZm9zW2luZGV4XTtcbiAgICBpbmZvLmhhc0Vycm9yID0gdHJ1ZTtcbiAgICAvKipcbiAgICAgKiBBbiBldmVudCBvY2N1cnMgaWYgdGhlIGltYWdlLCB2aWRlbyBmYWlscyB0byBsb2FkLlxuICAgICAqIEBrbyDsnbTrr7jsp4AsIOu5hOuUlOyYpOqwgCDroZzrlKnsl5Ag7Iuk7Yyo7ZWY66m0IOydtOuypO2KuOqwgCDrsJzsg53tlZzri6QuXG4gICAgICogQGV2ZW50IGVnLkltUmVhZHkjZXJyb3JcbiAgICAgKiBAcGFyYW0ge2VnLkltUmVhZHkuT25FcnJvcn0gZSAtIFRoZSBvYmplY3Qgb2YgZGF0YSB0byBiZSBzZW50IHRvIGFuIGV2ZW50IDxrbz7snbTrsqTtirjsl5Ag7KCE64us65CY64qUIOuNsOydtO2EsCDqsJ3ssrQ8L2tvPlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXY+XG4gICAgICogICAgPGltZyBzcmM9XCIuLzEuanBnXCIgZGF0YS13aWR0aD1cIjEyODBcIiBkYXRhLWhlaWdodD1cIjg1M1wiIHN0eWxlPVwid2lkdGg6MTAwJVwiLz5cbiAgICAgKiAgICA8aW1nIHNyYz1cIi4vMi5qcGdcIi8+XG4gICAgICogICAgPGltZyBzcmM9XCJFUlJcIi8+XG4gICAgICogPC9kaXY+XG4gICAgICogYGBgXG4gICAgICogIyMgSmF2YXNjcmlwdFxuICAgICAqIGBgYGpzXG4gICAgICogaW1wb3J0IEltUmVhZHkgZnJvbSBcIkBlZ2pzL2ltcmVhZHlcIjtcbiAgICAgKlxuICAgICAqIGNvbnN0IGltID0gbmV3IEltUmVhZHkoKTsgLy8gdW1kOiBlZy5JbVJlYWR5XG4gICAgICogaW0uY2hlY2soW2RvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJkaXZcIildKS5vbih7XG4gICAgICogICBlcnJvcjogZSA9PiB7XG4gICAgICogICAgIC8vIDxkaXY+Li4uPC9kaXY+LCAwLCA8aW1nIHNyYz1cIkVSUlwiLz5cbiAgICAgKiAgICAgY29uc29sZS5sb2coZS5lbGVtZW50LCBlLmluZGV4LCBlLnRhcmdldCksXG4gICAgICogICB9LFxuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqL1xuXG4gICAgdGhpcy50cmlnZ2VyKG5ldyBDb21wb25lbnRFdmVudCQxKFwiZXJyb3JcIiwge1xuICAgICAgZWxlbWVudDogaW5mby5lbGVtZW50LFxuICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICBlcnJvckNvdW50OiB0aGlzLmdldEVycm9yQ291bnQoKSxcbiAgICAgIHRvdGFsRXJyb3JDb3VudDogKyt0aGlzLnRvdGFsRXJyb3JDb3VudFxuICAgIH0pKTtcbiAgfTtcblxuICBfX3Byb3RvLm9uUHJlUmVhZHlFbGVtZW50ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgdmFyIGluZm8gPSB0aGlzLmVsZW1lbnRJbmZvc1tpbmRleF07XG4gICAgLyoqXG4gICAgICogQW4gZXZlbnQgb2NjdXJzIHdoZW4gdGhlIGVsZW1lbnQgaXMgcHJlLXJlYWR5ICh3aGVuIHRoZSBsb2FkaW5nIGF0dHJpYnV0ZSBpcyBhcHBsaWVkIG9yIHRoZSBzaXplIGlzIGtub3duKVxuICAgICAqIEBrbyDtlbTri7kg7JeY66as66i87Yq46rCAIOyCrOyghCDspIDruYTrkJjsl4jsnYQg65WMKGxvYWRpbmcg7IaN7ISx7J20IOyggeyaqeuQmOyXiOqxsOuCmCDsgqzsnbTspojrpbwg7JWMIOyImCDsnojsnYQg65WMKSDsnbTrsqTtirjqsIAg67Cc7IOd7ZWc64ukLlxuICAgICAqIEBldmVudCBlZy5JbVJlYWR5I3ByZVJlYWR5RWxlbWVudFxuICAgICAqIEBwYXJhbSB7ZWcuSW1SZWFkeS5PblByZVJlYWR5RWxlbWVudH0gZSAtIFRoZSBvYmplY3Qgb2YgZGF0YSB0byBiZSBzZW50IHRvIGFuIGV2ZW50IDxrbz7snbTrsqTtirjsl5Ag7KCE64us65CY64qUIOuNsOydtO2EsCDqsJ3ssrQ8L2tvPlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXY+XG4gICAgICogICAgPGltZyBzcmM9XCIuLzEuanBnXCIgZGF0YS13aWR0aD1cIjEyODBcIiBkYXRhLWhlaWdodD1cIjg1M1wiIHN0eWxlPVwid2lkdGg6MTAwJVwiLz5cbiAgICAgKiAgICA8aW1nIHNyYz1cIi4vMi5qcGdcIiBkYXRhLXdpZHRoPVwiMTI4MFwiIGRhdGEtaGVpZ2h0PVwiODUzXCIvPlxuICAgICAqICAgIDxpbWcgc3JjPVwiRVJSXCIgZGF0YS13aWR0aD1cIjEyODBcIiBkYXRhLWhlaWdodD1cIjg1M1wiLz5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKiAjIyBKYXZhc2NyaXB0XG4gICAgICogYGBganNcbiAgICAgKiBpbXBvcnQgSW1SZWFkeSBmcm9tIFwiQGVnanMvaW1yZWFkeVwiO1xuICAgICAqXG4gICAgICogY29uc3QgaW0gPSBuZXcgSW1SZWFkeSgpOyAvLyB1bWQ6IGVnLkltUmVhZHlcbiAgICAgKiBpbS5jaGVjayhkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiaW1nXCIpKS5vbih7XG4gICAgICogICBwcmVSZWFkeUVsZW1lbnQ6IGUgPT4ge1xuICAgICAqICAgICAvLyAxLCAzXG4gICAgICogICAgIC8vIDIsIDNcbiAgICAgKiAgICAgLy8gMywgM1xuICAgICAqICAgICBjb25zb2xlLmxvZyhlLnByZVJlYWR5Q291bnQsIGUudG90YWxDb3VudCksXG4gICAgICogICB9LFxuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqL1xuXG4gICAgdGhpcy50cmlnZ2VyKG5ldyBDb21wb25lbnRFdmVudCQxKFwicHJlUmVhZHlFbGVtZW50XCIsIHtcbiAgICAgIGVsZW1lbnQ6IGluZm8uZWxlbWVudCxcbiAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgIHByZVJlYWR5Q291bnQ6IHRoaXMucHJlUmVhZHlDb3VudCxcbiAgICAgIHJlYWR5Q291bnQ6IHRoaXMucmVhZHlDb3VudCxcbiAgICAgIHRvdGFsQ291bnQ6IHRoaXMudG90YWxDb3VudCxcbiAgICAgIGlzUHJlUmVhZHk6IHRoaXMuaXNQcmVSZWFkeSgpLFxuICAgICAgaXNSZWFkeTogdGhpcy5pc1JlYWR5KCksXG4gICAgICBoYXNMb2FkaW5nOiBpbmZvLmhhc0xvYWRpbmcsXG4gICAgICBpc1NraXA6IGluZm8uaXNTa2lwXG4gICAgfSkpO1xuICB9O1xuXG4gIF9fcHJvdG8ub25QcmVSZWFkeSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmlzUHJlUmVhZHlPdmVyID0gdHJ1ZTtcbiAgICAvKipcbiAgICAgKiBBbiBldmVudCBvY2N1cnMgd2hlbiBhbGwgZWxlbWVudCBhcmUgcHJlLXJlYWR5IChXaGVuIGFsbCBlbGVtZW50cyBoYXZlIHRoZSBsb2FkaW5nIGF0dHJpYnV0ZSBhcHBsaWVkIG9yIHRoZSBzaXplIGlzIGtub3duKVxuICAgICAqIEBrbyDrqqjrk6Ag7JeY66as66i87Yq465Ok7J20IOyCrOyghCDspIDruYTrkJwg6rK97JqwICjrqqjrk6Ag7JeY66as66i87Yq465Ok7J20IGxvYWRpbmcg7IaN7ISx7J20IOyggeyaqeuQmOyXiOqxsOuCmCDsgqzsnbTspojrpbwg7JWMIOyImCDsnojripQg6rK97JqwKSDsnbTrsqTtirjqsIAg67Cc7IOd7ZWc64ukLlxuICAgICAqIEBldmVudCBlZy5JbVJlYWR5I3ByZVJlYWR5XG4gICAgICogQHBhcmFtIHtlZy5JbVJlYWR5Lk9uUHJlUmVhZHl9IGUgLSBUaGUgb2JqZWN0IG9mIGRhdGEgdG8gYmUgc2VudCB0byBhbiBldmVudCA8a28+7J2067Kk7Yq47JeQIOyghOuLrOuQmOuKlCDrjbDsnbTthLAg6rCd7LK0PC9rbz5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2PlxuICAgICAqICAgIDxpbWcgc3JjPVwiLi8xLmpwZ1wiIGRhdGEtd2lkdGg9XCIxMjgwXCIgZGF0YS1oZWlnaHQ9XCI4NTNcIiBzdHlsZT1cIndpZHRoOjEwMCVcIi8+XG4gICAgICogICAgPGltZyBzcmM9XCIuLzIuanBnXCIgZGF0YS13aWR0aD1cIjEyODBcIiBkYXRhLWhlaWdodD1cIjg1M1wiLz5cbiAgICAgKiAgICA8aW1nIHNyYz1cIkVSUlwiIGRhdGEtd2lkdGg9XCIxMjgwXCIgZGF0YS1oZWlnaHQ9XCI4NTNcIi8+XG4gICAgICogPC9kaXY+XG4gICAgICogYGBgXG4gICAgICogIyMgSmF2YXNjcmlwdFxuICAgICAqIGBgYGpzXG4gICAgICogaW1wb3J0IEltUmVhZHkgZnJvbSBcIkBlZ2pzL2ltcmVhZHlcIjtcbiAgICAgKlxuICAgICAqIGNvbnN0IGltID0gbmV3IEltUmVhZHkoKTsgLy8gdW1kOiBlZy5JbVJlYWR5XG4gICAgICogaW0uY2hlY2soZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcImltZ1wiKSkub24oe1xuICAgICAqICAgcHJlUmVhZHk6IGUgPT4ge1xuICAgICAqICAgICAvLyAwLCAzXG4gICAgICogICAgIGNvbnNvbGUubG9nKGUucmVhZHlDb3VudCwgZS50b3RhbENvdW50KSxcbiAgICAgKiAgIH0sXG4gICAgICogfSk7XG4gICAgICogYGBgXG4gICAgICovXG5cbiAgICB0aGlzLnRyaWdnZXIobmV3IENvbXBvbmVudEV2ZW50JDEoXCJwcmVSZWFkeVwiLCB7XG4gICAgICByZWFkeUNvdW50OiB0aGlzLnJlYWR5Q291bnQsXG4gICAgICB0b3RhbENvdW50OiB0aGlzLnRvdGFsQ291bnQsXG4gICAgICBpc1JlYWR5OiB0aGlzLmlzUmVhZHkoKSxcbiAgICAgIGhhc0xvYWRpbmc6IHRoaXMuaGFzTG9hZGluZygpXG4gICAgfSkpO1xuICB9O1xuXG4gIF9fcHJvdG8ub25SZWFkeUVsZW1lbnQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICB2YXIgaW5mbyA9IHRoaXMuZWxlbWVudEluZm9zW2luZGV4XTtcbiAgICAvKipcbiAgICAgKiBBbiBldmVudCBvY2N1cnMgd2hlbiB0aGUgZWxlbWVudCBpcyByZWFkeVxuICAgICAqIEBrbyDtlbTri7kg7JeY66as66i87Yq46rCAIOykgOu5hOqwgCDrkJjsl4jsnYQg65WMIOydtOuypO2KuOqwgCDrsJzsg53tlZzri6QuXG4gICAgICogQGV2ZW50IGVnLkltUmVhZHkjcmVhZHlFbGVtZW50XG4gICAgICogQHBhcmFtIHtlZy5JbVJlYWR5Lk9uUmVhZHlFbGVtZW50fSBlIC0gVGhlIG9iamVjdCBvZiBkYXRhIHRvIGJlIHNlbnQgdG8gYW4gZXZlbnQgPGtvPuydtOuypO2KuOyXkCDsoITri6zrkJjripQg642w7J207YSwIOqwneyytDwva28+XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdj5cbiAgICAgKiAgICA8aW1nIHNyYz1cIi4vMS5qcGdcIiBkYXRhLXdpZHRoPVwiMTI4MFwiIGRhdGEtaGVpZ2h0PVwiODUzXCIgc3R5bGU9XCJ3aWR0aDoxMDAlXCIvPlxuICAgICAqICAgIDxpbWcgc3JjPVwiLi8yLmpwZ1wiIGRhdGEtd2lkdGg9XCIxMjgwXCIgZGF0YS1oZWlnaHQ9XCI4NTNcIi8+XG4gICAgICogICAgPGltZyBzcmM9XCJFUlJcIiBkYXRhLXdpZHRoPVwiMTI4MFwiIGRhdGEtaGVpZ2h0PVwiODUzXCIvPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqICMjIEphdmFzY3JpcHRcbiAgICAgKiBgYGBqc1xuICAgICAqIGltcG9ydCBJbVJlYWR5IGZyb20gXCJAZWdqcy9pbXJlYWR5XCI7XG4gICAgICpcbiAgICAgKiBjb25zdCBpbSA9IG5ldyBJbVJlYWR5KCk7IC8vIHVtZDogZWcuSW1SZWFkeVxuICAgICAqIGltLmNoZWNrKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJpbWdcIikpLm9uKHtcbiAgICAgKiAgIHJlYWR5RWxlbWVudDogZSA9PiB7XG4gICAgICogICAgIC8vIDEsIDAsIGZhbHNlLCAzXG4gICAgICogICAgIC8vIDIsIDEsIGZhbHNlLCAzXG4gICAgICogICAgIC8vIDMsIDIsIHRydWUsIDNcbiAgICAgKiAgICAgY29uc29sZS5sb2coZS5yZWFkeUNvdW50LCBlLmluZGV4LCBlLmhhc0Vycm9yLCBlLnRvdGFsQ291bnQpLFxuICAgICAqICAgfSxcbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cblxuICAgIHRoaXMudHJpZ2dlcihuZXcgQ29tcG9uZW50RXZlbnQkMShcInJlYWR5RWxlbWVudFwiLCB7XG4gICAgICBpbmRleDogaW5kZXgsXG4gICAgICBlbGVtZW50OiBpbmZvLmVsZW1lbnQsXG4gICAgICBoYXNFcnJvcjogaW5mby5oYXNFcnJvcixcbiAgICAgIGVycm9yQ291bnQ6IHRoaXMuZ2V0RXJyb3JDb3VudCgpLFxuICAgICAgdG90YWxFcnJvckNvdW50OiB0aGlzLnRvdGFsRXJyb3JDb3VudCxcbiAgICAgIHByZVJlYWR5Q291bnQ6IHRoaXMucHJlUmVhZHlDb3VudCxcbiAgICAgIHJlYWR5Q291bnQ6IHRoaXMucmVhZHlDb3VudCxcbiAgICAgIHRvdGFsQ291bnQ6IHRoaXMudG90YWxDb3VudCxcbiAgICAgIGlzUHJlUmVhZHk6IHRoaXMuaXNQcmVSZWFkeSgpLFxuICAgICAgaXNSZWFkeTogdGhpcy5pc1JlYWR5KCksXG4gICAgICBoYXNMb2FkaW5nOiBpbmZvLmhhc0xvYWRpbmcsXG4gICAgICBpc1ByZVJlYWR5T3ZlcjogdGhpcy5pc1ByZVJlYWR5T3ZlcixcbiAgICAgIGlzU2tpcDogaW5mby5pc1NraXBcbiAgICB9KSk7XG4gIH07XG5cbiAgX19wcm90by5vblJlYWR5ID0gZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEFuIGV2ZW50IG9jY3VycyB3aGVuIGFsbCBlbGVtZW50IGFyZSByZWFkeVxuICAgICAqIEBrbyDrqqjrk6Ag7JeY66as66i87Yq465Ok7J20IOykgOu5hOuQnCDqsr3smrAg7J2067Kk7Yq46rCAIOuwnOyDne2VnOuLpC5cbiAgICAgKiBAZXZlbnQgZWcuSW1SZWFkeSNyZWFkeVxuICAgICAqIEBwYXJhbSB7ZWcuSW1SZWFkeS5PblJlYWR5fSBlIC0gVGhlIG9iamVjdCBvZiBkYXRhIHRvIGJlIHNlbnQgdG8gYW4gZXZlbnQgPGtvPuydtOuypO2KuOyXkCDsoITri6zrkJjripQg642w7J207YSwIOqwneyytDwva28+XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdj5cbiAgICAgKiAgICA8aW1nIHNyYz1cIi4vMS5qcGdcIiBkYXRhLXdpZHRoPVwiMTI4MFwiIGRhdGEtaGVpZ2h0PVwiODUzXCIgc3R5bGU9XCJ3aWR0aDoxMDAlXCIvPlxuICAgICAqICAgIDxpbWcgc3JjPVwiLi8yLmpwZ1wiIGRhdGEtd2lkdGg9XCIxMjgwXCIgZGF0YS1oZWlnaHQ9XCI4NTNcIi8+XG4gICAgICogICAgPGltZyBzcmM9XCJFUlJcIiBkYXRhLXdpZHRoPVwiMTI4MFwiIGRhdGEtaGVpZ2h0PVwiODUzXCIvPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqICMjIEphdmFzY3JpcHRcbiAgICAgKiBgYGBqc1xuICAgICAqIGltcG9ydCBJbVJlYWR5IGZyb20gXCJAZWdqcy9pbXJlYWR5XCI7XG4gICAgICpcbiAgICAgKiBjb25zdCBpbSA9IG5ldyBJbVJlYWR5KCk7IC8vIHVtZDogZWcuSW1SZWFkeVxuICAgICAqIGltLmNoZWNrKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJpbWdcIikpLm9uKHtcbiAgICAgKiAgIHByZVJlYWR5OiBlID0+IHtcbiAgICAgKiAgICAgLy8gMCwgM1xuICAgICAqICAgICBjb25zb2xlLmxvZyhlLnJlYWR5Q291bnQsIGUudG90YWxDb3VudCksXG4gICAgICogICB9LFxuICAgICAqICAgcmVhZHk6IGUgPT4ge1xuICAgICAqICAgICAvLyAxLCAzXG4gICAgICogICAgIGNvbnNvbGUubG9nKGUuZXJyb3JDb3VudCwgZS50b3RhbENvdW50KSxcbiAgICAgKiAgIH0sXG4gICAgICogfSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgdGhpcy50cmlnZ2VyKG5ldyBDb21wb25lbnRFdmVudCQxKFwicmVhZHlcIiwge1xuICAgICAgZXJyb3JDb3VudDogdGhpcy5nZXRFcnJvckNvdW50KCksXG4gICAgICB0b3RhbEVycm9yQ291bnQ6IHRoaXMudG90YWxFcnJvckNvdW50LFxuICAgICAgdG90YWxDb3VudDogdGhpcy50b3RhbENvdW50XG4gICAgfSkpO1xuICB9O1xuXG4gIF9fcHJvdG8uZ2V0RXJyb3JDb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50SW5mb3MuZmlsdGVyKGZ1bmN0aW9uIChpbmZvKSB7XG4gICAgICByZXR1cm4gaW5mby5oYXNFcnJvcjtcbiAgICB9KS5sZW5ndGg7XG4gIH07XG5cbiAgX19wcm90by5oYXNMb2FkaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnRJbmZvcy5zb21lKGZ1bmN0aW9uIChpbmZvKSB7XG4gICAgICByZXR1cm4gaW5mby5oYXNMb2FkaW5nO1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBJbVJlYWR5TWFuYWdlcjtcbn0oQ29tcG9uZW50KTtcblxudmFyIEltYWdlTG9hZGVyID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzJDIoSW1hZ2VMb2FkZXIsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gSW1hZ2VMb2FkZXIoKSB7XG4gICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9fcHJvdG8gPSBJbWFnZUxvYWRlci5wcm90b3R5cGU7XG5cbiAgX19wcm90by5jaGVja0VsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG4gICAgdmFyIHNyYyA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwic3JjXCIpO1xuXG4gICAgaWYgKGVsZW1lbnQuY29tcGxldGUpIHtcbiAgICAgIGlmIChzcmMpIHtcbiAgICAgICAgLy8gY29tcGxldGVcbiAgICAgICAgaWYgKCFlbGVtZW50Lm5hdHVyYWxXaWR0aCkge1xuICAgICAgICAgIHRoaXMub25BbHJlYWR5RXJyb3IoZWxlbWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBVc2luZyBhbiBleHRlcm5hbCBsYXp5IGxvYWRpbmcgbW9kdWxlXG4gICAgICAgIHRoaXMub25BbHJlYWR5UHJlUmVhZHkoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmFkZEV2ZW50cygpO1xuICAgIElTX0lFICYmIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwic3JjXCIsIHNyYyk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgSW1hZ2VMb2FkZXIuRVZFTlRTID0gW1wibG9hZFwiLCBcImVycm9yXCJdO1xuICByZXR1cm4gSW1hZ2VMb2FkZXI7XG59KExvYWRlcik7XG5cbnZhciBWaWRlb0xvYWRlciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyQyKFZpZGVvTG9hZGVyLCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIFZpZGVvTG9hZGVyKCkge1xuICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfX3Byb3RvID0gVmlkZW9Mb2FkZXIucHJvdG90eXBlO1xuXG4gIF9fcHJvdG8uY2hlY2tFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50OyAvLyBIQVZFX05PVEhJTkc6IDAsIG5vIGluZm9ybWF0aW9uIHdoZXRoZXIgb3Igbm90IHRoZSBhdWRpby92aWRlbyBpcyByZWFkeVxuICAgIC8vIEhBVkVfTUVUQURBVEE6IDEsIEhBVkVfTUVUQURBVEEgLSBtZXRhZGF0YSBmb3IgdGhlIGF1ZGlvL3ZpZGVvIGlzIHJlYWR5XG4gICAgLy8gSEFWRV9DVVJSRU5UX0RBVEE6IDIsIGRhdGEgZm9yIHRoZSBjdXJyZW50IHBsYXliYWNrIHBvc2l0aW9uIGlzIGF2YWlsYWJsZSwgYnV0IG5vdCBlbm91Z2ggZGF0YSB0byBwbGF5IG5leHQgZnJhbWUvbWlsbGlzZWNvbmRcbiAgICAvLyBIQVZFX0ZVVFVSRV9EQVRBOiAzLCBkYXRhIGZvciB0aGUgY3VycmVudCBhbmQgYXQgbGVhc3QgdGhlIG5leHQgZnJhbWUgaXMgYXZhaWxhYmxlXG4gICAgLy8gSEFWRV9FTk9VR0hfREFUQTogNCwgZW5vdWdoIGRhdGEgYXZhaWxhYmxlIHRvIHN0YXJ0IHBsYXlpbmdcblxuICAgIGlmIChlbGVtZW50LnJlYWR5U3RhdGUgPj0gMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChlbGVtZW50LmVycm9yKSB7XG4gICAgICB0aGlzLm9uQWxyZWFkeUVycm9yKGVsZW1lbnQpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuYWRkRXZlbnRzKCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgVmlkZW9Mb2FkZXIuRVZFTlRTID0gW1wibG9hZGVkbWV0YWRhdGFcIiwgXCJlcnJvclwiXTtcbiAgcmV0dXJuIFZpZGVvTG9hZGVyO1xufShMb2FkZXIpO1xuXG52YXIgSW1SZWFkeSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyQyKEltUmVhZHksIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gSW1SZWFkeShvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBfX2Fzc2lnbiQxKHtcbiAgICAgIGxvYWRlcnM6IHtcbiAgICAgICAgaW1nOiBJbWFnZUxvYWRlcixcbiAgICAgICAgdmlkZW86IFZpZGVvTG9hZGVyXG4gICAgICB9XG4gICAgfSwgb3B0aW9ucykpIHx8IHRoaXM7XG4gIH1cblxuICByZXR1cm4gSW1SZWFkeTtcbn0oSW1SZWFkeU1hbmFnZXIpO1xuXG4vKlxuQ29weXJpZ2h0IChjKSAyMDE1LXByZXNlbnQgTkFWRVIgQ29ycC5cbm5hbWU6IEBlZ2pzL2ZsaWNraW5nXG5saWNlbnNlOiBNSVRcbmF1dGhvcjogTkFWRVIgQ29ycC5cbnJlcG9zaXRvcnk6IGh0dHBzOi8vZ2l0aHViLmNvbS9uYXZlci9lZ2pzLWZsaWNraW5nXG52ZXJzaW9uOiA0LjExLjRcbiovXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UsIFN1cHByZXNzZWRFcnJvciwgU3ltYm9sICovXG5cbnZhciBleHRlbmRTdGF0aWNzJDMgPSBmdW5jdGlvbiAoZCwgYikge1xuICBleHRlbmRTdGF0aWNzJDMgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwge1xuICAgIF9fcHJvdG9fXzogW11cbiAgfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZC5fX3Byb3RvX18gPSBiO1xuICB9IHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTtcbiAgfTtcbiAgcmV0dXJuIGV4dGVuZFN0YXRpY3MkMyhkLCBiKTtcbn07XG5mdW5jdGlvbiBfX2V4dGVuZHMkMyhkLCBiKSB7XG4gIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgZXh0ZW5kU3RhdGljcyQzKGQsIGIpO1xuICBmdW5jdGlvbiBfXygpIHtcbiAgICB0aGlzLmNvbnN0cnVjdG9yID0gZDtcbiAgfVxuICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59XG52YXIgX19hc3NpZ24kMiA9IGZ1bmN0aW9uICgpIHtcbiAgX19hc3NpZ24kMiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xuICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XG4gICAgfVxuICAgIHJldHVybiB0O1xuICB9O1xuICByZXR1cm4gX19hc3NpZ24kMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbmZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkge1xuICAgICAgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7XG4gICAgfVxuICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBfX2dlbmVyYXRvcih0aGlzQXJnLCBib2R5KSB7XG4gIHZhciBfID0ge1xuICAgICAgbGFiZWw6IDAsXG4gICAgICBzZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTtcbiAgICAgICAgcmV0dXJuIHRbMV07XG4gICAgICB9LFxuICAgICAgdHJ5czogW10sXG4gICAgICBvcHM6IFtdXG4gICAgfSxcbiAgICBmLFxuICAgIHksXG4gICAgdCxcbiAgICBnO1xuICByZXR1cm4gZyA9IHtcbiAgICBuZXh0OiB2ZXJiKDApLFxuICAgIFwidGhyb3dcIjogdmVyYigxKSxcbiAgICBcInJldHVyblwiOiB2ZXJiKDIpXG4gIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9KSwgZztcbiAgZnVuY3Rpb24gdmVyYihuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh2KSB7XG4gICAgICByZXR1cm4gc3RlcChbbiwgdl0pO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICB3aGlsZSAoZyAmJiAoZyA9IDAsIG9wWzBdICYmIChfID0gMCkpLCBfKSB0cnkge1xuICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICB0ID0gb3A7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBfLmxhYmVsKys7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiBvcFsxXSxcbiAgICAgICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICAgICAgfTtcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIF8ubGFiZWwrKztcbiAgICAgICAgICB5ID0gb3BbMV07XG4gICAgICAgICAgb3AgPSBbMF07XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNhc2UgNzpcbiAgICAgICAgICBvcCA9IF8ub3BzLnBvcCgpO1xuICAgICAgICAgIF8udHJ5cy5wb3AoKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkge1xuICAgICAgICAgICAgXyA9IDA7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCBvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkge1xuICAgICAgICAgICAgXy5sYWJlbCA9IG9wWzFdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkge1xuICAgICAgICAgICAgXy5sYWJlbCA9IHRbMV07XG4gICAgICAgICAgICB0ID0gb3A7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHtcbiAgICAgICAgICAgIF8ubGFiZWwgPSB0WzJdO1xuICAgICAgICAgICAgXy5vcHMucHVzaChvcCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgIF8udHJ5cy5wb3AoKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIG9wID0gWzYsIGVdO1xuICAgICAgeSA9IDA7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGYgPSB0ID0gMDtcbiAgICB9XG4gICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLFxuICAgICAgZG9uZTogdHJ1ZVxuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIF9fdmFsdWVzJDEobykge1xuICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsXG4gICAgbSA9IHMgJiYgb1tzXSxcbiAgICBpID0gMDtcbiAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XG4gIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcbiAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IG8gJiYgb1tpKytdLFxuICAgICAgICBkb25lOiAhb1xuICAgICAgfTtcbiAgICB9XG4gIH07XG4gIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn1cbmZ1bmN0aW9uIF9fcmVhZCQxKG8sIG4pIHtcbiAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICBpZiAoIW0pIHJldHVybiBvO1xuICB2YXIgaSA9IG0uY2FsbChvKSxcbiAgICByLFxuICAgIGFyID0gW10sXG4gICAgZTtcbiAgdHJ5IHtcbiAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBlID0ge1xuICAgICAgZXJyb3I6IGVycm9yXG4gICAgfTtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChlKSB0aHJvdyBlLmVycm9yO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYXI7XG59XG5cbi8qKiBAZGVwcmVjYXRlZCAqL1xuZnVuY3Rpb24gX19zcHJlYWQkMSgpIHtcbiAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIGFyID0gYXIuY29uY2F0KF9fcmVhZCQxKGFyZ3VtZW50c1tpXSkpO1xuICByZXR1cm4gYXI7XG59XG50eXBlb2YgU3VwcHJlc3NlZEVycm9yID09PSBcImZ1bmN0aW9uXCIgPyBTdXBwcmVzc2VkRXJyb3IgOiBmdW5jdGlvbiAoZXJyb3IsIHN1cHByZXNzZWQsIG1lc3NhZ2UpIHtcbiAgdmFyIGUgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIHJldHVybiBlLm5hbWUgPSBcIlN1cHByZXNzZWRFcnJvclwiLCBlLmVycm9yID0gZXJyb3IsIGUuc3VwcHJlc3NlZCA9IHN1cHByZXNzZWQsIGU7XG59O1xuXG4vKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgTkFWRVIgQ29ycC5cclxuICogZWdqcyBwcm9qZWN0cyBhcmUgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L3Jlc3RyaWN0LXRlbXBsYXRlLWV4cHJlc3Npb25zICovXG4vKipcclxuICogRXJyb3IgY29kZXMgb2Yge0BsaW5rIEZsaWNraW5nRXJyb3J9LiBCZWxvdyBhcmUgdGhlIGNvbmRpdGlvbnMgd2hlcmUgZWFjaCBlcnJvciBjb2RlIG9jY3Vycy5cclxuICogQGtvIHtAbGluayBGbGlja2luZ0Vycm9yfeydmCDsl5Drn6wg7L2U65OcLiDslYTrnpjripQg6rCB6rCB7J2YIOyXkOufrCDsvZTrk5zqsIAg67Cc7IOd7ZWY64qUIOyhsOqxtOyeheuLiOuLpC5cclxuICogQG5hbWUgRVJST1JfQ09ERVxyXG4gKiBAY29uc3RhbnRcclxuICogQHR5cGUgb2JqZWN0XHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBXUk9OR19UWVBFIFBhcmFtZXRlciB0eXBlIGlzIHdyb25nPGtvPu2MqOufrOuvuO2EsOydmCDtg4DsnoXsnbQg7J6Y66q765CY7JeI7J2EIOqyveyasDwva28+XHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBFTEVNRU5UX05PVF9GT1VORCBFbGVtZW50IGlzIG5vdCBmb3VuZCBpbnNpZGUgcGFnZSB3aXRoIHRoZSBnaXZlbiBDU1Mgc2VsZWN0b3I8a28+7KO87Ja07KeEIENTUyBzZWxlY3RvcuuhnCDtjpjsnbTsp4Ag64K07JeQ7IScIO2VtOuLuSDsl5jrpqzrqLztirjrpbwg7LC+7KeAIOuqu+2WiOydhCDqsr3smrA8L2tvPlxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gVkFMX01VU1RfTk9UX05VTEwgRXhwZWN0ZWQgbm9uLW51bGwgdmFsdWUsIGJ1dCBnaXZlbiBgbnVsbGAgb3IgYHVuZGVmaW5lZGA8a28+6rCS7J2EIOq4sOuMgO2WiOycvOuCmCwgYG51bGxg7J2064KYIGB1bmRlZmluZWRg66W8IOuwm+ydgCDqsr3smrA8L2tvPlxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gTk9UX0FUVEFDSEVEX1RPX0ZMSUNLSU5HIFdoZW4gRmxpY2tpbmcncyBjb21wb25lbnQgaXMgbm90IGluaXRpYWxpemVkIChpLmUuIHtAbGluayBGbGlja2luZyNpbml0fSBpcyBub3QgY2FsbGVkKTxrbz5GbGlja2luZyDrgrTrtoAg7Lu07Y+s64SM7Yq46rCAIOy0iOq4sO2ZlOuQmOyngCDslYrsnYAg6rK97JqwICh7QGxpbmsgRmxpY2tpbmcjaW5pdH3snbQg7Zi47Lac65CY7KeAIOyViuydgCDqsr3smrApPC9rbz5cclxuICogQHByb3BlcnR5IHtudW1iZXJ9IFdST05HX09QVElPTiBPbmUgb2YgdGhlIG9wdGlvbnMgaXMgd3Jvbmc8a28+7Ji17IWY65OkIOykkSDsnpjrqrvrkJwg6rCS7J20IOyeiOydhCDrlYw8L2tvPlxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gSU5ERVhfT1VUX09GX1JBTkdFIFdoZW4gdGhlIGdpdmVuIGluZGV4IGlzIG91dCBvZiBwb3NzaWJsZSByYW5nZTxrbz7snbjrjbHsiqTqsIAg7KO87Ja07KeEIOuylOychOulvCDrspfslrTrgpwg6rK97JqwPC9rbz5cclxuICogQHByb3BlcnR5IHtudW1iZXJ9IFBPU0lUSU9OX05PVF9SRUFDSEFCTEUgV2hlbiB7QGxpbmsgQ29udHJvbCNtb3ZlVG9Qb3NpdGlvbn0ncyBwb3NpdGlvbiBwYXJhbWV0ZXIgaXMgb3V0IG9mIHBvc3NpYmxlIHJhbmdlLjxrbz57QGxpbmsgQ29udHJvbCNtb3ZlVG9Qb3NpdGlvbn3snZggYHBvc2l0aW9uYCDtjKjrn6zrr7jthLDqsIAg64+E64usIOqwgOuKpe2VnCDrspTsnITrpbwg67KX7Ja064KcIOqyveyasDwva28+XHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBUUkFOU0ZPUk1fTk9UX1NVUFBPUlRFRCBDU1MgYHRyYW5zZm9ybWAgcHJvcGVydHkgaXMgbm90IGF2YWlsYWJsZSg8PUlFOCkgPGtvPkNTUyBgdHJhbnNmb3JtYCDsho3shLHsnYQg7IKs7Jqp7ZWgIOyImCDsl4bripQg6rK97JqwKDw9SUU4KTwva28+XHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBTVE9QX0NBTExFRF9CWV9VU0VSIFdoZW4gdGhlIGV2ZW50J3MgYHN0b3AoKWAgaXMgY2FsbGVkIGJ5IHVzZXIuPGtvPuyCrOyaqeyekOyXkCDsnZjtlbQg7J2067Kk7Yq47J2YIGBzdG9wKClg7J20IO2YuOy2nOuQnCDqsr3smrA8L2tvPlxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gQU5JTUFUSU9OX0lOVEVSUlVQVEVEIFdoZW4gdGhlIGFuaW1hdGlvbiBpcyBpbnRlcnJ1cHRlZCBieSB1c2VyLjxrbz7sgqzsmqnsnpDsl5Ag7J2Y7ZW0IOyVoOuLiOuplOydtOyFmOydtCDspJHri6jrkJwg6rK97JqwPC9rbz5cclxuICogQHByb3BlcnR5IHtudW1iZXJ9IEFOSU1BVElPTl9BTFJFQURZX1BMQVlJTkcgV2hlbiB0aGUgYW5pbWF0aW9uIGlzIGFscmVhZHkgcGxheWluZy48a28+7ZiE7J6sIOyVoOuLiOuplOydtOyFmOydtCDsnbTrr7gg7KeE7ZaJ7KSR7J24IOqyveyasDwva28+XHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBOT1RfQUxMT1dFRF9JTl9GUkFNRVdPUksgV2hlbiB0aGUgbm9uLWFsbG93ZWQgbWV0aG9kIGlzIGNhbGxlZCBmcm9tIGZyYW1ld29ya3MgKFJlYWN0LCBBbmd1bGFyLCBWdWUuLi4pXHJcbiAqIDxrbz7tlITroIjsnoTsm4ztgawoUmVhY3QsIEFuZ3VsYXIsIFZ1ZSAuLi4p7JeQ7IScIOyCrOyaqSDrtojqsIDriqXtlZwg66mU7IaM65Oc66W8IO2YuOy2nO2WiOydhCDqsr3smrA8L2tvPlxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gTk9UX0lOSVRJQUxJWkVEIFdoZW4gdGhlIHtAbGluayBGbGlja2luZyNpbml0fSBpcyBub3QgY2FsbGVkIGJlZm9yZSBidXQgaXMgbmVlZGVkPGtvPntAbGluayBGbGlja2luZyNpbml0feydmCDtmLjstpzsnbQg7ZWE7JqU7ZWY64KYLCDslYTsp4Eg7Zi47Lac65CY7KeAIOyViuyVmOydhCDqsr3smrA8L2tvPlxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gTk9fQUNUSVZFIFdoZW4gdGhlcmUncmUgbm8gYWN0aXZlIHBhbmVsIHRoYXQgZmxpY2tpbmcgaGFzIHNlbGVjdGVkLiBUaGlzIG1heSBiZSBkdWUgdG8gdGhlIGFic2VuY2Ugb2YgYW55IHBhbmVsczxrbz7tmITsnqwgRmxpY2tpbmfsnbQg7ISg7YOd7ZWcIO2MqOuEkOydtCDsl4bsnYQg6rK97JqwLiDsnbzrsJjsoIHsnLzroZwg7Yyo64SQ7J20IO2VmOuCmOuPhCDsl4bripQg6rK97Jqw7JeQIOuwnOyDne2VoCDsiJgg7J6I7Iq164uI64ukPC9rbz5cclxuICogQHByb3BlcnR5IHtudW1iZXJ9IE5PVF9BTExPV0VEX0lOX1ZJUlRVQUwgV2hlbiB0aGUgbm9uLWFsbG93ZWQgbWV0aG9kIGlzIGNhbGxlZCB3aGlsZSB0aGUgdmlydHVhbCBvcHRpb24gaXMgZW5hYmxlZDxrbz52aXJ0dWFsIOyYteyFmOydtCDtmZzshLHtmZTrkJwg7IOB7YOc7JeQ7IScIOyCrOyaqSDrtojqsIDriqXtlZwg66mU7IaM65Oc6rCAIO2YuOy2nOuQmOyXiOydhCDqsr3smrA8L2tvPlxyXG4gKi9cbnZhciBDT0RFID0ge1xuICBXUk9OR19UWVBFOiAwLFxuICBFTEVNRU5UX05PVF9GT1VORDogMSxcbiAgVkFMX01VU1RfTk9UX05VTEw6IDIsXG4gIE5PVF9BVFRBQ0hFRF9UT19GTElDS0lORzogMyxcbiAgV1JPTkdfT1BUSU9OOiA0LFxuICBJTkRFWF9PVVRfT0ZfUkFOR0U6IDUsXG4gIFBPU0lUSU9OX05PVF9SRUFDSEFCTEU6IDYsXG4gIFRSQU5TRk9STV9OT1RfU1VQUE9SVEVEOiA3LFxuICBTVE9QX0NBTExFRF9CWV9VU0VSOiA4LFxuICBBTklNQVRJT05fSU5URVJSVVBURUQ6IDksXG4gIEFOSU1BVElPTl9BTFJFQURZX1BMQVlJTkc6IDEwLFxuICBOT1RfQUxMT1dFRF9JTl9GUkFNRVdPUks6IDExLFxuICBOT1RfSU5JVElBTElaRUQ6IDEyLFxuICBOT19BQ1RJVkU6IDEzLFxuICBOT1RfQUxMT1dFRF9JTl9WSVJUVUFMOiAxNFxufTtcbnZhciBNRVNTQUdFID0ge1xuICBXUk9OR19UWVBFOiBmdW5jdGlvbiAod3JvbmdWYWwsIGNvcnJlY3RUeXBlcykge1xuICAgIHJldHVybiB3cm9uZ1ZhbCArIFwiKFwiICsgdHlwZW9mIHdyb25nVmFsICsgXCIpIGlzIG5vdCBhIFwiICsgY29ycmVjdFR5cGVzLm1hcChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgcmV0dXJuIFwiXFxcIlwiICsgdHlwZSArIFwiXFxcIlwiO1xuICAgIH0pLmpvaW4oXCIgb3IgXCIpICsgXCIuXCI7XG4gIH0sXG4gIEVMRU1FTlRfTk9UX0ZPVU5EOiBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gXCJFbGVtZW50IHdpdGggc2VsZWN0b3IgXFxcIlwiICsgc2VsZWN0b3IgKyBcIlxcXCIgbm90IGZvdW5kLlwiO1xuICB9LFxuICBWQUxfTVVTVF9OT1RfTlVMTDogZnVuY3Rpb24gKHZhbCwgbmFtZSkge1xuICAgIHJldHVybiBuYW1lICsgXCIgc2hvdWxkIGJlIHByb3ZpZGVkLiBHaXZlbjogXCIgKyB2YWw7XG4gIH0sXG4gIE5PVF9BVFRBQ0hFRF9UT19GTElDS0lORzogXCJUaGlzIG1vZHVsZSBpcyBub3QgYXR0YWNoZWQgdG8gdGhlIEZsaWNraW5nIGluc3RhbmNlLiBcXFwiaW5pdCgpXFxcIiBzaG91bGQgYmUgY2FsbGVkIGZpcnN0LlwiLFxuICBXUk9OR19PUFRJT046IGZ1bmN0aW9uIChvcHRpb25OYW1lLCB2YWwpIHtcbiAgICByZXR1cm4gXCJPcHRpb24gXFxcIlwiICsgb3B0aW9uTmFtZSArIFwiXFxcIiBpcyBub3QgaW4gY29ycmVjdCBmb3JtYXQsIGdpdmVuOiBcIiArIHZhbDtcbiAgfSxcbiAgSU5ERVhfT1VUX09GX1JBTkdFOiBmdW5jdGlvbiAodmFsLCBtaW4sIG1heCkge1xuICAgIHJldHVybiBcIkluZGV4IFxcXCJcIiArIHZhbCArIFwiXFxcIiBpcyBvdXQgb2YgcmFuZ2U6IHNob3VsZCBiZSBiZXR3ZWVuIFwiICsgbWluICsgXCIgYW5kIFwiICsgbWF4ICsgXCIuXCI7XG4gIH0sXG4gIFBPU0lUSU9OX05PVF9SRUFDSEFCTEU6IGZ1bmN0aW9uIChwb3NpdGlvbikge1xuICAgIHJldHVybiBcIlBvc2l0aW9uIFxcXCJcIiArIHBvc2l0aW9uICsgXCJcXFwiIGlzIG5vdCByZWFjaGFibGUuXCI7XG4gIH0sXG4gIFRSQU5TRk9STV9OT1RfU1VQUE9SVEVEOiBcIkJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBDU1MgdHJhbnNmb3JtLlwiLFxuICBTVE9QX0NBTExFRF9CWV9VU0VSOiBcIkV2ZW50IHN0b3AoKSBpcyBjYWxsZWQgYnkgdXNlci5cIixcbiAgQU5JTUFUSU9OX0lOVEVSUlVQVEVEOiBcIkFuaW1hdGlvbiBpcyBpbnRlcnJ1cHRlZCBieSB1c2VyIGlucHV0LlwiLFxuICBBTklNQVRJT05fQUxSRUFEWV9QTEFZSU5HOiBcIkFuaW1hdGlvbiBpcyBhbHJlYWR5IHBsYXlpbmcuXCIsXG4gIE5PVF9BTExPV0VEX0lOX0ZSQU1FV09SSzogXCJUaGlzIGJlaGF2aW9yIGlzIG5vdCBhbGxvd2VkIGluIHRoZSBmcmFtZXdvcmtzIGxpa2UgUmVhY3QsIFZ1ZSwgb3IgQW5ndWxhci5cIixcbiAgTk9UX0lOSVRJQUxJWkVEOiBcIkZsaWNraW5nIGlzIG5vdCBpbml0aWFsaXplZCB5ZXQsIGNhbGwgaW5pdCgpIGZpcnN0LlwiLFxuICBOT19BQ1RJVkU6IFwiVGhlcmUncyBubyBhY3RpdmUgcGFuZWwgdGhhdCBGbGlja2luZyBoYXMgc2VsZWN0ZWQuIFRoaXMgbWF5IGJlIGR1ZSB0byB0aGUgYWJzZW5jZSBvZiBhbnkgcGFuZWxzLlwiLFxuICBOT1RfQUxMT1dFRF9JTl9WSVJUVUFMOiBcIlRoaXMgYmVoYXZpb3IgaXMgbm90IGFsbG93ZWQgd2hlbiB0aGUgdmlydHVhbCBvcHRpb24gaXMgZW5hYmxlZFwiXG59O1xuXG4vKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgTkFWRVIgQ29ycC5cclxuICogZWdqcyBwcm9qZWN0cyBhcmUgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xuLyoqXHJcbiAqIEV2ZW50IHR5cGUgb2JqZWN0IHdpdGggZXZlbnQgbmFtZSBzdHJpbmdzIG9mIHtAbGluayBGbGlja2luZ31cclxuICogQGtvIHtAbGluayBGbGlja2luZ33snZgg7J2067Kk7Yq4IOydtOumhCDrrLjsnpDsl7Trk6TsnYQg64u07J2AIOqwneyytFxyXG4gKiBAdHlwZSB7b2JqZWN0fVxyXG4gKiBAcHJvcGVydHkge1wiaG9sZFN0YXJ0XCJ9IEhPTERfU1RBUlQgaG9sZFN0YXJ0IGV2ZW50PGtvPmhvbGRTdGFydCDsnbTrsqTtirg8L2tvPlxyXG4gKiBAcHJvcGVydHkge1wiaG9sZEVuZFwifSBIT0xEX0VORCBob2xkRW5kIGV2ZW50PGtvPmhvbGRFbmQg7J2067Kk7Yq4PC9rbz5cclxuICogQHByb3BlcnR5IHtcIm1vdmVTdGFydFwifSBNT1ZFX1NUQVJUIG1vdmVTdGFydCBldmVudDxrbz5tb3ZlU3RhcnQg7J2067Kk7Yq4PC9rbz5cclxuICogQHByb3BlcnR5IHtcIm1vdmVcIn0gTU9WRSBtb3ZlIGV2ZW50PGtvPm1vdmUg7J2067Kk7Yq4PC9rbz5cclxuICogQHByb3BlcnR5IHtcIm1vdmVFbmRcIn0gTU9WRV9FTkQgbW92ZUVuZCBldmVudDxrbz5tb3ZlRW5kIOydtOuypO2KuDwva28+XHJcbiAqIEBwcm9wZXJ0eSB7XCJ3aWxsQ2hhbmdlXCJ9IFdJTExfQ0hBTkdFIHdpbGxDaGFuZ2UgZXZlbnQ8a28+d2lsbENoYW5nZSDsnbTrsqTtirg8L2tvPlxyXG4gKiBAcHJvcGVydHkge1wiY2hhbmdlZFwifSBDSEFOR0VEIGNoYW5nZWQgZXZlbnQ8a28+Y2hhbmdlZCDsnbTrsqTtirg8L2tvPlxyXG4gKiBAcHJvcGVydHkge1wid2lsbFJlc3RvcmVcIn0gV0lMTF9SRVNUT1JFIHdpbGxSZXN0b3JlIGV2ZW50PGtvPndpbGxSZXN0b3JlIOydtOuypO2KuDwva28+XHJcbiAqIEBwcm9wZXJ0eSB7XCJyZXN0b3JlZFwifSBSRVNUT1JFRCByZXN0b3JlZCBldmVudDxrbz5yZXN0b3JlZCDsnbTrsqTtirg8L2tvPlxyXG4gKiBAcHJvcGVydHkge1wic2VsZWN0XCJ9IFNFTEVDVCBzZWxlY3QgZXZlbnQ8a28+c2VsZWN0IOydtOuypO2KuDwva28+XHJcbiAqIEBwcm9wZXJ0eSB7XCJuZWVkUGFuZWxcIn0gTkVFRF9QQU5FTCBuZWVkUGFuZWwgZXZlbnQ8a28+bmVlZFBhbmVsIOydtOuypO2KuDwva28+XHJcbiAqIEBwcm9wZXJ0eSB7XCJwYW5lbENoYW5nZVwifSBQQU5FTF9DSEFOR0UgcGFuZWxDaGFuZ2UgZXZlbnQ8a28+cGFuZWxDaGFuZ2Ug7J2067Kk7Yq4PC9rbz5cclxuICogQGV4YW1wbGVcclxuICogYGBgdHNcclxuICogaW1wb3J0IHsgRVZFTlRTIH0gZnJvbSBcIkBlZ2pzL2ZsaWNraW5nXCI7XHJcbiAqIEVWRU5UUy5NT1ZFX1NUQVJUOyAvLyBcIm1vdmVTdGFydFwiXHJcbiAqIGBgYFxyXG4gKi9cbnZhciBFVkVOVFMgPSB7XG4gIFJFQURZOiBcInJlYWR5XCIsXG4gIEJFRk9SRV9SRVNJWkU6IFwiYmVmb3JlUmVzaXplXCIsXG4gIEFGVEVSX1JFU0laRTogXCJhZnRlclJlc2l6ZVwiLFxuICBIT0xEX1NUQVJUOiBcImhvbGRTdGFydFwiLFxuICBIT0xEX0VORDogXCJob2xkRW5kXCIsXG4gIE1PVkVfU1RBUlQ6IFwibW92ZVN0YXJ0XCIsXG4gIE1PVkU6IFwibW92ZVwiLFxuICBNT1ZFX0VORDogXCJtb3ZlRW5kXCIsXG4gIFdJTExfQ0hBTkdFOiBcIndpbGxDaGFuZ2VcIixcbiAgQ0hBTkdFRDogXCJjaGFuZ2VkXCIsXG4gIFdJTExfUkVTVE9SRTogXCJ3aWxsUmVzdG9yZVwiLFxuICBSRVNUT1JFRDogXCJyZXN0b3JlZFwiLFxuICBTRUxFQ1Q6IFwic2VsZWN0XCIsXG4gIE5FRURfUEFORUw6IFwibmVlZFBhbmVsXCIsXG4gIFZJU0lCTEVfQ0hBTkdFOiBcInZpc2libGVDaGFuZ2VcIixcbiAgUkVBQ0hfRURHRTogXCJyZWFjaEVkZ2VcIixcbiAgUEFORUxfQ0hBTkdFOiBcInBhbmVsQ2hhbmdlXCJcbn07XG4vKipcclxuICogQW4gb2JqZWN0IHdpdGggYWxsIHBvc3NpYmxlIHByZWRlZmluZWQgbGl0ZXJhbCBzdHJpbmcgZm9yIHRoZSB7QGxpbmsgRmxpY2tpbmcjYWxpZ24gYWxpZ259IG9wdGlvblxyXG4gKiBAa28ge0BsaW5rIEZsaWNraW5nI2FsaWduIGFsaWdufSDsmLXshZjsl5Ag7IKs7Jqp65CY64qUIOuvuOumrCDsoJXsnZjrkJwg66as7YSw65+0IOyDgeyImOuTpOydhCDri7Tqs6Ag7J6I64qUIOqwneyytFxyXG4gKiBAdHlwZSB7b2JqZWN0fVxyXG4gKiBAcHJvcGVydHkge1wicHJldlwifSBQUkVWIGxlZnQvdG9wIGFsaWduPGtvPuyijC/sg4Eg7KCV66CsPC9rbz5cclxuICogQHByb3BlcnR5IHtcImNlbnRlclwifSBDRU5URVIgY2VudGVyIGFsaWduPGtvPuykkeyVmSDsoJXroKw8L2tvPlxyXG4gKiBAcHJvcGVydHkge1wibmV4dFwifSBORVhUIHJpZ2h0L2JvdHRvbSBhbGlnbjxrbz7smrAv7ZWYIOygleugrDwva28+XHJcbiAqL1xudmFyIEFMSUdOID0ge1xuICBQUkVWOiBcInByZXZcIixcbiAgQ0VOVEVSOiBcImNlbnRlclwiLFxuICBORVhUOiBcIm5leHRcIlxufTtcbi8qKlxyXG4gKiBBbiBvYmplY3Qgb2YgZGlyZWN0aW9uc1xyXG4gKiBAa28g67Cp7Zal7J2EIOuCmO2DgOuCtOuKlCDqsJLrk6TsnYQg64u06rOgIOyeiOuKlCDqsJ3ssrRcclxuICogQHR5cGUge29iamVjdH1cclxuICogQHByb3BlcnR5IHtcIlBSRVZcIn0gUFJFViBcImxlZnRcIiB3aGVuIHtAbGluayBGbGlja2luZyNob3Jpem9udGFsIGhvcml6b250YWx9IGlzIHRydWUsIGFuZCBcInRvcFwiIHdoZW4ge0BsaW5rIEZsaWNraW5nI2hvcml6b250YWwgaG9yaXpvbnRhbH0gaXMgZmFsc2VcclxuICogPGtvPntAbGluayBGbGlja2luZyNob3Jpem9udGFsIGhvcml6b250YWx96rCAIGB0cnVlYOydvCDqsr3smrAg7Jm87Kq9LCB7QGxpbmsgRmxpY2tpbmcjaG9yaXpvbnRhbCBob3Jpem9udGFsfeqwgCBgZmFsc2Vg7J28IOqyveyasCDsnITsqr3snYQg7J2Y66+47ZWp64uI64ukPC9rbz5cclxuICogQHByb3BlcnR5IHtcIk5FWFRcIn0gTkVYVCBcInJpZ2h0XCIgd2hlbiB7QGxpbmsgRmxpY2tpbmcjaG9yaXpvbnRhbCBob3Jpem9udGFsfSBpcyB0cnVlLCBhbmQgXCJib3R0b21cIiB3aGVuIHtAbGluayBGbGlja2luZyNob3Jpem9udGFsIGhvcml6b250YWx9IGlzIGZhbHNlXHJcbiAqIDxrbz57QGxpbmsgRmxpY2tpbmcjaG9yaXpvbnRhbCBob3Jpem9udGFsfeqwgCBgdHJ1ZWDsnbwg6rK97JqwIOyYpOuluOyqvSwge0BsaW5rIEZsaWNraW5nI2hvcml6b250YWwgaG9yaXpvbnRhbH3qsIAgYGZhbHNlYOydvCDqsr3smrAg7JWE656Y7Kq97J2EIOydmOuvuO2VqeuLiOuLpDwva28+XHJcbiAqIEBwcm9wZXJ0eSB7bnVsbH0gTk9ORSBUaGlzIHZhbHVlIHVzdWFsbHkgbWVhbnMgaXQncyB0aGUgc2FtZSBwb3NpdGlvbjxrbz7so7zroZwg7KCc7J6Q66as7J24IOqyveyasOulvCDsnZjrr7jtlanri4jri6Q8L2tvPlxyXG4gKi9cbnZhciBESVJFQ1RJT04gPSB7XG4gIFBSRVY6IFwiUFJFVlwiLFxuICBORVhUOiBcIk5FWFRcIixcbiAgTk9ORTogbnVsbFxufTtcbi8qKlxyXG4gKiBBbiBvYmplY3Qgd2l0aCBhbGwgcG9zc2libGUge0BsaW5rIEZsaWNraW5nI21vdmVUeXBlIG1vdmVUeXBlfXNcclxuICogQGtvIEZsaWNraW5n7J20IOygnOqzte2VmOuKlCB7QGxpbmsgRmxpY2tpbmcjbW92ZVR5cGUgbW92ZVR5cGV965Ok7J2EIOuLtOqzoCDsnojripQg6rCd7LK0XHJcbiAqIEB0eXBlIHtvYmplY3R9XHJcbiAqIEBwcm9wZXJ0eSB7XCJzbmFwXCJ9IFNOQVAgRmxpY2tpbmcncyB7QGxpbmsgRmxpY2tpbmcjbW92ZVR5cGUgbW92ZVR5cGV9IHRoYXQgZW5hYmxlcyB7QGxpbmsgU25hcENvbnRyb2x9IGFzIGEgRmxpY2tpbmcncyB7QGxpbmsgRmxpY2tpbmcjY29udHJvbCBjb250cm9sfVxyXG4gKiA8a28+RmxpY2tpbmfsnZgge0BsaW5rIEZsaWNraW5nI2NvbnRyb2wgY29udHJvbH3snYQge0BsaW5rIFNuYXBDb250cm9sfeuhnCDshKTsoJXtlZjqsowg7ZWY64qUIHtAbGluayBGbGlja2luZyNtb3ZlVHlwZSBtb3ZlVHlwZX08L2tvPlxyXG4gKiBAcHJvcGVydHkge1wiZnJlZVNjcm9sbFwifSBGUkVFX1NDUk9MTCBGbGlja2luZydzIHtAbGluayBGbGlja2luZyNtb3ZlVHlwZSBtb3ZlVHlwZX0gdGhhdCBlbmFibGVzIHtAbGluayBGcmVlQ29udHJvbH0gYXMgYSBGbGlja2luZydzIHtAbGluayBGbGlja2luZyNjb250cm9sIGNvbnRyb2x9XHJcbiAqIDxrbz5GbGlja2luZ+ydmCB7QGxpbmsgRmxpY2tpbmcjY29udHJvbCBjb250cm9sfeydhCB7QGxpbmsgRnJlZUNvbnRyb2x966GcIOyEpOygle2VmOqyjCDtlZjripQge0BsaW5rIEZsaWNraW5nI21vdmVUeXBlIG1vdmVUeXBlfTwva28+XHJcbiAqIEBwcm9wZXJ0eSB7XCJzdHJpY3RcIn0gU1RSSUNUIEZsaWNraW5nJ3Mge0BsaW5rIEZsaWNraW5nI21vdmVUeXBlIG1vdmVUeXBlfSB0aGF0IGVuYWJsZXMge0BsaW5rIFN0cmljdENvbnRyb2x9IGFzIGEgRmxpY2tpbmcncyB7QGxpbmsgRmxpY2tpbmcjY29udHJvbCBjb250cm9sfVxyXG4gKiA8a28+RmxpY2tpbmfsnZgge0BsaW5rIEZsaWNraW5nI2NvbnRyb2wgY29udHJvbH3snYQge0BsaW5rIFN0cmljdENvbnRyb2x966GcIOyEpOygle2VmOqyjCDtlZjripQge0BsaW5rIEZsaWNraW5nI21vdmVUeXBlIG1vdmVUeXBlfTwva28+XHJcbiAqL1xudmFyIE1PVkVfVFlQRSA9IHtcbiAgU05BUDogXCJzbmFwXCIsXG4gIEZSRUVfU0NST0xMOiBcImZyZWVTY3JvbGxcIixcbiAgU1RSSUNUOiBcInN0cmljdFwiXG59O1xudmFyIENMQVNTID0ge1xuICBWRVJUSUNBTDogXCJ2ZXJ0aWNhbFwiLFxuICBISURERU46IFwiZmxpY2tpbmctaGlkZGVuXCIsXG4gIERFRkFVTFRfVklSVFVBTDogXCJmbGlja2luZy1wYW5lbFwiXG59O1xuLyoqXHJcbiAqIEFuIG9iamVjdCB3aXRoIGFsbCBwb3NzaWJsZSB7QGxpbmsgRmxpY2tpbmcjY2lyY3VsYXJGYWxsYmFjayBjaXJjdWxhckZhbGxiYWNrfXNcclxuICogQGtvIEZsaWNraW5n7J2YIHtAbGluayBGbGlja2luZyNjaXJjdWxhckZhbGxiYWNrIGNpcmN1bGFyRmFsbGJhY2t97JeQIOyEpOyglSDqsIDriqXtlZwg6rCS65Ok7J2EIOuLtOqzoCDsnojripQg6rCd7LK0XHJcbiAqIEB0eXBlIHtvYmplY3R9XHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBMSU5FQVIgXCJsaW5lYXJcIlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gQk9VTkQgXCJib3VuZFwiXHJcbiAqL1xudmFyIENJUkNVTEFSX0ZBTExCQUNLID0ge1xuICBMSU5FQVI6IFwibGluZWFyXCIsXG4gIEJPVU5EOiBcImJvdW5kXCJcbn07XG4vKipcclxuICogQW4gb2JqZWN0IGZvciBpZGVudGlmeWluZyB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL2RpcmVjdGlvbiBkaXJlY3Rpb259IENTUyBwcm9wZXJ0eSBhcHBsaWVkIHRvIHRoZSBjYW1lcmEgZWxlbWVudChgLmZsaWNraW5nLWNhbWVyYWApXHJcbiAqIEBrbyDsubTrqZTrnbwg7JeY66as66i87Yq4KGAuZmxpY2tpbmctY2FtZXJhYCnsl5Ag7KCB7Jqp65CcIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvZGlyZWN0aW9uIGRpcmVjdGlvbn0gQ1NTIOyGjeyEseydhCDqtazrtoTtlZjquLAg7JyE7ZWcIOqwneyytFxyXG4gKiBAdHlwZSB7b2JqZWN0fVxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gTFRSIFwibHRyXCJcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IFJUTCBcInJ0bFwiXHJcbiAqL1xudmFyIE9SREVSID0ge1xuICBMVFI6IFwibHRyXCIsXG4gIFJUTDogXCJydGxcIlxufTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHlwZXNcbnZhciBtZXJnZSA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgdmFyIHNvdXJjZXMgPSBbXTtcbiAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICBzb3VyY2VzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICB9XG4gIHNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgT2JqZWN0LmtleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gdGFyZ2V0O1xufTtcbnZhciBnZXRFbGVtZW50ID0gZnVuY3Rpb24gKGVsLCBwYXJlbnQpIHtcbiAgdmFyIHRhcmdldEVsID0gbnVsbDtcbiAgaWYgKGlzU3RyaW5nKGVsKSkge1xuICAgIHZhciBwYXJlbnRFbCA9IHBhcmVudCA/IHBhcmVudCA6IGRvY3VtZW50O1xuICAgIHZhciBxdWVyeVJlc3VsdCA9IHBhcmVudEVsLnF1ZXJ5U2VsZWN0b3IoZWwpO1xuICAgIGlmICghcXVlcnlSZXN1bHQpIHtcbiAgICAgIHRocm93IG5ldyBGbGlja2luZ0Vycm9yKE1FU1NBR0UuRUxFTUVOVF9OT1RfRk9VTkQoZWwpLCBDT0RFLkVMRU1FTlRfTk9UX0ZPVU5EKTtcbiAgICB9XG4gICAgdGFyZ2V0RWwgPSBxdWVyeVJlc3VsdDtcbiAgfSBlbHNlIGlmIChlbCAmJiBlbC5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICB0YXJnZXRFbCA9IGVsO1xuICB9XG4gIGlmICghdGFyZ2V0RWwpIHtcbiAgICB0aHJvdyBuZXcgRmxpY2tpbmdFcnJvcihNRVNTQUdFLldST05HX1RZUEUoZWwsIFtcIkhUTUxFbGVtZW50XCIsIFwic3RyaW5nXCJdKSwgQ09ERS5XUk9OR19UWVBFKTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0RWw7XG59O1xudmFyIGNoZWNrRXhpc3RlbmNlID0gZnVuY3Rpb24gKHZhbHVlLCBuYW1lT25FcnJNc2cpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRmxpY2tpbmdFcnJvcihNRVNTQUdFLlZBTF9NVVNUX05PVF9OVUxMKHZhbHVlLCBuYW1lT25FcnJNc2cpLCBDT0RFLlZBTF9NVVNUX05PVF9OVUxMKTtcbiAgfVxufTtcbnZhciBjbGFtcCQxID0gZnVuY3Rpb24gKHgsIG1pbiwgbWF4KSB7XG4gIHJldHVybiBNYXRoLm1heChNYXRoLm1pbih4LCBtYXgpLCBtaW4pO1xufTtcbnZhciBnZXRGbGlja2luZ0F0dGFjaGVkID0gZnVuY3Rpb24gKHZhbCkge1xuICBpZiAoIXZhbCkge1xuICAgIHRocm93IG5ldyBGbGlja2luZ0Vycm9yKE1FU1NBR0UuTk9UX0FUVEFDSEVEX1RPX0ZMSUNLSU5HLCBDT0RFLk5PVF9BVFRBQ0hFRF9UT19GTElDS0lORyk7XG4gIH1cbiAgcmV0dXJuIHZhbDtcbn07XG52YXIgdG9BcnJheSQyID0gZnVuY3Rpb24gKGl0ZXJhYmxlKSB7XG4gIHJldHVybiBbXS5zbGljZS5jYWxsKGl0ZXJhYmxlKTtcbn07XG52YXIgcGFyc2VBbGlnbiQxID0gZnVuY3Rpb24gKGFsaWduLCBzaXplKSB7XG4gIHZhciBhbGlnblBvaW50O1xuICBpZiAoaXNTdHJpbmcoYWxpZ24pKSB7XG4gICAgc3dpdGNoIChhbGlnbikge1xuICAgICAgY2FzZSBBTElHTi5QUkVWOlxuICAgICAgICBhbGlnblBvaW50ID0gMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEFMSUdOLkNFTlRFUjpcbiAgICAgICAgYWxpZ25Qb2ludCA9IDAuNSAqIHNpemU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBBTElHTi5ORVhUOlxuICAgICAgICBhbGlnblBvaW50ID0gc2l6ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBhbGlnblBvaW50ID0gcGFyc2VBcml0aG1ldGljU2l6ZShhbGlnbiwgc2l6ZSk7XG4gICAgICAgIGlmIChhbGlnblBvaW50ID09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRmxpY2tpbmdFcnJvcihNRVNTQUdFLldST05HX09QVElPTihcImFsaWduXCIsIGFsaWduKSwgQ09ERS5XUk9OR19PUFRJT04pO1xuICAgICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGFsaWduUG9pbnQgPSBhbGlnbjtcbiAgfVxuICByZXR1cm4gYWxpZ25Qb2ludDtcbn07XG52YXIgcGFyc2VCb3VuY2UgPSBmdW5jdGlvbiAoYm91bmNlLCBzaXplKSB7XG4gIHZhciBwYXJzZWRCb3VuY2U7XG4gIGlmIChBcnJheS5pc0FycmF5KGJvdW5jZSkpIHtcbiAgICBwYXJzZWRCb3VuY2UgPSBib3VuY2UubWFwKGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHJldHVybiBwYXJzZUFyaXRobWV0aWNTaXplKHZhbCwgc2l6ZSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHBhcnNlZFZhbCA9IHBhcnNlQXJpdGhtZXRpY1NpemUoYm91bmNlLCBzaXplKTtcbiAgICBwYXJzZWRCb3VuY2UgPSBbcGFyc2VkVmFsLCBwYXJzZWRWYWxdO1xuICB9XG4gIHJldHVybiBwYXJzZWRCb3VuY2UubWFwKGZ1bmN0aW9uICh2YWwpIHtcbiAgICBpZiAodmFsID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBGbGlja2luZ0Vycm9yKE1FU1NBR0UuV1JPTkdfT1BUSU9OKFwiYm91bmNlXCIsIGJvdW5jZSksIENPREUuV1JPTkdfT1BUSU9OKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbDtcbiAgfSk7XG59O1xudmFyIHBhcnNlQXJpdGhtZXRpY1NpemUgPSBmdW5jdGlvbiAoY3NzVmFsdWUsIGJhc2UpIHtcbiAgdmFyIHBhcnNlZCA9IHBhcnNlQXJpdGhtZXRpY0V4cHJlc3Npb24oY3NzVmFsdWUpO1xuICBpZiAocGFyc2VkID09IG51bGwpIHJldHVybiBudWxsO1xuICByZXR1cm4gcGFyc2VkLnBlcmNlbnRhZ2UgKiBiYXNlICsgcGFyc2VkLmFic29sdXRlO1xufTtcbnZhciBwYXJzZUFyaXRobWV0aWNFeHByZXNzaW9uID0gZnVuY3Rpb24gKGNzc1ZhbHVlKSB7XG4gIHZhciBjc3NSZWdleCA9IC8oPzooXFwrfFxcLSlcXHMqKT8oXFxkKyg/OlxcLlxcZCspPyglfHB4KT8pL2c7XG4gIGlmICh0eXBlb2YgY3NzVmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcGVyY2VudGFnZTogMCxcbiAgICAgIGFic29sdXRlOiBjc3NWYWx1ZVxuICAgIH07XG4gIH1cbiAgdmFyIHBhcnNlZCA9IHtcbiAgICBwZXJjZW50YWdlOiAwLFxuICAgIGFic29sdXRlOiAwXG4gIH07XG4gIHZhciBpZHggPSAwO1xuICB2YXIgbWF0Y2hSZXN1bHQgPSBjc3NSZWdleC5leGVjKGNzc1ZhbHVlKTtcbiAgd2hpbGUgKG1hdGNoUmVzdWx0ICE9IG51bGwpIHtcbiAgICB2YXIgc2lnbiA9IG1hdGNoUmVzdWx0WzFdO1xuICAgIHZhciB2YWx1ZSA9IG1hdGNoUmVzdWx0WzJdO1xuICAgIHZhciB1bml0ID0gbWF0Y2hSZXN1bHRbM107XG4gICAgdmFyIHBhcnNlZFZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgaWYgKGlkeCA8PSAwKSB7XG4gICAgICBzaWduID0gc2lnbiB8fCBcIitcIjtcbiAgICB9XG4gICAgLy8gUmV0dXJuIGRlZmF1bHQgdmFsdWUgZm9yIHZhbHVlcyBub3QgaW4gZ29vZCBmb3JtXG4gICAgaWYgKCFzaWduKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIHNpZ25NdWx0aXBsaWVyID0gc2lnbiA9PT0gXCIrXCIgPyAxIDogLTE7XG4gICAgaWYgKHVuaXQgPT09IFwiJVwiKSB7XG4gICAgICBwYXJzZWQucGVyY2VudGFnZSArPSBzaWduTXVsdGlwbGllciAqIChwYXJzZWRWYWx1ZSAvIDEwMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcnNlZC5hYnNvbHV0ZSArPSBzaWduTXVsdGlwbGllciAqIHBhcnNlZFZhbHVlO1xuICAgIH1cbiAgICAvLyBNYXRjaCBuZXh0IG9jY3VycmVuY2VcbiAgICArK2lkeDtcbiAgICBtYXRjaFJlc3VsdCA9IGNzc1JlZ2V4LmV4ZWMoY3NzVmFsdWUpO1xuICB9XG4gIC8vIE5vbmUtbWF0Y2hlZFxuICBpZiAoaWR4ID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIHBhcnNlZDtcbn07XG52YXIgcGFyc2VDU1NTaXplVmFsdWUgPSBmdW5jdGlvbiAodmFsKSB7XG4gIHJldHVybiBpc1N0cmluZyh2YWwpID8gdmFsIDogdmFsICsgXCJweFwiO1xufTtcbnZhciBwYXJzZVBhbmVsQWxpZ24gPSBmdW5jdGlvbiAoYWxpZ24pIHtcbiAgcmV0dXJuIHR5cGVvZiBhbGlnbiA9PT0gXCJvYmplY3RcIiA/IGFsaWduLnBhbmVsIDogYWxpZ247XG59O1xudmFyIGdldERpcmVjdGlvbiQxID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSBlbmQpIHJldHVybiBESVJFQ1RJT04uTk9ORTtcbiAgcmV0dXJuIHN0YXJ0IDwgZW5kID8gRElSRUNUSU9OLk5FWFQgOiBESVJFQ1RJT04uUFJFVjtcbn07XG52YXIgcGFyc2VFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGVsZW1lbnQpKSB7XG4gICAgZWxlbWVudCA9IFtlbGVtZW50XTtcbiAgfVxuICB2YXIgZWxlbWVudHMgPSBbXTtcbiAgZWxlbWVudC5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgIGlmIChpc1N0cmluZyhlbCkpIHtcbiAgICAgIHZhciB0ZW1wRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIHRlbXBEaXYuaW5uZXJIVE1MID0gZWw7XG4gICAgICBlbGVtZW50cy5wdXNoLmFwcGx5KGVsZW1lbnRzLCBfX3NwcmVhZCQxKHRvQXJyYXkkMih0ZW1wRGl2LmNoaWxkcmVuKSkpO1xuICAgICAgd2hpbGUgKHRlbXBEaXYuZmlyc3RDaGlsZCkge1xuICAgICAgICB0ZW1wRGl2LnJlbW92ZUNoaWxkKHRlbXBEaXYuZmlyc3RDaGlsZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbCAmJiBlbC5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgIGVsZW1lbnRzLnB1c2goZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRmxpY2tpbmdFcnJvcihNRVNTQUdFLldST05HX1RZUEUoZWwsIFtcIkhUTUxFbGVtZW50XCIsIFwic3RyaW5nXCJdKSwgQ09ERS5XUk9OR19UWVBFKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gZWxlbWVudHM7XG59O1xudmFyIGdldE1pbnVzQ29tcGVuc2F0ZWRJbmRleCA9IGZ1bmN0aW9uIChpZHgsIG1heCkge1xuICByZXR1cm4gaWR4IDwgMCA/IGNsYW1wJDEoaWR4ICsgbWF4LCAwLCBtYXgpIDogY2xhbXAkMShpZHgsIDAsIG1heCk7XG59O1xudmFyIGluY2x1ZGVzID0gZnVuY3Rpb24gKGFycmF5LCB0YXJnZXQpIHtcbiAgdmFyIGVfMSwgX2E7XG4gIHRyeSB7XG4gICAgZm9yICh2YXIgYXJyYXlfMSA9IF9fdmFsdWVzJDEoYXJyYXkpLCBhcnJheV8xXzEgPSBhcnJheV8xLm5leHQoKTsgIWFycmF5XzFfMS5kb25lOyBhcnJheV8xXzEgPSBhcnJheV8xLm5leHQoKSkge1xuICAgICAgdmFyIHZhbCA9IGFycmF5XzFfMS52YWx1ZTtcbiAgICAgIGlmICh2YWwgPT09IHRhcmdldCkgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9IGNhdGNoIChlXzFfMSkge1xuICAgIGVfMSA9IHtcbiAgICAgIGVycm9yOiBlXzFfMVxuICAgIH07XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChhcnJheV8xXzEgJiYgIWFycmF5XzFfMS5kb25lICYmIChfYSA9IGFycmF5XzEucmV0dXJuKSkgX2EuY2FsbChhcnJheV8xKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xudmFyIGlzU3RyaW5nID0gZnVuY3Rpb24gKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gXCJzdHJpbmdcIjtcbn07XG52YXIgY2lyY3VsYXRlUG9zaXRpb24gPSBmdW5jdGlvbiAocG9zLCBtaW4sIG1heCkge1xuICB2YXIgc2l6ZSA9IG1heCAtIG1pbjtcbiAgaWYgKHBvcyA8IG1pbikge1xuICAgIHZhciBvZmZzZXQgPSAobWluIC0gcG9zKSAlIHNpemU7XG4gICAgcG9zID0gbWF4IC0gb2Zmc2V0O1xuICB9IGVsc2UgaWYgKHBvcyA+IG1heCkge1xuICAgIHZhciBvZmZzZXQgPSAocG9zIC0gbWF4KSAlIHNpemU7XG4gICAgcG9zID0gbWluICsgb2Zmc2V0O1xuICB9XG4gIHJldHVybiBwb3M7XG59O1xudmFyIGZpbmQkMSA9IGZ1bmN0aW9uIChhcnJheSwgY2hlY2tlcikge1xuICB2YXIgZV8yLCBfYTtcbiAgdHJ5IHtcbiAgICBmb3IgKHZhciBhcnJheV8yID0gX192YWx1ZXMkMShhcnJheSksIGFycmF5XzJfMSA9IGFycmF5XzIubmV4dCgpOyAhYXJyYXlfMl8xLmRvbmU7IGFycmF5XzJfMSA9IGFycmF5XzIubmV4dCgpKSB7XG4gICAgICB2YXIgdmFsID0gYXJyYXlfMl8xLnZhbHVlO1xuICAgICAgaWYgKGNoZWNrZXIodmFsKSkge1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZV8yXzEpIHtcbiAgICBlXzIgPSB7XG4gICAgICBlcnJvcjogZV8yXzFcbiAgICB9O1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoYXJyYXlfMl8xICYmICFhcnJheV8yXzEuZG9uZSAmJiAoX2EgPSBhcnJheV8yLnJldHVybikpIF9hLmNhbGwoYXJyYXlfMik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChlXzIpIHRocm93IGVfMi5lcnJvcjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xudmFyIGZpbmRSaWdodCA9IGZ1bmN0aW9uIChhcnJheSwgY2hlY2tlcikge1xuICBmb3IgKHZhciBpZHggPSBhcnJheS5sZW5ndGggLSAxOyBpZHggPj0gMDsgaWR4LS0pIHtcbiAgICB2YXIgdmFsID0gYXJyYXlbaWR4XTtcbiAgICBpZiAoY2hlY2tlcih2YWwpKSB7XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG52YXIgZmluZEluZGV4ID0gZnVuY3Rpb24gKGFycmF5LCBjaGVja2VyKSB7XG4gIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IGFycmF5Lmxlbmd0aDsgaWR4KyspIHtcbiAgICBpZiAoY2hlY2tlcihhcnJheVtpZHhdKSkge1xuICAgICAgcmV0dXJuIGlkeDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufTtcbnZhciBnZXRQcm9ncmVzcyA9IGZ1bmN0aW9uIChwb3MsIHByZXYsIG5leHQpIHtcbiAgcmV0dXJuIChwb3MgLSBwcmV2KSAvIChuZXh0IC0gcHJldik7XG59O1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2Vzc1xudmFyIGdldFN0eWxlID0gZnVuY3Rpb24gKGVsKSB7XG4gIHJldHVybiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCkgfHwgZWwuY3VycmVudFN0eWxlO1xufTtcbnZhciBzZXRTaXplID0gZnVuY3Rpb24gKGVsLCBfYSkge1xuICB2YXIgd2lkdGggPSBfYS53aWR0aCxcbiAgICBoZWlnaHQgPSBfYS5oZWlnaHQ7XG4gIGlmICh3aWR0aCAhPSBudWxsKSB7XG4gICAgaWYgKGlzU3RyaW5nKHdpZHRoKSkge1xuICAgICAgZWwuc3R5bGUud2lkdGggPSB3aWR0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc3R5bGUud2lkdGggPSB3aWR0aCArIFwicHhcIjtcbiAgICB9XG4gIH1cbiAgaWYgKGhlaWdodCAhPSBudWxsKSB7XG4gICAgaWYgKGlzU3RyaW5nKGhlaWdodCkpIHtcbiAgICAgIGVsLnN0eWxlLmhlaWdodCA9IGhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgXCJweFwiO1xuICAgIH1cbiAgfVxufTtcbnZhciBpc0JldHdlZW4gPSBmdW5jdGlvbiAodmFsLCBtaW4sIG1heCkge1xuICByZXR1cm4gdmFsID49IG1pbiAmJiB2YWwgPD0gbWF4O1xufTtcbnZhciBjaXJjdWxhdGVJbmRleCA9IGZ1bmN0aW9uIChpbmRleCwgbWF4KSB7XG4gIGlmIChpbmRleCA+PSBtYXgpIHtcbiAgICByZXR1cm4gaW5kZXggJSBtYXg7XG4gIH0gZWxzZSBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIGdldE1pbnVzQ29tcGVuc2F0ZWRJbmRleCgoaW5kZXggKyAxKSAlIG1heCAtIDEsIG1heCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG59O1xudmFyIHJhbmdlID0gZnVuY3Rpb24gKGVuZCkge1xuICB2YXIgYXJyID0gbmV3IEFycmF5KGVuZCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZW5kOyBpKyspIHtcbiAgICBhcnJbaV0gPSBpO1xuICB9XG4gIHJldHVybiBhcnI7XG59O1xudmFyIGdldEVsZW1lbnRTaXplID0gZnVuY3Rpb24gKF9hKSB7XG4gIHZhciBlbCA9IF9hLmVsLFxuICAgIGhvcml6b250YWwgPSBfYS5ob3Jpem9udGFsLFxuICAgIHVzZUZyYWN0aW9uYWxTaXplID0gX2EudXNlRnJhY3Rpb25hbFNpemUsXG4gICAgdXNlT2Zmc2V0ID0gX2EudXNlT2Zmc2V0LFxuICAgIHN0eWxlID0gX2Euc3R5bGU7XG4gIHZhciBzaXplID0gMDtcbiAgaWYgKHVzZUZyYWN0aW9uYWxTaXplKSB7XG4gICAgdmFyIGJhc2VTaXplID0gcGFyc2VGbG9hdChob3Jpem9udGFsID8gc3R5bGUud2lkdGggOiBzdHlsZS5oZWlnaHQpIHx8IDA7XG4gICAgdmFyIGlzQm9yZGVyQm94U2l6aW5nID0gc3R5bGUuYm94U2l6aW5nID09PSBcImJvcmRlci1ib3hcIjtcbiAgICB2YXIgYm9yZGVyID0gaG9yaXpvbnRhbCA/IHBhcnNlRmxvYXQoc3R5bGUuYm9yZGVyTGVmdFdpZHRoIHx8IFwiMFwiKSArIHBhcnNlRmxvYXQoc3R5bGUuYm9yZGVyUmlnaHRXaWR0aCB8fCBcIjBcIikgOiBwYXJzZUZsb2F0KHN0eWxlLmJvcmRlclRvcFdpZHRoIHx8IFwiMFwiKSArIHBhcnNlRmxvYXQoc3R5bGUuYm9yZGVyQm90dG9tV2lkdGggfHwgXCIwXCIpO1xuICAgIGlmIChpc0JvcmRlckJveFNpemluZykge1xuICAgICAgc2l6ZSA9IHVzZU9mZnNldCA/IGJhc2VTaXplIDogYmFzZVNpemUgLSBib3JkZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwYWRkaW5nID0gaG9yaXpvbnRhbCA/IHBhcnNlRmxvYXQoc3R5bGUucGFkZGluZ0xlZnQgfHwgXCIwXCIpICsgcGFyc2VGbG9hdChzdHlsZS5wYWRkaW5nUmlnaHQgfHwgXCIwXCIpIDogcGFyc2VGbG9hdChzdHlsZS5wYWRkaW5nVG9wIHx8IFwiMFwiKSArIHBhcnNlRmxvYXQoc3R5bGUucGFkZGluZ0JvdHRvbSB8fCBcIjBcIik7XG4gICAgICBzaXplID0gdXNlT2Zmc2V0ID8gYmFzZVNpemUgKyBwYWRkaW5nICsgYm9yZGVyIDogYmFzZVNpemUgKyBwYWRkaW5nO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgc2l6ZVN0ciA9IGhvcml6b250YWwgPyBcIldpZHRoXCIgOiBcIkhlaWdodFwiO1xuICAgIHNpemUgPSB1c2VPZmZzZXQgPyBlbFtcIm9mZnNldFwiICsgc2l6ZVN0cl0gOiBlbFtcImNsaWVudFwiICsgc2l6ZVN0cl07XG4gIH1cbiAgcmV0dXJuIE1hdGgubWF4KHNpemUsIDApO1xufTtcbnZhciBzZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiAob2JqLCBwcm90bykge1xuICBvYmouX19wcm90b19fID0gcHJvdG87XG4gIHJldHVybiBvYmo7XG59O1xuXG4vKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgTkFWRVIgQ29ycC5cclxuICogZWdqcyBwcm9qZWN0cyBhcmUgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xuLyoqXHJcbiAqIFNwZWNpYWwgdHlwZSBvZiBrbm93biBlcnJvciB0aGF0IHtAbGluayBGbGlja2luZ30gdGhyb3dzLlxyXG4gKiBAa28gRmxpY2tpbmcg64K067aA7JeQ7IScIOyVjOugpOynhCDsmKTrpZgg67Cc7IOd7IucIHRocm9365CY64qUIOyXkOufrFxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gY29kZSBFcnJvciBjb2RlPGtvPuyXkOufrCDsvZTrk5w8L2tvPlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbWVzc2FnZSBFcnJvciBtZXNzYWdlPGtvPuyXkOufrCDrqZTsi5zsp4A8L2tvPlxyXG4gKiBAc2VlIHtAbGluayBFUlJPUl9DT0RFIEVSUk9SX0NPREV9XHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYHRzXHJcbiAqIGltcG9ydCBGbGlja2luZywgeyBGbGlja2luZ0Vycm9yLCBFUlJPUl9DT0RFUyB9IGZyb20gXCJAZWdqcy9mbGlja2luZ1wiO1xyXG4gKiB0cnkge1xyXG4gKiAgIGNvbnN0IGZsaWNraW5nID0gbmV3IEZsaWNraW5nKFwiLmZsaWNraW5nLXZpZXdwb3J0XCIpXHJcbiAqIH0gY2F0Y2ggKGUpIHtcclxuICogICBpZiAoZSBpbnN0YW5jZW9mIEZsaWNraW5nRXJyb3IgJiYgZS5jb2RlID09PSBFUlJPUl9DT0RFUy5FTEVNRU5UX05PVF9GT1VORCkge1xyXG4gKiAgICAgY29uc29sZS5lcnJvcihcIkVsZW1lbnQgbm90IGZvdW5kXCIpXHJcbiAqICAgfVxyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKi9cbnZhciBGbGlja2luZ0Vycm9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzJDMoRmxpY2tpbmdFcnJvciwgX3N1cGVyKTtcbiAgLyoqXHJcbiAgICogQHBhcmFtIG1lc3NhZ2UgRXJyb3IgbWVzc2FnZTxrbz7sl5Drn6wg66mU7Iuc7KeAPC9rbz5cclxuICAgKiBAcGFyYW0gY29kZSBFcnJvciBjb2RlPGtvPuyXkOufrCDsvZTrk5w8L2tvPlxyXG4gICAqL1xuICBmdW5jdGlvbiBGbGlja2luZ0Vycm9yKG1lc3NhZ2UsIGNvZGUpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBtZXNzYWdlKSB8fCB0aGlzO1xuICAgIHNldFByb3RvdHlwZU9mKF90aGlzLCBGbGlja2luZ0Vycm9yLnByb3RvdHlwZSk7XG4gICAgX3RoaXMubmFtZSA9IFwiRmxpY2tpbmdFcnJvclwiO1xuICAgIF90aGlzLmNvZGUgPSBjb2RlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICByZXR1cm4gRmxpY2tpbmdFcnJvcjtcbn0oRXJyb3IpO1xuXG4vKipcclxuICogQSBjb21wb25lbnQgdGhhdCBtYW5hZ2VzIHZpZXdwb3J0IHNpemVcclxuICogQGtvIOu3sO2PrO2KuCDtgazquLAg7KCV67O066W8IOuLtOuLue2VmOuKlCDsu7Ttj6zrhIztirhcclxuICovXG52YXIgVmlld3BvcnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcclxuICAgKiBAcGFyYW0gZWwgQSB2aWV3cG9ydCBlbGVtZW50PGtvPuu3sO2PrO2KuCDsl5jrpqzrqLztirg8L2tvPlxyXG4gICAqL1xuICBmdW5jdGlvbiBWaWV3cG9ydChmbGlja2luZywgZWwpIHtcbiAgICB0aGlzLl9mbGlja2luZyA9IGZsaWNraW5nO1xuICAgIHRoaXMuX2VsID0gZWw7XG4gICAgdGhpcy5fd2lkdGggPSAwO1xuICAgIHRoaXMuX2hlaWdodCA9IDA7XG4gICAgdGhpcy5fcGFkZGluZyA9IHtcbiAgICAgIGxlZnQ6IDAsXG4gICAgICByaWdodDogMCxcbiAgICAgIHRvcDogMCxcbiAgICAgIGJvdHRvbTogMFxuICAgIH07XG4gICAgdGhpcy5faXNCb3JkZXJCb3hTaXppbmcgPSBmYWxzZTtcbiAgfVxuICB2YXIgX19wcm90byA9IFZpZXdwb3J0LnByb3RvdHlwZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwiZWxlbWVudFwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBBIHZpZXdwb3J0KHJvb3QpIGVsZW1lbnRcclxuICAgICAqIEBrbyDrt7Dtj6ztirgocm9vdCkg7JeY66as66i87Yq4XHJcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2VsO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJ3aWR0aFwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBWaWV3cG9ydCB3aWR0aCwgd2l0aG91dCBwYWRkaW5nc1xyXG4gICAgICogQGtvIOu3sO2PrO2KuCDrhIjruYRcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3dpZHRoIC0gdGhpcy5fcGFkZGluZy5sZWZ0IC0gdGhpcy5fcGFkZGluZy5yaWdodDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwiaGVpZ2h0XCIsIHtcbiAgICAvKipcclxuICAgICAqIFZpZXdwb3J0IGhlaWdodCwgd2l0aG91dCBwYWRkaW5nc1xyXG4gICAgICogQGtvIOu3sO2PrO2KuCDrhpLsnbRcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2hlaWdodCAtIHRoaXMuX3BhZGRpbmcudG9wIC0gdGhpcy5fcGFkZGluZy5ib3R0b207XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcInBhZGRpbmdcIiwge1xuICAgIC8qKlxyXG4gICAgICogVmlld3BvcnQgcGFkZGluZ3NcclxuICAgICAqIEBrbyDrt7Dtj6ztirggQ1NTIHBhZGRpbmcg6rCSXHJcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGxlZnQgQ1NTIGBwYWRkaW5nLWxlZnRgXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gcmlnaHQgQ1NTIGBwYWRkaW5nLXJpZ2h0YFxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHRvcCBDU1MgYHBhZGRpbmctdG9wYFxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGJvdHRvbSBDU1MgYHBhZGRpbmctYm90dG9tYFxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wYWRkaW5nO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICAvKipcclxuICAgKiBDaGFuZ2Ugdmlld3BvcnQncyBzaXplLlxyXG4gICAqIFRoaXMgd2lsbCBjaGFuZ2UgdGhlIGFjdHVhbCBzaXplIG9mIGAuZmxpY2tpbmctdmlld3BvcnRgIGVsZW1lbnQgYnkgY2hhbmdpbmcgaXRzIENTUyB3aWR0aC9oZWlnaHQgcHJvcGVydHlcclxuICAgKiBAa28g67ew7Y+s7Yq4IO2BrOq4sOulvCDrs4Dqsr3tlanri4jri6QuXHJcbiAgICogYC5mbGlja2luZy12aWV3cG9ydGAg7JeY66as66i87Yq47JeQIO2VtOuLuSDtgazquLDsnZggQ1NTIHdpZHRoL2hlaWdodOulvCDsoIHsmqntlanri4jri6RcclxuICAgKiBAcGFyYW0ge29iamVjdH0gW3NpemVdIE5ldyB2aWV3cG9ydCBzaXplPGtvPuyDiCDrt7Dtj6ztirgg7YGs6riwPC9rbz5cclxuICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtzaXplLndpZHRoXSBDU1Mgc3RyaW5nIG9yIG51bWJlcihpbiBweCk8a28+Q1NTIOusuOyekOyXtCDrmJDripQg7Iir7J6QKHB4KTwva28+XHJcbiAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbc2l6ZS5oZWlnaHRdIENTUyBzdHJpbmcgb3IgbnVtYmVyKGluIHB4KTxrbz5DU1Mg66y47J6Q7Je0IOuYkOuKlCDsiKvsnpAocHgpPC9rbz5cclxuICAgKi9cbiAgX19wcm90by5zZXRTaXplID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIHdpZHRoID0gX2Eud2lkdGgsXG4gICAgICBoZWlnaHQgPSBfYS5oZWlnaHQ7XG4gICAgdmFyIGVsID0gdGhpcy5fZWw7XG4gICAgdmFyIHBhZGRpbmcgPSB0aGlzLl9wYWRkaW5nO1xuICAgIHZhciBpc0JvcmRlckJveFNpemluZyA9IHRoaXMuX2lzQm9yZGVyQm94U2l6aW5nO1xuICAgIGlmICh3aWR0aCAhPSBudWxsKSB7XG4gICAgICBpZiAoaXNTdHJpbmcod2lkdGgpKSB7XG4gICAgICAgIGVsLnN0eWxlLndpZHRoID0gd2lkdGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbmV3V2lkdGggPSBpc0JvcmRlckJveFNpemluZyA/IHdpZHRoICsgcGFkZGluZy5sZWZ0ICsgcGFkZGluZy5yaWdodCA6IHdpZHRoO1xuICAgICAgICBlbC5zdHlsZS53aWR0aCA9IG5ld1dpZHRoICsgXCJweFwiO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaGVpZ2h0ICE9IG51bGwpIHtcbiAgICAgIGlmIChpc1N0cmluZyhoZWlnaHQpKSB7XG4gICAgICAgIGVsLnN0eWxlLmhlaWdodCA9IGhlaWdodDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBuZXdIZWlnaHQgPSBpc0JvcmRlckJveFNpemluZyA/IGhlaWdodCArIHBhZGRpbmcudG9wICsgcGFkZGluZy5ib3R0b20gOiBoZWlnaHQ7XG4gICAgICAgIGVsLnN0eWxlLmhlaWdodCA9IG5ld0hlaWdodCArIFwicHhcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5yZXNpemUoKTtcbiAgfTtcbiAgLyoqXHJcbiAgICogVXBkYXRlIHdpZHRoL2hlaWdodCB0byB0aGUgY3VycmVudCB2aWV3cG9ydCBlbGVtZW50J3Mgc2l6ZVxyXG4gICAqIEBrbyDtmITsnqwg67ew7Y+s7Yq4IOyXmOumrOuovO2KuOydmCDtgazquLDroZwg64SI67mEL+uGkuydtOulvCDsl4XrjbDsnbTtirjtlanri4jri6RcclxuICAgKi9cbiAgX19wcm90by5yZXNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVsID0gdGhpcy5fZWw7XG4gICAgdmFyIGVsU3R5bGUgPSBnZXRTdHlsZShlbCk7XG4gICAgdmFyIHVzZUZyYWN0aW9uYWxTaXplID0gdGhpcy5fZmxpY2tpbmcudXNlRnJhY3Rpb25hbFNpemU7XG4gICAgdGhpcy5fd2lkdGggPSBnZXRFbGVtZW50U2l6ZSh7XG4gICAgICBlbDogZWwsXG4gICAgICBob3Jpem9udGFsOiB0cnVlLFxuICAgICAgdXNlRnJhY3Rpb25hbFNpemU6IHVzZUZyYWN0aW9uYWxTaXplLFxuICAgICAgdXNlT2Zmc2V0OiBmYWxzZSxcbiAgICAgIHN0eWxlOiBlbFN0eWxlXG4gICAgfSk7XG4gICAgdGhpcy5faGVpZ2h0ID0gZ2V0RWxlbWVudFNpemUoe1xuICAgICAgZWw6IGVsLFxuICAgICAgaG9yaXpvbnRhbDogZmFsc2UsXG4gICAgICB1c2VGcmFjdGlvbmFsU2l6ZTogdXNlRnJhY3Rpb25hbFNpemUsXG4gICAgICB1c2VPZmZzZXQ6IGZhbHNlLFxuICAgICAgc3R5bGU6IGVsU3R5bGVcbiAgICB9KTtcbiAgICB0aGlzLl9wYWRkaW5nID0ge1xuICAgICAgbGVmdDogZWxTdHlsZS5wYWRkaW5nTGVmdCA/IHBhcnNlRmxvYXQoZWxTdHlsZS5wYWRkaW5nTGVmdCkgOiAwLFxuICAgICAgcmlnaHQ6IGVsU3R5bGUucGFkZGluZ1JpZ2h0ID8gcGFyc2VGbG9hdChlbFN0eWxlLnBhZGRpbmdSaWdodCkgOiAwLFxuICAgICAgdG9wOiBlbFN0eWxlLnBhZGRpbmdUb3AgPyBwYXJzZUZsb2F0KGVsU3R5bGUucGFkZGluZ1RvcCkgOiAwLFxuICAgICAgYm90dG9tOiBlbFN0eWxlLnBhZGRpbmdCb3R0b20gPyBwYXJzZUZsb2F0KGVsU3R5bGUucGFkZGluZ0JvdHRvbSkgOiAwXG4gICAgfTtcbiAgICB0aGlzLl9pc0JvcmRlckJveFNpemluZyA9IGVsU3R5bGUuYm94U2l6aW5nID09PSBcImJvcmRlci1ib3hcIjtcbiAgfTtcbiAgcmV0dXJuIFZpZXdwb3J0O1xufSgpO1xuXG52YXIgQXV0b1Jlc2l6ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBBdXRvUmVzaXplcihmbGlja2luZykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdGhpcy5fb25SZXNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZmxpY2tpbmcgPSBfdGhpcy5fZmxpY2tpbmc7XG4gICAgICB2YXIgcmVzaXplRGVib3VuY2UgPSBmbGlja2luZy5yZXNpemVEZWJvdW5jZTtcbiAgICAgIHZhciBtYXhSZXNpemVEZWJvdW5jZSA9IGZsaWNraW5nLm1heFJlc2l6ZURlYm91bmNlO1xuICAgICAgaWYgKHJlc2l6ZURlYm91bmNlIDw9IDApIHtcbiAgICAgICAgdm9pZCBmbGlja2luZy5yZXNpemUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChfdGhpcy5fbWF4UmVzaXplRGVib3VuY2VUaW1lciA8PSAwKSB7XG4gICAgICAgICAgaWYgKG1heFJlc2l6ZURlYm91bmNlID4gMCAmJiBtYXhSZXNpemVEZWJvdW5jZSA+PSByZXNpemVEZWJvdW5jZSkge1xuICAgICAgICAgICAgX3RoaXMuX21heFJlc2l6ZURlYm91bmNlVGltZXIgPSB3aW5kb3cuc2V0VGltZW91dChfdGhpcy5fZG9TY2hlZHVsZWRSZXNpemUsIG1heFJlc2l6ZURlYm91bmNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF90aGlzLl9yZXNpemVUaW1lciA+IDApIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQoX3RoaXMuX3Jlc2l6ZVRpbWVyKTtcbiAgICAgICAgICBfdGhpcy5fcmVzaXplVGltZXIgPSAwO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLl9yZXNpemVUaW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KF90aGlzLl9kb1NjaGVkdWxlZFJlc2l6ZSwgcmVzaXplRGVib3VuY2UpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5fZG9TY2hlZHVsZWRSZXNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBjbGVhclRpbWVvdXQoX3RoaXMuX3Jlc2l6ZVRpbWVyKTtcbiAgICAgIGNsZWFyVGltZW91dChfdGhpcy5fbWF4UmVzaXplRGVib3VuY2VUaW1lcik7XG4gICAgICBfdGhpcy5fbWF4UmVzaXplRGVib3VuY2VUaW1lciA9IC0xO1xuICAgICAgX3RoaXMuX3Jlc2l6ZVRpbWVyID0gLTE7XG4gICAgICB2b2lkIF90aGlzLl9mbGlja2luZy5yZXNpemUoKTtcbiAgICB9O1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbWVtYmVyLW9yZGVyaW5nXG4gICAgdGhpcy5fc2tpcEZpcnN0UmVzaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGlzRmlyc3RSZXNpemUgPSB0cnVlO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGlzRmlyc3RSZXNpemUpIHtcbiAgICAgICAgICBpc0ZpcnN0UmVzaXplID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLl9vblJlc2l6ZSgpO1xuICAgICAgfTtcbiAgICB9KCk7XG4gICAgdGhpcy5fZmxpY2tpbmcgPSBmbGlja2luZztcbiAgICB0aGlzLl9lbmFibGVkID0gZmFsc2U7XG4gICAgdGhpcy5fcmVzaXplT2JzZXJ2ZXIgPSBudWxsO1xuICAgIHRoaXMuX3Jlc2l6ZVRpbWVyID0gLTE7XG4gICAgdGhpcy5fbWF4UmVzaXplRGVib3VuY2VUaW1lciA9IC0xO1xuICB9XG4gIHZhciBfX3Byb3RvID0gQXV0b1Jlc2l6ZXIucHJvdG90eXBlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJlbmFibGVkXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9lbmFibGVkO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBfX3Byb3RvLmVuYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZmxpY2tpbmcgPSB0aGlzLl9mbGlja2luZztcbiAgICB2YXIgdmlld3BvcnQgPSBmbGlja2luZy52aWV3cG9ydDtcbiAgICBpZiAodGhpcy5fZW5hYmxlZCkge1xuICAgICAgdGhpcy5kaXNhYmxlKCk7XG4gICAgfVxuICAgIGlmIChmbGlja2luZy51c2VSZXNpemVPYnNlcnZlciAmJiAhIXdpbmRvdy5SZXNpemVPYnNlcnZlcikge1xuICAgICAgdmFyIHZpZXdwb3J0U2l6ZU5vdDAgPSB2aWV3cG9ydC53aWR0aCAhPT0gMCB8fCB2aWV3cG9ydC5oZWlnaHQgIT09IDA7XG4gICAgICB2YXIgcmVzaXplT2JzZXJ2ZXIgPSB2aWV3cG9ydFNpemVOb3QwID8gbmV3IFJlc2l6ZU9ic2VydmVyKHRoaXMuX3NraXBGaXJzdFJlc2l6ZSkgOiBuZXcgUmVzaXplT2JzZXJ2ZXIodGhpcy5fb25SZXNpemUpO1xuICAgICAgcmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZShmbGlja2luZy52aWV3cG9ydC5lbGVtZW50KTtcbiAgICAgIHRoaXMuX3Jlc2l6ZU9ic2VydmVyID0gcmVzaXplT2JzZXJ2ZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMuX29uUmVzaXplKTtcbiAgICB9XG4gICAgdGhpcy5fZW5hYmxlZCA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIF9fcHJvdG8uZGlzYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuX2VuYWJsZWQpIHJldHVybiB0aGlzO1xuICAgIHZhciByZXNpemVPYnNlcnZlciA9IHRoaXMuX3Jlc2l6ZU9ic2VydmVyO1xuICAgIGlmIChyZXNpemVPYnNlcnZlcikge1xuICAgICAgcmVzaXplT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgdGhpcy5fcmVzaXplT2JzZXJ2ZXIgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLl9vblJlc2l6ZSk7XG4gICAgfVxuICAgIHRoaXMuX2VuYWJsZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgcmV0dXJuIEF1dG9SZXNpemVyO1xufSgpO1xuXG4vKipcclxuICogQGludGVybmFsXHJcbiAqL1xudmFyIFZhbmlsbGFFbGVtZW50UHJvdmlkZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBWYW5pbGxhRWxlbWVudFByb3ZpZGVyKGVsZW1lbnQpIHtcbiAgICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLl9yZW5kZXJlZCA9IHRydWU7XG4gIH1cbiAgdmFyIF9fcHJvdG8gPSBWYW5pbGxhRWxlbWVudFByb3ZpZGVyLnByb3RvdHlwZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwiZWxlbWVudFwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZWxlbWVudDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwicmVuZGVyZWRcIiwge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlcmVkO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBfX3Byb3RvLnNob3cgPSBmdW5jdGlvbiAoZmxpY2tpbmcpIHtcbiAgICB2YXIgZWwgPSB0aGlzLmVsZW1lbnQ7XG4gICAgdmFyIGNhbWVyYUVsID0gZmxpY2tpbmcuY2FtZXJhLmVsZW1lbnQ7XG4gICAgaWYgKGVsLnBhcmVudEVsZW1lbnQgIT09IGNhbWVyYUVsKSB7XG4gICAgICBjYW1lcmFFbC5hcHBlbmRDaGlsZChlbCk7XG4gICAgICB0aGlzLl9yZW5kZXJlZCA9IHRydWU7XG4gICAgfVxuICB9O1xuICBfX3Byb3RvLmhpZGUgPSBmdW5jdGlvbiAoZmxpY2tpbmcpIHtcbiAgICB2YXIgZWwgPSB0aGlzLmVsZW1lbnQ7XG4gICAgdmFyIGNhbWVyYUVsID0gZmxpY2tpbmcuY2FtZXJhLmVsZW1lbnQ7XG4gICAgaWYgKGVsLnBhcmVudEVsZW1lbnQgPT09IGNhbWVyYUVsKSB7XG4gICAgICBjYW1lcmFFbC5yZW1vdmVDaGlsZChlbCk7XG4gICAgICB0aGlzLl9yZW5kZXJlZCA9IGZhbHNlO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIFZhbmlsbGFFbGVtZW50UHJvdmlkZXI7XG59KCk7XG5cbi8qXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNSBOQVZFUiBDb3JwLlxyXG4gKiBlZ2pzIHByb2plY3RzIGFyZSBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXG4vKipcclxuICogQGludGVybmFsXHJcbiAqL1xudmFyIFZpcnR1YWxFbGVtZW50UHJvdmlkZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBWaXJ0dWFsRWxlbWVudFByb3ZpZGVyKGZsaWNraW5nKSB7XG4gICAgdGhpcy5fZmxpY2tpbmcgPSBmbGlja2luZztcbiAgfVxuICB2YXIgX19wcm90byA9IFZpcnR1YWxFbGVtZW50UHJvdmlkZXIucHJvdG90eXBlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJlbGVtZW50XCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl92aXJ0dWFsRWxlbWVudC5uYXRpdmVFbGVtZW50O1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJyZW5kZXJlZFwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdmlydHVhbEVsZW1lbnQudmlzaWJsZTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwiX3ZpcnR1YWxFbGVtZW50XCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBmbGlja2luZyA9IHRoaXMuX2ZsaWNraW5nO1xuICAgICAgdmFyIGVsSW5kZXggPSB0aGlzLl9wYW5lbC5lbGVtZW50SW5kZXg7XG4gICAgICB2YXIgdmlydHVhbEVsZW1lbnRzID0gZmxpY2tpbmcudmlydHVhbC5lbGVtZW50cztcbiAgICAgIHJldHVybiB2aXJ0dWFsRWxlbWVudHNbZWxJbmRleF07XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIF9fcHJvdG8uaW5pdCA9IGZ1bmN0aW9uIChwYW5lbCkge1xuICAgIHRoaXMuX3BhbmVsID0gcGFuZWw7XG4gIH07XG4gIF9fcHJvdG8uc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBET19OT1RISU5HXG4gICAgLy8gQWN0dWFsIGVsZW1lbnQgdmlzaWJpbGl0eSBpcyBjb250cm9sbGVkIGJ5IFZpcnR1YWxNYW5hZ2VyXG4gIH07XG4gIF9fcHJvdG8uaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBET19OT1RISU5HXG4gICAgLy8gQWN0dWFsIGVsZW1lbnQgdmlzaWJpbGl0eSBpcyBjb250cm9sbGVkIGJ5IFZpcnR1YWxNYW5hZ2VyXG4gIH07XG4gIHJldHVybiBWaXJ0dWFsRWxlbWVudFByb3ZpZGVyO1xufSgpO1xuXG4vKipcclxuICogQSBtYW5hZ2VyIGNsYXNzIHRvIGFkZCAvIHJlbW92ZSB2aXJ0dWFsIHBhbmVsc1xyXG4gKi9cbnZhciBWaXJ0dWFsTWFuYWdlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFZpcnR1YWxNYW5hZ2VyKGZsaWNraW5nLCBvcHRpb25zKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgIHRoaXMuX2ZsaWNraW5nID0gZmxpY2tpbmc7XG4gICAgdGhpcy5fcmVuZGVyUGFuZWwgPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucmVuZGVyUGFuZWwpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH07XG4gICAgdGhpcy5faW5pdGlhbFBhbmVsQ291bnQgPSAoX2IgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaW5pdGlhbFBhbmVsQ291bnQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IC0xO1xuICAgIHRoaXMuX2NhY2hlID0gKF9jID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNhY2hlKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBmYWxzZTtcbiAgICB0aGlzLl9wYW5lbENsYXNzID0gKF9kID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnBhbmVsQ2xhc3MpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IENMQVNTLkRFRkFVTFRfVklSVFVBTDtcbiAgICB0aGlzLl9lbGVtZW50cyA9IFtdO1xuICB9XG4gIHZhciBfX3Byb3RvID0gVmlydHVhbE1hbmFnZXIucHJvdG90eXBlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJlbGVtZW50c1wiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZWxlbWVudHM7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcInJlbmRlclBhbmVsXCIsIHtcbiAgICAvLyBPcHRpb25zXG4gICAgLyoqXHJcbiAgICAgKiBBIHJlbmRlcmluZyBmdW5jdGlvbiBmb3IgdGhlIHBhbmVsIGVsZW1lbnQncyBpbm5lckhUTUxcclxuICAgICAqIEBrbyDtjKjrhJAg7JeY66as66i87Yq47J2YIGlubmVySFRNTOydhCDroIzrjZTrp4HtlZjripQg7ZWo7IiYXHJcbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb259XHJcbiAgICAgKiBAcGFyYW0ge1ZpcnR1YWxQYW5lbH0gcGFuZWwgSW5zdGFuY2Ugb2YgdGhlIHBhbmVsPGtvPu2MqOuEkCDsnbjsiqTthLTsiqQ8L2tvPlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IG9mIHRoZSBwYW5lbDxrbz7tjKjrhJAg7J24642x7IqkPC9rbz5cclxuICAgICAqIEBkZWZhdWx0IFwiKCkgPT4ge31cIlxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVuZGVyUGFuZWw7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHRoaXMuX3JlbmRlclBhbmVsID0gdmFsO1xuICAgICAgdGhpcy5fZmxpY2tpbmcucmVuZGVyZXIucGFuZWxzLmZvckVhY2goZnVuY3Rpb24gKHBhbmVsKSB7XG4gICAgICAgIHJldHVybiBwYW5lbC51bmNhY2hlUmVuZGVyUmVzdWx0KCk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwiaW5pdGlhbFBhbmVsQ291bnRcIiwge1xuICAgIC8qKlxyXG4gICAgICogSW5pdGlhbCBwYW5lbCBjb3VudCB0byByZW5kZXJcclxuICAgICAqIEBrbyDstZzstIjroZwg66CM642U66eB7ZWgIO2MqOuEkOydmCDqsJzsiJhcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IC0xXHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pbml0aWFsUGFuZWxDb3VudDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwiY2FjaGVcIiwge1xuICAgIC8qKlxyXG4gICAgICogV2hldGhlciB0byBjYWNoZSByZW5kZXJlZCBwYW5lbCdzIGlubmVySFRNTFxyXG4gICAgICogQGtvIOugjOuNlOungeuQnCDtjKjrhJDsnZggaW5uZXJIVE1MIOygleuztOulvCDsupDsi5ztlaDsp4Ag7Jes67aAXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqIEBkZWZhdWx0IGZhbHNlXHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jYWNoZTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgdGhpcy5fY2FjaGUgPSB2YWw7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcInBhbmVsQ2xhc3NcIiwge1xuICAgIC8qKlxyXG4gICAgICogVGhlIGNsYXNzIG5hbWUgdGhhdCB3aWxsIGJlIGFwcGxpZWQgdG8gcmVuZGVyZWQgcGFuZWwgZWxlbWVudHNcclxuICAgICAqIEBrbyDroIzrjZTrp4HrkJjripQg7Yyo64SQIOyXmOumrOuovO2KuOyXkCDsoIHsmqnrkKAg7YG0656Y7IqkIOydtOumhFxyXG4gICAgICogQHR5cGUge3N0cmluZ31cclxuICAgICAqIEBkZWZhdWx0IFwiZmxpY2tpbmctcGFuZWxcIlxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcGFuZWxDbGFzcztcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgdGhpcy5fcGFuZWxDbGFzcyA9IHZhbDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgX19wcm90by5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBmbGlja2luZyA9IHRoaXMuX2ZsaWNraW5nO1xuICAgIGlmICghZmxpY2tpbmcudmlydHVhbEVuYWJsZWQpIHJldHVybjtcbiAgICBpZiAoIWZsaWNraW5nLmV4dGVybmFsUmVuZGVyZXIgJiYgIWZsaWNraW5nLnJlbmRlckV4dGVybmFsKSB7XG4gICAgICB0aGlzLl9pbml0VmlydHVhbEVsZW1lbnRzKCk7XG4gICAgfVxuICAgIHZhciB2aXJ0dWFsRWxlbWVudHMgPSBmbGlja2luZy5jYW1lcmEuY2hpbGRyZW47XG4gICAgdGhpcy5fZWxlbWVudHMgPSB2aXJ0dWFsRWxlbWVudHMubWFwKGZ1bmN0aW9uIChlbCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmF0aXZlRWxlbWVudDogZWwsXG4gICAgICAgIHZpc2libGU6IHRydWVcbiAgICAgIH07XG4gICAgfSk7XG4gIH07XG4gIF9fcHJvdG8uc2hvdyA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgIHZhciBlbCA9IHRoaXMuX2VsZW1lbnRzW2luZGV4XTtcbiAgICB2YXIgbmF0aXZlRWwgPSBlbC5uYXRpdmVFbGVtZW50O1xuICAgIGVsLnZpc2libGUgPSB0cnVlO1xuICAgIGlmIChuYXRpdmVFbC5zdHlsZS5kaXNwbGF5KSB7XG4gICAgICBuYXRpdmVFbC5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcbiAgICB9XG4gIH07XG4gIF9fcHJvdG8uaGlkZSA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgIHZhciBlbCA9IHRoaXMuX2VsZW1lbnRzW2luZGV4XTtcbiAgICB2YXIgbmF0aXZlRWwgPSBlbC5uYXRpdmVFbGVtZW50O1xuICAgIGVsLnZpc2libGUgPSBmYWxzZTtcbiAgICBuYXRpdmVFbC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gIH07XG4gIC8qKlxyXG4gICAqIEFkZCBuZXcgdmlydHVhbCBwYW5lbHMgYXQgdGhlIGVuZCBvZiB0aGUgbGlzdFxyXG4gICAqIEBrbyDsg4jroZzsmrQg6rCA7IOBIO2MqOuEkOuTpOydhCDrpqzsiqTtirjsnZgg64Gd7JeQIOy2lOqwgO2VqeuLiOuLpFxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudCBUaGUgbnVtYmVyIG9mIHBhbmVscyB0byBhZGQ8a28+7LaU6rCA7ZWgIO2MqOuEkOydmCDqsJzsiJg8L2tvPlxyXG4gICAqIEByZXR1cm5zIHtBcnJheTxWaXJ0dWFsUGFuZWw+fSBUaGUgbmV3IHBhbmVscyBhZGRlZDxrbz7sg4jroa3qsowg7LaU6rCA65CcIO2MqOuEkOuTpDwva28+XHJcbiAgICovXG4gIF9fcHJvdG8uYXBwZW5kID0gZnVuY3Rpb24gKGNvdW50KSB7XG4gICAgaWYgKGNvdW50ID09PSB2b2lkIDApIHtcbiAgICAgIGNvdW50ID0gMTtcbiAgICB9XG4gICAgdmFyIGZsaWNraW5nID0gdGhpcy5fZmxpY2tpbmc7XG4gICAgcmV0dXJuIHRoaXMuaW5zZXJ0KGZsaWNraW5nLnBhbmVscy5sZW5ndGgsIGNvdW50KTtcbiAgfTtcbiAgLyoqXHJcbiAgICogQWRkIG5ldyB2aXJ0dWFsIHBhbmVscyBhdCB0aGUgc3RhcnQgb2YgdGhlIGxpc3RcclxuICAgKiBAa28g7IOI66Gc7Jq0IOqwgOyDgSDtjKjrhJDrk6TsnYQg66as7Iqk7Yq47J2YIOyLnOyekeyXkCDstpTqsIDtlanri4jri6RcclxuICAgKiBAcGFyYW0ge251bWJlcn0gY291bnQgVGhlIG51bWJlciBvZiBwYW5lbHMgdG8gYWRkPGtvPuy2lOqwgO2VoCDtjKjrhJDsnZgg6rCc7IiYPC9rbz5cclxuICAgKiBAcmV0dXJucyB7QXJyYXk8VmlydHVhbFBhbmVsPn0gVGhlIG5ldyBwYW5lbHMgYWRkZWQ8a28+7IOI66Gt6rKMIOy2lOqwgOuQnCDtjKjrhJDrk6Q8L2tvPlxyXG4gICAqL1xuICBfX3Byb3RvLnByZXBlbmQgPSBmdW5jdGlvbiAoY291bnQpIHtcbiAgICBpZiAoY291bnQgPT09IHZvaWQgMCkge1xuICAgICAgY291bnQgPSAxO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5pbnNlcnQoMCwgY291bnQpO1xuICB9O1xuICAvKipcclxuICAgKiBBZGQgbmV3IHZpcnR1YWwgcGFuZWxzIGF0IHRoZSBnaXZlbiBpbmRleFxyXG4gICAqIEBrbyDsg4jroZzsmrQg6rCA7IOBIO2MqOuEkOuTpOydhCDso7zslrTsp4Qg7J24642x7Iqk7JeQIOy2lOqwgO2VqeuLiOuLpFxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudCBUaGUgbnVtYmVyIG9mIHBhbmVscyB0byBhZGQ8a28+7LaU6rCA7ZWgIO2MqOuEkOydmCDqsJzsiJg8L2tvPlxyXG4gICAqIEByZXR1cm5zIHtBcnJheTxWaXJ0dWFsUGFuZWw+fSBUaGUgbmV3IHBhbmVscyBhZGRlZDxrbz7sg4jroa3qsowg7LaU6rCA65CcIO2MqOuEkOuTpDwva28+XHJcbiAgICovXG4gIF9fcHJvdG8uaW5zZXJ0ID0gZnVuY3Rpb24gKGluZGV4LCBjb3VudCkge1xuICAgIGlmIChjb3VudCA9PT0gdm9pZCAwKSB7XG4gICAgICBjb3VudCA9IDE7XG4gICAgfVxuICAgIGlmIChjb3VudCA8PSAwKSByZXR1cm4gW107XG4gICAgdmFyIGZsaWNraW5nID0gdGhpcy5fZmxpY2tpbmc7XG4gICAgcmV0dXJuIGZsaWNraW5nLnJlbmRlcmVyLmJhdGNoSW5zZXJ0KHtcbiAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgIGVsZW1lbnRzOiByYW5nZShjb3VudCksXG4gICAgICBoYXNET01JbkVsZW1lbnRzOiBmYWxzZVxuICAgIH0pO1xuICB9O1xuICAvKipcclxuICAgKiBSZW1vdmUgcGFuZWxzIGF0IHRoZSBnaXZlbiBpbmRleFxyXG4gICAqIEBrbyDso7zslrTsp4Qg7J24642x7Iqk7JeQ7IScIO2MqOuEkOuTpOydhCDsgq3soJztlanri4jri6RcclxuICAgKiBAcGFyYW0ge251bWJlcn0gY291bnQgVGhlIG51bWJlciBvZiBwYW5lbHMgdG8gcmVtb3ZlPGtvPuyCreygnO2VoCDtjKjrhJDsnZgg6rCc7IiYPC9rbz5cclxuICAgKiBAcmV0dXJucyB7QXJyYXk8VmlydHVhbFBhbmVsPn0gVGhlIHBhbmVscyByZW1vdmVkPGtvPuyCreygnOuQnCDtjKjrhJDrk6Q8L2tvPlxyXG4gICAqL1xuICBfX3Byb3RvLnJlbW92ZSA9IGZ1bmN0aW9uIChpbmRleCwgY291bnQpIHtcbiAgICBpZiAoY291bnQgPD0gMCkgcmV0dXJuIFtdO1xuICAgIHZhciBmbGlja2luZyA9IHRoaXMuX2ZsaWNraW5nO1xuICAgIHJldHVybiBmbGlja2luZy5yZW5kZXJlci5iYXRjaFJlbW92ZSh7XG4gICAgICBpbmRleDogaW5kZXgsXG4gICAgICBkZWxldGVDb3VudDogY291bnQsXG4gICAgICBoYXNET01JbkVsZW1lbnRzOiBmYWxzZVxuICAgIH0pO1xuICB9O1xuICBfX3Byb3RvLl9pbml0VmlydHVhbEVsZW1lbnRzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIGZsaWNraW5nID0gdGhpcy5fZmxpY2tpbmc7XG4gICAgdmFyIGNhbWVyYUVsZW1lbnQgPSBmbGlja2luZy5jYW1lcmEuZWxlbWVudDtcbiAgICB2YXIgcGFuZWxzUGVyVmlldyA9IGZsaWNraW5nLnBhbmVsc1BlclZpZXc7XG4gICAgdmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgIHZhciBuZXdFbGVtZW50cyA9IHJhbmdlKHBhbmVsc1BlclZpZXcgKyAxKS5tYXAoZnVuY3Rpb24gKGlkeCkge1xuICAgICAgdmFyIHBhbmVsRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgcGFuZWxFbC5jbGFzc05hbWUgPSBfdGhpcy5fcGFuZWxDbGFzcztcbiAgICAgIHBhbmVsRWwuZGF0YXNldC5lbGVtZW50SW5kZXggPSBpZHgudG9TdHJpbmcoKTtcbiAgICAgIHJldHVybiBwYW5lbEVsO1xuICAgIH0pO1xuICAgIG5ld0VsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChlbCk7XG4gICAgfSk7XG4gICAgY2FtZXJhRWxlbWVudC5hcHBlbmRDaGlsZChmcmFnbWVudCk7XG4gIH07XG4gIHJldHVybiBWaXJ0dWFsTWFuYWdlcjtcbn0oKTtcblxuLyoqXHJcbiAqIEFsbCBwb3NzaWJsZSBAZWdqcy9heGVzIGV2ZW50IGtleXNcclxuICogQGludGVybmFsXHJcbiAqL1xudmFyIEVWRU5UID0ge1xuICBIT0xEOiBcImhvbGRcIixcbiAgQ0hBTkdFOiBcImNoYW5nZVwiLFxuICBSRUxFQVNFOiBcInJlbGVhc2VcIixcbiAgQU5JTUFUSU9OX0VORDogXCJhbmltYXRpb25FbmRcIixcbiAgRklOSVNIOiBcImZpbmlzaFwiXG59O1xuLyoqXHJcbiAqIEFuIEF4aXMga2V5IHRoYXQgRmxpY2tpbmcgdXNlc1xyXG4gKiBAaW50ZXJuYWxcclxuICovXG52YXIgUE9TSVRJT05fS0VZID0gXCJmbGlja1wiO1xuXG52YXIgU1RBVEVfVFlQRTtcbihmdW5jdGlvbiAoU1RBVEVfVFlQRSkge1xuICBTVEFURV9UWVBFW1NUQVRFX1RZUEVbXCJJRExFXCJdID0gMF0gPSBcIklETEVcIjtcbiAgU1RBVEVfVFlQRVtTVEFURV9UWVBFW1wiSE9MRElOR1wiXSA9IDFdID0gXCJIT0xESU5HXCI7XG4gIFNUQVRFX1RZUEVbU1RBVEVfVFlQRVtcIkRSQUdHSU5HXCJdID0gMl0gPSBcIkRSQUdHSU5HXCI7XG4gIFNUQVRFX1RZUEVbU1RBVEVfVFlQRVtcIkFOSU1BVElOR1wiXSA9IDNdID0gXCJBTklNQVRJTkdcIjtcbiAgU1RBVEVfVFlQRVtTVEFURV9UWVBFW1wiRElTQUJMRURcIl0gPSA0XSA9IFwiRElTQUJMRURcIjtcbn0pKFNUQVRFX1RZUEUgfHwgKFNUQVRFX1RZUEUgPSB7fSkpO1xuLyoqXHJcbiAqIEEgY29tcG9uZW50IHRoYXQgc2hvd3MgdGhlIGN1cnJlbnQgc3RhdHVzIG9mIHRoZSB1c2VyIGlucHV0IG9yIHRoZSBhbmltYXRpb25cclxuICogQGtvIO2YhOyerCDsgqzsmqnsnpAg7J6F66ClIOuYkOuKlCDslaDri4jrqZTsnbTshZgg7IOB7YOc66W8IOuCmO2DgOuCtOuKlCDsu7Ttj6zrhIztirhcclxuICogQGludGVybmFsXHJcbiAqL1xudmFyIFN0YXRlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU3RhdGUoKSB7XG4gICAgdGhpcy5fZGVsdGEgPSAwO1xuICAgIHRoaXMuX3RhcmdldFBhbmVsID0gbnVsbDtcbiAgfVxuICB2YXIgX19wcm90byA9IFN0YXRlLnByb3RvdHlwZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwiZGVsdGFcIiwge1xuICAgIC8qKlxyXG4gICAgICogQSBzdW0gb2YgZGVsdGEgdmFsdWVzIG9mIGNoYW5nZSBldmVudHMgZnJvbSB0aGUgbGFzdCBob2xkIGV2ZW50IG9mIEF4ZXNcclxuICAgICAqIEBrbyDsnbTsoIQgaG9sZOydtOuypO2KuOu2gO2EsCBjaGFuZ2Xsl5Ag7J2Y7ZW0IOuwnOyDne2VnCDsnbTrj5kgZGVsdGHqsJLsnZgg7ZWp7IKwXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kZWx0YTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwidGFyZ2V0UGFuZWxcIiwge1xuICAgIC8qKlxyXG4gICAgICogQSBwYW5lbCB0byBzZXQgYXMge0BsaW5rIENvbnRyb2wjYWN0aXZlUGFuZWx9IGFmdGVyIHRoZSBhbmltYXRpb24gaXMgZmluaXNoZWRcclxuICAgICAqIEBrbyDslaDri4jrqZTsnbTshZgg7KKF66OM7IucIHtAbGluayBDb250cm9sI2FjdGl2ZVBhbmVsfeuhnCDshKTsoJXtlaAg7Yyo64SQXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl90YXJnZXRQYW5lbDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgdGhpcy5fdGFyZ2V0UGFuZWwgPSB2YWw7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIC8qKlxyXG4gICAqIEFuIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIHN0YXRlIGhhcyBjaGFuZ2VkIHRvIHRoaXMgc3RhdGVcclxuICAgKiBAa28g7ZiE7J6sIOyDge2DnOuhnCDrj4zsnoXtlojsnYTrlYwg7Zi47Lac65CY64qUIOy9nOuwsSDtlajsiJhcclxuICAgKiBAcGFyYW0ge1N0YXRlfSBwcmV2U3RhdGUgQW4gcHJldmlvdXMgc3RhdGU8a28+7J207KCEIOyDge2DnOqwkjwva28+XHJcbiAgICogQHJldHVybiB7dm9pZH1cclxuICAgKi9cbiAgX19wcm90by5vbkVudGVyID0gZnVuY3Rpb24gKHByZXZTdGF0ZSkge1xuICAgIHRoaXMuX2RlbHRhID0gcHJldlN0YXRlLl9kZWx0YTtcbiAgICB0aGlzLl90YXJnZXRQYW5lbCA9IHByZXZTdGF0ZS5fdGFyZ2V0UGFuZWw7XG4gIH07XG4gIC8qKlxyXG4gICAqIEFuIGV2ZW50IGhhbmRsZXIgZm9yIEF4ZXMncyB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1heGVzL3JlbGVhc2UvbGF0ZXN0L2RvYy9lZy5BeGVzLmh0bWwjZXZlbnQ6aG9sZCBob2xkfSBldmVudFxyXG4gICAqIEBrbyBBeGVz7J2YIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWF4ZXMvcmVsZWFzZS9sYXRlc3QvZG9jL2VnLkF4ZXMuaHRtbCNldmVudDpob2xkIGhvbGR9IOydtOuypO2KuCDtlbjrk6Trn6xcclxuICAgKiBAcGFyYW0ge29iamVjdH0gW2N0eF0gRXZlbnQgY29udGV4dDxrbz7snbTrsqTtirgg7L2Y7YWN7Iqk7Yq4PC9rbz5cclxuICAgKiBAcGFyYW0ge0ZsaWNraW5nfSBbY3R4LmZsaWNraW5nXSBBbiBpbnN0YW5jZSBvZiBGbGlja2luZzxrbz5GbGlja2luZyDsnbjsiqTthLTsiqQ8L2tvPlxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbY3R4LmF4ZXNFdmVudF0gQSB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1heGVzL3JlbGVhc2UvbGF0ZXN0L2RvYy9lZy5BeGVzLmh0bWwjZXZlbnQ6aG9sZCBob2xkfSBldmVudCBvZiBBeGVzXHJcbiAgICogPGtvPkF4ZXPsnZgge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtYXhlcy9yZWxlYXNlL2xhdGVzdC9kb2MvZWcuQXhlcy5odG1sI2V2ZW50OmhvbGQgaG9sZH0g7J2067Kk7Yq4PC9rbz5cclxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY3R4LnRyYW5zaXRUb10gQSBmdW5jdGlvbiBmb3IgY2hhbmdpbmcgY3VycmVudCBzdGF0ZSB0byBvdGhlciBzdGF0ZTxrbz7ri6Trpbgg7IOB7YOc66GcIOuzgOqyve2VmOq4sCDsnITtlZwg7ZWo7IiYPC9rbz5cclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xuICBfX3Byb3RvLm9uSG9sZCA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAvLyBETyBOT1RISU5HXG4gIH07XG4gIC8qKlxyXG4gICAqIEFuIGV2ZW50IGhhbmRsZXIgZm9yIEF4ZXMncyB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1heGVzL3JlbGVhc2UvbGF0ZXN0L2RvYy9lZy5BeGVzLmh0bWwjZXZlbnQ6Y2hhbmdlIGNoYW5nZX0gZXZlbnRcclxuICAgKiBAa28gQXhlc+ydmCB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1heGVzL3JlbGVhc2UvbGF0ZXN0L2RvYy9lZy5BeGVzLmh0bWwjZXZlbnQ6Y2hhbmdlIGNoYW5nZX0g7J2067Kk7Yq4IO2VuOuTpOufrFxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbY3R4XSBFdmVudCBjb250ZXh0PGtvPuydtOuypO2KuCDsvZjthY3siqTtirg8L2tvPlxyXG4gICAqIEBwYXJhbSB7RmxpY2tpbmd9IFtjdHguZmxpY2tpbmddIEFuIGluc3RhbmNlIG9mIEZsaWNraW5nPGtvPkZsaWNraW5nIOyduOyKpO2EtOyKpDwva28+XHJcbiAgICogQHBhcmFtIHtvYmplY3R9IFtjdHguYXhlc0V2ZW50XSBBIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWF4ZXMvcmVsZWFzZS9sYXRlc3QvZG9jL2VnLkF4ZXMuaHRtbCNldmVudDpjaGFuZ2UgY2hhbmdlfSBldmVudCBvZiBBeGVzXHJcbiAgICogPGtvPkF4ZXPsnZgge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtYXhlcy9yZWxlYXNlL2xhdGVzdC9kb2MvZWcuQXhlcy5odG1sI2V2ZW50OmNoYW5nZSBjaGFuZ2V9IOydtOuypO2KuDwva28+XHJcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2N0eC50cmFuc2l0VG9dIEEgZnVuY3Rpb24gZm9yIGNoYW5naW5nIGN1cnJlbnQgc3RhdGUgdG8gb3RoZXIgc3RhdGU8a28+64uk66W4IOyDge2DnOuhnCDrs4Dqsr3tlZjquLAg7JyE7ZWcIO2VqOyImDwva28+XHJcbiAgICogQHJldHVybiB7dm9pZH1cclxuICAgKi9cbiAgX19wcm90by5vbkNoYW5nZSA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAvLyBETyBOT1RISU5HXG4gIH07XG4gIC8qKlxyXG4gICAqIEFuIGV2ZW50IGhhbmRsZXIgZm9yIEF4ZXMncyB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1heGVzL3JlbGVhc2UvbGF0ZXN0L2RvYy9lZy5BeGVzLmh0bWwjZXZlbnQ6cmVsZWFzZSByZWxlYXNlfSBldmVudFxyXG4gICAqIEBrbyBBeGVz7J2YIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWF4ZXMvcmVsZWFzZS9sYXRlc3QvZG9jL2VnLkF4ZXMuaHRtbCNldmVudDpyZWxlYXNlIHJlbGVhc2V9IOydtOuypO2KuCDtlbjrk6Trn6xcclxuICAgKiBAcGFyYW0ge29iamVjdH0gW2N0eF0gRXZlbnQgY29udGV4dDxrbz7snbTrsqTtirgg7L2Y7YWN7Iqk7Yq4PC9rbz5cclxuICAgKiBAcGFyYW0ge0ZsaWNraW5nfSBbY3R4LmZsaWNraW5nXSBBbiBpbnN0YW5jZSBvZiBGbGlja2luZzxrbz5GbGlja2luZyDsnbjsiqTthLTsiqQ8L2tvPlxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbY3R4LmF4ZXNFdmVudF0gQSB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1heGVzL3JlbGVhc2UvbGF0ZXN0L2RvYy9lZy5BeGVzLmh0bWwjZXZlbnQ6cmVsZWFzZSByZWxlYXNlfSBldmVudCBvZiBBeGVzXHJcbiAgICogPGtvPkF4ZXPsnZgge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtYXhlcy9yZWxlYXNlL2xhdGVzdC9kb2MvZWcuQXhlcy5odG1sI2V2ZW50OnJlbGVhc2UgcmVsZWFzZX0g7J2067Kk7Yq4PC9rbz5cclxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY3R4LnRyYW5zaXRUb10gQSBmdW5jdGlvbiBmb3IgY2hhbmdpbmcgY3VycmVudCBzdGF0ZSB0byBvdGhlciBzdGF0ZTxrbz7ri6Trpbgg7IOB7YOc66GcIOuzgOqyve2VmOq4sCDsnITtlZwg7ZWo7IiYPC9rbz5cclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xuICBfX3Byb3RvLm9uUmVsZWFzZSA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAvLyBETyBOT1RISU5HXG4gIH07XG4gIC8qKlxyXG4gICAqIEFuIGV2ZW50IGhhbmRsZXIgZm9yIEF4ZXMncyB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1heGVzL3JlbGVhc2UvbGF0ZXN0L2RvYy9lZy5BeGVzLmh0bWwjZXZlbnQ6YW5pbWF0aW9uRW5kIGFuaW1hdGlvbkVuZH0gZXZlbnRcclxuICAgKiBAa28gQXhlc+ydmCB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1heGVzL3JlbGVhc2UvbGF0ZXN0L2RvYy9lZy5BeGVzLmh0bWwjZXZlbnQ6YW5pbWF0aW9uRW5kIGFuaW1hdGlvbkVuZH0g7J2067Kk7Yq4IO2VuOuTpOufrFxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbY3R4XSBFdmVudCBjb250ZXh0PGtvPuydtOuypO2KuCDsvZjthY3siqTtirg8L2tvPlxyXG4gICAqIEBwYXJhbSB7RmxpY2tpbmd9IFtjdHguZmxpY2tpbmddIEFuIGluc3RhbmNlIG9mIEZsaWNraW5nPGtvPkZsaWNraW5nIOyduOyKpO2EtOyKpDwva28+XHJcbiAgICogQHBhcmFtIHtvYmplY3R9IFtjdHguYXhlc0V2ZW50XSBBIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWF4ZXMvcmVsZWFzZS9sYXRlc3QvZG9jL2VnLkF4ZXMuaHRtbCNldmVudDphbmltYXRpb25FbmQgYW5pbWF0aW9uRW5kfSBldmVudCBvZiBBeGVzXHJcbiAgICogPGtvPkF4ZXPsnZgge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtYXhlcy9yZWxlYXNlL2xhdGVzdC9kb2MvZWcuQXhlcy5odG1sI2V2ZW50OmFuaW1hdGlvbkVuZCBhbmltYXRpb25FbmR9IOydtOuypO2KuDwva28+XHJcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2N0eC50cmFuc2l0VG9dIEEgZnVuY3Rpb24gZm9yIGNoYW5naW5nIGN1cnJlbnQgc3RhdGUgdG8gb3RoZXIgc3RhdGU8a28+64uk66W4IOyDge2DnOuhnCDrs4Dqsr3tlZjquLAg7JyE7ZWcIO2VqOyImDwva28+XHJcbiAgICogQHJldHVybiB7dm9pZH1cclxuICAgKi9cbiAgX19wcm90by5vbkFuaW1hdGlvbkVuZCA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAvLyBETyBOT1RISU5HXG4gIH07XG4gIC8qKlxyXG4gICAqIEFuIGV2ZW50IGhhbmRsZXIgZm9yIEF4ZXMncyB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1heGVzL3JlbGVhc2UvbGF0ZXN0L2RvYy9lZy5BeGVzLmh0bWwjZXZlbnQ6ZmluaXNoIGZpbmlzaH0gZXZlbnRcclxuICAgKiBAa28gQXhlc+ydmCB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1heGVzL3JlbGVhc2UvbGF0ZXN0L2RvYy9lZy5BeGVzLmh0bWwjZXZlbnQ6ZmluaXNoIGZpbmlzaH0g7J2067Kk7Yq4IO2VuOuTpOufrFxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbY3R4XSBFdmVudCBjb250ZXh0PGtvPuydtOuypO2KuCDsvZjthY3siqTtirg8L2tvPlxyXG4gICAqIEBwYXJhbSB7RmxpY2tpbmd9IFtjdHguZmxpY2tpbmddIEFuIGluc3RhbmNlIG9mIEZsaWNraW5nPGtvPkZsaWNraW5nIOyduOyKpO2EtOyKpDwva28+XHJcbiAgICogQHBhcmFtIHtvYmplY3R9IFtjdHguYXhlc0V2ZW50XSBBIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWF4ZXMvcmVsZWFzZS9sYXRlc3QvZG9jL2VnLkF4ZXMuaHRtbCNldmVudDpmaW5pc2ggZmluaXNofSBldmVudCBvZiBBeGVzPGtvPkF4ZXPsnZgge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtYXhlcy9yZWxlYXNlL2xhdGVzdC9kb2MvZWcuQXhlcy5odG1sI2V2ZW50OmZpbmlzaCBmaW5pc2h9IOydtOuypO2KuDwva28+XHJcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2N0eC50cmFuc2l0VG9dIEEgZnVuY3Rpb24gZm9yIGNoYW5naW5nIGN1cnJlbnQgc3RhdGUgdG8gb3RoZXIgc3RhdGU8a28+64uk66W4IOyDge2DnOuhnCDrs4Dqsr3tlZjquLAg7JyE7ZWcIO2VqOyImDwva28+XHJcbiAgICogQHJldHVybiB7dm9pZH1cclxuICAgKi9cbiAgX19wcm90by5vbkZpbmlzaCA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAvLyBETyBOT1RISU5HXG4gIH07XG4gIF9fcHJvdG8uX21vdmVUb0NoYW5nZWRQb3NpdGlvbiA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICB2YXIgZmxpY2tpbmcgPSBjdHguZmxpY2tpbmcsXG4gICAgICBheGVzRXZlbnQgPSBjdHguYXhlc0V2ZW50LFxuICAgICAgdHJhbnNpdFRvID0gY3R4LnRyYW5zaXRUbztcbiAgICB2YXIgZGVsdGEgPSBheGVzRXZlbnQuZGVsdGFbUE9TSVRJT05fS0VZXTtcbiAgICBpZiAoIWRlbHRhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2RlbHRhICs9IGRlbHRhO1xuICAgIHZhciBjYW1lcmEgPSBmbGlja2luZy5jYW1lcmE7XG4gICAgdmFyIHByZXZQb3NpdGlvbiA9IGNhbWVyYS5wb3NpdGlvbjtcbiAgICB2YXIgcG9zaXRpb24gPSBheGVzRXZlbnQucG9zW1BPU0lUSU9OX0tFWV07XG4gICAgdmFyIG5ld1Bvc2l0aW9uID0gZmxpY2tpbmcuY2lyY3VsYXJFbmFibGVkID8gY2lyY3VsYXRlUG9zaXRpb24ocG9zaXRpb24sIGNhbWVyYS5yYW5nZS5taW4sIGNhbWVyYS5yYW5nZS5tYXgpIDogcG9zaXRpb247XG4gICAgY2FtZXJhLmxvb2tBdChuZXdQb3NpdGlvbik7XG4gICAgdmFyIG1vdmVFdmVudCA9IG5ldyBDb21wb25lbnRFdmVudCQxKEVWRU5UUy5NT1ZFLCB7XG4gICAgICBpc1RydXN0ZWQ6IGF4ZXNFdmVudC5pc1RydXN0ZWQsXG4gICAgICBob2xkaW5nOiB0aGlzLmhvbGRpbmcsXG4gICAgICBkaXJlY3Rpb246IGdldERpcmVjdGlvbiQxKDAsIGF4ZXNFdmVudC5kZWx0YVtQT1NJVElPTl9LRVldKSxcbiAgICAgIGF4ZXNFdmVudDogYXhlc0V2ZW50XG4gICAgfSk7XG4gICAgZmxpY2tpbmcudHJpZ2dlcihtb3ZlRXZlbnQpO1xuICAgIGlmIChtb3ZlRXZlbnQuaXNDYW5jZWxlZCgpKSB7XG4gICAgICAvLyBSZXR1cm4gdG8gcHJldmlvdXMgcG9zaXRpb25cbiAgICAgIGNhbWVyYS5sb29rQXQocHJldlBvc2l0aW9uKTtcbiAgICAgIHRyYW5zaXRUbyhTVEFURV9UWVBFLkRJU0FCTEVEKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBTdGF0ZTtcbn0oKTtcblxuLyoqXHJcbiAqIEEgZGVmYXVsdCBzdGF0ZSB3aGVuIHRoZXJlJ3Mgbm8gdXNlciBpbnB1dCBhbmQgbm8gYW5pbWF0aW9uJ3MgcGxheWluZ1xyXG4gKiBAa28g7IKs7Jqp7J6Q7J2YIOyeheugpeydtCDsl4bqs6AsIOyVoOuLiOuplOydtOyFmOydtCDrj5nsnpHtlZjqs6Dsnojsp4Ag7JWK7J2AIOq4sOuzuCDsg4Htg5xcclxuICogQGludGVybmFsXHJcbiAqL1xudmFyIElkbGVTdGF0ZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyQzKElkbGVTdGF0ZSwgX3N1cGVyKTtcbiAgZnVuY3Rpb24gSWRsZVN0YXRlKCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIC8qKlxyXG4gICAgICogV2hldGhlciB1c2VyIGlzIGNsaWNraW5nIG9yIHRvdWNoaW5nXHJcbiAgICAgKiBAa28g7ZiE7J6sIOyCrOyaqeyekOqwgCDtgbTrpq0v7YSw7LmY7KSR7J247KeAIOyXrOu2gFxyXG4gICAgICogQHR5cGUge2ZhbHNlfVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBfdGhpcy5ob2xkaW5nID0gZmFsc2U7XG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIEZsaWNraW5nJ3MgYW5pbWF0aW5nXHJcbiAgICAgKiBAa28g7ZiE7J6sIOyVoOuLiOuplOydtOyFmCDrj5nsnpEg7Jes67aAXHJcbiAgICAgKiBAdHlwZSB7ZmFsc2V9XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIF90aGlzLmFuaW1hdGluZyA9IGZhbHNlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICB2YXIgX19wcm90byA9IElkbGVTdGF0ZS5wcm90b3R5cGU7XG4gIF9fcHJvdG8ub25FbnRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9kZWx0YSA9IDA7XG4gICAgdGhpcy5fdGFyZ2V0UGFuZWwgPSBudWxsO1xuICB9O1xuICBfX3Byb3RvLm9uSG9sZCA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAvLyBTaG91bGRuJ3QgZG8gYW55IGFjdGlvbiB1bnRpbCBhbnkgcGFuZWxzIG9uIGZsaWNraW5nIGFyZWFcbiAgICB2YXIgZmxpY2tpbmcgPSBjdHguZmxpY2tpbmcsXG4gICAgICBheGVzRXZlbnQgPSBjdHguYXhlc0V2ZW50LFxuICAgICAgdHJhbnNpdFRvID0gY3R4LnRyYW5zaXRUbztcbiAgICBpZiAoZmxpY2tpbmcucmVuZGVyZXIucGFuZWxDb3VudCA8PSAwKSB7XG4gICAgICB0cmFuc2l0VG8oU1RBVEVfVFlQRS5ESVNBQkxFRCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBob2xkU3RhcnRFdmVudCA9IG5ldyBDb21wb25lbnRFdmVudCQxKEVWRU5UUy5IT0xEX1NUQVJULCB7XG4gICAgICBheGVzRXZlbnQ6IGF4ZXNFdmVudFxuICAgIH0pO1xuICAgIGZsaWNraW5nLnRyaWdnZXIoaG9sZFN0YXJ0RXZlbnQpO1xuICAgIGlmIChob2xkU3RhcnRFdmVudC5pc0NhbmNlbGVkKCkpIHtcbiAgICAgIHRyYW5zaXRUbyhTVEFURV9UWVBFLkRJU0FCTEVEKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJhbnNpdFRvKFNUQVRFX1RZUEUuSE9MRElORyk7XG4gICAgfVxuICB9O1xuICAvLyBCeSBtZXRob2RzIGNhbGxcbiAgX19wcm90by5vbkNoYW5nZSA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICB2YXIgZmxpY2tpbmcgPSBjdHguZmxpY2tpbmcsXG4gICAgICBheGVzRXZlbnQgPSBjdHguYXhlc0V2ZW50LFxuICAgICAgdHJhbnNpdFRvID0gY3R4LnRyYW5zaXRUbztcbiAgICB2YXIgY29udHJvbGxlciA9IGZsaWNraW5nLmNvbnRyb2wuY29udHJvbGxlcjtcbiAgICB2YXIgYW5pbWF0aW5nQ29udGV4dCA9IGNvbnRyb2xsZXIuYW5pbWF0aW5nQ29udGV4dDtcbiAgICB2YXIgbW92ZVN0YXJ0RXZlbnQgPSBuZXcgQ29tcG9uZW50RXZlbnQkMShFVkVOVFMuTU9WRV9TVEFSVCwge1xuICAgICAgaXNUcnVzdGVkOiBheGVzRXZlbnQuaXNUcnVzdGVkLFxuICAgICAgaG9sZGluZzogdGhpcy5ob2xkaW5nLFxuICAgICAgZGlyZWN0aW9uOiBnZXREaXJlY3Rpb24kMShhbmltYXRpbmdDb250ZXh0LnN0YXJ0LCBhbmltYXRpbmdDb250ZXh0LmVuZCksXG4gICAgICBheGVzRXZlbnQ6IGF4ZXNFdmVudFxuICAgIH0pO1xuICAgIGZsaWNraW5nLnRyaWdnZXIobW92ZVN0YXJ0RXZlbnQpO1xuICAgIGlmIChtb3ZlU3RhcnRFdmVudC5pc0NhbmNlbGVkKCkpIHtcbiAgICAgIHRyYW5zaXRUbyhTVEFURV9UWVBFLkRJU0FCTEVEKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVHJpZ2dlciBBbmltYXRpbmdTdGF0ZSdzIG9uQ2hhbmdlLCB0byB0cmlnZ2VyIFwibW92ZVwiIGV2ZW50IGltbWVkaWF0ZWx5XG4gICAgICB0cmFuc2l0VG8oU1RBVEVfVFlQRS5BTklNQVRJTkcpLm9uQ2hhbmdlKGN0eCk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gSWRsZVN0YXRlO1xufShTdGF0ZSk7XG5cbi8qKlxyXG4gKiBBIHN0YXRlIHRoYXQgYWN0aXZhdGVzIHdoZW4gdXNlcidzIGhvbGRpbmcgdGhlIEZsaWNraW5nIGFyZWEsIGJ1dCBub3QgbW92ZWQgYSBzaW5nbGUgcGl4ZWwgeWV0XHJcbiAqIEBrbyDsgqzsmqnsnpDsnZgg7J6F66Cl7J20IOyLnOyekeuQmOyXiOycvOuCmCwg7JWE7KeBIOybgOyngeydtOyngOuKlCDslYrsnYAg7IOB7YOcXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cbnZhciBIb2xkaW5nU3RhdGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMkMyhIb2xkaW5nU3RhdGUsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIEhvbGRpbmdTdGF0ZSgpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgdXNlciBpcyBjbGlja2luZyBvciB0b3VjaGluZ1xyXG4gICAgICogQGtvIO2YhOyerCDsgqzsmqnsnpDqsIAg7YG066atL+2EsOy5mOykkeyduOyngCDsl6zrtoBcclxuICAgICAqIEB0eXBlIHt0cnVlfVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBfdGhpcy5ob2xkaW5nID0gdHJ1ZTtcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgRmxpY2tpbmcncyBhbmltYXRpbmdcclxuICAgICAqIEBrbyDtmITsnqwg7JWg64uI66mU7J207IWYIOuPmeyekSDsl6zrtoBcclxuICAgICAqIEB0eXBlIHtmYWxzZX1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgX3RoaXMuYW5pbWF0aW5nID0gZmFsc2U7XG4gICAgX3RoaXMuX3JlbGVhc2VFdmVudCA9IG51bGw7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIHZhciBfX3Byb3RvID0gSG9sZGluZ1N0YXRlLnByb3RvdHlwZTtcbiAgX19wcm90by5vbkNoYW5nZSA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICB2YXIgZmxpY2tpbmcgPSBjdHguZmxpY2tpbmcsXG4gICAgICBheGVzRXZlbnQgPSBjdHguYXhlc0V2ZW50LFxuICAgICAgdHJhbnNpdFRvID0gY3R4LnRyYW5zaXRUbztcbiAgICB2YXIgaW5wdXRFdmVudCA9IGF4ZXNFdmVudC5pbnB1dEV2ZW50O1xuICAgIHZhciBvZmZzZXQgPSBmbGlja2luZy5ob3Jpem9udGFsID8gaW5wdXRFdmVudC5vZmZzZXRYIDogaW5wdXRFdmVudC5vZmZzZXRZO1xuICAgIHZhciBtb3ZlU3RhcnRFdmVudCA9IG5ldyBDb21wb25lbnRFdmVudCQxKEVWRU5UUy5NT1ZFX1NUQVJULCB7XG4gICAgICBpc1RydXN0ZWQ6IGF4ZXNFdmVudC5pc1RydXN0ZWQsXG4gICAgICBob2xkaW5nOiB0aGlzLmhvbGRpbmcsXG4gICAgICBkaXJlY3Rpb246IGdldERpcmVjdGlvbiQxKDAsIC1vZmZzZXQpLFxuICAgICAgYXhlc0V2ZW50OiBheGVzRXZlbnRcbiAgICB9KTtcbiAgICBmbGlja2luZy50cmlnZ2VyKG1vdmVTdGFydEV2ZW50KTtcbiAgICBpZiAobW92ZVN0YXJ0RXZlbnQuaXNDYW5jZWxlZCgpKSB7XG4gICAgICB0cmFuc2l0VG8oU1RBVEVfVFlQRS5ESVNBQkxFRCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRyaWdnZXIgRHJhZ2dpbmdTdGF0ZSdzIG9uQ2hhbmdlLCB0byB0cmlnZ2VyIFwibW92ZVwiIGV2ZW50IGltbWVkaWF0ZWx5XG4gICAgICB0cmFuc2l0VG8oU1RBVEVfVFlQRS5EUkFHR0lORykub25DaGFuZ2UoY3R4KTtcbiAgICB9XG4gIH07XG4gIF9fcHJvdG8ub25SZWxlYXNlID0gZnVuY3Rpb24gKGN0eCkge1xuICAgIHZhciBmbGlja2luZyA9IGN0eC5mbGlja2luZyxcbiAgICAgIGF4ZXNFdmVudCA9IGN0eC5heGVzRXZlbnQsXG4gICAgICB0cmFuc2l0VG8gPSBjdHgudHJhbnNpdFRvO1xuICAgIGZsaWNraW5nLnRyaWdnZXIobmV3IENvbXBvbmVudEV2ZW50JDEoRVZFTlRTLkhPTERfRU5ELCB7XG4gICAgICBheGVzRXZlbnQ6IGF4ZXNFdmVudFxuICAgIH0pKTtcbiAgICBpZiAoYXhlc0V2ZW50LmRlbHRhLmZsaWNrICE9PSAwKSB7XG4gICAgICAvLyBTb21ldGltZXMgXCJyZWxlYXNlXCIgZXZlbnQgb24gYXhlcyB0cmlnZ2VyZWQgYmVmb3JlIFwiY2hhbmdlXCIgZXZlbnRcbiAgICAgIC8vIEVzcGVjaWFsbHkgaWYgdXNlciBmbGlja2VkIHBhbmVsIGZhc3QgaW4gcmVhbGx5IHNob3J0IGFtb3VudCBvZiB0aW1lXG4gICAgICAvLyBpZiBkZWx0YSBpcyBub3QgemVybywgdGhhdCBtZWFucyBhYm92ZSBjYXNlIGhhcHBlbmVkLlxuICAgICAgLy8gRXZlbnQgZmxvdyBzaG91bGQgYmUgSE9MRF9TVEFSVCAtPiBNT1ZFX1NUQVJUIC0+IE1PVkUgLT4gSE9MRF9FTkRcbiAgICAgIC8vIEF0IGxlYXN0IG9uZSBtb3ZlIGV2ZW50IHNob3VsZCBiZSBpbmNsdWRlZCBiZXR3ZWVuIGhvbGRTdGFydCBhbmQgaG9sZEVuZFxuICAgICAgYXhlc0V2ZW50LnNldFRvKHtcbiAgICAgICAgZmxpY2s6IGZsaWNraW5nLmNhbWVyYS5wb3NpdGlvblxuICAgICAgfSwgMCk7XG4gICAgICB0cmFuc2l0VG8oU1RBVEVfVFlQRS5JRExFKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gQ2FuJ3QgaGFuZGxlIHNlbGVjdCBldmVudCBoZXJlLFxuICAgIC8vIEFzIFwiZmluaXNoXCIgYXhlcyBldmVudCBoYXBwZW5zXG4gICAgdGhpcy5fcmVsZWFzZUV2ZW50ID0gYXhlc0V2ZW50O1xuICB9O1xuICBfX3Byb3RvLm9uRmluaXNoID0gZnVuY3Rpb24gKGN0eCkge1xuICAgIHZhciBlXzEsIF9hO1xuICAgIHZhciBmbGlja2luZyA9IGN0eC5mbGlja2luZyxcbiAgICAgIHRyYW5zaXRUbyA9IGN0eC50cmFuc2l0VG87XG4gICAgLy8gU2hvdWxkIHRyYW5zaXRlIHRvIElETEUgc3RhdGUgYmVmb3JlIHNlbGVjdCBldmVudFxuICAgIC8vIEFzIHVzZXIgZXhwZWN0cyBob2xkIGlzIGFscmVhZHkgZmluaXNoZWRcbiAgICB0cmFuc2l0VG8oU1RBVEVfVFlQRS5JRExFKTtcbiAgICBpZiAoIXRoaXMuX3JlbGVhc2VFdmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBIYW5kbGUgcmVsZWFzZSBldmVudCBoZXJlXG4gICAgLy8gVG8gcHJldmVudCBmaW5pc2ggZXZlbnQgY2FsbGVkIHR3aWNlXG4gICAgdmFyIHJlbGVhc2VFdmVudCA9IHRoaXMuX3JlbGVhc2VFdmVudDtcbiAgICAvLyBTdGF0aWMgY2xpY2tcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnQsIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2VzcyAqL1xuICAgIHZhciBzcmNFdmVudCA9IHJlbGVhc2VFdmVudC5pbnB1dEV2ZW50LnNyY0V2ZW50O1xuICAgIHZhciBjbGlja2VkRWxlbWVudDtcbiAgICBpZiAoc3JjRXZlbnQudHlwZSA9PT0gXCJ0b3VjaGVuZFwiKSB7XG4gICAgICB2YXIgdG91Y2hFdmVudCA9IHNyY0V2ZW50O1xuICAgICAgdmFyIHRvdWNoID0gdG91Y2hFdmVudC5jaGFuZ2VkVG91Y2hlc1swXTtcbiAgICAgIGNsaWNrZWRFbGVtZW50ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludCh0b3VjaC5jbGllbnRYLCB0b3VjaC5jbGllbnRZKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2xpY2tlZEVsZW1lbnQgPSBzcmNFdmVudC50YXJnZXQ7XG4gICAgfVxuICAgIC8qIGVzbGludC1lbmFibGUgKi9cbiAgICB2YXIgcGFuZWxzID0gZmxpY2tpbmcucmVuZGVyZXIucGFuZWxzO1xuICAgIHZhciBjbGlja2VkUGFuZWwgPSBudWxsO1xuICAgIHRyeSB7XG4gICAgICBmb3IgKHZhciBwYW5lbHNfMSA9IF9fdmFsdWVzJDEocGFuZWxzKSwgcGFuZWxzXzFfMSA9IHBhbmVsc18xLm5leHQoKTsgIXBhbmVsc18xXzEuZG9uZTsgcGFuZWxzXzFfMSA9IHBhbmVsc18xLm5leHQoKSkge1xuICAgICAgICB2YXIgcGFuZWwgPSBwYW5lbHNfMV8xLnZhbHVlO1xuICAgICAgICBpZiAocGFuZWwuY29udGFpbnMoY2xpY2tlZEVsZW1lbnQpKSB7XG4gICAgICAgICAgY2xpY2tlZFBhbmVsID0gcGFuZWw7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlXzFfMSkge1xuICAgICAgZV8xID0ge1xuICAgICAgICBlcnJvcjogZV8xXzFcbiAgICAgIH07XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChwYW5lbHNfMV8xICYmICFwYW5lbHNfMV8xLmRvbmUgJiYgKF9hID0gcGFuZWxzXzEucmV0dXJuKSkgX2EuY2FsbChwYW5lbHNfMSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjbGlja2VkUGFuZWwpIHtcbiAgICAgIHZhciBjYW1lcmFQb3NpdGlvbiA9IGZsaWNraW5nLmNhbWVyYS5wb3NpdGlvbjtcbiAgICAgIHZhciBjbGlja2VkUGFuZWxQb3NpdGlvbiA9IGNsaWNrZWRQYW5lbC5wb3NpdGlvbjtcbiAgICAgIGZsaWNraW5nLnRyaWdnZXIobmV3IENvbXBvbmVudEV2ZW50JDEoRVZFTlRTLlNFTEVDVCwge1xuICAgICAgICBpbmRleDogY2xpY2tlZFBhbmVsLmluZGV4LFxuICAgICAgICBwYW5lbDogY2xpY2tlZFBhbmVsLFxuICAgICAgICAvLyBEaXJlY3Rpb24gdG8gdGhlIGNsaWNrZWQgcGFuZWxcbiAgICAgICAgZGlyZWN0aW9uOiBnZXREaXJlY3Rpb24kMShjYW1lcmFQb3NpdGlvbiwgY2xpY2tlZFBhbmVsUG9zaXRpb24pXG4gICAgICB9KSk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gSG9sZGluZ1N0YXRlO1xufShTdGF0ZSk7XG5cbi8qKlxyXG4gKiBBIHN0YXRlIHRoYXQgYWN0aXZhdGVzIHdoZW4gdXNlcidzIGRyYWdnaW5nIHRoZSBGbGlja2luZyBhcmVhXHJcbiAqIEBrbyDsgqzsmqnsnpDqsIAg65Oc656Y6rmF7KSR7J24IOyDge2DnFxyXG4gKiBAaW50ZXJuYWxcclxuICovXG52YXIgRHJhZ2dpbmdTdGF0ZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyQzKERyYWdnaW5nU3RhdGUsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIERyYWdnaW5nU3RhdGUoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHVzZXIgaXMgY2xpY2tpbmcgb3IgdG91Y2hpbmdcclxuICAgICAqIEBrbyDtmITsnqwg7IKs7Jqp7J6Q6rCAIO2BtOumrS/thLDsuZjspJHsnbjsp4Ag7Jes67aAXHJcbiAgICAgKiBAdHlwZSB7dHJ1ZX1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgX3RoaXMuaG9sZGluZyA9IHRydWU7XG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIEZsaWNraW5nJ3MgYW5pbWF0aW5nXHJcbiAgICAgKiBAa28g7ZiE7J6sIOyVoOuLiOuplOydtOyFmCDrj5nsnpEg7Jes67aAXHJcbiAgICAgKiBAdHlwZSB7dHJ1ZX1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgX3RoaXMuYW5pbWF0aW5nID0gdHJ1ZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgdmFyIF9fcHJvdG8gPSBEcmFnZ2luZ1N0YXRlLnByb3RvdHlwZTtcbiAgX19wcm90by5vbkNoYW5nZSA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICB0aGlzLl9tb3ZlVG9DaGFuZ2VkUG9zaXRpb24oY3R4KTtcbiAgfTtcbiAgX19wcm90by5vblJlbGVhc2UgPSBmdW5jdGlvbiAoY3R4KSB7XG4gICAgdmFyIF9hO1xuICAgIHZhciBmbGlja2luZyA9IGN0eC5mbGlja2luZyxcbiAgICAgIGF4ZXNFdmVudCA9IGN0eC5heGVzRXZlbnQsXG4gICAgICB0cmFuc2l0VG8gPSBjdHgudHJhbnNpdFRvO1xuICAgIC8vIFVwZGF0ZSBsYXN0IHBvc2l0aW9uIHRvIGNvcGUgd2l0aCBBeGVzJ3MgYW5pbWF0aW5nIGJlaGF2aW9yXG4gICAgLy8gQXhlcyB1c2VzIHN0YXJ0IHBvc2l0aW9uIHdoZW4gYW5pbWF0aW9uIHN0YXJ0XG4gICAgZmxpY2tpbmcudHJpZ2dlcihuZXcgQ29tcG9uZW50RXZlbnQkMShFVkVOVFMuSE9MRF9FTkQsIHtcbiAgICAgIGF4ZXNFdmVudDogYXhlc0V2ZW50XG4gICAgfSkpO1xuICAgIGlmIChmbGlja2luZy5yZW5kZXJlci5wYW5lbENvdW50IDw9IDApIHtcbiAgICAgIC8vIFRoZXJlJ3JlIG5vIHBhbmVsc1xuICAgICAgdHJhbnNpdFRvKFNUQVRFX1RZUEUuSURMRSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRyYW5zaXRUbyhTVEFURV9UWVBFLkFOSU1BVElORyk7XG4gICAgdmFyIGNvbnRyb2wgPSBmbGlja2luZy5jb250cm9sO1xuICAgIHZhciBwb3NpdGlvbiA9IGF4ZXNFdmVudC5kZXN0UG9zW1BPU0lUSU9OX0tFWV07XG4gICAgdmFyIGR1cmF0aW9uID0gTWF0aC5tYXgoYXhlc0V2ZW50LmR1cmF0aW9uLCBmbGlja2luZy5kdXJhdGlvbik7XG4gICAgdHJ5IHtcbiAgICAgIHZvaWQgY29udHJvbC5tb3ZlVG9Qb3NpdGlvbihwb3NpdGlvbiwgZHVyYXRpb24sIGF4ZXNFdmVudCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0cmFuc2l0VG8oU1RBVEVfVFlQRS5JRExFKTtcbiAgICAgIGF4ZXNFdmVudC5zZXRUbygoX2EgPSB7fSwgX2FbUE9TSVRJT05fS0VZXSA9IGZsaWNraW5nLmNhbWVyYS5wb3NpdGlvbiwgX2EpLCAwKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBEcmFnZ2luZ1N0YXRlO1xufShTdGF0ZSk7XG5cbi8qKlxyXG4gKiBBIHN0YXRlIHRoYXQgYWN0aXZhdGVzIHdoZW4gRmxpY2tpbmcncyBhbmltYXRpbmcgYnkgdXNlciBpbnB1dCBvciBtZXRob2QgY2FsbFxyXG4gKiBAa28g7IKs7Jqp7J6QIOyeheugpeydtOuCmCDrqZTshozrk5wg7Zi47Lac7JeQIOydmO2VtCBGbGlja2luZ+ydmCDslaDri4jrqZTsnbTshZjsnbQg64+Z7J6R7KSR7J24IOyDge2DnFxyXG4gKiBAaW50ZXJuYWxcclxuICovXG52YXIgQW5pbWF0aW5nU3RhdGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMkMyhBbmltYXRpbmdTdGF0ZSwgX3N1cGVyKTtcbiAgZnVuY3Rpb24gQW5pbWF0aW5nU3RhdGUoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHVzZXIgaXMgY2xpY2tpbmcgb3IgdG91Y2hpbmdcclxuICAgICAqIEBrbyDtmITsnqwg7IKs7Jqp7J6Q6rCAIO2BtOumrS/thLDsuZjspJHsnbjsp4Ag7Jes67aAXHJcbiAgICAgKiBAdHlwZSB7ZmFsc2V9XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIF90aGlzLmhvbGRpbmcgPSBmYWxzZTtcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgRmxpY2tpbmcncyBhbmltYXRpbmdcclxuICAgICAqIEBrbyDtmITsnqwg7JWg64uI66mU7J207IWYIOuPmeyekSDsl6zrtoBcclxuICAgICAqIEB0eXBlIHt0cnVlfVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBfdGhpcy5hbmltYXRpbmcgPSB0cnVlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICB2YXIgX19wcm90byA9IEFuaW1hdGluZ1N0YXRlLnByb3RvdHlwZTtcbiAgX19wcm90by5vbkhvbGQgPSBmdW5jdGlvbiAoY3R4KSB7XG4gICAgdmFyIGZsaWNraW5nID0gY3R4LmZsaWNraW5nLFxuICAgICAgYXhlc0V2ZW50ID0gY3R4LmF4ZXNFdmVudCxcbiAgICAgIHRyYW5zaXRUbyA9IGN0eC50cmFuc2l0VG87XG4gICAgdmFyIHRhcmdldFBhbmVsID0gdGhpcy5fdGFyZ2V0UGFuZWw7XG4gICAgdmFyIGNvbnRyb2wgPSBmbGlja2luZy5jb250cm9sO1xuICAgIHRoaXMuX2RlbHRhID0gMDtcbiAgICBmbGlja2luZy5jb250cm9sLnVwZGF0ZUlucHV0KCk7XG4gICAgaWYgKGZsaWNraW5nLmNoYW5nZU9uSG9sZCAmJiB0YXJnZXRQYW5lbCkge1xuICAgICAgY29udHJvbC5zZXRBY3RpdmUodGFyZ2V0UGFuZWwsIGNvbnRyb2wuYWN0aXZlUGFuZWwsIGF4ZXNFdmVudC5pc1RydXN0ZWQpO1xuICAgIH1cbiAgICB2YXIgaG9sZFN0YXJ0RXZlbnQgPSBuZXcgQ29tcG9uZW50RXZlbnQkMShFVkVOVFMuSE9MRF9TVEFSVCwge1xuICAgICAgYXhlc0V2ZW50OiBheGVzRXZlbnRcbiAgICB9KTtcbiAgICBmbGlja2luZy50cmlnZ2VyKGhvbGRTdGFydEV2ZW50KTtcbiAgICBpZiAoaG9sZFN0YXJ0RXZlbnQuaXNDYW5jZWxlZCgpKSB7XG4gICAgICB0cmFuc2l0VG8oU1RBVEVfVFlQRS5ESVNBQkxFRCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyYW5zaXRUbyhTVEFURV9UWVBFLkRSQUdHSU5HKTtcbiAgICB9XG4gIH07XG4gIF9fcHJvdG8ub25DaGFuZ2UgPSBmdW5jdGlvbiAoY3R4KSB7XG4gICAgdGhpcy5fbW92ZVRvQ2hhbmdlZFBvc2l0aW9uKGN0eCk7XG4gIH07XG4gIF9fcHJvdG8ub25GaW5pc2ggPSBmdW5jdGlvbiAoY3R4KSB7XG4gICAgdmFyIGZsaWNraW5nID0gY3R4LmZsaWNraW5nLFxuICAgICAgYXhlc0V2ZW50ID0gY3R4LmF4ZXNFdmVudCxcbiAgICAgIHRyYW5zaXRUbyA9IGN0eC50cmFuc2l0VG87XG4gICAgdmFyIGNvbnRyb2wgPSBmbGlja2luZy5jb250cm9sO1xuICAgIHZhciBjb250cm9sbGVyID0gY29udHJvbC5jb250cm9sbGVyO1xuICAgIHZhciBhbmltYXRpbmdDb250ZXh0ID0gY29udHJvbGxlci5hbmltYXRpbmdDb250ZXh0O1xuICAgIHRyYW5zaXRUbyhTVEFURV9UWVBFLklETEUpO1xuICAgIGZsaWNraW5nLnRyaWdnZXIobmV3IENvbXBvbmVudEV2ZW50JDEoRVZFTlRTLk1PVkVfRU5ELCB7XG4gICAgICBpc1RydXN0ZWQ6IGF4ZXNFdmVudC5pc1RydXN0ZWQsXG4gICAgICBkaXJlY3Rpb246IGdldERpcmVjdGlvbiQxKGFuaW1hdGluZ0NvbnRleHQuc3RhcnQsIGFuaW1hdGluZ0NvbnRleHQuZW5kKSxcbiAgICAgIGF4ZXNFdmVudDogYXhlc0V2ZW50XG4gICAgfSkpO1xuICAgIHZhciB0YXJnZXRQYW5lbCA9IHRoaXMuX3RhcmdldFBhbmVsO1xuICAgIGlmICh0YXJnZXRQYW5lbCkge1xuICAgICAgY29udHJvbC5zZXRBY3RpdmUodGFyZ2V0UGFuZWwsIGNvbnRyb2wuYWN0aXZlUGFuZWwsIGF4ZXNFdmVudC5pc1RydXN0ZWQpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIEFuaW1hdGluZ1N0YXRlO1xufShTdGF0ZSk7XG5cbi8qKlxyXG4gKiBBIHN0YXRlIHRoYXQgYWN0aXZhdGVzIHdoZW4gRmxpY2tpbmcgaXMgc3RvcHBlZCBieSBldmVudCdzIGBzdG9wYCBtZXRob2RcclxuICogQGtvIOydtOuypO2KuOydmCBgc3RvcGDtmLjstpzsl5Ag7J2Y7ZW0IEZsaWNraW5n7J20IOygleyngOuQnCDsg4Htg5xcclxuICogQGludGVybmFsXHJcbiAqL1xudmFyIERpc2FibGVkU3RhdGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMkMyhEaXNhYmxlZFN0YXRlLCBfc3VwZXIpO1xuICBmdW5jdGlvbiBEaXNhYmxlZFN0YXRlKCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIC8qKlxyXG4gICAgICogV2hldGhlciB1c2VyIGlzIGNsaWNraW5nIG9yIHRvdWNoaW5nXHJcbiAgICAgKiBAa28g7ZiE7J6sIOyCrOyaqeyekOqwgCDtgbTrpq0v7YSw7LmY7KSR7J247KeAIOyXrOu2gFxyXG4gICAgICogQHR5cGUge2ZhbHNlfVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBfdGhpcy5ob2xkaW5nID0gZmFsc2U7XG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIEZsaWNraW5nJ3MgYW5pbWF0aW5nXHJcbiAgICAgKiBAa28g7ZiE7J6sIOyVoOuLiOuplOydtOyFmCDrj5nsnpEg7Jes67aAXHJcbiAgICAgKiBAdHlwZSB7dHJ1ZX1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgX3RoaXMuYW5pbWF0aW5nID0gdHJ1ZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgdmFyIF9fcHJvdG8gPSBEaXNhYmxlZFN0YXRlLnByb3RvdHlwZTtcbiAgX19wcm90by5vbkFuaW1hdGlvbkVuZCA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICB2YXIgdHJhbnNpdFRvID0gY3R4LnRyYW5zaXRUbztcbiAgICB0cmFuc2l0VG8oU1RBVEVfVFlQRS5JRExFKTtcbiAgfTtcbiAgX19wcm90by5vbkNoYW5nZSA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICB2YXIgYXhlc0V2ZW50ID0gY3R4LmF4ZXNFdmVudCxcbiAgICAgIHRyYW5zaXRUbyA9IGN0eC50cmFuc2l0VG87XG4gICAgLy8gQ2FuIHN0b3AgQXhlcydzIGNoYW5nZSBldmVudFxuICAgIGF4ZXNFdmVudC5zdG9wKCk7XG4gICAgdHJhbnNpdFRvKFNUQVRFX1RZUEUuSURMRSk7XG4gIH07XG4gIF9fcHJvdG8ub25SZWxlYXNlID0gZnVuY3Rpb24gKGN0eCkge1xuICAgIHZhciBheGVzRXZlbnQgPSBjdHguYXhlc0V2ZW50LFxuICAgICAgdHJhbnNpdFRvID0gY3R4LnRyYW5zaXRUbztcbiAgICAvLyBUaGlzIGlzIG5lZWRlZCB3aGVuIHN0b3BwZWQgaG9sZCBzdGFydCBldmVudFxuICAgIGlmIChheGVzRXZlbnQuZGVsdGEuZmxpY2sgPT09IDApIHtcbiAgICAgIHRyYW5zaXRUbyhTVEFURV9UWVBFLklETEUpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIERpc2FibGVkU3RhdGU7XG59KFN0YXRlKTtcblxuLyoqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cbnZhciBTdGF0ZU1hY2hpbmUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTdGF0ZU1hY2hpbmUoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB0aGlzLnRyYW5zaXRUbyA9IGZ1bmN0aW9uIChuZXh0U3RhdGVUeXBlKSB7XG4gICAgICB2YXIgbmV4dFN0YXRlO1xuICAgICAgc3dpdGNoIChuZXh0U3RhdGVUeXBlKSB7XG4gICAgICAgIGNhc2UgU1RBVEVfVFlQRS5JRExFOlxuICAgICAgICAgIG5leHRTdGF0ZSA9IG5ldyBJZGxlU3RhdGUoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBTVEFURV9UWVBFLkhPTERJTkc6XG4gICAgICAgICAgbmV4dFN0YXRlID0gbmV3IEhvbGRpbmdTdGF0ZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFNUQVRFX1RZUEUuRFJBR0dJTkc6XG4gICAgICAgICAgbmV4dFN0YXRlID0gbmV3IERyYWdnaW5nU3RhdGUoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBTVEFURV9UWVBFLkFOSU1BVElORzpcbiAgICAgICAgICBuZXh0U3RhdGUgPSBuZXcgQW5pbWF0aW5nU3RhdGUoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBTVEFURV9UWVBFLkRJU0FCTEVEOlxuICAgICAgICAgIG5leHRTdGF0ZSA9IG5ldyBEaXNhYmxlZFN0YXRlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBuZXh0U3RhdGUub25FbnRlcihfdGhpcy5fc3RhdGUpO1xuICAgICAgX3RoaXMuX3N0YXRlID0gbmV4dFN0YXRlO1xuICAgICAgcmV0dXJuIF90aGlzLl9zdGF0ZTtcbiAgICB9O1xuICAgIHRoaXMuX3N0YXRlID0gbmV3IElkbGVTdGF0ZSgpO1xuICB9XG4gIHZhciBfX3Byb3RvID0gU3RhdGVNYWNoaW5lLnByb3RvdHlwZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwic3RhdGVcIiwge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBfX3Byb3RvLmZpcmUgPSBmdW5jdGlvbiAoZXZlbnRUeXBlLCBleHRlcm5hbEN0eCkge1xuICAgIHZhciBjdXJyZW50U3RhdGUgPSB0aGlzLl9zdGF0ZTtcbiAgICB2YXIgY3R4ID0gX19hc3NpZ24kMihfX2Fzc2lnbiQyKHt9LCBleHRlcm5hbEN0eCksIHtcbiAgICAgIHRyYW5zaXRUbzogdGhpcy50cmFuc2l0VG9cbiAgICB9KTtcbiAgICBzd2l0Y2ggKGV2ZW50VHlwZSkge1xuICAgICAgY2FzZSBFVkVOVC5IT0xEOlxuICAgICAgICBjdXJyZW50U3RhdGUub25Ib2xkKGN0eCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBFVkVOVC5DSEFOR0U6XG4gICAgICAgIGN1cnJlbnRTdGF0ZS5vbkNoYW5nZShjdHgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRVZFTlQuUkVMRUFTRTpcbiAgICAgICAgY3VycmVudFN0YXRlLm9uUmVsZWFzZShjdHgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRVZFTlQuQU5JTUFUSU9OX0VORDpcbiAgICAgICAgY3VycmVudFN0YXRlLm9uQW5pbWF0aW9uRW5kKGN0eCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBFVkVOVC5GSU5JU0g6XG4gICAgICAgIGN1cnJlbnRTdGF0ZS5vbkZpbmlzaChjdHgpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH07XG4gIHJldHVybiBTdGF0ZU1hY2hpbmU7XG59KCk7XG5cbi8qKlxyXG4gKiBBIGNvbnRyb2xsZXIgdGhhdCBoYW5kbGVzIHRoZSB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1heGVzLyBAZWdqcy9heGVzfSBldmVudHNcclxuICogQGtvIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWF4ZXMvIEBlZ2pzL2F4ZXN97J2YIOydtOuypO2KuOulvCDsspjrpqztlZjripQg7Luo7Yq466Gk65+sIOy7tO2PrOuEjO2KuFxyXG4gKiBAaW50ZXJuYWxcclxuICovXG52YXIgQXhlc0NvbnRyb2xsZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKiogKi9cbiAgZnVuY3Rpb24gQXhlc0NvbnRyb2xsZXIoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB0aGlzLl9vbkF4ZXNIb2xkID0gZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuX2RyYWdnZWQgPSBmYWxzZTtcbiAgICB9O1xuICAgIHRoaXMuX29uQXhlc0NoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIF90aGlzLl9kcmFnZ2VkID0gISEoKF9hID0gX3RoaXMuX3BhbklucHV0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXNFbmFibGVkKCkpO1xuICAgIH07XG4gICAgdGhpcy5fcHJldmVudENsaWNrV2hlbkRyYWdnZWQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKF90aGlzLl9kcmFnZ2VkKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIH1cbiAgICAgIF90aGlzLl9kcmFnZ2VkID0gZmFsc2U7XG4gICAgfTtcbiAgICB0aGlzLl9yZXNldEludGVybmFsVmFsdWVzKCk7XG4gICAgdGhpcy5fc3RhdGVNYWNoaW5lID0gbmV3IFN0YXRlTWFjaGluZSgpO1xuICB9XG4gIHZhciBfX3Byb3RvID0gQXhlc0NvbnRyb2xsZXIucHJvdG90eXBlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJheGVzXCIsIHtcbiAgICAvKipcclxuICAgICAqIEFuIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWF4ZXMvZG9jcy9hcGkvQXhlcyBBeGVzfSBpbnN0YW5jZVxyXG4gICAgICogQGtvIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWF4ZXMvZG9jcy9hcGkvQXhlcyBBeGVzfeydmCDsnbjsiqTthLTsiqRcclxuICAgICAqIEB0eXBlIHtBeGVzIHwgbnVsbH1cclxuICAgICAqIEBzZWUgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1heGVzL2RvY3MvYXBpL0F4ZXNcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYXhlcztcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwicGFuSW5wdXRcIiwge1xuICAgIC8qKlxyXG4gICAgICogQW4ge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtYXhlcy9kb2NzL2FwaS9QYW5JbnB1dCBQYW5JbnB1dH0gaW5zdGFuY2VcclxuICAgICAqIEBrbyB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1heGVzL2RvY3MvYXBpL1BhbklucHV0IFBhbklucHV0feydmCDsnbjsiqTthLTsiqRcclxuICAgICAqIEB0eXBlIHtQYW5JbnB1dCB8IG51bGx9XHJcbiAgICAgKiBAc2VlIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtYXhlcy9kb2NzL2FwaS9QYW5JbnB1dFxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wYW5JbnB1dDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwic3RhdGVNYWNoaW5lXCIsIHtcbiAgICAvKipcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3RhdGVNYWNoaW5lO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJzdGF0ZVwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBBIGFjdGl2YXRlZCB7QGxpbmsgU3RhdGV9IHRoYXQgc2hvd3MgdGhlIGN1cnJlbnQgc3RhdHVzIG9mIHRoZSB1c2VyIGlucHV0IG9yIHRoZSBhbmltYXRpb25cclxuICAgICAqIEBrbyDtmITsnqwg7Zmc7ISx7ZmU65CcIHtAbGluayBTdGF0ZX0g7J247Iqk7YS07Iqk66GcIOyCrOyaqeyekCDsnoXroKUg65iQ64qUIOyVoOuLiOuplOydtOyFmCDsg4Htg5zrpbwg64KY7YOA64OF64uI64ukXHJcbiAgICAgKiBAdHlwZSB7U3RhdGV9XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdGF0ZU1hY2hpbmUuc3RhdGU7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcImFuaW1hdGluZ0NvbnRleHRcIiwge1xuICAgIC8qKlxyXG4gICAgICogQSBjb250ZXh0IG9mIHRoZSBjdXJyZW50IGFuaW1hdGlvbiBwbGF5aW5nXHJcbiAgICAgKiBAa28g7ZiE7J6sIOyerOyDneykkeyduCDslaDri4jrqZTsnbTshZgg7KCV67O0XHJcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHN0YXJ0IEEgc3RhcnQgcG9zaXRpb24gb2YgdGhlIGFuaW1hdGlvbjxrbz7slaDri4jrqZTsnbTshZgg7Iuc7J6RIOyngOygkDwva28+XHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZW5kIEEgZW5kIHBvc2l0aW9uIG9mIHRoZSBhbmltYXRpb248a28+7JWg64uI66mU7J207IWYIOuBnSDsp4DsoJA8L2tvPlxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG9mZnNldCBjYW1lcmEgb2Zmc2V0PGtvPuy5tOuplOudvCDsmKTtlITshYs8L2tvPlxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9hbmltYXRpbmdDb250ZXh0O1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJjb250cm9sUGFyYW1zXCIsIHtcbiAgICAvKipcclxuICAgICAqIEEgY3VycmVudCBjb250cm9sIHBhcmFtZXRlcnMgb2YgdGhlIEF4ZXMgaW5zdGFuY2VcclxuICAgICAqIEBrbyDtmZzshLHtmZTrkJwg7ZiE7J6sIEF4ZXMg7Yyo65+s66+47YSw65OkXHJcbiAgICAgKiBAdHlwZSB7Q29udHJvbFBhcmFtc31cclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGF4ZXMgPSB0aGlzLl9heGVzO1xuICAgICAgaWYgKCFheGVzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmFuZ2U6IHtcbiAgICAgICAgICAgIG1pbjogMCxcbiAgICAgICAgICAgIG1heDogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgcG9zaXRpb246IDAsXG4gICAgICAgICAgY2lyY3VsYXI6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB2YXIgYXhpcyA9IGF4ZXMuYXhpc1tQT1NJVElPTl9LRVldO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmFuZ2U6IHtcbiAgICAgICAgICBtaW46IGF4aXMucmFuZ2VbMF0sXG4gICAgICAgICAgbWF4OiBheGlzLnJhbmdlWzFdXG4gICAgICAgIH0sXG4gICAgICAgIGNpcmN1bGFyOiBheGlzLmNpcmN1bGFyWzBdLFxuICAgICAgICBwb3NpdGlvbjogdGhpcy5wb3NpdGlvblxuICAgICAgfTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwiZW5hYmxlZFwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBBIEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSB1c2VyIGlucHV0IGlzIGVuYWJsZWRcclxuICAgICAqIEBrbyDtmITsnqwg7IKs7Jqp7J6QIOyeheugpeydtCDtmZzshLHtmZTrkJjsl4jripTsp4Drpbwg64KY7YOA64K064qUIOqwklxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLl9wYW5JbnB1dCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzRW5hYmxlZCgpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBmYWxzZTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwicG9zaXRpb25cIiwge1xuICAgIC8qKlxyXG4gICAgICogQ3VycmVudCBwb3NpdGlvbiB2YWx1ZSBpbiB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1heGVzL3JlbGVhc2UvbGF0ZXN0L2RvYy9lZy5BeGVzLmh0bWwgQXhlc30gaW5zdGFuY2VcclxuICAgICAqIEBrbyB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1heGVzL3JlbGVhc2UvbGF0ZXN0L2RvYy9lZy5BeGVzLmh0bWwgQXhlc30g7J247Iqk7YS07IqkIOuCtOu2gOydmCDtmITsnqwg7KKM7ZGcIOqwklxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMuX2F4ZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXQoW1BPU0lUSU9OX0tFWV0pW1BPU0lUSU9OX0tFWV0pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDA7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcInJhbmdlXCIsIHtcbiAgICAvKipcclxuICAgICAqIEN1cnJlbnQgcmFuZ2UgdmFsdWUgaW4ge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtYXhlcy9yZWxlYXNlL2xhdGVzdC9kb2MvZWcuQXhlcy5odG1sIEF4ZXN9IGluc3RhbmNlXHJcbiAgICAgKiBAa28ge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtYXhlcy9yZWxlYXNlL2xhdGVzdC9kb2MvZWcuQXhlcy5odG1sIEF4ZXN9IOyduOyKpO2EtOyKpCDrgrTrtoDsnZgg7ZiE7J6sIOydtOuPmSDrspTsnIQg6rCSXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyW119XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLl9heGVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYXhpc1tQT1NJVElPTl9LRVldLnJhbmdlKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbMCwgMF07XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcImJvdW5jZVwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBBY3R1YWwgYm91bmNlIHNpemUocHgpXHJcbiAgICAgKiBAa28g7KCB7Jqp65CcIGJvdW5jZSDtgazquLAocHgg64uo7JyEKVxyXG4gICAgICogQHR5cGUge251bWJlcltdfVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIHJldHVybiAoX2EgPSB0aGlzLl9heGVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYXhpc1tQT1NJVElPTl9LRVldLmJvdW5jZTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgLyoqXHJcbiAgICogSW5pdGlhbGl6ZSBBeGVzQ29udHJvbGxlclxyXG4gICAqIEBrbyBBeGVzQ29udHJvbGxlcuulvCDstIjquLDtmZTtlanri4jri6RcclxuICAgKiBAcGFyYW0ge0ZsaWNraW5nfSBmbGlja2luZyBBbiBpbnN0YW5jZSBvZiBGbGlja2luZ1xyXG4gICAqIEBjaGFpbmFibGVcclxuICAgKiBAcmV0dXJuIHt0aGlzfVxyXG4gICAqL1xuICBfX3Byb3RvLmluaXQgPSBmdW5jdGlvbiAoZmxpY2tpbmcpIHtcbiAgICB2YXIgX2E7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB0aGlzLl9mbGlja2luZyA9IGZsaWNraW5nO1xuICAgIHRoaXMuX2F4ZXMgPSBuZXcgQXhlcygoX2EgPSB7fSwgX2FbUE9TSVRJT05fS0VZXSA9IHtcbiAgICAgIHJhbmdlOiBbMCwgMF0sXG4gICAgICBjaXJjdWxhcjogZmFsc2UsXG4gICAgICBib3VuY2U6IFswLCAwXVxuICAgIH0sIF9hKSwge1xuICAgICAgZGVjZWxlcmF0aW9uOiBmbGlja2luZy5kZWNlbGVyYXRpb24sXG4gICAgICBpbnRlcnJ1cHRhYmxlOiBmbGlja2luZy5pbnRlcnJ1cHRhYmxlLFxuICAgICAgbmVzdGVkOiBmbGlja2luZy5uZXN0ZWQsXG4gICAgICBlYXNpbmc6IGZsaWNraW5nLmVhc2luZ1xuICAgIH0pO1xuICAgIHRoaXMuX3BhbklucHV0ID0gbmV3IFBhbklucHV0KGZsaWNraW5nLnZpZXdwb3J0LmVsZW1lbnQsIHtcbiAgICAgIGlucHV0VHlwZTogZmxpY2tpbmcuaW5wdXRUeXBlLFxuICAgICAgdGhyZXNob2xkOiAxLFxuICAgICAgaU9TRWRnZVN3aXBlVGhyZXNob2xkOiBmbGlja2luZy5pT1NFZGdlU3dpcGVUaHJlc2hvbGQsXG4gICAgICBwcmV2ZW50RGVmYXVsdE9uRHJhZzogZmxpY2tpbmcucHJldmVudERlZmF1bHRPbkRyYWcsXG4gICAgICBzY2FsZTogZmxpY2tpbmcuaG9yaXpvbnRhbCA/IFtmbGlja2luZy5jYW1lcmEucGFuZWxPcmRlciA9PT0gT1JERVIuUlRMID8gMSA6IC0xLCAwXSA6IFswLCAtMV0sXG4gICAgICByZWxlYXNlT25TY3JvbGw6IHRydWVcbiAgICB9KTtcbiAgICB2YXIgYXhlcyA9IHRoaXMuX2F4ZXM7XG4gICAgYXhlcy5jb25uZWN0KGZsaWNraW5nLmhvcml6b250YWwgPyBbUE9TSVRJT05fS0VZLCBcIlwiXSA6IFtcIlwiLCBQT1NJVElPTl9LRVldLCB0aGlzLl9wYW5JbnB1dCk7XG4gICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICB2YXIgZXZlbnRUeXBlID0gRVZFTlRba2V5XTtcbiAgICAgIGF4ZXMub24oZXZlbnRUeXBlLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBfdGhpcy5fc3RhdGVNYWNoaW5lLmZpcmUoZXZlbnRUeXBlLCB7XG4gICAgICAgICAgZmxpY2tpbmc6IGZsaWNraW5nLFxuICAgICAgICAgIGF4ZXNFdmVudDogZVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgZm9yICh2YXIga2V5IGluIEVWRU5UKSB7XG4gICAgICBfbG9vcF8xKGtleSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcclxuICAgKiBEZXN0cm95IEF4ZXNDb250cm9sbGVyIGFuZCByZXR1cm4gdG8gaW5pdGlhbCBzdGF0ZVxyXG4gICAqIEBrbyBBeGVzQ29udHJvbGxlcuulvCDstIjquLAg7IOB7YOc66GcIOuQmOuPjOumveuLiOuLpFxyXG4gICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICovXG4gIF9fcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKHRoaXMuX2F4ZXMpIHtcbiAgICAgIHRoaXMucmVtb3ZlUHJldmVudENsaWNrSGFuZGxlcigpO1xuICAgICAgdGhpcy5fYXhlcy5kZXN0cm95KCk7XG4gICAgfVxuICAgIChfYSA9IHRoaXMuX3BhbklucHV0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGVzdHJveSgpO1xuICAgIHRoaXMuX3Jlc2V0SW50ZXJuYWxWYWx1ZXMoKTtcbiAgfTtcbiAgLyoqXHJcbiAgICogRW5hYmxlIGlucHV0IGZyb20gdGhlIHVzZXIgKG1vdXNlL3RvdWNoKVxyXG4gICAqIEBrbyDsgqzsmqnsnpDsnZgg7J6F66ClKOuniOyasOyKpC/thLDsuZgp66W8IO2ZnOyEse2ZlO2VqeuLiOuLpFxyXG4gICAqIEBjaGFpbmFibGVcclxuICAgKiBAcmV0dXJuIHt0aGlzfVxyXG4gICAqL1xuICBfX3Byb3RvLmVuYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX2E7XG4gICAgKF9hID0gdGhpcy5fcGFuSW5wdXQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5lbmFibGUoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXHJcbiAgICogRGlzYWJsZSBpbnB1dCBmcm9tIHRoZSB1c2VyIChtb3VzZS90b3VjaClcclxuICAgKiBAa28g7IKs7Jqp7J6Q7J2YIOyeheugpSjrp4jsmrDsiqQv7YSw7LmYKeulvCDrp4nsirXri4jri6RcclxuICAgKiBAY2hhaW5hYmxlXHJcbiAgICogQHJldHVybiB7dGhpc31cclxuICAgKi9cbiAgX19wcm90by5kaXNhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfYTtcbiAgICAoX2EgPSB0aGlzLl9wYW5JbnB1dCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRpc2FibGUoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXHJcbiAgICogUmVsZWFzZXMgb25nb2luZyB1c2VyIGlucHV0IChtb3VzZS90b3VjaClcclxuICAgKiBAa28g7IKs7Jqp7J6Q7J2YIO2YhOyerCDsnoXroKUo66eI7Jqw7IqkL+2EsOy5mCnrpbwg7KSR64uo7Iuc7YK164uI64ukXHJcbiAgICogQGNoYWluYWJsZVxyXG4gICAqIEByZXR1cm4ge3RoaXN9XHJcbiAgICovXG4gIF9fcHJvdG8ucmVsZWFzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX2E7XG4gICAgKF9hID0gdGhpcy5fcGFuSW5wdXQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZWxlYXNlKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxyXG4gICAqIENoYW5nZSB0aGUgZGVzdGluYXRpb24gYW5kIGR1cmF0aW9uIG9mIHRoZSBhbmltYXRpb24gY3VycmVudGx5IHBsYXlpbmdcclxuICAgKiBAa28g7J6s7IOdIOykkeyduCDslaDri4jrqZTsnbTshZjsnZgg66qp7KCB7KeA7JmAIOyerOyDnSDsi5zqsITsnYQg67OA6rK97ZWp64uI64ukXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHBvc2l0aW9uIEEgcG9zaXRpb24gdG8gbW92ZTxrbz7snbTrj5ntlaAg7KKM7ZGcPC9rbz5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gZHVyYXRpb24gRHVyYXRpb24gb2YgdGhlIGFuaW1hdGlvbiAodW5pdDogbXMpPGtvPuyVoOuLiOuplOydtOyFmCDsp4Ttlokg7Iuc6rCEICjri6jsnIQ6IG1zKTwva28+XHJcbiAgICogQGNoYWluYWJsZVxyXG4gICAqIEByZXR1cm4ge3RoaXN9XHJcbiAgICovXG4gIF9fcHJvdG8udXBkYXRlQW5pbWF0aW9uID0gZnVuY3Rpb24gKHBvc2l0aW9uLCBkdXJhdGlvbikge1xuICAgIHZhciBfYTtcbiAgICB2YXIgX2I7XG4gICAgdGhpcy5fYW5pbWF0aW5nQ29udGV4dCA9IF9fYXNzaWduJDIoX19hc3NpZ24kMih7fSwgdGhpcy5fYW5pbWF0aW5nQ29udGV4dCksIHtcbiAgICAgIGVuZDogcG9zaXRpb25cbiAgICB9KTtcbiAgICAoX2IgPSB0aGlzLl9heGVzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudXBkYXRlQW5pbWF0aW9uKHtcbiAgICAgIGRlc3RQb3M6IChfYSA9IHt9LCBfYVtQT1NJVElPTl9LRVldID0gcG9zaXRpb24sIF9hKSxcbiAgICAgIGR1cmF0aW9uOiBkdXJhdGlvblxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcclxuICAgKiBTdG9wcyB0aGUgYW5pbWF0aW9uIGN1cnJlbnRseSBwbGF5aW5nXHJcbiAgICogQGtvIOyerOyDnSDspJHsnbgg7JWg64uI66mU7J207IWY7J2EIOykkeuLqOyLnO2CteuLiOuLpFxyXG4gICAqIEBjaGFpbmFibGVcclxuICAgKiBAcmV0dXJuIHt0aGlzfVxyXG4gICAqL1xuICBfX3Byb3RvLnN0b3BBbmltYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9hO1xuICAgIChfYSA9IHRoaXMuX2F4ZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdG9wQW5pbWF0aW9uKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxyXG4gICAqIFVwZGF0ZSB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1heGVzLyBAZWdqcy9heGVzfSdzIHN0YXRlXHJcbiAgICogQGtvIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWF4ZXMvIEBlZ2pzL2F4ZXN97J2YIOyDge2DnOulvCDqsLHsi6Dtlanri4jri6RcclxuICAgKiBAY2hhaW5hYmxlXHJcbiAgICogQHRocm93cyB7RmxpY2tpbmdFcnJvcn1cclxuICAgKiB7QGxpbmsgRVJST1JfQ09ERSBOT1RfQVRUQUNIRURfVE9fRkxJQ0tJTkd9IFdoZW4ge0BsaW5rIEF4ZXNDb250cm9sbGVyI2luaXQgaW5pdH0gaXMgbm90IGNhbGxlZCBiZWZvcmVcclxuICAgKiA8a28+e0BsaW5rIEF4ZXNDb250cm9sbGVyI2luaXQgaW5pdH3snbQg7J207KCE7JeQIO2YuOy2nOuQmOyngCDslYrsnYAg6rK97JqwPC9rbz5cclxuICAgKiBAcmV0dXJuIHt0aGlzfVxyXG4gICAqL1xuICBfX3Byb3RvLnVwZGF0ZSA9IGZ1bmN0aW9uIChjb250cm9sUGFyYW1zKSB7XG4gICAgdmFyIF9hO1xuICAgIHZhciBmbGlja2luZyA9IGdldEZsaWNraW5nQXR0YWNoZWQodGhpcy5fZmxpY2tpbmcpO1xuICAgIHZhciBjYW1lcmEgPSBmbGlja2luZy5jYW1lcmE7XG4gICAgdmFyIGF4ZXMgPSB0aGlzLl9heGVzO1xuICAgIHZhciBheGlzID0gYXhlcy5heGlzW1BPU0lUSU9OX0tFWV07XG4gICAgYXhpcy5jaXJjdWxhciA9IFtjb250cm9sUGFyYW1zLmNpcmN1bGFyLCBjb250cm9sUGFyYW1zLmNpcmN1bGFyXTtcbiAgICBheGlzLnJhbmdlID0gW2NvbnRyb2xQYXJhbXMucmFuZ2UubWluLCBjb250cm9sUGFyYW1zLnJhbmdlLm1heF07XG4gICAgYXhpcy5ib3VuY2UgPSBwYXJzZUJvdW5jZShmbGlja2luZy5ib3VuY2UsIGNhbWVyYS5zaXplKTtcbiAgICBheGVzLmF4aXNNYW5hZ2VyLnNldCgoX2EgPSB7fSwgX2FbUE9TSVRJT05fS0VZXSA9IGNvbnRyb2xQYXJhbXMucG9zaXRpb24sIF9hKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxyXG4gICAqIEF0dGFjaCBhIGhhbmRsZXIgdG8gdGhlIGNhbWVyYSBlbGVtZW50IHRvIHByZXZlbnQgY2xpY2sgZXZlbnRzIGR1cmluZyBhbmltYXRpb25cclxuICAgKiBAa28g7Lm066mU6528IOyXmOumrOuovO2KuOyXkCDslaDri4jrqZTsnbTshZgg64+E7KSR7JeQIO2BtOumrSDsnbTrsqTtirjrpbwg67Cp7KeA7ZWY64qUIO2VuOuTpOufrOulvCDrtoDssKntlanri4jri6RcclxuICAgKiBAcmV0dXJuIHt0aGlzfVxyXG4gICAqL1xuICBfX3Byb3RvLmFkZFByZXZlbnRDbGlja0hhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZsaWNraW5nID0gZ2V0RmxpY2tpbmdBdHRhY2hlZCh0aGlzLl9mbGlja2luZyk7XG4gICAgdmFyIGF4ZXMgPSB0aGlzLl9heGVzO1xuICAgIHZhciBjYW1lcmFFbCA9IGZsaWNraW5nLmNhbWVyYS5lbGVtZW50O1xuICAgIGF4ZXMub24oRVZFTlQuSE9MRCwgdGhpcy5fb25BeGVzSG9sZCk7XG4gICAgYXhlcy5vbihFVkVOVC5DSEFOR0UsIHRoaXMuX29uQXhlc0NoYW5nZSk7XG4gICAgY2FtZXJhRWwuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX3ByZXZlbnRDbGlja1doZW5EcmFnZ2VkLCB0cnVlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXHJcbiAgICogRGV0YWNoIGEgaGFuZGxlciB0byB0aGUgY2FtZXJhIGVsZW1lbnQgdG8gcHJldmVudCBjbGljayBldmVudHMgZHVyaW5nIGFuaW1hdGlvblxyXG4gICAqIEBrbyDsubTrqZTrnbwg7JeY66as66i87Yq47JeQIOyVoOuLiOuplOydtOyFmCDrj4TspJHsl5Ag7YG066atIOydtOuypO2KuOulvCDrsKnsp4DtlZjripQg7ZW465Ok65+s66W8IO2DiOywqe2VqeuLiOuLpFxyXG4gICAqIEByZXR1cm4ge3RoaXN9XHJcbiAgICovXG4gIF9fcHJvdG8ucmVtb3ZlUHJldmVudENsaWNrSGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZmxpY2tpbmcgPSBnZXRGbGlja2luZ0F0dGFjaGVkKHRoaXMuX2ZsaWNraW5nKTtcbiAgICB2YXIgYXhlcyA9IHRoaXMuX2F4ZXM7XG4gICAgdmFyIGNhbWVyYUVsID0gZmxpY2tpbmcuY2FtZXJhLmVsZW1lbnQ7XG4gICAgYXhlcy5vZmYoRVZFTlQuSE9MRCwgdGhpcy5fb25BeGVzSG9sZCk7XG4gICAgYXhlcy5vZmYoRVZFTlQuQ0hBTkdFLCB0aGlzLl9vbkF4ZXNDaGFuZ2UpO1xuICAgIGNhbWVyYUVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9wcmV2ZW50Q2xpY2tXaGVuRHJhZ2dlZCwgdHJ1ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxyXG4gICAqIFJ1biBBeGVzJ3Mge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtYXhlcy9yZWxlYXNlL2xhdGVzdC9kb2MvZWcuQXhlcy5odG1sI3NldFRvIHNldFRvfSB1c2luZyB0aGUgZ2l2ZW4gcG9zaXRpb25cclxuICAgKiBAa28gQXhlc+ydmCB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1heGVzL3JlbGVhc2UvbGF0ZXN0L2RvYy9lZy5BeGVzLmh0bWwjc2V0VG8gc2V0VG99IOuplOyGjOuTnOulvCDso7zslrTsp4Qg7KKM7ZGc66W8IOydtOyaqe2VmOyXrCDsiJjtlontlanri4jri6RcclxuICAgKiBAcGFyYW0ge251bWJlcn0gcG9zaXRpb24gQSBwb3NpdGlvbiB0byBtb3ZlPGtvPuydtOuPme2VoCDsooztkZw8L2tvPlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkdXJhdGlvbiBEdXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uICh1bml0OiBtcyk8a28+7JWg64uI66mU7J207IWYIOynhO2WiSDsi5zqsIQgKOuLqOychDogbXMpPC9rbz5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gW2F4ZXNFdmVudF0gSWYgcHJvdmlkZWQsIGl0J2xsIHVzZSBpdHMge0BsaW5rIGh0dHBzOi8vbmF2ZXIjZ2l0aHViI2lvL2VnanMtYXhlcy9yZWxlYXNlL2xhdGVzdC9kb2MvZWcjQXhlcyNodG1sI3NldFRvIHNldFRvfSBtZXRob2QgaW5zdGVhZDxrbz7snbQg6rCS7J20IOyjvOyWtOyhjOydhCDqsr3smrAsIO2VtOuLuSDsnbTrsqTtirjsnZgge0BsaW5rIGh0dHBzOi8vbmF2ZXIjZ2l0aHViI2lvL2VnanMtYXhlcy9yZWxlYXNlL2xhdGVzdC9kb2MvZWcjQXhlcyNodG1sI3NldFRvIHNldFRvfSDrqZTshozrk5zrpbwg64yA7Iug7ZW07IScIOyCrOyaqe2VqeuLiOuLpC48L2tvPlxyXG4gICAqIEB0aHJvd3Mge0ZsaWNraW5nRXJyb3J9XHJcbiAgICogfGNvZGV8Y29uZGl0aW9ufFxyXG4gICAqIHwtLS18LS0tfFxyXG4gICAqIHx7QGxpbmsgRVJST1JfQ09ERSBOT1RfQVRUQUNIRURfVE9fRkxJQ0tJTkd9fFdoZW4ge0BsaW5rIENvbnRyb2wjaW5pdCBpbml0fSBpcyBub3QgY2FsbGVkIGJlZm9yZXxcclxuICAgKiB8e0BsaW5rIEVSUk9SX0NPREUgQU5JTUFUSU9OX0lOVEVSUlVQVEVEfXxXaGVuIHRoZSBhbmltYXRpb24gaXMgaW50ZXJydXB0ZWQgYnkgdXNlciBpbnB1dHxcclxuICAgKiA8a28+XHJcbiAgICpcclxuICAgKiB8Y29kZXxjb25kaXRpb258XHJcbiAgICogfC0tLXwtLS18XHJcbiAgICogfHtAbGluayBFUlJPUl9DT0RFIE5PVF9BVFRBQ0hFRF9UT19GTElDS0lOR318e0BsaW5rIENvbnRyb2wjaW5pdCBpbml0feydtCDsnbTsoITsl5Ag7Zi47Lac65CY7KeAIOyViuydgCDqsr3smrB8XHJcbiAgICogfHtAbGluayBFUlJPUl9DT0RFIEFOSU1BVElPTl9JTlRFUlJVUFRFRH187IKs7Jqp7J6QIOyeheugpeyXkCDsnZjtlbQg7JWg64uI66mU7J207IWY7J20IOykkeuLqOuQnCDqsr3smrB8XHJcbiAgICpcclxuICAgKiA8L2tvPlxyXG4gICAqIEByZXR1cm4ge1Byb21pc2U8dm9pZD59IEEgUHJvbWlzZSB3aGljaCB3aWxsIGJlIHJlc29sdmVkIGFmdGVyIHJlYWNoaW5nIHRoZSB0YXJnZXQgcG9zaXRpb248a28+7ZW064u5IOyijO2RnCDrj4Tri6zsi5zsl5AgcmVzb2x2ZeuQmOuKlCBQcm9taXNlPC9rbz5cclxuICAgKi9cbiAgX19wcm90by5hbmltYXRlVG8gPSBmdW5jdGlvbiAocG9zaXRpb24sIGR1cmF0aW9uLCBheGVzRXZlbnQpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHZhciBfYTtcbiAgICB2YXIgYXhlcyA9IHRoaXMuX2F4ZXM7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5fc3RhdGVNYWNoaW5lLnN0YXRlO1xuICAgIGlmICghYXhlcykge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBGbGlja2luZ0Vycm9yKE1FU1NBR0UuTk9UX0FUVEFDSEVEX1RPX0ZMSUNLSU5HLCBDT0RFLk5PVF9BVFRBQ0hFRF9UT19GTElDS0lORykpO1xuICAgIH1cbiAgICB2YXIgc3RhcnRQb3MgPSBheGVzLmdldChbUE9TSVRJT05fS0VZXSlbUE9TSVRJT05fS0VZXTtcbiAgICBpZiAoc3RhcnRQb3MgPT09IHBvc2l0aW9uKSB7XG4gICAgICB2YXIgZmxpY2tpbmcgPSBnZXRGbGlja2luZ0F0dGFjaGVkKHRoaXMuX2ZsaWNraW5nKTtcbiAgICAgIGZsaWNraW5nLmNhbWVyYS5sb29rQXQocG9zaXRpb24pO1xuICAgICAgaWYgKHN0YXRlLnRhcmdldFBhbmVsKSB7XG4gICAgICAgIGZsaWNraW5nLmNvbnRyb2wuc2V0QWN0aXZlKHN0YXRlLnRhcmdldFBhbmVsLCBmbGlja2luZy5jb250cm9sLmFjdGl2ZVBhbmVsLCAoX2EgPSBheGVzRXZlbnQgPT09IG51bGwgfHwgYXhlc0V2ZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBheGVzRXZlbnQuaXNUcnVzdGVkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYWxzZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIHRoaXMuX2FuaW1hdGluZ0NvbnRleHQgPSB7XG4gICAgICBzdGFydDogc3RhcnRQb3MsXG4gICAgICBlbmQ6IHBvc2l0aW9uLFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfTtcbiAgICB2YXIgYW5pbWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfYSwgX2I7XG4gICAgICB2YXIgcmVzZXRDb250ZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5fYW5pbWF0aW5nQ29udGV4dCA9IHtcbiAgICAgICAgICBzdGFydDogMCxcbiAgICAgICAgICBlbmQ6IDAsXG4gICAgICAgICAgb2Zmc2V0OiAwXG4gICAgICAgIH07XG4gICAgICB9O1xuICAgICAgYXhlcy5vbmNlKEVWRU5ULkZJTklTSCwgcmVzZXRDb250ZXh0KTtcbiAgICAgIGlmIChheGVzRXZlbnQpIHtcbiAgICAgICAgYXhlc0V2ZW50LnNldFRvKChfYSA9IHt9LCBfYVtQT1NJVElPTl9LRVldID0gcG9zaXRpb24sIF9hKSwgZHVyYXRpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXhlcy5zZXRUbygoX2IgPSB7fSwgX2JbUE9TSVRJT05fS0VZXSA9IHBvc2l0aW9uLCBfYiksIGR1cmF0aW9uKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgYW5pbWF0aW9uRmluaXNoSGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYXhlcy5vZmYoRVZFTlQuSE9MRCwgaW50ZXJydXB0aW9uSGFuZGxlcik7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH07XG4gICAgICB2YXIgaW50ZXJydXB0aW9uSGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYXhlcy5vZmYoRVZFTlQuRklOSVNILCBhbmltYXRpb25GaW5pc2hIYW5kbGVyKTtcbiAgICAgICAgcmVqZWN0KG5ldyBGbGlja2luZ0Vycm9yKE1FU1NBR0UuQU5JTUFUSU9OX0lOVEVSUlVQVEVELCBDT0RFLkFOSU1BVElPTl9JTlRFUlJVUFRFRCkpO1xuICAgICAgfTtcbiAgICAgIGF4ZXMub25jZShFVkVOVC5GSU5JU0gsIGFuaW1hdGlvbkZpbmlzaEhhbmRsZXIpO1xuICAgICAgYXhlcy5vbmNlKEVWRU5ULkhPTEQsIGludGVycnVwdGlvbkhhbmRsZXIpO1xuICAgICAgYW5pbWF0ZSgpO1xuICAgIH0pO1xuICB9O1xuICBfX3Byb3RvLnVwZGF0ZURpcmVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZmxpY2tpbmcgPSBnZXRGbGlja2luZ0F0dGFjaGVkKHRoaXMuX2ZsaWNraW5nKTtcbiAgICB2YXIgYXhlcyA9IHRoaXMuX2F4ZXM7XG4gICAgdmFyIHBhbklucHV0ID0gdGhpcy5fcGFuSW5wdXQ7XG4gICAgYXhlcy5kaXNjb25uZWN0KHBhbklucHV0KTtcbiAgICBheGVzLmNvbm5lY3QoZmxpY2tpbmcuaG9yaXpvbnRhbCA/IFtQT1NJVElPTl9LRVksIFwiXCJdIDogW1wiXCIsIFBPU0lUSU9OX0tFWV0sIHBhbklucHV0KTtcbiAgICBwYW5JbnB1dC5vcHRpb25zLnNjYWxlID0gZmxpY2tpbmcuaG9yaXpvbnRhbCA/IFtmbGlja2luZy5jYW1lcmEucGFuZWxPcmRlciA9PT0gT1JERVIuUlRMID8gMSA6IC0xLCAwXSA6IFswLCAtMV07XG4gIH07XG4gIF9fcHJvdG8uX3Jlc2V0SW50ZXJuYWxWYWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fZmxpY2tpbmcgPSBudWxsO1xuICAgIHRoaXMuX2F4ZXMgPSBudWxsO1xuICAgIHRoaXMuX3BhbklucHV0ID0gbnVsbDtcbiAgICB0aGlzLl9hbmltYXRpbmdDb250ZXh0ID0ge1xuICAgICAgc3RhcnQ6IDAsXG4gICAgICBlbmQ6IDAsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9O1xuICAgIHRoaXMuX2RyYWdnZWQgPSBmYWxzZTtcbiAgfTtcbiAgcmV0dXJuIEF4ZXNDb250cm9sbGVyO1xufSgpO1xuXG4vKipcclxuICogQSBjb21wb25lbnQgdGhhdCBtYW5hZ2VzIGlucHV0cyBhbmQgYW5pbWF0aW9uIG9mIEZsaWNraW5nXHJcbiAqIEBrbyBGbGlja2luZ+ydmCDsnoXroKUg7J6l7LmYICYg7JWg64uI66mU7J207IWY7J2EIOuLtOuLue2VmOuKlCDsu7Ttj6zrhIztirhcclxuICovXG52YXIgQ29udHJvbCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKiAqL1xuICBmdW5jdGlvbiBDb250cm9sKCkge1xuICAgIHRoaXMuX2ZsaWNraW5nID0gbnVsbDtcbiAgICB0aGlzLl9jb250cm9sbGVyID0gbmV3IEF4ZXNDb250cm9sbGVyKCk7XG4gICAgdGhpcy5fYWN0aXZlUGFuZWwgPSBudWxsO1xuICB9XG4gIHZhciBfX3Byb3RvID0gQ29udHJvbC5wcm90b3R5cGU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcImNvbnRyb2xsZXJcIiwge1xuICAgIC8qKlxyXG4gICAgICogQSBjb250cm9sbGVyIHRoYXQgaGFuZGxlcyB0aGUge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtYXhlcy8gQGVnanMvYXhlc30gZXZlbnRzXHJcbiAgICAgKiBAa28ge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtYXhlcy8gQGVnanMvYXhlc33snZgg7J2067Kk7Yq466W8IOyymOumrO2VmOuKlCDsu6jtirjroaTrn6wg7Lu07Y+s64SM7Yq4XHJcbiAgICAgKiBAdHlwZSB7QXhlc0NvbnRyb2xsZXJ9XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NvbnRyb2xsZXI7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcImFjdGl2ZUluZGV4XCIsIHtcbiAgICAvKipcclxuICAgICAqIEluZGV4IG51bWJlciBvZiB0aGUge0BsaW5rIEZsaWNraW5nI2N1cnJlbnRQYW5lbCBjdXJyZW50UGFuZWx9XHJcbiAgICAgKiBAa28ge0BsaW5rIEZsaWNraW5nI2N1cnJlbnRQYW5lbCBjdXJyZW50UGFuZWx97J2YIOyduOuNseyKpCDrsojtmLhcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLl9hY3RpdmVQYW5lbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmluZGV4KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAtMTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwiYWN0aXZlUGFuZWxcIiwge1xuICAgIC8qKlxyXG4gICAgICogQW4gYWN0aXZlIHBhbmVsXHJcbiAgICAgKiBAa28g7ZiE7J6sIOyEoO2DneuQnCDtjKjrhJBcclxuICAgICAqIEB0eXBlIHtQYW5lbCB8IG51bGx9XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2FjdGl2ZVBhbmVsO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJhbmltYXRpbmdcIiwge1xuICAgIC8qKlxyXG4gICAgICogV2hldGhlciBGbGlja2luZydzIGFuaW1hdGluZ1xyXG4gICAgICogQGtvIO2YhOyerCDslaDri4jrqZTsnbTshZgg64+Z7J6RIOyXrOu2gFxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NvbnRyb2xsZXIuc3RhdGUuYW5pbWF0aW5nO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJob2xkaW5nXCIsIHtcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgdXNlciBpcyBjbGlja2luZyBvciB0b3VjaGluZ1xyXG4gICAgICogQGtvIO2YhOyerCDsgqzsmqnsnpDqsIAg7YG066atL+2EsOy5mOykkeyduOyngCDsl6zrtoBcclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jb250cm9sbGVyLnN0YXRlLmhvbGRpbmc7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIC8qKlxyXG4gICAqIEluaXRpYWxpemUgQ29udHJvbFxyXG4gICAqIEBrbyBDb250cm9s7J2EIOy0iOq4sO2ZlO2VqeuLiOuLpFxyXG4gICAqIEBwYXJhbSB7RmxpY2tpbmd9IGZsaWNraW5nIEFuIGluc3RhbmNlIG9mIHtAbGluayBGbGlja2luZ308a28+RmxpY2tpbmfsnZgg7J247Iqk7YS07IqkPC9rbz5cclxuICAgKiBAY2hhaW5hYmxlXHJcbiAgICogQHJldHVybiB7dGhpc31cclxuICAgKi9cbiAgX19wcm90by5pbml0ID0gZnVuY3Rpb24gKGZsaWNraW5nKSB7XG4gICAgdGhpcy5fZmxpY2tpbmcgPSBmbGlja2luZztcbiAgICB0aGlzLl9jb250cm9sbGVyLmluaXQoZmxpY2tpbmcpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcclxuICAgKiBEZXN0cm95IENvbnRyb2wgYW5kIHJldHVybiB0byBpbml0aWFsIHN0YXRlXHJcbiAgICogQGtvIENvbnRyb2zsnYQg7LSI6riwIOyDge2DnOuhnCDrkJjrj4zrpr3ri4jri6RcclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xuICBfX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fY29udHJvbGxlci5kZXN0cm95KCk7XG4gICAgdGhpcy5fZmxpY2tpbmcgPSBudWxsO1xuICAgIHRoaXMuX2FjdGl2ZVBhbmVsID0gbnVsbDtcbiAgfTtcbiAgLyoqXHJcbiAgICogRW5hYmxlIGlucHV0IGZyb20gdGhlIHVzZXIgKG1vdXNlL3RvdWNoKVxyXG4gICAqIEBrbyDsgqzsmqnsnpDsnZgg7J6F66ClKOuniOyasOyKpC/thLDsuZgp66W8IO2ZnOyEse2ZlO2VqeuLiOuLpFxyXG4gICAqIEBjaGFpbmFibGVcclxuICAgKiBAcmV0dXJuIHt0aGlzfVxyXG4gICAqL1xuICBfX3Byb3RvLmVuYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9jb250cm9sbGVyLmVuYWJsZSgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcclxuICAgKiBEaXNhYmxlIGlucHV0IGZyb20gdGhlIHVzZXIgKG1vdXNlL3RvdWNoKVxyXG4gICAqIEBrbyDsgqzsmqnsnpDsnZgg7J6F66ClKOuniOyasOyKpC/thLDsuZgp66W8IOunieyKteuLiOuLpFxyXG4gICAqIEBjaGFpbmFibGVcclxuICAgKiBAcmV0dXJuIHt0aGlzfVxyXG4gICAqL1xuICBfX3Byb3RvLmRpc2FibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fY29udHJvbGxlci5kaXNhYmxlKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxyXG4gICAqIFJlbGVhc2VzIG9uZ29pbmcgdXNlciBpbnB1dCAobW91c2UvdG91Y2gpXHJcbiAgICogQGtvIOyCrOyaqeyekOydmCDtmITsnqwg7J6F66ClKOuniOyasOyKpC/thLDsuZgp66W8IOykkeuLqOyLnO2CteuLiOuLpFxyXG4gICAqIEBjaGFpbmFibGVcclxuICAgKiBAcmV0dXJuIHt0aGlzfVxyXG4gICAqL1xuICBfX3Byb3RvLnJlbGVhc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fY29udHJvbGxlci5yZWxlYXNlKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxyXG4gICAqIENoYW5nZSB0aGUgZGVzdGluYXRpb24gYW5kIGR1cmF0aW9uIG9mIHRoZSBhbmltYXRpb24gY3VycmVudGx5IHBsYXlpbmdcclxuICAgKiBAa28g7J6s7IOdIOykkeyduCDslaDri4jrqZTsnbTshZjsnZgg66qp7KCB7KeA7JmAIOyerOyDnSDsi5zqsITsnYQg67OA6rK97ZWp64uI64ukXHJcbiAgICogQHBhcmFtIHtQYW5lbH0gcGFuZWwgVGhlIHRhcmdldCBwYW5lbCB0byBtb3ZlPGtvPuydtOuPme2VoCDtjKjrhJA8L2tvPlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkdXJhdGlvbiBEdXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uICh1bml0OiBtcyk8a28+7JWg64uI66mU7J207IWYIOynhO2WiSDsi5zqsIQgKOuLqOychDogbXMpPC9rbz5cclxuICAgKiBAcGFyYW0ge0RJUkVDVElPTn0gZGlyZWN0aW9uIERpcmVjdGlvbiB0byBtb3ZlLCBvbmx5IGF2YWlsYWJsZSBpbiB0aGUge0BsaW5rIEZsaWNraW5nI2NpcmN1bGFyIGNpcmN1bGFyfSBtb2RlPGtvPuydtOuPme2VoCDrsKntlqUuIHtAbGluayBGbGlja2luZyNjaXJjdWxhciBjaXJjdWxhcn0g7Ji17IWYIO2ZnOyEse2ZlOyLnOyXkOunjCDsgqzsmqkg6rCA64ql7ZWp64uI64ukPC9rbz5cclxuICAgKiBAY2hhaW5hYmxlXHJcbiAgICogQHRocm93cyB7RmxpY2tpbmdFcnJvcn1cclxuICAgKiB7QGxpbmsgRVJST1JfQ09ERSBQT1NJVElPTl9OT1RfUkVBQ0hBQkxFfSBXaGVuIHRoZSBnaXZlbiBwYW5lbCBpcyBhbHJlYWR5IHJlbW92ZWQgb3Igbm90IGluIHRoZSBDYW1lcmEncyB7QGxpbmsgQ2FtZXJhI3JhbmdlIHJhbmdlfVxyXG4gICAqIDxrbz57QGxpbmsgRVJST1JfQ09ERSBQT1NJVElPTl9OT1RfUkVBQ0hBQkxFfSDso7zslrTsp4Qg7Yyo64SQ7J20IOygnOqxsOuQmOyXiOqxsOuCmCwgQ2FtZXJh7J2YIHtAbGluayBDYW1lcmEjcmFuZ2UgcmFuZ2V9IOuwluyXkCDsnojsnYQg6rK97JqwPC9rbz5cclxuICAgKiBAcmV0dXJuIHt0aGlzfVxyXG4gICAqL1xuICBfX3Byb3RvLnVwZGF0ZUFuaW1hdGlvbiA9IGZ1bmN0aW9uIChwYW5lbCwgZHVyYXRpb24sIGRpcmVjdGlvbikge1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuX2NvbnRyb2xsZXIuc3RhdGU7XG4gICAgdmFyIHBvc2l0aW9uID0gdGhpcy5fZ2V0UG9zaXRpb24ocGFuZWwsIGRpcmVjdGlvbiAhPT0gbnVsbCAmJiBkaXJlY3Rpb24gIT09IHZvaWQgMCA/IGRpcmVjdGlvbiA6IERJUkVDVElPTi5OT05FKTtcbiAgICBzdGF0ZS50YXJnZXRQYW5lbCA9IHBhbmVsO1xuICAgIHRoaXMuX2NvbnRyb2xsZXIudXBkYXRlQW5pbWF0aW9uKHBvc2l0aW9uLCBkdXJhdGlvbik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxyXG4gICAqIFN0b3BzIHRoZSBhbmltYXRpb24gY3VycmVudGx5IHBsYXlpbmdcclxuICAgKiBAa28g7J6s7IOdIOykkeyduCDslaDri4jrqZTsnbTshZjsnYQg7KSR64uo7Iuc7YK164uI64ukXHJcbiAgICogQGNoYWluYWJsZVxyXG4gICAqIEByZXR1cm4ge3RoaXN9XHJcbiAgICovXG4gIF9fcHJvdG8uc3RvcEFuaW1hdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLl9jb250cm9sbGVyLnN0YXRlO1xuICAgIHN0YXRlLnRhcmdldFBhbmVsID0gbnVsbDtcbiAgICB0aGlzLl9jb250cm9sbGVyLnN0b3BBbmltYXRpb24oKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXHJcbiAgICogVXBkYXRlIHBvc2l0aW9uIGFmdGVyIHJlc2l6aW5nXHJcbiAgICogQGtvIHJlc2l6ZSDsnbTtm4Tsl5AgcG9zaXRpb27snYQg7JeF642w7J207Yq47ZWp64uI64ukXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHByb2dyZXNzSW5QYW5lbCBQcmV2aW91cyBjYW1lcmEncyBwcm9ncmVzcyBpbiBhY3RpdmUgcGFuZWwgYmVmb3JlIHJlc2l6ZTxrbz5SZXNpemUg7J207KCEIO2YhOyerCDshKDtg53rkJwg7Yyo64SQIOuCtOyXkOyEnOydmCDsubTrqZTrnbwgcHJvZ3Jlc3Mg6rCSPC9rbz5cclxuICAgKiBAdGhyb3dzIHtGbGlja2luZ0Vycm9yfVxyXG4gICAqIHtAbGluayBFUlJPUl9DT0RFIE5PVF9BVFRBQ0hFRF9UT19GTElDS0lOR30gV2hlbiB7QGxpbmsgQ2FtZXJhI2luaXQgaW5pdH0gaXMgbm90IGNhbGxlZCBiZWZvcmVcclxuICAgKiA8a28+e0BsaW5rIEVSUk9SX0NPREUgTk9UX0FUVEFDSEVEX1RPX0ZMSUNLSU5HfSB7QGxpbmsgQ2FtZXJhI2luaXQgaW5pdH3snbQg7J207KCE7JeQIO2YuOy2nOuQmOyngCDslYrsnYAg6rK97JqwPC9rbz5cclxuICAgKiBAY2hhaW5hYmxlXHJcbiAgICogQHJldHVybiB7UHJvbWlzZTx2b2lkPn1cclxuICAgKi9cbiAgX19wcm90by51cGRhdGVQb3NpdGlvbiA9IGZ1bmN0aW9uIChwcm9ncmVzc0luUGFuZWwpIHtcbiAgICB2YXIgZmxpY2tpbmcgPSBnZXRGbGlja2luZ0F0dGFjaGVkKHRoaXMuX2ZsaWNraW5nKTtcbiAgICB2YXIgY2FtZXJhID0gZmxpY2tpbmcuY2FtZXJhO1xuICAgIHZhciBhY3RpdmVQYW5lbCA9IHRoaXMuX2FjdGl2ZVBhbmVsO1xuICAgIGlmIChhY3RpdmVQYW5lbCkge1xuICAgICAgY2FtZXJhLmxvb2tBdChjYW1lcmEuY2xhbXBUb1JlYWNoYWJsZVBvc2l0aW9uKGFjdGl2ZVBhbmVsLnBvc2l0aW9uKSk7XG4gICAgfVxuICB9O1xuICAvKipcclxuICAgKiBVcGRhdGUge0BsaW5rIENvbnRyb2wjY29udHJvbGxlciBjb250cm9sbGVyfSdzIHN0YXRlXHJcbiAgICogQGtvIHtAbGluayBDb250cm9sI2NvbnRyb2xsZXIgY29udHJvbGxlcn3snZgg64K067aAIOyDge2DnOulvCDqsLHsi6Dtlanri4jri6RcclxuICAgKiBAY2hhaW5hYmxlXHJcbiAgICogQHJldHVybiB7dGhpc31cclxuICAgKi9cbiAgX19wcm90by51cGRhdGVJbnB1dCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZmxpY2tpbmcgPSBnZXRGbGlja2luZ0F0dGFjaGVkKHRoaXMuX2ZsaWNraW5nKTtcbiAgICB2YXIgY2FtZXJhID0gZmxpY2tpbmcuY2FtZXJhO1xuICAgIHRoaXMuX2NvbnRyb2xsZXIudXBkYXRlKGNhbWVyYS5jb250cm9sUGFyYW1zKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXHJcbiAgICogUmVzZXQge0BsaW5rIENvbnRyb2wjYWN0aXZlUGFuZWwgYWN0aXZlUGFuZWx9IHRvIGBudWxsYFxyXG4gICAqIEBrbyB7QGxpbmsgQ29udHJvbCNhY3RpdmVQYW5lbCBhY3RpdmVQYW5lbH3snYQgYG51bGxg66GcIOy0iOq4sO2ZlO2VqeuLiOuLpFxyXG4gICAqIEBjaGFpbmFibGVcclxuICAgKiBAcmV0dXJuIHt0aGlzfVxyXG4gICAqL1xuICBfX3Byb3RvLnJlc2V0QWN0aXZlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2FjdGl2ZVBhbmVsID0gbnVsbDtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXHJcbiAgICogTW92ZSB7QGxpbmsgQ2FtZXJhfSB0byB0aGUgZ2l2ZW4gcGFuZWxcclxuICAgKiBAa28ge0BsaW5rIENhbWVyYX3rpbwg7ZW064u5IO2MqOuEkCDsnITroZwg7J2064+Z7ZWp64uI64ukXHJcbiAgICogQHBhcmFtIHtQYW5lbH0gcGFuZWwgVGhlIHRhcmdldCBwYW5lbCB0byBtb3ZlPGtvPuydtOuPme2VoCDtjKjrhJA8L2tvPlxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIEFuIG9wdGlvbnMgb2JqZWN0PGtvPuyYteyFmCDsmKTruIzsoJ3tirg8L2tvPlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkdXJhdGlvbiBEdXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uICh1bml0OiBtcyk8a28+7JWg64uI66mU7J207IWYIOynhO2WiSDsi5zqsIQgKOuLqOychDogbXMpPC9rbz5cclxuICAgKiBAcGFyYW0ge29iamVjdH0gW2F4ZXNFdmVudF0ge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtYXhlcy9yZWxlYXNlL2xhdGVzdC9kb2MvZWcuQXhlcy5odG1sI2V2ZW50OnJlbGVhc2UgcmVsZWFzZX0gZXZlbnQgb2Yge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtYXhlcy8gQXhlc31cclxuICAgKiA8a28+e0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtYXhlcy8gQXhlc33snZgge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtYXhlcy9yZWxlYXNlL2xhdGVzdC9kb2MvZWcuQXhlcy5odG1sI2V2ZW50OnJlbGVhc2UgcmVsZWFzZX0g7J2067Kk7Yq4PC9rbz5cclxuICAgKiBAcGFyYW0ge0RJUkVDVElPTn0gW2RpcmVjdGlvbj1ESVJFQ1RJT04uTk9ORV0gRGlyZWN0aW9uIHRvIG1vdmUsIG9ubHkgYXZhaWxhYmxlIGluIHRoZSB7QGxpbmsgRmxpY2tpbmcjY2lyY3VsYXIgY2lyY3VsYXJ9IG1vZGU8a28+7J2064+Z7ZWgIOuwqe2WpS4ge0BsaW5rIEZsaWNraW5nI2NpcmN1bGFyIGNpcmN1bGFyfSDsmLXshZgg7Zmc7ISx7ZmU7Iuc7JeQ66eMIOyCrOyaqSDqsIDriqXtlanri4jri6Q8L2tvPlxyXG4gICAqIEBmaXJlcyBGbGlja2luZyNtb3ZlU3RhcnRcclxuICAgKiBAZmlyZXMgRmxpY2tpbmcjbW92ZVxyXG4gICAqIEBmaXJlcyBGbGlja2luZyNtb3ZlRW5kXHJcbiAgICogQGZpcmVzIEZsaWNraW5nI3dpbGxDaGFuZ2VcclxuICAgKiBAZmlyZXMgRmxpY2tpbmcjY2hhbmdlZFxyXG4gICAqIEBmaXJlcyBGbGlja2luZyN3aWxsUmVzdG9yZVxyXG4gICAqIEBmaXJlcyBGbGlja2luZyNyZXN0b3JlZFxyXG4gICAqIEBmaXJlcyBGbGlja2luZyNuZWVkUGFuZWxcclxuICAgKiBAZmlyZXMgRmxpY2tpbmcjdmlzaWJsZUNoYW5nZVxyXG4gICAqIEBmaXJlcyBGbGlja2luZyNyZWFjaEVkZ2VcclxuICAgKiBAdGhyb3dzIHtGbGlja2luZ0Vycm9yfVxyXG4gICAqIHxjb2RlfGNvbmRpdGlvbnxcclxuICAgKiB8LS0tfC0tLXxcclxuICAgKiB8e0BsaW5rIEVSUk9SX0NPREUgUE9TSVRJT05fTk9UX1JFQUNIQUJMRX18V2hlbiB0aGUgZ2l2ZW4gcGFuZWwgaXMgYWxyZWFkeSByZW1vdmVkIG9yIG5vdCBpbiB0aGUgQ2FtZXJhJ3Mge0BsaW5rIENhbWVyYSNyYW5nZSByYW5nZX18XHJcbiAgICogfHtAbGluayBFUlJPUl9DT0RFIE5PVF9BVFRBQ0hFRF9UT19GTElDS0lOR318V2hlbiB7QGxpbmsgQ29udHJvbCNpbml0IGluaXR9IGlzIG5vdCBjYWxsZWQgYmVmb3JlfFxyXG4gICAqIHx7QGxpbmsgRVJST1JfQ09ERSBBTklNQVRJT05fSU5URVJSVVBURUR9fFdoZW4gdGhlIGFuaW1hdGlvbiBpcyBpbnRlcnJ1cHRlZCBieSB1c2VyIGlucHV0fFxyXG4gICAqIHx7QGxpbmsgRVJST1JfQ09ERSBTVE9QX0NBTExFRF9CWV9VU0VSfXxXaGVuIHRoZSBhbmltYXRpb24gaXMgaW50ZXJydXB0ZWQgYnkgdXNlciBpbnB1dHxcclxuICAgKiA8a28+XHJcbiAgICpcclxuICAgKiB8Y29kZXxjb25kaXRpb258XHJcbiAgICogfC0tLXwtLS18XHJcbiAgICogfHtAbGluayBFUlJPUl9DT0RFIFBPU0lUSU9OX05PVF9SRUFDSEFCTEV9fOyjvOyWtOynhCDtjKjrhJDsnbQg7KCc6rGw65CY7JeI6rGw64KYLCBDYW1lcmHsnZgge0BsaW5rIENhbWVyYSNyYW5nZSByYW5nZX0g67CW7JeQIOyeiOydhCDqsr3smrB8XHJcbiAgICogfHtAbGluayBFUlJPUl9DT0RFIE5PVF9BVFRBQ0hFRF9UT19GTElDS0lOR318e0BsaW5rIENvbnRyb2wjaW5pdCBpbml0feydtCDsnbTsoITsl5Ag7Zi47Lac65CY7KeAIOyViuydgCDqsr3smrB8XHJcbiAgICogfHtAbGluayBFUlJPUl9DT0RFIEFOSU1BVElPTl9JTlRFUlJVUFRFRH187IKs7Jqp7J6QIOyeheugpeyXkCDsnZjtlbQg7JWg64uI66mU7J207IWY7J20IOykkeuLqOuQnCDqsr3smrB8XHJcbiAgICogfHtAbGluayBFUlJPUl9DT0RFIFNUT1BfQ0FMTEVEX0JZX1VTRVJ9fOuwnOyDneuQnCDsnbTrsqTtirjrk6Qg7KSRIO2VmOuCmOudvOuPhCBgc3RvcCgpYOydtCDtmLjstpzrkJwg6rK97JqwfFxyXG4gICAqXHJcbiAgICogPC9rbz5cclxuICAgKiBAcmV0dXJuIHtQcm9taXNlPHZvaWQ+fSBBIFByb21pc2Ugd2hpY2ggd2lsbCBiZSByZXNvbHZlZCBhZnRlciByZWFjaGluZyB0aGUgdGFyZ2V0IHBhbmVsPGtvPu2VtOuLuSDtjKjrhJAg64+E64us7Iuc7JeQIHJlc29sdmXrkJjripQgUHJvbWlzZTwva28+XHJcbiAgICovXG4gIF9fcHJvdG8ubW92ZVRvUGFuZWwgPSBmdW5jdGlvbiAocGFuZWwsIF9hKSB7XG4gICAgdmFyIGR1cmF0aW9uID0gX2EuZHVyYXRpb24sXG4gICAgICBfYiA9IF9hLmRpcmVjdGlvbixcbiAgICAgIGRpcmVjdGlvbiA9IF9iID09PSB2b2lkIDAgPyBESVJFQ1RJT04uTk9ORSA6IF9iLFxuICAgICAgYXhlc0V2ZW50ID0gX2EuYXhlc0V2ZW50O1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwb3NpdGlvbjtcbiAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2MpIHtcbiAgICAgICAgcG9zaXRpb24gPSB0aGlzLl9nZXRQb3NpdGlvbihwYW5lbCwgZGlyZWN0aW9uKTtcbiAgICAgICAgdGhpcy5fdHJpZ2dlckluZGV4Q2hhbmdlRXZlbnQocGFuZWwsIHBhbmVsLnBvc2l0aW9uLCBheGVzRXZlbnQsIGRpcmVjdGlvbik7XG4gICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLl9hbmltYXRlVG9Qb3NpdGlvbih7XG4gICAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uLFxuICAgICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbixcbiAgICAgICAgICBuZXdBY3RpdmVQYW5lbDogcGFuZWwsXG4gICAgICAgICAgYXhlc0V2ZW50OiBheGVzRXZlbnRcbiAgICAgICAgfSldO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG4gIC8qKlxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqL1xuICBfX3Byb3RvLnNldEFjdGl2ZSA9IGZ1bmN0aW9uIChuZXdBY3RpdmVQYW5lbCwgcHJldkFjdGl2ZVBhbmVsLCBpc1RydXN0ZWQpIHtcbiAgICB2YXIgX2E7XG4gICAgdmFyIGZsaWNraW5nID0gZ2V0RmxpY2tpbmdBdHRhY2hlZCh0aGlzLl9mbGlja2luZyk7XG4gICAgdGhpcy5fYWN0aXZlUGFuZWwgPSBuZXdBY3RpdmVQYW5lbDtcbiAgICB0aGlzLl9uZXh0UGFuZWwgPSBudWxsO1xuICAgIGZsaWNraW5nLmNhbWVyYS51cGRhdGVBZGFwdGl2ZUhlaWdodCgpO1xuICAgIGlmIChuZXdBY3RpdmVQYW5lbCAhPT0gcHJldkFjdGl2ZVBhbmVsKSB7XG4gICAgICBmbGlja2luZy50cmlnZ2VyKG5ldyBDb21wb25lbnRFdmVudCQxKEVWRU5UUy5DSEFOR0VELCB7XG4gICAgICAgIGluZGV4OiBuZXdBY3RpdmVQYW5lbC5pbmRleCxcbiAgICAgICAgcGFuZWw6IG5ld0FjdGl2ZVBhbmVsLFxuICAgICAgICBwcmV2SW5kZXg6IChfYSA9IHByZXZBY3RpdmVQYW5lbCA9PT0gbnVsbCB8fCBwcmV2QWN0aXZlUGFuZWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByZXZBY3RpdmVQYW5lbC5pbmRleCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogLTEsXG4gICAgICAgIHByZXZQYW5lbDogcHJldkFjdGl2ZVBhbmVsLFxuICAgICAgICBpc1RydXN0ZWQ6IGlzVHJ1c3RlZCxcbiAgICAgICAgZGlyZWN0aW9uOiBwcmV2QWN0aXZlUGFuZWwgPyBnZXREaXJlY3Rpb24kMShwcmV2QWN0aXZlUGFuZWwucG9zaXRpb24sIG5ld0FjdGl2ZVBhbmVsLnBvc2l0aW9uKSA6IERJUkVDVElPTi5OT05FXG4gICAgICB9KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZsaWNraW5nLnRyaWdnZXIobmV3IENvbXBvbmVudEV2ZW50JDEoRVZFTlRTLlJFU1RPUkVELCB7XG4gICAgICAgIGlzVHJ1c3RlZDogaXNUcnVzdGVkXG4gICAgICB9KSk7XG4gICAgfVxuICB9O1xuICAvKipcclxuICAgKiBAaW50ZXJuYWxcclxuICAgKi9cbiAgX19wcm90by5jb3B5ID0gZnVuY3Rpb24gKGNvbnRyb2wpIHtcbiAgICB0aGlzLl9mbGlja2luZyA9IGNvbnRyb2wuX2ZsaWNraW5nO1xuICAgIHRoaXMuX2FjdGl2ZVBhbmVsID0gY29udHJvbC5fYWN0aXZlUGFuZWw7XG4gICAgdGhpcy5fY29udHJvbGxlciA9IGNvbnRyb2wuX2NvbnRyb2xsZXI7XG4gIH07XG4gIF9fcHJvdG8uX3RyaWdnZXJJbmRleENoYW5nZUV2ZW50ID0gZnVuY3Rpb24gKHBhbmVsLCBwb3NpdGlvbiwgYXhlc0V2ZW50LCBkaXJlY3Rpb24pIHtcbiAgICB2YXIgX2E7XG4gICAgdmFyIGZsaWNraW5nID0gZ2V0RmxpY2tpbmdBdHRhY2hlZCh0aGlzLl9mbGlja2luZyk7XG4gICAgdmFyIHRyaWdnZXJpbmdFdmVudCA9IHBhbmVsICE9PSB0aGlzLl9hY3RpdmVQYW5lbCA/IEVWRU5UUy5XSUxMX0NIQU5HRSA6IEVWRU5UUy5XSUxMX1JFU1RPUkU7XG4gICAgdmFyIGNhbWVyYSA9IGZsaWNraW5nLmNhbWVyYTtcbiAgICB2YXIgYWN0aXZlUGFuZWwgPSB0aGlzLl9hY3RpdmVQYW5lbDtcbiAgICB2YXIgZXZlbnQgPSBuZXcgQ29tcG9uZW50RXZlbnQkMSh0cmlnZ2VyaW5nRXZlbnQsIHtcbiAgICAgIGluZGV4OiBwYW5lbC5pbmRleCxcbiAgICAgIHBhbmVsOiBwYW5lbCxcbiAgICAgIGlzVHJ1c3RlZDogKGF4ZXNFdmVudCA9PT0gbnVsbCB8fCBheGVzRXZlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGF4ZXNFdmVudC5pc1RydXN0ZWQpIHx8IGZhbHNlLFxuICAgICAgZGlyZWN0aW9uOiBkaXJlY3Rpb24gIT09IG51bGwgJiYgZGlyZWN0aW9uICE9PSB2b2lkIDAgPyBkaXJlY3Rpb24gOiBnZXREaXJlY3Rpb24kMSgoX2EgPSBhY3RpdmVQYW5lbCA9PT0gbnVsbCB8fCBhY3RpdmVQYW5lbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWN0aXZlUGFuZWwucG9zaXRpb24pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNhbWVyYS5wb3NpdGlvbiwgcG9zaXRpb24pXG4gICAgfSk7XG4gICAgdGhpcy5fbmV4dFBhbmVsID0gcGFuZWw7XG4gICAgZmxpY2tpbmcudHJpZ2dlcihldmVudCk7XG4gICAgaWYgKGV2ZW50LmlzQ2FuY2VsZWQoKSkge1xuICAgICAgdGhyb3cgbmV3IEZsaWNraW5nRXJyb3IoTUVTU0FHRS5TVE9QX0NBTExFRF9CWV9VU0VSLCBDT0RFLlNUT1BfQ0FMTEVEX0JZX1VTRVIpO1xuICAgIH1cbiAgfTtcbiAgX19wcm90by5fYW5pbWF0ZVRvUG9zaXRpb24gPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgcG9zaXRpb24gPSBfYS5wb3NpdGlvbixcbiAgICAgIGR1cmF0aW9uID0gX2EuZHVyYXRpb24sXG4gICAgICBuZXdBY3RpdmVQYW5lbCA9IF9hLm5ld0FjdGl2ZVBhbmVsLFxuICAgICAgYXhlc0V2ZW50ID0gX2EuYXhlc0V2ZW50O1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBmbGlja2luZywgYW5pbWF0ZSwgc3RhdGU7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICBmbGlja2luZyA9IGdldEZsaWNraW5nQXR0YWNoZWQodGhpcy5fZmxpY2tpbmcpO1xuICAgICAgICBhbmltYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5fY29udHJvbGxlci5hbmltYXRlVG8ocG9zaXRpb24sIGR1cmF0aW9uLCBheGVzRXZlbnQpO1xuICAgICAgICB9O1xuICAgICAgICBzdGF0ZSA9IHRoaXMuX2NvbnRyb2xsZXIuc3RhdGU7XG4gICAgICAgIHN0YXRlLnRhcmdldFBhbmVsID0gbmV3QWN0aXZlUGFuZWw7XG4gICAgICAgIGlmIChkdXJhdGlvbiA8PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGFuaW1hdGUoKV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGFuaW1hdGUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIoX3RoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGZsaWNraW5nLnJlbmRlcmVyLnJlbmRlcigpXTtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChheGVzRXZlbnQgJiYgZXJyIGluc3RhbmNlb2YgRmxpY2tpbmdFcnJvciAmJiBlcnIuY29kZSA9PT0gQ09ERS5BTklNQVRJT05fSU5URVJSVVBURUQpIHJldHVybjtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9KV07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIF9fcHJvdG8uX2dldFBvc2l0aW9uID0gZnVuY3Rpb24gKHBhbmVsLCBkaXJlY3Rpb24pIHtcbiAgICBpZiAoZGlyZWN0aW9uID09PSB2b2lkIDApIHtcbiAgICAgIGRpcmVjdGlvbiA9IERJUkVDVElPTi5OT05FO1xuICAgIH1cbiAgICB2YXIgZmxpY2tpbmcgPSBnZXRGbGlja2luZ0F0dGFjaGVkKHRoaXMuX2ZsaWNraW5nKTtcbiAgICB2YXIgY2FtZXJhID0gZmxpY2tpbmcuY2FtZXJhO1xuICAgIHZhciBwb3NpdGlvbiA9IHBhbmVsLnBvc2l0aW9uO1xuICAgIHZhciBuZWFyZXN0QW5jaG9yID0gY2FtZXJhLmZpbmROZWFyZXN0QW5jaG9yKHBvc2l0aW9uKTtcbiAgICBpZiAocGFuZWwucmVtb3ZlZCB8fCAhbmVhcmVzdEFuY2hvcikge1xuICAgICAgdGhyb3cgbmV3IEZsaWNraW5nRXJyb3IoTUVTU0FHRS5QT1NJVElPTl9OT1RfUkVBQ0hBQkxFKHBhbmVsLnBvc2l0aW9uKSwgQ09ERS5QT1NJVElPTl9OT1RfUkVBQ0hBQkxFKTtcbiAgICB9XG4gICAgaWYgKCFjYW1lcmEuY2FuUmVhY2gocGFuZWwpKSB7XG4gICAgICAvLyBPdmVycmlkZSBwb3NpdGlvbiAmIHBhbmVsIGlmIHRoYXQgcGFuZWwgaXMgbm90IHJlYWNoYWJsZVxuICAgICAgcG9zaXRpb24gPSBuZWFyZXN0QW5jaG9yLnBvc2l0aW9uO1xuICAgICAgcGFuZWwgPSBuZWFyZXN0QW5jaG9yLnBhbmVsO1xuICAgIH0gZWxzZSBpZiAoZmxpY2tpbmcuY2lyY3VsYXJFbmFibGVkKSB7XG4gICAgICAvLyBDaXJjdWxhciBtb2RlIGlzIGVuYWJsZWQsIGZpbmQgbmVhcmVzdCBkaXN0YW5jZSB0byBwYW5lbFxuICAgICAgdmFyIGNhbVBvc18xID0gdGhpcy5fY29udHJvbGxlci5wb3NpdGlvbjsgLy8gQWN0dWFsIHBvc2l0aW9uIG9mIHRoZSBBeGVzXG4gICAgICB2YXIgY2FtUmFuZ2VEaWZmID0gY2FtZXJhLnJhbmdlRGlmZjtcbiAgICAgIHZhciBwb3NzaWJsZVBvc2l0aW9ucyA9IFtwb3NpdGlvbiwgcG9zaXRpb24gKyBjYW1SYW5nZURpZmYsIHBvc2l0aW9uIC0gY2FtUmFuZ2VEaWZmXS5maWx0ZXIoZnVuY3Rpb24gKHBvcykge1xuICAgICAgICBpZiAoZGlyZWN0aW9uID09PSBESVJFQ1RJT04uTk9ORSkgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBkaXJlY3Rpb24gPT09IERJUkVDVElPTi5QUkVWID8gcG9zIDw9IGNhbVBvc18xIDogcG9zID49IGNhbVBvc18xO1xuICAgICAgfSk7XG4gICAgICBwb3NpdGlvbiA9IHBvc3NpYmxlUG9zaXRpb25zLnJlZHVjZShmdW5jdGlvbiAobmVhcmVzdFBvc2l0aW9uLCBwb3MpIHtcbiAgICAgICAgaWYgKE1hdGguYWJzKGNhbVBvc18xIC0gcG9zKSA8IE1hdGguYWJzKGNhbVBvc18xIC0gbmVhcmVzdFBvc2l0aW9uKSkge1xuICAgICAgICAgIHJldHVybiBwb3M7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG5lYXJlc3RQb3NpdGlvbjtcbiAgICAgICAgfVxuICAgICAgfSwgSW5maW5pdHkpO1xuICAgIH1cbiAgICByZXR1cm4gcG9zaXRpb247XG4gIH07XG4gIHJldHVybiBDb250cm9sO1xufSgpO1xuXG4vKipcclxuICogQSBkYXRhIGNvbXBvbmVudCB0aGF0IGhhcyBhY3R1YWwgcG9zaXRpb24gd2hlcmUgdGhlIGNhbWVyYSBzaG91bGQgYmUgc3RvcHBlZCBhdFxyXG4gKiBAa28g7Lm066mU65286rCAIOygleyngO2VtOyVvO2VmOuKlCDsi6TsoJwg7JyE7LmY66W8IOuLtOqzoCDsnojripQg642w7J207YSwIOy7tO2PrOuEjO2KuFxyXG4gKi9cbnZhciBBbmNob3JQb2ludCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIEFuIG9wdGlvbnMgb2JqZWN0PGtvPuyYteyFmCDqsJ3ssrQ8L2tvPlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5pbmRleF0gSW5kZXggb2YgQW5jaG9yUG9pbnQ8a28+QW5jaG9yUG9pbnTsnZgg7J24642x7IqkPC9rbz5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMucG9zaXRpb25dIFBvc2l0aW9uIG9mIEFuY2hvclBvaW50PGtvPkFuY2hvclBvaW507J2YIOyijO2RnDwva28+XHJcbiAgICogQHBhcmFtIHtQYW5lbH0gW29wdGlvbnMucGFuZWxdIEEge0BsaW5rIFBhbmVsfSBpbnN0YW5jZSBBbmNob3JQb2ludCBpcyByZWZlcmVuY2luZyB0bzxrbz5BbmNob3JQb2ludOqwgCDssLjsobDtlZjqs6Ag7J6I64qUIHtAbGluayBQYW5lbH08L2tvPlxyXG4gICAqL1xuICBmdW5jdGlvbiBBbmNob3JQb2ludChfYSkge1xuICAgIHZhciBpbmRleCA9IF9hLmluZGV4LFxuICAgICAgcG9zaXRpb24gPSBfYS5wb3NpdGlvbixcbiAgICAgIHBhbmVsID0gX2EucGFuZWw7XG4gICAgdGhpcy5faW5kZXggPSBpbmRleDtcbiAgICB0aGlzLl9wb3MgPSBwb3NpdGlvbjtcbiAgICB0aGlzLl9wYW5lbCA9IHBhbmVsO1xuICB9XG4gIHZhciBfX3Byb3RvID0gQW5jaG9yUG9pbnQucHJvdG90eXBlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJpbmRleFwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBJbmRleCBvZiBBbmNob3JQb2ludFxyXG4gICAgICogQGtvIEFuY2hvclBvaW507J2YIOyduOuNseyKpFxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5faW5kZXg7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcInBvc2l0aW9uXCIsIHtcbiAgICAvKipcclxuICAgICAqIFBvc2l0aW9uIG9mIEFuY2hvclBvaW50XHJcbiAgICAgKiBAa28gQW5jaG9yUG9pbnTsnZgg7KKM7ZGcXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wb3M7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcInBhbmVsXCIsIHtcbiAgICAvKipcclxuICAgICAqIEEge0BsaW5rIFBhbmVsfSBpbnN0YW5jZSBBbmNob3JQb2ludCBpcyByZWZlcmVuY2luZyB0b1xyXG4gICAgICogQGtvIEFuY2hvclBvaW506rCAIOywuOyhsO2VmOqzoCDsnojripQge0BsaW5rIFBhbmVsfVxyXG4gICAgICogQHR5cGUge1BhbmVsfVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wYW5lbDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgcmV0dXJuIEFuY2hvclBvaW50O1xufSgpO1xuXG4vKipcclxuICogQSB7QGxpbmsgQ29udHJvbH0gdGhhdCB1c2VzIGEgcmVsZWFzZSBtb21lbnR1bSB0byBjaG9vc2UgZGVzdGluYXRpb24gcGFuZWxcclxuICogQGtvIOyeheugpeydhCDspJHri6jtlZwg7Iuc7KCQ7J2YIOqwgOyGjeuPhOyXkCDsmIHtlqXrsJvslYQg64+E64us7ZWgIO2MqOuEkOydhCDqs4TsgrDtlZjripQg7J2064+ZIOuwqeyLneydhCDsgqzsmqntlZjripQge0BsaW5rIENvbnRyb2x9XHJcbiAqL1xudmFyIFNuYXBDb250cm9sID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzJDMoU25hcENvbnRyb2wsIF9zdXBlcik7XG4gIC8qKiAqL1xuICBmdW5jdGlvbiBTbmFwQ29udHJvbChfYSkge1xuICAgIHZhciBfYiA9IChfYSA9PT0gdm9pZCAwID8ge30gOiBfYSkuY291bnQsXG4gICAgICBjb3VudCA9IF9iID09PSB2b2lkIDAgPyBJbmZpbml0eSA6IF9iO1xuICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgX3RoaXMuX2NvdW50ID0gY291bnQ7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIHZhciBfX3Byb3RvID0gU25hcENvbnRyb2wucHJvdG90eXBlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJjb3VudFwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBNYXhpbXVtIG51bWJlciBvZiBwYW5lbHMgY2FuIGdvIGFmdGVyIHJlbGVhc2VcclxuICAgICAqIEBrbyDsnoXroKUg7KSR64uoIOydtO2bhCDthrXqs7ztlZjsl6wg7J2064+Z7ZWgIOyImCDsnojripQg7Yyo64SQ7J2YIOy1nOuMgCDqsK/siJhcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCBJbmZpbml0eVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY291bnQ7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHRoaXMuX2NvdW50ID0gdmFsO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICAvKipcclxuICAgKiBNb3ZlIHtAbGluayBDYW1lcmF9IHRvIHRoZSBnaXZlbiBwb3NpdGlvblxyXG4gICAqIEBrbyB7QGxpbmsgQ2FtZXJhfeulvCDso7zslrTsp4Qg7KKM7ZGc66GcIOydtOuPme2VqeuLiOuLpFxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwb3NpdGlvbiBUaGUgdGFyZ2V0IHBvc2l0aW9uIHRvIG1vdmU8a28+7J2064+Z7ZWgIOyijO2RnDwva28+XHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGR1cmF0aW9uIER1cmF0aW9uIG9mIHRoZSBwYW5lbCBtb3ZlbWVudCBhbmltYXRpb24gKHVuaXQ6IG1zKS48a28+7Yyo64SQIOydtOuPmSDslaDri4jrqZTsnbTshZgg7KeE7ZaJIOyLnOqwhCAo64uo7JyEOiBtcyk8L2tvPlxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbYXhlc0V2ZW50XSB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1heGVzL3JlbGVhc2UvbGF0ZXN0L2RvYy9lZy5BeGVzLmh0bWwjZXZlbnQ6cmVsZWFzZSByZWxlYXNlfSBldmVudCBvZiB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1heGVzLyBBeGVzfVxyXG4gICAqIDxrbz57QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1heGVzLyBBeGVzfeydmCB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1heGVzL3JlbGVhc2UvbGF0ZXN0L2RvYy9lZy5BeGVzLmh0bWwjZXZlbnQ6cmVsZWFzZSByZWxlYXNlfSDsnbTrsqTtirg8L2tvPlxyXG4gICAqIEBmaXJlcyBGbGlja2luZyNtb3ZlU3RhcnRcclxuICAgKiBAZmlyZXMgRmxpY2tpbmcjbW92ZVxyXG4gICAqIEBmaXJlcyBGbGlja2luZyNtb3ZlRW5kXHJcbiAgICogQGZpcmVzIEZsaWNraW5nI3dpbGxDaGFuZ2VcclxuICAgKiBAZmlyZXMgRmxpY2tpbmcjY2hhbmdlZFxyXG4gICAqIEBmaXJlcyBGbGlja2luZyN3aWxsUmVzdG9yZVxyXG4gICAqIEBmaXJlcyBGbGlja2luZyNyZXN0b3JlZFxyXG4gICAqIEBmaXJlcyBGbGlja2luZyNuZWVkUGFuZWxcclxuICAgKiBAZmlyZXMgRmxpY2tpbmcjdmlzaWJsZUNoYW5nZVxyXG4gICAqIEBmaXJlcyBGbGlja2luZyNyZWFjaEVkZ2VcclxuICAgKiBAdGhyb3dzIHtGbGlja2luZ0Vycm9yfVxyXG4gICAqIHxjb2RlfGNvbmRpdGlvbnxcclxuICAgKiB8LS0tfC0tLXxcclxuICAgKiB8e0BsaW5rIEVSUk9SX0NPREUgUE9TSVRJT05fTk9UX1JFQUNIQUJMRX18V2hlbiB0aGUgZ2l2ZW4gcGFuZWwgaXMgYWxyZWFkeSByZW1vdmVkIG9yIG5vdCBpbiB0aGUgQ2FtZXJhJ3Mge0BsaW5rIENhbWVyYSNyYW5nZSByYW5nZX18XHJcbiAgICogfHtAbGluayBFUlJPUl9DT0RFIE5PVF9BVFRBQ0hFRF9UT19GTElDS0lOR318V2hlbiB7QGxpbmsgQ29udHJvbCNpbml0IGluaXR9IGlzIG5vdCBjYWxsZWQgYmVmb3JlfFxyXG4gICAqIHx7QGxpbmsgRVJST1JfQ09ERSBBTklNQVRJT05fSU5URVJSVVBURUR9fFdoZW4gdGhlIGFuaW1hdGlvbiBpcyBpbnRlcnJ1cHRlZCBieSB1c2VyIGlucHV0fFxyXG4gICAqIHx7QGxpbmsgRVJST1JfQ09ERSBTVE9QX0NBTExFRF9CWV9VU0VSfXxXaGVuIHRoZSBhbmltYXRpb24gaXMgaW50ZXJydXB0ZWQgYnkgdXNlciBpbnB1dHxcclxuICAgKiA8a28+XHJcbiAgICpcclxuICAgKiB8Y29kZXxjb25kaXRpb258XHJcbiAgICogfC0tLXwtLS18XHJcbiAgICogfHtAbGluayBFUlJPUl9DT0RFIFBPU0lUSU9OX05PVF9SRUFDSEFCTEV9fOyjvOyWtOynhCDtjKjrhJDsnbQg7KCc6rGw65CY7JeI6rGw64KYLCBDYW1lcmHsnZgge0BsaW5rIENhbWVyYSNyYW5nZSByYW5nZX0g67CW7JeQIOyeiOydhCDqsr3smrB8XHJcbiAgICogfHtAbGluayBFUlJPUl9DT0RFIE5PVF9BVFRBQ0hFRF9UT19GTElDS0lOR318e0BsaW5rIENvbnRyb2wjaW5pdCBpbml0feydtCDsnbTsoITsl5Ag7Zi47Lac65CY7KeAIOyViuydgCDqsr3smrB8XHJcbiAgICogfHtAbGluayBFUlJPUl9DT0RFIEFOSU1BVElPTl9JTlRFUlJVUFRFRH187IKs7Jqp7J6QIOyeheugpeyXkCDsnZjtlbQg7JWg64uI66mU7J207IWY7J20IOykkeuLqOuQnCDqsr3smrB8XHJcbiAgICogfHtAbGluayBFUlJPUl9DT0RFIFNUT1BfQ0FMTEVEX0JZX1VTRVJ9fOuwnOyDneuQnCDsnbTrsqTtirjrk6Qg7KSRIO2VmOuCmOudvOuPhCBgc3RvcCgpYOydtCDtmLjstpzrkJwg6rK97JqwfFxyXG4gICAqXHJcbiAgICogPC9rbz5cclxuICAgKiBAcmV0dXJuIHtQcm9taXNlPHZvaWQ+fSBBIFByb21pc2Ugd2hpY2ggd2lsbCBiZSByZXNvbHZlZCBhZnRlciByZWFjaGluZyB0aGUgdGFyZ2V0IHBvc2l0aW9uPGtvPu2VtOuLuSDsooztkZwg64+E64us7Iuc7JeQIHJlc29sdmXrkJjripQgUHJvbWlzZTwva28+XHJcbiAgICovXG4gIF9fcHJvdG8ubW92ZVRvUG9zaXRpb24gPSBmdW5jdGlvbiAocG9zaXRpb24sIGR1cmF0aW9uLCBheGVzRXZlbnQpIHtcbiAgICB2YXIgZmxpY2tpbmcgPSBnZXRGbGlja2luZ0F0dGFjaGVkKHRoaXMuX2ZsaWNraW5nKTtcbiAgICB2YXIgY2FtZXJhID0gZmxpY2tpbmcuY2FtZXJhO1xuICAgIHZhciBhY3RpdmVBbmNob3IgPSBjYW1lcmEuZmluZEFjdGl2ZUFuY2hvcigpO1xuICAgIHZhciBhbmNob3JBdENhbWVyYSA9IGNhbWVyYS5maW5kTmVhcmVzdEFuY2hvcihjYW1lcmEucG9zaXRpb24pO1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuX2NvbnRyb2xsZXIuc3RhdGU7XG4gICAgaWYgKCFhY3RpdmVBbmNob3IgfHwgIWFuY2hvckF0Q2FtZXJhKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEZsaWNraW5nRXJyb3IoTUVTU0FHRS5QT1NJVElPTl9OT1RfUkVBQ0hBQkxFKHBvc2l0aW9uKSwgQ09ERS5QT1NJVElPTl9OT1RfUkVBQ0hBQkxFKSk7XG4gICAgfVxuICAgIHZhciBzbmFwVGhyZXNob2xkID0gdGhpcy5fY2FsY1NuYXBUaHJlc2hvbGQoZmxpY2tpbmcudGhyZXNob2xkLCBwb3NpdGlvbiwgYWN0aXZlQW5jaG9yKTtcbiAgICB2YXIgcG9zRGVsdGEgPSBmbGlja2luZy5hbmltYXRpbmcgPyBzdGF0ZS5kZWx0YSA6IHBvc2l0aW9uIC0gY2FtZXJhLnBvc2l0aW9uO1xuICAgIHZhciBhYnNQb3NEZWx0YSA9IE1hdGguYWJzKHBvc0RlbHRhKTtcbiAgICB2YXIgc25hcERlbHRhID0gYXhlc0V2ZW50ICYmIGF4ZXNFdmVudC5kZWx0YVtQT1NJVElPTl9LRVldICE9PSAwID8gTWF0aC5hYnMoYXhlc0V2ZW50LmRlbHRhW1BPU0lUSU9OX0tFWV0pIDogYWJzUG9zRGVsdGE7XG4gICAgdmFyIHRhcmdldEFuY2hvcjtcbiAgICBpZiAoc25hcERlbHRhID49IHNuYXBUaHJlc2hvbGQgJiYgc25hcERlbHRhID4gMCkge1xuICAgICAgLy8gTW92ZSB0byBhbmNob3IgYXQgcG9zaXRpb25cbiAgICAgIHRhcmdldEFuY2hvciA9IHRoaXMuX2ZpbmRTbmFwcGVkQW5jaG9yKHBvc2l0aW9uLCBhbmNob3JBdENhbWVyYSk7XG4gICAgfSBlbHNlIGlmIChhYnNQb3NEZWx0YSA+PSBmbGlja2luZy50aHJlc2hvbGQgJiYgYWJzUG9zRGVsdGEgPiAwKSB7XG4gICAgICAvLyBNb3ZlIHRvIHRoZSBhZGphY2VudCBwYW5lbFxuICAgICAgdGFyZ2V0QW5jaG9yID0gdGhpcy5fZmluZEFkamFjZW50QW5jaG9yKHBvc2l0aW9uLCBwb3NEZWx0YSwgYW5jaG9yQXRDYW1lcmEpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGYWxsYmFjayB0byBuZWFyZXN0IHBhbmVsIGZyb20gY3VycmVudCBjYW1lcmFcbiAgICAgIHJldHVybiB0aGlzLm1vdmVUb1BhbmVsKGFuY2hvckF0Q2FtZXJhLnBhbmVsLCB7XG4gICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbixcbiAgICAgICAgYXhlc0V2ZW50OiBheGVzRXZlbnRcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl90cmlnZ2VySW5kZXhDaGFuZ2VFdmVudCh0YXJnZXRBbmNob3IucGFuZWwsIHBvc2l0aW9uLCBheGVzRXZlbnQpO1xuICAgIHJldHVybiB0aGlzLl9hbmltYXRlVG9Qb3NpdGlvbih7XG4gICAgICBwb3NpdGlvbjogY2FtZXJhLmNsYW1wVG9SZWFjaGFibGVQb3NpdGlvbih0YXJnZXRBbmNob3IucG9zaXRpb24pLFxuICAgICAgZHVyYXRpb246IGR1cmF0aW9uLFxuICAgICAgbmV3QWN0aXZlUGFuZWw6IHRhcmdldEFuY2hvci5wYW5lbCxcbiAgICAgIGF4ZXNFdmVudDogYXhlc0V2ZW50XG4gICAgfSk7XG4gIH07XG4gIF9fcHJvdG8uX2ZpbmRTbmFwcGVkQW5jaG9yID0gZnVuY3Rpb24gKHBvc2l0aW9uLCBhbmNob3JBdENhbWVyYSkge1xuICAgIHZhciBmbGlja2luZyA9IGdldEZsaWNraW5nQXR0YWNoZWQodGhpcy5fZmxpY2tpbmcpO1xuICAgIHZhciBjYW1lcmEgPSBmbGlja2luZy5jYW1lcmE7XG4gICAgdmFyIGNvdW50ID0gdGhpcy5fY291bnQ7XG4gICAgdmFyIGN1cnJlbnRQb3MgPSBjYW1lcmEucG9zaXRpb247XG4gICAgdmFyIGNsYW1wZWRQb3NpdGlvbiA9IGNhbWVyYS5jbGFtcFRvUmVhY2hhYmxlUG9zaXRpb24ocG9zaXRpb24pO1xuICAgIHZhciBhbmNob3JBdFBvc2l0aW9uID0gY2FtZXJhLmZpbmRBbmNob3JJbmNsdWRlUG9zaXRpb24oY2xhbXBlZFBvc2l0aW9uKTtcbiAgICBpZiAoIWFuY2hvckF0Q2FtZXJhIHx8ICFhbmNob3JBdFBvc2l0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRmxpY2tpbmdFcnJvcihNRVNTQUdFLlBPU0lUSU9OX05PVF9SRUFDSEFCTEUocG9zaXRpb24pLCBDT0RFLlBPU0lUSU9OX05PVF9SRUFDSEFCTEUpO1xuICAgIH1cbiAgICBpZiAoIWlzRmluaXRlKGNvdW50KSkge1xuICAgICAgcmV0dXJuIGFuY2hvckF0UG9zaXRpb247XG4gICAgfVxuICAgIHZhciBwYW5lbENvdW50ID0gZmxpY2tpbmcucGFuZWxDb3VudDtcbiAgICB2YXIgYW5jaG9ycyA9IGNhbWVyYS5hbmNob3JQb2ludHM7XG4gICAgdmFyIGxvb3BDb3VudCA9IE1hdGguc2lnbihwb3NpdGlvbiAtIGN1cnJlbnRQb3MpICogTWF0aC5mbG9vcihNYXRoLmFicyhwb3NpdGlvbiAtIGN1cnJlbnRQb3MpIC8gY2FtZXJhLnJhbmdlRGlmZik7XG4gICAgaWYgKHBvc2l0aW9uID4gY3VycmVudFBvcyAmJiBhbmNob3JBdFBvc2l0aW9uLmluZGV4IDwgYW5jaG9yQXRDYW1lcmEuaW5kZXggfHwgYW5jaG9yQXRQb3NpdGlvbi5wb3NpdGlvbiA+IGFuY2hvckF0Q2FtZXJhLnBvc2l0aW9uICYmIGFuY2hvckF0UG9zaXRpb24uaW5kZXggPT09IGFuY2hvckF0Q2FtZXJhLmluZGV4KSB7XG4gICAgICBsb29wQ291bnQgKz0gMTtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uIDwgY3VycmVudFBvcyAmJiBhbmNob3JBdFBvc2l0aW9uLmluZGV4ID4gYW5jaG9yQXRDYW1lcmEuaW5kZXggfHwgYW5jaG9yQXRQb3NpdGlvbi5wb3NpdGlvbiA8IGFuY2hvckF0Q2FtZXJhLnBvc2l0aW9uICYmIGFuY2hvckF0UG9zaXRpb24uaW5kZXggPT09IGFuY2hvckF0Q2FtZXJhLmluZGV4KSB7XG4gICAgICBsb29wQ291bnQgLT0gMTtcbiAgICB9XG4gICAgdmFyIGNpcmN1bGFySW5kZXhPZmZzZXQgPSBsb29wQ291bnQgKiBwYW5lbENvdW50O1xuICAgIHZhciBhbmNob3JBdFBvc2l0aW9uSW5kZXggPSBhbmNob3JBdFBvc2l0aW9uLmluZGV4ICsgY2lyY3VsYXJJbmRleE9mZnNldDtcbiAgICBpZiAoTWF0aC5hYnMoYW5jaG9yQXRQb3NpdGlvbkluZGV4IC0gYW5jaG9yQXRDYW1lcmEuaW5kZXgpIDw9IGNvdW50KSB7XG4gICAgICB2YXIgYW5jaG9yID0gYW5jaG9yc1thbmNob3JBdFBvc2l0aW9uLmluZGV4XTtcbiAgICAgIHJldHVybiBuZXcgQW5jaG9yUG9pbnQoe1xuICAgICAgICBpbmRleDogYW5jaG9yLmluZGV4LFxuICAgICAgICBwb3NpdGlvbjogYW5jaG9yLnBvc2l0aW9uICsgbG9vcENvdW50ICogY2FtZXJhLnJhbmdlRGlmZixcbiAgICAgICAgcGFuZWw6IGFuY2hvci5wYW5lbFxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChmbGlja2luZy5jaXJjdWxhckVuYWJsZWQpIHtcbiAgICAgIHZhciB0YXJnZXRBbmNob3IgPSBhbmNob3JzW2NpcmN1bGF0ZUluZGV4KGFuY2hvckF0Q2FtZXJhLmluZGV4ICsgTWF0aC5zaWduKHBvc2l0aW9uIC0gY3VycmVudFBvcykgKiBjb3VudCwgcGFuZWxDb3VudCldO1xuICAgICAgdmFyIGxvb3AgPSBNYXRoLmZsb29yKGNvdW50IC8gcGFuZWxDb3VudCk7XG4gICAgICBpZiAocG9zaXRpb24gPiBjdXJyZW50UG9zICYmIHRhcmdldEFuY2hvci5pbmRleCA8IGFuY2hvckF0Q2FtZXJhLmluZGV4KSB7XG4gICAgICAgIGxvb3AgKz0gMTtcbiAgICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPCBjdXJyZW50UG9zICYmIHRhcmdldEFuY2hvci5pbmRleCA+IGFuY2hvckF0Q2FtZXJhLmluZGV4KSB7XG4gICAgICAgIGxvb3AgLT0gMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgQW5jaG9yUG9pbnQoe1xuICAgICAgICBpbmRleDogdGFyZ2V0QW5jaG9yLmluZGV4LFxuICAgICAgICBwb3NpdGlvbjogdGFyZ2V0QW5jaG9yLnBvc2l0aW9uICsgbG9vcCAqIGNhbWVyYS5yYW5nZURpZmYsXG4gICAgICAgIHBhbmVsOiB0YXJnZXRBbmNob3IucGFuZWxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYW5jaG9yc1tjbGFtcCQxKGFuY2hvckF0Q2FtZXJhLmluZGV4ICsgTWF0aC5zaWduKHBvc2l0aW9uIC0gY3VycmVudFBvcykgKiBjb3VudCwgMCwgYW5jaG9ycy5sZW5ndGggLSAxKV07XG4gICAgfVxuICB9O1xuICBfX3Byb3RvLl9maW5kQWRqYWNlbnRBbmNob3IgPSBmdW5jdGlvbiAocG9zaXRpb24sIHBvc0RlbHRhLCBhbmNob3JBdENhbWVyYSkge1xuICAgIHZhciBfYTtcbiAgICB2YXIgZmxpY2tpbmcgPSBnZXRGbGlja2luZ0F0dGFjaGVkKHRoaXMuX2ZsaWNraW5nKTtcbiAgICB2YXIgY2FtZXJhID0gZmxpY2tpbmcuY2FtZXJhO1xuICAgIGlmIChjYW1lcmEuY2lyY3VsYXJFbmFibGVkKSB7XG4gICAgICB2YXIgYW5jaG9ySW5jbHVkZVBvc2l0aW9uID0gY2FtZXJhLmZpbmRBbmNob3JJbmNsdWRlUG9zaXRpb24ocG9zaXRpb24pO1xuICAgICAgaWYgKGFuY2hvckluY2x1ZGVQb3NpdGlvbiAmJiBhbmNob3JJbmNsdWRlUG9zaXRpb24ucG9zaXRpb24gIT09IGFuY2hvckF0Q2FtZXJhLnBvc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiBhbmNob3JJbmNsdWRlUG9zaXRpb247XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBhZGphY2VudEFuY2hvciA9IChfYSA9IHBvc0RlbHRhID4gMCA/IGNhbWVyYS5nZXROZXh0QW5jaG9yKGFuY2hvckF0Q2FtZXJhKSA6IGNhbWVyYS5nZXRQcmV2QW5jaG9yKGFuY2hvckF0Q2FtZXJhKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogYW5jaG9yQXRDYW1lcmE7XG4gICAgcmV0dXJuIGFkamFjZW50QW5jaG9yO1xuICB9O1xuICBfX3Byb3RvLl9jYWxjU25hcFRocmVzaG9sZCA9IGZ1bmN0aW9uICh0aHJlc2hvbGQsIHBvc2l0aW9uLCBhY3RpdmVBbmNob3IpIHtcbiAgICB2YXIgaXNOZXh0RGlyZWN0aW9uID0gcG9zaXRpb24gPiBhY3RpdmVBbmNob3IucG9zaXRpb247XG4gICAgdmFyIHBhbmVsID0gYWN0aXZlQW5jaG9yLnBhbmVsO1xuICAgIHZhciBwYW5lbFNpemUgPSBwYW5lbC5zaXplO1xuICAgIHZhciBhbGlnblBvcyA9IHBhbmVsLmFsaWduUG9zaXRpb247XG4gICAgLy8gTWluaW11bSBkaXN0YW5jZSBuZWVkZWQgdG8gZGVjaWRlIHByZXYvbmV4dCBwYW5lbCBhcyBuZWFyZXN0XG4gICAgLypcclxuICAgICAqIHwgIFByZXYgIHwgICAgIE5leHQgICAgIHxcclxuICAgICAqIHw8LS0tLS0tPnw8LS0tLS0tLS0tLS0tPnxcclxuICAgICAqIFsgICAgICAgIHw8LUFuY2hvciAgICAgIF1cclxuICAgICAqL1xuICAgIHJldHVybiBNYXRoLm1heCh0aHJlc2hvbGQsIGlzTmV4dERpcmVjdGlvbiA/IHBhbmVsU2l6ZSAtIGFsaWduUG9zICsgcGFuZWwubWFyZ2luLm5leHQgOiBhbGlnblBvcyArIHBhbmVsLm1hcmdpbi5wcmV2KTtcbiAgfTtcbiAgcmV0dXJuIFNuYXBDb250cm9sO1xufShDb250cm9sKTtcblxuLyoqXHJcbiAqIEEge0BsaW5rIENvbnRyb2x9IHRoYXQgY2FuIGJlIHNjcm9sbGVkIGZyZWVseSB3aXRob3V0IGFsaWdubWVudFxyXG4gKiBAa28g7Yyo64SQ7J20IOygle2VtOynhCDsp4DsoJDsl5Ag7KCV66Cs65CY7KeAIOyViuqzoCwg7J6Q7Jyg66Gt6rKMIOyKpO2BrOuhpO2VoCDsiJgg7J6I64qUIOydtOuPmSDrsKnsi53snYQg7IKs7Jqp7ZWY64qUIHtAbGluayBDb250cm9sfVxyXG4gKi9cbnZhciBGcmVlQ29udHJvbCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyQzKEZyZWVDb250cm9sLCBfc3VwZXIpO1xuICAvKiogKi9cbiAgZnVuY3Rpb24gRnJlZUNvbnRyb2woX2EpIHtcbiAgICB2YXIgX2IgPSAoX2EgPT09IHZvaWQgMCA/IHt9IDogX2EpLnN0b3BBdEVkZ2UsXG4gICAgICBzdG9wQXRFZGdlID0gX2IgPT09IHZvaWQgMCA/IHRydWUgOiBfYjtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgIF90aGlzLl9zdG9wQXRFZGdlID0gc3RvcEF0RWRnZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgdmFyIF9fcHJvdG8gPSBGcmVlQ29udHJvbC5wcm90b3R5cGU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcInN0b3BBdEVkZ2VcIiwge1xuICAgIC8qKlxyXG4gICAgICogTWFrZSBzY3JvbGwgYW5pbWF0aW9uIHRvIHN0b3AgYXQgdGhlIHN0YXJ0L2VuZCBvZiB0aGUgc2Nyb2xsIGFyZWEsIG5vdCBnb2luZyBvdXQgdGhlIGJvdW5jZSBhcmVhXHJcbiAgICAgKiBAa28g7Iqk7YGs66GkIOyVoOuLiOuplOydtOyFmOydhCDsiqTtgazroaQg7JiB7Jet7J2YIOyLnOyekeqzvCDrgZ3rtoDrtoTsl5DshJwg66mI7LaU64+E66GdIO2VmOyXrCwg67CU7Jq07IqkIOyYgeyXreydhCDrhJjslrTqsIDsp4Ag7JWK64+E66GdIO2VqeuLiOuLpFxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKiBAZGVmYXVsdCB0cnVlXHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdG9wQXRFZGdlO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICB0aGlzLl9zdG9wQXRFZGdlID0gdmFsO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICAvKipcclxuICAgKiBVcGRhdGUgcG9zaXRpb24gYWZ0ZXIgcmVzaXppbmdcclxuICAgKiBAa28gcmVzaXplIOydtO2bhOyXkCBwb3NpdGlvbuydhCDsl4XrjbDsnbTtirjtlanri4jri6RcclxuICAgKiBAcGFyYW0ge251bWJlcn0gcHJvZ3Jlc3NJblBhbmVsIFByZXZpb3VzIGNhbWVyYSdzIHByb2dyZXNzIGluIGFjdGl2ZSBwYW5lbCBiZWZvcmUgcmVzaXplPGtvPlJlc2l6ZSDsnbTsoIQg7ZiE7J6sIOyEoO2DneuQnCDtjKjrhJAg64K07JeQ7ISc7J2YIOy5tOuplOudvCBwcm9ncmVzcyDqsJI8L2tvPlxyXG4gICAqIEB0aHJvd3Mge0ZsaWNraW5nRXJyb3J9XHJcbiAgICoge0BsaW5rIEVSUk9SX0NPREUgTk9UX0FUVEFDSEVEX1RPX0ZMSUNLSU5HfSBXaGVuIHtAbGluayBDYW1lcmEjaW5pdCBpbml0fSBpcyBub3QgY2FsbGVkIGJlZm9yZVxyXG4gICAqIDxrbz57QGxpbmsgRVJST1JfQ09ERSBOT1RfQVRUQUNIRURfVE9fRkxJQ0tJTkd9IHtAbGluayBDYW1lcmEjaW5pdCBpbml0feydtCDsnbTsoITsl5Ag7Zi47Lac65CY7KeAIOyViuydgCDqsr3smrA8L2tvPlxyXG4gICAqIEBjaGFpbmFibGVcclxuICAgKiBAcmV0dXJuIHtQcm9taXNlPHZvaWQ+fVxyXG4gICAqL1xuICBfX3Byb3RvLnVwZGF0ZVBvc2l0aW9uID0gZnVuY3Rpb24gKHByb2dyZXNzSW5QYW5lbCkge1xuICAgIHZhciBmbGlja2luZyA9IGdldEZsaWNraW5nQXR0YWNoZWQodGhpcy5fZmxpY2tpbmcpO1xuICAgIHZhciBjYW1lcmEgPSBmbGlja2luZy5jYW1lcmE7XG4gICAgdmFyIGFjdGl2ZVBhbmVsID0gdGhpcy5fYWN0aXZlUGFuZWw7XG4gICAgaWYgKGFjdGl2ZVBhbmVsKSB7XG4gICAgICB2YXIgcGFuZWxSYW5nZSA9IGFjdGl2ZVBhbmVsLnJhbmdlO1xuICAgICAgdmFyIG5ld1Bvc2l0aW9uID0gcGFuZWxSYW5nZS5taW4gKyAocGFuZWxSYW5nZS5tYXggLSBwYW5lbFJhbmdlLm1pbikgKiBwcm9ncmVzc0luUGFuZWw7XG4gICAgICBjYW1lcmEubG9va0F0KGNhbWVyYS5jbGFtcFRvUmVhY2hhYmxlUG9zaXRpb24obmV3UG9zaXRpb24pKTtcbiAgICB9XG4gIH07XG4gIC8qKlxyXG4gICAqIE1vdmUge0BsaW5rIENhbWVyYX0gdG8gdGhlIGdpdmVuIHBvc2l0aW9uXHJcbiAgICogQGtvIHtAbGluayBDYW1lcmF966W8IOyjvOyWtOynhCDsooztkZzroZwg7J2064+Z7ZWp64uI64ukXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHBvc2l0aW9uIFRoZSB0YXJnZXQgcG9zaXRpb24gdG8gbW92ZTxrbz7snbTrj5ntlaAg7KKM7ZGcPC9rbz5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gZHVyYXRpb24gRHVyYXRpb24gb2YgdGhlIHBhbmVsIG1vdmVtZW50IGFuaW1hdGlvbiAodW5pdDogbXMpLjxrbz7tjKjrhJAg7J2064+ZIOyVoOuLiOuplOydtOyFmCDsp4Ttlokg7Iuc6rCEICjri6jsnIQ6IG1zKTwva28+XHJcbiAgICogQHBhcmFtIHtvYmplY3R9IFtheGVzRXZlbnRdIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWF4ZXMvcmVsZWFzZS9sYXRlc3QvZG9jL2VnLkF4ZXMuaHRtbCNldmVudDpyZWxlYXNlIHJlbGVhc2V9IGV2ZW50IG9mIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWF4ZXMvIEF4ZXN9XHJcbiAgICogPGtvPntAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWF4ZXMvIEF4ZXN97J2YIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWF4ZXMvcmVsZWFzZS9sYXRlc3QvZG9jL2VnLkF4ZXMuaHRtbCNldmVudDpyZWxlYXNlIHJlbGVhc2V9IOydtOuypO2KuDwva28+XHJcbiAgICogQGZpcmVzIEZsaWNraW5nI21vdmVTdGFydFxyXG4gICAqIEBmaXJlcyBGbGlja2luZyNtb3ZlXHJcbiAgICogQGZpcmVzIEZsaWNraW5nI21vdmVFbmRcclxuICAgKiBAZmlyZXMgRmxpY2tpbmcjd2lsbENoYW5nZVxyXG4gICAqIEBmaXJlcyBGbGlja2luZyNjaGFuZ2VkXHJcbiAgICogQGZpcmVzIEZsaWNraW5nI3dpbGxSZXN0b3JlXHJcbiAgICogQGZpcmVzIEZsaWNraW5nI3Jlc3RvcmVkXHJcbiAgICogQGZpcmVzIEZsaWNraW5nI25lZWRQYW5lbFxyXG4gICAqIEBmaXJlcyBGbGlja2luZyN2aXNpYmxlQ2hhbmdlXHJcbiAgICogQGZpcmVzIEZsaWNraW5nI3JlYWNoRWRnZVxyXG4gICAqIEB0aHJvd3Mge0ZsaWNraW5nRXJyb3J9XHJcbiAgICogfGNvZGV8Y29uZGl0aW9ufFxyXG4gICAqIHwtLS18LS0tfFxyXG4gICAqIHx7QGxpbmsgRVJST1JfQ09ERSBQT1NJVElPTl9OT1RfUkVBQ0hBQkxFfXxXaGVuIHRoZSBnaXZlbiBwYW5lbCBpcyBhbHJlYWR5IHJlbW92ZWQgb3Igbm90IGluIHRoZSBDYW1lcmEncyB7QGxpbmsgQ2FtZXJhI3JhbmdlIHJhbmdlfXxcclxuICAgKiB8e0BsaW5rIEVSUk9SX0NPREUgTk9UX0FUVEFDSEVEX1RPX0ZMSUNLSU5HfXxXaGVuIHtAbGluayBDb250cm9sI2luaXQgaW5pdH0gaXMgbm90IGNhbGxlZCBiZWZvcmV8XHJcbiAgICogfHtAbGluayBFUlJPUl9DT0RFIEFOSU1BVElPTl9JTlRFUlJVUFRFRH18V2hlbiB0aGUgYW5pbWF0aW9uIGlzIGludGVycnVwdGVkIGJ5IHVzZXIgaW5wdXR8XHJcbiAgICogfHtAbGluayBFUlJPUl9DT0RFIFNUT1BfQ0FMTEVEX0JZX1VTRVJ9fFdoZW4gdGhlIGFuaW1hdGlvbiBpcyBpbnRlcnJ1cHRlZCBieSB1c2VyIGlucHV0fFxyXG4gICAqIDxrbz5cclxuICAgKlxyXG4gICAqIHxjb2RlfGNvbmRpdGlvbnxcclxuICAgKiB8LS0tfC0tLXxcclxuICAgKiB8e0BsaW5rIEVSUk9SX0NPREUgUE9TSVRJT05fTk9UX1JFQUNIQUJMRX187KO87Ja07KeEIO2MqOuEkOydtCDsoJzqsbDrkJjsl4jqsbDrgpgsIENhbWVyYeydmCB7QGxpbmsgQ2FtZXJhI3JhbmdlIHJhbmdlfSDrsJbsl5Ag7J6I7J2EIOqyveyasHxcclxuICAgKiB8e0BsaW5rIEVSUk9SX0NPREUgTk9UX0FUVEFDSEVEX1RPX0ZMSUNLSU5HfXx7QGxpbmsgQ29udHJvbCNpbml0IGluaXR97J20IOydtOyghOyXkCDtmLjstpzrkJjsp4Ag7JWK7J2AIOqyveyasHxcclxuICAgKiB8e0BsaW5rIEVSUk9SX0NPREUgQU5JTUFUSU9OX0lOVEVSUlVQVEVEfXzsgqzsmqnsnpAg7J6F66Cl7JeQIOydmO2VtCDslaDri4jrqZTsnbTshZjsnbQg7KSR64uo65CcIOqyveyasHxcclxuICAgKiB8e0BsaW5rIEVSUk9SX0NPREUgU1RPUF9DQUxMRURfQllfVVNFUn1867Cc7IOd65CcIOydtOuypO2KuOuTpCDspJEg7ZWY64KY652864+EIGBzdG9wKClg7J20IO2YuOy2nOuQnCDqsr3smrB8XHJcbiAgICpcclxuICAgKiA8L2tvPlxyXG4gICAqIEByZXR1cm4ge1Byb21pc2U8dm9pZD59IEEgUHJvbWlzZSB3aGljaCB3aWxsIGJlIHJlc29sdmVkIGFmdGVyIHJlYWNoaW5nIHRoZSB0YXJnZXQgcG9zaXRpb248a28+7ZW064u5IOyijO2RnCDrj4Tri6zsi5zsl5AgcmVzb2x2ZeuQmOuKlCBQcm9taXNlPC9rbz5cclxuICAgKi9cbiAgX19wcm90by5tb3ZlVG9Qb3NpdGlvbiA9IGZ1bmN0aW9uIChwb3NpdGlvbiwgZHVyYXRpb24sIGF4ZXNFdmVudCkge1xuICAgIHZhciBmbGlja2luZyA9IGdldEZsaWNraW5nQXR0YWNoZWQodGhpcy5fZmxpY2tpbmcpO1xuICAgIHZhciBjYW1lcmEgPSBmbGlja2luZy5jYW1lcmE7XG4gICAgdmFyIHRhcmdldFBvcyA9IGNhbWVyYS5jbGFtcFRvUmVhY2hhYmxlUG9zaXRpb24ocG9zaXRpb24pO1xuICAgIHZhciBhbmNob3JBdFBvc2l0aW9uID0gY2FtZXJhLmZpbmRBbmNob3JJbmNsdWRlUG9zaXRpb24odGFyZ2V0UG9zKTtcbiAgICBpZiAoIWFuY2hvckF0UG9zaXRpb24pIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRmxpY2tpbmdFcnJvcihNRVNTQUdFLlBPU0lUSU9OX05PVF9SRUFDSEFCTEUocG9zaXRpb24pLCBDT0RFLlBPU0lUSU9OX05PVF9SRUFDSEFCTEUpKTtcbiAgICB9XG4gICAgdmFyIHRhcmdldFBhbmVsID0gYW5jaG9yQXRQb3NpdGlvbi5wYW5lbDtcbiAgICAvLyBUcmlnZ2VyIG9ubHkgY2hhbmdlIGV2ZW50XG4gICAgaWYgKHRhcmdldFBhbmVsICE9PSB0aGlzLl9hY3RpdmVQYW5lbCkge1xuICAgICAgdGhpcy5fdHJpZ2dlckluZGV4Q2hhbmdlRXZlbnQodGFyZ2V0UGFuZWwsIHBvc2l0aW9uLCBheGVzRXZlbnQpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fYW5pbWF0ZVRvUG9zaXRpb24oe1xuICAgICAgcG9zaXRpb246IHRoaXMuX3N0b3BBdEVkZ2UgPyB0YXJnZXRQb3MgOiBwb3NpdGlvbixcbiAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbixcbiAgICAgIG5ld0FjdGl2ZVBhbmVsOiB0YXJnZXRQYW5lbCxcbiAgICAgIGF4ZXNFdmVudDogYXhlc0V2ZW50XG4gICAgfSk7XG4gIH07XG4gIHJldHVybiBGcmVlQ29udHJvbDtcbn0oQ29udHJvbCk7XG5cbi8qKlxyXG4gKiBBIHtAbGluayBDb250cm9sfSB0aGF0IGFsbG93IHlvdSB0byBzZWxlY3QgdGhlIG1heGltdW0gbnVtYmVyIG9mIHBhbmVscyB0byBtb3ZlIGF0IGEgdGltZVxyXG4gKiBAa28g7ZWc67KI7JeQIOy1nOuMgOuhnCDsnbTrj5ntlaAg7Yyo64SQ7J2YIOqwnOyImOulvCDshKDtg50g6rCA64ql7ZWcIHtAbGluayBDb250cm9sfVxyXG4gKi9cbnZhciBTdHJpY3RDb250cm9sID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzJDMoU3RyaWN0Q29udHJvbCwgX3N1cGVyKTtcbiAgLyoqICovXG4gIGZ1bmN0aW9uIFN0cmljdENvbnRyb2woX2EpIHtcbiAgICB2YXIgX2IgPSAoX2EgPT09IHZvaWQgMCA/IHt9IDogX2EpLmNvdW50LFxuICAgICAgY291bnQgPSBfYiA9PT0gdm9pZCAwID8gMSA6IF9iO1xuICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgX3RoaXMuc2V0QWN0aXZlID0gZnVuY3Rpb24gKG5ld0FjdGl2ZVBhbmVsLCBwcmV2QWN0aXZlUGFuZWwsIGlzVHJ1c3RlZCkge1xuICAgICAgX3N1cGVyLnByb3RvdHlwZS5zZXRBY3RpdmUuY2FsbChfdGhpcywgbmV3QWN0aXZlUGFuZWwsIHByZXZBY3RpdmVQYW5lbCwgaXNUcnVzdGVkKTtcbiAgICAgIF90aGlzLnVwZGF0ZUlucHV0KCk7XG4gICAgfTtcbiAgICBfdGhpcy5fY291bnQgPSBjb3VudDtcbiAgICBfdGhpcy5fcmVzZXRJbmRleFJhbmdlKCk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIHZhciBfX3Byb3RvID0gU3RyaWN0Q29udHJvbC5wcm90b3R5cGU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcImNvdW50XCIsIHtcbiAgICAvKipcclxuICAgICAqIE1heGltdW0gbnVtYmVyIG9mIHBhbmVscyB0aGF0IGNhbiBiZSBtb3ZlZCBhdCBhIHRpbWVcclxuICAgICAqIEBrbyDstZzrjIDroZwg7JuA7KeB7J28IOyImCDsnojripQg7Yyo64SQ7J2YIOqwnOyImFxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDFcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NvdW50O1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICB0aGlzLl9jb3VudCA9IHZhbDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgLyoqXHJcbiAgICogRGVzdHJveSBDb250cm9sIGFuZCByZXR1cm4gdG8gaW5pdGlhbCBzdGF0ZVxyXG4gICAqIEBrbyBDb250cm9s7J2EIOy0iOq4sCDsg4Htg5zroZwg65CY64+M66a964uI64ukXHJcbiAgICogQHJldHVybiB7dm9pZH1cclxuICAgKi9cbiAgX19wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIF9zdXBlci5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuICAgIHRoaXMuX3Jlc2V0SW5kZXhSYW5nZSgpO1xuICB9O1xuICAvKipcclxuICAgKiBVcGRhdGUge0BsaW5rIENvbnRyb2wjY29udHJvbGxlciBjb250cm9sbGVyfSdzIHN0YXRlXHJcbiAgICogQGtvIHtAbGluayBDb250cm9sI2NvbnRyb2xsZXIgY29udHJvbGxlcn3snZgg64K067aAIOyDge2DnOulvCDqsLHsi6Dtlanri4jri6RcclxuICAgKiBAY2hhaW5hYmxlXHJcbiAgICogQHJldHVybiB7dGhpc31cclxuICAgKi9cbiAgX19wcm90by51cGRhdGVJbnB1dCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX2E7XG4gICAgdmFyIGZsaWNraW5nID0gZ2V0RmxpY2tpbmdBdHRhY2hlZCh0aGlzLl9mbGlja2luZyk7XG4gICAgdmFyIGNhbWVyYSA9IGZsaWNraW5nLmNhbWVyYTtcbiAgICB2YXIgcmVuZGVyZXIgPSBmbGlja2luZy5yZW5kZXJlcjtcbiAgICB2YXIgY29udHJvbGxlciA9IHRoaXMuX2NvbnRyb2xsZXI7XG4gICAgdmFyIGNvbnRyb2xQYXJhbXMgPSBjYW1lcmEuY29udHJvbFBhcmFtcztcbiAgICB2YXIgY291bnQgPSB0aGlzLl9jb3VudDtcbiAgICB2YXIgYWN0aXZlUGFuZWwgPSBjb250cm9sbGVyLnN0YXRlLmFuaW1hdGluZyA/IChfYSA9IGNhbWVyYS5maW5kTmVhcmVzdEFuY2hvcihjYW1lcmEucG9zaXRpb24pKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGFuZWwgOiB0aGlzLl9hY3RpdmVQYW5lbDtcbiAgICBpZiAoIWFjdGl2ZVBhbmVsKSB7XG4gICAgICBjb250cm9sbGVyLnVwZGF0ZShjb250cm9sUGFyYW1zKTtcbiAgICAgIHRoaXMuX3Jlc2V0SW5kZXhSYW5nZSgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHZhciBjYW1lcmFSYW5nZSA9IGNvbnRyb2xQYXJhbXMucmFuZ2U7XG4gICAgdmFyIGN1cnJlbnRQb3MgPSBhY3RpdmVQYW5lbC5wb3NpdGlvbjtcbiAgICB2YXIgY3VycmVudEluZGV4ID0gYWN0aXZlUGFuZWwuaW5kZXg7XG4gICAgdmFyIHBhbmVsQ291bnQgPSByZW5kZXJlci5wYW5lbENvdW50O1xuICAgIHZhciBwcmV2UGFuZWxJbmRleCA9IGN1cnJlbnRJbmRleCAtIGNvdW50O1xuICAgIHZhciBuZXh0UGFuZWxJbmRleCA9IGN1cnJlbnRJbmRleCArIGNvdW50O1xuICAgIGlmIChwcmV2UGFuZWxJbmRleCA8IDApIHtcbiAgICAgIHByZXZQYW5lbEluZGV4ID0gZmxpY2tpbmcuY2lyY3VsYXJFbmFibGVkID8gZ2V0TWludXNDb21wZW5zYXRlZEluZGV4KChwcmV2UGFuZWxJbmRleCArIDEpICUgcGFuZWxDb3VudCAtIDEsIHBhbmVsQ291bnQpIDogY2xhbXAkMShwcmV2UGFuZWxJbmRleCwgMCwgcGFuZWxDb3VudCAtIDEpO1xuICAgIH1cbiAgICBpZiAobmV4dFBhbmVsSW5kZXggPj0gcGFuZWxDb3VudCkge1xuICAgICAgbmV4dFBhbmVsSW5kZXggPSBmbGlja2luZy5jaXJjdWxhckVuYWJsZWQgPyBuZXh0UGFuZWxJbmRleCAlIHBhbmVsQ291bnQgOiBjbGFtcCQxKG5leHRQYW5lbEluZGV4LCAwLCBwYW5lbENvdW50IC0gMSk7XG4gICAgfVxuICAgIHZhciBwcmV2UGFuZWwgPSByZW5kZXJlci5wYW5lbHNbcHJldlBhbmVsSW5kZXhdO1xuICAgIHZhciBuZXh0UGFuZWwgPSByZW5kZXJlci5wYW5lbHNbbmV4dFBhbmVsSW5kZXhdO1xuICAgIHZhciBwcmV2UG9zID0gTWF0aC5tYXgocHJldlBhbmVsLnBvc2l0aW9uLCBjYW1lcmFSYW5nZS5taW4pO1xuICAgIHZhciBuZXh0UG9zID0gTWF0aC5taW4obmV4dFBhbmVsLnBvc2l0aW9uLCBjYW1lcmFSYW5nZS5tYXgpO1xuICAgIGlmIChwcmV2UG9zID4gY3VycmVudFBvcykge1xuICAgICAgcHJldlBvcyAtPSBjYW1lcmEucmFuZ2VEaWZmO1xuICAgIH1cbiAgICBpZiAobmV4dFBvcyA8IGN1cnJlbnRQb3MpIHtcbiAgICAgIG5leHRQb3MgKz0gY2FtZXJhLnJhbmdlRGlmZjtcbiAgICB9XG4gICAgY29udHJvbFBhcmFtcy5yYW5nZSA9IHtcbiAgICAgIG1pbjogcHJldlBvcyxcbiAgICAgIG1heDogbmV4dFBvc1xuICAgIH07XG4gICAgaWYgKGNvbnRyb2xQYXJhbXMuY2lyY3VsYXIpIHtcbiAgICAgIGlmIChjb250cm9sUGFyYW1zLnBvc2l0aW9uIDwgcHJldlBvcykge1xuICAgICAgICBjb250cm9sUGFyYW1zLnBvc2l0aW9uICs9IGNhbWVyYS5yYW5nZURpZmY7XG4gICAgICB9XG4gICAgICBpZiAoY29udHJvbFBhcmFtcy5wb3NpdGlvbiA+IG5leHRQb3MpIHtcbiAgICAgICAgY29udHJvbFBhcmFtcy5wb3NpdGlvbiAtPSBjYW1lcmEucmFuZ2VEaWZmO1xuICAgICAgfVxuICAgIH1cbiAgICBjb250cm9sUGFyYW1zLmNpcmN1bGFyID0gZmFsc2U7XG4gICAgY29udHJvbGxlci51cGRhdGUoY29udHJvbFBhcmFtcyk7XG4gICAgdGhpcy5faW5kZXhSYW5nZSA9IHtcbiAgICAgIG1pbjogcHJldlBhbmVsLmluZGV4LFxuICAgICAgbWF4OiBuZXh0UGFuZWwuaW5kZXhcbiAgICB9O1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBfX3Byb3RvLm1vdmVUb1BhbmVsID0gZnVuY3Rpb24gKHBhbmVsLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGZsaWNraW5nLCBjYW1lcmEsIGNvbnRyb2xsZXI7XG4gICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIGZsaWNraW5nID0gZ2V0RmxpY2tpbmdBdHRhY2hlZCh0aGlzLl9mbGlja2luZyk7XG4gICAgICAgIGNhbWVyYSA9IGZsaWNraW5nLmNhbWVyYTtcbiAgICAgICAgY29udHJvbGxlciA9IHRoaXMuX2NvbnRyb2xsZXI7XG4gICAgICAgIGNvbnRyb2xsZXIudXBkYXRlKGNhbWVyYS5jb250cm9sUGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9zdXBlci5wcm90b3R5cGUubW92ZVRvUGFuZWwuY2FsbCh0aGlzLCBwYW5lbCwgb3B0aW9ucyldO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG4gIC8qKlxyXG4gICAqIE1vdmUge0BsaW5rIENhbWVyYX0gdG8gdGhlIGdpdmVuIHBvc2l0aW9uXHJcbiAgICogQGtvIHtAbGluayBDYW1lcmF966W8IOyjvOyWtOynhCDsooztkZzroZwg7J2064+Z7ZWp64uI64ukXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHBvc2l0aW9uIFRoZSB0YXJnZXQgcG9zaXRpb24gdG8gbW92ZTxrbz7snbTrj5ntlaAg7KKM7ZGcPC9rbz5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gZHVyYXRpb24gRHVyYXRpb24gb2YgdGhlIHBhbmVsIG1vdmVtZW50IGFuaW1hdGlvbiAodW5pdDogbXMpLjxrbz7tjKjrhJAg7J2064+ZIOyVoOuLiOuplOydtOyFmCDsp4Ttlokg7Iuc6rCEICjri6jsnIQ6IG1zKTwva28+XHJcbiAgICogQHBhcmFtIHtvYmplY3R9IFtheGVzRXZlbnRdIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWF4ZXMvcmVsZWFzZS9sYXRlc3QvZG9jL2VnLkF4ZXMuaHRtbCNldmVudDpyZWxlYXNlIHJlbGVhc2V9IGV2ZW50IG9mIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWF4ZXMvIEF4ZXN9XHJcbiAgICogPGtvPntAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWF4ZXMvIEF4ZXN97J2YIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWF4ZXMvcmVsZWFzZS9sYXRlc3QvZG9jL2VnLkF4ZXMuaHRtbCNldmVudDpyZWxlYXNlIHJlbGVhc2V9IOydtOuypO2KuDwva28+XHJcbiAgICogQGZpcmVzIEZsaWNraW5nI21vdmVTdGFydFxyXG4gICAqIEBmaXJlcyBGbGlja2luZyNtb3ZlXHJcbiAgICogQGZpcmVzIEZsaWNraW5nI21vdmVFbmRcclxuICAgKiBAZmlyZXMgRmxpY2tpbmcjd2lsbENoYW5nZVxyXG4gICAqIEBmaXJlcyBGbGlja2luZyNjaGFuZ2VkXHJcbiAgICogQGZpcmVzIEZsaWNraW5nI3dpbGxSZXN0b3JlXHJcbiAgICogQGZpcmVzIEZsaWNraW5nI3Jlc3RvcmVkXHJcbiAgICogQGZpcmVzIEZsaWNraW5nI25lZWRQYW5lbFxyXG4gICAqIEBmaXJlcyBGbGlja2luZyN2aXNpYmxlQ2hhbmdlXHJcbiAgICogQGZpcmVzIEZsaWNraW5nI3JlYWNoRWRnZVxyXG4gICAqIEB0aHJvd3Mge0ZsaWNraW5nRXJyb3J9XHJcbiAgICogfGNvZGV8Y29uZGl0aW9ufFxyXG4gICAqIHwtLS18LS0tfFxyXG4gICAqIHx7QGxpbmsgRVJST1JfQ09ERSBQT1NJVElPTl9OT1RfUkVBQ0hBQkxFfXxXaGVuIHRoZSBnaXZlbiBwYW5lbCBpcyBhbHJlYWR5IHJlbW92ZWQgb3Igbm90IGluIHRoZSBDYW1lcmEncyB7QGxpbmsgQ2FtZXJhI3JhbmdlIHJhbmdlfXxcclxuICAgKiB8e0BsaW5rIEVSUk9SX0NPREUgTk9UX0FUVEFDSEVEX1RPX0ZMSUNLSU5HfXxXaGVuIHtAbGluayBDb250cm9sI2luaXQgaW5pdH0gaXMgbm90IGNhbGxlZCBiZWZvcmV8XHJcbiAgICogfHtAbGluayBFUlJPUl9DT0RFIEFOSU1BVElPTl9JTlRFUlJVUFRFRH18V2hlbiB0aGUgYW5pbWF0aW9uIGlzIGludGVycnVwdGVkIGJ5IHVzZXIgaW5wdXR8XHJcbiAgICogfHtAbGluayBFUlJPUl9DT0RFIFNUT1BfQ0FMTEVEX0JZX1VTRVJ9fFdoZW4gdGhlIGFuaW1hdGlvbiBpcyBpbnRlcnJ1cHRlZCBieSB1c2VyIGlucHV0fFxyXG4gICAqIDxrbz5cclxuICAgKlxyXG4gICAqIHxjb2RlfGNvbmRpdGlvbnxcclxuICAgKiB8LS0tfC0tLXxcclxuICAgKiB8e0BsaW5rIEVSUk9SX0NPREUgUE9TSVRJT05fTk9UX1JFQUNIQUJMRX187KO87Ja07KeEIO2MqOuEkOydtCDsoJzqsbDrkJjsl4jqsbDrgpgsIENhbWVyYeydmCB7QGxpbmsgQ2FtZXJhI3JhbmdlIHJhbmdlfSDrsJbsl5Ag7J6I7J2EIOqyveyasHxcclxuICAgKiB8e0BsaW5rIEVSUk9SX0NPREUgTk9UX0FUVEFDSEVEX1RPX0ZMSUNLSU5HfXx7QGxpbmsgQ29udHJvbCNpbml0IGluaXR97J20IOydtOyghOyXkCDtmLjstpzrkJjsp4Ag7JWK7J2AIOqyveyasHxcclxuICAgKiB8e0BsaW5rIEVSUk9SX0NPREUgQU5JTUFUSU9OX0lOVEVSUlVQVEVEfXzsgqzsmqnsnpAg7J6F66Cl7JeQIOydmO2VtCDslaDri4jrqZTsnbTshZjsnbQg7KSR64uo65CcIOqyveyasHxcclxuICAgKiB8e0BsaW5rIEVSUk9SX0NPREUgU1RPUF9DQUxMRURfQllfVVNFUn1867Cc7IOd65CcIOydtOuypO2KuOuTpCDspJEg7ZWY64KY652864+EIGBzdG9wKClg7J20IO2YuOy2nOuQnCDqsr3smrB8XHJcbiAgICpcclxuICAgKiA8L2tvPlxyXG4gICAqIEByZXR1cm4ge1Byb21pc2U8dm9pZD59IEEgUHJvbWlzZSB3aGljaCB3aWxsIGJlIHJlc29sdmVkIGFmdGVyIHJlYWNoaW5nIHRoZSB0YXJnZXQgcG9zaXRpb248a28+7ZW064u5IOyijO2RnCDrj4Tri6zsi5zsl5AgcmVzb2x2ZeuQmOuKlCBQcm9taXNlPC9rbz5cclxuICAgKi9cbiAgX19wcm90by5tb3ZlVG9Qb3NpdGlvbiA9IGZ1bmN0aW9uIChwb3NpdGlvbiwgZHVyYXRpb24sIGF4ZXNFdmVudCkge1xuICAgIHZhciBfYTtcbiAgICB2YXIgZmxpY2tpbmcgPSBnZXRGbGlja2luZ0F0dGFjaGVkKHRoaXMuX2ZsaWNraW5nKTtcbiAgICB2YXIgY2FtZXJhID0gZmxpY2tpbmcuY2FtZXJhO1xuICAgIHZhciBjdXJyZW50UGFuZWwgPSAoX2EgPSB0aGlzLl9uZXh0UGFuZWwpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRoaXMuX2FjdGl2ZVBhbmVsO1xuICAgIHZhciBheGVzUmFuZ2UgPSB0aGlzLl9jb250cm9sbGVyLnJhbmdlO1xuICAgIHZhciBpbmRleFJhbmdlID0gdGhpcy5faW5kZXhSYW5nZTtcbiAgICB2YXIgY2FtZXJhUmFuZ2UgPSBjYW1lcmEucmFuZ2U7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5fY29udHJvbGxlci5zdGF0ZTtcbiAgICB2YXIgY2xhbXBlZFBvc2l0aW9uID0gY2xhbXAkMShjYW1lcmEuY2xhbXBUb1JlYWNoYWJsZVBvc2l0aW9uKHBvc2l0aW9uKSwgYXhlc1JhbmdlWzBdLCBheGVzUmFuZ2VbMV0pO1xuICAgIHZhciBhbmNob3JBdFBvc2l0aW9uID0gY2FtZXJhLmZpbmRBbmNob3JJbmNsdWRlUG9zaXRpb24oY2xhbXBlZFBvc2l0aW9uKTtcbiAgICBpZiAoIWFuY2hvckF0UG9zaXRpb24gfHwgIWN1cnJlbnRQYW5lbCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBGbGlja2luZ0Vycm9yKE1FU1NBR0UuUE9TSVRJT05fTk9UX1JFQUNIQUJMRShwb3NpdGlvbiksIENPREUuUE9TSVRJT05fTk9UX1JFQUNIQUJMRSkpO1xuICAgIH1cbiAgICB2YXIgcHJldlBvcyA9IGN1cnJlbnRQYW5lbC5wb3NpdGlvbjtcbiAgICB2YXIgcG9zRGVsdGEgPSBmbGlja2luZy5hbmltYXRpbmcgPyBzdGF0ZS5kZWx0YSA6IHBvc2l0aW9uIC0gY2FtZXJhLnBvc2l0aW9uO1xuICAgIHZhciBpc092ZXJUaHJlc2hvbGQgPSBNYXRoLmFicyhwb3NEZWx0YSkgPj0gZmxpY2tpbmcudGhyZXNob2xkO1xuICAgIHZhciBhZGphY2VudEFuY2hvciA9IHBvc2l0aW9uID4gcHJldlBvcyA/IGNhbWVyYS5nZXROZXh0QW5jaG9yKGFuY2hvckF0UG9zaXRpb24pIDogY2FtZXJhLmdldFByZXZBbmNob3IoYW5jaG9yQXRQb3NpdGlvbik7XG4gICAgdmFyIHRhcmdldFBvcztcbiAgICB2YXIgdGFyZ2V0UGFuZWw7XG4gICAgdmFyIGFuY2hvcnMgPSBjYW1lcmEuYW5jaG9yUG9pbnRzO1xuICAgIHZhciBmaXJzdEFuY2hvciA9IGFuY2hvcnNbMF07XG4gICAgdmFyIGxhc3RBbmNob3IgPSBhbmNob3JzW2FuY2hvcnMubGVuZ3RoIC0gMV07XG4gICAgdmFyIHNob3VsZEJvdW5jZVRvRmlyc3QgPSBwb3NpdGlvbiA8PSBjYW1lcmFSYW5nZS5taW4gJiYgaXNCZXR3ZWVuKGZpcnN0QW5jaG9yLnBhbmVsLmluZGV4LCBpbmRleFJhbmdlLm1pbiwgaW5kZXhSYW5nZS5tYXgpO1xuICAgIHZhciBzaG91bGRCb3VuY2VUb0xhc3QgPSBwb3NpdGlvbiA+PSBjYW1lcmFSYW5nZS5tYXggJiYgaXNCZXR3ZWVuKGxhc3RBbmNob3IucGFuZWwuaW5kZXgsIGluZGV4UmFuZ2UubWluLCBpbmRleFJhbmdlLm1heCk7XG4gICAgdmFyIGlzQWRqYWNlbnQgPSBhZGphY2VudEFuY2hvciAmJiAoaW5kZXhSYW5nZS5taW4gPD0gaW5kZXhSYW5nZS5tYXggPyBpc0JldHdlZW4oYWRqYWNlbnRBbmNob3IuaW5kZXgsIGluZGV4UmFuZ2UubWluLCBpbmRleFJhbmdlLm1heCkgOiBhZGphY2VudEFuY2hvci5pbmRleCA+PSBpbmRleFJhbmdlLm1pbiB8fCBhZGphY2VudEFuY2hvci5pbmRleCA8PSBpbmRleFJhbmdlLm1heCk7XG4gICAgaWYgKHNob3VsZEJvdW5jZVRvRmlyc3QgfHwgc2hvdWxkQm91bmNlVG9MYXN0KSB7XG4gICAgICAvLyBJbiBib3VuY2UgYXJlYVxuICAgICAgdmFyIHRhcmdldEFuY2hvciA9IHBvc2l0aW9uIDwgY2FtZXJhUmFuZ2UubWluID8gZmlyc3RBbmNob3IgOiBsYXN0QW5jaG9yO1xuICAgICAgdGFyZ2V0UGFuZWwgPSB0YXJnZXRBbmNob3IucGFuZWw7XG4gICAgICB0YXJnZXRQb3MgPSB0YXJnZXRBbmNob3IucG9zaXRpb247XG4gICAgfSBlbHNlIGlmIChpc092ZXJUaHJlc2hvbGQgJiYgYW5jaG9yQXRQb3NpdGlvbi5wb3NpdGlvbiAhPT0gY3VycmVudFBhbmVsLnBvc2l0aW9uKSB7XG4gICAgICAvLyBNb3ZlIHRvIGFuY2hvciBhdCBwb3NpdGlvblxuICAgICAgdGFyZ2V0UGFuZWwgPSBhbmNob3JBdFBvc2l0aW9uLnBhbmVsO1xuICAgICAgdGFyZ2V0UG9zID0gYW5jaG9yQXRQb3NpdGlvbi5wb3NpdGlvbjtcbiAgICB9IGVsc2UgaWYgKGlzT3ZlclRocmVzaG9sZCAmJiBpc0FkamFjZW50KSB7XG4gICAgICAvLyBNb3ZlIHRvIGFkamFjZW50IGFuY2hvclxuICAgICAgdGFyZ2V0UGFuZWwgPSBhZGphY2VudEFuY2hvci5wYW5lbDtcbiAgICAgIHRhcmdldFBvcyA9IGFkamFjZW50QW5jaG9yLnBvc2l0aW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGYWxsYmFjayB0byBuZWFyZXN0IHBhbmVsIGZyb20gY3VycmVudCBjYW1lcmFcbiAgICAgIHZhciBhbmNob3JBdENhbWVyYSA9IGNhbWVyYS5maW5kTmVhcmVzdEFuY2hvcihjYW1lcmEucG9zaXRpb24pO1xuICAgICAgaWYgKCFhbmNob3JBdENhbWVyYSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEZsaWNraW5nRXJyb3IoTUVTU0FHRS5QT1NJVElPTl9OT1RfUkVBQ0hBQkxFKHBvc2l0aW9uKSwgQ09ERS5QT1NJVElPTl9OT1RfUkVBQ0hBQkxFKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5tb3ZlVG9QYW5lbChhbmNob3JBdENhbWVyYS5wYW5lbCwge1xuICAgICAgICBkdXJhdGlvbjogZHVyYXRpb24sXG4gICAgICAgIGF4ZXNFdmVudDogYXhlc0V2ZW50XG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fdHJpZ2dlckluZGV4Q2hhbmdlRXZlbnQodGFyZ2V0UGFuZWwsIHBvc2l0aW9uLCBheGVzRXZlbnQpO1xuICAgIHJldHVybiB0aGlzLl9hbmltYXRlVG9Qb3NpdGlvbih7XG4gICAgICBwb3NpdGlvbjogdGFyZ2V0UG9zLFxuICAgICAgZHVyYXRpb246IGR1cmF0aW9uLFxuICAgICAgbmV3QWN0aXZlUGFuZWw6IHRhcmdldFBhbmVsLFxuICAgICAgYXhlc0V2ZW50OiBheGVzRXZlbnRcbiAgICB9KTtcbiAgfTtcbiAgX19wcm90by5fcmVzZXRJbmRleFJhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2luZGV4UmFuZ2UgPSB7XG4gICAgICBtaW46IDAsXG4gICAgICBtYXg6IDBcbiAgICB9O1xuICB9O1xuICByZXR1cm4gU3RyaWN0Q29udHJvbDtcbn0oQ29udHJvbCk7XG5cbi8qKlxyXG4gKiBBIG1vZGUgb2YgY2FtZXJhXHJcbiAqL1xudmFyIENhbWVyYU1vZGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKiogKi9cbiAgZnVuY3Rpb24gQ2FtZXJhTW9kZShmbGlja2luZykge1xuICAgIHRoaXMuX2ZsaWNraW5nID0gZmxpY2tpbmc7XG4gIH1cbiAgdmFyIF9fcHJvdG8gPSBDYW1lcmFNb2RlLnByb3RvdHlwZTtcbiAgX19wcm90by5nZXRBbmNob3JzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwYW5lbHMgPSB0aGlzLl9mbGlja2luZy5yZW5kZXJlci5wYW5lbHM7XG4gICAgcmV0dXJuIHBhbmVscy5tYXAoZnVuY3Rpb24gKHBhbmVsLCBpbmRleCkge1xuICAgICAgcmV0dXJuIG5ldyBBbmNob3JQb2ludCh7XG4gICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgcG9zaXRpb246IHBhbmVsLnBvc2l0aW9uLFxuICAgICAgICBwYW5lbDogcGFuZWxcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuICBfX3Byb3RvLmZpbmRBbmNob3JJbmNsdWRlUG9zaXRpb24gPSBmdW5jdGlvbiAocG9zaXRpb24pIHtcbiAgICB2YXIgYW5jaG9ycyA9IHRoaXMuX2ZsaWNraW5nLmNhbWVyYS5hbmNob3JQb2ludHM7XG4gICAgdmFyIGFuY2hvcnNJbmNsdWRpbmdQb3NpdGlvbiA9IGFuY2hvcnMuZmlsdGVyKGZ1bmN0aW9uIChhbmNob3IpIHtcbiAgICAgIHJldHVybiBhbmNob3IucGFuZWwuaW5jbHVkZVBvc2l0aW9uKHBvc2l0aW9uLCB0cnVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gYW5jaG9yc0luY2x1ZGluZ1Bvc2l0aW9uLnJlZHVjZShmdW5jdGlvbiAobmVhcmVzdCwgYW5jaG9yKSB7XG4gICAgICBpZiAoIW5lYXJlc3QpIHJldHVybiBhbmNob3I7XG4gICAgICByZXR1cm4gTWF0aC5hYnMobmVhcmVzdC5wb3NpdGlvbiAtIHBvc2l0aW9uKSA8IE1hdGguYWJzKGFuY2hvci5wb3NpdGlvbiAtIHBvc2l0aW9uKSA/IG5lYXJlc3QgOiBhbmNob3I7XG4gICAgfSwgbnVsbCk7XG4gIH07XG4gIF9fcHJvdG8uZmluZE5lYXJlc3RBbmNob3IgPSBmdW5jdGlvbiAocG9zaXRpb24pIHtcbiAgICB2YXIgYW5jaG9ycyA9IHRoaXMuX2ZsaWNraW5nLmNhbWVyYS5hbmNob3JQb2ludHM7XG4gICAgaWYgKGFuY2hvcnMubGVuZ3RoIDw9IDApIHJldHVybiBudWxsO1xuICAgIHZhciBwcmV2RGlzdCA9IEluZmluaXR5O1xuICAgIGZvciAodmFyIGFuY2hvcklkeCA9IDA7IGFuY2hvcklkeCA8IGFuY2hvcnMubGVuZ3RoOyBhbmNob3JJZHgrKykge1xuICAgICAgdmFyIGFuY2hvciA9IGFuY2hvcnNbYW5jaG9ySWR4XTtcbiAgICAgIHZhciBkaXN0ID0gTWF0aC5hYnMoYW5jaG9yLnBvc2l0aW9uIC0gcG9zaXRpb24pO1xuICAgICAgaWYgKGRpc3QgPiBwcmV2RGlzdCkge1xuICAgICAgICAvLyBSZXR1cm4gcHJldmlvdXMgYW5jaG9yXG4gICAgICAgIHJldHVybiBhbmNob3JzW2FuY2hvcklkeCAtIDFdO1xuICAgICAgfVxuICAgICAgcHJldkRpc3QgPSBkaXN0O1xuICAgIH1cbiAgICAvLyBSZXR1cm4gbGFzdCBhbmNob3JcbiAgICByZXR1cm4gYW5jaG9yc1thbmNob3JzLmxlbmd0aCAtIDFdO1xuICB9O1xuICBfX3Byb3RvLmNsYW1wVG9SZWFjaGFibGVQb3NpdGlvbiA9IGZ1bmN0aW9uIChwb3NpdGlvbikge1xuICAgIHZhciBjYW1lcmEgPSB0aGlzLl9mbGlja2luZy5jYW1lcmE7XG4gICAgdmFyIHJhbmdlID0gY2FtZXJhLnJhbmdlO1xuICAgIHJldHVybiBjbGFtcCQxKHBvc2l0aW9uLCByYW5nZS5taW4sIHJhbmdlLm1heCk7XG4gIH07XG4gIF9fcHJvdG8uZ2V0Q2lyY3VsYXJPZmZzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIDA7XG4gIH07XG4gIF9fcHJvdG8uY2FuUmVhY2ggPSBmdW5jdGlvbiAocGFuZWwpIHtcbiAgICB2YXIgY2FtZXJhID0gdGhpcy5fZmxpY2tpbmcuY2FtZXJhO1xuICAgIHZhciByYW5nZSA9IGNhbWVyYS5yYW5nZTtcbiAgICBpZiAocGFuZWwucmVtb3ZlZCkgcmV0dXJuIGZhbHNlO1xuICAgIHZhciBwYW5lbFBvcyA9IHBhbmVsLnBvc2l0aW9uO1xuICAgIHJldHVybiBwYW5lbFBvcyA+PSByYW5nZS5taW4gJiYgcGFuZWxQb3MgPD0gcmFuZ2UubWF4O1xuICB9O1xuICBfX3Byb3RvLmNhblNlZSA9IGZ1bmN0aW9uIChwYW5lbCkge1xuICAgIHZhciBjYW1lcmEgPSB0aGlzLl9mbGlja2luZy5jYW1lcmE7XG4gICAgdmFyIHZpc2libGVSYW5nZSA9IGNhbWVyYS52aXNpYmxlUmFuZ2U7XG4gICAgLy8gU2hvdWxkIG5vdCBpbmNsdWRlIG1hcmdpbiwgYXMgd2UgZG9uJ3QgZGVjbGFyZSB3aGF0IHRoZSBtYXJnaW4gaXMgdmlzaWJsZSBhcyB3aGF0IHRoZSBwYW5lbCBpcyB2aXNpYmxlLlxuICAgIHJldHVybiBwYW5lbC5pc1Zpc2libGVPblJhbmdlKHZpc2libGVSYW5nZS5taW4sIHZpc2libGVSYW5nZS5tYXgpO1xuICB9O1xuICByZXR1cm4gQ2FtZXJhTW9kZTtcbn0oKTtcblxudmFyIExpbmVhckNhbWVyYU1vZGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMkMyhMaW5lYXJDYW1lcmFNb2RlLCBfc3VwZXIpO1xuICBmdW5jdGlvbiBMaW5lYXJDYW1lcmFNb2RlKCkge1xuICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuICB2YXIgX19wcm90byA9IExpbmVhckNhbWVyYU1vZGUucHJvdG90eXBlO1xuICBfX3Byb3RvLmNoZWNrQXZhaWxhYmlsaXR5ID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIEl0J3MgYWx3YXlzIGF2YWlsYWJsZVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuICBfX3Byb3RvLmdldFJhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgdmFyIHJlbmRlcmVyID0gdGhpcy5fZmxpY2tpbmcucmVuZGVyZXI7XG4gICAgdmFyIGZpcnN0UGFuZWwgPSByZW5kZXJlci5nZXRQYW5lbCgwKTtcbiAgICB2YXIgbGFzdFBhbmVsID0gcmVuZGVyZXIuZ2V0UGFuZWwocmVuZGVyZXIucGFuZWxDb3VudCAtIDEpO1xuICAgIHJldHVybiB7XG4gICAgICBtaW46IChfYSA9IGZpcnN0UGFuZWwgPT09IG51bGwgfHwgZmlyc3RQYW5lbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmlyc3RQYW5lbC5wb3NpdGlvbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMCxcbiAgICAgIG1heDogKF9iID0gbGFzdFBhbmVsID09PSBudWxsIHx8IGxhc3RQYW5lbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGFzdFBhbmVsLnBvc2l0aW9uKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwXG4gICAgfTtcbiAgfTtcbiAgcmV0dXJuIExpbmVhckNhbWVyYU1vZGU7XG59KENhbWVyYU1vZGUpO1xuXG4vKipcclxuICogQSB7QGxpbmsgQ2FtZXJhfSBtb2RlIHRoYXQgY29ubmVjdHMgdGhlIGxhc3QgcGFuZWwgYW5kIHRoZSBmaXJzdCBwYW5lbCwgZW5hYmxpbmcgY29udGludW91cyBsb29wXHJcbiAqIEBrbyDssqvrsojsp7gg7Yyo64SQ6rO8IOuniOyngOuniSDtjKjrhJDsnbQg7J207Ja07KeEIOyDge2DnOuhnCwg66y07ZWc7Z6IIO2ajOyghO2VoCDsiJgg7J6I64qUIOyiheulmOydmCB7QGxpbmsgQ2FtZXJhfSDrqqjrk5xcclxuICovXG52YXIgQ2lyY3VsYXJDYW1lcmFNb2RlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzJDMoQ2lyY3VsYXJDYW1lcmFNb2RlLCBfc3VwZXIpO1xuICBmdW5jdGlvbiBDaXJjdWxhckNhbWVyYU1vZGUoKSB7XG4gICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG4gIHZhciBfX3Byb3RvID0gQ2lyY3VsYXJDYW1lcmFNb2RlLnByb3RvdHlwZTtcbiAgX19wcm90by5jaGVja0F2YWlsYWJpbGl0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZmxpY2tpbmcgPSB0aGlzLl9mbGlja2luZztcbiAgICB2YXIgcmVuZGVyZXIgPSBmbGlja2luZy5yZW5kZXJlcjtcbiAgICB2YXIgcGFuZWxzID0gcmVuZGVyZXIucGFuZWxzO1xuICAgIGlmIChwYW5lbHMubGVuZ3RoIDw9IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGZpcnN0UGFuZWwgPSBwYW5lbHNbMF07XG4gICAgdmFyIGxhc3RQYW5lbCA9IHBhbmVsc1twYW5lbHMubGVuZ3RoIC0gMV07XG4gICAgdmFyIGZpcnN0UGFuZWxQcmV2ID0gZmlyc3RQYW5lbC5yYW5nZS5taW4gLSBmaXJzdFBhbmVsLm1hcmdpbi5wcmV2O1xuICAgIHZhciBsYXN0UGFuZWxOZXh0ID0gbGFzdFBhbmVsLnJhbmdlLm1heCArIGxhc3RQYW5lbC5tYXJnaW4ubmV4dDtcbiAgICB2YXIgdmlzaWJsZVNpemUgPSBmbGlja2luZy5jYW1lcmEuc2l6ZTtcbiAgICB2YXIgcGFuZWxTaXplU3VtID0gbGFzdFBhbmVsTmV4dCAtIGZpcnN0UGFuZWxQcmV2O1xuICAgIHZhciBjYW5TZXRDaXJjdWxhck1vZGUgPSBwYW5lbHMuZXZlcnkoZnVuY3Rpb24gKHBhbmVsKSB7XG4gICAgICByZXR1cm4gcGFuZWxTaXplU3VtIC0gcGFuZWwuc2l6ZSA+PSB2aXNpYmxlU2l6ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gY2FuU2V0Q2lyY3VsYXJNb2RlO1xuICB9O1xuICBfX3Byb3RvLmdldFJhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBmbGlja2luZyA9IHRoaXMuX2ZsaWNraW5nO1xuICAgIHZhciBwYW5lbHMgPSBmbGlja2luZy5yZW5kZXJlci5wYW5lbHM7XG4gICAgaWYgKHBhbmVscy5sZW5ndGggPD0gMCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWluOiAwLFxuICAgICAgICBtYXg6IDBcbiAgICAgIH07XG4gICAgfVxuICAgIHZhciBmaXJzdFBhbmVsID0gcGFuZWxzWzBdO1xuICAgIHZhciBsYXN0UGFuZWwgPSBwYW5lbHNbcGFuZWxzLmxlbmd0aCAtIDFdO1xuICAgIHZhciBmaXJzdFBhbmVsUHJldiA9IGZpcnN0UGFuZWwucmFuZ2UubWluIC0gZmlyc3RQYW5lbC5tYXJnaW4ucHJldjtcbiAgICB2YXIgbGFzdFBhbmVsTmV4dCA9IGxhc3RQYW5lbC5yYW5nZS5tYXggKyBsYXN0UGFuZWwubWFyZ2luLm5leHQ7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1pbjogZmlyc3RQYW5lbFByZXYsXG4gICAgICBtYXg6IGxhc3RQYW5lbE5leHRcbiAgICB9O1xuICB9O1xuICBfX3Byb3RvLmdldEFuY2hvcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZsaWNraW5nID0gdGhpcy5fZmxpY2tpbmc7XG4gICAgdmFyIHBhbmVscyA9IGZsaWNraW5nLnJlbmRlcmVyLnBhbmVscztcbiAgICByZXR1cm4gcGFuZWxzLm1hcChmdW5jdGlvbiAocGFuZWwsIGluZGV4KSB7XG4gICAgICByZXR1cm4gbmV3IEFuY2hvclBvaW50KHtcbiAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICBwb3NpdGlvbjogcGFuZWwucG9zaXRpb24sXG4gICAgICAgIHBhbmVsOiBwYW5lbFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG4gIF9fcHJvdG8uZmluZE5lYXJlc3RBbmNob3IgPSBmdW5jdGlvbiAocG9zaXRpb24pIHtcbiAgICB2YXIgY2FtZXJhID0gdGhpcy5fZmxpY2tpbmcuY2FtZXJhO1xuICAgIHZhciBhbmNob3JzID0gY2FtZXJhLmFuY2hvclBvaW50cztcbiAgICBpZiAoYW5jaG9ycy5sZW5ndGggPD0gMCkgcmV0dXJuIG51bGw7XG4gICAgdmFyIGNhbVJhbmdlID0gY2FtZXJhLnJhbmdlO1xuICAgIHZhciBtaW5EaXN0ID0gSW5maW5pdHk7XG4gICAgdmFyIG1pbkRpc3RJbmRleCA9IC0xO1xuICAgIGZvciAodmFyIGFuY2hvcklkeCA9IDA7IGFuY2hvcklkeCA8IGFuY2hvcnMubGVuZ3RoOyBhbmNob3JJZHgrKykge1xuICAgICAgdmFyIGFuY2hvciA9IGFuY2hvcnNbYW5jaG9ySWR4XTtcbiAgICAgIHZhciBkaXN0ID0gTWF0aC5taW4oTWF0aC5hYnMoYW5jaG9yLnBvc2l0aW9uIC0gcG9zaXRpb24pLCBNYXRoLmFicyhhbmNob3IucG9zaXRpb24gLSBjYW1SYW5nZS5taW4gKyBjYW1SYW5nZS5tYXggLSBwb3NpdGlvbiksIE1hdGguYWJzKHBvc2l0aW9uIC0gY2FtUmFuZ2UubWluICsgY2FtUmFuZ2UubWF4IC0gYW5jaG9yLnBvc2l0aW9uKSk7XG4gICAgICBpZiAoZGlzdCA8IG1pbkRpc3QpIHtcbiAgICAgICAgbWluRGlzdCA9IGRpc3Q7XG4gICAgICAgIG1pbkRpc3RJbmRleCA9IGFuY2hvcklkeDtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gUmV0dXJuIGxhc3QgYW5jaG9yXG4gICAgcmV0dXJuIGFuY2hvcnNbbWluRGlzdEluZGV4XTtcbiAgfTtcbiAgX19wcm90by5maW5kQW5jaG9ySW5jbHVkZVBvc2l0aW9uID0gZnVuY3Rpb24gKHBvc2l0aW9uKSB7XG4gICAgdmFyIGNhbWVyYSA9IHRoaXMuX2ZsaWNraW5nLmNhbWVyYTtcbiAgICB2YXIgcmFuZ2UgPSBjYW1lcmEucmFuZ2U7XG4gICAgdmFyIGFuY2hvcnMgPSBjYW1lcmEuYW5jaG9yUG9pbnRzO1xuICAgIHZhciByYW5nZURpZmYgPSBjYW1lcmEucmFuZ2VEaWZmO1xuICAgIHZhciBhbmNob3JDb3VudCA9IGFuY2hvcnMubGVuZ3RoO1xuICAgIHZhciBwb3NpdGlvbkluUmFuZ2UgPSBjaXJjdWxhdGVQb3NpdGlvbihwb3NpdGlvbiwgcmFuZ2UubWluLCByYW5nZS5tYXgpO1xuICAgIHZhciBhbmNob3JJblJhbmdlID0gX3N1cGVyLnByb3RvdHlwZS5maW5kQW5jaG9ySW5jbHVkZVBvc2l0aW9uLmNhbGwodGhpcywgcG9zaXRpb25JblJhbmdlKTtcbiAgICBpZiAoYW5jaG9yQ291bnQgPiAwICYmIChwb3NpdGlvbiA9PT0gcmFuZ2UubWluIHx8IHBvc2l0aW9uID09PSByYW5nZS5tYXgpKSB7XG4gICAgICB2YXIgcG9zc2libGVBbmNob3JzID0gW2FuY2hvckluUmFuZ2UsIG5ldyBBbmNob3JQb2ludCh7XG4gICAgICAgIGluZGV4OiAwLFxuICAgICAgICBwb3NpdGlvbjogYW5jaG9yc1swXS5wb3NpdGlvbiArIHJhbmdlRGlmZixcbiAgICAgICAgcGFuZWw6IGFuY2hvcnNbMF0ucGFuZWxcbiAgICAgIH0pLCBuZXcgQW5jaG9yUG9pbnQoe1xuICAgICAgICBpbmRleDogYW5jaG9yQ291bnQgLSAxLFxuICAgICAgICBwb3NpdGlvbjogYW5jaG9yc1thbmNob3JDb3VudCAtIDFdLnBvc2l0aW9uIC0gcmFuZ2VEaWZmLFxuICAgICAgICBwYW5lbDogYW5jaG9yc1thbmNob3JDb3VudCAtIDFdLnBhbmVsXG4gICAgICB9KV0uZmlsdGVyKGZ1bmN0aW9uIChhbmNob3IpIHtcbiAgICAgICAgcmV0dXJuICEhYW5jaG9yO1xuICAgICAgfSk7XG4gICAgICBhbmNob3JJblJhbmdlID0gcG9zc2libGVBbmNob3JzLnJlZHVjZShmdW5jdGlvbiAobmVhcmVzdCwgYW5jaG9yKSB7XG4gICAgICAgIGlmICghbmVhcmVzdCkgcmV0dXJuIGFuY2hvcjtcbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKG5lYXJlc3QucG9zaXRpb24gLSBwb3NpdGlvbikgPCBNYXRoLmFicyhhbmNob3IucG9zaXRpb24gLSBwb3NpdGlvbikgPyBuZWFyZXN0IDogYW5jaG9yO1xuICAgICAgfSwgbnVsbCk7XG4gICAgfVxuICAgIGlmICghYW5jaG9ySW5SYW5nZSkgcmV0dXJuIG51bGw7XG4gICAgaWYgKHBvc2l0aW9uIDwgcmFuZ2UubWluKSB7XG4gICAgICB2YXIgbG9vcENvdW50ID0gLU1hdGguZmxvb3IoKHJhbmdlLm1pbiAtIHBvc2l0aW9uKSAvIHJhbmdlRGlmZikgLSAxO1xuICAgICAgcmV0dXJuIG5ldyBBbmNob3JQb2ludCh7XG4gICAgICAgIGluZGV4OiBhbmNob3JJblJhbmdlLmluZGV4LFxuICAgICAgICBwb3NpdGlvbjogYW5jaG9ySW5SYW5nZS5wb3NpdGlvbiArIHJhbmdlRGlmZiAqIGxvb3BDb3VudCxcbiAgICAgICAgcGFuZWw6IGFuY2hvckluUmFuZ2UucGFuZWxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPiByYW5nZS5tYXgpIHtcbiAgICAgIHZhciBsb29wQ291bnQgPSBNYXRoLmZsb29yKChwb3NpdGlvbiAtIHJhbmdlLm1heCkgLyByYW5nZURpZmYpICsgMTtcbiAgICAgIHJldHVybiBuZXcgQW5jaG9yUG9pbnQoe1xuICAgICAgICBpbmRleDogYW5jaG9ySW5SYW5nZS5pbmRleCxcbiAgICAgICAgcG9zaXRpb246IGFuY2hvckluUmFuZ2UucG9zaXRpb24gKyByYW5nZURpZmYgKiBsb29wQ291bnQsXG4gICAgICAgIHBhbmVsOiBhbmNob3JJblJhbmdlLnBhbmVsXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGFuY2hvckluUmFuZ2U7XG4gIH07XG4gIF9fcHJvdG8uZ2V0Q2lyY3VsYXJPZmZzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZsaWNraW5nID0gdGhpcy5fZmxpY2tpbmc7XG4gICAgdmFyIGNhbWVyYSA9IGZsaWNraW5nLmNhbWVyYTtcbiAgICBpZiAoIWNhbWVyYS5jaXJjdWxhckVuYWJsZWQpIHJldHVybiAwO1xuICAgIHZhciB0b2dnbGVkID0gZmxpY2tpbmcucGFuZWxzLmZpbHRlcihmdW5jdGlvbiAocGFuZWwpIHtcbiAgICAgIHJldHVybiBwYW5lbC50b2dnbGVkO1xuICAgIH0pO1xuICAgIHZhciB0b2dnbGVkUHJldiA9IHRvZ2dsZWQuZmlsdGVyKGZ1bmN0aW9uIChwYW5lbCkge1xuICAgICAgcmV0dXJuIHBhbmVsLnRvZ2dsZURpcmVjdGlvbiA9PT0gRElSRUNUSU9OLlBSRVY7XG4gICAgfSk7XG4gICAgdmFyIHRvZ2dsZWROZXh0ID0gdG9nZ2xlZC5maWx0ZXIoZnVuY3Rpb24gKHBhbmVsKSB7XG4gICAgICByZXR1cm4gcGFuZWwudG9nZ2xlRGlyZWN0aW9uID09PSBESVJFQ1RJT04uTkVYVDtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5fY2FsY1BhbmVsQXJlYVN1bSh0b2dnbGVkUHJldikgLSB0aGlzLl9jYWxjUGFuZWxBcmVhU3VtKHRvZ2dsZWROZXh0KTtcbiAgfTtcbiAgX19wcm90by5jbGFtcFRvUmVhY2hhYmxlUG9zaXRpb24gPSBmdW5jdGlvbiAocG9zaXRpb24pIHtcbiAgICAvLyBCYXNpY2FsbHkgYWxsIHBvc2l0aW9uIGlzIHJlYWNoYWJsZSBmb3IgY2lyY3VsYXIgY2FtZXJhXG4gICAgcmV0dXJuIHBvc2l0aW9uO1xuICB9O1xuICBfX3Byb3RvLmNhblJlYWNoID0gZnVuY3Rpb24gKHBhbmVsKSB7XG4gICAgaWYgKHBhbmVsLnJlbW92ZWQpIHJldHVybiBmYWxzZTtcbiAgICAvLyBBbHdheXMgcmVhY2hhYmxlIG9uIGNpcmN1bGFyIG1vZGVcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbiAgX19wcm90by5jYW5TZWUgPSBmdW5jdGlvbiAocGFuZWwpIHtcbiAgICB2YXIgY2FtZXJhID0gdGhpcy5fZmxpY2tpbmcuY2FtZXJhO1xuICAgIHZhciByYW5nZSA9IGNhbWVyYS5yYW5nZTtcbiAgICB2YXIgcmFuZ2VEaWZmID0gY2FtZXJhLnJhbmdlRGlmZjtcbiAgICB2YXIgdmlzaWJsZVJhbmdlID0gY2FtZXJhLnZpc2libGVSYW5nZTtcbiAgICB2YXIgdmlzaWJsZUluQ3VycmVudFJhbmdlID0gX3N1cGVyLnByb3RvdHlwZS5jYW5TZWUuY2FsbCh0aGlzLCBwYW5lbCk7XG4gICAgLy8gQ2hlY2sgbG9vcGVkIHZpc2libGUgYXJlYSBmb3IgY2lyY3VsYXIgY2FzZVxuICAgIGlmICh2aXNpYmxlUmFuZ2UubWluIDwgcmFuZ2UubWluKSB7XG4gICAgICByZXR1cm4gdmlzaWJsZUluQ3VycmVudFJhbmdlIHx8IHBhbmVsLmlzVmlzaWJsZU9uUmFuZ2UodmlzaWJsZVJhbmdlLm1pbiArIHJhbmdlRGlmZiwgdmlzaWJsZVJhbmdlLm1heCArIHJhbmdlRGlmZik7XG4gICAgfSBlbHNlIGlmICh2aXNpYmxlUmFuZ2UubWF4ID4gcmFuZ2UubWF4KSB7XG4gICAgICByZXR1cm4gdmlzaWJsZUluQ3VycmVudFJhbmdlIHx8IHBhbmVsLmlzVmlzaWJsZU9uUmFuZ2UodmlzaWJsZVJhbmdlLm1pbiAtIHJhbmdlRGlmZiwgdmlzaWJsZVJhbmdlLm1heCAtIHJhbmdlRGlmZik7XG4gICAgfVxuICAgIHJldHVybiB2aXNpYmxlSW5DdXJyZW50UmFuZ2U7XG4gIH07XG4gIF9fcHJvdG8uX2NhbGNQYW5lbEFyZWFTdW0gPSBmdW5jdGlvbiAocGFuZWxzKSB7XG4gICAgcmV0dXJuIHBhbmVscy5yZWR1Y2UoZnVuY3Rpb24gKHN1bSwgcGFuZWwpIHtcbiAgICAgIHJldHVybiBzdW0gKyBwYW5lbC5zaXplSW5jbHVkaW5nTWFyZ2luO1xuICAgIH0sIDApO1xuICB9O1xuICByZXR1cm4gQ2lyY3VsYXJDYW1lcmFNb2RlO1xufShDYW1lcmFNb2RlKTtcblxudmFyIEJvdW5kQ2FtZXJhTW9kZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyQzKEJvdW5kQ2FtZXJhTW9kZSwgX3N1cGVyKTtcbiAgZnVuY3Rpb24gQm91bmRDYW1lcmFNb2RlKCkge1xuICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuICB2YXIgX19wcm90byA9IEJvdW5kQ2FtZXJhTW9kZS5wcm90b3R5cGU7XG4gIF9fcHJvdG8uY2hlY2tBdmFpbGFiaWxpdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZsaWNraW5nID0gdGhpcy5fZmxpY2tpbmc7XG4gICAgdmFyIHJlbmRlcmVyID0gZmxpY2tpbmcucmVuZGVyZXI7XG4gICAgdmFyIGZpcnN0UGFuZWwgPSByZW5kZXJlci5nZXRQYW5lbCgwKTtcbiAgICB2YXIgbGFzdFBhbmVsID0gcmVuZGVyZXIuZ2V0UGFuZWwocmVuZGVyZXIucGFuZWxDb3VudCAtIDEpO1xuICAgIGlmICghZmlyc3RQYW5lbCB8fCAhbGFzdFBhbmVsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciB2aWV3cG9ydFNpemUgPSBmbGlja2luZy5jYW1lcmEuc2l6ZTtcbiAgICB2YXIgZmlyc3RQYW5lbFByZXYgPSBmaXJzdFBhbmVsLnJhbmdlLm1pbjtcbiAgICB2YXIgbGFzdFBhbmVsTmV4dCA9IGxhc3RQYW5lbC5yYW5nZS5tYXg7XG4gICAgdmFyIHBhbmVsQXJlYVNpemUgPSBsYXN0UGFuZWxOZXh0IC0gZmlyc3RQYW5lbFByZXY7XG4gICAgdmFyIGlzQmlnZ2VyVGhhblZpZXdwb3J0ID0gdmlld3BvcnRTaXplIDwgcGFuZWxBcmVhU2l6ZTtcbiAgICByZXR1cm4gaXNCaWdnZXJUaGFuVmlld3BvcnQ7XG4gIH07XG4gIF9fcHJvdG8uZ2V0UmFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZsaWNraW5nID0gdGhpcy5fZmxpY2tpbmc7XG4gICAgdmFyIHJlbmRlcmVyID0gZmxpY2tpbmcucmVuZGVyZXI7XG4gICAgdmFyIGFsaWduUG9zID0gZmxpY2tpbmcuY2FtZXJhLmFsaWduUG9zaXRpb247XG4gICAgdmFyIGZpcnN0UGFuZWwgPSByZW5kZXJlci5nZXRQYW5lbCgwKTtcbiAgICB2YXIgbGFzdFBhbmVsID0gcmVuZGVyZXIuZ2V0UGFuZWwocmVuZGVyZXIucGFuZWxDb3VudCAtIDEpO1xuICAgIGlmICghZmlyc3RQYW5lbCB8fCAhbGFzdFBhbmVsKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtaW46IDAsXG4gICAgICAgIG1heDogMFxuICAgICAgfTtcbiAgICB9XG4gICAgdmFyIHZpZXdwb3J0U2l6ZSA9IGZsaWNraW5nLmNhbWVyYS5zaXplO1xuICAgIHZhciBmaXJzdFBhbmVsUHJldiA9IGZpcnN0UGFuZWwucmFuZ2UubWluO1xuICAgIHZhciBsYXN0UGFuZWxOZXh0ID0gbGFzdFBhbmVsLnJhbmdlLm1heDtcbiAgICB2YXIgcGFuZWxBcmVhU2l6ZSA9IGxhc3RQYW5lbE5leHQgLSBmaXJzdFBhbmVsUHJldjtcbiAgICB2YXIgaXNCaWdnZXJUaGFuVmlld3BvcnQgPSB2aWV3cG9ydFNpemUgPCBwYW5lbEFyZWFTaXplO1xuICAgIHZhciBmaXJzdFBvcyA9IGZpcnN0UGFuZWxQcmV2ICsgYWxpZ25Qb3M7XG4gICAgdmFyIGxhc3RQb3MgPSBsYXN0UGFuZWxOZXh0IC0gdmlld3BvcnRTaXplICsgYWxpZ25Qb3M7XG4gICAgaWYgKGlzQmlnZ2VyVGhhblZpZXdwb3J0KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtaW46IGZpcnN0UG9zLFxuICAgICAgICBtYXg6IGxhc3RQb3NcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhbGlnbiA9IGZsaWNraW5nLmNhbWVyYS5hbGlnbjtcbiAgICAgIHZhciBhbGlnblZhbCA9IHR5cGVvZiBhbGlnbiA9PT0gXCJvYmplY3RcIiA/IGFsaWduLmNhbWVyYSA6IGFsaWduO1xuICAgICAgdmFyIHBvcyA9IGZpcnN0UG9zICsgcGFyc2VBbGlnbiQxKGFsaWduVmFsLCBsYXN0UG9zIC0gZmlyc3RQb3MpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWluOiBwb3MsXG4gICAgICAgIG1heDogcG9zXG4gICAgICB9O1xuICAgIH1cbiAgfTtcbiAgX19wcm90by5nZXRBbmNob3JzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBmbGlja2luZyA9IHRoaXMuX2ZsaWNraW5nO1xuICAgIHZhciBjYW1lcmEgPSBmbGlja2luZy5jYW1lcmE7XG4gICAgdmFyIHBhbmVscyA9IGZsaWNraW5nLnJlbmRlcmVyLnBhbmVscztcbiAgICBpZiAocGFuZWxzLmxlbmd0aCA8PSAwKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHZhciByYW5nZSA9IGZsaWNraW5nLmNhbWVyYS5yYW5nZTtcbiAgICB2YXIgcmVhY2hhYmxlUGFuZWxzID0gcGFuZWxzLmZpbHRlcihmdW5jdGlvbiAocGFuZWwpIHtcbiAgICAgIHJldHVybiBjYW1lcmEuY2FuUmVhY2gocGFuZWwpO1xuICAgIH0pO1xuICAgIGlmIChyZWFjaGFibGVQYW5lbHMubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIHNob3VsZFByZXBlbmRCb3VuZEFuY2hvciA9IHJlYWNoYWJsZVBhbmVsc1swXS5wb3NpdGlvbiAhPT0gcmFuZ2UubWluO1xuICAgICAgdmFyIHNob3VsZEFwcGVuZEJvdW5kQW5jaG9yID0gcmVhY2hhYmxlUGFuZWxzW3JlYWNoYWJsZVBhbmVscy5sZW5ndGggLSAxXS5wb3NpdGlvbiAhPT0gcmFuZ2UubWF4O1xuICAgICAgdmFyIGluZGV4T2Zmc2V0XzEgPSBzaG91bGRQcmVwZW5kQm91bmRBbmNob3IgPyAxIDogMDtcbiAgICAgIHZhciBuZXdBbmNob3JzID0gcmVhY2hhYmxlUGFuZWxzLm1hcChmdW5jdGlvbiAocGFuZWwsIGlkeCkge1xuICAgICAgICByZXR1cm4gbmV3IEFuY2hvclBvaW50KHtcbiAgICAgICAgICBpbmRleDogaWR4ICsgaW5kZXhPZmZzZXRfMSxcbiAgICAgICAgICBwb3NpdGlvbjogcGFuZWwucG9zaXRpb24sXG4gICAgICAgICAgcGFuZWw6IHBhbmVsXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBpZiAoc2hvdWxkUHJlcGVuZEJvdW5kQW5jaG9yKSB7XG4gICAgICAgIG5ld0FuY2hvcnMuc3BsaWNlKDAsIDAsIG5ldyBBbmNob3JQb2ludCh7XG4gICAgICAgICAgaW5kZXg6IDAsXG4gICAgICAgICAgcG9zaXRpb246IHJhbmdlLm1pbixcbiAgICAgICAgICBwYW5lbDogcGFuZWxzW3JlYWNoYWJsZVBhbmVsc1swXS5pbmRleCAtIDFdXG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICAgIGlmIChzaG91bGRBcHBlbmRCb3VuZEFuY2hvcikge1xuICAgICAgICBuZXdBbmNob3JzLnB1c2gobmV3IEFuY2hvclBvaW50KHtcbiAgICAgICAgICBpbmRleDogbmV3QW5jaG9ycy5sZW5ndGgsXG4gICAgICAgICAgcG9zaXRpb246IHJhbmdlLm1heCxcbiAgICAgICAgICBwYW5lbDogcGFuZWxzW3JlYWNoYWJsZVBhbmVsc1tyZWFjaGFibGVQYW5lbHMubGVuZ3RoIC0gMV0uaW5kZXggKyAxXVxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3QW5jaG9ycztcbiAgICB9IGVsc2UgaWYgKHJhbmdlLm1pbiAhPT0gcmFuZ2UubWF4KSB7XG4gICAgICAvLyBUaGVyZSdyZSBtb3JlIHRoYW4gMiBwYW5lbHNcbiAgICAgIHZhciBuZWFyZXN0UGFuZWxBdE1pbiA9IHRoaXMuX2ZpbmROZWFyZXN0UGFuZWwocmFuZ2UubWluLCBwYW5lbHMpO1xuICAgICAgdmFyIHBhbmVsQXRNaW4gPSBuZWFyZXN0UGFuZWxBdE1pbi5pbmRleCA9PT0gcGFuZWxzLmxlbmd0aCAtIDEgPyBuZWFyZXN0UGFuZWxBdE1pbi5wcmV2KCkgOiBuZWFyZXN0UGFuZWxBdE1pbjtcbiAgICAgIHZhciBwYW5lbEF0TWF4ID0gcGFuZWxBdE1pbi5uZXh0KCk7XG4gICAgICByZXR1cm4gW25ldyBBbmNob3JQb2ludCh7XG4gICAgICAgIGluZGV4OiAwLFxuICAgICAgICBwb3NpdGlvbjogcmFuZ2UubWluLFxuICAgICAgICBwYW5lbDogcGFuZWxBdE1pblxuICAgICAgfSksIG5ldyBBbmNob3JQb2ludCh7XG4gICAgICAgIGluZGV4OiAxLFxuICAgICAgICBwb3NpdGlvbjogcmFuZ2UubWF4LFxuICAgICAgICBwYW5lbDogcGFuZWxBdE1heFxuICAgICAgfSldO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gW25ldyBBbmNob3JQb2ludCh7XG4gICAgICAgIGluZGV4OiAwLFxuICAgICAgICBwb3NpdGlvbjogcmFuZ2UubWluLFxuICAgICAgICBwYW5lbDogdGhpcy5fZmluZE5lYXJlc3RQYW5lbChyYW5nZS5taW4sIHBhbmVscylcbiAgICAgIH0pXTtcbiAgICB9XG4gIH07XG4gIF9fcHJvdG8uZmluZEFuY2hvckluY2x1ZGVQb3NpdGlvbiA9IGZ1bmN0aW9uIChwb3NpdGlvbikge1xuICAgIHZhciBjYW1lcmEgPSB0aGlzLl9mbGlja2luZy5jYW1lcmE7XG4gICAgdmFyIHJhbmdlID0gY2FtZXJhLnJhbmdlO1xuICAgIHZhciBhbmNob3JzID0gY2FtZXJhLmFuY2hvclBvaW50cztcbiAgICBpZiAoYW5jaG9ycy5sZW5ndGggPD0gMCkgcmV0dXJuIG51bGw7XG4gICAgaWYgKHBvc2l0aW9uIDw9IHJhbmdlLm1pbikge1xuICAgICAgcmV0dXJuIGFuY2hvcnNbMF07XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA+PSByYW5nZS5tYXgpIHtcbiAgICAgIHJldHVybiBhbmNob3JzW2FuY2hvcnMubGVuZ3RoIC0gMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmZpbmRBbmNob3JJbmNsdWRlUG9zaXRpb24uY2FsbCh0aGlzLCBwb3NpdGlvbik7XG4gICAgfVxuICB9O1xuICBfX3Byb3RvLl9maW5kTmVhcmVzdFBhbmVsID0gZnVuY3Rpb24gKHBvcywgcGFuZWxzKSB7XG4gICAgdmFyIHByZXZEaXN0ID0gSW5maW5pdHk7XG4gICAgZm9yICh2YXIgcGFuZWxJZHggPSAwOyBwYW5lbElkeCA8IHBhbmVscy5sZW5ndGg7IHBhbmVsSWR4KyspIHtcbiAgICAgIHZhciBwYW5lbCA9IHBhbmVsc1twYW5lbElkeF07XG4gICAgICB2YXIgZGlzdCA9IE1hdGguYWJzKHBhbmVsLnBvc2l0aW9uIC0gcG9zKTtcbiAgICAgIGlmIChkaXN0ID4gcHJldkRpc3QpIHtcbiAgICAgICAgLy8gUmV0dXJuIHByZXZpb3VzIGFuY2hvclxuICAgICAgICByZXR1cm4gcGFuZWxzW3BhbmVsSWR4IC0gMV07XG4gICAgICB9XG4gICAgICBwcmV2RGlzdCA9IGRpc3Q7XG4gICAgfVxuICAgIC8vIFJldHVybiBsYXN0IGFuY2hvclxuICAgIHJldHVybiBwYW5lbHNbcGFuZWxzLmxlbmd0aCAtIDFdO1xuICB9O1xuICByZXR1cm4gQm91bmRDYW1lcmFNb2RlO1xufShDYW1lcmFNb2RlKTtcblxuLyoqXHJcbiAqIEEgY29tcG9uZW50IHRoYXQgbWFuYWdlcyBhY3R1YWwgbW92ZW1lbnQgaW5zaWRlIHRoZSB2aWV3cG9ydFxyXG4gKiBAa28g67ew7Y+s7Yq4IOuCtOyXkOyEnOydmCDsi6TsoJwg7JuA7KeB7J6E7J2EIOuLtOuLue2VmOuKlCDsu7Ttj6zrhIztirhcclxuICovXG52YXIgQ2FtZXJhID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqICovXG4gIGZ1bmN0aW9uIENhbWVyYShmbGlja2luZywgX2EpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHZhciBfYiA9IChfYSA9PT0gdm9pZCAwID8ge30gOiBfYSkuYWxpZ24sXG4gICAgICBhbGlnbiA9IF9iID09PSB2b2lkIDAgPyBBTElHTi5DRU5URVIgOiBfYjtcbiAgICB0aGlzLl9jaGVja1RyYW5zbGF0ZVN1cHBvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZV8xLCBfYTtcbiAgICAgIHZhciB0cmFuc2Zvcm1zID0gW1wid2Via2l0VHJhbnNmb3JtXCIsIFwibXNUcmFuc2Zvcm1cIiwgXCJNb3pUcmFuc2Zvcm1cIiwgXCJPVHJhbnNmb3JtXCIsIFwidHJhbnNmb3JtXCJdO1xuICAgICAgdmFyIHN1cHBvcnRlZFN0eWxlID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlO1xuICAgICAgdmFyIHRyYW5zZm9ybU5hbWUgPSBcIlwiO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgdHJhbnNmb3Jtc18xID0gX192YWx1ZXMkMSh0cmFuc2Zvcm1zKSwgdHJhbnNmb3Jtc18xXzEgPSB0cmFuc2Zvcm1zXzEubmV4dCgpOyAhdHJhbnNmb3Jtc18xXzEuZG9uZTsgdHJhbnNmb3Jtc18xXzEgPSB0cmFuc2Zvcm1zXzEubmV4dCgpKSB7XG4gICAgICAgICAgdmFyIHByZWZpeGVkVHJhbnNmb3JtID0gdHJhbnNmb3Jtc18xXzEudmFsdWU7XG4gICAgICAgICAgaWYgKHByZWZpeGVkVHJhbnNmb3JtIGluIHN1cHBvcnRlZFN0eWxlKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1OYW1lID0gcHJlZml4ZWRUcmFuc2Zvcm07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlXzFfMSkge1xuICAgICAgICBlXzEgPSB7XG4gICAgICAgICAgZXJyb3I6IGVfMV8xXG4gICAgICAgIH07XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICh0cmFuc2Zvcm1zXzFfMSAmJiAhdHJhbnNmb3Jtc18xXzEuZG9uZSAmJiAoX2EgPSB0cmFuc2Zvcm1zXzEucmV0dXJuKSkgX2EuY2FsbCh0cmFuc2Zvcm1zXzEpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCF0cmFuc2Zvcm1OYW1lKSB7XG4gICAgICAgIHRocm93IG5ldyBGbGlja2luZ0Vycm9yKE1FU1NBR0UuVFJBTlNGT1JNX05PVF9TVVBQT1JURUQsIENPREUuVFJBTlNGT1JNX05PVF9TVVBQT1JURUQpO1xuICAgICAgfVxuICAgICAgX3RoaXMuX3RyYW5zZm9ybSA9IHRyYW5zZm9ybU5hbWU7XG4gICAgfTtcbiAgICB0aGlzLl9mbGlja2luZyA9IGZsaWNraW5nO1xuICAgIHRoaXMuX3Jlc2V0SW50ZXJuYWxWYWx1ZXMoKTtcbiAgICAvLyBPcHRpb25zXG4gICAgdGhpcy5fYWxpZ24gPSBhbGlnbjtcbiAgfVxuICB2YXIgX19wcm90byA9IENhbWVyYS5wcm90b3R5cGU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcImVsZW1lbnRcIiwge1xuICAgIC8vIEludGVybmFsIHN0YXRlcyBnZXR0ZXJcbiAgICAvKipcclxuICAgICAqIFRoZSBjYW1lcmEgZWxlbWVudChgLmZsaWNraW5nLWNhbWVyYWApXHJcbiAgICAgKiBAa28g7Lm066mU6528IOyXmOumrOuovO2KuChgLmZsaWNraW5nLWNhbWVyYWApXHJcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2VsO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJjaGlsZHJlblwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBBbiBhcnJheSBvZiB0aGUgY2hpbGQgZWxlbWVudHMgb2YgdGhlIGNhbWVyYSBlbGVtZW50KGAuZmxpY2tpbmctY2FtZXJhYClcclxuICAgICAqIEBrbyDsubTrqZTrnbwg7JeY66as66i87Yq4KGAuZmxpY2tpbmctY2FtZXJhYCnsnZgg7J6Q7IudIOyXmOumrOuovO2KuCDrsLDsl7RcclxuICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudFtdfVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0b0FycmF5JDIodGhpcy5fZWwuY2hpbGRyZW4pO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJwb3NpdGlvblwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBDdXJyZW50IHBvc2l0aW9uIG9mIHRoZSBjYW1lcmFcclxuICAgICAqIEBrbyBDYW1lcmHsnZgg7ZiE7J6sIOyijO2RnFxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcG9zaXRpb247XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcImFsaWduUG9zaXRpb25cIiwge1xuICAgIC8qKlxyXG4gICAgICogQWxpZ24gcG9zaXRpb24gaW5zaWRlIHRoZSB2aWV3cG9ydCB3aGVyZSB7QGxpbmsgUGFuZWx9J3Mge0BsaW5rIFBhbmVsI2FsaWduUG9zaXRpb24gYWxpZ25Qb3NpdGlvbn0gc2hvdWxkIGJlIGxvY2F0ZWQgYXRcclxuICAgICAqIEBrbyDtjKjrhJDsnZgg7KCV66CsIOq4sOykgCDsnITsuZguIOu3sO2PrO2KuCDrgrTsl5DshJwge0BsaW5rIFBhbmVsfeydmCB7QGxpbmsgUGFuZWwjYWxpZ25Qb3NpdGlvbiBhbGlnblBvc2l0aW9ufeydtCDsnITsuZjtlbTslbwg7ZWY64qUIOqzs+yeheuLiOuLpFxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYWxpZ25Qb3M7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcIm9mZnNldFwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBQb3NpdGlvbiBvZmZzZXQsIHVzZWQgZm9yIHRoZSB7QGxpbmsgRmxpY2tpbmcjcmVuZGVyT25seVZpc2libGUgcmVuZGVyT25seVZpc2libGV9IG9wdGlvblxyXG4gICAgICogQGtvIENhbWVyYeydmCDsooztkZwg7Jik7ZSE7IWLLiB7QGxpbmsgRmxpY2tpbmcjcmVuZGVyT25seVZpc2libGUgcmVuZGVyT25seVZpc2libGV9IOyYteyFmOydhCDsnITtlbQg7IKs7Jqp65Cp64uI64ukLlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fb2Zmc2V0IC0gdGhpcy5fY2lyY3VsYXJPZmZzZXQ7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcImNpcmN1bGFyRW5hYmxlZFwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHRoZSBgY2lyY3VsYXJgIG9wdGlvbiBpcyBlbmFibGVkLlxyXG4gICAgICogVGhlIHtAbGluayBGbGlja2luZyNjaXJjdWxhciBjaXJjdWxhcn0gb3B0aW9uIGNhbid0IGJlIGVuYWJsZWQgd2hlbiBzdW0gb2YgdGhlIHBhbmVsIHNpemVzIGFyZSB0b28gc21hbGwuXHJcbiAgICAgKiBAa28ge0BsaW5rIEZsaWNraW5nI2NpcmN1bGFyIGNpcmN1bGFyfSDsmLXshZjsnbQg7Zmc7ISx7ZmU65CY7JeI64qU7KeAIOyXrOu2gOulvCDrgpjtg4DrgrTripQg66mk67KEIOuzgOyImC5cclxuICAgICAqIHtAbGluayBGbGlja2luZyNjaXJjdWxhciBjaXJjdWxhcn0g7Ji17IWY7J2AIO2MqOuEkOydmCDtgazquLDsnZgg7ZWp7J20IOy2qeu2hO2VmOyngCDslYrsnYQg6rK97JqwIOu5hO2ZnOyEse2ZlOuQqeuLiOuLpC5cclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICogQGRlZmF1bHQgZmFsc2VcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2lyY3VsYXJFbmFibGVkO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJtb2RlXCIsIHtcbiAgICAvKipcclxuICAgICAqIEEgY3VycmVudCBjYW1lcmEgbW9kZVxyXG4gICAgICogQHR5cGUge0NhbWVyYU1vZGV9XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX21vZGU7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcInJhbmdlXCIsIHtcbiAgICAvKipcclxuICAgICAqIEEgcmFuZ2UgdGhhdCBDYW1lcmEncyB7QGxpbmsgQ2FtZXJhI3Bvc2l0aW9uIHBvc2l0aW9ufSBjYW4gcmVhY2hcclxuICAgICAqIEBrbyBDYW1lcmHsnZgge0BsaW5rIENhbWVyYSNwb3NpdGlvbiBwb3NpdGlvbn3snbQg64+E64usIOqwgOuKpe2VnCDrspTsnIRcclxuICAgICAqIEB0eXBlIHtvYmplY3R9XHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbWluIEEgbWluaW11bSBwb3NpdGlvbjxrbz7stZzshowg7JyE7LmYPC9rbz5cclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtYXggQSBtYXhpbXVtIHBvc2l0aW9uPGtvPuy1nOuMgCDsnITsuZg8L2tvPlxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yYW5nZTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwicmFuZ2VEaWZmXCIsIHtcbiAgICAvKipcclxuICAgICAqIEEgZGlmZmVyZW5jZSBiZXR3ZWVuIENhbWVyYSdzIG1pbmltdW0gYW5kIG1heGltdW0gcG9zaXRpb24gdGhhdCBjYW4gcmVhY2hcclxuICAgICAqIEBrbyBDYW1lcmHqsIAg64+E64usIOqwgOuKpe2VnCDstZzshowv7LWc64yAIOyijO2RnOydmCDssKjsnbRcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3JhbmdlLm1heCAtIHRoaXMuX3JhbmdlLm1pbjtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwidmlzaWJsZVBhbmVsc1wiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBBbiBhcnJheSBvZiB2aXNpYmxlIHBhbmVscyBmcm9tIHRoZSBjdXJyZW50IHBvc2l0aW9uXHJcbiAgICAgKiBAa28g7ZiE7J6sIOuztOydtOuKlCDtjKjrhJDrk6TsnZgg67Cw7Je0XHJcbiAgICAgKiBAdHlwZSB7UGFuZWxbXX1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdmlzaWJsZVBhbmVscztcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwidmlzaWJsZVJhbmdlXCIsIHtcbiAgICAvKipcclxuICAgICAqIEEgcmFuZ2Ugb2YgdGhlIHZpc2libGUgYXJlYSBmcm9tIHRoZSBjdXJyZW50IHBvc2l0aW9uXHJcbiAgICAgKiBAa28g7ZiE7J6sIOychOy5mOyXkOyEnCDrs7TsnbTripQg67KU7JyEXHJcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG1pbiBBIG1pbmltdW0gcG9zaXRpb248a28+7LWc7IaMIOychOy5mDwva28+XHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbWluIEEgbWF4aW11bSBwb3NpdGlvbjxrbz7stZzrjIAg7JyE7LmYPC9rbz5cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtaW46IHRoaXMuX3Bvc2l0aW9uIC0gdGhpcy5fYWxpZ25Qb3MsXG4gICAgICAgIG1heDogdGhpcy5fcG9zaXRpb24gLSB0aGlzLl9hbGlnblBvcyArIHRoaXMuc2l6ZVxuICAgICAgfTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwiYW5jaG9yUG9pbnRzXCIsIHtcbiAgICAvKipcclxuICAgICAqIEFuIGFycmF5IG9mIHtAbGluayBBbmNob3JQb2ludH1zIHRoYXQgQ2FtZXJhIGNhbiBiZSBzdG9wcGVkIGF0XHJcbiAgICAgKiBAa28g7Lm066mU65286rCAIOuPhOuLrCDqsIDriqXtlZwge0BsaW5rIEFuY2hvclBvaW50feydmCDrqqnroZ1cclxuICAgICAqIEB0eXBlIHtBbmNob3JQb2ludFtdfVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9hbmNob3JzO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJjb250cm9sUGFyYW1zXCIsIHtcbiAgICAvKipcclxuICAgICAqIEEgY3VycmVudCBwYXJhbWV0ZXJzIG9mIHRoZSBDYW1lcmEgZm9yIHVwZGF0aW5nIHtAbGluayBBeGVzQ29udHJvbGxlcn1cclxuICAgICAqIEBrbyB7QGxpbmsgQXhlc0NvbnRyb2xsZXJ966W8IOyXheuNsOydtO2KuO2VmOq4sCDsnITtlZwg7ZiE7J6sIENhbWVyYSDtjKjrn6zrr7jthLDrk6RcclxuICAgICAqIEB0eXBlIHtDb250cm9sUGFyYW1zfVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJhbmdlOiB0aGlzLl9yYW5nZSxcbiAgICAgICAgcG9zaXRpb246IHRoaXMuX3Bvc2l0aW9uLFxuICAgICAgICBjaXJjdWxhcjogdGhpcy5fY2lyY3VsYXJFbmFibGVkXG4gICAgICB9O1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJhdEVkZ2VcIiwge1xuICAgIC8qKlxyXG4gICAgICogQSBCb29sZWFuIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciBDYW1lcmEncyBvdmVyIHRoZSBtaW5pbXVtIG9yIG1heGltdW0gcG9zaXRpb24gcmVhY2hhYmxlXHJcbiAgICAgKiBAa28g7ZiE7J6sIOy5tOuplOudvOqwgCDrj4Tri6wg6rCA64ql7ZWcIOuylOychOydmCDstZzshowg7Zi57J2AIOy1nOuMgOygkOydhCDrhJjslrTshLDripTsp4Drpbwg64KY7YOA64OF64uI64ukXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcG9zaXRpb24gPD0gdGhpcy5fcmFuZ2UubWluIHx8IHRoaXMuX3Bvc2l0aW9uID49IHRoaXMuX3JhbmdlLm1heDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwic2l6ZVwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdGhlIHNpemUgb2YgdGhlIHZpZXdwb3J0XHJcbiAgICAgKiBAa28g67ew7Y+s7Yq4IO2BrOq4sOulvCDrsJjtmZjtlanri4jri6RcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGZsaWNraW5nID0gdGhpcy5fZmxpY2tpbmc7XG4gICAgICByZXR1cm4gZmxpY2tpbmcgPyBmbGlja2luZy5ob3Jpem9udGFsID8gZmxpY2tpbmcudmlld3BvcnQud2lkdGggOiBmbGlja2luZy52aWV3cG9ydC5oZWlnaHQgOiAwO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJwcm9ncmVzc1wiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdGhlIGNhbWVyYSdzIHBvc2l0aW9uIHByb2dyZXNzIGZyb20gdGhlIGZpcnN0IHBhbmVsIHRvIGxhc3QgcGFuZWxcclxuICAgICAqIFJhbmdlIGlzIGZyb20gMCB0byBsYXN0IHBhbmVsJ3MgaW5kZXhcclxuICAgICAqIEBrbyDssqvrsojsp7gg7Yyo64SQ66Gc67aA7YSwIOuniOyngOuniSDtjKjrhJDquYzsp4DsnZgg7Lm066mU6528IOychOy5mOydmCDsp4Ttlonrj4Trpbwg67CY7ZmY7ZWp64uI64ukXHJcbiAgICAgKiDrspTsnITripQgMOu2gO2EsCDrp4jsp4Drp4kg7Yyo64SQ7J2YIOyduOuNseyKpOq5jOyngOyeheuLiOuLpFxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZmxpY2tpbmcgPSB0aGlzLl9mbGlja2luZztcbiAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMuX3Bvc2l0aW9uICsgdGhpcy5fb2Zmc2V0O1xuICAgICAgdmFyIG5lYXJlc3RBbmNob3IgPSB0aGlzLmZpbmROZWFyZXN0QW5jaG9yKHRoaXMuX3Bvc2l0aW9uKTtcbiAgICAgIGlmICghZmxpY2tpbmcgfHwgIW5lYXJlc3RBbmNob3IpIHtcbiAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgIH1cbiAgICAgIHZhciBuZWFyZXN0UGFuZWwgPSBuZWFyZXN0QW5jaG9yLnBhbmVsO1xuICAgICAgdmFyIHBhbmVsUG9zID0gbmVhcmVzdFBhbmVsLnBvc2l0aW9uICsgbmVhcmVzdFBhbmVsLm9mZnNldDtcbiAgICAgIHZhciBib3VuY2VTaXplID0gZmxpY2tpbmcuY29udHJvbC5jb250cm9sbGVyLmJvdW5jZTtcbiAgICAgIHZhciBfYSA9IHRoaXMucmFuZ2UsXG4gICAgICAgIHByZXZSYW5nZSA9IF9hLm1pbixcbiAgICAgICAgbmV4dFJhbmdlID0gX2EubWF4O1xuICAgICAgdmFyIHJhbmdlRGlmZiA9IHRoaXMucmFuZ2VEaWZmO1xuICAgICAgaWYgKHBvc2l0aW9uID09PSBwYW5lbFBvcykge1xuICAgICAgICByZXR1cm4gbmVhcmVzdFBhbmVsLmluZGV4O1xuICAgICAgfVxuICAgICAgaWYgKHBvc2l0aW9uIDwgcGFuZWxQb3MpIHtcbiAgICAgICAgdmFyIHByZXZQYW5lbCA9IG5lYXJlc3RQYW5lbC5wcmV2KCk7XG4gICAgICAgIHZhciBwcmV2UG9zaXRpb24gPSBwcmV2UGFuZWwgPyBwcmV2UGFuZWwucG9zaXRpb24gKyBwcmV2UGFuZWwub2Zmc2V0IDogcHJldlJhbmdlIC0gYm91bmNlU2l6ZVswXTtcbiAgICAgICAgLy8gTG9vcGVkXG4gICAgICAgIGlmIChwcmV2UG9zaXRpb24gPiBwYW5lbFBvcykge1xuICAgICAgICAgIHByZXZQb3NpdGlvbiAtPSByYW5nZURpZmY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5lYXJlc3RQYW5lbC5pbmRleCAtIDEgKyBnZXRQcm9ncmVzcyhwb3NpdGlvbiwgcHJldlBvc2l0aW9uLCBwYW5lbFBvcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbmV4dFBhbmVsID0gbmVhcmVzdFBhbmVsLm5leHQoKTtcbiAgICAgICAgdmFyIG5leHRQb3NpdGlvbiA9IG5leHRQYW5lbCA/IG5leHRQYW5lbC5wb3NpdGlvbiArIG5leHRQYW5lbC5vZmZzZXQgOiBuZXh0UmFuZ2UgKyBib3VuY2VTaXplWzFdO1xuICAgICAgICAvLyBMb29wZWRcbiAgICAgICAgaWYgKG5leHRQb3NpdGlvbiA8IHBhbmVsUG9zKSB7XG4gICAgICAgICAgbmV4dFBvc2l0aW9uICs9IHJhbmdlRGlmZjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmVhcmVzdFBhbmVsLmluZGV4ICsgZ2V0UHJvZ3Jlc3MocG9zaXRpb24sIHBhbmVsUG9zLCBuZXh0UG9zaXRpb24pO1xuICAgICAgfVxuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJwYW5lbE9yZGVyXCIsIHtcbiAgICAvKipcclxuICAgICAqIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvZGlyZWN0aW9uIGRpcmVjdGlvbn0gQ1NTIHByb3BlcnR5IGFwcGxpZWQgdG8gdGhlIGNhbWVyYSBlbGVtZW50KGAuZmxpY2tpbmctY2FtZXJhYClcclxuICAgICAqIEBrbyDsubTrqZTrnbwg7JeY66as66i87Yq4KGAuZmxpY2tpbmctY2FtZXJhYCnsl5Ag7KCB7Jqp65CcIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvZGlyZWN0aW9uIGRpcmVjdGlvbn0gQ1NTIOyGjeyEsVxyXG4gICAgICogQHR5cGUge3N0cmluZ31cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcGFuZWxPcmRlcjtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwiYWxpZ25cIiwge1xuICAgIC8vIE9wdGlvbnMgR2V0dGVyXG4gICAgLyoqXHJcbiAgICAgKiBBIHZhbHVlIGluZGljYXRpbmcgd2hlcmUgdGhlIHtAbGluayBDYW1lcmEjYWxpZ25Qb3NpdGlvbiBhbGlnblBvc2l0aW9ufSBzaG91bGQgYmUgbG9jYXRlZCBhdCBpbnNpZGUgdGhlIHZpZXdwb3J0IGVsZW1lbnRcclxuICAgICAqIEBrbyB7QGxpbmsgQ2FtZXJhI2FsaWduUG9zaXRpb24gYWxpZ25Qb3NpdGlvbn3snbQg67ew7Y+s7Yq4IOyXmOumrOuovO2KuCDrgrTsnZgg7Ja065SU7JeQIOychOy5mO2VtOyVvCDtlZjripTsp4Drpbwg64KY7YOA64K064qUIOqwklxyXG4gICAgICogQHR5cGUge0FMSUdOIHwgc3RyaW5nIHwgbnVtYmVyfVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYWxpZ247XG4gICAgfSxcbiAgICAvLyBPcHRpb25zIFNldHRlclxuICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgdGhpcy5fYWxpZ24gPSB2YWw7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIC8qKlxyXG4gICAqIEluaXRpYWxpemUgQ2FtZXJhXHJcbiAgICogQGtvIENhbWVyYeulvCDstIjquLDtmZTtlanri4jri6RcclxuICAgKiBAdGhyb3dzIHtGbGlja2luZ0Vycm9yfVxyXG4gICAqIHtAbGluayBFUlJPUl9DT0RFIFZBTF9NVVNUX05PVF9OVUxMfSBJZiB0aGUgY2FtZXJhIGVsZW1lbnQoYC5mbGlja2luZy1jYW1lcmFgKSBkb2VzIG5vdCBleGlzdCBpbnNpZGUgdmlld3BvcnQgZWxlbWVudFxyXG4gICAqIDxrbz57QGxpbmsgRVJST1JfQ09ERSBWQUxfTVVTVF9OT1RfTlVMTH0g67ew7Y+s7Yq4IOyXmOumrOuovO2KuCDrgrTrtoDsl5Ag7Lm066mU6528IOyXmOumrOuovO2KuChgLmZsaWNraW5nLWNhbWVyYWAp6rCAIOyhtOyerO2VmOyngCDslYrsnYQg6rK97JqwPC9rbz5cclxuICAgKiBAcmV0dXJuIHt0aGlzfVxyXG4gICAqL1xuICBfX3Byb3RvLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZpZXdwb3J0RWwgPSB0aGlzLl9mbGlja2luZy52aWV3cG9ydC5lbGVtZW50O1xuICAgIGNoZWNrRXhpc3RlbmNlKHZpZXdwb3J0RWwuZmlyc3RFbGVtZW50Q2hpbGQsIFwiRmlyc3QgZWxlbWVudCBjaGlsZCBvZiB0aGUgdmlld3BvcnQgZWxlbWVudFwiKTtcbiAgICB0aGlzLl9lbCA9IHZpZXdwb3J0RWwuZmlyc3RFbGVtZW50Q2hpbGQ7XG4gICAgdGhpcy5fY2hlY2tUcmFuc2xhdGVTdXBwb3J0KCk7XG4gICAgdGhpcy5fdXBkYXRlTW9kZSgpO1xuICAgIHRoaXMudXBkYXRlUGFuZWxPcmRlcigpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcclxuICAgKiBEZXN0cm95IENhbWVyYSBhbmQgcmV0dXJuIHRvIGluaXRpYWwgc3RhdGVcclxuICAgKiBAa28gQ2FtZXJh66W8IOy0iOq4sCDsg4Htg5zroZwg65CY64+M66a964uI64ukXHJcbiAgICogQHJldHVybiB7dm9pZH1cclxuICAgKi9cbiAgX19wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3Jlc2V0SW50ZXJuYWxWYWx1ZXMoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXHJcbiAgICogTW92ZSB0byB0aGUgZ2l2ZW4gcG9zaXRpb24gYW5kIGFwcGx5IENTUyB0cmFuc2Zvcm1cclxuICAgKiBAa28g7ZW064u5IOyijO2RnOuhnCDsnbTrj5ntlZjqs6AsIENTUyB0cmFuc2Zvcm3snYQg7KCB7Jqp7ZWp64uI64ukXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHBvcyBBIG5ldyBwb3NpdGlvbjxrbz7sm4Dsp4Hsnbwg7JyE7LmYPC9rbz5cclxuICAgKiBAdGhyb3dzIHtGbGlja2luZ0Vycm9yfVxyXG4gICAqIHtAbGluayBFUlJPUl9DT0RFIE5PVF9BVFRBQ0hFRF9UT19GTElDS0lOR30gV2hlbiB7QGxpbmsgQ2FtZXJhI2luaXQgaW5pdH0gaXMgbm90IGNhbGxlZCBiZWZvcmVcclxuICAgKiA8a28+e0BsaW5rIEVSUk9SX0NPREUgTk9UX0FUVEFDSEVEX1RPX0ZMSUNLSU5HfSB7QGxpbmsgQ2FtZXJhI2luaXQgaW5pdH3snbQg7J207KCE7JeQIO2YuOy2nOuQmOyngCDslYrsnYAg6rK97JqwPC9rbz5cclxuICAgKiBAcmV0dXJuIHt0aGlzfVxyXG4gICAqL1xuICBfX3Byb3RvLmxvb2tBdCA9IGZ1bmN0aW9uIChwb3MpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHZhciBmbGlja2luZyA9IGdldEZsaWNraW5nQXR0YWNoZWQodGhpcy5fZmxpY2tpbmcpO1xuICAgIHZhciBwcmV2UG9zID0gdGhpcy5fcG9zaXRpb247XG4gICAgdGhpcy5fcG9zaXRpb24gPSBwb3M7XG4gICAgdmFyIHRvZ2dsZWQgPSB0aGlzLl90b2dnbGVQYW5lbHMocHJldlBvcywgcG9zKTtcbiAgICB0aGlzLl9yZWZyZXNoVmlzaWJsZVBhbmVscygpO1xuICAgIHRoaXMuX2NoZWNrTmVlZFBhbmVsKCk7XG4gICAgdGhpcy5fY2hlY2tSZWFjaEVuZChwcmV2UG9zLCBwb3MpO1xuICAgIGlmICh0b2dnbGVkKSB7XG4gICAgICB2b2lkIGZsaWNraW5nLnJlbmRlcmVyLnJlbmRlcigpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy51cGRhdGVPZmZzZXQoKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFwcGx5VHJhbnNmb3JtKCk7XG4gICAgfVxuICB9O1xuICAvKipcclxuICAgKiBSZXR1cm4gYSBwcmV2aW91cyB7QGxpbmsgQW5jaG9yUG9pbnR9IG9mIGdpdmVuIHtAbGluayBBbmNob3JQb2ludH1cclxuICAgKiBJZiBpdCBkb2VzIG5vdCBleGlzdCwgcmV0dXJuIGBudWxsYCBpbnN0ZWFkXHJcbiAgICogQGtvIOyjvOyWtOynhCB7QGxpbmsgQW5jaG9yUG9pbnR97J2YIOydtOyghCB7QGxpbmsgQW5jaG9yUG9pbnR966W8IOuwmO2ZmO2VqeuLiOuLpFxyXG4gICAqIOyhtOyerO2VmOyngCDslYrsnYQg6rK97JqwIGBudWxsYOydhCDrsJjtmZjtlanri4jri6RcclxuICAgKiBAcGFyYW0ge0FuY2hvclBvaW50fSBhbmNob3IgQSByZWZlcmVuY2Uge0BsaW5rIEFuY2hvclBvaW50fTxrbz7quLDspIAge0BsaW5rIEFuY2hvclBvaW50fTwva28+XHJcbiAgICogQHJldHVybiB7QW5jaG9yUG9pbnQgfCBudWxsfSBUaGUgcHJldmlvdXMge0BsaW5rIEFuY2hvclBvaW50fTxrbz7snbTsoIQge0BsaW5rIEFuY2hvclBvaW50fTwva28+XHJcbiAgICovXG4gIF9fcHJvdG8uZ2V0UHJldkFuY2hvciA9IGZ1bmN0aW9uIChhbmNob3IpIHtcbiAgICBpZiAoIXRoaXMuX2NpcmN1bGFyRW5hYmxlZCB8fCBhbmNob3IuaW5kZXggIT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzLl9hbmNob3JzW2FuY2hvci5pbmRleCAtIDFdIHx8IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhbmNob3JzID0gdGhpcy5fYW5jaG9ycztcbiAgICAgIHZhciByYW5nZURpZmYgPSB0aGlzLnJhbmdlRGlmZjtcbiAgICAgIHZhciBsYXN0QW5jaG9yID0gYW5jaG9yc1thbmNob3JzLmxlbmd0aCAtIDFdO1xuICAgICAgcmV0dXJuIG5ldyBBbmNob3JQb2ludCh7XG4gICAgICAgIGluZGV4OiBsYXN0QW5jaG9yLmluZGV4LFxuICAgICAgICBwb3NpdGlvbjogbGFzdEFuY2hvci5wb3NpdGlvbiAtIHJhbmdlRGlmZixcbiAgICAgICAgcGFuZWw6IGxhc3RBbmNob3IucGFuZWxcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgLyoqXHJcbiAgICogUmV0dXJuIGEgbmV4dCB7QGxpbmsgQW5jaG9yUG9pbnR9IG9mIGdpdmVuIHtAbGluayBBbmNob3JQb2ludH1cclxuICAgKiBJZiBpdCBkb2VzIG5vdCBleGlzdCwgcmV0dXJuIGBudWxsYCBpbnN0ZWFkXHJcbiAgICogQGtvIOyjvOyWtOynhCB7QGxpbmsgQW5jaG9yUG9pbnR97J2YIOuLpOydjCB7QGxpbmsgQW5jaG9yUG9pbnR966W8IOuwmO2ZmO2VqeuLiOuLpFxyXG4gICAqIOyhtOyerO2VmOyngCDslYrsnYQg6rK97JqwIGBudWxsYOydhCDrsJjtmZjtlanri4jri6RcclxuICAgKiBAcGFyYW0ge0FuY2hvclBvaW50fSBhbmNob3IgQSByZWZlcmVuY2Uge0BsaW5rIEFuY2hvclBvaW50fTxrbz7quLDspIAge0BsaW5rIEFuY2hvclBvaW50fTwva28+XHJcbiAgICogQHJldHVybiB7QW5jaG9yUG9pbnQgfCBudWxsfSBUaGUgbmV4dCB7QGxpbmsgQW5jaG9yUG9pbnR9PGtvPuuLpOydjCB7QGxpbmsgQW5jaG9yUG9pbnR9PC9rbz5cclxuICAgKi9cbiAgX19wcm90by5nZXROZXh0QW5jaG9yID0gZnVuY3Rpb24gKGFuY2hvcikge1xuICAgIHZhciBhbmNob3JzID0gdGhpcy5fYW5jaG9ycztcbiAgICBpZiAoIXRoaXMuX2NpcmN1bGFyRW5hYmxlZCB8fCBhbmNob3IuaW5kZXggIT09IGFuY2hvcnMubGVuZ3RoIC0gMSkge1xuICAgICAgcmV0dXJuIGFuY2hvcnNbYW5jaG9yLmluZGV4ICsgMV0gfHwgbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHJhbmdlRGlmZiA9IHRoaXMucmFuZ2VEaWZmO1xuICAgICAgdmFyIGZpcnN0QW5jaG9yID0gYW5jaG9yc1swXTtcbiAgICAgIHJldHVybiBuZXcgQW5jaG9yUG9pbnQoe1xuICAgICAgICBpbmRleDogZmlyc3RBbmNob3IuaW5kZXgsXG4gICAgICAgIHBvc2l0aW9uOiBmaXJzdEFuY2hvci5wb3NpdGlvbiArIHJhbmdlRGlmZixcbiAgICAgICAgcGFuZWw6IGZpcnN0QW5jaG9yLnBhbmVsXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIC8qKlxyXG4gICAqIFJldHVybiB0aGUgY2FtZXJhJ3MgcG9zaXRpb24gcHJvZ3Jlc3MgaW4gdGhlIHBhbmVsIGJlbG93XHJcbiAgICogVmFsdWUgaXMgZnJvbSAwIHRvIDEgd2hlbiB0aGUgY2FtZXJhJ3MgaW5zaWRlIHBhbmVsXHJcbiAgICogVmFsdWUgY2FuIGJlIGxvd2VyIHRoYW4gMCBvciBiaWdnZXIgdGhhbiAxIHdoZW4gaXQncyBpbiB0aGUgbWFyZ2luIGFyZWFcclxuICAgKiBAa28g7ZiE7J6sIOy5tOuplOudvCDslYTrnpgg7Yyo64SQ7JeQ7ISc7J2YIOychOy5mCDsp4Ttlonrj4Trpbwg67CY7ZmY7ZWp64uI64ukXHJcbiAgICog67CY7ZmY6rCS7J2AIOy5tOuplOudvOqwgCDtjKjrhJAg64K067aA7JeQIOyeiOydhCDqsr3smrAgMOu2gO2EsCAx6rmM7KeA7J2YIOqwkuydhCDqsJbsirXri4jri6RcclxuICAgKiDtjKjrhJDsnZggbWFyZ2luIOyYgeyXreyXkCDsnojsnYQg6rK97JqwIDDrs7Tri6Qg7J6R6rGw64KYIDHrs7Tri6Qg7YGwIOqwkuydhCDrsJjtmZjtlaAg7IiYIOyeiOyKteuLiOuLpFxyXG4gICAqL1xuICBfX3Byb3RvLmdldFByb2dyZXNzSW5QYW5lbCA9IGZ1bmN0aW9uIChwYW5lbCkge1xuICAgIHZhciBwYW5lbFJhbmdlID0gcGFuZWwucmFuZ2U7XG4gICAgcmV0dXJuICh0aGlzLl9wb3NpdGlvbiAtIHBhbmVsUmFuZ2UubWluKSAvIChwYW5lbFJhbmdlLm1heCAtIHBhbmVsUmFuZ2UubWluKTtcbiAgfTtcbiAgLyoqXHJcbiAgICogUmV0dXJuIHtAbGluayBBbmNob3JQb2ludH0gdGhhdCBpbmNsdWRlcyBnaXZlbiBwb3NpdGlvblxyXG4gICAqIElmIHRoZXJlJ3Mgbm8ge0BsaW5rIEFuY2hvclBvaW50fSB0aGF0IGluY2x1ZGVzIHRoZSBnaXZlbiBwb3NpdGlvbiwgcmV0dXJuIGBudWxsYCBpbnN0ZWFkXHJcbiAgICogQGtvIOyjvOyWtOynhCDsooztkZzrpbwg7Y+s7ZWo7ZWY64qUIHtAbGluayBBbmNob3JQb2ludH3rpbwg67CY7ZmY7ZWp64uI64ukXHJcbiAgICog7KO87Ja07KeEIOyijO2RnOulvCDtj6ztlajtlZjripQge0BsaW5rIEFuY2hvclBvaW50feqwgCDsl4bsnYQg6rK97JqwIGBudWxsYOydhCDrsJjtmZjtlanri4jri6RcclxuICAgKiBAcGFyYW0ge251bWJlcn0gcG9zaXRpb24gQSBwb3NpdGlvbiB0byBjaGVjazxrbz7tmZXsnbjtlaAg7KKM7ZGcPC9rbz5cclxuICAgKiBAcmV0dXJuIHtBbmNob3JQb2ludCB8IG51bGx9IFRoZSB7QGxpbmsgQW5jaG9yUG9pbnR9IHRoYXQgaW5jbHVkZXMgdGhlIGdpdmVuIHBvc2l0aW9uPGtvPu2VtOuLuSDsooztkZzrpbwg7Y+s7ZWo7ZWY64qUIHtAbGluayBBbmNob3JQb2ludH08L2tvPlxyXG4gICAqL1xuICBfX3Byb3RvLmZpbmRBbmNob3JJbmNsdWRlUG9zaXRpb24gPSBmdW5jdGlvbiAocG9zaXRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5fbW9kZS5maW5kQW5jaG9ySW5jbHVkZVBvc2l0aW9uKHBvc2l0aW9uKTtcbiAgfTtcbiAgLyoqXHJcbiAgICogUmV0dXJuIHtAbGluayBBbmNob3JQb2ludH0gbmVhcmVzdCB0byBnaXZlbiBwb3NpdGlvblxyXG4gICAqIElmIHRoZXJlJ3JlIG5vIHtAbGluayBBbmNob3JQb2ludH1zLCByZXR1cm4gYG51bGxgIGluc3RlYWRcclxuICAgKiBAa28g7ZW064u5IOyijO2RnOyXkOyEnCDqsIDsnqUg6rCA6rmM7Jq0IHtAbGluayBBbmNob3JQb2ludH3rpbwg67CY7ZmY7ZWp64uI64ukXHJcbiAgICoge0BsaW5rIEFuY2hvclBvaW50feqwgCDtlZjrgpjrj4Qg7JeG7J2EIOqyveyasCBgbnVsbGDsnYQg67CY7ZmY7ZWp64uI64ukXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHBvc2l0aW9uIEEgcG9zaXRpb24gdG8gY2hlY2s8a28+7ZmV7J247ZWgIOyijO2RnDwva28+XHJcbiAgICogQHJldHVybiB7QW5jaG9yUG9pbnQgfCBudWxsfSBUaGUge0BsaW5rIEFuY2hvclBvaW50fSBuZWFyZXN0IHRvIHRoZSBnaXZlbiBwb3NpdGlvbjxrbz7tlbTri7kg7KKM7ZGc7JeQIOqwgOyepSDsnbjsoJHtlZwge0BsaW5rIEFuY2hvclBvaW50fTwva28+XHJcbiAgICovXG4gIF9fcHJvdG8uZmluZE5lYXJlc3RBbmNob3IgPSBmdW5jdGlvbiAocG9zaXRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5fbW9kZS5maW5kTmVhcmVzdEFuY2hvcihwb3NpdGlvbik7XG4gIH07XG4gIC8qKlxyXG4gICAqIFJldHVybiB7QGxpbmsgQW5jaG9yUG9pbnR9IHRoYXQgbWF0Y2hlcyB7QGxpbmsgRmxpY2tpbmcjY3VycmVudFBhbmVsfVxyXG4gICAqIEBrbyDtmITsnqwge0BsaW5rIEZsaWNraW5nI2N1cnJlbnRQYW5lbH3sl5Ag7ZW064u57ZWY64qUIHtAbGluayBBbmNob3JQb2ludH3rpbwg67CY7ZmY7ZWp64uI64ukXHJcbiAgICogQHJldHVybiB7QW5jaG9yUG9pbnQgfCBudWxsfVxyXG4gICAqL1xuICBfX3Byb3RvLmZpbmRBY3RpdmVBbmNob3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9hO1xuICAgIHZhciBmbGlja2luZyA9IGdldEZsaWNraW5nQXR0YWNoZWQodGhpcy5fZmxpY2tpbmcpO1xuICAgIHZhciBhY3RpdmVQYW5lbCA9IGZsaWNraW5nLmNvbnRyb2wuYWN0aXZlUGFuZWw7XG4gICAgaWYgKCFhY3RpdmVQYW5lbCkgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIChfYSA9IGZpbmQkMSh0aGlzLl9hbmNob3JzLCBmdW5jdGlvbiAoYW5jaG9yKSB7XG4gICAgICByZXR1cm4gYW5jaG9yLnBhbmVsLmluZGV4ID09PSBhY3RpdmVQYW5lbC5pbmRleDtcbiAgICB9KSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdGhpcy5maW5kTmVhcmVzdEFuY2hvcihhY3RpdmVQYW5lbC5wb3NpdGlvbik7XG4gIH07XG4gIC8qKlxyXG4gICAqIENsYW1wIHRoZSBnaXZlbiBwb3NpdGlvbiBiZXR3ZWVuIGNhbWVyYSdzIHJhbmdlXHJcbiAgICogQGtvIOyjvOyWtOynhCDsooztkZzrpbwgQ2FtZXJh6rCAIOuPhOuLrCDqsIDriqXtlZwg67KU7JyEIOyCrOydtOydmCDqsJLsnLzroZwg66eM65Ot64uI64ukXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHBvc2l0aW9uIEEgcG9zaXRpb24gdG8gY2xhbXA8a28+67KU7JyE66W8IOygnO2VnO2VoCDsooztkZw8L2tvPlxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gQSBjbGFtcGVkIHBvc2l0aW9uPGtvPuuylOychCDsoJztlZzrkJwg7KKM7ZGcPC9rbz5cclxuICAgKi9cbiAgX19wcm90by5jbGFtcFRvUmVhY2hhYmxlUG9zaXRpb24gPSBmdW5jdGlvbiAocG9zaXRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5fbW9kZS5jbGFtcFRvUmVhY2hhYmxlUG9zaXRpb24ocG9zaXRpb24pO1xuICB9O1xuICAvKipcclxuICAgKiBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiBwYW5lbCBpcyBpbnNpZGUgb2YgdGhlIENhbWVyYSdzIHJhbmdlXHJcbiAgICogQGtvIO2VtOuLuSB7QGxpbmsgUGFuZWx97J20IENhbWVyYeqwgCDrj4Tri6wg6rCA64ql7ZWcIOuylOychCDrgrTsl5Ag7J6I64qU7KeA66W8IOuwmO2ZmO2VqeuLiOuLpFxyXG4gICAqIEBwYXJhbSBwYW5lbCBBbiBpbnN0YW5jZSBvZiB7QGxpbmsgUGFuZWx9IHRvIGNoZWNrPGtvPu2ZleyduO2VoCB7QGxpbmsgUGFuZWx97J2YIOyduOyKpO2EtOyKpDwva28+XHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgcGFuZWwncyBpbnNpZGUgQ2FtZXJhJ3MgcmFuZ2U8a28+64+E64usIOqwgOuKpe2VnCDrspTsnIQg64K07JeQIO2VtOuLuSDtjKjrhJDsnbQg7KG07J6s7ZWY64qU7KeAIOyXrOu2gDwva28+XHJcbiAgICovXG4gIF9fcHJvdG8uY2FuUmVhY2ggPSBmdW5jdGlvbiAocGFuZWwpIHtcbiAgICByZXR1cm4gdGhpcy5fbW9kZS5jYW5SZWFjaChwYW5lbCk7XG4gIH07XG4gIC8qKlxyXG4gICAqIENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHBhbmVsIGVsZW1lbnQgaXMgdmlzaWJsZSBhdCB0aGUgY3VycmVudCBwb3NpdGlvblxyXG4gICAqIEBrbyDtmITsnqwg7KKM7ZGc7JeQ7IScIO2VtOuLuSDtjKjrhJAg7JeY66as66i87Yq466W8IOuzvCDsiJgg7J6I64qU7KeAIOyXrOu2gOulvCDrsJjtmZjtlanri4jri6RcclxuICAgKiBAcGFyYW0gcGFuZWwgQW4gaW5zdGFuY2Ugb2Yge0BsaW5rIFBhbmVsfSB0byBjaGVjazxrbz7tmZXsnbjtlaAge0BsaW5rIFBhbmVsfeydmCDsnbjsiqTthLTsiqQ8L2tvPlxyXG4gICAqIEByZXR1cm4gV2hldGhlciB0aGUgcGFuZWwgZWxlbWVudCBpcyB2aXNpYmxlIGF0IHRoZSBjdXJyZW50IHBvc2l0aW9uPGtvPu2YhOyerCDsnITsuZjsl5DshJwg7ZW064u5IO2MqOuEkCDsl5jrpqzrqLztirjqsIAg67O07J2064qU7KeAIOyXrOu2gDwva28+XHJcbiAgICovXG4gIF9fcHJvdG8uY2FuU2VlID0gZnVuY3Rpb24gKHBhbmVsKSB7XG4gICAgcmV0dXJuIHRoaXMuX21vZGUuY2FuU2VlKHBhbmVsKTtcbiAgfTtcbiAgLyoqXHJcbiAgICogVXBkYXRlIHtAbGluayBDYW1lcmEjcmFuZ2UgcmFuZ2V9IG9mIENhbWVyYVxyXG4gICAqIEBrbyBDYW1lcmHsnZgge0BsaW5rIENhbWVyYSNyYW5nZSByYW5nZX3rpbwg7JeF642w7J207Yq47ZWp64uI64ukXHJcbiAgICogQG1ldGhvZFxyXG4gICAqIEBhYnN0cmFjdFxyXG4gICAqIEBtZW1iZXJvZiBDYW1lcmFcclxuICAgKiBAaW5zdGFuY2VcclxuICAgKiBAbmFtZSB1cGRhdGVSYW5nZVxyXG4gICAqIEBjaGFpbmFibGVcclxuICAgKiBAdGhyb3dzIHtGbGlja2luZ0Vycm9yfVxyXG4gICAqIHtAbGluayBFUlJPUl9DT0RFIE5PVF9BVFRBQ0hFRF9UT19GTElDS0lOR30gV2hlbiB7QGxpbmsgQ2FtZXJhI2luaXQgaW5pdH0gaXMgbm90IGNhbGxlZCBiZWZvcmVcclxuICAgKiA8a28+e0BsaW5rIEVSUk9SX0NPREUgTk9UX0FUVEFDSEVEX1RPX0ZMSUNLSU5HfSB7QGxpbmsgQ2FtZXJhI2luaXQgaW5pdH3snbQg7J207KCE7JeQIO2YuOy2nOuQmOyngCDslYrsnYAg6rK97JqwPC9rbz5cclxuICAgKiBAcmV0dXJuIHt0aGlzfVxyXG4gICAqL1xuICBfX3Byb3RvLnVwZGF0ZVJhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBmbGlja2luZyA9IGdldEZsaWNraW5nQXR0YWNoZWQodGhpcy5fZmxpY2tpbmcpO1xuICAgIHZhciByZW5kZXJlciA9IGZsaWNraW5nLnJlbmRlcmVyO1xuICAgIHZhciBwYW5lbHMgPSByZW5kZXJlci5wYW5lbHM7XG4gICAgdGhpcy5fdXBkYXRlTW9kZSgpO1xuICAgIHRoaXMuX3JhbmdlID0gdGhpcy5fbW9kZS5nZXRSYW5nZSgpO1xuICAgIHBhbmVscy5mb3JFYWNoKGZ1bmN0aW9uIChwYW5lbCkge1xuICAgICAgcmV0dXJuIHBhbmVsLnVwZGF0ZUNpcmN1bGFyVG9nZ2xlRGlyZWN0aW9uKCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxyXG4gICAqIFVwZGF0ZSBDYW1lcmEncyB7QGxpbmsgQ2FtZXJhI2FsaWduUG9zaXRpb24gYWxpZ25Qb3NpdGlvbn1cclxuICAgKiBAa28gQ2FtZXJh7J2YIHtAbGluayBDYW1lcmEjYWxpZ25Qb3NpdGlvbiBhbGlnblBvc2l0aW9ufeydhCDsl4XrjbDsnbTtirjtlanri4jri6RcclxuICAgKiBAY2hhaW5hYmxlXHJcbiAgICogQHJldHVybiB7dGhpc31cclxuICAgKi9cbiAgX19wcm90by51cGRhdGVBbGlnblBvcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYWxpZ24gPSB0aGlzLl9hbGlnbjtcbiAgICB2YXIgYWxpZ25WYWwgPSB0eXBlb2YgYWxpZ24gPT09IFwib2JqZWN0XCIgPyBhbGlnbi5jYW1lcmEgOiBhbGlnbjtcbiAgICB0aGlzLl9hbGlnblBvcyA9IHBhcnNlQWxpZ24kMShhbGlnblZhbCwgdGhpcy5zaXplKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXHJcbiAgICogVXBkYXRlIENhbWVyYSdzIHtAbGluayBDYW1lcmEjYW5jaG9yUG9pbnRzIGFuY2hvclBvaW50c31cclxuICAgKiBAa28gQ2FtZXJh7J2YIHtAbGluayBDYW1lcmEjYW5jaG9yUG9pbnRzIGFuY2hvclBvaW50c33rpbwg7JeF642w7J207Yq47ZWp64uI64ukXHJcbiAgICogQHRocm93cyB7RmxpY2tpbmdFcnJvcn1cclxuICAgKiB7QGxpbmsgRVJST1JfQ09ERSBOT1RfQVRUQUNIRURfVE9fRkxJQ0tJTkd9IFdoZW4ge0BsaW5rIENhbWVyYSNpbml0IGluaXR9IGlzIG5vdCBjYWxsZWQgYmVmb3JlXHJcbiAgICogPGtvPntAbGluayBFUlJPUl9DT0RFIE5PVF9BVFRBQ0hFRF9UT19GTElDS0lOR30ge0BsaW5rIENhbWVyYSNpbml0IGluaXR97J20IOydtOyghOyXkCDtmLjstpzrkJjsp4Ag7JWK7J2AIOqyveyasDwva28+XHJcbiAgICogQGNoYWluYWJsZVxyXG4gICAqIEByZXR1cm4ge3RoaXN9XHJcbiAgICovXG4gIF9fcHJvdG8udXBkYXRlQW5jaG9ycyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9hbmNob3JzID0gdGhpcy5fbW9kZS5nZXRBbmNob3JzKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxyXG4gICAqIFVwZGF0ZSBWaWV3cG9ydCdzIGhlaWdodCB0byBhY3RpdmUgcGFuZWwncyBoZWlnaHRcclxuICAgKiBAa28g7ZiE7J6sIOyEoO2DneuQnCDtjKjrhJDsnZgg64aS7J207JmAIOuPmeydvO2VmOuPhOuhnSDrt7Dtj6ztirjsnZgg64aS7J2066W8IOyXheuNsOydtO2KuO2VqeuLiOuLpFxyXG4gICAqIEB0aHJvd3Mge0ZsaWNraW5nRXJyb3J9XHJcbiAgICoge0BsaW5rIEVSUk9SX0NPREUgTk9UX0FUVEFDSEVEX1RPX0ZMSUNLSU5HfSBXaGVuIHtAbGluayBDYW1lcmEjaW5pdCBpbml0fSBpcyBub3QgY2FsbGVkIGJlZm9yZVxyXG4gICAqIDxrbz57QGxpbmsgRVJST1JfQ09ERSBOT1RfQVRUQUNIRURfVE9fRkxJQ0tJTkd9IHtAbGluayBDYW1lcmEjaW5pdCBpbml0feydtCDsnbTsoITsl5Ag7Zi47Lac65CY7KeAIOyViuydgCDqsr3smrA8L2tvPlxyXG4gICAqIEBjaGFpbmFibGVcclxuICAgKiBAcmV0dXJuIHt0aGlzfVxyXG4gICAqL1xuICBfX3Byb3RvLnVwZGF0ZUFkYXB0aXZlSGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBmbGlja2luZyA9IGdldEZsaWNraW5nQXR0YWNoZWQodGhpcy5fZmxpY2tpbmcpO1xuICAgIHZhciBhY3RpdmVQYW5lbCA9IGZsaWNraW5nLmNvbnRyb2wuYWN0aXZlUGFuZWw7XG4gICAgaWYgKCFmbGlja2luZy5ob3Jpem9udGFsIHx8ICFmbGlja2luZy5hZGFwdGl2ZSB8fCAhYWN0aXZlUGFuZWwpIHJldHVybjtcbiAgICBmbGlja2luZy52aWV3cG9ydC5zZXRTaXplKHtcbiAgICAgIGhlaWdodDogYWN0aXZlUGFuZWwuaGVpZ2h0XG4gICAgfSk7XG4gIH07XG4gIC8qKlxyXG4gICAqIFVwZGF0ZSBjdXJyZW50IG9mZnNldCBvZiB0aGUgY2FtZXJhXHJcbiAgICogQGtvIO2YhOyerCDsubTrqZTrnbzsnZgg7Jik7ZSE7IWL7J2EIOyXheuNsOydtO2KuO2VqeuLiOuLpFxyXG4gICAqIEBjaGFpbmFibGVcclxuICAgKiBAcmV0dXJuIHt0aGlzfVxyXG4gICAqL1xuICBfX3Byb3RvLnVwZGF0ZU9mZnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZmxpY2tpbmcgPSBnZXRGbGlja2luZ0F0dGFjaGVkKHRoaXMuX2ZsaWNraW5nKTtcbiAgICB2YXIgcG9zaXRpb24gPSB0aGlzLl9wb3NpdGlvbjtcbiAgICB2YXIgdW5SZW5kZXJlZFBhbmVscyA9IGZsaWNraW5nLnBhbmVscy5maWx0ZXIoZnVuY3Rpb24gKHBhbmVsKSB7XG4gICAgICByZXR1cm4gIXBhbmVsLnJlbmRlcmVkO1xuICAgIH0pO1xuICAgIHRoaXMuX29mZnNldCA9IHVuUmVuZGVyZWRQYW5lbHMuZmlsdGVyKGZ1bmN0aW9uIChwYW5lbCkge1xuICAgICAgcmV0dXJuIHBhbmVsLnBvc2l0aW9uICsgcGFuZWwub2Zmc2V0IDwgcG9zaXRpb247XG4gICAgfSkucmVkdWNlKGZ1bmN0aW9uIChvZmZzZXQsIHBhbmVsKSB7XG4gICAgICByZXR1cm4gb2Zmc2V0ICsgcGFuZWwuc2l6ZUluY2x1ZGluZ01hcmdpbjtcbiAgICB9LCAwKTtcbiAgICB0aGlzLl9jaXJjdWxhck9mZnNldCA9IHRoaXMuX21vZGUuZ2V0Q2lyY3VsYXJPZmZzZXQoKTtcbiAgICB0aGlzLmFwcGx5VHJhbnNmb3JtKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxyXG4gICAqIFVwZGF0ZSBkaXJlY3Rpb24gdG8gbWF0Y2ggdGhlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvZGlyZWN0aW9uIGRpcmVjdGlvbn0gQ1NTIHByb3BlcnR5IGFwcGxpZWQgdG8gdGhlIGNhbWVyYSBlbGVtZW50XHJcbiAgICogQGtvIOy5tOuplOudvCDsl5jrpqzrqLztirjsl5Ag7KCB7Jqp65CcIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvZGlyZWN0aW9uIGRpcmVjdGlvbn0gQ1NTIOyGjeyEseyXkCDrp57qsowg67Cp7Zal7J2EIOyXheuNsOydtO2KuO2VqeuLiOuLpFxyXG4gICAqIEByZXR1cm4ge3RoaXN9XHJcbiAgICovXG4gIF9fcHJvdG8udXBkYXRlUGFuZWxPcmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZmxpY2tpbmcgPSBnZXRGbGlja2luZ0F0dGFjaGVkKHRoaXMuX2ZsaWNraW5nKTtcbiAgICBpZiAoIWZsaWNraW5nLmhvcml6b250YWwpIHJldHVybiB0aGlzO1xuICAgIHZhciBlbCA9IHRoaXMuX2VsO1xuICAgIHZhciBkaXJlY3Rpb24gPSBnZXRTdHlsZShlbCkuZGlyZWN0aW9uO1xuICAgIGlmIChkaXJlY3Rpb24gIT09IHRoaXMuX3BhbmVsT3JkZXIpIHtcbiAgICAgIHRoaXMuX3BhbmVsT3JkZXIgPSBkaXJlY3Rpb24gPT09IE9SREVSLlJUTCA/IE9SREVSLlJUTCA6IE9SREVSLkxUUjtcbiAgICAgIGlmIChmbGlja2luZy5pbml0aWFsaXplZCkge1xuICAgICAgICBmbGlja2luZy5jb250cm9sLmNvbnRyb2xsZXIudXBkYXRlRGlyZWN0aW9uKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcclxuICAgKiBSZXNldCB0aGUgaGlzdG9yeSBvZiB7QGxpbmsgRmxpY2tpbmcjZXZlbnQ6bmVlZFBhbmVsIG5lZWRQYW5lbH0gZXZlbnRzIHNvIGl0IGNhbiBiZSB0cmlnZ2VyZWQgYWdhaW5cclxuICAgKiBAa28g67Cc7IOd7ZWcIHtAbGluayBGbGlja2luZyNldmVudDpuZWVkUGFuZWwgbmVlZFBhbmVsfSDsnbTrsqTtirjrk6TsnYQg7LSI6riw7ZmU7ZWY7JesIOuLpOyLnCDrsJzsg53tlaAg7IiYIOyeiOuPhOuhnSDtlanri4jri6RcclxuICAgKiBAY2hhaW5hYmxlXHJcbiAgICogQHJldHVybiB7dGhpc31cclxuICAgKi9cbiAgX19wcm90by5yZXNldE5lZWRQYW5lbEhpc3RvcnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fbmVlZFBhbmVsVHJpZ2dlcmVkID0ge1xuICAgICAgcHJldjogZmFsc2UsXG4gICAgICBuZXh0OiBmYWxzZVxuICAgIH07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxyXG4gICAqIEFwcGx5IFwidHJhbnNmb3JtXCIgc3R5bGUgd2l0aCB0aGUgY3VycmVudCBwb3NpdGlvbiB0byBjYW1lcmEgZWxlbWVudFxyXG4gICAqIEBrbyDtmITsnqwg7JyE7LmY66W8IOq4sOykgOycvOuhnO2VnCB0cmFuc2Zvcm0g7Iqk7YOA7J287J2EIOy5tOuplOudvCDsl5jrpqzrqLztirjsl5Ag7KCB7Jqp7ZWp64uI64ukLlxyXG4gICAqIEByZXR1cm4ge3RoaXN9XHJcbiAgICovXG4gIF9fcHJvdG8uYXBwbHlUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVsID0gdGhpcy5fZWw7XG4gICAgdmFyIGZsaWNraW5nID0gZ2V0RmxpY2tpbmdBdHRhY2hlZCh0aGlzLl9mbGlja2luZyk7XG4gICAgdmFyIHJlbmRlcmVyID0gZmxpY2tpbmcucmVuZGVyZXI7XG4gICAgaWYgKHJlbmRlcmVyLnJlbmRlcmluZyB8fCAhZmxpY2tpbmcuaW5pdGlhbGl6ZWQpIHJldHVybiB0aGlzO1xuICAgIHZhciBhY3R1YWxQb3NpdGlvbiA9IHRoaXMuX3Bvc2l0aW9uIC0gdGhpcy5fYWxpZ25Qb3MgLSB0aGlzLl9vZmZzZXQgKyB0aGlzLl9jaXJjdWxhck9mZnNldDtcbiAgICBlbC5zdHlsZVt0aGlzLl90cmFuc2Zvcm1dID0gZmxpY2tpbmcuaG9yaXpvbnRhbCA/IFwidHJhbnNsYXRlKFwiICsgKHRoaXMuX3BhbmVsT3JkZXIgPT09IE9SREVSLlJUTCA/IGFjdHVhbFBvc2l0aW9uIDogLWFjdHVhbFBvc2l0aW9uKSArIFwicHgpXCIgOiBcInRyYW5zbGF0ZSgwLCBcIiArIC1hY3R1YWxQb3NpdGlvbiArIFwicHgpXCI7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIF9fcHJvdG8uX3Jlc2V0SW50ZXJuYWxWYWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fcG9zaXRpb24gPSAwO1xuICAgIHRoaXMuX2FsaWduUG9zID0gMDtcbiAgICB0aGlzLl9vZmZzZXQgPSAwO1xuICAgIHRoaXMuX2NpcmN1bGFyT2Zmc2V0ID0gMDtcbiAgICB0aGlzLl9jaXJjdWxhckVuYWJsZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yYW5nZSA9IHtcbiAgICAgIG1pbjogMCxcbiAgICAgIG1heDogMFxuICAgIH07XG4gICAgdGhpcy5fdmlzaWJsZVBhbmVscyA9IFtdO1xuICAgIHRoaXMuX2FuY2hvcnMgPSBbXTtcbiAgICB0aGlzLl9uZWVkUGFuZWxUcmlnZ2VyZWQgPSB7XG4gICAgICBwcmV2OiBmYWxzZSxcbiAgICAgIG5leHQ6IGZhbHNlXG4gICAgfTtcbiAgfTtcbiAgX19wcm90by5fcmVmcmVzaFZpc2libGVQYW5lbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB2YXIgZmxpY2tpbmcgPSBnZXRGbGlja2luZ0F0dGFjaGVkKHRoaXMuX2ZsaWNraW5nKTtcbiAgICB2YXIgcGFuZWxzID0gZmxpY2tpbmcucmVuZGVyZXIucGFuZWxzO1xuICAgIHZhciBuZXdWaXNpYmxlUGFuZWxzID0gcGFuZWxzLmZpbHRlcihmdW5jdGlvbiAocGFuZWwpIHtcbiAgICAgIHJldHVybiBfdGhpcy5jYW5TZWUocGFuZWwpO1xuICAgIH0pO1xuICAgIHZhciBwcmV2VmlzaWJsZVBhbmVscyA9IHRoaXMuX3Zpc2libGVQYW5lbHM7XG4gICAgdGhpcy5fdmlzaWJsZVBhbmVscyA9IG5ld1Zpc2libGVQYW5lbHM7XG4gICAgdmFyIGFkZGVkID0gbmV3VmlzaWJsZVBhbmVscy5maWx0ZXIoZnVuY3Rpb24gKHBhbmVsKSB7XG4gICAgICByZXR1cm4gIWluY2x1ZGVzKHByZXZWaXNpYmxlUGFuZWxzLCBwYW5lbCk7XG4gICAgfSk7XG4gICAgdmFyIHJlbW92ZWQgPSBwcmV2VmlzaWJsZVBhbmVscy5maWx0ZXIoZnVuY3Rpb24gKHBhbmVsKSB7XG4gICAgICByZXR1cm4gIWluY2x1ZGVzKG5ld1Zpc2libGVQYW5lbHMsIHBhbmVsKTtcbiAgICB9KTtcbiAgICBpZiAoYWRkZWQubGVuZ3RoID4gMCB8fCByZW1vdmVkLmxlbmd0aCA+IDApIHtcbiAgICAgIHZvaWQgZmxpY2tpbmcucmVuZGVyZXIucmVuZGVyKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZsaWNraW5nLnRyaWdnZXIobmV3IENvbXBvbmVudEV2ZW50JDEoRVZFTlRTLlZJU0lCTEVfQ0hBTkdFLCB7XG4gICAgICAgICAgYWRkZWQ6IGFkZGVkLFxuICAgICAgICAgIHJlbW92ZWQ6IHJlbW92ZWQsXG4gICAgICAgICAgdmlzaWJsZVBhbmVsczogbmV3VmlzaWJsZVBhbmVsc1xuICAgICAgICB9KSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIF9fcHJvdG8uX2NoZWNrTmVlZFBhbmVsID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBuZWVkUGFuZWxUcmlnZ2VyZWQgPSB0aGlzLl9uZWVkUGFuZWxUcmlnZ2VyZWQ7XG4gICAgaWYgKG5lZWRQYW5lbFRyaWdnZXJlZC5wcmV2ICYmIG5lZWRQYW5lbFRyaWdnZXJlZC5uZXh0KSByZXR1cm47XG4gICAgdmFyIGZsaWNraW5nID0gZ2V0RmxpY2tpbmdBdHRhY2hlZCh0aGlzLl9mbGlja2luZyk7XG4gICAgdmFyIHBhbmVscyA9IGZsaWNraW5nLnJlbmRlcmVyLnBhbmVscztcbiAgICBpZiAocGFuZWxzLmxlbmd0aCA8PSAwKSB7XG4gICAgICBpZiAoIW5lZWRQYW5lbFRyaWdnZXJlZC5wcmV2KSB7XG4gICAgICAgIGZsaWNraW5nLnRyaWdnZXIobmV3IENvbXBvbmVudEV2ZW50JDEoRVZFTlRTLk5FRURfUEFORUwsIHtcbiAgICAgICAgICBkaXJlY3Rpb246IERJUkVDVElPTi5QUkVWXG4gICAgICAgIH0pKTtcbiAgICAgICAgbmVlZFBhbmVsVHJpZ2dlcmVkLnByZXYgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKCFuZWVkUGFuZWxUcmlnZ2VyZWQubmV4dCkge1xuICAgICAgICBmbGlja2luZy50cmlnZ2VyKG5ldyBDb21wb25lbnRFdmVudCQxKEVWRU5UUy5ORUVEX1BBTkVMLCB7XG4gICAgICAgICAgZGlyZWN0aW9uOiBESVJFQ1RJT04uTkVYVFxuICAgICAgICB9KSk7XG4gICAgICAgIG5lZWRQYW5lbFRyaWdnZXJlZC5uZXh0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGNhbWVyYVBvc2l0aW9uID0gdGhpcy5fcG9zaXRpb247XG4gICAgdmFyIGNhbWVyYVNpemUgPSB0aGlzLnNpemU7XG4gICAgdmFyIGNhbWVyYVJhbmdlID0gdGhpcy5fcmFuZ2U7XG4gICAgdmFyIG5lZWRQYW5lbFRocmVzaG9sZCA9IGZsaWNraW5nLm5lZWRQYW5lbFRocmVzaG9sZDtcbiAgICB2YXIgY2FtZXJhUHJldiA9IGNhbWVyYVBvc2l0aW9uIC0gdGhpcy5fYWxpZ25Qb3M7XG4gICAgdmFyIGNhbWVyYU5leHQgPSBjYW1lcmFQcmV2ICsgY2FtZXJhU2l6ZTtcbiAgICB2YXIgZmlyc3RQYW5lbCA9IHBhbmVsc1swXTtcbiAgICB2YXIgbGFzdFBhbmVsID0gcGFuZWxzW3BhbmVscy5sZW5ndGggLSAxXTtcbiAgICBpZiAoIW5lZWRQYW5lbFRyaWdnZXJlZC5wcmV2KSB7XG4gICAgICB2YXIgZmlyc3RQYW5lbFByZXYgPSBmaXJzdFBhbmVsLnJhbmdlLm1pbjtcbiAgICAgIGlmIChjYW1lcmFQcmV2IDw9IGZpcnN0UGFuZWxQcmV2ICsgbmVlZFBhbmVsVGhyZXNob2xkIHx8IGNhbWVyYVBvc2l0aW9uIDw9IGNhbWVyYVJhbmdlLm1pbiArIG5lZWRQYW5lbFRocmVzaG9sZCkge1xuICAgICAgICBmbGlja2luZy50cmlnZ2VyKG5ldyBDb21wb25lbnRFdmVudCQxKEVWRU5UUy5ORUVEX1BBTkVMLCB7XG4gICAgICAgICAgZGlyZWN0aW9uOiBESVJFQ1RJT04uUFJFVlxuICAgICAgICB9KSk7XG4gICAgICAgIG5lZWRQYW5lbFRyaWdnZXJlZC5wcmV2ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFuZWVkUGFuZWxUcmlnZ2VyZWQubmV4dCkge1xuICAgICAgdmFyIGxhc3RQYW5lbE5leHQgPSBsYXN0UGFuZWwucmFuZ2UubWF4O1xuICAgICAgaWYgKGNhbWVyYU5leHQgPj0gbGFzdFBhbmVsTmV4dCAtIG5lZWRQYW5lbFRocmVzaG9sZCB8fCBjYW1lcmFQb3NpdGlvbiA+PSBjYW1lcmFSYW5nZS5tYXggLSBuZWVkUGFuZWxUaHJlc2hvbGQpIHtcbiAgICAgICAgZmxpY2tpbmcudHJpZ2dlcihuZXcgQ29tcG9uZW50RXZlbnQkMShFVkVOVFMuTkVFRF9QQU5FTCwge1xuICAgICAgICAgIGRpcmVjdGlvbjogRElSRUNUSU9OLk5FWFRcbiAgICAgICAgfSkpO1xuICAgICAgICBuZWVkUGFuZWxUcmlnZ2VyZWQubmV4dCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBfX3Byb3RvLl9jaGVja1JlYWNoRW5kID0gZnVuY3Rpb24gKHByZXZQb3MsIG5ld1Bvcykge1xuICAgIHZhciBmbGlja2luZyA9IGdldEZsaWNraW5nQXR0YWNoZWQodGhpcy5fZmxpY2tpbmcpO1xuICAgIHZhciByYW5nZSA9IHRoaXMuX3JhbmdlO1xuICAgIHZhciB3YXNCZXR3ZWVuUmFuZ2UgPSBwcmV2UG9zID4gcmFuZ2UubWluICYmIHByZXZQb3MgPCByYW5nZS5tYXg7XG4gICAgdmFyIGlzQmV0d2VlblJhbmdlID0gbmV3UG9zID4gcmFuZ2UubWluICYmIG5ld1BvcyA8IHJhbmdlLm1heDtcbiAgICBpZiAoIXdhc0JldHdlZW5SYW5nZSB8fCBpc0JldHdlZW5SYW5nZSkgcmV0dXJuO1xuICAgIHZhciBkaXJlY3Rpb24gPSBuZXdQb3MgPD0gcmFuZ2UubWluID8gRElSRUNUSU9OLlBSRVYgOiBESVJFQ1RJT04uTkVYVDtcbiAgICBmbGlja2luZy50cmlnZ2VyKG5ldyBDb21wb25lbnRFdmVudCQxKEVWRU5UUy5SRUFDSF9FREdFLCB7XG4gICAgICBkaXJlY3Rpb246IGRpcmVjdGlvblxuICAgIH0pKTtcbiAgfTtcbiAgX19wcm90by5fdXBkYXRlTW9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZmxpY2tpbmcgPSBnZXRGbGlja2luZ0F0dGFjaGVkKHRoaXMuX2ZsaWNraW5nKTtcbiAgICBpZiAoZmxpY2tpbmcuY2lyY3VsYXIpIHtcbiAgICAgIHZhciBjaXJjdWxhck1vZGUgPSBuZXcgQ2lyY3VsYXJDYW1lcmFNb2RlKGZsaWNraW5nKTtcbiAgICAgIHZhciBjYW5TZXRDaXJjdWxhck1vZGUgPSBjaXJjdWxhck1vZGUuY2hlY2tBdmFpbGFiaWxpdHkoKTtcbiAgICAgIGlmIChjYW5TZXRDaXJjdWxhck1vZGUpIHtcbiAgICAgICAgdGhpcy5fbW9kZSA9IGNpcmN1bGFyTW9kZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBmYWxsYmFja01vZGUgPSBmbGlja2luZy5jaXJjdWxhckZhbGxiYWNrO1xuICAgICAgICB0aGlzLl9tb2RlID0gZmFsbGJhY2tNb2RlID09PSBDSVJDVUxBUl9GQUxMQkFDSy5CT1VORCA/IG5ldyBCb3VuZENhbWVyYU1vZGUoZmxpY2tpbmcpIDogbmV3IExpbmVhckNhbWVyYU1vZGUoZmxpY2tpbmcpO1xuICAgICAgfVxuICAgICAgdGhpcy5fY2lyY3VsYXJFbmFibGVkID0gY2FuU2V0Q2lyY3VsYXJNb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9tb2RlID0gZmxpY2tpbmcuYm91bmQgPyBuZXcgQm91bmRDYW1lcmFNb2RlKGZsaWNraW5nKSA6IG5ldyBMaW5lYXJDYW1lcmFNb2RlKGZsaWNraW5nKTtcbiAgICAgIHRoaXMuX2NpcmN1bGFyRW5hYmxlZCA9IGZhbHNlO1xuICAgIH1cbiAgfTtcbiAgX19wcm90by5fdG9nZ2xlUGFuZWxzID0gZnVuY3Rpb24gKHByZXZQb3MsIHBvcykge1xuICAgIGlmIChwb3MgPT09IHByZXZQb3MpIHJldHVybiBmYWxzZTtcbiAgICB2YXIgZmxpY2tpbmcgPSBnZXRGbGlja2luZ0F0dGFjaGVkKHRoaXMuX2ZsaWNraW5nKTtcbiAgICB2YXIgcGFuZWxzID0gZmxpY2tpbmcucmVuZGVyZXIucGFuZWxzO1xuICAgIHZhciB0b2dnbGVkID0gcGFuZWxzLm1hcChmdW5jdGlvbiAocGFuZWwpIHtcbiAgICAgIHJldHVybiBwYW5lbC50b2dnbGUocHJldlBvcywgcG9zKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdG9nZ2xlZC5zb21lKGZ1bmN0aW9uIChpc1RvZ2dsZWQpIHtcbiAgICAgIHJldHVybiBpc1RvZ2dsZWQ7XG4gICAgfSk7XG4gIH07XG4gIHJldHVybiBDYW1lcmE7XG59KCk7XG5cbi8qKlxyXG4gKiBBIGNvbXBvbmVudCB0aGF0IG1hbmFnZXMge0BsaW5rIFBhbmVsfSBhbmQgaXRzIGVsZW1lbnRzXHJcbiAqIEBrbyB7QGxpbmsgUGFuZWx96rO8IOq3uCDsl5jrpqzrqLztirjrk6TsnYQg6rSA66as7ZWY64qUIOy7tO2PrOuEjO2KuFxyXG4gKi9cbnZhciBSZW5kZXJlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIEFuIG9wdGlvbnMgb2JqZWN0PGtvPuyYteyFmCDsmKTruIzsoJ3tirg8L2tvPlxyXG4gICAqIEBwYXJhbSB7Q29uc3RhbnRzLkFMSUdOIHwgc3RyaW5nIHwgbnVtYmVyfSBbb3B0aW9ucy5hbGlnbj1cImNlbnRlclwiXSBBbiB7QGxpbmsgRmxpY2tpbmcjYWxpZ24gYWxpZ259IHZhbHVlIHRoYXQgd2lsbCBiZSBhcHBsaWVkIHRvIGFsbCBwYW5lbHM8a28+7KCE7LK0IO2MqOuEkOyXkCDsoIHsmqnrkKAge0BsaW5rIEZsaWNraW5nI2FsaWduIGFsaWdufSDqsJI8L2tvPlxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy5zdHJhdGVneV0gQW4gaW5zdGFuY2Ugb2YgUmVuZGVyaW5nU3RyYXRlZ3koaW50ZXJuYWwgbW9kdWxlKTxrbz5SZW5kZXJpbmdTdHJhdGVneeydmCDsnbjsiqTthLTsiqQo64K067aAIOuqqOuTiCk8L2tvPlxyXG4gICAqL1xuICBmdW5jdGlvbiBSZW5kZXJlcihfYSkge1xuICAgIHZhciBfYiA9IF9hLmFsaWduLFxuICAgICAgYWxpZ24gPSBfYiA9PT0gdm9pZCAwID8gQUxJR04uQ0VOVEVSIDogX2IsXG4gICAgICBzdHJhdGVneSA9IF9hLnN0cmF0ZWd5O1xuICAgIHRoaXMuX2ZsaWNraW5nID0gbnVsbDtcbiAgICB0aGlzLl9wYW5lbHMgPSBbXTtcbiAgICB0aGlzLl9yZW5kZXJpbmcgPSBmYWxzZTtcbiAgICAvLyBCaW5kIG9wdGlvbnNcbiAgICB0aGlzLl9hbGlnbiA9IGFsaWduO1xuICAgIHRoaXMuX3N0cmF0ZWd5ID0gc3RyYXRlZ3k7XG4gIH1cbiAgdmFyIF9fcHJvdG8gPSBSZW5kZXJlci5wcm90b3R5cGU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcInBhbmVsc1wiLCB7XG4gICAgLy8gSW50ZXJuYWwgc3RhdGVzIEdldHRlclxuICAgIC8qKlxyXG4gICAgICogQXJyYXkgb2YgcGFuZWxzXHJcbiAgICAgKiBAa28g7KCE7LK0IO2MqOuEkOuTpOydmCDrsLDsl7RcclxuICAgICAqIEB0eXBlIHtQYW5lbFtdfVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKiBAc2VlIFBhbmVsXHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wYW5lbHM7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcInJlbmRlcmluZ1wiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBBIGJvb2xlYW4gdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHJlbmRlcmluZyBpcyBpbiBwcm9ncmVzc1xyXG4gICAgICogQGtvIO2YhOyerCDroIzrjZTrp4HsnbQg7Iuc7J6R65CY7Ja0IOuBneuCmOq4sCDsoITquYzsp4DsnZgg7IOB7YOc7J247KeA7J2YIOyXrOu2gFxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVuZGVyaW5nO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJwYW5lbENvdW50XCIsIHtcbiAgICAvKipcclxuICAgICAqIENvdW50IG9mIHBhbmVsc1xyXG4gICAgICogQGtvIOyghOyytCDtjKjrhJDsnZgg6rCc7IiYXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wYW5lbHMubGVuZ3RoO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJzdHJhdGVneVwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N0cmF0ZWd5O1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJhbGlnblwiLCB7XG4gICAgLy8gT3B0aW9ucyBHZXR0ZXJcbiAgICAvKipcclxuICAgICAqIEEge0BsaW5rIFBhbmVsfSdzIHtAbGluayBQYW5lbCNhbGlnbiBhbGlnbn0gdmFsdWUgdGhhdCBhcHBsaWVkIHRvIGFsbCBwYW5lbHNcclxuICAgICAqIEBrbyB7QGxpbmsgUGFuZWx97JeQIOqzte2GteyggeycvOuhnCDsoIHsmqntlaAge0BsaW5rIFBhbmVsI2FsaWduIGFsaWdufSDqsJJcclxuICAgICAqIEB0eXBlIHtDb25zdGFudHMuQUxJR04gfCBzdHJpbmcgfCBudW1iZXJ9XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9hbGlnbjtcbiAgICB9LFxuICAgIC8vIE9wdGlvbnMgU2V0dGVyXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICB0aGlzLl9hbGlnbiA9IHZhbDtcbiAgICAgIHZhciBwYW5lbEFsaWduID0gcGFyc2VQYW5lbEFsaWduKHZhbCk7XG4gICAgICB0aGlzLl9wYW5lbHMuZm9yRWFjaChmdW5jdGlvbiAocGFuZWwpIHtcbiAgICAgICAgcGFuZWwuYWxpZ24gPSBwYW5lbEFsaWduO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIC8qKlxyXG4gICAqIEluaXRpYWxpemUgUmVuZGVyZXJcclxuICAgKiBAa28gUmVuZGVyZXLrpbwg7LSI6riw7ZmU7ZWp64uI64ukXHJcbiAgICogQHBhcmFtIHtGbGlja2luZ30gZmxpY2tpbmcgQW4gaW5zdGFuY2Ugb2Yge0BsaW5rIEZsaWNraW5nfTxrbz5GbGlja2luZ+ydmCDsnbjsiqTthLTsiqQ8L2tvPlxyXG4gICAqIEBjaGFpbmFibGVcclxuICAgKiBAcmV0dXJuIHt0aGlzfVxyXG4gICAqL1xuICBfX3Byb3RvLmluaXQgPSBmdW5jdGlvbiAoZmxpY2tpbmcpIHtcbiAgICB0aGlzLl9mbGlja2luZyA9IGZsaWNraW5nO1xuICAgIHRoaXMuX2NvbGxlY3RQYW5lbHMoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXHJcbiAgICogRGVzdHJveSBSZW5kZXJlciBhbmQgcmV0dXJuIHRvIGluaXRpYWwgc3RhdGVcclxuICAgKiBAa28gUmVuZGVyZXLrpbwg7LSI6riwIOyDge2DnOuhnCDrkJjrj4zrpr3ri4jri6RcclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xuICBfX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fZmxpY2tpbmcgPSBudWxsO1xuICAgIHRoaXMuX3BhbmVscyA9IFtdO1xuICB9O1xuICAvKipcclxuICAgKiBSZXR1cm4gdGhlIHtAbGluayBQYW5lbH0gYXQgdGhlIGdpdmVuIGluZGV4LiBgbnVsbGAgaWYgaXQgZG9lc24ndCBleGlzdHMuXHJcbiAgICogQGtvIOyjvOyWtOynhCDsnbjrjbHsiqTsl5Ag7ZW064u57ZWY64qUIHtAbGluayBQYW5lbH3snYQg67CY7ZmY7ZWp64uI64ukLiDso7zslrTsp4Qg7J24642x7Iqk7JeQIO2VtOuLue2VmOuKlCDtjKjrhJDsnbQg7KG07J6s7ZWY7KeAIOyViuydhCDqsr3smrAgYG51bGxg7J2EIOuwmO2ZmO2VqeuLiOuLpC5cclxuICAgKiBAcmV0dXJuIHtQYW5lbCB8IG51bGx9IFBhbmVsIGF0IHRoZSBnaXZlbiBpbmRleDxrbz7so7zslrTsp4Qg7J24642x7Iqk7JeQIO2VtOuLue2VmOuKlCDtjKjrhJA8L2tvPlxyXG4gICAqIEBzZWUgUGFuZWxcclxuICAgKi9cbiAgX19wcm90by5nZXRQYW5lbCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgIHJldHVybiB0aGlzLl9wYW5lbHNbaW5kZXhdIHx8IG51bGw7XG4gIH07XG4gIF9fcHJvdG8uZm9yY2VSZW5kZXJBbGxQYW5lbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fcGFuZWxzLmZvckVhY2goZnVuY3Rpb24gKHBhbmVsKSB7XG4gICAgICByZXR1cm4gcGFuZWwubWFya0ZvclNob3coKTtcbiAgICB9KTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH07XG4gIC8qKlxyXG4gICAqIFVwZGF0ZSBhbGwgcGFuZWwgc2l6ZXNcclxuICAgKiBAa28g66qo65OgIO2MqOuEkOydmCDtgazquLDrpbwg7JeF642w7J207Yq47ZWp64uI64ukXHJcbiAgICogQGNoYWluYWJsZVxyXG4gICAqIEByZXR1cm4ge3RoaXN9XHJcbiAgICovXG4gIF9fcHJvdG8udXBkYXRlUGFuZWxTaXplID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBmbGlja2luZyA9IGdldEZsaWNraW5nQXR0YWNoZWQodGhpcy5fZmxpY2tpbmcpO1xuICAgIHZhciBwYW5lbHMgPSB0aGlzLl9wYW5lbHM7XG4gICAgaWYgKHBhbmVscy5sZW5ndGggPD0gMCkgcmV0dXJuIHRoaXM7XG4gICAgaWYgKGZsaWNraW5nLnBhbmVsc1BlclZpZXcgPiAwKSB7XG4gICAgICB2YXIgZmlyc3RQYW5lbCA9IHBhbmVsc1swXTtcbiAgICAgIGZpcnN0UGFuZWwucmVzaXplKCk7XG4gICAgICB0aGlzLl91cGRhdGVQYW5lbFNpemVCeUdyaWQoZmlyc3RQYW5lbCwgcGFuZWxzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmxpY2tpbmcucGFuZWxzLmZvckVhY2goZnVuY3Rpb24gKHBhbmVsKSB7XG4gICAgICAgIHJldHVybiBwYW5lbC5yZXNpemUoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXHJcbiAgICogSW5zZXJ0IG5ldyBwYW5lbHMgYXQgZ2l2ZW4gaW5kZXhcclxuICAgKiBUaGlzIHdpbGwgaW5jcmVhc2UgaW5kZXggb2YgcGFuZWxzIGFmdGVyIGJ5IHRoZSBudW1iZXIgb2YgcGFuZWxzIGFkZGVkXHJcbiAgICogQGtvIOyjvOyWtOynhCDsnbjrjbHsiqTsl5Ag7IOI66Gc7Jq0IO2MqOuEkOuTpOydhCDstpTqsIDtlanri4jri6RcclxuICAgKiDtlbTri7kg7J24642x7Iqk67O064ukIOqwmeqxsOuCmCDtgbAg7J24642x7Iqk66W8IOqwgOynhCDquLDsobQg7Yyo64SQ65Ok7J2AIOy2lOqwgO2VnCDtjKjrhJDsnZgg6rCc7IiY66eM7YG8IOyduOuNseyKpOqwgCDspp3qsIDtlanri4jri6QuXHJcbiAgICogQHBhcmFtIHtBcnJheTxvYmplY3Q+fSBpdGVtcyBBbiBhcnJheSBvZiBpdGVtcyB0byBpbnNlcnQ8a28+7LaU6rCA7ZWgIOyVhOydtO2FnOuTpOydmCDrsLDsl7Q8L2tvPlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbaXRlbXMuaW5kZXhdIEluZGV4IHRvIGluc2VydCBuZXcgcGFuZWxzIGF0PGtvPuyDiOuhnCDtjKjrhJDrk6TsnYQg7LaU6rCA7ZWgIOyduOuNseyKpDwva28+XHJcbiAgICogQHBhcmFtIHthbnlbXX0gW2l0ZW1zLmVsZW1lbnRzXSBBbiBhcnJheSBvZiBlbGVtZW50IG9yIGZyYW1ld29yayBjb21wb25lbnQgd2l0aCBlbGVtZW50IGluIGl0PGtvPuyXmOumrOuovO2KuOydmCDrsLDsl7Qg7Zi57J2AIO2UhOugiOyehOybjO2BrOyXkOyEnCDsl5jrpqzrqLztirjrpbwg7Y+s7ZWo7ZWcIOy7tO2PrOuEjO2KuOuTpOydmCDrsLDsl7Q8L2tvPlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2l0ZW1zLmhhc0RPTUluRWxlbWVudHNdIFdoZXRoZXIgaXQgY29udGFpbnMgYWN0dWFsIERPTSBlbGVtZW50cy4gSWYgc2V0IHRvIHRydWUsIHJlbmRlcmVyIHdpbGwgYWRkIHRoZW0gdG8gdGhlIGNhbWVyYSBlbGVtZW50PGtvPuuCtOu2gOyXkCDsi6TsoJwgRE9NIOyXmOumrOuovO2KuOuTpOydhCDtj6ztlajtlZjqs6Ag7J6I64qU7KeAIOyXrOu2gC4gdHJ1ZeuhnCDshKTsoJXtlaAg6rK97JqwLCDroIzrjZTrn6zripQg7ZW064u5IOyXmOumrOuovO2KuOuTpOydhCDsubTrqZTrnbwg7JeY66as66i87Yq4IOuCtOu2gOyXkCDstpTqsIDtlanri4jri6Q8L2tvPlxyXG4gICAqIEByZXR1cm4ge1BhbmVsW119IEFuIGFycmF5IG9mIHByZXBlbmRlZCBwYW5lbHM8a28+7LaU6rCA65CcIO2MqOuEkOuTpOydmCDrsLDsl7Q8L2tvPlxyXG4gICAqL1xuICBfX3Byb3RvLmJhdGNoSW5zZXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpdGVtcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICBpdGVtc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB2YXIgYWxsUGFuZWxzSW5zZXJ0ZWQgPSB0aGlzLmJhdGNoSW5zZXJ0RGVmZXIuYXBwbHkodGhpcywgX19zcHJlYWQkMShpdGVtcykpO1xuICAgIGlmIChhbGxQYW5lbHNJbnNlcnRlZC5sZW5ndGggPD0gMCkgcmV0dXJuIFtdO1xuICAgIHRoaXMudXBkYXRlQWZ0ZXJQYW5lbENoYW5nZShhbGxQYW5lbHNJbnNlcnRlZCwgW10pO1xuICAgIHJldHVybiBhbGxQYW5lbHNJbnNlcnRlZDtcbiAgfTtcbiAgLyoqXHJcbiAgICogRGVmZXJzIHVwZGF0ZVxyXG4gICAqIGNhbWVyYSBwb3NpdGlvbiAmIG90aGVycyB3aWxsIGJlIHVwZGF0ZWQgYWZ0ZXIgY2FsbGluZyB1cGRhdGVBZnRlclBhbmVsQ2hhbmdlXHJcbiAgICogQGludGVybmFsXHJcbiAgICovXG4gIF9fcHJvdG8uYmF0Y2hJbnNlcnREZWZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHZhciBpdGVtcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICBpdGVtc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB2YXIgcGFuZWxzID0gdGhpcy5fcGFuZWxzO1xuICAgIHZhciBmbGlja2luZyA9IGdldEZsaWNraW5nQXR0YWNoZWQodGhpcy5fZmxpY2tpbmcpO1xuICAgIHZhciBwcmV2Rmlyc3RQYW5lbCA9IHBhbmVsc1swXTtcbiAgICB2YXIgYWxpZ24gPSBwYXJzZVBhbmVsQWxpZ24odGhpcy5fYWxpZ24pO1xuICAgIHZhciBhbGxQYW5lbHNJbnNlcnRlZCA9IGl0ZW1zLnJlZHVjZShmdW5jdGlvbiAoYWRkZWRQYW5lbHMsIGl0ZW0pIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIHZhciBpbnNlcnRpbmdJZHggPSBnZXRNaW51c0NvbXBlbnNhdGVkSW5kZXgoaXRlbS5pbmRleCwgcGFuZWxzLmxlbmd0aCk7XG4gICAgICB2YXIgcGFuZWxzUHVzaGVkID0gcGFuZWxzLnNsaWNlKGluc2VydGluZ0lkeCk7XG4gICAgICB2YXIgcGFuZWxzSW5zZXJ0ZWQgPSBpdGVtLmVsZW1lbnRzLm1hcChmdW5jdGlvbiAoZWwsIGlkeCkge1xuICAgICAgICByZXR1cm4gX3RoaXMuX2NyZWF0ZVBhbmVsKGVsLCB7XG4gICAgICAgICAgaW5kZXg6IGluc2VydGluZ0lkeCArIGlkeCxcbiAgICAgICAgICBhbGlnbjogYWxpZ24sXG4gICAgICAgICAgZmxpY2tpbmc6IGZsaWNraW5nXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBwYW5lbHMuc3BsaWNlLmFwcGx5KHBhbmVscywgX19zcHJlYWQkMShbaW5zZXJ0aW5nSWR4LCAwXSwgcGFuZWxzSW5zZXJ0ZWQpKTtcbiAgICAgIGlmIChpdGVtLmhhc0RPTUluRWxlbWVudHMpIHtcbiAgICAgICAgLy8gSW5zZXJ0IHRoZSBhY3R1YWwgZWxlbWVudHMgYXMgY2FtZXJhIGVsZW1lbnQncyBjaGlsZHJlblxuICAgICAgICBfdGhpcy5faW5zZXJ0UGFuZWxFbGVtZW50cyhwYW5lbHNJbnNlcnRlZCwgKF9hID0gcGFuZWxzUHVzaGVkWzBdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsKTtcbiAgICAgIH1cbiAgICAgIC8vIFJlc2l6ZSB0aGUgbmV3bHkgYWRkZWQgcGFuZWxzXG4gICAgICBpZiAoZmxpY2tpbmcucGFuZWxzUGVyVmlldyA+IDApIHtcbiAgICAgICAgdmFyIGZpcnN0UGFuZWwgPSBwcmV2Rmlyc3RQYW5lbCB8fCBwYW5lbHNJbnNlcnRlZFswXS5yZXNpemUoKTtcbiAgICAgICAgX3RoaXMuX3VwZGF0ZVBhbmVsU2l6ZUJ5R3JpZChmaXJzdFBhbmVsLCBwYW5lbHNJbnNlcnRlZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYW5lbHNJbnNlcnRlZC5mb3JFYWNoKGZ1bmN0aW9uIChwYW5lbCkge1xuICAgICAgICAgIHJldHVybiBwYW5lbC5yZXNpemUoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAvLyBVcGRhdGUgcGFuZWwgaW5kZXhlcyAmIHBvc2l0aW9uc1xuICAgICAgcGFuZWxzUHVzaGVkLmZvckVhY2goZnVuY3Rpb24gKHBhbmVsKSB7XG4gICAgICAgIHBhbmVsLmluY3JlYXNlSW5kZXgocGFuZWxzSW5zZXJ0ZWQubGVuZ3RoKTtcbiAgICAgICAgcGFuZWwudXBkYXRlUG9zaXRpb24oKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIF9fc3ByZWFkJDEoYWRkZWRQYW5lbHMsIHBhbmVsc0luc2VydGVkKTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIGFsbFBhbmVsc0luc2VydGVkO1xuICB9O1xuICAvKipcclxuICAgKiBSZW1vdmUgdGhlIHBhbmVsIGF0IHRoZSBnaXZlbiBpbmRleFxyXG4gICAqIFRoaXMgd2lsbCBkZWNyZWFzZSBpbmRleCBvZiBwYW5lbHMgYWZ0ZXIgYnkgdGhlIG51bWJlciBvZiBwYW5lbHMgcmVtb3ZlZFxyXG4gICAqIEBrbyDso7zslrTsp4Qg7J24642x7Iqk7J2YIO2MqOuEkOydhCDsoJzqsbDtlanri4jri6RcclxuICAgKiDtlbTri7kg7J24642x7Iqk67O064ukIO2BsCDsnbjrjbHsiqTrpbwg6rCA7KeEIOq4sOyhtCDtjKjrhJDrk6TsnYAg7KCc6rGw7ZWcIO2MqOuEkOydmCDqsJzsiJjrp4ztgbwg7J24642x7Iqk6rCAIOqwkOyGjO2VqeuLiOuLpFxyXG4gICAqIEBwYXJhbSB7QXJyYXk8b2JqZWN0Pn0gaXRlbXMgQW4gYXJyYXkgb2YgaXRlbXMgdG8gcmVtb3ZlPGtvPuygnOqxsO2VoCDslYTsnbTthZzrk6TsnZgg67Cw7Je0PC9rbz5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gW2l0ZW1zLmluZGV4XSBJbmRleCBvZiBwYW5lbCB0byByZW1vdmU8a28+7KCc6rGw7ZWgIO2MqOuEkOydmCDsnbjrjbHsiqQ8L2tvPlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbaXRlbXMuZGVsZXRlQ291bnQ9MV0gTnVtYmVyIG9mIHBhbmVscyB0byByZW1vdmUgZnJvbSBpbmRleDxrbz5gaW5kZXhgIOydtO2bhOuhnCDsoJzqsbDtlaAg7Yyo64SQ7J2YIOqwnOyImDwva28+XHJcbiAgICogQHBhcmFtIHtib29sZWFufSBbaXRlbXMuaGFzRE9NSW5FbGVtZW50cz0xXSBXaGV0aGVyIGl0IGNvbnRhaW5zIGFjdHVhbCBET00gZWxlbWVudHMuIElmIHNldCB0byB0cnVlLCByZW5kZXJlciB3aWxsIHJlbW92ZSB0aGVtIGZyb20gdGhlIGNhbWVyYSBlbGVtZW50PGtvPuuCtOu2gOyXkCDsi6TsoJwgRE9NIOyXmOumrOuovO2KuOuTpOydhCDtj6ztlajtlZjqs6Ag7J6I64qU7KeAIOyXrOu2gC4gdHJ1ZeuhnCDshKTsoJXtlaAg6rK97JqwLCDroIzrjZTrn6zripQg7ZW064u5IOyXmOumrOuovO2KuOuTpOydhCDsubTrqZTrnbwg7JeY66as66i87Yq4IOuCtOu2gOyXkOyEnCDsoJzqsbDtlanri4jri6Q8L2tvPlxyXG4gICAqIEByZXR1cm4gQW4gYXJyYXkgb2YgcmVtb3ZlZCBwYW5lbHM8a28+7KCc6rGw65CcIO2MqOuEkOuTpOydmCDrsLDsl7Q8L2tvPlxyXG4gICAqL1xuICBfX3Byb3RvLmJhdGNoUmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpdGVtcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICBpdGVtc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB2YXIgYWxsUGFuZWxzUmVtb3ZlZCA9IHRoaXMuYmF0Y2hSZW1vdmVEZWZlci5hcHBseSh0aGlzLCBfX3NwcmVhZCQxKGl0ZW1zKSk7XG4gICAgaWYgKGFsbFBhbmVsc1JlbW92ZWQubGVuZ3RoIDw9IDApIHJldHVybiBbXTtcbiAgICB0aGlzLnVwZGF0ZUFmdGVyUGFuZWxDaGFuZ2UoW10sIGFsbFBhbmVsc1JlbW92ZWQpO1xuICAgIHJldHVybiBhbGxQYW5lbHNSZW1vdmVkO1xuICB9O1xuICAvKipcclxuICAgKiBEZWZlcnMgdXBkYXRlXHJcbiAgICogY2FtZXJhIHBvc2l0aW9uICYgb3RoZXJzIHdpbGwgYmUgdXBkYXRlZCBhZnRlciBjYWxsaW5nIHVwZGF0ZUFmdGVyUGFuZWxDaGFuZ2VcclxuICAgKiBAaW50ZXJuYWxcclxuICAgKi9cbiAgX19wcm90by5iYXRjaFJlbW92ZURlZmVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIGl0ZW1zID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIGl0ZW1zW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciBwYW5lbHMgPSB0aGlzLl9wYW5lbHM7XG4gICAgdmFyIGZsaWNraW5nID0gZ2V0RmxpY2tpbmdBdHRhY2hlZCh0aGlzLl9mbGlja2luZyk7XG4gICAgdmFyIGNvbnRyb2wgPSBmbGlja2luZy5jb250cm9sO1xuICAgIHZhciBhY3RpdmVQYW5lbCA9IGNvbnRyb2wuYWN0aXZlUGFuZWw7XG4gICAgdmFyIGFsbFBhbmVsc1JlbW92ZWQgPSBpdGVtcy5yZWR1Y2UoZnVuY3Rpb24gKHJlbW92ZWQsIGl0ZW0pIHtcbiAgICAgIHZhciBpbmRleCA9IGl0ZW0uaW5kZXgsXG4gICAgICAgIGRlbGV0ZUNvdW50ID0gaXRlbS5kZWxldGVDb3VudDtcbiAgICAgIHZhciByZW1vdmluZ0lkeCA9IGdldE1pbnVzQ29tcGVuc2F0ZWRJbmRleChpbmRleCwgcGFuZWxzLmxlbmd0aCk7XG4gICAgICB2YXIgcGFuZWxzUHVsbGVkID0gcGFuZWxzLnNsaWNlKHJlbW92aW5nSWR4ICsgZGVsZXRlQ291bnQpO1xuICAgICAgdmFyIHBhbmVsc1JlbW92ZWQgPSBwYW5lbHMuc3BsaWNlKHJlbW92aW5nSWR4LCBkZWxldGVDb3VudCk7XG4gICAgICBpZiAocGFuZWxzUmVtb3ZlZC5sZW5ndGggPD0gMCkgcmV0dXJuIFtdO1xuICAgICAgLy8gVXBkYXRlIHBhbmVsIGluZGV4ZXMgJiBwb3NpdGlvbnNcbiAgICAgIHBhbmVsc1B1bGxlZC5mb3JFYWNoKGZ1bmN0aW9uIChwYW5lbCkge1xuICAgICAgICBwYW5lbC5kZWNyZWFzZUluZGV4KHBhbmVsc1JlbW92ZWQubGVuZ3RoKTtcbiAgICAgICAgcGFuZWwudXBkYXRlUG9zaXRpb24oKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKGl0ZW0uaGFzRE9NSW5FbGVtZW50cykge1xuICAgICAgICBfdGhpcy5fcmVtb3ZlUGFuZWxFbGVtZW50cyhwYW5lbHNSZW1vdmVkKTtcbiAgICAgIH1cbiAgICAgIC8vIFJlbW92ZSBwYW5lbCBlbGVtZW50c1xuICAgICAgcGFuZWxzUmVtb3ZlZC5mb3JFYWNoKGZ1bmN0aW9uIChwYW5lbCkge1xuICAgICAgICByZXR1cm4gcGFuZWwuZGVzdHJveSgpO1xuICAgICAgfSk7XG4gICAgICBpZiAoaW5jbHVkZXMocGFuZWxzUmVtb3ZlZCwgYWN0aXZlUGFuZWwpKSB7XG4gICAgICAgIGNvbnRyb2wucmVzZXRBY3RpdmUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfX3NwcmVhZCQxKHJlbW92ZWQsIHBhbmVsc1JlbW92ZWQpO1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gYWxsUGFuZWxzUmVtb3ZlZDtcbiAgfTtcbiAgLyoqXHJcbiAgICogQGludGVybmFsXHJcbiAgICovXG4gIF9fcHJvdG8udXBkYXRlQWZ0ZXJQYW5lbENoYW5nZSA9IGZ1bmN0aW9uIChwYW5lbHNBZGRlZCwgcGFuZWxzUmVtb3ZlZCkge1xuICAgIHZhciBfYTtcbiAgICB2YXIgZmxpY2tpbmcgPSBnZXRGbGlja2luZ0F0dGFjaGVkKHRoaXMuX2ZsaWNraW5nKTtcbiAgICB2YXIgY2FtZXJhID0gZmxpY2tpbmcuY2FtZXJhLFxuICAgICAgY29udHJvbCA9IGZsaWNraW5nLmNvbnRyb2w7XG4gICAgdmFyIHBhbmVscyA9IHRoaXMuX3BhbmVscztcbiAgICB2YXIgYWN0aXZlUGFuZWwgPSBjb250cm9sLmFjdGl2ZVBhbmVsO1xuICAgIC8vIFVwZGF0ZSBjYW1lcmEgJiBjb250cm9sXG4gICAgdGhpcy5fdXBkYXRlQ2FtZXJhQW5kQ29udHJvbCgpO1xuICAgIHZvaWQgdGhpcy5yZW5kZXIoKTtcbiAgICBpZiAoIWZsaWNraW5nLmFuaW1hdGluZykge1xuICAgICAgaWYgKCFhY3RpdmVQYW5lbCB8fCBhY3RpdmVQYW5lbC5yZW1vdmVkKSB7XG4gICAgICAgIGlmIChwYW5lbHMubGVuZ3RoIDw9IDApIHtcbiAgICAgICAgICAvLyBBbGwgcGFuZWxzIHJlbW92ZWRcbiAgICAgICAgICBjYW1lcmEubG9va0F0KDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciB0YXJnZXRJbmRleCA9IChfYSA9IGFjdGl2ZVBhbmVsID09PSBudWxsIHx8IGFjdGl2ZVBhbmVsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhY3RpdmVQYW5lbC5pbmRleCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgICBpZiAodGFyZ2V0SW5kZXggPiBwYW5lbHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgdGFyZ2V0SW5kZXggPSBwYW5lbHMubGVuZ3RoIC0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdm9pZCBjb250cm9sLm1vdmVUb1BhbmVsKHBhbmVsc1t0YXJnZXRJbmRleF0sIHtcbiAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdm9pZCBjb250cm9sLm1vdmVUb1BhbmVsKGFjdGl2ZVBhbmVsLCB7XG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBmbGlja2luZy5jYW1lcmEudXBkYXRlT2Zmc2V0KCk7XG4gICAgaWYgKHBhbmVsc0FkZGVkLmxlbmd0aCA+IDAgfHwgcGFuZWxzUmVtb3ZlZC5sZW5ndGggPiAwKSB7XG4gICAgICBmbGlja2luZy50cmlnZ2VyKG5ldyBDb21wb25lbnRFdmVudCQxKEVWRU5UUy5QQU5FTF9DSEFOR0UsIHtcbiAgICAgICAgYWRkZWQ6IHBhbmVsc0FkZGVkLFxuICAgICAgICByZW1vdmVkOiBwYW5lbHNSZW1vdmVkXG4gICAgICB9KSk7XG4gICAgICB0aGlzLmNoZWNrUGFuZWxDb250ZW50c1JlYWR5KF9fc3ByZWFkJDEocGFuZWxzQWRkZWQsIHBhbmVsc1JlbW92ZWQpKTtcbiAgICB9XG4gIH07XG4gIC8qKlxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqL1xuICBfX3Byb3RvLmNoZWNrUGFuZWxDb250ZW50c1JlYWR5ID0gZnVuY3Rpb24gKGNoZWNraW5nUGFuZWxzKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB2YXIgZmxpY2tpbmcgPSBnZXRGbGlja2luZ0F0dGFjaGVkKHRoaXMuX2ZsaWNraW5nKTtcbiAgICB2YXIgcmVzaXplT25Db250ZW50c1JlYWR5ID0gZmxpY2tpbmcucmVzaXplT25Db250ZW50c1JlYWR5O1xuICAgIHZhciBwYW5lbHMgPSB0aGlzLl9wYW5lbHM7XG4gICAgaWYgKCFyZXNpemVPbkNvbnRlbnRzUmVhZHkgfHwgZmxpY2tpbmcudmlydHVhbEVuYWJsZWQpIHJldHVybjtcbiAgICB2YXIgaGFzQ29udGVudHMgPSBmdW5jdGlvbiAocGFuZWwpIHtcbiAgICAgIHJldHVybiBwYW5lbC5lbGVtZW50ICYmICEhcGFuZWwuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFwiaW1nLCB2aWRlb1wiKTtcbiAgICB9O1xuICAgIGNoZWNraW5nUGFuZWxzID0gY2hlY2tpbmdQYW5lbHMuZmlsdGVyKGZ1bmN0aW9uIChwYW5lbCkge1xuICAgICAgcmV0dXJuIGhhc0NvbnRlbnRzKHBhbmVsKTtcbiAgICB9KTtcbiAgICBpZiAoY2hlY2tpbmdQYW5lbHMubGVuZ3RoIDw9IDApIHJldHVybjtcbiAgICB2YXIgY29udGVudHNSZWFkeUNoZWNrZXIgPSBuZXcgSW1SZWFkeSgpO1xuICAgIGNoZWNraW5nUGFuZWxzLmZvckVhY2goZnVuY3Rpb24gKHBhbmVsKSB7XG4gICAgICBwYW5lbC5sb2FkaW5nID0gdHJ1ZTtcbiAgICB9KTtcbiAgICBjb250ZW50c1JlYWR5Q2hlY2tlci5vbihcInJlYWR5RWxlbWVudFwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKCFfdGhpcy5fZmxpY2tpbmcpIHtcbiAgICAgICAgLy8gUmVuZGVyZXIncyBkZXN0cm95KCkgaXMgY2FsbGVkIGJlZm9yZVxuICAgICAgICBjb250ZW50c1JlYWR5Q2hlY2tlci5kZXN0cm95KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBwYW5lbCA9IGNoZWNraW5nUGFuZWxzW2UuaW5kZXhdO1xuICAgICAgdmFyIGNhbWVyYSA9IGZsaWNraW5nLmNhbWVyYTtcbiAgICAgIHZhciBjb250cm9sID0gZmxpY2tpbmcuY29udHJvbDtcbiAgICAgIHZhciBwcmV2UHJvZ3Jlc3NJblBhbmVsID0gY29udHJvbC5hY3RpdmVQYW5lbCA/IGNhbWVyYS5nZXRQcm9ncmVzc0luUGFuZWwoY29udHJvbC5hY3RpdmVQYW5lbCkgOiAwO1xuICAgICAgcGFuZWwubG9hZGluZyA9IGZhbHNlO1xuICAgICAgcGFuZWwucmVzaXplKCk7XG4gICAgICBwYW5lbHMuc2xpY2UocGFuZWwuaW5kZXggKyAxKS5mb3JFYWNoKGZ1bmN0aW9uIChwYW5lbEJlaGluZCkge1xuICAgICAgICByZXR1cm4gcGFuZWxCZWhpbmQudXBkYXRlUG9zaXRpb24oKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKCFmbGlja2luZy5pbml0aWFsaXplZCkgcmV0dXJuO1xuICAgICAgY2FtZXJhLnVwZGF0ZVJhbmdlKCk7XG4gICAgICBjYW1lcmEudXBkYXRlT2Zmc2V0KCk7XG4gICAgICBjYW1lcmEudXBkYXRlQW5jaG9ycygpO1xuICAgICAgaWYgKGNvbnRyb2wuYW5pbWF0aW5nKSA7IGVsc2Uge1xuICAgICAgICBjb250cm9sLnVwZGF0ZVBvc2l0aW9uKHByZXZQcm9ncmVzc0luUGFuZWwpO1xuICAgICAgICBjb250cm9sLnVwZGF0ZUlucHV0KCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29udGVudHNSZWFkeUNoZWNrZXIub24oXCJwcmVSZWFkeVwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKF90aGlzLl9mbGlja2luZykge1xuICAgICAgICB2b2lkIF90aGlzLnJlbmRlcigpO1xuICAgICAgfVxuICAgICAgaWYgKGUucmVhZHlDb3VudCA9PT0gZS50b3RhbENvdW50KSB7XG4gICAgICAgIGNvbnRlbnRzUmVhZHlDaGVja2VyLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb250ZW50c1JlYWR5Q2hlY2tlci5vbihcInJlYWR5XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChfdGhpcy5fZmxpY2tpbmcpIHtcbiAgICAgICAgdm9pZCBfdGhpcy5yZW5kZXIoKTtcbiAgICAgIH1cbiAgICAgIGNvbnRlbnRzUmVhZHlDaGVja2VyLmRlc3Ryb3koKTtcbiAgICB9KTtcbiAgICBjb250ZW50c1JlYWR5Q2hlY2tlci5jaGVjayhjaGVja2luZ1BhbmVscy5tYXAoZnVuY3Rpb24gKHBhbmVsKSB7XG4gICAgICByZXR1cm4gcGFuZWwuZWxlbWVudDtcbiAgICB9KSk7XG4gIH07XG4gIF9fcHJvdG8uX3VwZGF0ZUNhbWVyYUFuZENvbnRyb2wgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZsaWNraW5nID0gZ2V0RmxpY2tpbmdBdHRhY2hlZCh0aGlzLl9mbGlja2luZyk7XG4gICAgdmFyIGNhbWVyYSA9IGZsaWNraW5nLmNhbWVyYSxcbiAgICAgIGNvbnRyb2wgPSBmbGlja2luZy5jb250cm9sO1xuICAgIGNhbWVyYS51cGRhdGVSYW5nZSgpO1xuICAgIGNhbWVyYS51cGRhdGVPZmZzZXQoKTtcbiAgICBjYW1lcmEudXBkYXRlQW5jaG9ycygpO1xuICAgIGNhbWVyYS5yZXNldE5lZWRQYW5lbEhpc3RvcnkoKTtcbiAgICBjb250cm9sLnVwZGF0ZUlucHV0KCk7XG4gIH07XG4gIF9fcHJvdG8uX3Nob3dPbmx5VmlzaWJsZVBhbmVscyA9IGZ1bmN0aW9uIChmbGlja2luZykge1xuICAgIHZhciBwYW5lbHMgPSBmbGlja2luZy5yZW5kZXJlci5wYW5lbHM7XG4gICAgdmFyIGNhbWVyYSA9IGZsaWNraW5nLmNhbWVyYTtcbiAgICB2YXIgdmlzaWJsZUluZGV4ZXMgPSBjYW1lcmEudmlzaWJsZVBhbmVscy5yZWR1Y2UoZnVuY3Rpb24gKHZpc2libGVzLCBwYW5lbCkge1xuICAgICAgdmlzaWJsZXNbcGFuZWwuaW5kZXhdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB2aXNpYmxlcztcbiAgICB9LCB7fSk7XG4gICAgcGFuZWxzLmZvckVhY2goZnVuY3Rpb24gKHBhbmVsKSB7XG4gICAgICBpZiAocGFuZWwuaW5kZXggaW4gdmlzaWJsZUluZGV4ZXMgfHwgcGFuZWwubG9hZGluZykge1xuICAgICAgICBwYW5lbC5tYXJrRm9yU2hvdygpO1xuICAgICAgfSBlbHNlIGlmICghZmxpY2tpbmcuaG9sZGluZykge1xuICAgICAgICAvLyBEdXJpbmcgdGhlIGlucHV0IHNlcXVlbmNlLFxuICAgICAgICAvLyBEbyBub3QgcmVtb3ZlIHBhbmVsIGVsZW1lbnRzIGFzIGl0IHdvbid0IHRyaWdnZXIgdG91Y2hlbmQgZXZlbnQuXG4gICAgICAgIHBhbmVsLm1hcmtGb3JIaWRlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIF9fcHJvdG8uX3VwZGF0ZVBhbmVsU2l6ZUJ5R3JpZCA9IGZ1bmN0aW9uIChyZWZlcmVuY2VQYW5lbCwgcGFuZWxzKSB7XG4gICAgdmFyIGZsaWNraW5nID0gZ2V0RmxpY2tpbmdBdHRhY2hlZCh0aGlzLl9mbGlja2luZyk7XG4gICAgdmFyIHBhbmVsc1BlclZpZXcgPSBmbGlja2luZy5wYW5lbHNQZXJWaWV3O1xuICAgIGlmIChwYW5lbHNQZXJWaWV3IDw9IDApIHtcbiAgICAgIHRocm93IG5ldyBGbGlja2luZ0Vycm9yKE1FU1NBR0UuV1JPTkdfT1BUSU9OKFwicGFuZWxzUGVyVmlld1wiLCBwYW5lbHNQZXJWaWV3KSwgQ09ERS5XUk9OR19PUFRJT04pO1xuICAgIH1cbiAgICBpZiAocGFuZWxzLmxlbmd0aCA8PSAwKSByZXR1cm47XG4gICAgdmFyIHZpZXdwb3J0U2l6ZSA9IGZsaWNraW5nLmNhbWVyYS5zaXplO1xuICAgIHZhciBnYXAgPSByZWZlcmVuY2VQYW5lbC5tYXJnaW4ucHJldiArIHJlZmVyZW5jZVBhbmVsLm1hcmdpbi5uZXh0O1xuICAgIHZhciBwYW5lbFNpemUgPSAodmlld3BvcnRTaXplIC0gZ2FwICogKHBhbmVsc1BlclZpZXcgLSAxKSkgLyBwYW5lbHNQZXJWaWV3O1xuICAgIHZhciBwYW5lbFNpemVPYmogPSBmbGlja2luZy5ob3Jpem9udGFsID8ge1xuICAgICAgd2lkdGg6IHBhbmVsU2l6ZVxuICAgIH0gOiB7XG4gICAgICBoZWlnaHQ6IHBhbmVsU2l6ZVxuICAgIH07XG4gICAgdmFyIGZpcnN0UGFuZWxTaXplT2JqID0gX19hc3NpZ24kMih7XG4gICAgICBzaXplOiBwYW5lbFNpemUsXG4gICAgICBtYXJnaW46IHJlZmVyZW5jZVBhbmVsLm1hcmdpblxuICAgIH0sICFmbGlja2luZy5ob3Jpem9udGFsICYmIHtcbiAgICAgIGhlaWdodDogcmVmZXJlbmNlUGFuZWwuaGVpZ2h0XG4gICAgfSk7XG4gICAgaWYgKCFmbGlja2luZy5ub1BhbmVsU3R5bGVPdmVycmlkZSkge1xuICAgICAgdGhpcy5fc3RyYXRlZ3kudXBkYXRlUGFuZWxTaXplcyhmbGlja2luZywgcGFuZWxTaXplT2JqKTtcbiAgICB9XG4gICAgZmxpY2tpbmcucGFuZWxzLmZvckVhY2goZnVuY3Rpb24gKHBhbmVsKSB7XG4gICAgICByZXR1cm4gcGFuZWwucmVzaXplKGZpcnN0UGFuZWxTaXplT2JqKTtcbiAgICB9KTtcbiAgfTtcbiAgX19wcm90by5fcmVtb3ZlQWxsQ2hpbGRzRnJvbUNhbWVyYSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZmxpY2tpbmcgPSBnZXRGbGlja2luZ0F0dGFjaGVkKHRoaXMuX2ZsaWNraW5nKTtcbiAgICB2YXIgY2FtZXJhRWxlbWVudCA9IGZsaWNraW5nLmNhbWVyYS5lbGVtZW50O1xuICAgIC8vIFJlbW92ZSBvdGhlciBlbGVtZW50c1xuICAgIHdoaWxlIChjYW1lcmFFbGVtZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgIGNhbWVyYUVsZW1lbnQucmVtb3ZlQ2hpbGQoY2FtZXJhRWxlbWVudC5maXJzdENoaWxkKTtcbiAgICB9XG4gIH07XG4gIF9fcHJvdG8uX2luc2VydFBhbmVsRWxlbWVudHMgPSBmdW5jdGlvbiAocGFuZWxzLCBuZXh0U2libGluZykge1xuICAgIGlmIChuZXh0U2libGluZyA9PT0gdm9pZCAwKSB7XG4gICAgICBuZXh0U2libGluZyA9IG51bGw7XG4gICAgfVxuICAgIHZhciBmbGlja2luZyA9IGdldEZsaWNraW5nQXR0YWNoZWQodGhpcy5fZmxpY2tpbmcpO1xuICAgIHZhciBjYW1lcmEgPSBmbGlja2luZy5jYW1lcmE7XG4gICAgdmFyIGNhbWVyYUVsZW1lbnQgPSBjYW1lcmEuZWxlbWVudDtcbiAgICB2YXIgbmV4dFNpYmxpbmdFbGVtZW50ID0gKG5leHRTaWJsaW5nID09PSBudWxsIHx8IG5leHRTaWJsaW5nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBuZXh0U2libGluZy5lbGVtZW50KSB8fCBudWxsO1xuICAgIHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICBwYW5lbHMuZm9yRWFjaChmdW5jdGlvbiAocGFuZWwpIHtcbiAgICAgIHJldHVybiBmcmFnbWVudC5hcHBlbmRDaGlsZChwYW5lbC5lbGVtZW50KTtcbiAgICB9KTtcbiAgICBjYW1lcmFFbGVtZW50Lmluc2VydEJlZm9yZShmcmFnbWVudCwgbmV4dFNpYmxpbmdFbGVtZW50KTtcbiAgfTtcbiAgX19wcm90by5fcmVtb3ZlUGFuZWxFbGVtZW50cyA9IGZ1bmN0aW9uIChwYW5lbHMpIHtcbiAgICB2YXIgZmxpY2tpbmcgPSBnZXRGbGlja2luZ0F0dGFjaGVkKHRoaXMuX2ZsaWNraW5nKTtcbiAgICB2YXIgY2FtZXJhRWxlbWVudCA9IGZsaWNraW5nLmNhbWVyYS5lbGVtZW50O1xuICAgIHBhbmVscy5mb3JFYWNoKGZ1bmN0aW9uIChwYW5lbCkge1xuICAgICAgY2FtZXJhRWxlbWVudC5yZW1vdmVDaGlsZChwYW5lbC5lbGVtZW50KTtcbiAgICB9KTtcbiAgfTtcbiAgX19wcm90by5fYWZ0ZXJSZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZsaWNraW5nID0gZ2V0RmxpY2tpbmdBdHRhY2hlZCh0aGlzLl9mbGlja2luZyk7XG4gICAgZmxpY2tpbmcuY2FtZXJhLmFwcGx5VHJhbnNmb3JtKCk7XG4gIH07XG4gIHJldHVybiBSZW5kZXJlcjtcbn0oKTtcblxuLyoqXHJcbiAqXHJcbiAqL1xudmFyIFZhbmlsbGFSZW5kZXJlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyQzKFZhbmlsbGFSZW5kZXJlciwgX3N1cGVyKTtcbiAgZnVuY3Rpb24gVmFuaWxsYVJlbmRlcmVyKCkge1xuICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3JlcXVpcmUtYXdhaXRcbiAgdmFyIF9fcHJvdG8gPSBWYW5pbGxhUmVuZGVyZXIucHJvdG90eXBlO1xuICBfX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZmxpY2tpbmcsIHN0cmF0ZWd5O1xuICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBmbGlja2luZyA9IGdldEZsaWNraW5nQXR0YWNoZWQodGhpcy5fZmxpY2tpbmcpO1xuICAgICAgICBzdHJhdGVneSA9IHRoaXMuX3N0cmF0ZWd5O1xuICAgICAgICBzdHJhdGVneS51cGRhdGVSZW5kZXJpbmdQYW5lbHMoZmxpY2tpbmcpO1xuICAgICAgICBzdHJhdGVneS5yZW5kZXJQYW5lbHMoZmxpY2tpbmcpO1xuICAgICAgICB0aGlzLl9yZXNldFBhbmVsRWxlbWVudE9yZGVyKCk7XG4gICAgICAgIHRoaXMuX2FmdGVyUmVuZGVyKCk7XG4gICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIF9fcHJvdG8uX2NvbGxlY3RQYW5lbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZsaWNraW5nID0gZ2V0RmxpY2tpbmdBdHRhY2hlZCh0aGlzLl9mbGlja2luZyk7XG4gICAgdmFyIGNhbWVyYSA9IGZsaWNraW5nLmNhbWVyYTtcbiAgICB0aGlzLl9yZW1vdmVBbGxUZXh0Tm9kZXMoKTtcbiAgICB0aGlzLl9wYW5lbHMgPSB0aGlzLl9zdHJhdGVneS5jb2xsZWN0UGFuZWxzKGZsaWNraW5nLCBjYW1lcmEuY2hpbGRyZW4pO1xuICB9O1xuICBfX3Byb3RvLl9jcmVhdGVQYW5lbCA9IGZ1bmN0aW9uIChlbCwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLl9zdHJhdGVneS5jcmVhdGVQYW5lbChlbCwgb3B0aW9ucyk7XG4gIH07XG4gIF9fcHJvdG8uX3Jlc2V0UGFuZWxFbGVtZW50T3JkZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZsaWNraW5nID0gZ2V0RmxpY2tpbmdBdHRhY2hlZCh0aGlzLl9mbGlja2luZyk7XG4gICAgdmFyIGNhbWVyYUVsID0gZmxpY2tpbmcuY2FtZXJhLmVsZW1lbnQ7XG4gICAgLy8gV2UncmUgdXNpbmcgcmV2ZXJzZWQgcGFuZWxzIGhlcmUgYXMgbGFzdCBwYW5lbCBzaG91bGQgYmUgdGhlIGxhc3QgZWxlbWVudCBvZiBjYW1lcmEgZWxlbWVudFxuICAgIHZhciByZXZlcnNlZEVsZW1lbnRzID0gdGhpcy5fc3RyYXRlZ3kuZ2V0UmVuZGVyaW5nRWxlbWVudHNCeU9yZGVyKGZsaWNraW5nKS5yZXZlcnNlKCk7XG4gICAgcmV2ZXJzZWRFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbCwgaWR4KSB7XG4gICAgICB2YXIgbmV4dEVsID0gcmV2ZXJzZWRFbGVtZW50c1tpZHggLSAxXSA/IHJldmVyc2VkRWxlbWVudHNbaWR4IC0gMV0gOiBudWxsO1xuICAgICAgaWYgKGVsLm5leHRFbGVtZW50U2libGluZyAhPT0gbmV4dEVsKSB7XG4gICAgICAgIGNhbWVyYUVsLmluc2VydEJlZm9yZShlbCwgbmV4dEVsKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgX19wcm90by5fcmVtb3ZlQWxsVGV4dE5vZGVzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBmbGlja2luZyA9IGdldEZsaWNraW5nQXR0YWNoZWQodGhpcy5fZmxpY2tpbmcpO1xuICAgIHZhciBjYW1lcmFFbGVtZW50ID0gZmxpY2tpbmcuY2FtZXJhLmVsZW1lbnQ7XG4gICAgLy8gUmVtb3ZlIGFsbCB0ZXh0IG5vZGVzIGluIHRoZSBjYW1lcmEgZWxlbWVudFxuICAgIHRvQXJyYXkkMihjYW1lcmFFbGVtZW50LmNoaWxkTm9kZXMpLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSkge1xuICAgICAgICBjYW1lcmFFbGVtZW50LnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICByZXR1cm4gVmFuaWxsYVJlbmRlcmVyO1xufShSZW5kZXJlcik7XG5cbi8qKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXG52YXIgRXh0ZXJuYWxSZW5kZXJlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyQzKEV4dGVybmFsUmVuZGVyZXIsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIEV4dGVybmFsUmVuZGVyZXIoKSB7XG4gICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG4gIC8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFycyAqL1xuICB2YXIgX19wcm90byA9IEV4dGVybmFsUmVuZGVyZXIucHJvdG90eXBlO1xuICBfX3Byb3RvLl9yZW1vdmVQYW5lbEVsZW1lbnRzID0gZnVuY3Rpb24gKHBhbmVscykge1xuICAgIC8vIERPIE5PVEhJTkcsIG92ZXJyaWRlZCB0byBwcmV2ZW50IGFuIHVuZXhwZWN0ZWQgZXJyb3JcbiAgfTtcbiAgX19wcm90by5fcmVtb3ZlQWxsQ2hpbGRzRnJvbUNhbWVyYSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBETyBOT1RISU5HLCBvdmVycmlkZWQgdG8gcHJldmVudCBhbiB1bmV4cGVjdGVkIGVycm9yXG4gIH07XG4gIHJldHVybiBFeHRlcm5hbFJlbmRlcmVyO1xufShSZW5kZXJlcik7XG5cbi8qKlxyXG4gKiBBIHNsaWRlIGRhdGEgY29tcG9uZW50IHRoYXQgaG9sZHMgaW5mb3JtYXRpb24gb2YgYSBzaW5nbGUgSFRNTEVsZW1lbnRcclxuICogQGtvIOyKrOudvOydtOuTnCDrjbDsnbTthLAg7Lu07Y+s64SM7Yq466GcLCDri6jsnbwgSFRNTEVsZW1lbnTsnZgg7KCV67O066W8IOqwluqzoCDsnojsirXri4jri6RcclxuICovXG52YXIgUGFuZWwgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcclxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBBbiBvcHRpb25zIG9iamVjdDxrbz7smLXshZgg7Jik67iM7KCd7Yq4PC9rbz5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuaW5kZXhdIEFuIGluaXRpYWwgaW5kZXggb2YgdGhlIHBhbmVsPGtvPu2MqOuEkOydmCDstIjquLAg7J24642x7IqkPC9rbz5cclxuICAgKiBAcGFyYW0ge0NvbnN0YW50cy5BTElHTiB8IHN0cmluZyB8IG51bWJlcn0gW29wdGlvbnMuYWxpZ25dIEFuIGluaXRpYWwge0BsaW5rIEZsaWNraW5nI2FsaWduIGFsaWdufSB2YWx1ZSBvZiB0aGUgcGFuZWw8a28+7Yyo64SQ7J2YIOy0iOq4sCB7QGxpbmsgRmxpY2tpbmcjYWxpZ24gYWxpZ2596rCSPC9rbz5cclxuICAgKiBAcGFyYW0ge0ZsaWNraW5nfSBbb3B0aW9ucy5mbGlja2luZ10gQSBGbGlja2luZyBpbnN0YW5jZSBwYW5lbCdzIHJlZmVyZW5jaW5nPGtvPu2MqOuEkOydtCDssLjsobDtlZjripQge0BsaW5rIEZsaWNraW5nfSDsnbjsiqTthLTsiqQ8L2tvPlxyXG4gICAqIEBwYXJhbSB7RmxpY2tpbmd9IFtvcHRpb25zLmVsZW1lbnRQcm92aWRlcl0gQSBwcm92aWRlciBpbnN0YW5jZSB0aGF0IHJlZGlyZWN0cyBlbGVtZW50czxrbz7si6TsoJwg7JeY66as66i87Yq466W8IOuwmO2ZmO2VmOuKlCDsl5jrpqzrqLztirgg6rO16riJ7J6Q7J2YIOyduOyKpO2EtOyKpDwva28+XHJcbiAgICovXG4gIGZ1bmN0aW9uIFBhbmVsKF9hKSB7XG4gICAgdmFyIGluZGV4ID0gX2EuaW5kZXgsXG4gICAgICBhbGlnbiA9IF9hLmFsaWduLFxuICAgICAgZmxpY2tpbmcgPSBfYS5mbGlja2luZyxcbiAgICAgIGVsZW1lbnRQcm92aWRlciA9IF9hLmVsZW1lbnRQcm92aWRlcjtcbiAgICB0aGlzLl9pbmRleCA9IGluZGV4O1xuICAgIHRoaXMuX2ZsaWNraW5nID0gZmxpY2tpbmc7XG4gICAgdGhpcy5fZWxQcm92aWRlciA9IGVsZW1lbnRQcm92aWRlcjtcbiAgICB0aGlzLl9hbGlnbiA9IGFsaWduO1xuICAgIHRoaXMuX3JlbW92ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZW5kZXJlZCA9IHRydWU7XG4gICAgdGhpcy5fbG9hZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3Jlc2V0SW50ZXJuYWxTdGF0ZXMoKTtcbiAgfVxuICB2YXIgX19wcm90byA9IFBhbmVsLnByb3RvdHlwZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwiZWxlbWVudFwiLCB7XG4gICAgLy8gSW50ZXJuYWwgU3RhdGVzIEdldHRlclxuICAgIC8qKlxyXG4gICAgICogYEhUTUxFbGVtZW50YCB0aGF0IHBhbmVsJ3MgcmVmZXJlbmNpbmdcclxuICAgICAqIEBrbyDtjKjrhJDsnbQg7LC47KGw7ZWY6rOgIOyeiOuKlCBgSFRNTEVsZW1lbnRgXHJcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2VsUHJvdmlkZXIuZWxlbWVudDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwiZWxlbWVudFByb3ZpZGVyXCIsIHtcbiAgICAvKipcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9lbFByb3ZpZGVyO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJpbmRleFwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBJbmRleCBvZiB0aGUgcGFuZWxcclxuICAgICAqIEBrbyDtjKjrhJDsnZgg7J24642x7IqkXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pbmRleDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwicG9zaXRpb25cIiwge1xuICAgIC8qKlxyXG4gICAgICogUG9zaXRpb24gb2YgdGhlIHBhbmVsLCBpbmNsdWRpbmcge0BsaW5rIFBhbmVsI2FsaWduUG9zaXRpb24gYWxpZ25Qb3NpdGlvbn1cclxuICAgICAqIEBrbyDtjKjrhJDsnZgg7ZiE7J6sIOyijO2RnCwge0BsaW5rIFBhbmVsI2FsaWduUG9zaXRpb24gYWxpZ25Qb3NpdGlvbn3snYQg7Y+s7ZWo7ZWY6rOgIOyeiOyKteuLiOuLpFxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcG9zICsgdGhpcy5fYWxpZ25Qb3M7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcInNpemVcIiwge1xuICAgIC8qKlxyXG4gICAgICogQ2FjaGVkIHNpemUgb2YgdGhlIHBhbmVsIGVsZW1lbnRcclxuICAgICAqIFRoaXMgaXMgZXF1YWwgdG8ge0BsaW5rIFBhbmVsI2VsZW1lbnQgZWxlbWVudH0ncyBgb2Zmc2V0V2lkdGhgIGlmIHtAbGluayBGbGlja2luZyNob3Jpem9udGFsIGhvcml6b250YWx9IGlzIGB0cnVlYCwgYW5kIGBvZmZzZXRIZWlnaHRgIGVsc2VcclxuICAgICAqIEBrbyDtjKjrhJAg7JeY66as66i87Yq47J2YIOy6kOyLnOuQnCDtgazquLBcclxuICAgICAqIOydtCDqsJLsnYAge0BsaW5rIEZsaWNraW5nI2hvcml6b250YWwgaG9yaXpvbnRhbH3snbQgYHRydWVg7J28IOqyveyasCB7QGxpbmsgUGFuZWwjZWxlbWVudCBlbGVtZW50feydmCBgb2Zmc2V0V2lkdGhg7JmAIOuPmeydvO2VmOqzoCwgYGZhbHNlYOydvCDqsr3smrAgYG9mZnNldEhlaWdodGDsmYAg64+Z7J287ZWp64uI64ukXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zaXplO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJzaXplSW5jbHVkaW5nTWFyZ2luXCIsIHtcbiAgICAvKipcclxuICAgICAqIFBhbmVsJ3Mgc2l6ZSBpbmNsdWRpbmcgQ1NTIGBtYXJnaW5gXHJcbiAgICAgKiBUaGlzIHZhbHVlIGluY2x1ZGVzIHtAbGluayBQYW5lbCNlbGVtZW50IGVsZW1lbnR9J3MgbWFyZ2luIGxlZnQvcmlnaHQgaWYge0BsaW5rIEZsaWNraW5nI2hvcml6b250YWwgaG9yaXpvbnRhbH0gaXMgYHRydWVgLCBhbmQgbWFyZ2luIHRvcC9ib3R0b20gZWxzZVxyXG4gICAgICogQGtvIENTUyBgbWFyZ2luYOydhCDtj6ztlajtlZwg7Yyo64SQ7J2YIO2BrOq4sFxyXG4gICAgICog7J20IOqwkuydgCB7QGxpbmsgRmxpY2tpbmcjaG9yaXpvbnRhbCBob3Jpem9udGFsfeydtCBgdHJ1ZWDsnbwg6rK97JqwIG1hcmdpbiBsZWZ0L3JpZ2h07J2EIO2PrO2VqO2VmOqzoCwgYGZhbHNlYOydvCDqsr3smrAgbWFyZ2luIHRvcC9ib3R0b23snYQg7Y+s7ZWo7ZWp64uI64ukXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zaXplICsgdGhpcy5fbWFyZ2luLnByZXYgKyB0aGlzLl9tYXJnaW4ubmV4dDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwiaGVpZ2h0XCIsIHtcbiAgICAvKipcclxuICAgICAqIEhlaWdodCBvZiB0aGUgcGFuZWwgZWxlbWVudFxyXG4gICAgICogQGtvIO2MqOuEkCDsl5jrpqzrqLztirjsnZgg64aS7J20XHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9oZWlnaHQ7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcIm1hcmdpblwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBDYWNoZWQgQ1NTIGBtYXJnaW5gIHZhbHVlIG9mIHRoZSBwYW5lbCBlbGVtZW50XHJcbiAgICAgKiBAa28g7Yyo64SQIOyXmOumrOuovO2KuOydmCBDU1MgYG1hcmdpbmAg6rCSXHJcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHByZXYgQ1NTIGBtYXJnaW4tbGVmdGAgd2hlbiB0aGUge0BsaW5rIEZsaWNraW5nI2hvcml6b250YWwgaG9yaXpvbnRhbH0gaXMgYHRydWVgLCBhbmQgYG1hcmdpbi10b3BgIGVsc2VcclxuICAgICAqIDxrbz57QGxpbmsgRmxpY2tpbmcjaG9yaXpvbnRhbCBob3Jpem9udGFsfeydtCBgdHJ1ZWDsnbwg6rK97JqwIGBtYXJnaW4tbGVmdGAsIGBmYWxzZWDsnbwg6rK97JqwIGBtYXJnaW4tdG9wYOyXkCDtlbTri7ntlZjripQg6rCSPC9rbz5cclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBuZXh0IENTUyBgbWFyZ2luLXJpZ2h0YCB3aGVuIHRoZSB7QGxpbmsgRmxpY2tpbmcjaG9yaXpvbnRhbCBob3Jpem9udGFsfSBpcyBgdHJ1ZWAsIGFuZCBgbWFyZ2luLWJvdHRvbWAgZWxzZVxyXG4gICAgICogPGtvPntAbGluayBGbGlja2luZyNob3Jpem9udGFsIGhvcml6b250YWx97J20IGB0cnVlYOydvCDqsr3smrAgYG1hcmdpbi1yaWdodGAsIGBmYWxzZWDsnbwg6rK97JqwIGBtYXJnaW4tYm90dG9tYOyXkCDtlbTri7ntlZjripQg6rCSPC9rbz5cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbWFyZ2luO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJhbGlnblBvc2l0aW9uXCIsIHtcbiAgICAvKipcclxuICAgICAqIEFsaWduIHBvc2l0aW9uIGluc2lkZSB0aGUgcGFuZWwgd2hlcmUge0BsaW5rIENhbWVyYX0ncyB7QGxpbmsgQ2FtZXJhI2FsaWduUG9zaXRpb24gYWxpZ25Qb3NpdGlvbn0gaW5zaWRlIHZpZXdwb3J0IHNob3VsZCBiZSBsb2NhdGVkIGF0XHJcbiAgICAgKiBAa28g7Yyo64SQ7J2YIOygleugrCDquLDspIAg7JyE7LmYLiB7QGxpbmsgQ2FtZXJhfeydmCDrt7Dtj6ztirgg64K07JeQ7ISc7J2YIHtAbGluayBDYW1lcmEjYWxpZ25Qb3NpdGlvbiBhbGlnblBvc2l0aW9ufeydtCDsnITsuZjtlbTslbwg7ZWY64qUIOqzs+yeheuLiOuLpFxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYWxpZ25Qb3M7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcInJlbW92ZWRcIiwge1xuICAgIC8qKlxyXG4gICAgICogQSB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIHBhbmVsJ3Mge0BsaW5rIEZsaWNraW5nI3JlbW92ZSByZW1vdmV9ZFxyXG4gICAgICogQGtvIO2MqOuEkOydtCB7QGxpbmsgRmxpY2tpbmcjcmVtb3ZlIHJlbW92ZX3rkJjsl4jripTsp4Ag7Jes67aA66W8IOuCmO2DgOuCtOuKlCDqsJJcclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZW1vdmVkO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJyZW5kZXJlZFwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBBIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciB0aGUgcGFuZWwncyBlbGVtZW50IGlzIGJlaW5nIHJlbmRlcmVkIG9uIHRoZSBzY3JlZW5cclxuICAgICAqIEBrbyDtjKjrhJDsnZgg7JeY66as66i87Yq46rCAIO2ZlOuptOyDgeyXkCDroIzrjZTrp4HrkJjqs6DsnojripTsp4Ag7Jes67aA66W8IOuCmO2DgOuCtOuKlCDqsJJcclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJlZDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwibG9hZGluZ1wiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBBIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciB0aGUgcGFuZWwncyBpbWFnZS92aWRlbyBpcyBub3QgbG9hZGVkIGFuZCB3YWl0aW5nIGZvciByZXNpemVcclxuICAgICAqIEBrbyDtjKjrhJAg64K067aA7J2YIOydtOuvuOyngC/ruYTrlJTsmKTqsIAg7JWE7KeBIOuhnOuTnOuQmOyngCDslYrslYQge0BsaW5rIFBhbmVsI3Jlc2l6ZSByZXNpemV965CgIOqyg+yduOyngOulvCDrgpjtg4DrgrTripQg6rCSXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbG9hZGluZztcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgdGhpcy5fbG9hZGluZyA9IHZhbDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwicmFuZ2VcIiwge1xuICAgIC8qKlxyXG4gICAgICogUGFuZWwgZWxlbWVudCdzIHJhbmdlIG9mIHRoZSBib3VuZGluZyBib3hcclxuICAgICAqIEBrbyDtjKjrhJAg7JeY66as66i87Yq47J2YIEJvdW5kaW5nIGJveCDrspTsnIRcclxuICAgICAqIEB0eXBlIHtvYmplY3R9XHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gW21pbl0gQm91bmRpbmcgYm94J3MgbGVmdCh7QGxpbmsgRmxpY2tpbmcjaG9yaXpvbnRhbCBob3Jpem9udGFsfTogdHJ1ZSkgLyB0b3Aoe0BsaW5rIEZsaWNraW5nI2hvcml6b250YWwgaG9yaXpvbnRhbH06IGZhbHNlKVxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFttYXhdIEJvdW5kaW5nIGJveCdzIHJpZ2h0KHtAbGluayBGbGlja2luZyNob3Jpem9udGFsIGhvcml6b250YWx9OiB0cnVlKSAvIGJvdHRvbSh7QGxpbmsgRmxpY2tpbmcjaG9yaXpvbnRhbCBob3Jpem9udGFsfTogZmFsc2UpXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWluOiB0aGlzLl9wb3MsXG4gICAgICAgIG1heDogdGhpcy5fcG9zICsgdGhpcy5fc2l6ZVxuICAgICAgfTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwidG9nZ2xlZFwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBBIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciB0aGUgcGFuZWwncyBwb3NpdGlvbiBpcyB0b2dnbGVkIGJ5IGNpcmN1bGFyIGJlaGF2aW9yXHJcbiAgICAgKiBAa28g7Yyo64SQ7J2YIOychOy5mOqwgCBjaXJjdWxhciDrj5nsnpHsl5Ag7J2Y7ZW0IO2GoOq4gOuQmOyXiOuKlOyngCDsl6zrtoDrpbwg64KY7YOA64K064qUIOqwklxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3RvZ2dsZWQ7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcInRvZ2dsZURpcmVjdGlvblwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBBIGRpcmVjdGlvbiB3aGVyZSB0aGUgcGFuZWwncyBwb3NpdGlvbiBpcyB0b2dnbGVkXHJcbiAgICAgKiBAa28g7Yyo64SQ7J2YIOychOy5mOqwgCBjaXJjdWxhciDrj5nsnpHsl5Ag7J2Y7ZW0IO2GoOq4gOuQmOuKlCDrsKntlqVcclxuICAgICAqIEB0eXBlIHtESVJFQ1RJT059XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3RvZ2dsZURpcmVjdGlvbjtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwib2Zmc2V0XCIsIHtcbiAgICAvKipcclxuICAgICAqIEFjdHVhbCBwb3NpdGlvbiBvZmZzZXQgZGV0ZXJtaW5lZCBieSB7QGxpbmsgUGFuZWwjb3JkZXJ9XHJcbiAgICAgKiBAa28ge0BsaW5rIFBhbmVsI29yZGVyfeyXkCDsnZjtlZwg7Iuk7KCcIOychOy5mCDrs4Dqsr3qsJJcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHRvZ2dsZURpcmVjdGlvbiA9IHRoaXMuX3RvZ2dsZURpcmVjdGlvbjtcbiAgICAgIHZhciBjYW1lcmFSYW5nZURpZmYgPSB0aGlzLl9mbGlja2luZy5jYW1lcmEucmFuZ2VEaWZmO1xuICAgICAgcmV0dXJuIHRvZ2dsZURpcmVjdGlvbiA9PT0gRElSRUNUSU9OLk5PTkUgfHwgIXRoaXMuX3RvZ2dsZWQgPyAwIDogdG9nZ2xlRGlyZWN0aW9uID09PSBESVJFQ1RJT04uUFJFViA/IC1jYW1lcmFSYW5nZURpZmYgOiBjYW1lcmFSYW5nZURpZmY7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcInByb2dyZXNzXCIsIHtcbiAgICAvKipcclxuICAgICAqIFByb2dyZXNzIG9mIG1vdmVtZW50IGJldHdlZW4gcHJldmlvdXMgb3IgbmV4dCBwYW5lbCByZWxhdGl2ZSB0byBjdXJyZW50IHBhbmVsXHJcbiAgICAgKiBAa28g7J20IO2MqOuEkOuhnOu2gO2EsCDsnbTsoIQv64uk7J2MIO2MqOuEkOycvOuhnOydmCDsnbTrj5kg7KeE7ZaJ66WgXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBmbGlja2luZyA9IHRoaXMuX2ZsaWNraW5nO1xuICAgICAgcmV0dXJuIHRoaXMuaW5kZXggLSBmbGlja2luZy5jYW1lcmEucHJvZ3Jlc3M7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcIm91dHNldFByb2dyZXNzXCIsIHtcbiAgICAvKipcclxuICAgICAqIFByb2dyZXNzIG9mIG1vdmVtZW50IGJldHdlZW4gcG9pbnRzIHRoYXQgcGFuZWwgaXMgY29tcGxldGVseSBpbnZpc2libGUgb3V0c2lkZSBvZiB2aWV3cG9ydChwcmV2IGRpcmVjdGlvbjogLTEsIHNlbGVjdGVkIHBvaW50OiAwLCBuZXh0IGRpcmVjdGlvbjogMSlcclxuICAgICAqIEBrbyDtmITsnqwg7Yyo64SQ7J20IOu3sO2PrO2KuCDsmIHsl60g67CW7Jy866GcIOyZhOyghO2eiCDsgqzrnbzsp4DripQg7KeA7KCQ7J2EIOq4sOykgOycvOuhnCDtlZjripQg7KeE7ZaJ64+EKHByZXbrsKntlqU6IC0xLCDshKDtg50g7KeA7KCQOiAwLCBuZXh067Cp7ZalOiAxKVxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uICsgdGhpcy5vZmZzZXQ7XG4gICAgICB2YXIgYWxpZ25Qb3NpdGlvbiA9IHRoaXMuX2FsaWduUG9zO1xuICAgICAgdmFyIGNhbWVyYSA9IHRoaXMuX2ZsaWNraW5nLmNhbWVyYTtcbiAgICAgIHZhciBjYW1Qb3MgPSBjYW1lcmEucG9zaXRpb247XG4gICAgICBpZiAoY2FtUG9zID09PSBwb3NpdGlvbikge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIGlmIChjYW1Qb3MgPCBwb3NpdGlvbikge1xuICAgICAgICB2YXIgZGlzYXBwZWFyUG9zTmV4dCA9IHBvc2l0aW9uICsgKGNhbWVyYS5zaXplIC0gY2FtZXJhLmFsaWduUG9zaXRpb24pICsgYWxpZ25Qb3NpdGlvbjtcbiAgICAgICAgcmV0dXJuIC1nZXRQcm9ncmVzcyhjYW1Qb3MsIHBvc2l0aW9uLCBkaXNhcHBlYXJQb3NOZXh0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBkaXNhcHBlYXJQb3NQcmV2ID0gcG9zaXRpb24gLSAoY2FtZXJhLmFsaWduUG9zaXRpb24gKyB0aGlzLl9zaXplIC0gYWxpZ25Qb3NpdGlvbik7XG4gICAgICAgIHJldHVybiAxIC0gZ2V0UHJvZ3Jlc3MoY2FtUG9zLCBkaXNhcHBlYXJQb3NQcmV2LCBwb3NpdGlvbik7XG4gICAgICB9XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcInZpc2libGVSYXRpb1wiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBQZXJjZW50YWdlIG9mIGFyZWEgd2hlcmUgcGFuZWwgaXMgdmlzaWJsZSBpbiB0aGUgdmlld3BvcnRcclxuICAgICAqIEBrbyDrt7Dtj6ztirgg7JWI7JeQ7IScIO2MqOuEkOydtCDrs7TsnbTripQg7JiB7Jet7J2YIOu5hOycqFxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcmFuZ2UgPSB0aGlzLnJhbmdlO1xuICAgICAgdmFyIHNpemUgPSB0aGlzLl9zaXplO1xuICAgICAgdmFyIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgdmFyIHZpc2libGVSYW5nZSA9IHRoaXMuX2ZsaWNraW5nLmNhbWVyYS52aXNpYmxlUmFuZ2U7XG4gICAgICB2YXIgY2hlY2tpbmdSYW5nZSA9IHtcbiAgICAgICAgbWluOiByYW5nZS5taW4gKyBvZmZzZXQsXG4gICAgICAgIG1heDogcmFuZ2UubWF4ICsgb2Zmc2V0XG4gICAgICB9O1xuICAgICAgaWYgKGNoZWNraW5nUmFuZ2UubWF4IDw9IHZpc2libGVSYW5nZS5taW4gfHwgY2hlY2tpbmdSYW5nZS5taW4gPj0gdmlzaWJsZVJhbmdlLm1heCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIHZhciB2aXNpYmxlU2l6ZSA9IHNpemU7XG4gICAgICBpZiAodmlzaWJsZVJhbmdlLm1pbiA+IGNoZWNraW5nUmFuZ2UubWluKSB7XG4gICAgICAgIHZpc2libGVTaXplIC09IHZpc2libGVSYW5nZS5taW4gLSBjaGVja2luZ1JhbmdlLm1pbjtcbiAgICAgIH1cbiAgICAgIGlmICh2aXNpYmxlUmFuZ2UubWF4IDwgY2hlY2tpbmdSYW5nZS5tYXgpIHtcbiAgICAgICAgdmlzaWJsZVNpemUgLT0gY2hlY2tpbmdSYW5nZS5tYXggLSB2aXNpYmxlUmFuZ2UubWF4O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZpc2libGVTaXplIC8gc2l6ZTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwiYWxpZ25cIiwge1xuICAgIC8vIE9wdGlvbnMgR2V0dGVyXG4gICAgLyoqXHJcbiAgICAgKiBBIHZhbHVlIGluZGljYXRpbmcgd2hlcmUgdGhlIHtAbGluayBQYW5lbCNhbGlnblBvc2l0aW9uIGFsaWduUG9zaXRpb259IHNob3VsZCBiZSBsb2NhdGVkIGF0IGluc2lkZSB0aGUgcGFuZWwgZWxlbWVudFxyXG4gICAgICogQGtvIHtAbGluayBQYW5lbCNhbGlnblBvc2l0aW9uIGFsaWduUG9zaXRpb2597J20IO2MqOuEkCDrgrTsnZgg7Ja065SU7JeQIOychOy5mO2VtOyVvCDtlZjripTsp4Drpbwg64KY7YOA64K064qUIOqwklxyXG4gICAgICogQHR5cGUge0NvbnN0YW50cy5BTElHTiB8IHN0cmluZyB8IG51bWJlcn1cclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2FsaWduO1xuICAgIH0sXG4gICAgLy8gT3B0aW9ucyBTZXR0ZXJcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHRoaXMuX2FsaWduID0gdmFsO1xuICAgICAgdGhpcy5fdXBkYXRlQWxpZ25Qb3MoKTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgLyoqXHJcbiAgICogTWFyayBwYW5lbCBlbGVtZW50IHRvIGJlIGFwcGVuZGVkIG9uIHRoZSBjYW1lcmEgZWxlbWVudFxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqL1xuICBfX3Byb3RvLm1hcmtGb3JTaG93ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3JlbmRlcmVkID0gdHJ1ZTtcbiAgICB0aGlzLl9lbFByb3ZpZGVyLnNob3codGhpcy5fZmxpY2tpbmcpO1xuICB9O1xuICAvKipcclxuICAgKiBNYXJrIHBhbmVsIGVsZW1lbnQgdG8gYmUgcmVtb3ZlZCBmcm9tIHRoZSBjYW1lcmEgZWxlbWVudFxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqL1xuICBfX3Byb3RvLm1hcmtGb3JIaWRlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3JlbmRlcmVkID0gZmFsc2U7XG4gICAgdGhpcy5fZWxQcm92aWRlci5oaWRlKHRoaXMuX2ZsaWNraW5nKTtcbiAgfTtcbiAgLyoqXHJcbiAgICogVXBkYXRlIHNpemUgb2YgdGhlIHBhbmVsXHJcbiAgICogQGtvIO2MqOuEkOydmCDtgazquLDrpbwg6rCx7Iug7ZWp64uI64ukXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IGNhY2hlZCBQcmVkZWZpbmVkIGNhY2hlZCBzaXplIG9mIHRoZSBwYW5lbDxrbz7sgqzsoITsl5Ag7LqQ7Iuc65CcIO2MqOuEkOydmCDtgazquLAg7KCV67O0PC9rbz5cclxuICAgKiBAY2hhaW5hYmxlXHJcbiAgICogQHJldHVybiB7dGhpc31cclxuICAgKi9cbiAgX19wcm90by5yZXNpemUgPSBmdW5jdGlvbiAoY2FjaGVkKSB7XG4gICAgdmFyIF9hO1xuICAgIHZhciBlbCA9IHRoaXMuZWxlbWVudDtcbiAgICB2YXIgZmxpY2tpbmcgPSB0aGlzLl9mbGlja2luZztcbiAgICB2YXIgaG9yaXpvbnRhbCA9IGZsaWNraW5nLmhvcml6b250YWwsXG4gICAgICB1c2VGcmFjdGlvbmFsU2l6ZSA9IGZsaWNraW5nLnVzZUZyYWN0aW9uYWxTaXplO1xuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgIHRoaXMuX3NpemUgPSBjYWNoZWQuc2l6ZTtcbiAgICAgIHRoaXMuX21hcmdpbiA9IF9fYXNzaWduJDIoe30sIGNhY2hlZC5tYXJnaW4pO1xuICAgICAgdGhpcy5faGVpZ2h0ID0gKF9hID0gY2FjaGVkLmhlaWdodCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZ2V0RWxlbWVudFNpemUoe1xuICAgICAgICBlbDogZWwsXG4gICAgICAgIGhvcml6b250YWw6IGZhbHNlLFxuICAgICAgICB1c2VGcmFjdGlvbmFsU2l6ZTogdXNlRnJhY3Rpb25hbFNpemUsXG4gICAgICAgIHVzZU9mZnNldDogdHJ1ZSxcbiAgICAgICAgc3R5bGU6IGdldFN0eWxlKGVsKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBlbFN0eWxlID0gZ2V0U3R5bGUoZWwpO1xuICAgICAgdGhpcy5fc2l6ZSA9IGdldEVsZW1lbnRTaXplKHtcbiAgICAgICAgZWw6IGVsLFxuICAgICAgICBob3Jpem9udGFsOiBob3Jpem9udGFsLFxuICAgICAgICB1c2VGcmFjdGlvbmFsU2l6ZTogdXNlRnJhY3Rpb25hbFNpemUsXG4gICAgICAgIHVzZU9mZnNldDogdHJ1ZSxcbiAgICAgICAgc3R5bGU6IGVsU3R5bGVcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fbWFyZ2luID0gaG9yaXpvbnRhbCA/IHtcbiAgICAgICAgcHJldjogcGFyc2VGbG9hdChlbFN0eWxlLm1hcmdpbkxlZnQgfHwgXCIwXCIpLFxuICAgICAgICBuZXh0OiBwYXJzZUZsb2F0KGVsU3R5bGUubWFyZ2luUmlnaHQgfHwgXCIwXCIpXG4gICAgICB9IDoge1xuICAgICAgICBwcmV2OiBwYXJzZUZsb2F0KGVsU3R5bGUubWFyZ2luVG9wIHx8IFwiMFwiKSxcbiAgICAgICAgbmV4dDogcGFyc2VGbG9hdChlbFN0eWxlLm1hcmdpbkJvdHRvbSB8fCBcIjBcIilcbiAgICAgIH07XG4gICAgICB0aGlzLl9oZWlnaHQgPSBob3Jpem9udGFsID8gZ2V0RWxlbWVudFNpemUoe1xuICAgICAgICBlbDogZWwsXG4gICAgICAgIGhvcml6b250YWw6IGZhbHNlLFxuICAgICAgICB1c2VGcmFjdGlvbmFsU2l6ZTogdXNlRnJhY3Rpb25hbFNpemUsXG4gICAgICAgIHVzZU9mZnNldDogdHJ1ZSxcbiAgICAgICAgc3R5bGU6IGVsU3R5bGVcbiAgICAgIH0pIDogdGhpcy5fc2l6ZTtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVQb3NpdGlvbigpO1xuICAgIHRoaXMuX3VwZGF0ZUFsaWduUG9zKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxyXG4gICAqIENoYW5nZSBwYW5lbCdzIHNpemUuIFRoaXMgd2lsbCBjaGFuZ2UgdGhlIGFjdHVhbCBzaXplIG9mIHRoZSBwYW5lbCBlbGVtZW50IGJ5IGNoYW5naW5nIGl0cyBDU1Mgd2lkdGgvaGVpZ2h0IHByb3BlcnR5XHJcbiAgICogQGtvIO2MqOuEkCDtgazquLDrpbwg67OA6rK97ZWp64uI64ukLiDtjKjrhJAg7JeY66as66i87Yq47JeQIO2VtOuLuSDtgazquLDsnZggQ1NTIHdpZHRoL2hlaWdodOulvCDsoIHsmqntlanri4jri6RcclxuICAgKiBAcGFyYW0ge29iamVjdH0gW3NpemVdIE5ldyBwYW5lbCBzaXplPGtvPuyDiCDtjKjrhJAg7YGs6riwPC9rbz5cclxuICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtzaXplLndpZHRoXSBDU1Mgc3RyaW5nIG9yIG51bWJlcihpbiBweCk8a28+Q1NTIOusuOyekOyXtCDrmJDripQg7Iir7J6QKHB4KTwva28+XHJcbiAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbc2l6ZS5oZWlnaHRdIENTUyBzdHJpbmcgb3IgbnVtYmVyKGluIHB4KTxrbz5DU1Mg66y47J6Q7Je0IOuYkOuKlCDsiKvsnpAocHgpPC9rbz5cclxuICAgKiBAY2hhaW5hYmxlXHJcbiAgICogQHJldHVybiB7dGhpc31cclxuICAgKi9cbiAgX19wcm90by5zZXRTaXplID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgICBzZXRTaXplKHRoaXMuZWxlbWVudCwgc2l6ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxyXG4gICAqIENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIGVsZW1lbnQgaXMgaW5zaWRlIG9mIHRoaXMgcGFuZWwncyB7QGxpbmsgUGFuZWwjZWxlbWVudCBlbGVtZW50fVxyXG4gICAqIEBrbyDtlbTri7kg7JeY66as66i87Yq46rCAIOydtCDtjKjrhJDsnZgge0BsaW5rIFBhbmVsI2VsZW1lbnQgZWxlbWVudH0g64K07JeQIO2PrO2VqOuQmOyWtCDsnojripTsp4Drpbwg67CY7ZmY7ZWp64uI64ukXHJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBUaGUgSFRNTEVsZW1lbnQgdG8gY2hlY2s8a28+7ZmV7J247ZWY6rOg7J6QIO2VmOuKlCBIVE1MRWxlbWVudDwva28+XHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gQSBCb29sZWFuIHZhbHVlIGluZGljYXRpbmcgdGhlIGVsZW1lbnQgaXMgaW5zaWRlIG9mIHRoaXMgcGFuZWwge0BsaW5rIFBhbmVsI2VsZW1lbnQgZWxlbWVudH08a28+7Yyo64SQ7J2YIHtAbGluayBQYW5lbCNlbGVtZW50IGVsZW1lbnR964K07JeQIO2VtOuLuSDsl5jrpqzrqLztirgg7Y+s7ZWoIOyXrOu2gDwva28+XHJcbiAgICovXG4gIF9fcHJvdG8uY29udGFpbnMgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gISEoKF9hID0gdGhpcy5lbGVtZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29udGFpbnMoZWxlbWVudCkpO1xuICB9O1xuICAvKipcclxuICAgKiBSZXNldCBpbnRlcm5hbCBzdGF0ZSBhbmQgc2V0IHtAbGluayBQYW5lbCNyZW1vdmVkIHJlbW92ZWR9IHRvIGB0cnVlYFxyXG4gICAqIEBrbyDrgrTrtoAg7IOB7YOc66W8IOy0iOq4sO2ZlO2VmOqzoCB7QGxpbmsgUGFuZWwjcmVtb3ZlZCByZW1vdmVkfeulvCBgdHJ1ZWDroZwg7ISk7KCV7ZWp64uI64ukLlxyXG4gICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICovXG4gIF9fcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9yZXNldEludGVybmFsU3RhdGVzKCk7XG4gICAgdGhpcy5fcmVtb3ZlZCA9IHRydWU7XG4gIH07XG4gIC8qKlxyXG4gICAqIENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHBvc2l0aW9uIGlzIGluc2lkZSBvZiB0aGlzIHBhbmVsJ3Mge0BsaW5rIFBhbmVsI3JhbmdlIHJhbmdlfVxyXG4gICAqIEBrbyDso7zslrTsp4Qg7KKM7ZGc6rCAIO2YhOyerCDtjKjrhJDsnZgge0BsaW5rIFBhbmVsI3JhbmdlIHJhbmdlfeuCtOyXkCDsho3tlbTsnojripTsp4Drpbwg67CY7ZmY7ZWp64uI64ukLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgQSBwb3NpdGlvbiB0byBjaGVjazxrbz7tmZXsnbjtlZjqs6DsnpAg7ZWY64qUIOyijO2RnDwva28+XHJcbiAgICogQHBhcmFtIHtib29sZWFufSBbaW5jbHVkZU1hcmdpbj1mYWxzZV0gSW5jbHVkZSB7QGxpbmsgUGFuZWwjbWFyZ2luIG1hcmdpbn0gdG8gdGhlIHJhbmdlPGtvPu2MqOuEkCDsmIHsl63sl5Age0BsaW5rIFBhbmVsI21hcmdpbiBtYXJnaW596rCS7J2EIO2PrO2VqOyLnO2CteuLiOuLpDwva28+XHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gQSBCb29sZWFuIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciB0aGUgZ2l2ZW4gcG9zaXRpb24gaXMgaW5jbHVkZWQgaW4gdGhlIHBhbmVsIHJhbmdlPGtvPu2VtOuLuSDsooztkZzqsIAg7Yyo64SQIOyYgeyXrSDrgrTsl5Ag7IaN7ZW07J6I64qU7KeAIOyXrOu2gDwva28+XHJcbiAgICovXG4gIF9fcHJvdG8uaW5jbHVkZVBvc2l0aW9uID0gZnVuY3Rpb24gKHBvcywgaW5jbHVkZU1hcmdpbikge1xuICAgIGlmIChpbmNsdWRlTWFyZ2luID09PSB2b2lkIDApIHtcbiAgICAgIGluY2x1ZGVNYXJnaW4gPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuaW5jbHVkZVJhbmdlKHBvcywgcG9zLCBpbmNsdWRlTWFyZ2luKTtcbiAgfTtcbiAgLyoqXHJcbiAgICogQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gcmFuZ2UgaXMgZnVsbHkgaW5jbHVkZWQgaW4gdGhpcyBwYW5lbCdzIGFyZWEgKGluY2x1c2l2ZSlcclxuICAgKiBAa28g7KO87Ja07KeEIOuylOychOqwgCDsnbQg7Yyo64SQIOuCtOu2gOyXkCDsmYTsoITtnogg7Y+s7ZWo65CY64qU7KeA66W8IOuwmO2ZmO2VqeuLiOuLpFxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gTWluaW11bSB2YWx1ZSBvZiB0aGUgcmFuZ2UgdG8gY2hlY2s8a28+7ZmV7J247ZWY6rOg7J6QIO2VmOuKlCDstZzshowg67KU7JyEPC9rbz5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gbWF4IE1heGltdW0gdmFsdWUgb2YgdGhlIHJhbmdlIHRvIGNoZWNrPGtvPu2ZleyduO2VmOqzoOyekCDtlZjripQg7LWc64yAIOuylOychDwva28+XHJcbiAgICogQHBhcmFtIHtib29sZWFufSBbaW5jbHVkZU1hcmdpbj1mYWxzZV0gSW5jbHVkZSB7QGxpbmsgUGFuZWwjbWFyZ2luIG1hcmdpbn0gdG8gdGhlIHJhbmdlPGtvPu2MqOuEkCDsmIHsl63sl5Age0BsaW5rIFBhbmVsI21hcmdpbiBtYXJnaW596rCS7J2EIO2PrO2VqOyLnO2CteuLiOuLpDwva28+XHJcbiAgICogQHJldHVybnMge2Jvb2xlYW59IEEgQm9vbGVhbiB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGdpdmVuIHJhbmdlIGlzIGZ1bGx5IGluY2x1ZGVkIGluIHRoZSBwYW5lbCByYW5nZTxrbz7tlbTri7kg67KU7JyE6rCAIO2MqOuEkCDsmIHsl60g64K07JeQIOyZhOyghO2eiCDsho3tlbTsnojripTsp4Ag7Jes67aAPC9rbz5cclxuICAgKi9cbiAgX19wcm90by5pbmNsdWRlUmFuZ2UgPSBmdW5jdGlvbiAobWluLCBtYXgsIGluY2x1ZGVNYXJnaW4pIHtcbiAgICBpZiAoaW5jbHVkZU1hcmdpbiA9PT0gdm9pZCAwKSB7XG4gICAgICBpbmNsdWRlTWFyZ2luID0gZmFsc2U7XG4gICAgfVxuICAgIHZhciBtYXJnaW4gPSB0aGlzLl9tYXJnaW47XG4gICAgdmFyIHBhbmVsUmFuZ2UgPSB0aGlzLnJhbmdlO1xuICAgIGlmIChpbmNsdWRlTWFyZ2luKSB7XG4gICAgICBwYW5lbFJhbmdlLm1pbiAtPSBtYXJnaW4ucHJldjtcbiAgICAgIHBhbmVsUmFuZ2UubWF4ICs9IG1hcmdpbi5uZXh0O1xuICAgIH1cbiAgICByZXR1cm4gbWF4ID49IHBhbmVsUmFuZ2UubWluICYmIG1pbiA8PSBwYW5lbFJhbmdlLm1heDtcbiAgfTtcbiAgLyoqXHJcbiAgICogQ2hlY2sgd2hldGhlciB0aGUgcGFuZWwgaXMgdmlzYmxlIGluIHRoZSBnaXZlbiByYW5nZSAoZXhjbHVzaXZlKVxyXG4gICAqIEBrbyDso7zslrTsp4Qg67KU7JyEIOuCtOyXkOyEnCDsnbQg7Yyo64SQ7J2YIOydvOu2gOqwgCDrs7Tsl6zsp4DripTsp4Drpbwg67CY7ZmY7ZWp64uI64ukXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG1pbiBNaW5pbXVtIHZhbHVlIG9mIHRoZSByYW5nZSB0byBjaGVjazxrbz7tmZXsnbjtlZjqs6DsnpAg7ZWY64qUIOy1nOyGjCDrspTsnIQ8L2tvPlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtYXggTWF4aW11bSB2YWx1ZSBvZiB0aGUgcmFuZ2UgdG8gY2hlY2s8a28+7ZmV7J247ZWY6rOg7J6QIO2VmOuKlCDstZzrjIAg67KU7JyEPC9rbz5cclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gQSBCb29sZWFuIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciB0aGUgcGFuZWwgaXMgdmlzaWJsZTxrbz7tlbTri7kg67KU7JyEIOuCtOyXkOyEnCDtjKjrhJDsnYQg67O8IOyImCDsnojripTsp4Ag7Jes67aAPC9rbz5cclxuICAgKi9cbiAgX19wcm90by5pc1Zpc2libGVPblJhbmdlID0gZnVuY3Rpb24gKG1pbiwgbWF4KSB7XG4gICAgdmFyIHBhbmVsUmFuZ2UgPSB0aGlzLnJhbmdlO1xuICAgIHJldHVybiBtYXggPiBwYW5lbFJhbmdlLm1pbiAmJiBtaW4gPCBwYW5lbFJhbmdlLm1heDtcbiAgfTtcbiAgLyoqXHJcbiAgICogTW92ZSB7QGxpbmsgQ2FtZXJhfSB0byB0aGlzIHBhbmVsXHJcbiAgICogQGtvIHtAbGluayBDYW1lcmF966W8IOydtCDtjKjrhJDroZwg7J2064+Z7ZWp64uI64ukXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtkdXJhdGlvbl0gRHVyYXRpb24gb2YgdGhlIGFuaW1hdGlvbiAodW5pdDogbXMpPGtvPuyVoOuLiOuplOydtOyFmCDsp4Ttlokg7Iuc6rCEICjri6jsnIQ6IG1zKTwva28+XHJcbiAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59IEEgUHJvbWlzZSB3aGljaCB3aWxsIGJlIHJlc29sdmVkIGFmdGVyIHJlYWNoaW5nIHRoZSBwYW5lbDxrbz7tjKjrhJAg64+E64us7Iuc7JeQIHJlc29sdmXrkJjripQgUHJvbWlzZTwva28+XHJcbiAgICovXG4gIF9fcHJvdG8uZm9jdXMgPSBmdW5jdGlvbiAoZHVyYXRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5fZmxpY2tpbmcubW92ZVRvKHRoaXMuX2luZGV4LCBkdXJhdGlvbik7XG4gIH07XG4gIC8qKlxyXG4gICAqIEdldCBwcmV2aW91cyhgaW5kZXggLSAxYCkgcGFuZWwuIFdoZW4gdGhlIHByZXZpb3VzIHBhbmVsIGRvZXMgbm90IGV4aXN0LCB0aGlzIHdpbGwgcmV0dXJuIGBudWxsYCBpbnN0ZWFkXHJcbiAgICogSWYgdGhlIHtAbGluayBGbGlja2luZyNjaXJjdWxhckVuYWJsZWQgY2lyY3VsYXJ9IGlzIGVuYWJsZWQsIHRoaXMgd2lsbCByZXR1cm4gdGhlIGxhc3QgcGFuZWwgaWYgY2FsbGVkIGZyb20gdGhlIGZpcnN0IHBhbmVsXHJcbiAgICogQGtvIOydtOyghChgaW5kZXggLSAxYCkg7Yyo64SQ7J2EIOuwmO2ZmO2VqeuLiOuLpC4g7J207KCEIO2MqOuEkOydtCDsl4bsnYQg6rK97JqwIGBudWxsYOydhCDrsJjtmZjtlanri4jri6RcclxuICAgKiB7QGxpbmsgRmxpY2tpbmcjY2lyY3VsYXJFbmFibGVkIGNpcmN1bGFyfSDrqqjrk5zqsIAg7Zmc7ISx7ZmU65CY7JeI7J2EIOuVjCDssqvrsojsp7gg7Yyo64SQ7JeQ7IScIOydtCDrqZTshozrk5zrpbwg7Zi47Lac7ZWgIOqyveyasCDrp4jsp4Drp4kg7Yyo64SQ7J2EIOuwmO2ZmO2VqeuLiOuLpFxyXG4gICAqIEByZXR1cm5zIHtQYW5lbCB8IG51bGx9IFRoZSBwcmV2aW91cyBwYW5lbDxrbz7snbTsoIQg7Yyo64SQPC9rbz5cclxuICAgKi9cbiAgX19wcm90by5wcmV2ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpbmRleCA9IHRoaXMuX2luZGV4O1xuICAgIHZhciBmbGlja2luZyA9IHRoaXMuX2ZsaWNraW5nO1xuICAgIHZhciByZW5kZXJlciA9IGZsaWNraW5nLnJlbmRlcmVyO1xuICAgIHZhciBwYW5lbENvdW50ID0gcmVuZGVyZXIucGFuZWxDb3VudDtcbiAgICBpZiAocGFuZWxDb3VudCA9PT0gMSkgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIGZsaWNraW5nLmNpcmN1bGFyRW5hYmxlZCA/IHJlbmRlcmVyLmdldFBhbmVsKGluZGV4ID09PSAwID8gcGFuZWxDb3VudCAtIDEgOiBpbmRleCAtIDEpIDogcmVuZGVyZXIuZ2V0UGFuZWwoaW5kZXggLSAxKTtcbiAgfTtcbiAgLyoqXHJcbiAgICogR2V0IG5leHQoYGluZGV4ICsgMWApIHBhbmVsLiBXaGVuIHRoZSBuZXh0IHBhbmVsIGRvZXMgbm90IGV4aXN0LCB0aGlzIHdpbGwgcmV0dXJuIGBudWxsYCBpbnN0ZWFkXHJcbiAgICogSWYgdGhlIHtAbGluayBGbGlja2luZyNjaXJjdWxhckVuYWJsZWQgY2lyY3VsYXJ9IGlzIGVuYWJsZWQsIHRoaXMgd2lsbCByZXR1cm4gdGhlIGZpcnN0IHBhbmVsIGlmIGNhbGxlZCBmcm9tIHRoZSBsYXN0IHBhbmVsXHJcbiAgICogQGtvIOuLpOydjChgaW5kZXggKyAxYCkg7Yyo64SQ7J2EIOuwmO2ZmO2VqeuLiOuLpC4g64uk7J2MIO2MqOuEkOydtCDsl4bsnYQg6rK97JqwIGBudWxsYOydhCDrsJjtmZjtlanri4jri6RcclxuICAgKiB7QGxpbmsgRmxpY2tpbmcjY2lyY3VsYXJFbmFibGVkIGNpcmN1bGFyfSDrqqjrk5zqsIAg7Zmc7ISx7ZmU65CY7JeI7J2EIOuVjCDrp4jsp4Drp4kg7Yyo64SQ7JeQ7IScIOydtCDrqZTshozrk5zrpbwg7Zi47Lac7ZWgIOqyveyasCDssqvrsojsp7gg7Yyo64SQ7J2EIOuwmO2ZmO2VqeuLiOuLpFxyXG4gICAqIEByZXR1cm5zIHtQYW5lbCB8IG51bGx9IFRoZSBwcmV2aW91cyBwYW5lbDxrbz7ri6TsnYwg7Yyo64SQPC9rbz5cclxuICAgKi9cbiAgX19wcm90by5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpbmRleCA9IHRoaXMuX2luZGV4O1xuICAgIHZhciBmbGlja2luZyA9IHRoaXMuX2ZsaWNraW5nO1xuICAgIHZhciByZW5kZXJlciA9IGZsaWNraW5nLnJlbmRlcmVyO1xuICAgIHZhciBwYW5lbENvdW50ID0gcmVuZGVyZXIucGFuZWxDb3VudDtcbiAgICBpZiAocGFuZWxDb3VudCA9PT0gMSkgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIGZsaWNraW5nLmNpcmN1bGFyRW5hYmxlZCA/IHJlbmRlcmVyLmdldFBhbmVsKGluZGV4ID09PSBwYW5lbENvdW50IC0gMSA/IDAgOiBpbmRleCArIDEpIDogcmVuZGVyZXIuZ2V0UGFuZWwoaW5kZXggKyAxKTtcbiAgfTtcbiAgLyoqXHJcbiAgICogSW5jcmVhc2UgcGFuZWwncyBpbmRleCBieSB0aGUgZ2l2ZW4gdmFsdWVcclxuICAgKiBAa28g7Yyo64SQ7J2YIOyduOuNseyKpOulvCDso7zslrTsp4Qg6rCS66eM7YG8IOymneqwgOyLnO2CteuLiOuLpFxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqIEBjaGFpbmFibGVcclxuICAgKiBAcGFyYW0gdmFsIEFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDA8a28+MOuztOuLpCDqsJnqsbDrgpgg7YGwIOygleyImDwva28+XHJcbiAgICogQHJldHVybnMge3RoaXN9XHJcbiAgICovXG4gIF9fcHJvdG8uaW5jcmVhc2VJbmRleCA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICB0aGlzLl9pbmRleCArPSBNYXRoLm1heCh2YWwsIDApO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcclxuICAgKiBEZWNyZWFzZSBwYW5lbCdzIGluZGV4IGJ5IHRoZSBnaXZlbiB2YWx1ZVxyXG4gICAqIEBrbyDtjKjrhJDsnZgg7J24642x7Iqk66W8IOyjvOyWtOynhCDqsJLrp4ztgbwg6rCQ7IaM7Iuc7YK164uI64ukXHJcbiAgICogQGludGVybmFsXHJcbiAgICogQGNoYWluYWJsZVxyXG4gICAqIEBwYXJhbSB2YWwgQW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMDxrbz4w67O064ukIOqwmeqxsOuCmCDtgbAg7KCV7IiYPC9rbz5cclxuICAgKiBAcmV0dXJucyB7dGhpc31cclxuICAgKi9cbiAgX19wcm90by5kZWNyZWFzZUluZGV4ID0gZnVuY3Rpb24gKHZhbCkge1xuICAgIHRoaXMuX2luZGV4IC09IE1hdGgubWF4KHZhbCwgMCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqL1xuICBfX3Byb3RvLnVwZGF0ZVBvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcmV2UGFuZWwgPSB0aGlzLl9mbGlja2luZy5yZW5kZXJlci5wYW5lbHNbdGhpcy5faW5kZXggLSAxXTtcbiAgICB0aGlzLl9wb3MgPSBwcmV2UGFuZWwgPyBwcmV2UGFuZWwucmFuZ2UubWF4ICsgcHJldlBhbmVsLm1hcmdpbi5uZXh0ICsgdGhpcy5fbWFyZ2luLnByZXYgOiB0aGlzLl9tYXJnaW4ucHJldjtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXHJcbiAgICogQGludGVybmFsXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gdG9nZ2xlZFxyXG4gICAqL1xuICBfX3Byb3RvLnRvZ2dsZSA9IGZ1bmN0aW9uIChwcmV2UG9zLCBuZXdQb3MpIHtcbiAgICB2YXIgdG9nZ2xlRGlyZWN0aW9uID0gdGhpcy5fdG9nZ2xlRGlyZWN0aW9uO1xuICAgIHZhciB0b2dnbGVQb3NpdGlvbiA9IHRoaXMuX3RvZ2dsZVBvc2l0aW9uO1xuICAgIGlmICh0b2dnbGVEaXJlY3Rpb24gPT09IERJUkVDVElPTi5OT05FIHx8IG5ld1BvcyA9PT0gcHJldlBvcykgcmV0dXJuIGZhbHNlO1xuICAgIHZhciBwcmV2VG9nZ2xlZCA9IHRoaXMuX3RvZ2dsZWQ7XG4gICAgaWYgKG5ld1BvcyA+IHByZXZQb3MpIHtcbiAgICAgIGlmICh0b2dnbGVQb3NpdGlvbiA+PSBwcmV2UG9zICYmIHRvZ2dsZVBvc2l0aW9uIDw9IG5ld1Bvcykge1xuICAgICAgICB0aGlzLl90b2dnbGVkID0gdG9nZ2xlRGlyZWN0aW9uID09PSBESVJFQ1RJT04uTkVYVDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRvZ2dsZVBvc2l0aW9uIDw9IHByZXZQb3MgJiYgdG9nZ2xlUG9zaXRpb24gPj0gbmV3UG9zKSB7XG4gICAgICAgIHRoaXMuX3RvZ2dsZWQgPSB0b2dnbGVEaXJlY3Rpb24gIT09IERJUkVDVElPTi5ORVhUO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJldlRvZ2dsZWQgIT09IHRoaXMuX3RvZ2dsZWQ7XG4gIH07XG4gIC8qKlxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqL1xuICBfX3Byb3RvLnVwZGF0ZUNpcmN1bGFyVG9nZ2xlRGlyZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBmbGlja2luZyA9IHRoaXMuX2ZsaWNraW5nO1xuICAgIGlmICghZmxpY2tpbmcuY2lyY3VsYXJFbmFibGVkKSB7XG4gICAgICB0aGlzLl90b2dnbGVEaXJlY3Rpb24gPSBESVJFQ1RJT04uTk9ORTtcbiAgICAgIHRoaXMuX3RvZ2dsZVBvc2l0aW9uID0gMDtcbiAgICAgIHRoaXMuX3RvZ2dsZWQgPSBmYWxzZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB2YXIgY2FtZXJhID0gZmxpY2tpbmcuY2FtZXJhO1xuICAgIHZhciBjYW1SYW5nZSA9IGNhbWVyYS5yYW5nZTtcbiAgICB2YXIgY2FtQWxpZ25Qb3NpdGlvbiA9IGNhbWVyYS5hbGlnblBvc2l0aW9uO1xuICAgIHZhciBjYW1WaXNpYmxlUmFuZ2UgPSBjYW1lcmEudmlzaWJsZVJhbmdlO1xuICAgIHZhciBjYW1WaXNpYmxlU2l6ZSA9IGNhbVZpc2libGVSYW5nZS5tYXggLSBjYW1WaXNpYmxlUmFuZ2UubWluO1xuICAgIHZhciBtaW5pbXVtVmlzaWJsZSA9IGNhbVJhbmdlLm1pbiAtIGNhbUFsaWduUG9zaXRpb247XG4gICAgdmFyIG1heGltdW1WaXNpYmxlID0gY2FtUmFuZ2UubWF4IC0gY2FtQWxpZ25Qb3NpdGlvbiArIGNhbVZpc2libGVTaXplO1xuICAgIHZhciBzaG91bGRCZVZpc2libGVBdE1pbiA9IHRoaXMuaW5jbHVkZVJhbmdlKG1heGltdW1WaXNpYmxlIC0gY2FtVmlzaWJsZVNpemUsIG1heGltdW1WaXNpYmxlLCBmYWxzZSk7XG4gICAgdmFyIHNob3VsZEJlVmlzaWJsZUF0TWF4ID0gdGhpcy5pbmNsdWRlUmFuZ2UobWluaW11bVZpc2libGUsIG1pbmltdW1WaXNpYmxlICsgY2FtVmlzaWJsZVNpemUsIGZhbHNlKTtcbiAgICB0aGlzLl90b2dnbGVkID0gZmFsc2U7XG4gICAgaWYgKHNob3VsZEJlVmlzaWJsZUF0TWluKSB7XG4gICAgICB0aGlzLl90b2dnbGVEaXJlY3Rpb24gPSBESVJFQ1RJT04uUFJFVjtcbiAgICAgIHRoaXMuX3RvZ2dsZVBvc2l0aW9uID0gdGhpcy5yYW5nZS5tYXggKyBjYW1SYW5nZS5taW4gLSBjYW1SYW5nZS5tYXggKyBjYW1BbGlnblBvc2l0aW9uO1xuICAgICAgdGhpcy50b2dnbGUoSW5maW5pdHksIGNhbWVyYS5wb3NpdGlvbik7XG4gICAgfSBlbHNlIGlmIChzaG91bGRCZVZpc2libGVBdE1heCkge1xuICAgICAgdGhpcy5fdG9nZ2xlRGlyZWN0aW9uID0gRElSRUNUSU9OLk5FWFQ7XG4gICAgICB0aGlzLl90b2dnbGVQb3NpdGlvbiA9IHRoaXMucmFuZ2UubWluICsgY2FtUmFuZ2UubWF4IC0gY2FtVmlzaWJsZVNpemUgKyBjYW1BbGlnblBvc2l0aW9uO1xuICAgICAgdGhpcy50b2dnbGUoLUluZmluaXR5LCBjYW1lcmEucG9zaXRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl90b2dnbGVEaXJlY3Rpb24gPSBESVJFQ1RJT04uTk9ORTtcbiAgICAgIHRoaXMuX3RvZ2dsZVBvc2l0aW9uID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIF9fcHJvdG8uX3VwZGF0ZUFsaWduUG9zID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2FsaWduUG9zID0gcGFyc2VBbGlnbiQxKHRoaXMuX2FsaWduLCB0aGlzLl9zaXplKTtcbiAgfTtcbiAgX19wcm90by5fcmVzZXRJbnRlcm5hbFN0YXRlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9zaXplID0gMDtcbiAgICB0aGlzLl9wb3MgPSAwO1xuICAgIHRoaXMuX21hcmdpbiA9IHtcbiAgICAgIHByZXY6IDAsXG4gICAgICBuZXh0OiAwXG4gICAgfTtcbiAgICB0aGlzLl9oZWlnaHQgPSAwO1xuICAgIHRoaXMuX2FsaWduUG9zID0gMDtcbiAgICB0aGlzLl90b2dnbGVkID0gZmFsc2U7XG4gICAgdGhpcy5fdG9nZ2xlUG9zaXRpb24gPSAwO1xuICAgIHRoaXMuX3RvZ2dsZURpcmVjdGlvbiA9IERJUkVDVElPTi5OT05FO1xuICB9O1xuICByZXR1cm4gUGFuZWw7XG59KCk7XG5cbnZhciBOb3JtYWxSZW5kZXJpbmdTdHJhdGVneSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE5vcm1hbFJlbmRlcmluZ1N0cmF0ZWd5KF9hKSB7XG4gICAgdmFyIHByb3ZpZGVyQ3RvciA9IF9hLnByb3ZpZGVyQ3RvcjtcbiAgICB0aGlzLl9wcm92aWRlckN0b3IgPSBwcm92aWRlckN0b3I7XG4gIH1cbiAgdmFyIF9fcHJvdG8gPSBOb3JtYWxSZW5kZXJpbmdTdHJhdGVneS5wcm90b3R5cGU7XG4gIF9fcHJvdG8ucmVuZGVyUGFuZWxzID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIERPX05PVEhJTkdcbiAgfTtcbiAgX19wcm90by5nZXRSZW5kZXJpbmdJbmRleGVzQnlPcmRlciA9IGZ1bmN0aW9uIChmbGlja2luZykge1xuICAgIHZhciByZW5kZXJlZFBhbmVscyA9IGZsaWNraW5nLnJlbmRlcmVyLnBhbmVscy5maWx0ZXIoZnVuY3Rpb24gKHBhbmVsKSB7XG4gICAgICByZXR1cm4gcGFuZWwucmVuZGVyZWQ7XG4gICAgfSk7XG4gICAgdmFyIHRvZ2dsZWRQcmV2ID0gcmVuZGVyZWRQYW5lbHMuZmlsdGVyKGZ1bmN0aW9uIChwYW5lbCkge1xuICAgICAgcmV0dXJuIHBhbmVsLnRvZ2dsZWQgJiYgcGFuZWwudG9nZ2xlRGlyZWN0aW9uID09PSBESVJFQ1RJT04uUFJFVjtcbiAgICB9KTtcbiAgICB2YXIgdG9nZ2xlZE5leHQgPSByZW5kZXJlZFBhbmVscy5maWx0ZXIoZnVuY3Rpb24gKHBhbmVsKSB7XG4gICAgICByZXR1cm4gcGFuZWwudG9nZ2xlZCAmJiBwYW5lbC50b2dnbGVEaXJlY3Rpb24gPT09IERJUkVDVElPTi5ORVhUO1xuICAgIH0pO1xuICAgIHZhciBub3RUb2dnbGVkID0gcmVuZGVyZWRQYW5lbHMuZmlsdGVyKGZ1bmN0aW9uIChwYW5lbCkge1xuICAgICAgcmV0dXJuICFwYW5lbC50b2dnbGVkO1xuICAgIH0pO1xuICAgIHJldHVybiBfX3NwcmVhZCQxKHRvZ2dsZWRQcmV2LCBub3RUb2dnbGVkLCB0b2dnbGVkTmV4dCkubWFwKGZ1bmN0aW9uIChwYW5lbCkge1xuICAgICAgcmV0dXJuIHBhbmVsLmluZGV4O1xuICAgIH0pO1xuICB9O1xuICBfX3Byb3RvLmdldFJlbmRlcmluZ0VsZW1lbnRzQnlPcmRlciA9IGZ1bmN0aW9uIChmbGlja2luZykge1xuICAgIHZhciBwYW5lbHMgPSBmbGlja2luZy5wYW5lbHM7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UmVuZGVyaW5nSW5kZXhlc0J5T3JkZXIoZmxpY2tpbmcpLm1hcChmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgIHJldHVybiBwYW5lbHNbaW5kZXhdLmVsZW1lbnQ7XG4gICAgfSk7XG4gIH07XG4gIF9fcHJvdG8udXBkYXRlUmVuZGVyaW5nUGFuZWxzID0gZnVuY3Rpb24gKGZsaWNraW5nKSB7XG4gICAgaWYgKGZsaWNraW5nLnJlbmRlck9ubHlWaXNpYmxlKSB7XG4gICAgICB0aGlzLl9zaG93T25seVZpc2libGVQYW5lbHMoZmxpY2tpbmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmbGlja2luZy5wYW5lbHMuZm9yRWFjaChmdW5jdGlvbiAocGFuZWwpIHtcbiAgICAgICAgcmV0dXJuIHBhbmVsLm1hcmtGb3JTaG93KCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIF9fcHJvdG8uY29sbGVjdFBhbmVscyA9IGZ1bmN0aW9uIChmbGlja2luZywgZWxlbWVudHMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHZhciBhbGlnbiA9IHBhcnNlUGFuZWxBbGlnbihmbGlja2luZy5yZW5kZXJlci5hbGlnbik7XG4gICAgcmV0dXJuIGVsZW1lbnRzLm1hcChmdW5jdGlvbiAoZWwsIGluZGV4KSB7XG4gICAgICByZXR1cm4gbmV3IFBhbmVsKHtcbiAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICBlbGVtZW50UHJvdmlkZXI6IG5ldyBfdGhpcy5fcHJvdmlkZXJDdG9yKGVsKSxcbiAgICAgICAgYWxpZ246IGFsaWduLFxuICAgICAgICBmbGlja2luZzogZmxpY2tpbmdcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuICBfX3Byb3RvLmNyZWF0ZVBhbmVsID0gZnVuY3Rpb24gKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFBhbmVsKF9fYXNzaWduJDIoX19hc3NpZ24kMih7fSwgb3B0aW9ucyksIHtcbiAgICAgIGVsZW1lbnRQcm92aWRlcjogbmV3IHRoaXMuX3Byb3ZpZGVyQ3RvcihlbGVtZW50KVxuICAgIH0pKTtcbiAgfTtcbiAgX19wcm90by51cGRhdGVQYW5lbFNpemVzID0gZnVuY3Rpb24gKGZsaWNraW5nLCBzaXplKSB7XG4gICAgZmxpY2tpbmcucGFuZWxzLmZvckVhY2goZnVuY3Rpb24gKHBhbmVsKSB7XG4gICAgICByZXR1cm4gcGFuZWwuc2V0U2l6ZShzaXplKTtcbiAgICB9KTtcbiAgfTtcbiAgX19wcm90by5fc2hvd09ubHlWaXNpYmxlUGFuZWxzID0gZnVuY3Rpb24gKGZsaWNraW5nKSB7XG4gICAgdmFyIHBhbmVscyA9IGZsaWNraW5nLnJlbmRlcmVyLnBhbmVscztcbiAgICB2YXIgY2FtZXJhID0gZmxpY2tpbmcuY2FtZXJhO1xuICAgIHZhciB2aXNpYmxlSW5kZXhlcyA9IGNhbWVyYS52aXNpYmxlUGFuZWxzLnJlZHVjZShmdW5jdGlvbiAodmlzaWJsZXMsIHBhbmVsKSB7XG4gICAgICB2aXNpYmxlc1twYW5lbC5pbmRleF0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHZpc2libGVzO1xuICAgIH0sIHt9KTtcbiAgICBwYW5lbHMuZm9yRWFjaChmdW5jdGlvbiAocGFuZWwpIHtcbiAgICAgIGlmIChwYW5lbC5pbmRleCBpbiB2aXNpYmxlSW5kZXhlcyB8fCBwYW5lbC5sb2FkaW5nKSB7XG4gICAgICAgIHBhbmVsLm1hcmtGb3JTaG93KCk7XG4gICAgICB9IGVsc2UgaWYgKCFmbGlja2luZy5ob2xkaW5nKSB7XG4gICAgICAgIC8vIER1cmluZyB0aGUgaW5wdXQgc2VxdWVuY2UsXG4gICAgICAgIC8vIERvIG5vdCByZW1vdmUgcGFuZWwgZWxlbWVudHMgYXMgaXQgd29uJ3QgdHJpZ2dlciB0b3VjaGVuZCBldmVudC5cbiAgICAgICAgcGFuZWwubWFya0ZvckhpZGUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjYW1lcmEudXBkYXRlT2Zmc2V0KCk7XG4gIH07XG4gIHJldHVybiBOb3JtYWxSZW5kZXJpbmdTdHJhdGVneTtcbn0oKTtcblxuLyoqXHJcbiAqIEFuIHNsaWRlIGRhdGEgY29tcG9uZW50IHRoYXQgaG9sZHMgaW5mb3JtYXRpb24gb2YgYSBzaW5nbGUgSFRNTEVsZW1lbnRcclxuICogQGtvIOyKrOudvOydtOuTnCDrjbDsnbTthLAg7Lu07Y+s64SM7Yq466GcLCDri6jsnbwgSFRNTEVsZW1lbnTsnZgg7KCV67O066W8IOqwluqzoCDsnojsirXri4jri6RcclxuICovXG52YXIgVmlydHVhbFBhbmVsID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzJDMoVmlydHVhbFBhbmVsLCBfc3VwZXIpO1xuICAvKipcclxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBBbiBvcHRpb25zIG9iamVjdDxrbz7smLXshZgg7Jik67iM7KCd7Yq4PC9rbz5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuaW5kZXhdIEFuIGluaXRpYWwgaW5kZXggb2YgdGhlIHBhbmVsPGtvPu2MqOuEkOydmCDstIjquLAg7J24642x7IqkPC9rbz5cclxuICAgKiBAcGFyYW0ge0NvbnN0YW50cy5BTElHTiB8IHN0cmluZyB8IG51bWJlcn0gW29wdGlvbnMuYWxpZ25dIEFuIGluaXRpYWwge0BsaW5rIEZsaWNraW5nI2FsaWduIGFsaWdufSB2YWx1ZSBvZiB0aGUgcGFuZWw8a28+7Yyo64SQ7J2YIOy0iOq4sCB7QGxpbmsgRmxpY2tpbmcjYWxpZ24gYWxpZ2596rCSPC9rbz5cclxuICAgKiBAcGFyYW0ge0ZsaWNraW5nfSBbb3B0aW9ucy5mbGlja2luZ10gQSBGbGlja2luZyBpbnN0YW5jZSBwYW5lbCdzIHJlZmVyZW5jaW5nPGtvPu2MqOuEkOydtCDssLjsobDtlZjripQge0BsaW5rIEZsaWNraW5nfSDsnbjsiqTthLTsiqQ8L2tvPlxyXG4gICAqL1xuICBmdW5jdGlvbiBWaXJ0dWFsUGFuZWwob3B0aW9ucykge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMpIHx8IHRoaXM7XG4gICAgb3B0aW9ucy5lbGVtZW50UHJvdmlkZXIuaW5pdChfdGhpcyk7XG4gICAgX3RoaXMuX2VsUHJvdmlkZXIgPSBvcHRpb25zLmVsZW1lbnRQcm92aWRlcjtcbiAgICBfdGhpcy5fY2FjaGVkSW5uZXJIVE1MID0gbnVsbDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgdmFyIF9fcHJvdG8gPSBWaXJ0dWFsUGFuZWwucHJvdG90eXBlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJlbGVtZW50XCIsIHtcbiAgICAvKipcclxuICAgICAqIGBIVE1MRWxlbWVudGAgdGhhdCBwYW5lbCdzIHJlZmVyZW5jaW5nXHJcbiAgICAgKiBAa28g7Yyo64SQ7J20IOywuOyhsO2VmOqzoCDsnojripQgYEhUTUxFbGVtZW50YFxyXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9lbFByb3ZpZGVyLmVsZW1lbnQ7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcImNhY2hlZElubmVySFRNTFwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBDYWNoZWQgaW5uZXJIVE1MIGJ5IHRoZSBwcmV2aW91cyByZW5kZXIgZnVuY3Rpb25cclxuICAgICAqIEBrbyDsnbTsoIQg66CM642U66eB7JeQ7IScIOy6kOyLnOuQnCBpbm5lckhUTUwg7KCV67O0XHJcbiAgICAgKiBAdHlwZSB7c3RyaW5nfG51bGx9XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlZElubmVySFRNTDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwiZWxlbWVudEluZGV4XCIsIHtcbiAgICAvKipcclxuICAgICAqIEFuIG51bWJlciBmb3IgaW5kZXhpbmcgd2hpY2ggZWxlbWVudCBpdCB3aWxsIGJlIHJlbmRlcmVkIG9uXHJcbiAgICAgKiBAa28g66qHIOuyiOynuCDsl5jrpqzrqLztirjsl5Ag66CM642U66eB65CgIOqyg+yduOyngOulvCDrgpjtg4DrgrTripQg7Iir7J6QXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBmbGlja2luZyA9IHRoaXMuX2ZsaWNraW5nO1xuICAgICAgdmFyIHZpcnR1YWxFbENvdW50ID0gZmxpY2tpbmcucGFuZWxzUGVyVmlldyArIDE7XG4gICAgICB2YXIgcGFuZWxDb3VudCA9IGZsaWNraW5nLnBhbmVsQ291bnQ7XG4gICAgICB2YXIgaW5kZXggPSB0aGlzLl9pbmRleDtcbiAgICAgIGlmICh0aGlzLl90b2dnbGVkKSB7XG4gICAgICAgIC8vIFRvIHByZXZlbnQgZWxlbWVudCBkdXBsaWNhdGlvblxuICAgICAgICBpbmRleCA9IHRoaXMuX3RvZ2dsZURpcmVjdGlvbiA9PT0gRElSRUNUSU9OLk5FWFQgPyBpbmRleCArIHBhbmVsQ291bnQgOiBpbmRleCAtIHBhbmVsQ291bnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2lyY3VsYXRlSW5kZXgoaW5kZXgsIHZpcnR1YWxFbENvdW50KTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgX19wcm90by5jYWNoZVJlbmRlclJlc3VsdCA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICB0aGlzLl9jYWNoZWRJbm5lckhUTUwgPSByZXN1bHQ7XG4gIH07XG4gIF9fcHJvdG8udW5jYWNoZVJlbmRlclJlc3VsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9jYWNoZWRJbm5lckhUTUwgPSBudWxsO1xuICB9O1xuICBfX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZmxpY2tpbmcgPSB0aGlzLl9mbGlja2luZztcbiAgICB2YXIgX2EgPSBmbGlja2luZy52aXJ0dWFsLFxuICAgICAgcmVuZGVyUGFuZWwgPSBfYS5yZW5kZXJQYW5lbCxcbiAgICAgIGNhY2hlID0gX2EuY2FjaGU7XG4gICAgdmFyIGVsZW1lbnQgPSB0aGlzLl9lbFByb3ZpZGVyLmVsZW1lbnQ7XG4gICAgdmFyIG5ld0lubmVySFRNTCA9IHRoaXMuX2NhY2hlZElubmVySFRNTCB8fCByZW5kZXJQYW5lbCh0aGlzLCB0aGlzLl9pbmRleCk7XG4gICAgaWYgKG5ld0lubmVySFRNTCA9PT0gZWxlbWVudC5pbm5lckhUTUwpIHJldHVybjtcbiAgICBlbGVtZW50LmlubmVySFRNTCA9IG5ld0lubmVySFRNTDtcbiAgICBpZiAoY2FjaGUpIHtcbiAgICAgIHRoaXMuY2FjaGVSZW5kZXJSZXN1bHQobmV3SW5uZXJIVE1MKTtcbiAgICB9XG4gIH07XG4gIF9fcHJvdG8uaW5jcmVhc2VJbmRleCA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICB0aGlzLnVuY2FjaGVSZW5kZXJSZXN1bHQoKTtcbiAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5pbmNyZWFzZUluZGV4LmNhbGwodGhpcywgdmFsKTtcbiAgfTtcbiAgX19wcm90by5kZWNyZWFzZUluZGV4ID0gZnVuY3Rpb24gKHZhbCkge1xuICAgIHRoaXMudW5jYWNoZVJlbmRlclJlc3VsdCgpO1xuICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmRlY3JlYXNlSW5kZXguY2FsbCh0aGlzLCB2YWwpO1xuICB9O1xuICByZXR1cm4gVmlydHVhbFBhbmVsO1xufShQYW5lbCk7XG5cbnZhciBWaXJ0dWFsUmVuZGVyaW5nU3RyYXRlZ3kgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBWaXJ0dWFsUmVuZGVyaW5nU3RyYXRlZ3koKSB7fVxuICB2YXIgX19wcm90byA9IFZpcnR1YWxSZW5kZXJpbmdTdHJhdGVneS5wcm90b3R5cGU7XG4gIF9fcHJvdG8ucmVuZGVyUGFuZWxzID0gZnVuY3Rpb24gKGZsaWNraW5nKSB7XG4gICAgdmFyIHZpcnR1YWxNYW5hZ2VyID0gZmxpY2tpbmcudmlydHVhbDtcbiAgICB2YXIgdmlzaWJsZVBhbmVscyA9IGZsaWNraW5nLnZpc2libGVQYW5lbHM7XG4gICAgdmFyIGludmlzaWJsZUluZGV4ZXMgPSByYW5nZShmbGlja2luZy5wYW5lbHNQZXJWaWV3ICsgMSk7XG4gICAgdmlzaWJsZVBhbmVscy5mb3JFYWNoKGZ1bmN0aW9uIChwYW5lbCkge1xuICAgICAgdmFyIGVsZW1lbnRJbmRleCA9IHBhbmVsLmVsZW1lbnRJbmRleDtcbiAgICAgIHBhbmVsLnJlbmRlcigpO1xuICAgICAgdmlydHVhbE1hbmFnZXIuc2hvdyhlbGVtZW50SW5kZXgpO1xuICAgICAgaW52aXNpYmxlSW5kZXhlc1tlbGVtZW50SW5kZXhdID0gLTE7XG4gICAgfSk7XG4gICAgaW52aXNpYmxlSW5kZXhlcy5maWx0ZXIoZnVuY3Rpb24gKHZhbCkge1xuICAgICAgcmV0dXJuIHZhbCA+PSAwO1xuICAgIH0pLmZvckVhY2goZnVuY3Rpb24gKGlkeCkge1xuICAgICAgdmlydHVhbE1hbmFnZXIuaGlkZShpZHgpO1xuICAgIH0pO1xuICB9O1xuICBfX3Byb3RvLmdldFJlbmRlcmluZ0luZGV4ZXNCeU9yZGVyID0gZnVuY3Rpb24gKGZsaWNraW5nKSB7XG4gICAgdmFyIHZpcnR1YWxNYW5hZ2VyID0gZmxpY2tpbmcudmlydHVhbDtcbiAgICB2YXIgdmlzaWJsZVBhbmVscyA9IF9fc3ByZWFkJDEoZmxpY2tpbmcudmlzaWJsZVBhbmVscykuZmlsdGVyKGZ1bmN0aW9uIChwYW5lbCkge1xuICAgICAgcmV0dXJuIHBhbmVsLnJlbmRlcmVkO1xuICAgIH0pLnNvcnQoZnVuY3Rpb24gKHBhbmVsMSwgcGFuZWwyKSB7XG4gICAgICByZXR1cm4gcGFuZWwxLnBvc2l0aW9uICsgcGFuZWwxLm9mZnNldCAtIChwYW5lbDIucG9zaXRpb24gKyBwYW5lbDIub2Zmc2V0KTtcbiAgICB9KTtcbiAgICBpZiAodmlzaWJsZVBhbmVscy5sZW5ndGggPD0gMCkgcmV0dXJuIHZpcnR1YWxNYW5hZ2VyLmVsZW1lbnRzLm1hcChmdW5jdGlvbiAoXywgaWR4KSB7XG4gICAgICByZXR1cm4gaWR4O1xuICAgIH0pO1xuICAgIHZhciB2aXNpYmxlSW5kZXhlcyA9IHZpc2libGVQYW5lbHMubWFwKGZ1bmN0aW9uIChwYW5lbCkge1xuICAgICAgcmV0dXJuIHBhbmVsLmVsZW1lbnRJbmRleDtcbiAgICB9KTtcbiAgICB2YXIgaW52aXNpYmxlSW5kZXhlcyA9IHZpcnR1YWxNYW5hZ2VyLmVsZW1lbnRzLm1hcChmdW5jdGlvbiAoZWwsIGlkeCkge1xuICAgICAgcmV0dXJuIF9fYXNzaWduJDIoX19hc3NpZ24kMih7fSwgZWwpLCB7XG4gICAgICAgIGlkeDogaWR4XG4gICAgICB9KTtcbiAgICB9KS5maWx0ZXIoZnVuY3Rpb24gKGVsKSB7XG4gICAgICByZXR1cm4gIWVsLnZpc2libGU7XG4gICAgfSkubWFwKGZ1bmN0aW9uIChlbCkge1xuICAgICAgcmV0dXJuIGVsLmlkeDtcbiAgICB9KTtcbiAgICByZXR1cm4gX19zcHJlYWQkMSh2aXNpYmxlSW5kZXhlcywgaW52aXNpYmxlSW5kZXhlcyk7XG4gIH07XG4gIF9fcHJvdG8uZ2V0UmVuZGVyaW5nRWxlbWVudHNCeU9yZGVyID0gZnVuY3Rpb24gKGZsaWNraW5nKSB7XG4gICAgdmFyIHZpcnR1YWxNYW5hZ2VyID0gZmxpY2tpbmcudmlydHVhbDtcbiAgICB2YXIgZWxlbWVudHMgPSB2aXJ0dWFsTWFuYWdlci5lbGVtZW50cztcbiAgICByZXR1cm4gdGhpcy5nZXRSZW5kZXJpbmdJbmRleGVzQnlPcmRlcihmbGlja2luZykubWFwKGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnRzW2luZGV4XS5uYXRpdmVFbGVtZW50O1xuICAgIH0pO1xuICB9O1xuICBfX3Byb3RvLnVwZGF0ZVJlbmRlcmluZ1BhbmVscyA9IGZ1bmN0aW9uIChmbGlja2luZykge1xuICAgIHZhciBwYW5lbHMgPSBmbGlja2luZy5yZW5kZXJlci5wYW5lbHM7XG4gICAgdmFyIGNhbWVyYSA9IGZsaWNraW5nLmNhbWVyYTtcbiAgICB2YXIgdmlzaWJsZUluZGV4ZXMgPSBjYW1lcmEudmlzaWJsZVBhbmVscy5yZWR1Y2UoZnVuY3Rpb24gKHZpc2libGVzLCBwYW5lbCkge1xuICAgICAgdmlzaWJsZXNbcGFuZWwuaW5kZXhdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB2aXNpYmxlcztcbiAgICB9LCB7fSk7XG4gICAgcGFuZWxzLmZvckVhY2goZnVuY3Rpb24gKHBhbmVsKSB7XG4gICAgICBpZiAocGFuZWwuaW5kZXggaW4gdmlzaWJsZUluZGV4ZXMgfHwgcGFuZWwubG9hZGluZykge1xuICAgICAgICBwYW5lbC5tYXJrRm9yU2hvdygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFuZWwubWFya0ZvckhpZGUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjYW1lcmEudXBkYXRlT2Zmc2V0KCk7XG4gIH07XG4gIF9fcHJvdG8uY29sbGVjdFBhbmVscyA9IGZ1bmN0aW9uIChmbGlja2luZykge1xuICAgIHZhciBhbGlnbiA9IHBhcnNlUGFuZWxBbGlnbihmbGlja2luZy5yZW5kZXJlci5hbGlnbik7XG4gICAgcmV0dXJuIHJhbmdlKGZsaWNraW5nLnZpcnR1YWwuaW5pdGlhbFBhbmVsQ291bnQpLm1hcChmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgIHJldHVybiBuZXcgVmlydHVhbFBhbmVsKHtcbiAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICBlbGVtZW50UHJvdmlkZXI6IG5ldyBWaXJ0dWFsRWxlbWVudFByb3ZpZGVyKGZsaWNraW5nKSxcbiAgICAgICAgYWxpZ246IGFsaWduLFxuICAgICAgICBmbGlja2luZzogZmxpY2tpbmdcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuICBfX3Byb3RvLmNyZWF0ZVBhbmVsID0gZnVuY3Rpb24gKF9lbCwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgVmlydHVhbFBhbmVsKF9fYXNzaWduJDIoX19hc3NpZ24kMih7fSwgb3B0aW9ucyksIHtcbiAgICAgIGVsZW1lbnRQcm92aWRlcjogbmV3IFZpcnR1YWxFbGVtZW50UHJvdmlkZXIob3B0aW9ucy5mbGlja2luZylcbiAgICB9KSk7XG4gIH07XG4gIF9fcHJvdG8udXBkYXRlUGFuZWxTaXplcyA9IGZ1bmN0aW9uIChmbGlja2luZywgc2l6ZSkge1xuICAgIGZsaWNraW5nLnZpcnR1YWwuZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgIHNldFNpemUoZWwubmF0aXZlRWxlbWVudCwgc2l6ZSk7XG4gICAgfSk7XG4gICAgZmxpY2tpbmcucGFuZWxzLmZvckVhY2goZnVuY3Rpb24gKHBhbmVsKSB7XG4gICAgICByZXR1cm4gcGFuZWwuc2V0U2l6ZShzaXplKTtcbiAgICB9KTtcbiAgfTtcbiAgcmV0dXJuIFZpcnR1YWxSZW5kZXJpbmdTdHJhdGVneTtcbn0oKTtcblxuLyoqXHJcbiAqIEBleHRlbmRzIENvbXBvbmVudFxyXG4gKiBAc3VwcG9ydCB7XCJpZVwiOiBcIjkrKHdpdGggcG9seWZpbGwpXCIsIFwiY2hcIiA6IFwibGF0ZXN0XCIsIFwiZmZcIiA6IFwibGF0ZXN0XCIsICBcInNmXCIgOiBcImxhdGVzdFwiLCBcImVkZ2VcIiA6IFwibGF0ZXN0XCIsIFwiaW9zXCIgOiBcIjcrXCIsIFwiYW5cIiA6IFwiNC5YK1wifVxyXG4gKiBAcmVxdWlyZXMge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9uYXZlci9lZ2pzLWNvbXBvbmVudHxAZWdqcy9jb21wb25lbnR9XHJcbiAqIEByZXF1aXJlcyB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL25hdmVyL2VnanMtYXhlc3xAZWdqcy9heGVzfVxyXG4gKi9cbnZhciBGbGlja2luZyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyQzKEZsaWNraW5nLCBfc3VwZXIpO1xuICAvKipcclxuICAgKiBAcGFyYW0gcm9vdCBBIHJvb3QgSFRNTEVsZW1lbnQgdG8gaW5pdGlhbGl6ZSBGbGlja2luZyBvbiBpdC4gV2hlbiBpdCdzIGEgdHlwZW9mIGBzdHJpbmdgLCBpdCBzaG91bGQgYmUgYSBjc3Mgc2VsZWN0b3Igc3RyaW5nXHJcbiAgICogPGtvPkZsaWNraW5n7J2EIOy0iOq4sO2ZlO2VoCBIVE1MRWxlbWVudOuhnCwgYHN0cmluZ2Ag7YOA7J6F7Jy866GcIOyngOygleyLnCBjc3Mg7ISg7YOd7J6QIOusuOyekOyXtOydhCDsp4DsoJXtlbTslbwg7ZWp64uI64ukLjwva28+XHJcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zPXt9XSBBbiBvcHRpb25zIG9iamVjdCBmb3IgRmxpY2tpbmcuPGtvPkZsaWNraW5n7JeQIOyggeyaqe2VoCDsmLXshZgg7Jik67iM7KCd7Yq4PC9rbz5cclxuICAgKiBAdGhyb3dzIHtGbGlja2luZ0Vycm9yfVxyXG4gICAqIHxjb2RlfGNvbmRpdGlvbnxcclxuICAgKiB8LS0tfC0tLXxcclxuICAgKiB8e0BsaW5rIEVSUk9SX0NPREUgV1JPTkdfVFlQRX18V2hlbiB0aGUgcm9vdCBpcyBub3QgZWl0aGVyIHN0cmluZyBvciBIVE1MRWxlbWVudHxcclxuICAgKiB8e0BsaW5rIEVSUk9SX0NPREUgRUxFTUVOVF9OT1RfRk9VTkR9fFdoZW4gdGhlIGVsZW1lbnQgd2l0aCBnaXZlbiBDU1Mgc2VsZWN0b3IgZG9lcyBub3QgZXhpc3R8XHJcbiAgICogPGtvPlxyXG4gICAqXHJcbiAgICogfGNvZGV87KGw6rG0fFxyXG4gICAqIHwtLS18LS0tfFxyXG4gICAqIHx7QGxpbmsgRVJST1JfQ09ERSBXUk9OR19UWVBFfXzro6jtirgg7JeY66as66i87Yq46rCAIHN0cmluZ+ydtOuCmCBIVE1MRWxlbWVudOqwgCDslYTri5Ag6rK97JqwfFxyXG4gICAqIHx7QGxpbmsgRVJST1JfQ09ERSBFTEVNRU5UX05PVF9GT1VORH187KO87Ja07KeEIENTUyBzZWxlY3RvcuuhnCDsl5jrpqzrqLztirjrpbwg7LC+7KeAIOuqu+2WiOydhCDqsr3smrB8XHJcbiAgICpcclxuICAgKiA8L2tvPlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogYGBgdHNcclxuICAgKiBpbXBvcnQgRmxpY2tpbmcgZnJvbSBcIkBlZ2pzL2ZsaWNraW5nXCI7XHJcbiAgICpcclxuICAgKiAvLyBDcmVhdGluZyBuZXcgaW5zdGFuY2Ugb2YgRmxpY2tpbmcgd2l0aCBIVE1MRWxlbWVudFxyXG4gICAqIGNvbnN0IGZsaWNraW5nID0gbmV3IEZsaWNraW5nKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIuZmxpY2tpbmctdmlld3BvcnRcIiksIHsgY2lyY3VsYXI6IHRydWUgfSk7XHJcbiAgICpcclxuICAgKiAvLyBDcmVhdGluZyBuZXcgaW5zdGFuY2Ugb2YgRmxpY2tpbmcgd2l0aCBDU1Mgc2VsZWN0b3JcclxuICAgKiBjb25zdCBmbGlja2luZzIgPSBuZXcgRmxpY2tpbmcoXCIuZmxpY2tpbmctdmlld3BvcnRcIiwgeyBjaXJjdWxhcjogdHJ1ZSB9KTtcclxuICAgKiBgYGBcclxuICAgKi9cbiAgZnVuY3Rpb24gRmxpY2tpbmcocm9vdCwgX2EpIHtcbiAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSxcbiAgICAgIF9jID0gX2IuYWxpZ24sXG4gICAgICBhbGlnbiA9IF9jID09PSB2b2lkIDAgPyBBTElHTi5DRU5URVIgOiBfYyxcbiAgICAgIF9kID0gX2IuZGVmYXVsdEluZGV4LFxuICAgICAgZGVmYXVsdEluZGV4ID0gX2QgPT09IHZvaWQgMCA/IDAgOiBfZCxcbiAgICAgIF9lID0gX2IuaG9yaXpvbnRhbCxcbiAgICAgIGhvcml6b250YWwgPSBfZSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9lLFxuICAgICAgX2YgPSBfYi5jaXJjdWxhcixcbiAgICAgIGNpcmN1bGFyID0gX2YgPT09IHZvaWQgMCA/IGZhbHNlIDogX2YsXG4gICAgICBfZyA9IF9iLmNpcmN1bGFyRmFsbGJhY2ssXG4gICAgICBjaXJjdWxhckZhbGxiYWNrID0gX2cgPT09IHZvaWQgMCA/IENJUkNVTEFSX0ZBTExCQUNLLkxJTkVBUiA6IF9nLFxuICAgICAgX2ggPSBfYi5ib3VuZCxcbiAgICAgIGJvdW5kID0gX2ggPT09IHZvaWQgMCA/IGZhbHNlIDogX2gsXG4gICAgICBfaiA9IF9iLmFkYXB0aXZlLFxuICAgICAgYWRhcHRpdmUgPSBfaiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfaixcbiAgICAgIF9rID0gX2IucGFuZWxzUGVyVmlldyxcbiAgICAgIHBhbmVsc1BlclZpZXcgPSBfayA9PT0gdm9pZCAwID8gLTEgOiBfayxcbiAgICAgIF9sID0gX2Iubm9QYW5lbFN0eWxlT3ZlcnJpZGUsXG4gICAgICBub1BhbmVsU3R5bGVPdmVycmlkZSA9IF9sID09PSB2b2lkIDAgPyBmYWxzZSA6IF9sLFxuICAgICAgX20gPSBfYi5yZXNpemVPbkNvbnRlbnRzUmVhZHksXG4gICAgICByZXNpemVPbkNvbnRlbnRzUmVhZHkgPSBfbSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfbSxcbiAgICAgIF9vID0gX2IubmVzdGVkLFxuICAgICAgbmVzdGVkID0gX28gPT09IHZvaWQgMCA/IGZhbHNlIDogX28sXG4gICAgICBfcCA9IF9iLm5lZWRQYW5lbFRocmVzaG9sZCxcbiAgICAgIG5lZWRQYW5lbFRocmVzaG9sZCA9IF9wID09PSB2b2lkIDAgPyAwIDogX3AsXG4gICAgICBfcSA9IF9iLnByZXZlbnRFdmVudHNCZWZvcmVJbml0LFxuICAgICAgcHJldmVudEV2ZW50c0JlZm9yZUluaXQgPSBfcSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9xLFxuICAgICAgX3IgPSBfYi5kZWNlbGVyYXRpb24sXG4gICAgICBkZWNlbGVyYXRpb24gPSBfciA9PT0gdm9pZCAwID8gMC4wMDc1IDogX3IsXG4gICAgICBfcyA9IF9iLmR1cmF0aW9uLFxuICAgICAgZHVyYXRpb24gPSBfcyA9PT0gdm9pZCAwID8gNTAwIDogX3MsXG4gICAgICBfdCA9IF9iLmVhc2luZyxcbiAgICAgIGVhc2luZyA9IF90ID09PSB2b2lkIDAgPyBmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4gMSAtIE1hdGgucG93KDEgLSB4LCAzKTtcbiAgICAgIH0gOiBfdCxcbiAgICAgIF91ID0gX2IuaW5wdXRUeXBlLFxuICAgICAgaW5wdXRUeXBlID0gX3UgPT09IHZvaWQgMCA/IFtcIm1vdXNlXCIsIFwidG91Y2hcIl0gOiBfdSxcbiAgICAgIF92ID0gX2IubW92ZVR5cGUsXG4gICAgICBtb3ZlVHlwZSA9IF92ID09PSB2b2lkIDAgPyBcInNuYXBcIiA6IF92LFxuICAgICAgX3cgPSBfYi50aHJlc2hvbGQsXG4gICAgICB0aHJlc2hvbGQgPSBfdyA9PT0gdm9pZCAwID8gNDAgOiBfdyxcbiAgICAgIF94ID0gX2IuaW50ZXJydXB0YWJsZSxcbiAgICAgIGludGVycnVwdGFibGUgPSBfeCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF94LFxuICAgICAgX3kgPSBfYi5ib3VuY2UsXG4gICAgICBib3VuY2UgPSBfeSA9PT0gdm9pZCAwID8gXCIyMCVcIiA6IF95LFxuICAgICAgX3ogPSBfYi5pT1NFZGdlU3dpcGVUaHJlc2hvbGQsXG4gICAgICBpT1NFZGdlU3dpcGVUaHJlc2hvbGQgPSBfeiA9PT0gdm9pZCAwID8gMzAgOiBfeixcbiAgICAgIF8wID0gX2IucHJldmVudENsaWNrT25EcmFnLFxuICAgICAgcHJldmVudENsaWNrT25EcmFnID0gXzAgPT09IHZvaWQgMCA/IHRydWUgOiBfMCxcbiAgICAgIF8xID0gX2IucHJldmVudERlZmF1bHRPbkRyYWcsXG4gICAgICBwcmV2ZW50RGVmYXVsdE9uRHJhZyA9IF8xID09PSB2b2lkIDAgPyBmYWxzZSA6IF8xLFxuICAgICAgXzIgPSBfYi5kaXNhYmxlT25Jbml0LFxuICAgICAgZGlzYWJsZU9uSW5pdCA9IF8yID09PSB2b2lkIDAgPyBmYWxzZSA6IF8yLFxuICAgICAgXzMgPSBfYi5jaGFuZ2VPbkhvbGQsXG4gICAgICBjaGFuZ2VPbkhvbGQgPSBfMyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfMyxcbiAgICAgIF80ID0gX2IucmVuZGVyT25seVZpc2libGUsXG4gICAgICByZW5kZXJPbmx5VmlzaWJsZSA9IF80ID09PSB2b2lkIDAgPyBmYWxzZSA6IF80LFxuICAgICAgXzUgPSBfYi52aXJ0dWFsLFxuICAgICAgdmlydHVhbCA9IF81ID09PSB2b2lkIDAgPyBudWxsIDogXzUsXG4gICAgICBfNiA9IF9iLmF1dG9Jbml0LFxuICAgICAgYXV0b0luaXQgPSBfNiA9PT0gdm9pZCAwID8gdHJ1ZSA6IF82LFxuICAgICAgXzcgPSBfYi5hdXRvUmVzaXplLFxuICAgICAgYXV0b1Jlc2l6ZSA9IF83ID09PSB2b2lkIDAgPyB0cnVlIDogXzcsXG4gICAgICBfOCA9IF9iLnVzZVJlc2l6ZU9ic2VydmVyLFxuICAgICAgdXNlUmVzaXplT2JzZXJ2ZXIgPSBfOCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF84LFxuICAgICAgXzkgPSBfYi5yZXNpemVEZWJvdW5jZSxcbiAgICAgIHJlc2l6ZURlYm91bmNlID0gXzkgPT09IHZvaWQgMCA/IDAgOiBfOSxcbiAgICAgIF8xMCA9IF9iLm1heFJlc2l6ZURlYm91bmNlLFxuICAgICAgbWF4UmVzaXplRGVib3VuY2UgPSBfMTAgPT09IHZvaWQgMCA/IDEwMCA6IF8xMCxcbiAgICAgIF8xMSA9IF9iLnVzZUZyYWN0aW9uYWxTaXplLFxuICAgICAgdXNlRnJhY3Rpb25hbFNpemUgPSBfMTEgPT09IHZvaWQgMCA/IGZhbHNlIDogXzExLFxuICAgICAgXzEyID0gX2IuZXh0ZXJuYWxSZW5kZXJlcixcbiAgICAgIGV4dGVybmFsUmVuZGVyZXIgPSBfMTIgPT09IHZvaWQgMCA/IG51bGwgOiBfMTIsXG4gICAgICBfMTMgPSBfYi5yZW5kZXJFeHRlcm5hbCxcbiAgICAgIHJlbmRlckV4dGVybmFsID0gXzEzID09PSB2b2lkIDAgPyBudWxsIDogXzEzO1xuICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgLy8gSW50ZXJuYWwgc3RhdGVzXG4gICAgX3RoaXMuX2luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgX3RoaXMuX3BsdWdpbnMgPSBbXTtcbiAgICAvLyBCaW5kIG9wdGlvbnNcbiAgICBfdGhpcy5fYWxpZ24gPSBhbGlnbjtcbiAgICBfdGhpcy5fZGVmYXVsdEluZGV4ID0gZGVmYXVsdEluZGV4O1xuICAgIF90aGlzLl9ob3Jpem9udGFsID0gaG9yaXpvbnRhbDtcbiAgICBfdGhpcy5fY2lyY3VsYXIgPSBjaXJjdWxhcjtcbiAgICBfdGhpcy5fY2lyY3VsYXJGYWxsYmFjayA9IGNpcmN1bGFyRmFsbGJhY2s7XG4gICAgX3RoaXMuX2JvdW5kID0gYm91bmQ7XG4gICAgX3RoaXMuX2FkYXB0aXZlID0gYWRhcHRpdmU7XG4gICAgX3RoaXMuX3BhbmVsc1BlclZpZXcgPSBwYW5lbHNQZXJWaWV3O1xuICAgIF90aGlzLl9ub1BhbmVsU3R5bGVPdmVycmlkZSA9IG5vUGFuZWxTdHlsZU92ZXJyaWRlO1xuICAgIF90aGlzLl9yZXNpemVPbkNvbnRlbnRzUmVhZHkgPSByZXNpemVPbkNvbnRlbnRzUmVhZHk7XG4gICAgX3RoaXMuX25lc3RlZCA9IG5lc3RlZDtcbiAgICBfdGhpcy5fdmlydHVhbCA9IHZpcnR1YWw7XG4gICAgX3RoaXMuX25lZWRQYW5lbFRocmVzaG9sZCA9IG5lZWRQYW5lbFRocmVzaG9sZDtcbiAgICBfdGhpcy5fcHJldmVudEV2ZW50c0JlZm9yZUluaXQgPSBwcmV2ZW50RXZlbnRzQmVmb3JlSW5pdDtcbiAgICBfdGhpcy5fZGVjZWxlcmF0aW9uID0gZGVjZWxlcmF0aW9uO1xuICAgIF90aGlzLl9kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgIF90aGlzLl9lYXNpbmcgPSBlYXNpbmc7XG4gICAgX3RoaXMuX2lucHV0VHlwZSA9IGlucHV0VHlwZTtcbiAgICBfdGhpcy5fbW92ZVR5cGUgPSBtb3ZlVHlwZTtcbiAgICBfdGhpcy5fdGhyZXNob2xkID0gdGhyZXNob2xkO1xuICAgIF90aGlzLl9pbnRlcnJ1cHRhYmxlID0gaW50ZXJydXB0YWJsZTtcbiAgICBfdGhpcy5fYm91bmNlID0gYm91bmNlO1xuICAgIF90aGlzLl9pT1NFZGdlU3dpcGVUaHJlc2hvbGQgPSBpT1NFZGdlU3dpcGVUaHJlc2hvbGQ7XG4gICAgX3RoaXMuX3ByZXZlbnRDbGlja09uRHJhZyA9IHByZXZlbnRDbGlja09uRHJhZztcbiAgICBfdGhpcy5fcHJldmVudERlZmF1bHRPbkRyYWcgPSBwcmV2ZW50RGVmYXVsdE9uRHJhZztcbiAgICBfdGhpcy5fZGlzYWJsZU9uSW5pdCA9IGRpc2FibGVPbkluaXQ7XG4gICAgX3RoaXMuX2NoYW5nZU9uSG9sZCA9IGNoYW5nZU9uSG9sZDtcbiAgICBfdGhpcy5fcmVuZGVyT25seVZpc2libGUgPSByZW5kZXJPbmx5VmlzaWJsZTtcbiAgICBfdGhpcy5fYXV0b0luaXQgPSBhdXRvSW5pdDtcbiAgICBfdGhpcy5fYXV0b1Jlc2l6ZSA9IGF1dG9SZXNpemU7XG4gICAgX3RoaXMuX3VzZVJlc2l6ZU9ic2VydmVyID0gdXNlUmVzaXplT2JzZXJ2ZXI7XG4gICAgX3RoaXMuX3Jlc2l6ZURlYm91bmNlID0gcmVzaXplRGVib3VuY2U7XG4gICAgX3RoaXMuX21heFJlc2l6ZURlYm91bmNlID0gbWF4UmVzaXplRGVib3VuY2U7XG4gICAgX3RoaXMuX3VzZUZyYWN0aW9uYWxTaXplID0gdXNlRnJhY3Rpb25hbFNpemU7XG4gICAgX3RoaXMuX2V4dGVybmFsUmVuZGVyZXIgPSBleHRlcm5hbFJlbmRlcmVyO1xuICAgIF90aGlzLl9yZW5kZXJFeHRlcm5hbCA9IHJlbmRlckV4dGVybmFsO1xuICAgIC8vIENyZWF0ZSBjb3JlIGNvbXBvbmVudHNcbiAgICBfdGhpcy5fdmlld3BvcnQgPSBuZXcgVmlld3BvcnQoX3RoaXMsIGdldEVsZW1lbnQocm9vdCkpO1xuICAgIF90aGlzLl9hdXRvUmVzaXplciA9IG5ldyBBdXRvUmVzaXplcihfdGhpcyk7XG4gICAgX3RoaXMuX3JlbmRlcmVyID0gX3RoaXMuX2NyZWF0ZVJlbmRlcmVyKCk7XG4gICAgX3RoaXMuX2NhbWVyYSA9IF90aGlzLl9jcmVhdGVDYW1lcmEoKTtcbiAgICBfdGhpcy5fY29udHJvbCA9IF90aGlzLl9jcmVhdGVDb250cm9sKCk7XG4gICAgX3RoaXMuX3ZpcnR1YWxNYW5hZ2VyID0gbmV3IFZpcnR1YWxNYW5hZ2VyKF90aGlzLCB2aXJ0dWFsKTtcbiAgICBpZiAoX3RoaXMuX2F1dG9Jbml0KSB7XG4gICAgICB2b2lkIF90aGlzLmluaXQoKTtcbiAgICB9XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIHZhciBfX3Byb3RvID0gRmxpY2tpbmcucHJvdG90eXBlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJjb250cm9sXCIsIHtcbiAgICAvLyBDb21wb25lbnRzXG4gICAgLyoqXHJcbiAgICAgKiB7QGxpbmsgQ29udHJvbH0gaW5zdGFuY2Ugb2YgdGhlIEZsaWNraW5nXHJcbiAgICAgKiBAa28g7ZiE7J6sIEZsaWNraW5n7JeQIO2ZnOyEse2ZlOuQnCB7QGxpbmsgQ29udHJvbH0g7J247Iqk7YS07IqkXHJcbiAgICAgKiBAdHlwZSB7Q29udHJvbH1cclxuICAgICAqIEBkZWZhdWx0IFNuYXBDb250cm9sXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqIEBzZWUgQ29udHJvbFxyXG4gICAgICogQHNlZSBTbmFwQ29udHJvbFxyXG4gICAgICogQHNlZSBGcmVlQ29udHJvbFxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY29udHJvbDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwiY2FtZXJhXCIsIHtcbiAgICAvKipcclxuICAgICAqIHtAbGluayBDYW1lcmF9IGluc3RhbmNlIG9mIHRoZSBGbGlja2luZ1xyXG4gICAgICogQGtvIO2YhOyerCBGbGlja2luZ+yXkCDtmZzshLHtmZTrkJwge0BsaW5rIENhbWVyYX0g7J247Iqk7YS07IqkXHJcbiAgICAgKiBAdHlwZSB7Q2FtZXJhfVxyXG4gICAgICogQGRlZmF1bHQgTGluZWFyQ2FtZXJhXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqIEBzZWUgQ2FtZXJhXHJcbiAgICAgKiBAc2VlIExpbmVhckNhbWVyYVxyXG4gICAgICogQHNlZSBCb3VuZENhbWVyYVxyXG4gICAgICogQHNlZSBDaXJjdWxhckNhbWVyYVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2FtZXJhO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJyZW5kZXJlclwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiB7QGxpbmsgUmVuZGVyZXJ9IGluc3RhbmNlIG9mIHRoZSBGbGlja2luZ1xyXG4gICAgICogQGtvIO2YhOyerCBGbGlja2luZ+yXkCDtmZzshLHtmZTrkJwge0BsaW5rIFJlbmRlcmVyfSDsnbjsiqTthLTsiqRcclxuICAgICAqIEB0eXBlIHtSZW5kZXJlcn1cclxuICAgICAqIEBkZWZhdWx0IFZhbmlsbGFSZW5kZXJlclxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKiBAc2VlIFJlbmRlcmVyXHJcbiAgICAgKiBAc2VlIFZhbmlsbGFSZW5kZXJlclxyXG4gICAgICogQHNlZSBFeHRlcm5hbFJlbmRlcmVyXHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJlcjtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwidmlld3BvcnRcIiwge1xuICAgIC8qKlxyXG4gICAgICogQSBjb21wb25lbnQgdGhhdCBtYW5hZ2VzIHZpZXdwb3J0IHNpemVcclxuICAgICAqIEBrbyDrt7Dtj6ztirgg7YGs6riwIOygleuztOulvCDri7Tri7ntlZjripQg7Lu07Y+s64SM7Yq4XHJcbiAgICAgKiBAdHlwZSB7Vmlld3BvcnR9XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqIEBzZWUgVmlld3BvcnRcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3ZpZXdwb3J0O1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJpbml0aWFsaXplZFwiLCB7XG4gICAgLy8gSW50ZXJuYWwgU3RhdGVzXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIEZsaWNraW5nJ3Mge0BsaW5rIEZsaWNraW5nI2luaXQgaW5pdCgpfSBpcyBjYWxsZWQuXHJcbiAgICAgKiBUaGlzIGlzIGB0cnVlYCB3aGVuIHtAbGluayBGbGlja2luZyNpbml0IGluaXQoKX0gaXMgY2FsbGVkLCBhbmQgaXMgYGZhbHNlYCBhZnRlciBjYWxsaW5nIHtAbGluayBGbGlja2luZyNkZXN0cm95IGRlc3Ryb3koKX0uXHJcbiAgICAgKiBAa28gRmxpY2tpbmfsnZgge0BsaW5rIEZsaWNraW5nI2luaXQgaW5pdCgpfeydtCDtmLjstpzrkJjsl4jripTsp4Drpbwg64KY7YOA64K064qUIOuppOuyhCDrs4DsiJguXHJcbiAgICAgKiDsnbQg6rCS7J2AIHtAbGluayBGbGlja2luZyNpbml0IGluaXQoKX3snbQg7Zi47Lac65CY7JeI7Jy866m0IGB0cnVlYOuhnCDrs4DtlZjqs6AsIHtAbGluayBGbGlja2luZyNkZXN0cm95IGRlc3Ryb3koKX3tmLjstpwg7J207ZuE7JeQIOuLpOyLnCBgZmFsc2Vg66GcIOuzgOqyveuQqeuLiOuLpC5cclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICogQGRlZmF1bHQgZmFsc2VcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5faW5pdGlhbGl6ZWQ7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcImNpcmN1bGFyRW5hYmxlZFwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHRoZSBgY2lyY3VsYXJgIG9wdGlvbiBpcyBlbmFibGVkLlxyXG4gICAgICogVGhlIHtAbGluayBGbGlja2luZyNjaXJjdWxhciBjaXJjdWxhcn0gb3B0aW9uIGNhbid0IGJlIGVuYWJsZWQgd2hlbiBzdW0gb2YgdGhlIHBhbmVsIHNpemVzIGFyZSB0b28gc21hbGwuXHJcbiAgICAgKiBAa28ge0BsaW5rIEZsaWNraW5nI2NpcmN1bGFyIGNpcmN1bGFyfSDsmLXshZjsnbQg7Zmc7ISx7ZmU65CY7JeI64qU7KeAIOyXrOu2gOulvCDrgpjtg4DrgrTripQg66mk67KEIOuzgOyImC5cclxuICAgICAqIHtAbGluayBGbGlja2luZyNjaXJjdWxhciBjaXJjdWxhcn0g7Ji17IWY7J2AIO2MqOuEkOydmCDtgazquLDsnZgg7ZWp7J20IOy2qeu2hO2VmOyngCDslYrsnYQg6rK97JqwIOu5hO2ZnOyEse2ZlOuQqeuLiOuLpC5cclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICogQGRlZmF1bHQgZmFsc2VcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2FtZXJhLmNpcmN1bGFyRW5hYmxlZDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwidmlydHVhbEVuYWJsZWRcIiwge1xuICAgIC8qKlxyXG4gICAgICogV2hldGhlciB0aGUgYHZpcnR1YWxgIG9wdGlvbiBpcyBlbmFibGVkLlxyXG4gICAgICogVGhlIHtAbGluayBGbGlja2luZyN2aXJ0dWFsIHZpcnR1YWx9IG9wdGlvbiBjYW4ndCBiZSBlbmFibGVkIHdoZW4gIHtAbGluayBGbGlja2luZyNwYW5lbHNQZXJWaWV3IHBhbmVsc1BlclZpZXd9IGlzIGxlc3Mgb3IgZXF1YWwgdGhhbiB6ZXJvLlxyXG4gICAgICogQGtvIHtAbGluayBGbGlja2luZyN2aXJ0dWFsIHZpcnR1YWx9IOyYteyFmOydtCDtmZzshLHtmZTrkJjsl4jripTsp4Ag7Jes67aA66W8IOuCmO2DgOuCtOuKlCDrqaTrsoQg67OA7IiYLlxyXG4gICAgICoge0BsaW5rIEZsaWNraW5nI3ZpcnR1YWwgdmlydHVhbH0g7Ji17IWY7J2AIHtAbGluayBGbGlja2luZyNwYW5lbHNQZXJWaWV3IHBhbmVsc1BlclZpZXd9IOyYteyFmOydmCDqsJLsnbQgMOuztOuLpCDqsJnqsbDrgpgg7J6R7Jy866m0IOu5hO2ZnOyEse2ZlOuQqeuLiOuLpC5cclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICogQGRlZmF1bHQgZmFsc2VcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcGFuZWxzUGVyVmlldyA+IDAgJiYgdGhpcy5fdmlydHVhbCAhPSBudWxsO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJpbmRleFwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBJbmRleCBudW1iZXIgb2YgdGhlIHtAbGluayBGbGlja2luZyNjdXJyZW50UGFuZWwgY3VycmVudFBhbmVsfVxyXG4gICAgICogQGtvIHtAbGluayBGbGlja2luZyNjdXJyZW50UGFuZWwgY3VycmVudFBhbmVsfeydmCDsnbjrjbHsiqQg67KI7Zi4XHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgMFxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jb250cm9sLmFjdGl2ZUluZGV4O1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJlbGVtZW50XCIsIHtcbiAgICAvKipcclxuICAgICAqIFRoZSByb290KGAuZmxpY2tpbmctdmlld3BvcnRgKSBlbGVtZW50XHJcbiAgICAgKiBAa28gcm9vdChgLmZsaWNraW5nLXZpZXdwb3J0YCkg7JeY66as66i87Yq4XHJcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3ZpZXdwb3J0LmVsZW1lbnQ7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcImN1cnJlbnRQYW5lbFwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBDdXJyZW50bHkgYWN0aXZlIHBhbmVsXHJcbiAgICAgKiBAa28g7ZiE7J6sIOyEoO2DneuQnCDtjKjrhJBcclxuICAgICAqIEB0eXBlIHtQYW5lbH1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQHNlZSBQYW5lbFxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY29udHJvbC5hY3RpdmVQYW5lbDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwicGFuZWxzXCIsIHtcbiAgICAvKipcclxuICAgICAqIEFycmF5IG9mIHBhbmVsc1xyXG4gICAgICogQGtvIOyghOyytCDtjKjrhJDrk6TsnZgg67Cw7Je0XHJcbiAgICAgKiBAdHlwZSB7UGFuZWxbXX1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQHNlZSBQYW5lbFxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVuZGVyZXIucGFuZWxzO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJwYW5lbENvdW50XCIsIHtcbiAgICAvKipcclxuICAgICAqIENvdW50IG9mIHBhbmVsc1xyXG4gICAgICogQGtvIOyghOyytCDtjKjrhJDsnZgg6rCc7IiYXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJlci5wYW5lbENvdW50O1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJ2aXNpYmxlUGFuZWxzXCIsIHtcbiAgICAvKipcclxuICAgICAqIEFycmF5IG9mIHBhbmVscyB0aGF0IGlzIHZpc2libGUgYXQgdGhlIGN1cnJlbnQgcG9zaXRpb25cclxuICAgICAqIEBrbyDtmITsnqwg67O07J2064qUIO2MqOuEkOydmCDrsLDsl7RcclxuICAgICAqIEB0eXBlIHtQYW5lbFtdfVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKiBAc2VlIFBhbmVsXHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jYW1lcmEudmlzaWJsZVBhbmVscztcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwiYW5pbWF0aW5nXCIsIHtcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgRmxpY2tpbmcncyBhbmltYXRpbmdcclxuICAgICAqIEBrbyDtmITsnqwg7JWg64uI66mU7J207IWYIOuPmeyekSDsl6zrtoBcclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jb250cm9sLmFuaW1hdGluZztcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwiaG9sZGluZ1wiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHVzZXIgaXMgY2xpY2tpbmcgb3IgdG91Y2hpbmdcclxuICAgICAqIEBrbyDtmITsnqwg7IKs7Jqp7J6Q6rCAIO2BtOumrS/thLDsuZjspJHsnbjsp4Ag7Jes67aAXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY29udHJvbC5ob2xkaW5nO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJhY3RpdmVQbHVnaW5zXCIsIHtcbiAgICAvKipcclxuICAgICAqIEEgY3VycmVudCBsaXN0IG9mIGFjdGl2YXRlZCBwbHVnaW5zXHJcbiAgICAgKiBAa28g7ZiE7J6sIO2ZnOyEse2ZlOuQnCDtlIzrn6zqt7jsnbgg66qp66GdXHJcbiAgICAgKiBAdHlwZSB7UGx1Z2luW119XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3BsdWdpbnM7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcImFsaWduXCIsIHtcbiAgICAvLyBPcHRpb25zIEdldHRlclxuICAgIC8vIFVJIC8gTEFZT1VUXG4gICAgLyoqXHJcbiAgICAgKiBBbGlnbiBwb3NpdGlvbiBvZiB0aGUgcGFuZWxzIHdpdGhpbiB2aWV3cG9ydC4gWW91IGNhbiBzZXQgZGlmZmVyZW50IHZhbHVlcyBlYWNoIGZvciB0aGUgcGFuZWwgYW5kIGNhbWVyYVxyXG4gICAgICogQGtvIOu3sO2PrO2KuCDrgrTsl5DshJwg7Yyo64SQIOygleugrOuwqeyLneydhCDshKTsoJXtlZjripQg7Ji17IWYLiDsubTrqZTrnbzsmYAg7Yyo64SQIOqwnOuzhOuhnCDsmLXshZjsnYQg7ISk7KCV7ZWgIOyImOuPhCDsnojsirXri4jri6RcclxuICAgICAqIEB0eXBlIHtBTElHTiB8IHN0cmluZyB8IG51bWJlciB8IHsgcGFuZWw6IHN0cmluZyB8IG51bWJlciwgY2FtZXJhOiBzdHJpbmcgfCBudW1iZXIgfX1cclxuICAgICAqIEBwcm9wZXJ0eSB7QUxJR04gfCBzdHJpbmcgfCBudW1iZXJ9IHBhbmVsIFRoZSBhbGlnbiB2YWx1ZSBmb3IgZWFjaCB7QGxpbmsgUGFuZWx9czxrbz7qsJzqsJzsnZgge0BsaW5rIFBhbmVsfeyXkCDsoIHsmqntlaAg6rCSPC9rbz5cclxuICAgICAqIEBwcm9wZXJ0eSB7QUxJR04gfCBzdHJpbmcgfCBudW1iZXJ9IGNhbWVyYSBUaGUgYWxpZ24gdmFsdWUgZm9yIHtAbGluayBDYW1lcmF9PGtvPntAbGluayBDYW1lcmF97JeQIOyggeyaqe2VoCDqsJI8L2tvPlxyXG4gICAgICogQGRlZmF1bHQgXCJjZW50ZXJcIlxyXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1mbGlja2luZy9PcHRpb25zI2FsaWduIGFsaWduICggT3B0aW9ucyApfVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGBgYHRzXHJcbiAgICAgKiBjb25zdCBwb3NzaWJsZU9wdGlvbnMgPSBbXHJcbiAgICAgKiAgIC8vIExpdGVyYWwgc3RyaW5nc1xyXG4gICAgICogICBcInByZXZcIiwgXCJjZW50ZXJcIiwgXCJuZXh0XCIsXHJcbiAgICAgKiAgIC8vICUgdmFsdWVzLCBhcHBsaWVkIHRvIGJvdGggcGFuZWwgJiBjYW1lcmFcclxuICAgICAqICAgXCIwJVwiLCBcIjI1JVwiLCBcIjQyJVwiLFxyXG4gICAgICogICAvLyBweCB2YWx1ZXMsIGFyaXRobWV0aWMgY2FsY3VsYXRpb24gd2l0aCAoKy8tKSBpcyBhbHNvIGFsbG93ZWQuXHJcbiAgICAgKiAgIFwiMHB4XCIsIFwiMTAwcHhcIiwgXCI1MCUgLSAyNXB4XCIsXHJcbiAgICAgKiAgIC8vIG51bWJlcnMsIHNhbWUgdG8gbnVtYmVyICsgcHggKFwiMHB4XCIsIFwiMTAwcHhcIilcclxuICAgICAqICAgMCwgMTAwLCAxMDAwLFxyXG4gICAgICogICAvLyBTZXR0aW5nIGEgZGlmZmVyZW50IHZhbHVlIGZvciBwYW5lbCAmIGNhbWVyYVxyXG4gICAgICogICB7IHBhbmVsOiBcIjEwJVwiLCBjYW1lcmE6IFwiMjUlXCIgfVxyXG4gICAgICogXTtcclxuICAgICAqXHJcbiAgICAgKiBwb3NzaWJsZU9wdGlvbnMuZm9yRWFjaChhbGlnbiA9PiB7XHJcbiAgICAgKiAgIG5ldyBGbGlja2luZyhcIiNlbFwiLCB7IGFsaWduIH0pO1xyXG4gICAgICogfSk7XHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2FsaWduO1xuICAgIH0sXG4gICAgLy8gT3B0aW9ucyBTZXR0ZXJcbiAgICAvLyBVSSAvIExBWU9VVFxuICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgdGhpcy5fYWxpZ24gPSB2YWw7XG4gICAgICB0aGlzLl9yZW5kZXJlci5hbGlnbiA9IHZhbDtcbiAgICAgIHRoaXMuX2NhbWVyYS5hbGlnbiA9IHZhbDtcbiAgICAgIHZvaWQgdGhpcy5yZXNpemUoKTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwiZGVmYXVsdEluZGV4XCIsIHtcbiAgICAvKipcclxuICAgICAqIEluZGV4IG9mIHRoZSBwYW5lbCB0byBtb3ZlIHdoZW4gRmxpY2tpbmcncyB7QGxpbmsgRmxpY2tpbmcjaW5pdCBpbml0KCl9IGlzIGNhbGxlZC4gQSB6ZXJvLWJhc2VkIGludGVnZXJcclxuICAgICAqIEBrbyBGbGlja2luZ+ydmCB7QGxpbmsgRmxpY2tpbmcjaW5pdCBpbml0KCl97J20IO2YuOy2nOuQoCDrlYwg7J2064+Z7ZWgIOuUlO2PtO2KuCDtjKjrhJDsnZgg7J24642x7Iqk66GcLCAw67aA7YSwIOyLnOyeke2VmOuKlCDsoJXsiJjsnoXri4jri6RcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWZsaWNraW5nL09wdGlvbnMjZGVmYXVsdGluZGV4IGRlZmF1bHRJbmRleCAoIE9wdGlvbnMgKX1cclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2RlZmF1bHRJbmRleDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgdGhpcy5fZGVmYXVsdEluZGV4ID0gdmFsO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJob3Jpem9udGFsXCIsIHtcbiAgICAvKipcclxuICAgICAqIERpcmVjdGlvbiBvZiBwYW5lbCBtb3ZlbWVudCAodHJ1ZTogaG9yaXpvbnRhbCwgZmFsc2U6IHZlcnRpY2FsKVxyXG4gICAgICogQGtvIO2MqOuEkCDsnbTrj5kg67Cp7ZalICh0cnVlOiDqsIDroZzrsKntlqUsIGZhbHNlOiDshLjroZzrsKntlqUpXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqIEBkZWZhdWx0IHRydWVcclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtZmxpY2tpbmcvT3B0aW9ucyNob3Jpem9udGFsIGhvcml6b250YWwgKCBPcHRpb25zICl9XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9ob3Jpem9udGFsO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICB0aGlzLl9ob3Jpem9udGFsID0gdmFsO1xuICAgICAgdGhpcy5fY29udHJvbC5jb250cm9sbGVyLnVwZGF0ZURpcmVjdGlvbigpO1xuICAgICAgdm9pZCB0aGlzLnJlc2l6ZSgpO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJjaXJjdWxhclwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBFbmFibGVzIGNpcmN1bGFyKGNvbnRpbnVvdXMgbG9vcCkgbW9kZSwgd2hpY2ggY29ubmVjdHMgZmlyc3QvbGFzdCBwYW5lbCBmb3IgY29udGludW91cyBzY3JvbGxpbmcuXHJcbiAgICAgKiBAa28g7Iic7ZmYIOuqqOuTnOulvCDtmZzshLHtmZTtlanri4jri6QuIOyInO2ZmCDrqqjrk5zsl5DshJzripQg7JaRIOuBneydmCDtjKjrhJDsnbQg7ISc66GcIOyXsOqysOuQmOyWtCDrgYrquYDsl4bripQg7Iqk7YGs66Gk7J20IOqwgOuKpe2VqeuLiOuLpC5cclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICogQGRlZmF1bHQgZmFsc2VcclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtZmxpY2tpbmcvT3B0aW9ucyNjaXJjdWxhciBjaXJjdWxhciAoIE9wdGlvbnMgKX1cclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NpcmN1bGFyO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICB0aGlzLl9jaXJjdWxhciA9IHZhbDtcbiAgICAgIHZvaWQgdGhpcy5yZXNpemUoKTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwiY2lyY3VsYXJGYWxsYmFja1wiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBTZXQgcGFuZWwgY29udHJvbCBtb2RlIGZvciB0aGUgY2FzZSB3aGVuIGNpcmN1bGFyIGNhbm5vdCBiZSBlbmFibGVkLlxyXG4gICAgICogXCJsaW5lYXJcIiB3aWxsIHNldCB0aGUgdmlldydzIHJhbmdlIGZyb20gdGhlIHRvcCBvZiB0aGUgZmlyc3QgcGFuZWwgdG8gdGhlIHRvcCBvZiB0aGUgbGFzdCBwYW5lbC5cclxuICAgICAqIFwiYm91bmRcIiB3aWxsIHByZXZlbnQgdGhlIHZpZXcgZnJvbSBnb2luZyBvdXQgb2YgdGhlIGZpcnN0L2xhc3QgcGFuZWwsIHNvIGl0IHdvbid0IHNob3cgZW1wdHkgc3BhY2VzIGJlZm9yZS9hZnRlciB0aGUgZmlyc3QvbGFzdCBwYW5lbC5cclxuICAgICAqIEBrbyDsiJztmZgg66qo65OcIOyCrOyaqSDrtojqsIDriqXsi5wg7IKs7Jqp7ZWgIO2MqOuEkCDsobDsnpEg67KU7JyEIOyEpOyglSDrsKnsi53snYQg67OA6rK97ZWp64uI64ukLlxyXG4gICAgICogXCJsaW5lYXJcIiDsgqzsmqnsi5wg7Iuc7KCQ7J20IOyyq+uyiOynuCDsl5jrpqzrqLztirgg7JyE7JeQ7ISc67aA7YSwIOuniOyngOuniSDsl5jrpqzrqLztirgg7JyE6rmM7KeAIOybgOyngeydvCDsiJgg7J6I64+E66GdIOyEpOygle2VqeuLiOuLpC5cclxuICAgICAqIFwiYm91bmRcIiDsgqzsmqnsi5wg7Iuc7KCQ7J20IOyyq+uyiOynuCDsl5jrpqzrqLztirjsmYAg66eI7KeA66eJIOyXmOumrOuovO2KuOydmCDrgZ3qs7wg64GdIOyCrOydtOyXkOyEnCDsm4Dsp4Hsnbwg7IiYIOyeiOuPhOuhnSDshKTsoJXtlanri4jri6QuXHJcbiAgICAgKiBAc2VlIENJUkNVTEFSX0ZBTExCQUNLXHJcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICogQGRlZmF1bHQgXCJsaW5lYXJcIlxyXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1mbGlja2luZy9PcHRpb25zI2NpcmN1bGFyZmFsbGJhY2sgY2lyY3VsYXJGYWxsYmFjayAoIE9wdGlvbnMgKX1cclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NpcmN1bGFyRmFsbGJhY2s7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcImJvdW5kXCIsIHtcbiAgICAvKipcclxuICAgICAqIFByZXZlbnQgdGhlIHZpZXcoY2FtZXJhIGVsZW1lbnQpIGZyb20gZ29pbmcgb3V0IG9mIHRoZSBmaXJzdC9sYXN0IHBhbmVsLCBzbyBpdCB3b24ndCBzaG93IGVtcHR5IHNwYWNlcyBiZWZvcmUvYWZ0ZXIgdGhlIGZpcnN0L2xhc3QgcGFuZWxcclxuICAgICAqIE9ubHkgY2FuIGJlIGVuYWJsZWQgd2hlbiBgY2lyY3VsYXI9ZmFsc2VgXHJcbiAgICAgKiBAa28g67ewKOy5tOuplOudvCDsl5jrpqzrqLztirgp6rCAIOyyq+uyiOynuOyZgCDrp4jsp4Drp4kg7Yyo64SQIOuwluycvOuhnCDrhJjslrTqsIDsp4Ag66q77ZWY6rKMIO2VmOyXrCwg7LKr67KI7Ke4L+uniOyngOuniSDtjKjrhJAg7KCEL+2bhOydmCDruYgg6rO16rCE7J2EIOuztOydtOyngCDslYrrj4TroZ0g7ZWY64qUIOyYteyFmOyeheuLiOuLpFxyXG4gICAgICogYGNpcmN1bGFyPWZhbHNlYOyduCDqsr3smrDsl5Drp4wg7IKs7Jqp7ZWgIOyImCDsnojsirXri4jri6RcclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICogQGRlZmF1bHQgZmFsc2VcclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtZmxpY2tpbmcvT3B0aW9ucyNib3VuZCBib3VuZCAoIE9wdGlvbnMgKX1cclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2JvdW5kO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICB0aGlzLl9ib3VuZCA9IHZhbDtcbiAgICAgIHZvaWQgdGhpcy5yZXNpemUoKTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwiYWRhcHRpdmVcIiwge1xuICAgIC8qKlxyXG4gICAgICogVXBkYXRlIGhlaWdodCBvZiB0aGUgdmlld3BvcnQgZWxlbWVudCBhZnRlciBtb3ZlbWVudCBzYW1lIHRvIHRoZSBoZWlnaHQgb2YgdGhlIHBhbmVsIGJlbG93LiBUaGlzIGNhbiBiZSBvbmx5IGVuYWJsZWQgd2hlbiBgaG9yaXpvbnRhbD10cnVlYFxyXG4gICAgICogQGtvIOydtOuPme2VnCDtm4Qg67ew7Y+s7Yq4IOyXmOumrOuovO2KuOydmCDtgazquLDrpbwg7ZiE7J6sIO2MqOuEkOydmCDrhpLsnbTsmYAg64+Z7J287ZWY6rKMIOyEpOygle2VqeuLiOuLpC4gYGhvcml6b250YWw9dHJ1ZWDsnbgg6rK97Jqw7JeQ66eMIOyCrOyaqe2VoCDsiJgg7J6I7Iq164uI64ukLlxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1mbGlja2luZy9PcHRpb25zI2FkYXB0aXZlIGFkYXB0aXZlICggT3B0aW9ucyApfVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYWRhcHRpdmU7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHRoaXMuX2FkYXB0aXZlID0gdmFsO1xuICAgICAgdm9pZCB0aGlzLnJlc2l6ZSgpO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJwYW5lbHNQZXJWaWV3XCIsIHtcbiAgICAvKipcclxuICAgICAqIEEgdmlzaWJsZSBudW1iZXIgb2YgcGFuZWxzIG9uIHZpZXdwb3J0LiBFbmFibGluZyB0aGlzIG9wdGlvbiB3aWxsIGF1dG9tYXRpY2FsbHkgcmVzaXplIHBhbmVsIHNpemVcclxuICAgICAqIEBrbyDtlZwg7ZmU66m07JeQIOuztOydtOuKlCDtjKjrhJDsnZgg6rCc7IiYLiDsnbQg7Ji17IWY7J2EIO2ZnOyEse2ZlO2VoCDqsr3smrAg7Yyo64SQ7J2YIO2BrOq4sOulvCDqsJXsoJzroZwg7J6s7KGw7KCV7ZWp64uI64ukXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgLTFcclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtZmxpY2tpbmcvT3B0aW9ucyNwYW5lbHNwZXJ2aWV3IHBhbmVsc1BlclZpZXcgKCBPcHRpb25zICl9XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wYW5lbHNQZXJWaWV3O1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICB0aGlzLl9wYW5lbHNQZXJWaWV3ID0gdmFsO1xuICAgICAgdm9pZCB0aGlzLnJlc2l6ZSgpO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJub1BhbmVsU3R5bGVPdmVycmlkZVwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBFbmFibGluZyB0aGlzIG9wdGlvbiB3aWxsIG5vdCBjaGFuZ2UgYHdpZHRoL2hlaWdodGAgc3R5bGUgb2YgdGhlIHBhbmVscyBpZiB7QGxpbmsgRmxpY2tpbmcjcGFuZWxzUGVyVmlld30gaXMgZW5hYmxlZC5cclxuICAgICAqIFRoaXMgYmVoYXZpb3IgY2FuIGJlIHVzZWZ1bCBpbiB0ZXJtcyBvZiBwZXJmb3JtYW5jZSB3aGVuIHlvdSdyZSBtYW51YWxseSBtYW5hZ2luZyBhbGwgcGFuZWwgc2l6ZXNcclxuICAgICAqIEBrbyDsnbQg7Ji17IWY7J2EIO2ZnOyEse2ZlO2VoCDqsr3smrAsIHtAbGluayBGbGlja2luZyNwYW5lbHNQZXJWaWV3fSDsmLXshZjsnbQg7Zmc7ISx7ZmU65CY7JeI7J2EIOuVjCDtjKjrhJDsnZggYHdpZHRoL2hlaWdodGAg7Iqk7YOA7J287J2EIOuzgOqyve2VmOyngCDslYrrj4TroZ0g7ISk7KCV7ZWp64uI64ukLlxyXG4gICAgICog66qo65OgIO2MqOuEkOuTpOydmCDtgazquLDrpbwg7KeB7KCRIOq0gOumrO2VmOqzoCDsnojsnYQg6rK97JqwLCDsnbQg7Ji17IWY7J2EIO2ZnOyEse2ZlO2VmOuptCDshLHriqXrqbTsl5DshJwg7Jyg66as7ZWgIOyImCDsnojsirXri4jri6RcclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICogQGRlZmF1bHQgZmFsc2VcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX25vUGFuZWxTdHlsZU92ZXJyaWRlO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICB0aGlzLl9ub1BhbmVsU3R5bGVPdmVycmlkZSA9IHZhbDtcbiAgICAgIHZvaWQgdGhpcy5yZXNpemUoKTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwicmVzaXplT25Db250ZW50c1JlYWR5XCIsIHtcbiAgICAvKipcclxuICAgICAqIEVuYWJsaW5nIHRoaXMgb3B0aW9uIHdpbGwgYXV0b21hdGljYWxseSBjYWxsIHtAbGluayBGbGlja2luZyNyZXNpemV9IHdoZW4gYWxsIGltYWdlL3ZpZGVvIGluc2lkZSBwYW5lbHMgYXJlIGxvYWRlZC5cclxuICAgICAqIFRoaXMgY2FuIGJlIHVzZWZ1bCB3aGVuIHlvdSBoYXZlIGNvbnRlbnRzIGluc2lkZSBGbGlja2luZyB0aGF0IGNoYW5nZXMgaXRzIHNpemUgd2hlbiBpdCdzIGxvYWRlZFxyXG4gICAgICogQGtvIOydtCDsmLXshZjsnYQg7Zmc7ISx7ZmU7ZWgIOqyveyasCwgRmxpY2tpbmcg7Yyo64SQIOuCtOu2gOydmCDsnbTrr7jsp4Av67mE65SU7Jik65Ok7J20IOuhnOuTnOuQmOyXiOydhCDrlYwg7J6Q64+Z7Jy866GcIHtAbGluayBGbGlja2luZyNyZXNpemV966W8IO2YuOy2nO2VqeuLiOuLpC5cclxuICAgICAqIOydtCDrj5nsnpHsnYAgRmxpY2tpbmcg64K067aA7JeQIOuhnOuTnCDsoIQv7ZuE66GcIO2BrOq4sOqwgCDrs4DtlZjripQg7L2Y7YWQ7Lig66W8IO2PrO2VqO2VmOqzoCDsnojsnYQg65WMIOycoOyaqe2VmOqyjCDsgqzsmqntlZjsi6Qg7IiYIOyeiOyKteuLiOuLpC5cclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICogQGRlZmF1bHQgZmFsc2VcclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtZmxpY2tpbmcvT3B0aW9ucyNyZXNpemVPbkNvbnRlbnRzUmVhZHkgcmVzaXplT25Db250ZW50c1JlYWR5ICggT3B0aW9ucyApfVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVzaXplT25Db250ZW50c1JlYWR5O1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICB0aGlzLl9yZXNpemVPbkNvbnRlbnRzUmVhZHkgPSB2YWw7XG4gICAgICBpZiAodmFsKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLmNoZWNrUGFuZWxDb250ZW50c1JlYWR5KHRoaXMuX3JlbmRlcmVyLnBhbmVscyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcIm5lc3RlZFwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBJZiB5b3UgZW5hYmxlIHRoaXMgb3B0aW9uIG9uIGNoaWxkIEZsaWNraW5nIHdoZW4gdGhlIEZsaWNraW5nIGlzIHBsYWNlZCBpbnNpZGUgdGhlIEZsaWNraW5nLCB0aGUgcGFyZW50IEZsaWNraW5nIHdpbGwgbW92ZSBpbiB0aGUgc2FtZSBkaXJlY3Rpb24gYWZ0ZXIgdGhlIGNoaWxkIEZsaWNraW5nIHJlYWNoZXMgdGhlIGZpcnN0L2xhc3QgcGFuZWwuXHJcbiAgICAgKiBJZiB0aGUgcGFyZW50IEZsaWNraW5nIGFuZCBjaGlsZCBGbGlja2luZyBoYXZlIGRpZmZlcmVudCBob3Jpem9udGFsIG9wdGlvbiwgeW91IGRvIG5vdCBuZWVkIHRvIHNldCB0aGlzIG9wdGlvbi5cclxuICAgICAqIEBrbyBGbGlja2luZyDrgrTrtoDsl5AgRmxpY2tpbmfsnbQg67Cw7LmY65CgIOuVjCDtlZjsnIQgRmxpY2tpbmfsl5DshJwg7J20IOyYteyFmOydhCDtmZzshLHtmZTtlZjrqbQg7ZWY7JyEIEZsaWNraW5n7J20IOyyqy/rp4jsp4Drp4kg7Yyo64SQ7JeQIOuPhOuLrO2VnCDrkqTrtoDthLAg6rCZ7J2AIOuwqe2WpeycvOuhnCDsg4HsnIQgRmxpY2tpbmfsnbQg7JuA7KeB7J6F64uI64ukLlxyXG4gICAgICog66eM7JW9IOyDgeychCBGbGlja2luZ+qzvCDtlZjsnIQgRmxpY2tpbmfsnbQg7ISc66GcIOuLpOuluCBob3Jpem9udGFsIOyYteyFmOydhCDqsIDsp4Dqs6Ag7J6I64uk66m0IOydtCDsmLXshZjsnYQg7ISk7KCV7ZWgIO2VhOyalOqwgCDsl4bsirXri4jri6QuXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqIEBkZWZhdWx0IGZhbHNlXHJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWZsaWNraW5nL09wdGlvbnMjbmVzdGVkIG5lc3RlZCAoIE9wdGlvbnMgKX1cclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX25lc3RlZDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgdGhpcy5fbmVzdGVkID0gdmFsO1xuICAgICAgdmFyIGF4ZXMgPSB0aGlzLl9jb250cm9sLmNvbnRyb2xsZXIuYXhlcztcbiAgICAgIGlmIChheGVzKSB7XG4gICAgICAgIGF4ZXMub3B0aW9ucy5uZXN0ZWQgPSB2YWw7XG4gICAgICB9XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcIm5lZWRQYW5lbFRocmVzaG9sZFwiLCB7XG4gICAgLy8gRVZFTlRTXG4gICAgLyoqXHJcbiAgICAgKiBBIFRocmVzaG9sZCBmcm9tIHZpZXdwb3J0IGVkZ2UgYmVmb3JlIHRyaWdnZXJpbmcgYG5lZWRQYW5lbGAgZXZlbnRcclxuICAgICAqIEBrbyBgbmVlZFBhbmVsYOydtOuypO2KuOqwgCDrsJzsg53tlZjquLAg7JyE7ZWcIOu3sO2PrO2KuCDrgZ3snLzroZzrtoDthLDsnZgg7LWc64yAIOqxsOumrFxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtZmxpY2tpbmcvT3B0aW9ucyNuZWVkcGFuZWx0aHJlc2hvbGQgbmVlZFBhbmVsVGhyZXNob2xkICggT3B0aW9ucyApfVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbmVlZFBhbmVsVGhyZXNob2xkO1xuICAgIH0sXG4gICAgLy8gRVZFTlRTXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICB0aGlzLl9uZWVkUGFuZWxUaHJlc2hvbGQgPSB2YWw7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcInByZXZlbnRFdmVudHNCZWZvcmVJbml0XCIsIHtcbiAgICAvKipcclxuICAgICAqIFdoZW4gZW5hYmxlZCwgZXZlbnRzIGFyZSBub3QgdHJpZ2dlcmVkIGJlZm9yZSBgcmVhZHlgIHdoZW4gaW5pdGlhbGl6aW5nXHJcbiAgICAgKiBAa28g7Zmc7ISx7ZmU7ZWgIOqyveyasCDstIjquLDtmZTsi5wgYHJlYWR5YCDsnbTrsqTtirgg7J207KCE7J2YIOydtOuypO2KuOqwgCDrsJzsg53tlZjsp4Ag7JWK7Iq164uI64ukLlxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKiBAZGVmYXVsdCB0cnVlXHJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWZsaWNraW5nL09wdGlvbnMjcHJldmVudGV2ZW50c2JlZm9yZWluaXQgcHJldmVudEV2ZW50c0JlZm9yZUluaXQgKCBPcHRpb25zICl9XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcmV2ZW50RXZlbnRzQmVmb3JlSW5pdDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgdGhpcy5fcHJldmVudEV2ZW50c0JlZm9yZUluaXQgPSB2YWw7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcImRlY2VsZXJhdGlvblwiLCB7XG4gICAgLy8gQU5JTUFUSU9OXG4gICAgLyoqXHJcbiAgICAgKiBEZWNlbGVyYXRpb24gdmFsdWUgZm9yIHBhbmVsIG1vdmVtZW50IGFuaW1hdGlvbiB3aGljaCBpcyB0cmlnZ2VyZWQgYnkgdXNlciBpbnB1dC4gQSBoaWdoZXIgdmFsdWUgbWVhbnMgYSBzaG9ydGVyIGFuaW1hdGlvbiB0aW1lXHJcbiAgICAgKiBAa28g7IKs7Jqp7J6Q7J2YIOuPmeyekeycvOuhnCDqsIDsho3rj4TqsIAg7KCB7Jqp65CcIO2MqOuEkCDsnbTrj5kg7JWg64uI66mU7J207IWY7J2YIOqwkOyGjeuPhC4g6rCS7J20IOuGkuydhOyImOuhnSDslaDri4jrqZTsnbTshZgg7Iuk7ZaJIOyLnOqwhOydtCDsp6fslYTsp5Hri4jri6RcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCAwLjAwNzVcclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtZmxpY2tpbmcvT3B0aW9ucyNkZWNlbGVyYXRpb24gZGVjZWxlcmF0aW9uICggT3B0aW9ucyApfVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGVjZWxlcmF0aW9uO1xuICAgIH0sXG4gICAgLy8gQU5JTUFUSU9OXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICB0aGlzLl9kZWNlbGVyYXRpb24gPSB2YWw7XG4gICAgICB2YXIgYXhlcyA9IHRoaXMuX2NvbnRyb2wuY29udHJvbGxlci5heGVzO1xuICAgICAgaWYgKGF4ZXMpIHtcbiAgICAgICAgYXhlcy5vcHRpb25zLmRlY2VsZXJhdGlvbiA9IHZhbDtcbiAgICAgIH1cbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwiZWFzaW5nXCIsIHtcbiAgICAvKipcclxuICAgICAqIEFuIGVhc2luZyBmdW5jdGlvbiBhcHBsaWVkIHRvIHRoZSBwYW5lbCBtb3ZlbWVudCBhbmltYXRpb24uIERlZmF1bHQgdmFsdWUgaXMgYGVhc2VPdXRDdWJpY2BcclxuICAgICAqIEBrbyDtjKjrhJAg7J2064+ZIOyVoOuLiOuplOydtOyFmOyXkCDsoIHsmqntlaAgZWFzaW5nIO2VqOyImC4g6riw67O46rCS7J2AIGBlYXNlT3V0Q3ViaWNg7J2064ukXHJcbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb259XHJcbiAgICAgKiBAZGVmYXVsdCB4ID0+IDEgLSBNYXRoLnBvdygxIC0geCwgMylcclxuICAgICAqIEBzZWUgRWFzaW5nIEZ1bmN0aW9ucyBDaGVhdCBTaGVldCB7QGxpbmsgaHR0cDovL2Vhc2luZ3MubmV0L30gPGtvPuydtOynlSDtlajsiJggQ2hlYXQgU2hlZXQge0BsaW5rIGh0dHA6Ly9lYXNpbmdzLm5ldC99PC9rbz5cclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtZmxpY2tpbmcvT3B0aW9ucyNlYXNpbmcgRWFzaW5nICggT3B0aW9ucyApfVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZWFzaW5nO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICB0aGlzLl9lYXNpbmcgPSB2YWw7XG4gICAgICB2YXIgYXhlcyA9IHRoaXMuX2NvbnRyb2wuY29udHJvbGxlci5heGVzO1xuICAgICAgaWYgKGF4ZXMpIHtcbiAgICAgICAgYXhlcy5vcHRpb25zLmVhc2luZyA9IHZhbDtcbiAgICAgIH1cbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwiZHVyYXRpb25cIiwge1xuICAgIC8qKlxyXG4gICAgICogRGVmYXVsdCBkdXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uIChtcylcclxuICAgICAqIEBrbyDrlJTtj7Ttirgg7JWg64uI66mU7J207IWYIOyerOyDnSDsi5zqsIQgKG1zKVxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDUwMFxyXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1mbGlja2luZy9PcHRpb25zI2R1cmF0aW9uIGR1cmF0aW9uICggT3B0aW9ucyApfVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZHVyYXRpb247XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHRoaXMuX2R1cmF0aW9uID0gdmFsO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJpbnB1dFR5cGVcIiwge1xuICAgIC8vIElOUFVUXG4gICAgLyoqXHJcbiAgICAgKiBUeXBlcyBvZiBpbnB1dCBkZXZpY2VzIHRvIGVuYWJsZVxyXG4gICAgICogQGtvIO2ZnOyEse2ZlO2VoCDsnoXroKUg7J6l7LmYIOyiheulmFxyXG4gICAgICogQHR5cGUge3N0cmluZ1tdfVxyXG4gICAgICogQGRlZmF1bHQgW1widG91Y2hcIiwgXCJtb3VzZVwiXVxyXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1heGVzL09wdGlvbnMjcGFuaW5wdXQtb3B0aW9ucyBQb3NzaWJsZSB2YWx1ZXMgKFBhbklucHV0T3B0aW9uI2lucHV0VHlwZSl9XHJcbiAgICAgKiA8a28+e0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtYXhlcy9PcHRpb25zI3BhbmlucHV0LW9wdGlvbnMg6rCA64ql7ZWcIOqwkuuTpCAoUGFuSW5wdXRPcHRpb24jaW5wdXRUeXBlKX08L2tvPlxyXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1mbGlja2luZy9PcHRpb25zI2lucHV0dHlwZSBpbnB1dFR5cGUgKCBPcHRpb25zICl9XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pbnB1dFR5cGU7XG4gICAgfSxcbiAgICAvLyBJTlBVVFxuICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgdGhpcy5faW5wdXRUeXBlID0gdmFsO1xuICAgICAgdmFyIHBhbklucHV0ID0gdGhpcy5fY29udHJvbC5jb250cm9sbGVyLnBhbklucHV0O1xuICAgICAgaWYgKHBhbklucHV0KSB7XG4gICAgICAgIHBhbklucHV0Lm9wdGlvbnMuaW5wdXRUeXBlID0gdmFsO1xuICAgICAgfVxuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJtb3ZlVHlwZVwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBNb3ZlbWVudCBzdHlsZSBieSB1c2VyIGlucHV0LiBUaGlzIHdpbGwgY2hhbmdlIGluc3RhbmNlIHR5cGUgb2Yge0BsaW5rIEZsaWNraW5nI2NvbnRyb2x9XHJcbiAgICAgKiBZb3UgY2FuIHVzZSB0aGUgdmFsdWVzIG9mIHRoZSBjb25zdGFudCB7QGxpbmsgTU9WRV9UWVBFfVxyXG4gICAgICogQGtvIOyCrOyaqeyekCDsnoXroKXsl5Ag7J2Y7ZWcIOydtOuPmSDrsKnsi50uIOydtCDqsJLsl5Ag65Sw6528IHtAbGluayBGbGlja2luZyNjb250cm9sfeydmCDsnbjsiqTthLTsiqQg7YOA7J6F7J20IOqysOygleuQqeuLiOuLpFxyXG4gICAgICog7IOB7IiYIHtAbGluayBNT1ZFX1RZUEV97JeQIOygleydmOuQnCDqsJLrk6TsnYQg7J207Jqp7ZWgIOyImCDsnojsirXri4jri6RcclxuICAgICAqIEB0eXBlIHtNT1ZFX1RZUEUgfCBQYWlyPHN0cmluZywgb2JqZWN0Pn1cclxuICAgICAqIEBkZWZhdWx0IFwic25hcFwiXHJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWZsaWNraW5nL09wdGlvbnMjbW92ZXR5cGUgbW92ZVR5cGUgKCBPcHRpb25zICl9XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogfG1vdmVUeXBlfGNvbnRyb2x8b3B0aW9uc3xcclxuICAgICAqIHw6LS0tOnw6LS0tOnw6LS0tOnxcclxuICAgICAqIHxcInNuYXBcInx7QGxpbmsgU25hcENvbnRyb2x9fHxcclxuICAgICAqIHxcImZyZWVTY3JvbGxcInx7QGxpbmsgRnJlZUNvbnRyb2x9fHtAbGluayBGcmVlQ29udHJvbE9wdGlvbnN9fFxyXG4gICAgICpcclxuICAgICAqIGBgYHRzXHJcbiAgICAgKiBpbXBvcnQgRmxpY2tpbmcsIHsgTU9WRV9UWVBFIH0gZnJvbSBcIkBlZ2pzL2ZsaWNraW5nXCI7XHJcbiAgICAgKlxyXG4gICAgICogY29uc3QgZmxpY2tpbmcgPSBuZXcgRmxpY2tpbmcoe1xyXG4gICAgICogICBtb3ZlVHlwZTogTU9WRV9UWVBFLlNOQVBcclxuICAgICAqIH0pO1xyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogYGBgdHNcclxuICAgICAqIGNvbnN0IGZsaWNraW5nID0gbmV3IEZsaWNraW5nKHtcclxuICAgICAqICAgLy8gSWYgeW91IHdhbnQgbW9yZSBzcGVjaWZpYyBzZXR0aW5ncyBmb3IgdGhlIG1vdmVUeXBlXHJcbiAgICAgKiAgIC8vIFttb3ZlVHlwZSwgb3B0aW9ucyBmb3IgdGhhdCBtb3ZlVHlwZV1cclxuICAgICAqICAgLy8gSW4gdGhpcyBjYXNlLCBpdCdzIFtcImZyZWVTY3JvbGxcIiwgRnJlZUNvbnRyb2xPcHRpb25zXVxyXG4gICAgICogICBtb3ZlVHlwZTogW01PVkVfVFlQRS5GUkVFX1NDUk9MTCwgeyBzdG9wQXRFZGdlOiB0cnVlIH1dXHJcbiAgICAgKiB9KTtcclxuICAgICAqIGBgYFxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbW92ZVR5cGU7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHRoaXMuX21vdmVUeXBlID0gdmFsO1xuICAgICAgdmFyIHByZXZDb250cm9sID0gdGhpcy5fY29udHJvbDtcbiAgICAgIHZhciBuZXdDb250cm9sID0gdGhpcy5fY3JlYXRlQ29udHJvbCgpO1xuICAgICAgdmFyIGFjdGl2ZVBhbmVsID0gcHJldkNvbnRyb2wuYWN0aXZlUGFuZWw7XG4gICAgICBuZXdDb250cm9sLmNvcHkocHJldkNvbnRyb2wpO1xuICAgICAgdmFyIHByZXZQcm9ncmVzc0luUGFuZWwgPSBhY3RpdmVQYW5lbCA/IHRoaXMuX2NhbWVyYS5nZXRQcm9ncmVzc0luUGFuZWwoYWN0aXZlUGFuZWwpIDogMDtcbiAgICAgIHRoaXMuX2NvbnRyb2wgPSBuZXdDb250cm9sO1xuICAgICAgdGhpcy5fY29udHJvbC51cGRhdGVQb3NpdGlvbihwcmV2UHJvZ3Jlc3NJblBhbmVsKTtcbiAgICAgIHRoaXMuX2NvbnRyb2wudXBkYXRlSW5wdXQoKTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwidGhyZXNob2xkXCIsIHtcbiAgICAvKipcclxuICAgICAqIE1vdmVtZW50IHRocmVzaG9sZCB0byBjaGFuZ2UgcGFuZWwgKHVuaXQ6IHB4KS4gSXQgc2hvdWxkIGJlIGRyYWdnZWQgYWJvdmUgdGhlIHRocmVzaG9sZCB0byBjaGFuZ2UgdGhlIGN1cnJlbnQgcGFuZWwuXHJcbiAgICAgKiBAa28g7Yyo64SQIOuzgOqyveydhCDsnITtlZwg7J2064+ZIOyehOqzhOqwkiAo64uo7JyEOiBweCkuIOyjvOyWtOynhCDqsJIg7J207IOB7Jy866GcIOyKpO2BrOuhpO2VtOyVvOunjCDtjKjrhJAg67OA6rK97J20IOqwgOuKpe2VmOuLpC5cclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCA0MFxyXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1mbGlja2luZy9PcHRpb25zI3RocmVzaG9sZCBUaHJlc2hvbGQgKCBPcHRpb25zICl9XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl90aHJlc2hvbGQ7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHRoaXMuX3RocmVzaG9sZCA9IHZhbDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwiaW50ZXJydXB0YWJsZVwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBTZXQgYW5pbWF0aW9uIHRvIGJlIGludGVycnVwdGFibGUgYnkgY2xpY2svdG91Y2guXHJcbiAgICAgKiBAa28g7IKs7Jqp7J6Q7J2YIO2BtOumrS/thLDsuZjroZwg7J247ZW0IOyVoOuLiOuplOydtOyFmOydhCDrj4TspJHsl5Ag66mI7LacIOyImCDsnojrj4TroZ0g7ISk7KCV7ZWp64uI64ukLlxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKiBAZGVmYXVsdCB0cnVlXHJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWZsaWNraW5nL09wdGlvbnMjaW50ZXJydXB0YWJsZSBJbnRlcnJ1cHRhYmxlICggT3B0aW9ucyApfVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5faW50ZXJydXB0YWJsZTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgdGhpcy5faW50ZXJydXB0YWJsZSA9IHZhbDtcbiAgICAgIHZhciBheGVzID0gdGhpcy5fY29udHJvbC5jb250cm9sbGVyLmF4ZXM7XG4gICAgICBpZiAoYXhlcykge1xuICAgICAgICBheGVzLm9wdGlvbnMuaW50ZXJydXB0YWJsZSA9IHZhbDtcbiAgICAgIH1cbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwiYm91bmNlXCIsIHtcbiAgICAvKipcclxuICAgICAqIFRoZSBzaXplIHZhbHVlIG9mIHRoZSBib3VuY2UgYXJlYS4gT25seSBjYW4gYmUgZW5hYmxlZCB3aGVuIGBjaXJjdWxhcj1mYWxzZWAuXHJcbiAgICAgKiBZb3UgY2FuIHNldCBkaWZmZXJlbnQgYm91bmNlIHZhbHVlIGZvciBwcmV2L25leHQgZGlyZWN0aW9uIGJ5IHVzaW5nIGFycmF5LlxyXG4gICAgICogYG51bWJlcmAgZm9yIHB4IHZhbHVlLCBhbmQgYHN0cmluZ2AgZm9yIHB4LCBhbmQgJSB2YWx1ZSByZWxhdGl2ZSB0byB2aWV3cG9ydCBzaXplLlxyXG4gICAgICogWW91IGhhdmUgdG8gY2FsbCB7QGxpbmsgQ29udHJvbCN1cGRhdGVJbnB1dH0gYWZ0ZXIgY2hhbmdpbmcgdGhpcyB0byB0YWtlIGVmZmVjdC5cclxuICAgICAqIEBrbyBGbGlja2luZ+ydtCDstZzrjIAg7JiB7Jet7J2EIOuEmOyWtOyEnCDqsIgg7IiYIOyeiOuKlCDstZzrjIAg7YGs6riwLiBgY2lyY3VsYXI9ZmFsc2Vg7J24IOqyveyasOyXkOunjCDsgqzsmqntlaAg7IiYIOyeiOyKteuLiOuLpC5cclxuICAgICAqIOuwsOyXtOydhCDthrXtlbQgcHJldi9uZXh0IOuwqe2WpeyXkCDrjIDtlbQg7ISc66GcIOuLpOuluCDrsJTsmrTsiqQg6rCS7J2EIOyngOygle2VoCDsiJgg7J6I7Iq164uI64ukLlxyXG4gICAgICogYG51bWJlcmDrpbwg7Ya17ZW0IHB46rCS7J2ELCBgc3Rpcm5nYOydhCDthrXtlbQgcHgg7Zi57J2AIOu3sO2PrO2KuCDtgazquLAg64yA67mEICXqsJLsnYQg7IKs7Jqp7ZWgIOyImCDsnojsirXri4jri6QuXHJcbiAgICAgKiDsnbQg6rCS7J2EIOuzgOqyveyLnCB7QGxpbmsgQ29udHJvbCN1cGRhdGVJbnB1dH3rpbwg7Zi47Lac7ZW07JW8IO2VqeuLiOuLpC5cclxuICAgICAqIEB0eXBlIHtzdHJpbmcgfCBudW1iZXIgfCBBcnJheTxzdHJpbmcgfCBudW1iZXI+fVxyXG4gICAgICogQGRlZmF1bHQgXCIyMCVcIlxyXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1mbGlja2luZy9PcHRpb25zI2JvdW5jZSBib3VuY2UgKCBPcHRpb25zICl9XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYGBgdHNcclxuICAgICAqIGNvbnN0IHBvc3NpYmxlT3B0aW9ucyA9IFtcclxuICAgICAqICAgLy8gJSB2YWx1ZXMsIHJlbGF0aXZlIHRvIHZpZXdwb3J0IGVsZW1lbnQoXCIuZmxpY2tpbmctdmlld3BvcnRcIikncyBzaXplXHJcbiAgICAgKiAgIFwiMCVcIiwgXCIyNSVcIiwgXCI0MiVcIixcclxuICAgICAqICAgLy8gcHggdmFsdWVzLCBhcml0aG1ldGljIGNhbGN1bGF0aW9uIHdpdGggKCsvLSkgaXMgYWxzbyBhbGxvd2VkLlxyXG4gICAgICogICBcIjBweFwiLCBcIjEwMHB4XCIsIFwiNTAlIC0gMjVweFwiLFxyXG4gICAgICogICAvLyBudW1iZXJzLCBzYW1lIHRvIG51bWJlciArIHB4IChcIjBweFwiLCBcIjEwMHB4XCIpXHJcbiAgICAgKiAgIDAsIDEwMCwgMTAwMFxyXG4gICAgICogXTtcclxuICAgICAqIGBgYFxyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBgYGB0c1xyXG4gICAgICogY29uc3QgZmxpY2tpbmcgPSBuZXcgRmxpY2tpbmcoXCIjZWxcIiwgeyBib3VuY2U6IFwiMjAlXCIgfSk7XHJcbiAgICAgKlxyXG4gICAgICogZmxpY2tpbmcuYm91bmNlID0gXCIxMDAlXCI7XHJcbiAgICAgKiBmbGlja2luZy5jb250cm9sLnVwZGF0ZUlucHV0KCk7IC8vIENhbGwgdGhpcyB0byB1cGRhdGUhXHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2JvdW5jZTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgdGhpcy5fYm91bmNlID0gdmFsO1xuICAgICAgdGhpcy5fY29udHJvbC51cGRhdGVJbnB1dCgpO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJpT1NFZGdlU3dpcGVUaHJlc2hvbGRcIiwge1xuICAgIC8qKlxyXG4gICAgICogU2l6ZSBvZiB0aGUgYXJlYSBmcm9tIHRoZSByaWdodCBlZGdlIGluIGlPUyBzYWZhcmkgKGluIHB4KSB3aGljaCBlbmFibGVzIHN3aXBlLWJhY2sgb3Igc3dpcGUtZm9yd2FyZFxyXG4gICAgICogQGtvIGlPUyBTYWZhcmnsl5DshJwgc3dpcGXrpbwg7Ya17ZWcIOuSpOuhnOqwgOq4sC/slZ7snLzroZzqsIDquLDrpbwg7Zmc7ISx7ZmU7ZWY64qUIOyYpOuluOyqvSDrgZ3snLzroZzrtoDthLDsnZgg7JiB7Jet7J2YIO2BrOq4sCAocHgpXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgMzBcclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtZmxpY2tpbmcvT3B0aW9ucyNpb3NlZGdlc3dpcGV0aHJlc2hvbGQgaU9TRWRnZVN3aXBlVGhyZXNob2xkICggT3B0aW9ucyApfVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5faU9TRWRnZVN3aXBlVGhyZXNob2xkO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICB0aGlzLl9pT1NFZGdlU3dpcGVUaHJlc2hvbGQgPSB2YWw7XG4gICAgICB2YXIgcGFuSW5wdXQgPSB0aGlzLl9jb250cm9sLmNvbnRyb2xsZXIucGFuSW5wdXQ7XG4gICAgICBpZiAocGFuSW5wdXQpIHtcbiAgICAgICAgcGFuSW5wdXQub3B0aW9ucy5pT1NFZGdlU3dpcGVUaHJlc2hvbGQgPSB2YWw7XG4gICAgICB9XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcInByZXZlbnRDbGlja09uRHJhZ1wiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBBdXRvbWF0aWNhbGx5IHByZXZlbnQgYGNsaWNrYCBldmVudCBpZiB0aGUgdXNlciBoYXMgZHJhZ2dlZCBhdCBsZWFzdCBhIHNpbmdsZSBwaXhlbCBvbiB0aGUgdmlld3BvcnQgZWxlbWVudFxyXG4gICAgICogQGtvIOyCrOyaqeyekOqwgCDrt7Dtj6ztirgg7JiB7Jet7J2EIDHtlL3shYDsnbTrnbzrj4Qg65Oc656Y6re47ZaI7J2EIOqyveyasCDsnpDrj5nsnLzroZwge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2tvL2RvY3MvV2ViL0FQSS9FbGVtZW50L2NsaWNrX2V2ZW50IGNsaWNrfSDsnbTrsqTtirjrpbwg7Leo7IaM7ZWp64uI64ukXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqIEBkZWZhdWx0IHRydWVcclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtZmxpY2tpbmcvT3B0aW9ucyNwcmV2ZW50Y2xpY2tvbmRyYWcgcHJldmVudENsaWNrT25EcmFnICggT3B0aW9ucyApfVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJldmVudENsaWNrT25EcmFnO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICB2YXIgcHJldlZhbCA9IHRoaXMuX3ByZXZlbnRDbGlja09uRHJhZztcbiAgICAgIGlmICh2YWwgPT09IHByZXZWYWwpIHJldHVybjtcbiAgICAgIHZhciBjb250cm9sbGVyID0gdGhpcy5fY29udHJvbC5jb250cm9sbGVyO1xuICAgICAgaWYgKHZhbCkge1xuICAgICAgICBjb250cm9sbGVyLmFkZFByZXZlbnRDbGlja0hhbmRsZXIoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRyb2xsZXIucmVtb3ZlUHJldmVudENsaWNrSGFuZGxlcigpO1xuICAgICAgfVxuICAgICAgdGhpcy5fcHJldmVudENsaWNrT25EcmFnID0gdmFsO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJwcmV2ZW50RGVmYXVsdE9uRHJhZ1wiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHRvIHVzZSB0aGUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2tvL2RvY3MvV2ViL0FQSS9FdmVudC9wcmV2ZW50RGVmYXVsdCBwcmV2ZW50RGVmYXVsdH0gd2hlbiB0aGUgdXNlciBzdGFydHMgZHJhZ2dpbmdcclxuICAgICAqIEBrbyDsgqzsmqnsnpDqsIAg65Oc656Y6re466W8IOyLnOyeke2VoCDrlYwge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2tvL2RvY3MvV2ViL0FQSS9FdmVudC9wcmV2ZW50RGVmYXVsdCBwcmV2ZW50RGVmYXVsdH0g7Iuk7ZaJIOyXrOu2gFxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1mbGlja2luZy9PcHRpb25zI3ByZXZlbnREZWZhdWx0T25EcmFnIHByZXZlbnREZWZhdWx0T25EcmFnICggT3B0aW9ucyApfVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJldmVudERlZmF1bHRPbkRyYWc7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHRoaXMuX3ByZXZlbnREZWZhdWx0T25EcmFnID0gdmFsO1xuICAgICAgdmFyIHBhbklucHV0ID0gdGhpcy5fY29udHJvbC5jb250cm9sbGVyLnBhbklucHV0O1xuICAgICAgaWYgKHBhbklucHV0KSB7XG4gICAgICAgIHBhbklucHV0Lm9wdGlvbnMucHJldmVudERlZmF1bHRPbkRyYWcgPSB2YWw7XG4gICAgICB9XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcImRpc2FibGVPbkluaXRcIiwge1xuICAgIC8qKlxyXG4gICAgICogQXV0b21hdGljYWxseSBjYWxsIHtAbGluayBGbGlja2luZyNkaXNhYmxlSW5wdXQgZGlzYWJsZUlucHV0KCl9IG9uIGluaXRpYWxpemF0aW9uXHJcbiAgICAgKiBAa28gRmxpY2tpbmcgaW5pdOyLnOyXkCB7QGxpbmsgRmxpY2tpbmcjZGlzYWJsZUlucHV0IGRpc2FibGVJbnB1dCgpfeydhCDrsJTroZwg7Zi47Lac7ZWp64uI64ukXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqIEBkZWZhdWx0IGZhbHNlXHJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWZsaWNraW5nL09wdGlvbnMjZGlzYWJsZW9uaW5pdCBkaXNhYmxlT25Jbml0ICggT3B0aW9ucyApfVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGlzYWJsZU9uSW5pdDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgdGhpcy5fZGlzYWJsZU9uSW5pdCA9IHZhbDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwiY2hhbmdlT25Ib2xkXCIsIHtcbiAgICAvKipcclxuICAgICAqIENoYW5nZSBhY3RpdmUgcGFuZWwgaW5kZXggb24gbW91c2UvdG91Y2ggaG9sZCB3aGlsZSBhbmltYXRpbmcuXHJcbiAgICAgKiBgaW5kZXhgIG9mIHRoZSBgd2lsbENoYW5nZWAvYHdpbGxSZXN0b3JlYCBldmVudCB3aWxsIGJlIHVzZWQgYXMgbmV3IGluZGV4LlxyXG4gICAgICogQGtvIOyVoOuLiOuplOydtOyFmCDrj4TspJEg66eI7Jqw7IqkL+2EsOy5mCDsnoXroKXsi5wg7ZiE7J6sIO2ZnOyEse2ZlOuQnCDtjKjrhJDsnZgg7J24642x7Iqk66W8IOuzgOqyve2VqeuLiOuLpC5cclxuICAgICAqIGB3aWxsQ2hhbmdlYC9gd2lsbFJlc3RvcmVgIOydtOuypO2KuOydmCBgaW5kZXhg6rCS7J20IOyDiOuhnOyatCDsnbjrjbHsiqTroZwg7IKs7Jqp65CgIOqyg+yeheuLiOuLpC5cclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICogQGRlZmF1bHQgZmFsc2VcclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtZmxpY2tpbmcvT3B0aW9ucyNjaGFuZ2VvbmhvbGQgY2hhbmdlT25Ib2xkICggT3B0aW9ucyApfVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2hhbmdlT25Ib2xkO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICB0aGlzLl9jaGFuZ2VPbkhvbGQgPSB2YWw7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcInJlbmRlck9ubHlWaXNpYmxlXCIsIHtcbiAgICAvLyBQRVJGT1JNQU5DRVxuICAgIC8qKlxyXG4gICAgICogV2hldGhlciB0byByZW5kZXIgdmlzaWJsZSBwYW5lbHMgb25seS4gVGhpcyBjYW4gZHJhbWF0aWNhbGx5IGluY3JlYXNlIHBlcmZvcm1hbmNlIHdoZW4gdGhlcmUncmUgbWFueSBwYW5lbHNcclxuICAgICAqIEBrbyDrs7TsnbTripQg7Yyo64SQ66eMIOugjOuNlOunge2VoOyngCDsl6zrtoDrpbwg7ISk7KCV7ZWp64uI64ukLiDtjKjrhJDsnbQg66eO7J2EIOqyveyasOyXkCDtjbztj6zrqLzsiqTrpbwg7YGs6rKMIO2WpeyDgeyLnO2CrCDsiJgg7J6I7Iq164uI64ukXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqIEBkZWZhdWx0IGZhbHNlXHJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWZsaWNraW5nL09wdGlvbnMjcmVuZGVyb25seXZpc2libGUgcmVuZGVyT25seVZpc2libGUgKCBPcHRpb25zICl9XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJPbmx5VmlzaWJsZTtcbiAgICB9LFxuICAgIC8vIFBFUkZPUk1BTkNFXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICB0aGlzLl9yZW5kZXJPbmx5VmlzaWJsZSA9IHZhbDtcbiAgICAgIHZvaWQgdGhpcy5fcmVuZGVyZXIucmVuZGVyKCk7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcInZpcnR1YWxcIiwge1xuICAgIC8qKlxyXG4gICAgICogQnkgZW5hYmxpbmcgdGhpcyBvcHRpb24sIGl0IHdpbGwgcmVkdWNlIG1lbW9yeSBjb25zdW1wdGlvbiBieSByZXN0cmljdGluZyB0aGUgbnVtYmVyIG9mIERPTSBlbGVtZW50cyB0byBgcGFuZWxzUGVyVmlldyArIDFgXHJcbiAgICAgKiBNdXN0IGJlIHVzZWQgd2l0aCBgcGFuZWxzUGVydmlld2AuXHJcbiAgICAgKiBBZnRlciBGbGlja2luZydzIGluaXRpYWxpemVkLCB0aGlzIHByb3BlcnR5IGNhbiBiZSB1c2VkIHRvIGFkZC9yZW1vdmUgdGhlIHBhbmVsIGNvdW50LlxyXG4gICAgICogQGtvIOydtCDsmLXshZjsnYQg7Zmc7ISx7ZmU7ZWgIOqyveyasCDtjKjrhJAg7JeY66as66i87Yq47J2YIOqwnOyImOulvCBgcGFuZWxzUGVyVmlldyArIDFgIOqwnOuhnCDqs6DsoJXtlajsnLzroZzsjagsIOuplOuqqOumrCDsgqzsmqnrn4nsnYQg7KSE7J28IOyImCDsnojsirXri4jri6QuXHJcbiAgICAgKiBgcGFuZWxzUGVyVmlld2Ag7Ji17IWY6rO8IO2VqOq7mCDsgqzsmqnrkJjslrTslbzrp4wg7ZWp64uI64ukLlxyXG4gICAgICogRmxpY2tpbmcg7LSI6riw7ZmUIOydtO2bhOyXkCwg7J20IO2UhOuhnO2NvO2LsOuKlCDroIzrjZTrp4HtlZjripQg7Yyo64SQ7J2YIOqwnOyImOulvCDstpTqsIAv7KCc6rGw7ZWY6riwIOychO2VtCDsgqzsmqnrkKAg7IiYIOyeiOyKteuLiOuLpC5cclxuICAgICAqIEB0eXBlIHtWaXJ0dWFsTWFuYWdlcn1cclxuICAgICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IHJlbmRlclBhbmVsIEEgcmVuZGVyaW5nIGZ1bmN0aW9uIGZvciB0aGUgcGFuZWwgZWxlbWVudCdzIGlubmVySFRNTDxrbz7tjKjrhJAg7JeY66as66i87Yq47J2YIGlubmVySFRNTOydhCDroIzrjZTrp4HtlZjripQg7ZWo7IiYPC9rbz5cclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpbml0aWFsUGFuZWxDb3VudCBJbml0aWFsIHBhbmVsIGNvdW50IHRvIHJlbmRlcjxrbz7stZzstIjroZwg66CM642U66eB7ZWgIO2MqOuEkOydmCDqsJzsiJg8L2tvPlxyXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbY2FjaGU9ZmFsc2VdIFdoZXRoZXIgdG8gY2FjaGUgcmVuZGVyZWQgcGFuZWwncyBpbm5lckhUTUw8a28+66CM642U66eB65CcIO2MqOuEkOydmCBpbm5lckhUTUwg7KCV67O066W8IOy6kOyLnO2VoOyngCDsl6zrtoA8L2tvPlxyXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtwYW5lbENsYXNzPVwiZmxpY2tpbmctcGFuZWxcIl0gVGhlIGNsYXNzIG5hbWUgdGhhdCB3aWxsIGJlIGFwcGxpZWQgdG8gcmVuZGVyZWQgcGFuZWwgZWxlbWVudHM8a28+66CM642U66eB65CY64qUIO2MqOuEkCDsl5jrpqzrqLztirjsl5Ag7KCB7Jqp65CgIO2BtOuemOyKpCDsnbTrpoQ8L2tvPlxyXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1mbGlja2luZy9PcHRpb25zI3ZpcnR1YWwgdmlydHVhbCAoIE9wdGlvbnMgKX1cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBgYGB0c1xyXG4gICAgICogaW1wb3J0IEZsaWNraW5nLCB7IFZpcnR1YWxQYW5lbCB9IGZyb20gXCJAZWdqcy9mbGlja2luZ1wiO1xyXG4gICAgICpcclxuICAgICAqIGNvbnN0IGZsaWNraW5nID0gbmV3IEZsaWNraW5nKFwiI3NvbWVfZWxcIiwge1xyXG4gICAgICogICBwYW5lbHNQZXJWaWV3OiAzLFxyXG4gICAgICogICB2aXJ0dWFsOiB7XHJcbiAgICAgKiAgICAgcmVuZGVyUGFuZWw6IChwYW5lbDogVmlydHVhbFBhbmVsLCBpbmRleDogbnVtYmVyKSA9PiBgUGFuZWwgJHtpbmRleH1gLFxyXG4gICAgICogICAgIGluaXRpYWxQYW5lbENvdW50OiAxMDBcclxuICAgICAqICAgfVxyXG4gICAgICogfSk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gQWRkIDEwMCB2aXJ0dWFsIHBhbmVscyAoYXQgdGhlIGVuZClcclxuICAgICAqIGZsaWNraW5nLnZpcnR1YWwuYXBwZW5kKDEwMCk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gUmVtb3ZlIDEwMCB2aXJ0dWFsIHBhbmVscyBmcm9tIDAgdG8gMTAwXHJcbiAgICAgKiBmbGlja2luZy52aXJ0dWFsLnJlbW92ZSgwLCAxMDApO1xyXG4gICAgICogYGBgXHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl92aXJ0dWFsTWFuYWdlcjtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwiYXV0b0luaXRcIiwge1xuICAgIC8vIE9USEVSU1xuICAgIC8qKlxyXG4gICAgICogQ2FsbCB7QGxpbmsgRmxpY2tpbmcjaW5pdCBpbml0KCl9IGF1dG9tYXRpY2FsbHkgd2hlbiBjcmVhdGluZyBGbGlja2luZydzIGluc3RhbmNlXHJcbiAgICAgKiBAa28gRmxpY2tpbmcg7J247Iqk7YS07Iqk66W8IOyDneyEse2VoCDrlYwg7J6Q64+Z7Jy866GcIHtAbGluayBGbGlja2luZyNpbml0IGluaXQoKX3rpbwg7Zi47Lac7ZWp64uI64ukXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqIEBkZWZhdWx0IHRydWVcclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtZmxpY2tpbmcvT3B0aW9ucyNhdXRvaW5pdCBhdXRvSW5pdCAoIE9wdGlvbnMgKX1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYXV0b0luaXQ7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcImF1dG9SZXNpemVcIiwge1xuICAgIC8qKlxyXG4gICAgICogV2hldGhlciB0byBhdXRvbWF0aWNhbGx5IGNhbGwge0BsaW5rIEZsaWNraW5nI3Jlc2l6ZSByZXNpemUoKX0gd2hlbiB0aGUgdmlld3BvcnQgZWxlbWVudCguZmxpY2tpbmctdmlld3BvcnQpJ3Mgc2l6ZSBpcyBjaGFuZ2VkXHJcbiAgICAgKiBAa28g67ew7Y+s7Yq4IOyXmOumrOuovO2KuCguZmxpY2tpbmctdmlld3BvcnQp7J2YIO2BrOq4sCDrs4Dqsr3si5wge0BsaW5rIEZsaWNraW5nI3Jlc2l6ZSByZXNpemUoKX0g66mU7IaM65Oc66W8IOyekOuPmeycvOuhnCDtmLjstpztlaDsp4Ag7Jes67aA66W8IOyEpOygle2VqeuLiOuLpFxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKiBAZGVmYXVsdCB0cnVlXHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9hdXRvUmVzaXplO1xuICAgIH0sXG4gICAgLy8gT1RIRVJTXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICB0aGlzLl9hdXRvUmVzaXplID0gdmFsO1xuICAgICAgaWYgKHZhbCkge1xuICAgICAgICB0aGlzLl9hdXRvUmVzaXplci5lbmFibGUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2F1dG9SZXNpemVyLmRpc2FibGUoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwidXNlUmVzaXplT2JzZXJ2ZXJcIiwge1xuICAgIC8qKlxyXG4gICAgICogV2hldGhlciB0byBsaXN0ZW4ge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9SZXNpemVPYnNlcnZlciBSZXNpemVPYnNlcnZlcn0ncyBldmVudCBpbnN0ZWFkIG9mIFdpbmRvdydzIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9rby9kb2NzL1dlYi9BUEkvV2luZG93L3Jlc2l6ZV9ldmVudCByZXNpemV9IGV2ZW50IHdoZW4gdXNpbmcgdGhlIGBhdXRvUmVzaXplYCBvcHRpb25cclxuICAgICAqIEBrbyBhdXRvUmVzaXplIOyYteyFmCDsgqzsmqnsi5wge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9SZXNpemVPYnNlcnZlciBSZXNpemVPYnNlcnZlcn3snZgg7J2067Kk7Yq466W8IFdpbmRvd+qwneyytOydmCB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcva28vZG9jcy9XZWIvQVBJL1dpbmRvdy9yZXNpemVfZXZlbnQgcmVzaXplfSDsnbTrsqTtirgg64yA7IugIOyImOyLoO2VoOyngCDsl6zrtoDrpbwg7ISk7KCV7ZWp64uI64ukXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqIEBkZWZhdWx0IHRydWVcclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtZmxpY2tpbmcvT3B0aW9ucyN1c2VyZXNpemVvYnNlcnZlciB1c2VSZXNpemVPYnNlcnZlciAoIE9wdGlvbnMgKX1cclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3VzZVJlc2l6ZU9ic2VydmVyO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICB0aGlzLl91c2VSZXNpemVPYnNlcnZlciA9IHZhbDtcbiAgICAgIGlmICh0aGlzLl9hdXRvUmVzaXplKSB7XG4gICAgICAgIHRoaXMuX2F1dG9SZXNpemVyLmVuYWJsZSgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJyZXNpemVEZWJvdW5jZVwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBEZWxheXMgc2l6ZSByZWNhbGN1bGF0aW9uIGZyb20gYGF1dG9SZXNpemVgIGJ5IHRoZSBnaXZlbiB0aW1lIGluIG1pbGlzZWNvbmQuXHJcbiAgICAgKiBJZiB0aGUgc2l6ZSBpcyBjaGFuZ2VkIGFnYWluIHdoaWxlIGJlaW5nIGRlbGF5ZWQsIGl0IGNhbmNlbHMgdGhlIHByZXZpb3VzIG9uZSBhbmQgZGVsYXlzIGZyb20gdGhlIGJlZ2lubmluZyBhZ2Fpbi5cclxuICAgICAqIFRoaXMgY2FuIGluY3JlYXNlIHBlcmZvcm1hbmNlIGJ5IHByZXZlbnRpbmcgYHJlc2l6ZWAgYmVpbmcgY2FsbGVkIHRvbyBvZnRlbi5cclxuICAgICAqIEBrbyBgYXV0b1Jlc2l6ZWAg7ISk7KCV7Iuc7JeQIO2YuOy2nOuQmOuKlCDtgazquLAg7J6s6rOE7IKw7J2EIOyjvOyWtOynhCDsi5zqsIQo64uo7JyEOiBtcynrp4ztgbwg7KeA7Jew7Iuc7YK164uI64ukLlxyXG4gICAgICog7KeA7Jew7Iuc7YKk64qUIOuPhOykkSDtgazquLDqsIAg64uk7IucIOuzgOqyveuQmOyXiOydhCDqsr3smrAsIOydtOyghCDqsoPsnYQg7Leo7IaM7ZWY6rOgIOyjvOyWtOynhCDsi5zqsITrp4ztgbwg64uk7IucIOyngOyXsOyLnO2CteuLiOuLpC5cclxuICAgICAqIOydtOulvCDthrXtlbQgYHJlc2l6ZWDqsIAg64SI66y0IOunjuydtCDtmLjstpzrkJjripQg6rKD7J2EIOuwqeyngO2VmOyXrCDshLHriqXsnYQg7Zal7IOB7Iuc7YKsIOyImCDsnojsirXri4jri6QuXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgMFxyXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1mbGlja2luZy9PcHRpb25zI3Jlc2l6ZWRlYm91bmNlIHJlc2l6ZURlYm91bmNlICggT3B0aW9ucyApfVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVzaXplRGVib3VuY2U7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcIm1heFJlc2l6ZURlYm91bmNlXCIsIHtcbiAgICAvKipcclxuICAgICAqIFRoZSBtYXhpbXVtIHRpbWUgZm9yIHNpemUgcmVjYWxjdWxhdGlvbiBkZWxheSB3aGVuIHVzaW5nIGByZXNpemVEZWJvdW5jZWAsIGluIG1pbGlzZWNvbmQuXHJcbiAgICAgKiBUaGlzIGd1YXJhbnRlZXMgdGhhdCBzaXplIHJlY2FsY3VsYXRpb24gaXMgcGVyZm9ybWVkIGF0IGxlYXN0IG9uY2UgZXZlcnkgKG4pbXMuXHJcbiAgICAgKiBAa28gYHJlc2l6ZURlYm91bmNlYCDsgqzsmqnsi5zsl5Ag7YGs6riwIOyerOqzhOyCsOydtCDsp4Dsl7DrkJjripQg7LWc64yAIOyLnOqwhOydhCDsp4DsoJXtlanri4jri6QuICjri6jsnIQ6IG1zKVxyXG4gICAgICog7J2066W8IO2Gte2VtCwg7KCB7Ja064+EIChuKW1z7JeQIO2VnOuyiOydgCDtgazquLAg7J6s6rOE7IKw7J2EIOyImO2Wie2VmOuKlCDqsoPsnYQg67O07J6l7ZWgIOyImCDsnojsirXri4jri6QuXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgMTAwXHJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWZsaWNraW5nL09wdGlvbnMjbWF4cmVzaXplZGVib3VuY2UgbWF4UmVzaXplRGVib3VuY2UgKCBPcHRpb25zICl9XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tYXhSZXNpemVEZWJvdW5jZTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwidXNlRnJhY3Rpb25hbFNpemVcIiwge1xuICAgIC8qKlxyXG4gICAgICogQnkgZW5hYmxpbmcgdGhpcywgRmxpY2tpbmcgd2lsbCBjYWxjdWxhdGUgYWxsIGludGVybmFsIHNpemUgd2l0aCBDU1Mgd2lkdGggY29tcHV0ZWQgd2l0aCBnZXRDb21wdXRlZFN0eWxlLlxyXG4gICAgICogVGhpcyBjYW4gcHJldmVudCAxcHggb2Zmc2V0IGlzc3VlIGluIHNvbWUgY2FzZXMgd2hlcmUgcGFuZWwgc2l6ZSBoYXMgdGhlIGZyYWN0aW9uYWwgcGFydC5cclxuICAgICAqIEFsbCBzaXplcyB3aWxsIGhhdmUgdGhlIG9yaWdpbmFsIHNpemUgYmVmb3JlIENTUyB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL3RyYW5zZm9ybSB0cmFuc2Zvcm19IGlzIGFwcGxpZWQgb24gdGhlIGVsZW1lbnQuXHJcbiAgICAgKiBAa28g7J20IOyYteyFmOydhCDtmZzshLHtmZTtlaAg6rK97JqwLCBGbGlja2luZ+ydgCDrgrTrtoDsnZgg66qo65OgIO2BrOq4sOulvCB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VsZW1lbnQvZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGdldEJvdW5kaW5nQ2xpZW50UmVjdH3rpbwg7J207Jqp7ZWY7JesIOqzhOyCsO2VqeuLiOuLpC5cclxuICAgICAqIOydtOulvCDthrXtlbQsIO2MqOuEkCDtgazquLDsl5Ag7IaM7IiY7KCQ7J2EIO2PrO2VqO2VoCDqsr3smrDsl5Ag67Cc7IOd7ZWgIOyImCDsnojripQg7J2867aAIDFweCDsmKTtlITshYsg7J207IqI66W8IO2VtOqysCDqsIDriqXtlanri4jri6QuXHJcbiAgICAgKiDrqqjrk6Ag7YGs6riw64qUIENTUyB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL3RyYW5zZm9ybSB0cmFuc2Zvcm197J20IOyXmOumrOuovO2KuOyXkCDsoIHsmqnrkJjquLAg7J207KCE7J2YIO2BrOq4sOulvCDsgqzsmqntlaAg6rKD7J6F64uI64ukLlxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1mbGlja2luZy9PcHRpb25zI3VzZWZyYWN0aW9uYWxzaXplIHVzZUZyYWN0aW9uYWxTaXplICggT3B0aW9ucyApfVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdXNlRnJhY3Rpb25hbFNpemU7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcImV4dGVybmFsUmVuZGVyZXJcIiwge1xuICAgIC8qKlxyXG4gICAgICogVGhpcyBpcyBhbiBvcHRpb24gZm9yIHRoZSBmcmFtZXdvcmtzKFJlYWN0LCBWdWUsIEFuZ3VsYXIsIC4uLikuIERvbid0IHNldCBpdCBhcyBpdCdzIGF1dG9tYXRpY2FsbHkgbWFuYWdlZCBieSBGbGlja2luZy5cclxuICAgICAqIEBrbyDtlITroIjsnoTsm4ztgawoUmVhY3QsIFZ1ZSwgQW5ndWxhciwgLi4uKeyXkOyEnOunjCDsgqzsmqntlZjripQg7Ji17IWY7Jy866GcLCDsnpDrj5nsnLzroZwg7ISk7KCV65CY66+A66GcIOuUsOuhnCDsgqzsmqntlZjsi6Qg7ZWE7JqUIOyXhuyKteuLiOuLpCFcclxuICAgICAqIEBkZWZhdWx0IG51bGxcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9leHRlcm5hbFJlbmRlcmVyO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJyZW5kZXJFeHRlcm5hbFwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGlzIGFuIG9wdGlvbiBmb3IgdGhlIGZyYW1ld29ya3MoUmVhY3QsIFZ1ZSwgQW5ndWxhciwgLi4uKS4gRG9uJ3Qgc2V0IGl0IGFzIGl0J3MgYXV0b21hdGljYWxseSBtYW5hZ2VkIGJ5IEZsaWNraW5nLlxyXG4gICAgICogQGtvIO2UhOugiOyehOybjO2BrChSZWFjdCwgVnVlLCBBbmd1bGFyLCAuLi4p7JeQ7ISc66eMIOyCrOyaqe2VmOuKlCDsmLXshZjsnLzroZwsIOyekOuPmeycvOuhnCDshKTsoJXrkJjrr4DroZwg65Sw66GcIOyCrOyaqe2VmOyLpCDtlYTsmpQg7JeG7Iq164uI64ukIVxyXG4gICAgICogQGRlZmF1bHQgbnVsbFxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqIEBkZXByZWNhdGVkXHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJFeHRlcm5hbDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgLyoqXHJcbiAgICogSW5pdGlhbGl6ZSBGbGlja2luZyBhbmQgbW92ZSB0byB0aGUgZGVmYXVsdCBpbmRleFxyXG4gICAqIFRoaXMgaXMgYXV0b21hdGljYWxseSBjYWxsZWQgb24gRmxpY2tpbmcncyBjb25zdHJ1Y3RvciB3aGVuIGBhdXRvSW5pdGAgaXMgdHJ1ZShkZWZhdWx0KVxyXG4gICAqIEBrbyBGbGlja2luZ+ydhCDstIjquLDtmZTtlZjqs6AsIOuUlO2PtO2KuCDsnbjrjbHsiqTroZwg7J2064+Z7ZWp64uI64ukXHJcbiAgICog7J20IOuplOyGjOuTnOuKlCBgYXV0b0luaXRgIOyYteyFmOydtCB0cnVlKGRlZmF1bHQp7J28IOqyveyasCBGbGlja2luZ+ydtCDsg53shLHrkKAg65WMIOyekOuPmeycvOuhnCDtmLjstpzrkKnri4jri6RcclxuICAgKiBAZmlyZXMgRmxpY2tpbmcjcmVhZHlcclxuICAgKiBAcmV0dXJuIHtQcm9taXNlPHZvaWQ+fVxyXG4gICAqL1xuICBfX3Byb3RvLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBpZiAodGhpcy5faW5pdGlhbGl6ZWQpIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB2YXIgY2FtZXJhID0gdGhpcy5fY2FtZXJhO1xuICAgIHZhciByZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVyO1xuICAgIHZhciBjb250cm9sID0gdGhpcy5fY29udHJvbDtcbiAgICB2YXIgdmlydHVhbE1hbmFnZXIgPSB0aGlzLl92aXJ0dWFsTWFuYWdlcjtcbiAgICB2YXIgb3JpZ2luYWxUcmlnZ2VyID0gdGhpcy50cmlnZ2VyO1xuICAgIHZhciBwcmV2ZW50RXZlbnRzQmVmb3JlSW5pdCA9IHRoaXMuX3ByZXZlbnRFdmVudHNCZWZvcmVJbml0O1xuICAgIGNhbWVyYS5pbml0KCk7XG4gICAgdmlydHVhbE1hbmFnZXIuaW5pdCgpO1xuICAgIHJlbmRlcmVyLmluaXQodGhpcyk7XG4gICAgY29udHJvbC5pbml0KHRoaXMpO1xuICAgIGlmIChwcmV2ZW50RXZlbnRzQmVmb3JlSW5pdCkge1xuICAgICAgdGhpcy50cmlnZ2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICB9O1xuICAgIH1cbiAgICB0aGlzLl9pbml0aWFsUmVzaXplKCk7XG4gICAgLy8gTG9vayBhdCBpbml0aWFsIHBhbmVsXG4gICAgdGhpcy5fbW92ZVRvSW5pdGlhbFBhbmVsKCk7XG4gICAgaWYgKHRoaXMuX2F1dG9SZXNpemUpIHtcbiAgICAgIHRoaXMuX2F1dG9SZXNpemVyLmVuYWJsZSgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fcHJldmVudENsaWNrT25EcmFnKSB7XG4gICAgICBjb250cm9sLmNvbnRyb2xsZXIuYWRkUHJldmVudENsaWNrSGFuZGxlcigpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fZGlzYWJsZU9uSW5pdCkge1xuICAgICAgdGhpcy5kaXNhYmxlSW5wdXQoKTtcbiAgICB9XG4gICAgcmVuZGVyZXIuY2hlY2tQYW5lbENvbnRlbnRzUmVhZHkocmVuZGVyZXIucGFuZWxzKTtcbiAgICB0aGlzLl9pbml0aWFsaXplZCA9IHRydWU7XG4gICAgcmV0dXJuIHJlbmRlcmVyLnJlbmRlcigpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgLy8gRG9uZSBpbml0aWFsaXppbmcgJiBlbWl0IHJlYWR5IGV2ZW50XG4gICAgICBfdGhpcy5fcGx1Z2lucy5mb3JFYWNoKGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICAgICAgcmV0dXJuIHBsdWdpbi5pbml0KF90aGlzKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKHByZXZlbnRFdmVudHNCZWZvcmVJbml0KSB7XG4gICAgICAgIF90aGlzLnRyaWdnZXIgPSBvcmlnaW5hbFRyaWdnZXI7XG4gICAgICB9XG4gICAgICBfdGhpcy50cmlnZ2VyKG5ldyBDb21wb25lbnRFdmVudCQxKEVWRU5UUy5SRUFEWSkpO1xuICAgIH0pO1xuICB9O1xuICAvKipcclxuICAgKiBEZXN0cm95IEZsaWNraW5nIGFuZCByZW1vdmUgYWxsIGV2ZW50IGhhbmRsZXJzXHJcbiAgICogQGtvIEZsaWNraW5n6rO8IO2VmOychCDsu7Ttj6zrhIztirjrk6TsnYQg7LSI6riwIOyDge2DnOuhnCDrkJjrj4zrpqzqs6AsIOu2gOywqeuQnCDrqqjrk6Ag7J2067Kk7Yq4IO2VuOuTpOufrOulvCDsoJzqsbDtlanri4jri6RcclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xuICBfX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5vZmYoKTtcbiAgICB0aGlzLl9hdXRvUmVzaXplci5kaXNhYmxlKCk7XG4gICAgdGhpcy5fY29udHJvbC5kZXN0cm95KCk7XG4gICAgdGhpcy5fY2FtZXJhLmRlc3Ryb3koKTtcbiAgICB0aGlzLl9yZW5kZXJlci5kZXN0cm95KCk7XG4gICAgdGhpcy5fcGx1Z2lucy5mb3JFYWNoKGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICAgIHJldHVybiBwbHVnaW4uZGVzdHJveSgpO1xuICAgIH0pO1xuICAgIHRoaXMuX2luaXRpYWxpemVkID0gZmFsc2U7XG4gIH07XG4gIC8qKlxyXG4gICAqIE1vdmUgdG8gdGhlIHByZXZpb3VzIHBhbmVsIChjdXJyZW50IGluZGV4IC0gMSlcclxuICAgKiBAa28g7J207KCEIO2MqOuEkOuhnCDsnbTrj5ntlanri4jri6QgKO2YhOyerCDsnbjrjbHsiqQgLSAxKVxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZHVyYXRpb249e0BsaW5rIEZsaWNraW5nI2R1cmF0aW9uIG9wdGlvbnMuZHVyYXRpb259XSBEdXJhdGlvbiBvZiB0aGUgcGFuZWwgbW92ZW1lbnQgYW5pbWF0aW9uICh1bml0OiBtcyk8a28+7Yyo64SQIOydtOuPmSDslaDri4jrqZTsnbTshZgg7KeE7ZaJIOyLnOqwhCAo64uo7JyEOiBtcyk8L2tvPlxyXG4gICAqIEBhc3luY1xyXG4gICAqIEBmaXJlcyBGbGlja2luZyNtb3ZlU3RhcnRcclxuICAgKiBAZmlyZXMgRmxpY2tpbmcjbW92ZVxyXG4gICAqIEBmaXJlcyBGbGlja2luZyNtb3ZlRW5kXHJcbiAgICogQGZpcmVzIEZsaWNraW5nI3dpbGxDaGFuZ2VcclxuICAgKiBAZmlyZXMgRmxpY2tpbmcjY2hhbmdlZFxyXG4gICAqIEBmaXJlcyBGbGlja2luZyN3aWxsUmVzdG9yZVxyXG4gICAqIEBmaXJlcyBGbGlja2luZyNyZXN0b3JlZFxyXG4gICAqIEBmaXJlcyBGbGlja2luZyNuZWVkUGFuZWxcclxuICAgKiBAZmlyZXMgRmxpY2tpbmcjdmlzaWJsZUNoYW5nZVxyXG4gICAqIEBmaXJlcyBGbGlja2luZyNyZWFjaEVkZ2VcclxuICAgKiBAdGhyb3dzIHtGbGlja2luZ0Vycm9yfVxyXG4gICAqIHxjb2RlfGNvbmRpdGlvbnxcclxuICAgKiB8LS0tfC0tLXxcclxuICAgKiB8e0BsaW5rIEVSUk9SX0NPREUgSU5ERVhfT1VUX09GX1JBTkdFfXxXaGVuIHRoZSBwcmV2aW91cyBwYW5lbCBkb2VzIG5vdCBleGlzdHxcclxuICAgKiB8e0BsaW5rIEVSUk9SX0NPREUgQU5JTUFUSU9OX0FMUkVBRFlfUExBWUlOR318V2hlbiB0aGUgYW5pbWF0aW9uIGlzIGFscmVhZHkgcGxheWluZ3xcclxuICAgKiB8e0BsaW5rIEVSUk9SX0NPREUgQU5JTUFUSU9OX0lOVEVSUlVQVEVEfXxXaGVuIHRoZSBhbmltYXRpb24gaXMgaW50ZXJydXB0ZWQgYnkgdXNlciBpbnB1dHxcclxuICAgKiB8e0BsaW5rIEVSUk9SX0NPREUgU1RPUF9DQUxMRURfQllfVVNFUn18V2hlbiB0aGUgYW55IG9mIHRoZSBldmVudCdzIGBzdG9wKClgIGlzIGNhbGxlZHxcclxuICAgKiA8a28+XHJcbiAgICpcclxuICAgKiB8Y29kZXxjb25kaXRpb258XHJcbiAgICogfC0tLXwtLS18XHJcbiAgICogfHtAbGluayBFUlJPUl9DT0RFIElOREVYX09VVF9PRl9SQU5HRX187J207KCEIO2MqOuEkOydtCDsobTsnqztlZjsp4Ag7JWK7J2EIOqyveyasHxcclxuICAgKiB8e0BsaW5rIEVSUk9SX0NPREUgQU5JTUFUSU9OX0FMUkVBRFlfUExBWUlOR3187JWg64uI66mU7J207IWY7J20IOydtOuvuCDsp4TtlonspJHsnbgg6rK97JqwfFxyXG4gICAqIHx7QGxpbmsgRVJST1JfQ09ERSBBTklNQVRJT05fSU5URVJSVVBURUR9fOyCrOyaqeyekCDsnoXroKXsl5Ag7J2Y7ZW0IOyVoOuLiOuplOydtOyFmOydtCDspJHri6jrkJwg6rK97JqwfFxyXG4gICAqIHx7QGxpbmsgRVJST1JfQ09ERSBTVE9QX0NBTExFRF9CWV9VU0VSfXzrsJzsg53rkJwg7J2067Kk7Yq465OkIOykkSDtlZjrgpjrnbzrj4QgYHN0b3AoKWDsnbQg7Zi47Lac65CcIOqyveyasHxcclxuICAgKiA8L2tvPlxyXG4gICAqIEByZXR1cm4ge1Byb21pc2U8dm9pZD59IEEgUHJvbWlzZSB3aGljaCB3aWxsIGJlIHJlc29sdmVkIGFmdGVyIHJlYWNoaW5nIHRoZSBwcmV2aW91cyBwYW5lbDxrbz7snbTsoIQg7Yyo64SQIOuPhOuLrOyLnOyXkCByZXNvbHZl65CY64qUIFByb21pc2U8L2tvPlxyXG4gICAqL1xuICBfX3Byb3RvLnByZXYgPSBmdW5jdGlvbiAoZHVyYXRpb24pIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICBpZiAoZHVyYXRpb24gPT09IHZvaWQgMCkge1xuICAgICAgZHVyYXRpb24gPSB0aGlzLl9kdXJhdGlvbjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubW92ZVRvKChfYyA9IChfYiA9IChfYSA9IHRoaXMuX2NvbnRyb2wuYWN0aXZlUGFuZWwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wcmV2KCkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5pbmRleCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogLTEsIGR1cmF0aW9uLCBESVJFQ1RJT04uUFJFVik7XG4gIH07XG4gIC8qKlxyXG4gICAqIE1vdmUgdG8gdGhlIG5leHQgcGFuZWwgKGN1cnJlbnQgaW5kZXggKyAxKVxyXG4gICAqIEBrbyDri6TsnYwg7Yyo64SQ66GcIOydtOuPme2VqeuLiOuLpCAo7ZiE7J6sIOyduOuNseyKpCArIDEpXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtkdXJhdGlvbj17QGxpbmsgRmxpY2tpbmcjZHVyYXRpb24gb3B0aW9ucy5kdXJhdGlvbn1dIER1cmF0aW9uIG9mIHRoZSBwYW5lbCBtb3ZlbWVudCBhbmltYXRpb24gKHVuaXQ6IG1zKS48a28+7Yyo64SQIOydtOuPmSDslaDri4jrqZTsnbTshZgg7KeE7ZaJIOyLnOqwhCAo64uo7JyEOiBtcyk8L2tvPlxyXG4gICAqIEBhc3luY1xyXG4gICAqIEBmaXJlcyBGbGlja2luZyNtb3ZlU3RhcnRcclxuICAgKiBAZmlyZXMgRmxpY2tpbmcjbW92ZVxyXG4gICAqIEBmaXJlcyBGbGlja2luZyNtb3ZlRW5kXHJcbiAgICogQGZpcmVzIEZsaWNraW5nI3dpbGxDaGFuZ2VcclxuICAgKiBAZmlyZXMgRmxpY2tpbmcjY2hhbmdlZFxyXG4gICAqIEBmaXJlcyBGbGlja2luZyN3aWxsUmVzdG9yZVxyXG4gICAqIEBmaXJlcyBGbGlja2luZyNyZXN0b3JlZFxyXG4gICAqIEBmaXJlcyBGbGlja2luZyNuZWVkUGFuZWxcclxuICAgKiBAZmlyZXMgRmxpY2tpbmcjdmlzaWJsZUNoYW5nZVxyXG4gICAqIEBmaXJlcyBGbGlja2luZyNyZWFjaEVkZ2VcclxuICAgKiBAdGhyb3dzIHtGbGlja2luZ0Vycm9yfVxyXG4gICAqIHxjb2RlfGNvbmRpdGlvbnxcclxuICAgKiB8LS0tfC0tLXxcclxuICAgKiB8e0BsaW5rIEVSUk9SX0NPREUgSU5ERVhfT1VUX09GX1JBTkdFfXxXaGVuIHRoZSBuZXh0IHBhbmVsIGRvZXMgbm90IGV4aXN0fFxyXG4gICAqIHx7QGxpbmsgRVJST1JfQ09ERSBBTklNQVRJT05fQUxSRUFEWV9QTEFZSU5HfXxXaGVuIHRoZSBhbmltYXRpb24gaXMgYWxyZWFkeSBwbGF5aW5nfFxyXG4gICAqIHx7QGxpbmsgRVJST1JfQ09ERSBBTklNQVRJT05fSU5URVJSVVBURUR9fFdoZW4gdGhlIGFuaW1hdGlvbiBpcyBpbnRlcnJ1cHRlZCBieSB1c2VyIGlucHV0fFxyXG4gICAqIHx7QGxpbmsgRVJST1JfQ09ERSBTVE9QX0NBTExFRF9CWV9VU0VSfXxXaGVuIHRoZSBhbnkgb2YgdGhlIGV2ZW50J3MgYHN0b3AoKWAgaXMgY2FsbGVkfFxyXG4gICAqIDxrbz5cclxuICAgKlxyXG4gICAqIHxjb2RlfGNvbmRpdGlvbnxcclxuICAgKiB8LS0tfC0tLXxcclxuICAgKiB8e0BsaW5rIEVSUk9SX0NPREUgSU5ERVhfT1VUX09GX1JBTkdFfXzri6TsnYwg7Yyo64SQ7J20IOyhtOyerO2VmOyngCDslYrsnYQg6rK97JqwfFxyXG4gICAqIHx7QGxpbmsgRVJST1JfQ09ERSBBTklNQVRJT05fQUxSRUFEWV9QTEFZSU5HfXzslaDri4jrqZTsnbTshZjsnbQg7J2066+4IOynhO2WieykkeyduCDqsr3smrB8XHJcbiAgICogfHtAbGluayBFUlJPUl9DT0RFIEFOSU1BVElPTl9JTlRFUlJVUFRFRH187IKs7Jqp7J6QIOyeheugpeyXkCDsnZjtlbQg7JWg64uI66mU7J207IWY7J20IOykkeuLqOuQnCDqsr3smrB8XHJcbiAgICogfHtAbGluayBFUlJPUl9DT0RFIFNUT1BfQ0FMTEVEX0JZX1VTRVJ9fOuwnOyDneuQnCDsnbTrsqTtirjrk6Qg7KSRIO2VmOuCmOudvOuPhCBgc3RvcCgpYOydtCDtmLjstpzrkJwg6rK97JqwfFxyXG4gICAqXHJcbiAgICogPC9rbz5cclxuICAgKiBAcmV0dXJuIHtQcm9taXNlPHZvaWQ+fSBBIFByb21pc2Ugd2hpY2ggd2lsbCBiZSByZXNvbHZlZCBhZnRlciByZWFjaGluZyB0aGUgbmV4dCBwYW5lbDxrbz7ri6TsnYwg7Yyo64SQIOuPhOuLrOyLnOyXkCByZXNvbHZl65CY64qUIFByb21pc2U8L2tvPlxyXG4gICAqL1xuICBfX3Byb3RvLm5leHQgPSBmdW5jdGlvbiAoZHVyYXRpb24pIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICBpZiAoZHVyYXRpb24gPT09IHZvaWQgMCkge1xuICAgICAgZHVyYXRpb24gPSB0aGlzLl9kdXJhdGlvbjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubW92ZVRvKChfYyA9IChfYiA9IChfYSA9IHRoaXMuX2NvbnRyb2wuYWN0aXZlUGFuZWwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5uZXh0KCkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5pbmRleCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogdGhpcy5fcmVuZGVyZXIucGFuZWxDb3VudCwgZHVyYXRpb24sIERJUkVDVElPTi5ORVhUKTtcbiAgfTtcbiAgLyoqXHJcbiAgICogTW92ZSB0byB0aGUgcGFuZWwgd2l0aCBnaXZlbiBpbmRleFxyXG4gICAqIEBrbyDso7zslrTsp4Qg7J24642x7Iqk7JeQIO2VtOuLue2VmOuKlCDtjKjrhJDroZwg7J2064+Z7ZWp64uI64ukXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgcGFuZWwgdG8gbW92ZTxrbz7snbTrj5ntlaAg7Yyo64SQ7J2YIOyduOuNseyKpDwva28+XHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtkdXJhdGlvbj17QGxpbmsgRmxpY2tpbmcjZHVyYXRpb24gb3B0aW9ucy5kdXJhdGlvbn1dIER1cmF0aW9uIG9mIHRoZSBhbmltYXRpb24gKHVuaXQ6IG1zKTxrbz7slaDri4jrqZTsnbTshZgg7KeE7ZaJIOyLnOqwhCAo64uo7JyEOiBtcyk8L2tvPlxyXG4gICAqIEBwYXJhbSB7RElSRUNUSU9OfSBbZGlyZWN0aW9uPURJUkVDVElPTi5OT05FXSBEaXJlY3Rpb24gdG8gbW92ZSwgb25seSBhdmFpbGFibGUgaW4gdGhlIHtAbGluayBGbGlja2luZyNjaXJjdWxhciBjaXJjdWxhcn0gbW9kZTxrbz7snbTrj5ntlaAg67Cp7ZalLiB7QGxpbmsgRmxpY2tpbmcjY2lyY3VsYXIgY2lyY3VsYXJ9IOyYteyFmCDtmZzshLHtmZTsi5zsl5Drp4wg7IKs7JqpIOqwgOuKpe2VqeuLiOuLpDwva28+XHJcbiAgICogQGFzeW5jXHJcbiAgICogQGZpcmVzIEZsaWNraW5nI21vdmVTdGFydFxyXG4gICAqIEBmaXJlcyBGbGlja2luZyNtb3ZlXHJcbiAgICogQGZpcmVzIEZsaWNraW5nI21vdmVFbmRcclxuICAgKiBAZmlyZXMgRmxpY2tpbmcjd2lsbENoYW5nZVxyXG4gICAqIEBmaXJlcyBGbGlja2luZyNjaGFuZ2VkXHJcbiAgICogQGZpcmVzIEZsaWNraW5nI3dpbGxSZXN0b3JlXHJcbiAgICogQGZpcmVzIEZsaWNraW5nI3Jlc3RvcmVkXHJcbiAgICogQGZpcmVzIEZsaWNraW5nI25lZWRQYW5lbFxyXG4gICAqIEBmaXJlcyBGbGlja2luZyN2aXNpYmxlQ2hhbmdlXHJcbiAgICogQGZpcmVzIEZsaWNraW5nI3JlYWNoRWRnZVxyXG4gICAqIEB0aHJvd3Mge0ZsaWNraW5nRXJyb3J9XHJcbiAgICogfGNvZGV8Y29uZGl0aW9ufFxyXG4gICAqIHwtLS18LS0tfFxyXG4gICAqIHx7QGxpbmsgRVJST1JfQ09ERSBJTkRFWF9PVVRfT0ZfUkFOR0V9fFdoZW4gdGhlIHJvb3QgaXMgbm90IGVpdGhlciBzdHJpbmcgb3IgSFRNTEVsZW1lbnR8XHJcbiAgICogfHtAbGluayBFUlJPUl9DT0RFIEFOSU1BVElPTl9BTFJFQURZX1BMQVlJTkd9fFdoZW4gdGhlIGFuaW1hdGlvbiBpcyBhbHJlYWR5IHBsYXlpbmd8XHJcbiAgICogfHtAbGluayBFUlJPUl9DT0RFIEFOSU1BVElPTl9JTlRFUlJVUFRFRH18V2hlbiB0aGUgYW5pbWF0aW9uIGlzIGludGVycnVwdGVkIGJ5IHVzZXIgaW5wdXR8XHJcbiAgICogfHtAbGluayBFUlJPUl9DT0RFIFNUT1BfQ0FMTEVEX0JZX1VTRVJ9fFdoZW4gdGhlIGFueSBvZiB0aGUgZXZlbnQncyBgc3RvcCgpYCBpcyBjYWxsZWR8XHJcbiAgICogPGtvPlxyXG4gICAqXHJcbiAgICogfGNvZGV8Y29uZGl0aW9ufFxyXG4gICAqIHwtLS18LS0tfFxyXG4gICAqIHx7QGxpbmsgRVJST1JfQ09ERSBJTkRFWF9PVVRfT0ZfUkFOR0V9fO2VtOuLuSDsnbjrjbHsiqTrpbwg6rCA7KeEIO2MqOuEkOydtCDsobTsnqztlZjsp4Ag7JWK7J2EIOqyveyasHxcclxuICAgKiB8e0BsaW5rIEVSUk9SX0NPREUgQU5JTUFUSU9OX0FMUkVBRFlfUExBWUlOR3187JWg64uI66mU7J207IWY7J20IOydtOuvuCDsp4TtlonspJHsnbgg6rK97JqwfFxyXG4gICAqIHx7QGxpbmsgRVJST1JfQ09ERSBBTklNQVRJT05fSU5URVJSVVBURUR9fOyCrOyaqeyekCDsnoXroKXsl5Ag7J2Y7ZW0IOyVoOuLiOuplOydtOyFmOydtCDspJHri6jrkJwg6rK97JqwfFxyXG4gICAqIHx7QGxpbmsgRVJST1JfQ09ERSBTVE9QX0NBTExFRF9CWV9VU0VSfXzrsJzsg53rkJwg7J2067Kk7Yq465OkIOykkSDtlZjrgpjrnbzrj4QgYHN0b3AoKWDsnbQg7Zi47Lac65CcIOqyveyasHxcclxuICAgKlxyXG4gICAqIDwva28+XHJcbiAgICogQHJldHVybiB7UHJvbWlzZTx2b2lkPn0gQSBQcm9taXNlIHdoaWNoIHdpbGwgYmUgcmVzb2x2ZWQgYWZ0ZXIgcmVhY2hpbmcgdGhlIHRhcmdldCBwYW5lbDxrbz7tlbTri7kg7Yyo64SQIOuPhOuLrOyLnOyXkCByZXNvbHZl65CY64qUIFByb21pc2U8L2tvPlxyXG4gICAqL1xuICBfX3Byb3RvLm1vdmVUbyA9IGZ1bmN0aW9uIChpbmRleCwgZHVyYXRpb24sIGRpcmVjdGlvbikge1xuICAgIGlmIChkdXJhdGlvbiA9PT0gdm9pZCAwKSB7XG4gICAgICBkdXJhdGlvbiA9IHRoaXMuX2R1cmF0aW9uO1xuICAgIH1cbiAgICBpZiAoZGlyZWN0aW9uID09PSB2b2lkIDApIHtcbiAgICAgIGRpcmVjdGlvbiA9IERJUkVDVElPTi5OT05FO1xuICAgIH1cbiAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLl9yZW5kZXJlcjtcbiAgICB2YXIgcGFuZWxDb3VudCA9IHJlbmRlcmVyLnBhbmVsQ291bnQ7XG4gICAgdmFyIHBhbmVsID0gcmVuZGVyZXIuZ2V0UGFuZWwoaW5kZXgpO1xuICAgIGlmICghcGFuZWwpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRmxpY2tpbmdFcnJvcihNRVNTQUdFLklOREVYX09VVF9PRl9SQU5HRShpbmRleCwgMCwgcGFuZWxDb3VudCAtIDEpLCBDT0RFLklOREVYX09VVF9PRl9SQU5HRSkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fY29udHJvbC5hbmltYXRpbmcpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRmxpY2tpbmdFcnJvcihNRVNTQUdFLkFOSU1BVElPTl9BTFJFQURZX1BMQVlJTkcsIENPREUuQU5JTUFUSU9OX0FMUkVBRFlfUExBWUlORykpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fY29udHJvbC5ob2xkaW5nKSB7XG4gICAgICB0aGlzLl9jb250cm9sLmNvbnRyb2xsZXIucmVsZWFzZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY29udHJvbC5tb3ZlVG9QYW5lbChwYW5lbCwge1xuICAgICAgZHVyYXRpb246IGR1cmF0aW9uLFxuICAgICAgZGlyZWN0aW9uOiBkaXJlY3Rpb25cbiAgICB9KTtcbiAgfTtcbiAgLyoqXHJcbiAgICogQ2hhbmdlIHRoZSBkZXN0aW5hdGlvbiBhbmQgZHVyYXRpb24gb2YgdGhlIGFuaW1hdGlvbiBjdXJyZW50bHkgcGxheWluZ1xyXG4gICAqIEBrbyDsnqzsg50g7KSR7J24IOyVoOuLiOuplOydtOyFmOydmCDrqqnsoIHsp4DsmYAg7J6s7IOdIOyLnOqwhOydhCDrs4Dqsr3tlanri4jri6RcclxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBwYW5lbCB0byBtb3ZlPGtvPuydtOuPme2VoCDtjKjrhJDsnZgg7J24642x7IqkPC9rbz5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gZHVyYXRpb24gRHVyYXRpb24gb2YgdGhlIGFuaW1hdGlvbiAodW5pdDogbXMpPGtvPuyVoOuLiOuplOydtOyFmCDsp4Ttlokg7Iuc6rCEICjri6jsnIQ6IG1zKTwva28+XHJcbiAgICogQHBhcmFtIHtESVJFQ1RJT059IGRpcmVjdGlvbiBEaXJlY3Rpb24gdG8gbW92ZSwgb25seSBhdmFpbGFibGUgaW4gdGhlIHtAbGluayBGbGlja2luZyNjaXJjdWxhciBjaXJjdWxhcn0gbW9kZTxrbz7snbTrj5ntlaAg67Cp7ZalLiB7QGxpbmsgRmxpY2tpbmcjY2lyY3VsYXIgY2lyY3VsYXJ9IOyYteyFmCDtmZzshLHtmZTsi5zsl5Drp4wg7IKs7JqpIOqwgOuKpe2VqeuLiOuLpDwva28+XHJcbiAgICogQHRocm93cyB7RmxpY2tpbmdFcnJvcn1cclxuICAgKiB7QGxpbmsgRVJST1JfQ09ERSBJTkRFWF9PVVRfT0ZfUkFOR0V9IFdoZW4gdGhlIHJvb3QgaXMgbm90IGVpdGhlciBzdHJpbmcgb3IgSFRNTEVsZW1lbnRcclxuICAgKiA8a28+e0BsaW5rIEVSUk9SX0NPREUgSU5ERVhfT1VUX09GX1JBTkdFfSDtlbTri7kg7J24642x7Iqk66W8IOqwgOynhCDtjKjrhJDsnbQg7KG07J6s7ZWY7KeAIOyViuydhCDqsr3smrA8L2tvPlxyXG4gICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICovXG4gIF9fcHJvdG8udXBkYXRlQW5pbWF0aW9uID0gZnVuY3Rpb24gKGluZGV4LCBkdXJhdGlvbiwgZGlyZWN0aW9uKSB7XG4gICAgaWYgKCF0aGlzLl9jb250cm9sLmFuaW1hdGluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLl9yZW5kZXJlcjtcbiAgICB2YXIgcGFuZWxDb3VudCA9IHJlbmRlcmVyLnBhbmVsQ291bnQ7XG4gICAgdmFyIHBhbmVsID0gcmVuZGVyZXIuZ2V0UGFuZWwoaW5kZXgpO1xuICAgIGlmICghcGFuZWwpIHtcbiAgICAgIHRocm93IG5ldyBGbGlja2luZ0Vycm9yKE1FU1NBR0UuSU5ERVhfT1VUX09GX1JBTkdFKGluZGV4LCAwLCBwYW5lbENvdW50IC0gMSksIENPREUuSU5ERVhfT1VUX09GX1JBTkdFKTtcbiAgICB9XG4gICAgdGhpcy5fY29udHJvbC51cGRhdGVBbmltYXRpb24ocGFuZWwsIGR1cmF0aW9uLCBkaXJlY3Rpb24pO1xuICB9O1xuICAvKipcclxuICAgKiBTdG9wcyB0aGUgYW5pbWF0aW9uIGN1cnJlbnRseSBwbGF5aW5nXHJcbiAgICogQGtvIOyerOyDnSDspJHsnbgg7JWg64uI66mU7J207IWY7J2EIOykkeuLqOyLnO2CteuLiOuLpFxyXG4gICAqIEBmaXJlcyBGbGlja2luZyNtb3ZlRW5kXHJcbiAgICogQHJldHVybiB7dm9pZH1cclxuICAgKi9cbiAgX19wcm90by5zdG9wQW5pbWF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5fY29udHJvbC5hbmltYXRpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fY29udHJvbC5zdG9wQW5pbWF0aW9uKCk7XG4gIH07XG4gIC8qKlxyXG4gICAqIFJldHVybiB0aGUge0BsaW5rIFBhbmVsfSBhdCB0aGUgZ2l2ZW4gaW5kZXguIGBudWxsYCBpZiBpdCBkb2Vzbid0IGV4aXN0cy5cclxuICAgKiBAa28g7KO87Ja07KeEIOyduOuNseyKpOyXkCDtlbTri7ntlZjripQge0BsaW5rIFBhbmVsfeydhCDrsJjtmZjtlanri4jri6QuIOyjvOyWtOynhCDsnbjrjbHsiqTsl5Ag7ZW064u57ZWY64qUIO2MqOuEkOydtCDsobTsnqztlZjsp4Ag7JWK7J2EIOqyveyasCBgbnVsbGDsnYQg67CY7ZmY7ZWp64uI64ukLlxyXG4gICAqIEByZXR1cm4ge1BhbmVsIHwgbnVsbH0gUGFuZWwgYXQgdGhlIGdpdmVuIGluZGV4PGtvPuyjvOyWtOynhCDsnbjrjbHsiqTsl5Ag7ZW064u57ZWY64qUIO2MqOuEkDwva28+XHJcbiAgICogQHNlZSBQYW5lbFxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogYGBgdHNcclxuICAgKiBjb25zdCBwYW5lbCA9IGZsaWNraW5nLmdldFBhbmVsKDApO1xyXG4gICAqIC8vIFdoaWNoIGlzIGEgc2hvcnRoYW5kIHRvLi4uXHJcbiAgICogY29uc3Qgc2FtZVBhbmVsID0gZmxpY2tpbmcucGFuZWxzWzBdO1xyXG4gICAqIGBgYFxyXG4gICAqL1xuICBfX3Byb3RvLmdldFBhbmVsID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlbmRlcmVyLmdldFBhbmVsKGluZGV4KTtcbiAgfTtcbiAgLyoqXHJcbiAgICogRW5hYmxlIGlucHV0IGZyb20gdGhlIHVzZXIgKG1vdXNlL3RvdWNoKVxyXG4gICAqIEBrbyDsgqzsmqnsnpDsnZgg7J6F66ClKOuniOyasOyKpC/thLDsuZgp66W8IO2ZnOyEse2ZlO2VqeuLiOuLpFxyXG4gICAqIEByZXR1cm4ge3RoaXN9XHJcbiAgICovXG4gIF9fcHJvdG8uZW5hYmxlSW5wdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fY29udHJvbC5lbmFibGUoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXHJcbiAgICogRGlzYWJsZSBpbnB1dCBmcm9tIHRoZSB1c2VyIChtb3VzZS90b3VjaClcclxuICAgKiBAa28g7IKs7Jqp7J6Q7J2YIOyeheugpSjrp4jsmrDsiqQv7YSw7LmYKeulvCDrp4nsirXri4jri6RcclxuICAgKiBAcmV0dXJuIHt0aGlzfVxyXG4gICAqL1xuICBfX3Byb3RvLmRpc2FibGVJbnB1dCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9jb250cm9sLmRpc2FibGUoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXHJcbiAgICogR2V0IGN1cnJlbnQgZmxpY2tpbmcgc3RhdHVzLiBZb3UgY2FuIHJlc3RvcmUgY3VycmVudCBzdGF0ZSBieSBnaXZpbmcgcmV0dXJuZWQgdmFsdWUgdG8ge0BsaW5rIEZsaWNraW5nI3NldFN0YXR1cyBzZXRTdGF0dXMoKX1cclxuICAgKiBAa28g7ZiE7J6sIOyDge2DnOulvCDrsJjtmZjtlanri4jri6QuIOuwmO2ZmOuwm+ydgCDqsJLsnYQge0BsaW5rIEZsaWNraW5nI3NldFN0YXR1cyBzZXRTdGF0dXMoKX0g66mU7IaM65Oc7J2YIOyduOyekOuhnCDsp4DsoJXtlZjrqbQg7ZiE7J6sIOyDge2DnOulvCDrs7Xsm5DtlaAg7IiYIOyeiOyKteuLiOuLpFxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIFN0YXR1cyByZXRyaWV2aW5nIG9wdGlvbnM8a28+U3RhdHVzIOuwmO2ZmCDsmLXshZg8L2tvPlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuaW5kZXg9dHJ1ZV0gSW5jbHVkZSBjdXJyZW50IHBhbmVsIGluZGV4IHRvIHRoZSByZXR1cm5pbmcgc3RhdHVzLiBDYW1lcmEgd2lsbCBhdXRvbWF0aWNhbGx5IG1vdmUgdG8gdGhlIGdpdmVuIGluZGV4IHdoZW4gdGhlIHtAbGluayBGbGlja2luZyNzZXRTdGF0dXMgc2V0U3RhdHVzfSBpcyBjYWxsZWQ8a28+7ZiE7J6sIO2MqOuEkCDsnbjrjbHsiqTrpbwg67CY7ZmY6rCS7JeQIO2PrO2VqOyLnO2CteuLiOuLpC4ge0BsaW5rIEZsaWNraW5nI3NldFN0YXR1cyBzZXRTdGF0dXN9IO2YuOy2nOyLnCDsnpDrj5nsnLzroZwg7ZW064u5IOyduOuNseyKpOuhnCDsubTrqZTrnbzrpbwg7JuA7KeB7J6F64uI64ukPC9rbz5cclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnBvc2l0aW9uPXRydWVdIEluY2x1ZGUgY2FtZXJhIHBvc2l0aW9uIHRvIHRoZSByZXR1cm5pbmcgc3RhdHVzLiBUaGlzIHdvcmtzIG9ubHkgd2hlbiB0aGUge0BsaW5rIEZsaWNraW5nI21vdmVUeXBlIG1vdmVUeXBlfSBpcyBgZnJlZVNjcm9sbGA8a28+7Lm066mU65287J2YIO2YhOyerCDsnITsuZjrpbwg67CY7ZmY6rCS7JeQIO2PrO2VqOyLnO2CteuLiOuLpC4g7J20IOyYteyFmOydgCB7QGxpbmsgRmxpY2tpbmcjbW92ZVR5cGUgbW92ZVR5cGV97J20IGBmcmVlU2Nyb2xsYOydvCDqsr3smrDsl5Drp4wg64+Z7J6R7ZWp64uI64ukPC9rbz5cclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmluY2x1ZGVQYW5lbEhUTUw9ZmFsc2VdIEluY2x1ZGUgcGFuZWwncyBgb3V0ZXJIVE1MYCB0byB0aGUgcmV0dXJuaW5nIHN0YXR1czxrbz7tjKjrhJDsnZggYG91dGVySFRNTGDsnYQg67CY7ZmY6rCS7JeQIO2PrO2VqOyLnO2CteuLiOuLpDwva28+XHJcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy52aXNpYmxlUGFuZWxzT25seT1mYWxzZV0gSW5jbHVkZSBvbmx5IHtAbGluayBGbGlja2luZyN2aXNpYmxlUGFuZWwgdmlzaWJsZVBhbmVsfSdzIEhUTUwuIFRoaXMgb3B0aW9uIGlzIGF2YWlsYWJsZSBvbmx5IHdoZW4gdGhlIGBpbmNsdWRlUGFuZWxIVE1MYCBpcyB0cnVlXHJcbiAgICogPGtvPu2YhOyerCDrs7TsnbTripQg7Yyo64SQKHtAbGluayBGbGlja2luZyN2aXNpYmxlUGFuZWwgdmlzaWJsZVBhbmVsfSnsnZggSFRNTOunjCDrsJjtmZjtlanri4jri6QuIGBpbmNsdWRlUGFuZWxIVE1MYOydtCBgdHJ1ZWDsnbwg6rK97Jqw7JeQ66eMIOuPmeyeke2VqeuLiOuLpC48L2tvPlxyXG4gICAqIEByZXR1cm4ge1N0YXR1c30gQW4gb2JqZWN0IHdpdGggY3VycmVudCBzdGF0dXMgdmFsdWUgaW5mb3JtYXRpb248a28+7ZiE7J6sIOyDge2DnOqwkiDsoJXrs7Trpbwg6rCA7KeEIOqwneyytC48L2tvPlxyXG4gICAqL1xuICBfX3Byb3RvLmdldFN0YXR1cyA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBfYiwgX2M7XG4gICAgdmFyIF9kID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsXG4gICAgICBfZSA9IF9kLmluZGV4LFxuICAgICAgaW5kZXggPSBfZSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9lLFxuICAgICAgX2YgPSBfZC5wb3NpdGlvbixcbiAgICAgIHBvc2l0aW9uID0gX2YgPT09IHZvaWQgMCA/IHRydWUgOiBfZixcbiAgICAgIF9nID0gX2QuaW5jbHVkZVBhbmVsSFRNTCxcbiAgICAgIGluY2x1ZGVQYW5lbEhUTUwgPSBfZyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfZyxcbiAgICAgIF9oID0gX2QudmlzaWJsZVBhbmVsc09ubHksXG4gICAgICB2aXNpYmxlUGFuZWxzT25seSA9IF9oID09PSB2b2lkIDAgPyBmYWxzZSA6IF9oO1xuICAgIHZhciBjYW1lcmEgPSB0aGlzLl9jYW1lcmE7XG4gICAgdmFyIHBhbmVscyA9IHZpc2libGVQYW5lbHNPbmx5ID8gdGhpcy52aXNpYmxlUGFuZWxzIDogdGhpcy5wYW5lbHM7XG4gICAgdmFyIHN0YXR1cyA9IHtcbiAgICAgIHBhbmVsczogcGFuZWxzLm1hcChmdW5jdGlvbiAocGFuZWwpIHtcbiAgICAgICAgdmFyIHBhbmVsSW5mbyA9IHtcbiAgICAgICAgICBpbmRleDogcGFuZWwuaW5kZXhcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGluY2x1ZGVQYW5lbEhUTUwpIHtcbiAgICAgICAgICBwYW5lbEluZm8uaHRtbCA9IHBhbmVsLmVsZW1lbnQub3V0ZXJIVE1MO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYW5lbEluZm87XG4gICAgICB9KVxuICAgIH07XG4gICAgaWYgKGluZGV4KSB7XG4gICAgICBzdGF0dXMuaW5kZXggPSB0aGlzLmluZGV4O1xuICAgIH1cbiAgICBpZiAocG9zaXRpb24pIHtcbiAgICAgIHZhciBuZWFyZXN0QW5jaG9yID0gY2FtZXJhLmZpbmROZWFyZXN0QW5jaG9yKGNhbWVyYS5wb3NpdGlvbik7XG4gICAgICBpZiAobmVhcmVzdEFuY2hvcikge1xuICAgICAgICBzdGF0dXMucG9zaXRpb24gPSB7XG4gICAgICAgICAgcGFuZWw6IG5lYXJlc3RBbmNob3IucGFuZWwuaW5kZXgsXG4gICAgICAgICAgcHJvZ3Jlc3NJblBhbmVsOiBjYW1lcmEuZ2V0UHJvZ3Jlc3NJblBhbmVsKG5lYXJlc3RBbmNob3IucGFuZWwpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh2aXNpYmxlUGFuZWxzT25seSkge1xuICAgICAgdmFyIHZpc2libGVQYW5lbHMgPSB0aGlzLnZpc2libGVQYW5lbHM7XG4gICAgICBzdGF0dXMudmlzaWJsZU9mZnNldCA9IChfYyA9IChfYiA9IHZpc2libGVQYW5lbHNbMF0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5pbmRleCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogMDtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXR1cztcbiAgfTtcbiAgLyoqXHJcbiAgICogUmVzdG9yZSB0byB0aGUgc3RhdGUgb2YgdGhlIGdpdmVuIHtAbGluayBTdGF0dXN9XHJcbiAgICogQGtvIOyjvOyWtOynhCB7QGxpbmsgU3RhdHVzfeydmCDsg4Htg5zroZwg67O17JuQ7ZWp64uI64ukXHJcbiAgICogQHBhcmFtIHtQYXJ0aWFsPFN0YXR1cz59IHN0YXR1cyBTdGF0dXMgdmFsdWUgdG8gYmUgcmVzdG9yZWQuIFlvdSBzaG91bGQgdXNlIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIHtAbGluayBGbGlja2luZyNnZXRTdGF0dXMgZ2V0U3RhdHVzKCl9IG1ldGhvZDxrbz7rs7Xsm5DtlaAg7IOB7YOcIOqwki4ge0BsaW5rIEZsaWNraW5nI2dldFN0YXR1cyBnZXRTdGF0dXMoKX0g66mU7ISc65Oc7J2YIOuwmO2ZmOqwkuydhCDsp4DsoJXtlZjrqbQg65Cp64uI64ukPC9rbz5cclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xuICBfX3Byb3RvLnNldFN0YXR1cyA9IGZ1bmN0aW9uIChzdGF0dXMpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKCF0aGlzLl9pbml0aWFsaXplZCkge1xuICAgICAgdGhyb3cgbmV3IEZsaWNraW5nRXJyb3IoTUVTU0FHRS5OT1RfSU5JVElBTElaRUQsIENPREUuTk9UX0lOSVRJQUxJWkVEKTtcbiAgICB9XG4gICAgdmFyIGluZGV4ID0gc3RhdHVzLmluZGV4LFxuICAgICAgcG9zaXRpb24gPSBzdGF0dXMucG9zaXRpb24sXG4gICAgICB2aXNpYmxlT2Zmc2V0ID0gc3RhdHVzLnZpc2libGVPZmZzZXQsXG4gICAgICBwYW5lbHMgPSBzdGF0dXMucGFuZWxzO1xuICAgIHZhciByZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVyO1xuICAgIHZhciBjb250cm9sID0gdGhpcy5fY29udHJvbDtcbiAgICAvLyBDYW4ndCBhZGQvcmVtb3ZlIHBhbmVscyBvbiBleHRlcm5hbCByZW5kZXJpbmdcbiAgICBpZiAoKChfYSA9IHBhbmVsc1swXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0bWwpICYmICF0aGlzLl9yZW5kZXJFeHRlcm5hbCkge1xuICAgICAgcmVuZGVyZXIuYmF0Y2hSZW1vdmUoe1xuICAgICAgICBpbmRleDogMCxcbiAgICAgICAgZGVsZXRlQ291bnQ6IHRoaXMucGFuZWxzLmxlbmd0aCxcbiAgICAgICAgaGFzRE9NSW5FbGVtZW50czogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZW5kZXJlci5iYXRjaEluc2VydCh7XG4gICAgICAgIGluZGV4OiAwLFxuICAgICAgICBlbGVtZW50czogcGFyc2VFbGVtZW50KHBhbmVscy5tYXAoZnVuY3Rpb24gKHBhbmVsKSB7XG4gICAgICAgICAgcmV0dXJuIHBhbmVsLmh0bWw7XG4gICAgICAgIH0pKSxcbiAgICAgICAgaGFzRE9NSW5FbGVtZW50czogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChpbmRleCAhPSBudWxsKSB7XG4gICAgICB2YXIgcGFuZWxJbmRleCA9IHZpc2libGVPZmZzZXQgPyBpbmRleCAtIHZpc2libGVPZmZzZXQgOiBpbmRleDtcbiAgICAgIHZvaWQgdGhpcy5tb3ZlVG8ocGFuZWxJbmRleCwgMCkuY2F0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChwb3NpdGlvbiAmJiB0aGlzLl9tb3ZlVHlwZSA9PT0gTU9WRV9UWVBFLkZSRUVfU0NST0xMKSB7XG4gICAgICB2YXIgcGFuZWwgPSBwb3NpdGlvbi5wYW5lbCxcbiAgICAgICAgcHJvZ3Jlc3NJblBhbmVsID0gcG9zaXRpb24ucHJvZ3Jlc3NJblBhbmVsO1xuICAgICAgdmFyIHBhbmVsSW5kZXggPSB2aXNpYmxlT2Zmc2V0ID8gcGFuZWwgLSB2aXNpYmxlT2Zmc2V0IDogcGFuZWw7XG4gICAgICB2YXIgcGFuZWxSYW5nZSA9IHJlbmRlcmVyLnBhbmVsc1twYW5lbEluZGV4XS5yYW5nZTtcbiAgICAgIHZhciBuZXdDYW1lcmFQb3MgPSBwYW5lbFJhbmdlLm1pbiArIChwYW5lbFJhbmdlLm1heCAtIHBhbmVsUmFuZ2UubWluKSAqIHByb2dyZXNzSW5QYW5lbDtcbiAgICAgIHZvaWQgY29udHJvbC5tb3ZlVG9Qb3NpdGlvbihuZXdDYW1lcmFQb3MsIDApLmNhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgLyoqXHJcbiAgICogQWRkIHBsdWdpbnMgdGhhdCBjYW4gaGF2ZSBkaWZmZXJlbnQgZWZmZWN0cyBvbiBGbGlja2luZ1xyXG4gICAqIEBrbyDtlIzrpqztgrnsl5Ag64uk7JaR7ZWcIO2aqOqzvOulvCDrtoDsl6ztlaAg7IiYIOyeiOuKlCDtlIzrn6zqt7jsnbjsnYQg7LaU6rCA7ZWp64uI64ukXHJcbiAgICogQHBhcmFtIHsuLi5QbHVnaW59IHBsdWdpbnMgVGhlIHBsdWdpbihzKSB0byBhZGQ8a28+7LaU6rCA7ZWgIO2UjOufrOq3uOyduCjrk6QpPC9rbz5cclxuICAgKiBAcmV0dXJuIHt0aGlzfVxyXG4gICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL25hdmVyL2VnanMtZmxpY2tpbmctcGx1Z2luc1xyXG4gICAqL1xuICBfX3Byb3RvLmFkZFBsdWdpbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9hO1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIHBsdWdpbnMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgcGx1Z2luc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICBpZiAodGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgIHBsdWdpbnMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbS5pbml0KF90aGlzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAoX2EgPSB0aGlzLl9wbHVnaW5zKS5wdXNoLmFwcGx5KF9hLCBfX3NwcmVhZCQxKHBsdWdpbnMpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXHJcbiAgICogUmVtb3ZlIHBsdWdpbnMgZnJvbSBGbGlja2luZy5cclxuICAgKiBAa28g7ZSM66as7YK57Jy866Gc67aA7YSwIO2UjOufrOq3uOyduOuTpOydhCDsoJzqsbDtlanri4jri6QuXHJcbiAgICogQHBhcmFtIHsuLi5QbHVnaW59IHBsdWdpbiBUaGUgcGx1Z2luKHMpIHRvIHJlbW92ZS48a28+7KCc6rGwIO2UjOufrOq3uOyduCjrk6QpLjwva28+XHJcbiAgICogQHJldHVybiB7dGhpc31cclxuICAgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9uYXZlci9lZ2pzLWZsaWNraW5nLXBsdWdpbnNcclxuICAgKi9cbiAgX19wcm90by5yZW1vdmVQbHVnaW5zID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIHBsdWdpbnMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgcGx1Z2luc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICBwbHVnaW5zLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHZhciBmb3VuZEluZGV4ID0gZmluZEluZGV4KF90aGlzLl9wbHVnaW5zLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHJldHVybiB2YWwgPT09IGl0ZW07XG4gICAgICB9KTtcbiAgICAgIGlmIChmb3VuZEluZGV4ID49IDApIHtcbiAgICAgICAgaXRlbS5kZXN0cm95KCk7XG4gICAgICAgIF90aGlzLl9wbHVnaW5zLnNwbGljZShmb3VuZEluZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXHJcbiAgICogVXBkYXRlIHZpZXdwb3J0L3BhbmVsIHNpemVzXHJcbiAgICogQGtvIO2MqOuEkCDrsI8g67ew7Y+s7Yq47J2YIO2BrOq4sOulvCDqsLHsi6Dtlanri4jri6RcclxuICAgKiBAbWV0aG9kXHJcbiAgICogQGZpcmVzIEZsaWNraW5nI2JlZm9yZVJlc2l6ZVxyXG4gICAqIEBmaXJlcyBGbGlja2luZyNhZnRlclJlc2l6ZVxyXG4gICAqIEByZXR1cm4ge3RoaXN9XHJcbiAgICovXG4gIF9fcHJvdG8ucmVzaXplID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB2aWV3cG9ydCwgcmVuZGVyZXIsIGNhbWVyYSwgY29udHJvbCwgYWN0aXZlUGFuZWwsIHByZXZXaWR0aCwgcHJldkhlaWdodCwgcHJldlByb2dyZXNzSW5QYW5lbCwgbmV3V2lkdGgsIG5ld0hlaWdodCwgc2l6ZUNoYW5nZWQ7XG4gICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICB2aWV3cG9ydCA9IHRoaXMuX3ZpZXdwb3J0O1xuICAgICAgICAgICAgcmVuZGVyZXIgPSB0aGlzLl9yZW5kZXJlcjtcbiAgICAgICAgICAgIGNhbWVyYSA9IHRoaXMuX2NhbWVyYTtcbiAgICAgICAgICAgIGNvbnRyb2wgPSB0aGlzLl9jb250cm9sO1xuICAgICAgICAgICAgYWN0aXZlUGFuZWwgPSBjb250cm9sLmFjdGl2ZVBhbmVsO1xuICAgICAgICAgICAgcHJldldpZHRoID0gdmlld3BvcnQud2lkdGg7XG4gICAgICAgICAgICBwcmV2SGVpZ2h0ID0gdmlld3BvcnQuaGVpZ2h0O1xuICAgICAgICAgICAgcHJldlByb2dyZXNzSW5QYW5lbCA9IGFjdGl2ZVBhbmVsID8gY2FtZXJhLmdldFByb2dyZXNzSW5QYW5lbChhY3RpdmVQYW5lbCkgOiAwO1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKG5ldyBDb21wb25lbnRFdmVudCQxKEVWRU5UUy5CRUZPUkVfUkVTSVpFLCB7XG4gICAgICAgICAgICAgIHdpZHRoOiBwcmV2V2lkdGgsXG4gICAgICAgICAgICAgIGhlaWdodDogcHJldkhlaWdodCxcbiAgICAgICAgICAgICAgZWxlbWVudDogdmlld3BvcnQuZWxlbWVudFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgdmlld3BvcnQucmVzaXplKCk7XG4gICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCByZW5kZXJlci5mb3JjZVJlbmRlckFsbFBhbmVscygpXTtcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBfYS5zZW50KCk7IC8vIFJlbmRlciBhbGwgcGFuZWwgZWxlbWVudHMsIHRvIHVwZGF0ZSBzaXplc1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9pbml0aWFsaXplZCkge1xuICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlbmRlcmVyLnVwZGF0ZVBhbmVsU2l6ZSgpO1xuICAgICAgICAgICAgY2FtZXJhLnVwZGF0ZUFsaWduUG9zKCk7XG4gICAgICAgICAgICBjYW1lcmEudXBkYXRlUmFuZ2UoKTtcbiAgICAgICAgICAgIGNhbWVyYS51cGRhdGVBbmNob3JzKCk7XG4gICAgICAgICAgICBjYW1lcmEudXBkYXRlQWRhcHRpdmVIZWlnaHQoKTtcbiAgICAgICAgICAgIGNhbWVyYS51cGRhdGVQYW5lbE9yZGVyKCk7XG4gICAgICAgICAgICBjYW1lcmEudXBkYXRlT2Zmc2V0KCk7XG4gICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCByZW5kZXJlci5yZW5kZXIoKV07XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9pbml0aWFsaXplZCkge1xuICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjb250cm9sLmFuaW1hdGluZykgOyBlbHNlIHtcbiAgICAgICAgICAgICAgY29udHJvbC51cGRhdGVQb3NpdGlvbihwcmV2UHJvZ3Jlc3NJblBhbmVsKTtcbiAgICAgICAgICAgICAgY29udHJvbC51cGRhdGVJbnB1dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3V2lkdGggPSB2aWV3cG9ydC53aWR0aDtcbiAgICAgICAgICAgIG5ld0hlaWdodCA9IHZpZXdwb3J0LmhlaWdodDtcbiAgICAgICAgICAgIHNpemVDaGFuZ2VkID0gbmV3V2lkdGggIT09IHByZXZXaWR0aCB8fCBuZXdIZWlnaHQgIT09IHByZXZIZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIobmV3IENvbXBvbmVudEV2ZW50JDEoRVZFTlRTLkFGVEVSX1JFU0laRSwge1xuICAgICAgICAgICAgICB3aWR0aDogdmlld3BvcnQud2lkdGgsXG4gICAgICAgICAgICAgIGhlaWdodDogdmlld3BvcnQuaGVpZ2h0LFxuICAgICAgICAgICAgICBwcmV2OiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IHByZXZXaWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHByZXZIZWlnaHRcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2l6ZUNoYW5nZWQ6IHNpemVDaGFuZ2VkLFxuICAgICAgICAgICAgICBlbGVtZW50OiB2aWV3cG9ydC5lbGVtZW50XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuICAvKipcclxuICAgKiBBZGQgbmV3IHBhbmVscyBhZnRlciB0aGUgbGFzdCBwYW5lbFxyXG4gICAqIEBrbyDtjKjrhJAg66qp66Gd7J2YIOygnOydvCDrgZ3sl5Ag7IOI66Gc7Jq0IO2MqOuEkOuTpOydhCDstpTqsIDtlanri4jri6RcclxuICAgKiBAcGFyYW0ge0VsZW1lbnRMaWtlIHwgRWxlbWVudExpa2VbXX0gZWxlbWVudCBBIG5ldyBIVE1MRWxlbWVudCwgYSBvdXRlckhUTUwgb2YgZWxlbWVudCwgb3IgYW4gYXJyYXkgb2YgYm90aFxyXG4gICAqIDxrbz7sg4jroZzsmrQgSFRNTEVsZW1lbnQsIO2YueydgCDsl5jrpqzrqLztirjsnZggb3V0ZXJIVE1MLCDtmLnsnYAg6re46rKD65Ok7J2YIOuwsOyXtDwva28+XHJcbiAgICogQHJldHVybiB7UGFuZWxbXX0gQW4gYXJyYXkgb2YgYXBwZW5kZWQgcGFuZWxzPGtvPuy2lOqwgOuQnCDtjKjrhJDrk6TsnZgg67Cw7Je0PC9rbz5cclxuICAgKiBAc2VlIFBhbmVsXHJcbiAgICogQHNlZSBFbGVtZW50TGlrZVxyXG4gICAqIEB0aHJvd3Mge0ZsaWNraW5nRXJyb3J9IHtAbGluayBFUlJPUl9DT0RFIEVSUk9SX0NPREUuTk9UX0FMTE9XRURfSU5fRlJBTUVXT1JLfSBpZiBjYWxsZWQgb24gZnJhbWV3b3JrcyAoUmVhY3QsIEFuZ3VsYXIsIFZ1ZS4uLilcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGBgYHRzXHJcbiAgICogY29uc3QgZmxpY2tpbmcgPSBuZXcgRmxpY2tpbmcoXCIjZmxpY2tcIik7XHJcbiAgICogLy8gVGhlc2UgYXJlIHBvc3NpYmxlIHBhcmFtZXRlcnNcclxuICAgKiBmbGlja2luZy5hcHBlbmQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSk7XHJcbiAgICogZmxpY2tpbmcuYXBwZW5kKFwiXFw8ZGl2XFw+UGFuZWxcXDwvZGl2XFw+XCIpO1xyXG4gICAqIGZsaWNraW5nLmFwcGVuZChbXCJcXDxkaXZcXD5QYW5lbFxcPC9kaXZcXD5cIiwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKV0pO1xyXG4gICAqIC8vIEV2ZW4gdGhpcyBpcyBwb3NzaWJsZVxyXG4gICAqIGZsaWNraW5nLmFwcGVuZChcIlxcPGRpdlxcPlBhbmVsIDFcXDwvZGl2XFw+XFw8ZGl2XFw+UGFuZWwgMlxcPC9kaXZcXD5cIik7XHJcbiAgICogYGBgXHJcbiAgICovXG4gIF9fcHJvdG8uYXBwZW5kID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gdGhpcy5pbnNlcnQodGhpcy5fcmVuZGVyZXIucGFuZWxDb3VudCwgZWxlbWVudCk7XG4gIH07XG4gIC8qKlxyXG4gICAqIEFkZCBuZXcgcGFuZWxzIGJlZm9yZSB0aGUgZmlyc3QgcGFuZWxcclxuICAgKiBUaGlzIHdpbGwgaW5jcmVhc2UgaW5kZXggb2YgcGFuZWxzIGFmdGVyIGJ5IHRoZSBudW1iZXIgb2YgcGFuZWxzIGFkZGVkXHJcbiAgICogQGtvIO2MqOuEkCDrqqnroZ3snZgg7KCc7J28IOyVnihpbmRleCAwKeyXkCDsg4jroZzsmrQg7Yyo64SQ65Ok7J2EIOy2lOqwgO2VqeuLiOuLpFxyXG4gICAqIOy2lOqwgO2VnCDtjKjrhJDsnZgg6rCc7IiY66eM7YG8IOq4sOyhtCDtjKjrhJDrk6TsnZgg7J24642x7Iqk6rCAIOymneqwgO2VqeuLiOuLpC5cclxuICAgKiBAcGFyYW0ge0VsZW1lbnRMaWtlIHwgRWxlbWVudExpa2VbXX0gZWxlbWVudCBBIG5ldyBIVE1MRWxlbWVudCwgYSBvdXRlckhUTUwgb2YgZWxlbWVudCwgb3IgYW4gYXJyYXkgb2YgYm90aFxyXG4gICAqIDxrbz7sg4jroZzsmrQgSFRNTEVsZW1lbnQsIO2YueydgCDsl5jrpqzrqLztirjsnZggb3V0ZXJIVE1MLCDtmLnsnYAg6re46rKD65Ok7J2YIOuwsOyXtDwva28+XHJcbiAgICogQHJldHVybiB7UGFuZWxbXX0gQW4gYXJyYXkgb2YgcHJlcGVuZGVkIHBhbmVsczxrbz7stpTqsIDrkJwg7Yyo64SQ65Ok7J2YIOuwsOyXtDwva28+XHJcbiAgICogQHNlZSBQYW5lbFxyXG4gICAqIEBzZWUgRWxlbWVudExpa2VcclxuICAgKiBAdGhyb3dzIHtGbGlja2luZ0Vycm9yfSB7QGxpbmsgRVJST1JfQ09ERSBFUlJPUl9DT0RFLk5PVF9BTExPV0VEX0lOX0ZSQU1FV09SS30gaWYgY2FsbGVkIG9uIGZyYW1ld29ya3MgKFJlYWN0LCBBbmd1bGFyLCBWdWUuLi4pXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBgYGB0c1xyXG4gICAqIGNvbnN0IGZsaWNraW5nID0gbmV3IGVnLkZsaWNraW5nKFwiI2ZsaWNrXCIpO1xyXG4gICAqIGZsaWNraW5nLnByZXBlbmQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSk7XHJcbiAgICogZmxpY2tpbmcucHJlcGVuZChcIlxcPGRpdlxcPlBhbmVsXFw8L2RpdlxcPlwiKTtcclxuICAgKiBmbGlja2luZy5wcmVwZW5kKFtcIlxcPGRpdlxcPlBhbmVsXFw8L2RpdlxcPlwiLCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpXSk7XHJcbiAgICogLy8gRXZlbiB0aGlzIGlzIHBvc3NpYmxlXHJcbiAgICogZmxpY2tpbmcucHJlcGVuZChcIlxcPGRpdlxcPlBhbmVsIDFcXDwvZGl2XFw+XFw8ZGl2XFw+UGFuZWwgMlxcPC9kaXZcXD5cIik7XHJcbiAgICogYGBgXHJcbiAgICovXG4gIF9fcHJvdG8ucHJlcGVuZCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgcmV0dXJuIHRoaXMuaW5zZXJ0KDAsIGVsZW1lbnQpO1xuICB9O1xuICAvKipcclxuICAgKiBJbnNlcnQgbmV3IHBhbmVscyBhdCBnaXZlbiBpbmRleFxyXG4gICAqIFRoaXMgd2lsbCBpbmNyZWFzZSBpbmRleCBvZiBwYW5lbHMgYWZ0ZXIgYnkgdGhlIG51bWJlciBvZiBwYW5lbHMgYWRkZWRcclxuICAgKiBAa28g7KO87Ja07KeEIOyduOuNseyKpOyXkCDsg4jroZzsmrQg7Yyo64SQ65Ok7J2EIOy2lOqwgO2VqeuLiOuLpFxyXG4gICAqIO2VtOuLuSDsnbjrjbHsiqTrs7Tri6Qg6rCZ6rGw64KYIO2BsCDsnbjrjbHsiqTrpbwg6rCA7KeEIOq4sOyhtCDtjKjrhJDrk6TsnYAg7LaU6rCA7ZWcIO2MqOuEkOydmCDqsJzsiJjrp4ztgbwg7J24642x7Iqk6rCAIOymneqwgO2VqeuLiOuLpC5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggdG8gaW5zZXJ0IG5ldyBwYW5lbHMgYXQ8a28+7IOI66GcIO2MqOuEkOuTpOydhCDstpTqsIDtlaAg7J24642x7IqkPC9rbz5cclxuICAgKiBAcGFyYW0ge0VsZW1lbnRMaWtlIHwgRWxlbWVudExpa2VbXX0gZWxlbWVudCBBIG5ldyBIVE1MRWxlbWVudCwgYSBvdXRlckhUTUwgb2YgZWxlbWVudCwgb3IgYW4gYXJyYXkgb2YgYm90aFxyXG4gICAqIDxrbz7sg4jroZzsmrQgSFRNTEVsZW1lbnQsIO2YueydgCDsl5jrpqzrqLztirjsnZggb3V0ZXJIVE1MLCDtmLnsnYAg6re46rKD65Ok7J2YIOuwsOyXtDwva28+XHJcbiAgICogQHJldHVybiB7UGFuZWxbXX0gQW4gYXJyYXkgb2YgcHJlcGVuZGVkIHBhbmVsczxrbz7stpTqsIDrkJwg7Yyo64SQ65Ok7J2YIOuwsOyXtDwva28+XHJcbiAgICogQHRocm93cyB7RmxpY2tpbmdFcnJvcn0ge0BsaW5rIEVSUk9SX0NPREUgRVJST1JfQ09ERS5OT1RfQUxMT1dFRF9JTl9GUkFNRVdPUkt9IGlmIGNhbGxlZCBvbiBmcmFtZXdvcmtzIChSZWFjdCwgQW5ndWxhciwgVnVlLi4uKVxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogYGBgdHNcclxuICAgKiBjb25zdCBmbGlja2luZyA9IG5ldyBlZy5GbGlja2luZyhcIiNmbGlja1wiKTtcclxuICAgKiBmbGlja2luZy5pbnNlcnQoMCwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSk7XHJcbiAgICogZmxpY2tpbmcuaW5zZXJ0KDIsIFwiXFw8ZGl2XFw+UGFuZWxcXDwvZGl2XFw+XCIpO1xyXG4gICAqIGZsaWNraW5nLmluc2VydCgxLCBbXCJcXDxkaXZcXD5QYW5lbFxcPC9kaXZcXD5cIiwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKV0pO1xyXG4gICAqIC8vIEV2ZW4gdGhpcyBpcyBwb3NzaWJsZVxyXG4gICAqIGZsaWNraW5nLmluc2VydCgzLCBcIlxcPGRpdlxcPlBhbmVsIDFcXDwvZGl2XFw+XFw8ZGl2XFw+UGFuZWwgMlxcPC9kaXZcXD5cIik7XHJcbiAgICogYGBgXHJcbiAgICovXG4gIF9fcHJvdG8uaW5zZXJ0ID0gZnVuY3Rpb24gKGluZGV4LCBlbGVtZW50KSB7XG4gICAgaWYgKHRoaXMuX3JlbmRlckV4dGVybmFsKSB7XG4gICAgICB0aHJvdyBuZXcgRmxpY2tpbmdFcnJvcihNRVNTQUdFLk5PVF9BTExPV0VEX0lOX0ZSQU1FV09SSywgQ09ERS5OT1RfQUxMT1dFRF9JTl9GUkFNRVdPUkspO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcmVuZGVyZXIuYmF0Y2hJbnNlcnQoe1xuICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgZWxlbWVudHM6IHBhcnNlRWxlbWVudChlbGVtZW50KSxcbiAgICAgIGhhc0RPTUluRWxlbWVudHM6IHRydWVcbiAgICB9KTtcbiAgfTtcbiAgLyoqXHJcbiAgICogUmVtb3ZlIHRoZSBwYW5lbCBhdCB0aGUgZ2l2ZW4gaW5kZXhcclxuICAgKiBUaGlzIHdpbGwgZGVjcmVhc2UgaW5kZXggb2YgcGFuZWxzIGFmdGVyIGJ5IHRoZSBudW1iZXIgb2YgcGFuZWxzIHJlbW92ZWRcclxuICAgKiBAa28g7KO87Ja07KeEIOyduOuNseyKpOydmCDtjKjrhJDsnYQg7KCc6rGw7ZWp64uI64ukXHJcbiAgICog7ZW064u5IOyduOuNseyKpOuztOuLpCDtgbAg7J24642x7Iqk66W8IOqwgOynhCDquLDsobQg7Yyo64SQ65Ok7J2AIOygnOqxsO2VnCDtjKjrhJDsnZgg6rCc7IiY66eM7YG8IOyduOuNseyKpOqwgCDqsJDshoztlanri4jri6RcclxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggb2YgcGFuZWwgdG8gcmVtb3ZlPGtvPuygnOqxsO2VoCDtjKjrhJDsnZgg7J24642x7IqkPC9rbz5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gW2RlbGV0ZUNvdW50PTFdIE51bWJlciBvZiBwYW5lbHMgdG8gcmVtb3ZlIGZyb20gaW5kZXg8a28+YGluZGV4YCDsnbTtm4TroZwg7KCc6rGw7ZWgIO2MqOuEkOydmCDqsJzsiJg8L2tvPlxyXG4gICAqIEByZXR1cm4ge1BhbmVsW119IEFuIGFycmF5IG9mIHJlbW92ZWQgcGFuZWxzPGtvPuygnOqxsOuQnCDtjKjrhJDrk6TsnZgg67Cw7Je0PC9rbz5cclxuICAgKi9cbiAgX19wcm90by5yZW1vdmUgPSBmdW5jdGlvbiAoaW5kZXgsIGRlbGV0ZUNvdW50KSB7XG4gICAgaWYgKGRlbGV0ZUNvdW50ID09PSB2b2lkIDApIHtcbiAgICAgIGRlbGV0ZUNvdW50ID0gMTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3JlbmRlckV4dGVybmFsKSB7XG4gICAgICB0aHJvdyBuZXcgRmxpY2tpbmdFcnJvcihNRVNTQUdFLk5PVF9BTExPV0VEX0lOX0ZSQU1FV09SSywgQ09ERS5OT1RfQUxMT1dFRF9JTl9GUkFNRVdPUkspO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcmVuZGVyZXIuYmF0Y2hSZW1vdmUoe1xuICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgZGVsZXRlQ291bnQ6IGRlbGV0ZUNvdW50LFxuICAgICAgaGFzRE9NSW5FbGVtZW50czogdHJ1ZVxuICAgIH0pO1xuICB9O1xuICBfX3Byb3RvLl9jcmVhdGVDb250cm9sID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfYTtcbiAgICB2YXIgbW92ZVR5cGUgPSB0aGlzLl9tb3ZlVHlwZTtcbiAgICB2YXIgbW92ZVR5cGVzID0gT2JqZWN0LmtleXMoTU9WRV9UWVBFKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIE1PVkVfVFlQRVtrZXldO1xuICAgIH0pO1xuICAgIHZhciBtb3ZlVHlwZVN0ciA9IEFycmF5LmlzQXJyYXkobW92ZVR5cGUpID8gbW92ZVR5cGVbMF0gOiBtb3ZlVHlwZTtcbiAgICB2YXIgbW92ZVR5cGVPcHRpb25zID0gQXJyYXkuaXNBcnJheShtb3ZlVHlwZSkgPyAoX2EgPSBtb3ZlVHlwZVsxXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge30gOiB7fTtcbiAgICBpZiAoIWluY2x1ZGVzKG1vdmVUeXBlcywgbW92ZVR5cGVTdHIpKSB7XG4gICAgICB0aHJvdyBuZXcgRmxpY2tpbmdFcnJvcihNRVNTQUdFLldST05HX09QVElPTihcIm1vdmVUeXBlXCIsIEpTT04uc3RyaW5naWZ5KG1vdmVUeXBlKSksIENPREUuV1JPTkdfT1BUSU9OKTtcbiAgICB9XG4gICAgc3dpdGNoIChtb3ZlVHlwZVN0cikge1xuICAgICAgY2FzZSBNT1ZFX1RZUEUuU05BUDpcbiAgICAgICAgcmV0dXJuIG5ldyBTbmFwQ29udHJvbChtb3ZlVHlwZU9wdGlvbnMpO1xuICAgICAgY2FzZSBNT1ZFX1RZUEUuRlJFRV9TQ1JPTEw6XG4gICAgICAgIHJldHVybiBuZXcgRnJlZUNvbnRyb2wobW92ZVR5cGVPcHRpb25zKTtcbiAgICAgIGNhc2UgTU9WRV9UWVBFLlNUUklDVDpcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJpY3RDb250cm9sKG1vdmVUeXBlT3B0aW9ucyk7XG4gICAgfVxuICB9O1xuICBfX3Byb3RvLl9jcmVhdGVDYW1lcmEgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX2NpcmN1bGFyICYmIHRoaXMuX2JvdW5kKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgY29uc29sZS53YXJuKFwiXFxcImNpcmN1bGFyXFxcIiBhbmQgXFxcImJvdW5kXFxcIiBvcHRpb24gY2Fubm90IGJlIHVzZWQgdG9nZXRoZXIsIGlnbm9yaW5nIGJvdW5kLlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBDYW1lcmEodGhpcywge1xuICAgICAgYWxpZ246IHRoaXMuX2FsaWduXG4gICAgfSk7XG4gIH07XG4gIF9fcHJvdG8uX2NyZWF0ZVJlbmRlcmVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlcm5hbFJlbmRlcmVyID0gdGhpcy5fZXh0ZXJuYWxSZW5kZXJlcjtcbiAgICBpZiAodGhpcy5fdmlydHVhbCAmJiB0aGlzLl9wYW5lbHNQZXJWaWV3IDw9IDApIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlLndhcm4oXCJcXFwidmlydHVhbFxcXCIgYW5kIFxcXCJwYW5lbHNQZXJWaWV3XFxcIiBvcHRpb24gc2hvdWxkIGJlIHVzZWQgdG9nZXRoZXIsIGlnbm9yaW5nIHZpcnR1YWwuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gZXh0ZXJuYWxSZW5kZXJlciA/IGV4dGVybmFsUmVuZGVyZXIgOiB0aGlzLl9yZW5kZXJFeHRlcm5hbCA/IHRoaXMuX2NyZWF0ZUV4dGVybmFsUmVuZGVyZXIoKSA6IHRoaXMuX2NyZWF0ZVZhbmlsbGFSZW5kZXJlcigpO1xuICB9O1xuICBfX3Byb3RvLl9jcmVhdGVFeHRlcm5hbFJlbmRlcmVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfYSA9IHRoaXMuX3JlbmRlckV4dGVybmFsLFxuICAgICAgcmVuZGVyZXIgPSBfYS5yZW5kZXJlcixcbiAgICAgIHJlbmRlcmVyT3B0aW9ucyA9IF9hLnJlbmRlcmVyT3B0aW9ucztcbiAgICByZXR1cm4gbmV3IHJlbmRlcmVyKF9fYXNzaWduJDIoe1xuICAgICAgYWxpZ246IHRoaXMuX2FsaWduXG4gICAgfSwgcmVuZGVyZXJPcHRpb25zKSk7XG4gIH07XG4gIF9fcHJvdG8uX2NyZWF0ZVZhbmlsbGFSZW5kZXJlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdmlydHVhbCA9IHRoaXMudmlydHVhbEVuYWJsZWQ7XG4gICAgcmV0dXJuIG5ldyBWYW5pbGxhUmVuZGVyZXIoe1xuICAgICAgYWxpZ246IHRoaXMuX2FsaWduLFxuICAgICAgc3RyYXRlZ3k6IHZpcnR1YWwgPyBuZXcgVmlydHVhbFJlbmRlcmluZ1N0cmF0ZWd5KCkgOiBuZXcgTm9ybWFsUmVuZGVyaW5nU3RyYXRlZ3koe1xuICAgICAgICBwcm92aWRlckN0b3I6IFZhbmlsbGFFbGVtZW50UHJvdmlkZXJcbiAgICAgIH0pXG4gICAgfSk7XG4gIH07XG4gIF9fcHJvdG8uX21vdmVUb0luaXRpYWxQYW5lbCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLl9yZW5kZXJlcjtcbiAgICB2YXIgY29udHJvbCA9IHRoaXMuX2NvbnRyb2w7XG4gICAgdmFyIGNhbWVyYSA9IHRoaXMuX2NhbWVyYTtcbiAgICB2YXIgZGVmYXVsdFBhbmVsID0gcmVuZGVyZXIuZ2V0UGFuZWwodGhpcy5fZGVmYXVsdEluZGV4KSB8fCByZW5kZXJlci5nZXRQYW5lbCgwKTtcbiAgICBpZiAoIWRlZmF1bHRQYW5lbCkgcmV0dXJuO1xuICAgIHZhciBuZWFyZXN0QW5jaG9yID0gY2FtZXJhLmZpbmROZWFyZXN0QW5jaG9yKGRlZmF1bHRQYW5lbC5wb3NpdGlvbik7XG4gICAgdmFyIGluaXRpYWxQYW5lbCA9IG5lYXJlc3RBbmNob3IgJiYgZGVmYXVsdFBhbmVsLmluZGV4ICE9PSBuZWFyZXN0QW5jaG9yLnBhbmVsLmluZGV4ID8gbmVhcmVzdEFuY2hvci5wYW5lbCA6IGRlZmF1bHRQYW5lbDtcbiAgICBjb250cm9sLnNldEFjdGl2ZShpbml0aWFsUGFuZWwsIG51bGwsIGZhbHNlKTtcbiAgICBpZiAoIW5lYXJlc3RBbmNob3IpIHtcbiAgICAgIHRocm93IG5ldyBGbGlja2luZ0Vycm9yKE1FU1NBR0UuUE9TSVRJT05fTk9UX1JFQUNIQUJMRShpbml0aWFsUGFuZWwucG9zaXRpb24pLCBDT0RFLlBPU0lUSU9OX05PVF9SRUFDSEFCTEUpO1xuICAgIH1cbiAgICB2YXIgcG9zaXRpb24gPSBpbml0aWFsUGFuZWwucG9zaXRpb247XG4gICAgaWYgKCFjYW1lcmEuY2FuUmVhY2goaW5pdGlhbFBhbmVsKSkge1xuICAgICAgcG9zaXRpb24gPSBuZWFyZXN0QW5jaG9yLnBvc2l0aW9uO1xuICAgIH1cbiAgICBjYW1lcmEubG9va0F0KHBvc2l0aW9uKTtcbiAgICBjb250cm9sLnVwZGF0ZUlucHV0KCk7XG4gICAgY2FtZXJhLnVwZGF0ZU9mZnNldCgpO1xuICB9O1xuICBfX3Byb3RvLl9pbml0aWFsUmVzaXplID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2aWV3cG9ydCA9IHRoaXMuX3ZpZXdwb3J0O1xuICAgIHZhciByZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVyO1xuICAgIHZhciBjYW1lcmEgPSB0aGlzLl9jYW1lcmE7XG4gICAgdmFyIGNvbnRyb2wgPSB0aGlzLl9jb250cm9sO1xuICAgIHRoaXMudHJpZ2dlcihuZXcgQ29tcG9uZW50RXZlbnQkMShFVkVOVFMuQkVGT1JFX1JFU0laRSwge1xuICAgICAgd2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IDAsXG4gICAgICBlbGVtZW50OiB2aWV3cG9ydC5lbGVtZW50XG4gICAgfSkpO1xuICAgIHZpZXdwb3J0LnJlc2l6ZSgpO1xuICAgIHJlbmRlcmVyLnVwZGF0ZVBhbmVsU2l6ZSgpO1xuICAgIGNhbWVyYS51cGRhdGVBbGlnblBvcygpO1xuICAgIGNhbWVyYS51cGRhdGVSYW5nZSgpO1xuICAgIGNhbWVyYS51cGRhdGVBbmNob3JzKCk7XG4gICAgY2FtZXJhLnVwZGF0ZU9mZnNldCgpO1xuICAgIGNvbnRyb2wudXBkYXRlSW5wdXQoKTtcbiAgICB2YXIgbmV3V2lkdGggPSB2aWV3cG9ydC53aWR0aDtcbiAgICB2YXIgbmV3SGVpZ2h0ID0gdmlld3BvcnQuaGVpZ2h0O1xuICAgIHZhciBzaXplQ2hhbmdlZCA9IG5ld1dpZHRoICE9PSAwIHx8IG5ld0hlaWdodCAhPT0gMDtcbiAgICB0aGlzLnRyaWdnZXIobmV3IENvbXBvbmVudEV2ZW50JDEoRVZFTlRTLkFGVEVSX1JFU0laRSwge1xuICAgICAgd2lkdGg6IHZpZXdwb3J0LndpZHRoLFxuICAgICAgaGVpZ2h0OiB2aWV3cG9ydC5oZWlnaHQsXG4gICAgICBwcmV2OiB7XG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IDBcbiAgICAgIH0sXG4gICAgICBzaXplQ2hhbmdlZDogc2l6ZUNoYW5nZWQsXG4gICAgICBlbGVtZW50OiB2aWV3cG9ydC5lbGVtZW50XG4gICAgfSkpO1xuICB9O1xuICAvKipcclxuICAgKiBWZXJzaW9uIGluZm8gc3RyaW5nXHJcbiAgICogQGtvIOuyhOyghOygleuztCDrrLjsnpDsl7RcclxuICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogYGBgdHNcclxuICAgKiBGbGlja2luZy5WRVJTSU9OOyAgLy8gZXgpIDQuMC4wXHJcbiAgICogYGBgXHJcbiAgICovXG4gIEZsaWNraW5nLlZFUlNJT04gPSBcIjQuMTEuNFwiO1xuICByZXR1cm4gRmxpY2tpbmc7XG59KENvbXBvbmVudCk7XG5cbi8qKlxyXG4gKiBEZWNvcmF0b3IgdGhhdCBtYWtlcyB0aGUgbWV0aG9kIG9mIGZsaWNraW5nIGF2YWlsYWJsZSBpbiB0aGUgZnJhbWV3b3JrLlxyXG4gKiBAa28g7ZSE66CI7J6E7JuM7YGs7JeQ7IScIO2UjOumrO2CueydmCDrqZTshozrk5zrpbwg7IKs7Jqp7ZWgIOyImCDsnojqsowg7ZWY64qUIOuNsOy9lOugiOydtO2EsC5cclxuICogQG1lbWJlcm9mIGVnLkZsaWNraW5nXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYGpzXHJcbiAqIGltcG9ydCBGbGlja2luZywgeyB3aXRoRmxpY2tpbmdNZXRob2RzIH0gZnJvbSBcIkBlZ2pzL2ZsaWNraW5nXCI7XHJcbiAqXHJcbiAqIGNsYXNzIEZsaWNraW5nIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PFBhcnRpYWw8RmxpY2tpbmdQcm9wcyAmIEZsaWNraW5nT3B0aW9ucz4+IHtcclxuICogICAmIzY0O3dpdGhGbGlja2luZ01ldGhvZHNcclxuICogICBwcml2YXRlIGZsaWNraW5nOiBGbGlja2luZztcclxuICogfVxyXG4gKiBgYGBcclxuICovXG52YXIgd2l0aEZsaWNraW5nTWV0aG9kcyA9IGZ1bmN0aW9uIChwcm90b3R5cGUsIGZsaWNraW5nTmFtZSkge1xuICBbQ29tcG9uZW50LnByb3RvdHlwZSwgRmxpY2tpbmcucHJvdG90eXBlXS5mb3JFYWNoKGZ1bmN0aW9uIChwcm90bykge1xuICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3RvKS5maWx0ZXIoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHJldHVybiAhcHJvdG90eXBlW25hbWVdICYmIG5hbWUuaW5kZXhPZihcIl9cIikgIT09IDAgJiYgbmFtZSAhPT0gXCJjb25zdHJ1Y3RvclwiO1xuICAgIH0pLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwcm90bywgbmFtZSk7XG4gICAgICBpZiAoZGVzY3JpcHRvci52YWx1ZSkge1xuICAgICAgICAvLyBQdWJsaWMgRnVuY3Rpb25cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvdHlwZSwgbmFtZSwge1xuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIChfYSA9IGRlc2NyaXB0b3IudmFsdWUpLmNhbGwuYXBwbHkoX2EsIF9fc3ByZWFkJDEoW3RoaXNbZmxpY2tpbmdOYW1lXV0sIGFyZ3MpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGdldHRlckRlc2NyaXB0b3IgPSB7fTtcbiAgICAgICAgaWYgKGRlc2NyaXB0b3IuZ2V0KSB7XG4gICAgICAgICAgZ2V0dGVyRGVzY3JpcHRvci5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICB2YXIgZmxpY2tpbmcgPSB0aGlzW2ZsaWNraW5nTmFtZV07XG4gICAgICAgICAgICByZXR1cm4gZmxpY2tpbmcgJiYgKChfYSA9IGRlc2NyaXB0b3IuZ2V0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChmbGlja2luZykpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlc2NyaXB0b3Iuc2V0KSB7XG4gICAgICAgICAgZ2V0dGVyRGVzY3JpcHRvci5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIChfYSA9IGRlc2NyaXB0b3Iuc2V0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbC5hcHBseShfYSwgX19zcHJlYWQkMShbdGhpc1tmbGlja2luZ05hbWVdXSwgYXJncykpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvdHlwZSwgbmFtZSwgZ2V0dGVyRGVzY3JpcHRvcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufTtcblxudmFyIHN5bmMgPSAoZnVuY3Rpb24gKGZsaWNraW5nLCBkaWZmUmVzdWx0LCByZW5kZXJlZCkge1xuICB2YXIgcmVuZGVyZXIgPSBmbGlja2luZy5yZW5kZXJlcjtcbiAgdmFyIHBhbmVscyA9IHJlbmRlcmVyLnBhbmVscztcbiAgdmFyIHByZXZMaXN0ID0gX19zcHJlYWQkMShkaWZmUmVzdWx0LnByZXZMaXN0KTtcbiAgdmFyIGFkZGVkID0gW107XG4gIHZhciByZW1vdmVkID0gW107XG4gIGlmIChkaWZmUmVzdWx0LnJlbW92ZWQubGVuZ3RoID4gMCkge1xuICAgIHZhciBlbmRJZHhfMSA9IC0xO1xuICAgIHZhciBwcmV2SWR4XzEgPSAtMTtcbiAgICBkaWZmUmVzdWx0LnJlbW92ZWQuZm9yRWFjaChmdW5jdGlvbiAocmVtb3ZlZElkeCkge1xuICAgICAgaWYgKGVuZElkeF8xIDwgMCkge1xuICAgICAgICBlbmRJZHhfMSA9IHJlbW92ZWRJZHg7XG4gICAgICB9XG4gICAgICBpZiAocHJldklkeF8xID49IDAgJiYgcmVtb3ZlZElkeCAhPT0gcHJldklkeF8xIC0gMSkge1xuICAgICAgICByZW1vdmVkLnB1c2guYXBwbHkocmVtb3ZlZCwgX19zcHJlYWQkMShiYXRjaFJlbW92ZShyZW5kZXJlciwgcHJldklkeF8xLCBlbmRJZHhfMSArIDEpKSk7XG4gICAgICAgIGVuZElkeF8xID0gcmVtb3ZlZElkeDtcbiAgICAgICAgcHJldklkeF8xID0gcmVtb3ZlZElkeDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByZXZJZHhfMSA9IHJlbW92ZWRJZHg7XG4gICAgICB9XG4gICAgICBwcmV2TGlzdC5zcGxpY2UocmVtb3ZlZElkeCwgMSk7XG4gICAgfSk7XG4gICAgcmVtb3ZlZC5wdXNoLmFwcGx5KHJlbW92ZWQsIF9fc3ByZWFkJDEoYmF0Y2hSZW1vdmUocmVuZGVyZXIsIHByZXZJZHhfMSwgZW5kSWR4XzEgKyAxKSkpO1xuICB9XG4gIGRpZmZSZXN1bHQub3JkZXJlZC5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBfYiA9IF9fcmVhZCQxKF9hLCAyKSxcbiAgICAgIGZyb20gPSBfYlswXSxcbiAgICAgIHRvID0gX2JbMV07XG4gICAgdmFyIHByZXZQYW5lbCA9IHBhbmVscy5zcGxpY2UoZnJvbSwgMSlbMF07XG4gICAgcGFuZWxzLnNwbGljZSh0bywgMCwgcHJldlBhbmVsKTtcbiAgfSk7XG4gIGlmIChkaWZmUmVzdWx0Lm9yZGVyZWQubGVuZ3RoID4gMCkge1xuICAgIHBhbmVscy5mb3JFYWNoKGZ1bmN0aW9uIChwYW5lbCwgaWR4KSB7XG4gICAgICB2YXIgaW5kZXhEaWZmID0gaWR4IC0gcGFuZWwuaW5kZXg7XG4gICAgICBpZiAoaW5kZXhEaWZmID4gMCkge1xuICAgICAgICBwYW5lbC5pbmNyZWFzZUluZGV4KGluZGV4RGlmZik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYW5lbC5kZWNyZWFzZUluZGV4KC1pbmRleERpZmYpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHBhbmVscy5zb3J0KGZ1bmN0aW9uIChwYW5lbDEsIHBhbmVsMikge1xuICAgICAgcmV0dXJuIHBhbmVsMS5pbmRleCAtIHBhbmVsMi5pbmRleDtcbiAgICB9KTtcbiAgICBwYW5lbHMuZm9yRWFjaChmdW5jdGlvbiAocGFuZWwpIHtcbiAgICAgIHBhbmVsLnVwZGF0ZVBvc2l0aW9uKCk7XG4gICAgfSk7XG4gIH1cbiAgaWYgKGRpZmZSZXN1bHQuYWRkZWQubGVuZ3RoID4gMCkge1xuICAgIHZhciBzdGFydElkeF8xID0gLTE7XG4gICAgdmFyIHByZXZJZHhfMiA9IC0xO1xuICAgIHZhciBhZGRlZEVsZW1lbnRzXzEgPSByZW5kZXJlZC5zbGljZShwcmV2TGlzdC5sZW5ndGgpO1xuICAgIGRpZmZSZXN1bHQuYWRkZWQuZm9yRWFjaChmdW5jdGlvbiAoYWRkZWRJZHgsIGlkeCkge1xuICAgICAgaWYgKHN0YXJ0SWR4XzEgPCAwKSB7XG4gICAgICAgIHN0YXJ0SWR4XzEgPSBpZHg7XG4gICAgICB9XG4gICAgICBpZiAocHJldklkeF8yID49IDAgJiYgYWRkZWRJZHggIT09IHByZXZJZHhfMiArIDEpIHtcbiAgICAgICAgYWRkZWQucHVzaC5hcHBseShhZGRlZCwgX19zcHJlYWQkMShiYXRjaEluc2VydChyZW5kZXJlciwgZGlmZlJlc3VsdCwgYWRkZWRFbGVtZW50c18xLCBzdGFydElkeF8xLCBpZHggKyAxKSkpO1xuICAgICAgICBzdGFydElkeF8xID0gLTE7XG4gICAgICAgIHByZXZJZHhfMiA9IC0xO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJldklkeF8yID0gYWRkZWRJZHg7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHN0YXJ0SWR4XzEgPj0gMCkge1xuICAgICAgYWRkZWQucHVzaC5hcHBseShhZGRlZCwgX19zcHJlYWQkMShiYXRjaEluc2VydChyZW5kZXJlciwgZGlmZlJlc3VsdCwgYWRkZWRFbGVtZW50c18xLCBzdGFydElkeF8xKSkpO1xuICAgIH1cbiAgfVxuICBpZiAoZGlmZlJlc3VsdC5hZGRlZC5sZW5ndGggPiAwIHx8IGRpZmZSZXN1bHQucmVtb3ZlZC5sZW5ndGggPiAwKSB7XG4gICAgcmVuZGVyZXIudXBkYXRlQWZ0ZXJQYW5lbENoYW5nZShhZGRlZCwgcmVtb3ZlZCk7XG4gIH1cbn0pO1xudmFyIGJhdGNoSW5zZXJ0ID0gZnVuY3Rpb24gKHJlbmRlcmVyLCBkaWZmUmVzdWx0LCBhZGRlZEVsZW1lbnRzLCBzdGFydElkeCwgZW5kSWR4KSB7XG4gIHJldHVybiByZW5kZXJlci5iYXRjaEluc2VydERlZmVyLmFwcGx5KHJlbmRlcmVyLCBfX3NwcmVhZCQxKGRpZmZSZXN1bHQuYWRkZWQuc2xpY2Uoc3RhcnRJZHgsIGVuZElkeCkubWFwKGZ1bmN0aW9uIChpbmRleCwgZWxJZHgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgZWxlbWVudHM6IFthZGRlZEVsZW1lbnRzW2VsSWR4XV0sXG4gICAgICBoYXNET01JbkVsZW1lbnRzOiBmYWxzZVxuICAgIH07XG4gIH0pKSk7XG59O1xudmFyIGJhdGNoUmVtb3ZlID0gZnVuY3Rpb24gKHJlbmRlcmVyLCBzdGFydElkeCwgZW5kSWR4KSB7XG4gIHZhciByZW1vdmVkID0gcmVuZGVyZXIucGFuZWxzLnNsaWNlKHN0YXJ0SWR4LCBlbmRJZHgpO1xuICByZXR1cm4gcmVuZGVyZXIuYmF0Y2hSZW1vdmVEZWZlcih7XG4gICAgaW5kZXg6IHN0YXJ0SWR4LFxuICAgIGRlbGV0ZUNvdW50OiByZW1vdmVkLmxlbmd0aCxcbiAgICBoYXNET01JbkVsZW1lbnRzOiBmYWxzZVxuICB9KTtcbn07XG5cbnZhciBnZXRSZW5kZXJpbmdQYW5lbHMgPSAoZnVuY3Rpb24gKGZsaWNraW5nLCBkaWZmUmVzdWx0KSB7XG4gIHZhciByZW1vdmVkUGFuZWxzID0gZGlmZlJlc3VsdC5yZW1vdmVkLnJlZHVjZShmdW5jdGlvbiAobWFwLCBpZHgpIHtcbiAgICBtYXBbaWR4XSA9IHRydWU7XG4gICAgcmV0dXJuIG1hcDtcbiAgfSwge30pO1xuICB2YXIgbWFpbnRhaW5lZE1hcCA9IGRpZmZSZXN1bHQubWFpbnRhaW5lZC5yZWR1Y2UoZnVuY3Rpb24gKG1hcCwgX2EpIHtcbiAgICB2YXIgX2IgPSBfX3JlYWQkMShfYSwgMiksXG4gICAgICBwcmV2ID0gX2JbMF0sXG4gICAgICBjdXJyZW50ID0gX2JbMV07XG4gICAgbWFwW3ByZXZdID0gY3VycmVudDtcbiAgICByZXR1cm4gbWFwO1xuICB9LCB7fSk7XG4gIHJldHVybiBfX3NwcmVhZCQxKGZsaWNraW5nLnBhbmVscy5maWx0ZXIoZnVuY3Rpb24gKHBhbmVsKSB7XG4gICAgcmV0dXJuICFyZW1vdmVkUGFuZWxzW3BhbmVsLmluZGV4XTtcbiAgfSlcbiAgLy8gU29ydCBwYW5lbHMgYnkgcG9zaXRpb25cbiAgLnNvcnQoZnVuY3Rpb24gKHBhbmVsMSwgcGFuZWwyKSB7XG4gICAgcmV0dXJuIHBhbmVsMS5wb3NpdGlvbiArIHBhbmVsMS5vZmZzZXQgLSAocGFuZWwyLnBvc2l0aW9uICsgcGFuZWwyLm9mZnNldCk7XG4gIH0pLm1hcChmdW5jdGlvbiAocGFuZWwpIHtcbiAgICByZXR1cm4gZGlmZlJlc3VsdC5saXN0W21haW50YWluZWRNYXBbcGFuZWwuaW5kZXhdXTtcbiAgfSksIGRpZmZSZXN1bHQuYWRkZWQubWFwKGZ1bmN0aW9uIChpZHgpIHtcbiAgICByZXR1cm4gZGlmZlJlc3VsdC5saXN0W2lkeF07XG4gIH0pKTtcbn0pO1xuXG52YXIgZ2V0RGVmYXVsdENhbWVyYVRyYW5zZm9ybSA9IChmdW5jdGlvbiAoYWxpZ24sIGhvcml6b250YWwsIGZpcnN0UGFuZWxTaXplKSB7XG4gIGlmIChhbGlnbiA9PT0gdm9pZCAwKSB7XG4gICAgYWxpZ24gPSBBTElHTi5DRU5URVI7XG4gIH1cbiAgaWYgKGhvcml6b250YWwgPT09IHZvaWQgMCkge1xuICAgIGhvcml6b250YWwgPSB0cnVlO1xuICB9XG4gIHZhciBjYW1lcmFBbGlnbiA9IGdldENhbWVyYUFsaWduKGFsaWduKTtcbiAgdmFyIHBhbmVsQWxpZ24gPSBnZXRQYW5lbEFsaWduKGFsaWduKTtcbiAgaWYgKHBhbmVsQWxpZ24gPT0gbnVsbCkgcmV0dXJuIFwiXCI7XG4gIHZhciBjYW1Qb3NpdGlvbiA9IFwiY2FsYyhcIiArIGNhbWVyYUFsaWduICsgXCIgLSAoXCIgKyAoZmlyc3RQYW5lbFNpemUgfHwgXCIwcHhcIikgKyBcIiAqIFwiICsgcGFuZWxBbGlnbi5wZXJjZW50YWdlICsgXCIpIC0gXCIgKyBwYW5lbEFsaWduLmFic29sdXRlICsgXCJweClcIjtcbiAgcmV0dXJuIGhvcml6b250YWwgPyBcInRyYW5zbGF0ZShcIiArIGNhbVBvc2l0aW9uICsgXCIpXCIgOiBcInRyYW5zbGF0ZSgwLCBcIiArIGNhbVBvc2l0aW9uICsgXCIpXCI7XG59KTtcbnZhciBnZXRDYW1lcmFBbGlnbiA9IGZ1bmN0aW9uIChhbGlnbikge1xuICB2YXIgYWxpZ25WYWwgPSB0eXBlb2YgYWxpZ24gPT09IFwib2JqZWN0XCIgPyBhbGlnbi5jYW1lcmEgOiBhbGlnbjtcbiAgcmV0dXJuIHBhcnNlQWxpZ24oYWxpZ25WYWwpO1xufTtcbnZhciBnZXRQYW5lbEFsaWduID0gZnVuY3Rpb24gKGFsaWduKSB7XG4gIHZhciBhbGlnblZhbCA9IHR5cGVvZiBhbGlnbiA9PT0gXCJvYmplY3RcIiA/IGFsaWduLnBhbmVsIDogYWxpZ247XG4gIHJldHVybiBwYXJzZUFyaXRobWV0aWNFeHByZXNzaW9uKHBhcnNlQWxpZ24oYWxpZ25WYWwpKTtcbn07XG52YXIgcGFyc2VBbGlnbiA9IGZ1bmN0aW9uIChhbGlnblZhbCkge1xuICBpZiAodHlwZW9mIGFsaWduVmFsID09PSBcIm51bWJlclwiKSB7XG4gICAgcmV0dXJuIGFsaWduVmFsICsgXCJweFwiO1xuICB9XG4gIHN3aXRjaCAoYWxpZ25WYWwpIHtcbiAgICBjYXNlIEFMSUdOLkNFTlRFUjpcbiAgICAgIHJldHVybiBcIjUwJVwiO1xuICAgIGNhc2UgQUxJR04uTkVYVDpcbiAgICAgIHJldHVybiBcIjEwMCVcIjtcbiAgICBjYXNlIEFMSUdOLlBSRVY6XG4gICAgICByZXR1cm4gXCIwJVwiO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gYWxpZ25WYWw7XG4gIH1cbn07XG5cbi8qXG5Db3B5cmlnaHQgKGMpIDIwMTUtcHJlc2VudCBOQVZFUiBDb3JwLlxubmFtZTogQGVnanMvcmVhY3QtZmxpY2tpbmdcbmxpY2Vuc2U6IE1JVFxuYXV0aG9yOiBOQVZFUiBDb3JwLlxucmVwb3NpdG9yeTogaHR0cHM6Ly9naXRodWIuY29tL25hdmVyL2VnanMtZmxpY2tpbmcvdHJlZS9tYXN0ZXIvcGFja2FnZXMvcmVhY3QtZmxpY2tpbmdcbnZlcnNpb246IDQuMTEuNFxuKi9cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xuXG52YXIgZXh0ZW5kU3RhdGljcyQ0ID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgZXh0ZW5kU3RhdGljcyQ0ID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IHtcbiAgICBfX3Byb3RvX186IFtdXG4gIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikge1xuICAgIGQuX19wcm90b19fID0gYjtcbiAgfSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07XG4gIH07XG4gIHJldHVybiBleHRlbmRTdGF0aWNzJDQoZCwgYik7XG59O1xuZnVuY3Rpb24gX19leHRlbmRzJDQoZCwgYikge1xuICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gIGV4dGVuZFN0YXRpY3MkNChkLCBiKTtcbiAgZnVuY3Rpb24gX18oKSB7XG4gICAgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7XG4gIH1cbiAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufVxudmFyIF9fYXNzaWduJDMgPSBmdW5jdGlvbiAoKSB7XG4gIF9fYXNzaWduJDMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcbiAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xuICAgIH1cbiAgICByZXR1cm4gdDtcbiAgfTtcbiAgcmV0dXJuIF9fYXNzaWduJDMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5mdW5jdGlvbiBfX3Jlc3QocywgZSkge1xuICB2YXIgdCA9IHt9O1xuICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMCkgdFtwXSA9IHNbcF07XG4gIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIikgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSkgdFtwW2ldXSA9IHNbcFtpXV07XG4gIH1cbiAgcmV0dXJuIHQ7XG59XG5mdW5jdGlvbiBfX2RlY29yYXRlJDEoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLFxuICAgIGQ7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7ZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn1cbmZ1bmN0aW9uIF9fYXdhaXRlciQxKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7XG4gICAgICByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTtcbiAgICB9XG4gICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIF9fZ2VuZXJhdG9yJDEodGhpc0FyZywgYm9keSkge1xuICB2YXIgXyA9IHtcbiAgICAgIGxhYmVsOiAwLFxuICAgICAgc2VudDogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodFswXSAmIDEpIHRocm93IHRbMV07XG4gICAgICAgIHJldHVybiB0WzFdO1xuICAgICAgfSxcbiAgICAgIHRyeXM6IFtdLFxuICAgICAgb3BzOiBbXVxuICAgIH0sXG4gICAgZixcbiAgICB5LFxuICAgIHQsXG4gICAgZztcbiAgcmV0dXJuIGcgPSB7XG4gICAgbmV4dDogdmVyYigwKSxcbiAgICBcInRocm93XCI6IHZlcmIoMSksXG4gICAgXCJyZXR1cm5cIjogdmVyYigyKVxuICB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSksIGc7XG4gIGZ1bmN0aW9uIHZlcmIobikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodikge1xuICAgICAgcmV0dXJuIHN0ZXAoW24sIHZdKTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgd2hpbGUgKGcgJiYgKGcgPSAwLCBvcFswXSAmJiAoXyA9IDApKSwgXykgdHJ5IHtcbiAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgdCA9IG9wO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgXy5sYWJlbCsrO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogb3BbMV0sXG4gICAgICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICBfLmxhYmVsKys7XG4gICAgICAgICAgeSA9IG9wWzFdO1xuICAgICAgICAgIG9wID0gWzBdO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgb3AgPSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICBfLnRyeXMucG9wKCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHtcbiAgICAgICAgICAgIF8gPSAwO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgb3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpIHtcbiAgICAgICAgICAgIF8ubGFiZWwgPSBvcFsxXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHtcbiAgICAgICAgICAgIF8ubGFiZWwgPSB0WzFdO1xuICAgICAgICAgICAgdCA9IG9wO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7XG4gICAgICAgICAgICBfLmxhYmVsID0gdFsyXTtcbiAgICAgICAgICAgIF8ub3BzLnB1c2gob3ApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICBfLnRyeXMucG9wKCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBvcCA9IFs2LCBlXTtcbiAgICAgIHkgPSAwO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBmID0gdCA9IDA7XG4gICAgfVxuICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdO1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCxcbiAgICAgIGRvbmU6IHRydWVcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBfX3NwcmVhZEFycmF5KHRvLCBmcm9tLCBwYWNrKSB7XG4gIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xuICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcbiAgICAgIGFyW2ldID0gZnJvbVtpXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XG59XG5cbnZhciBERUZBVUxUX1BST1BTID0ge1xuICB2aWV3cG9ydFRhZzogXCJkaXZcIixcbiAgY2FtZXJhVGFnOiBcImRpdlwiLFxuICBjYW1lcmFDbGFzczogXCJcIixcbiAgcmVuZGVyT25TYW1lS2V5OiBmYWxzZSxcbiAgcGx1Z2luczogW10sXG4gIHVzZUZpbmRET01Ob2RlOiBmYWxzZSxcbiAgaGlkZUJlZm9yZUluaXQ6IGZhbHNlLFxuICBvblJlYWR5OiBmdW5jdGlvbiAoZSkge30sXG4gIG9uQmVmb3JlUmVzaXplOiBmdW5jdGlvbiAoZSkge30sXG4gIG9uQWZ0ZXJSZXNpemU6IGZ1bmN0aW9uIChlKSB7fSxcbiAgb25Ib2xkU3RhcnQ6IGZ1bmN0aW9uIChlKSB7fSxcbiAgb25Ib2xkRW5kOiBmdW5jdGlvbiAoZSkge30sXG4gIG9uTW92ZVN0YXJ0OiBmdW5jdGlvbiAoZSkge30sXG4gIG9uTW92ZTogZnVuY3Rpb24gKGUpIHt9LFxuICBvbk1vdmVFbmQ6IGZ1bmN0aW9uIChlKSB7fSxcbiAgb25XaWxsQ2hhbmdlOiBmdW5jdGlvbiAoZSkge30sXG4gIG9uQ2hhbmdlZDogZnVuY3Rpb24gKGUpIHt9LFxuICBvbldpbGxSZXN0b3JlOiBmdW5jdGlvbiAoZSkge30sXG4gIG9uUmVzdG9yZWQ6IGZ1bmN0aW9uIChlKSB7fSxcbiAgb25TZWxlY3Q6IGZ1bmN0aW9uIChlKSB7fSxcbiAgb25OZWVkUGFuZWw6IGZ1bmN0aW9uIChlKSB7fSxcbiAgb25WaXNpYmxlQ2hhbmdlOiBmdW5jdGlvbiAoZSkge30sXG4gIG9uUmVhY2hFZGdlOiBmdW5jdGlvbiAoZSkge30sXG4gIG9uUGFuZWxDaGFuZ2U6IGZ1bmN0aW9uIChlKSB7fVxufTtcblxudmFyIFJlYWN0UmVuZGVyZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMkNChSZWFjdFJlbmRlcmVyLCBfc3VwZXIpO1xuICBmdW5jdGlvbiBSZWFjdFJlbmRlcmVyKG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zKSB8fCB0aGlzO1xuICAgIF90aGlzLl9yZWFjdEZsaWNraW5nID0gb3B0aW9ucy5yZWFjdEZsaWNraW5nO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3JlcXVpcmUtYXdhaXRcbiAgdmFyIF9fcHJvdG8gPSBSZWFjdFJlbmRlcmVyLnByb3RvdHlwZTtcbiAgX19wcm90by5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZmxpY2tpbmcsIHJlYWN0RmxpY2tpbmcsIHN0cmF0ZWd5O1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIHJldHVybiBfX2dlbmVyYXRvciQxKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBmbGlja2luZyA9IGdldEZsaWNraW5nQXR0YWNoZWQodGhpcy5fZmxpY2tpbmcpO1xuICAgICAgICByZWFjdEZsaWNraW5nID0gdGhpcy5fcmVhY3RGbGlja2luZztcbiAgICAgICAgc3RyYXRlZ3kgPSB0aGlzLl9zdHJhdGVneTtcbiAgICAgICAgdGhpcy5fcmVuZGVyaW5nID0gdHJ1ZTtcbiAgICAgICAgc3RyYXRlZ3kudXBkYXRlUmVuZGVyaW5nUGFuZWxzKGZsaWNraW5nKTtcbiAgICAgICAgc3RyYXRlZ3kucmVuZGVyUGFuZWxzKGZsaWNraW5nKTtcbiAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgcmVhY3RGbGlja2luZy5yZW5kZXJFbWl0dGVyLm9uY2UoXCJyZW5kZXJcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuX3JlbmRlcmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgX3RoaXMuX2FmdGVyUmVuZGVyKCk7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmVhY3RGbGlja2luZy5mb3JjZVVwZGF0ZSgpO1xuICAgICAgICB9KV07XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbiAgX19wcm90by5mb3JjZVJlbmRlckFsbFBhbmVscyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciByZWFjdEZsaWNraW5nO1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIHJldHVybiBfX2dlbmVyYXRvciQxKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgcmVhY3RGbGlja2luZyA9IHRoaXMuX3JlYWN0RmxpY2tpbmc7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJpbmcgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgX3N1cGVyLnByb3RvdHlwZS5mb3JjZVJlbmRlckFsbFBhbmVscy5jYWxsKHRoaXMpXTtcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgcmVhY3RGbGlja2luZy5yZW5kZXJFbWl0dGVyLm9uY2UoXCJyZW5kZXJcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9yZW5kZXJpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICByZWFjdEZsaWNraW5nLmZvcmNlVXBkYXRlKCk7XG4gICAgICAgICAgICB9KV07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuICBfX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgX3N1cGVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gICAgdGhpcy5fcmVhY3RGbGlja2luZy5yZW5kZXJFbWl0dGVyLm9mZihcInJlbmRlclwiKTtcbiAgfTtcbiAgX19wcm90by5fY29sbGVjdFBhbmVscyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZmxpY2tpbmcgPSBnZXRGbGlja2luZ0F0dGFjaGVkKHRoaXMuX2ZsaWNraW5nKTtcbiAgICB2YXIgcmVhY3RGbGlja2luZyA9IHRoaXMuX3JlYWN0RmxpY2tpbmc7XG4gICAgdmFyIHJlYWN0UGFuZWxzID0gcmVhY3RGbGlja2luZy5yZWFjdFBhbmVscztcbiAgICB0aGlzLl9wYW5lbHMgPSB0aGlzLl9zdHJhdGVneS5jb2xsZWN0UGFuZWxzKGZsaWNraW5nLCByZWFjdFBhbmVscyk7XG4gIH07XG4gIF9fcHJvdG8uX2NyZWF0ZVBhbmVsID0gZnVuY3Rpb24gKGV4dGVybmFsQ29tcG9uZW50LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0cmF0ZWd5LmNyZWF0ZVBhbmVsKGV4dGVybmFsQ29tcG9uZW50LCBvcHRpb25zKTtcbiAgfTtcbiAgcmV0dXJuIFJlYWN0UmVuZGVyZXI7XG59KEV4dGVybmFsUmVuZGVyZXIpO1xuXG52YXIgU3RyaWN0UGFuZWwgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMkNChTdHJpY3RQYW5lbCwgX3N1cGVyKTtcbiAgZnVuY3Rpb24gU3RyaWN0UGFuZWwoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgX3RoaXMuX2hpZGUgPSBmYWxzZTtcbiAgICBfdGhpcy5fZWxSZWYgPSBjcmVhdGVSZWYoKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgdmFyIF9fcHJvdG8gPSBTdHJpY3RQYW5lbC5wcm90b3R5cGU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcIm5hdGl2ZUVsZW1lbnRcIiwge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2VsUmVmLmN1cnJlbnQ7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcInJlbmRlcmVkXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAhdGhpcy5faGlkZTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgX19wcm90by5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hpZGUgPyBjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsKSA6IHRoaXMuX2dldEVsZW1lbnQoKTtcbiAgfTtcbiAgX19wcm90by5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2hpZGUgPSBmYWxzZTtcbiAgfTtcbiAgX19wcm90by5oaWRlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2hpZGUgPSB0cnVlO1xuICB9O1xuICBfX3Byb3RvLl9nZXRFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBybihrJDEub25seSh0aGlzLnByb3BzLmNoaWxkcmVuKSwge1xuICAgICAgcmVmOiB0aGlzLl9lbFJlZlxuICAgIH0pO1xuICB9O1xuICByZXR1cm4gU3RyaWN0UGFuZWw7XG59KENvbXBvbmVudCQxKTtcblxudmFyIE5vblN0cmljdFBhbmVsID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzJDQoTm9uU3RyaWN0UGFuZWwsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIE5vblN0cmljdFBhbmVsKCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIF90aGlzLl9oaWRlID0gZmFsc2U7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIHZhciBfX3Byb3RvID0gTm9uU3RyaWN0UGFuZWwucHJvdG90eXBlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJuYXRpdmVFbGVtZW50XCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBvbih0aGlzKTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwicmVuZGVyZWRcIiwge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICF0aGlzLl9oaWRlO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBfX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5faGlkZSA/IGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIG51bGwpIDogdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgfTtcbiAgX19wcm90by5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2hpZGUgPSBmYWxzZTtcbiAgfTtcbiAgX19wcm90by5oaWRlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2hpZGUgPSB0cnVlO1xuICB9O1xuICByZXR1cm4gTm9uU3RyaWN0UGFuZWw7XG59KENvbXBvbmVudCQxKTtcblxuLypcbiAqIENvcHlyaWdodCAoYykgMjAxNSBOQVZFUiBDb3JwLlxuICogZWdqcyBwcm9qZWN0cyBhcmUgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbnZhciBWaWV3cG9ydFNsb3QgPSBSZWFjdF9fZGVmYXVsdC5tZW1vKGZ1bmN0aW9uIChwcm9wcykge1xuICByZXR1cm4gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChSZWFjdF9fZGVmYXVsdC5GcmFnbWVudCwgbnVsbCwgcHJvcHMuY2hpbGRyZW4pO1xufSk7XG5cbnZhciBSZWFjdEVsZW1lbnRQcm92aWRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFJlYWN0RWxlbWVudFByb3ZpZGVyKGVsKSB7XG4gICAgdGhpcy5fZWwgPSBlbDtcbiAgfVxuICB2YXIgX19wcm90byA9IFJlYWN0RWxlbWVudFByb3ZpZGVyLnByb3RvdHlwZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwiZWxlbWVudFwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZWwubmF0aXZlRWxlbWVudDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwicmVuZGVyZWRcIiwge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2VsLnJlbmRlcmVkO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBfX3Byb3RvLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fZWwuc2hvdygpO1xuICB9O1xuICBfX3Byb3RvLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fZWwuaGlkZSgpO1xuICB9O1xuICByZXR1cm4gUmVhY3RFbGVtZW50UHJvdmlkZXI7XG59KCk7XG5cbnZhciBGbGlja2luZyQxID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzJDQoRmxpY2tpbmckMSwgX3N1cGVyKTtcbiAgZnVuY3Rpb24gRmxpY2tpbmckMShwcm9wcykge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzO1xuICAgIF90aGlzLl9wYW5lbHMgPSBbXTtcbiAgICBfdGhpcy5fcmVuZGVyRW1pdHRlciA9IG5ldyBDb21wb25lbnQoKTtcbiAgICB2YXIgY2hpbGRyZW4gPSBfdGhpcy5fZ2V0Q2hpbGRyZW4oKTtcbiAgICBfdGhpcy5fcGFuZWxzID0gX3RoaXMuX2NyZWF0ZVBhbmVsUmVmcyhwcm9wcywgY2hpbGRyZW4pO1xuICAgIF90aGlzLl9wcmV2Q2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgdmFyIF9fcHJvdG8gPSBGbGlja2luZyQxLnByb3RvdHlwZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwicmVhY3RQYW5lbHNcIiwge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3BhbmVscy5tYXAoZnVuY3Rpb24gKHBhbmVsKSB7XG4gICAgICAgIHJldHVybiBwYW5lbC5jdXJyZW50O1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcInJlbmRlckVtaXR0ZXJcIiwge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlckVtaXR0ZXI7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIF9fcHJvdG8uY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgcmVuZGVyZXJPcHRpb25zID0ge1xuICAgICAgcmVhY3RGbGlja2luZzogdGhpcyxcbiAgICAgIGFsaWduOiBwcm9wcy5hbGlnbixcbiAgICAgIHN0cmF0ZWd5OiBwcm9wcy52aXJ0dWFsICYmIHByb3BzLnBhbmVsc1BlclZpZXcgPiAwID8gbmV3IFZpcnR1YWxSZW5kZXJpbmdTdHJhdGVneSgpIDogbmV3IE5vcm1hbFJlbmRlcmluZ1N0cmF0ZWd5KHtcbiAgICAgICAgcHJvdmlkZXJDdG9yOiBSZWFjdEVsZW1lbnRQcm92aWRlclxuICAgICAgfSlcbiAgICB9O1xuICAgIHZhciBmbGlja2luZyA9IG5ldyBGbGlja2luZyh0aGlzLl92aWV3cG9ydEVsZW1lbnQsIF9fYXNzaWduJDMoX19hc3NpZ24kMyh7fSwgcHJvcHMpLCB7XG4gICAgICBleHRlcm5hbFJlbmRlcmVyOiBuZXcgUmVhY3RSZW5kZXJlcihyZW5kZXJlck9wdGlvbnMpXG4gICAgfSkpO1xuICAgIHRoaXMuX3ZhbmlsbGFGbGlja2luZyA9IGZsaWNraW5nO1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2dldENoaWxkcmVuKCk7XG4gICAgdGhpcy5fanN4RGlmZmVyID0gbmV3IExpc3REaWZmZXIoY2hpbGRyZW4sIGZ1bmN0aW9uIChwYW5lbCkge1xuICAgICAgcmV0dXJuIHBhbmVsLmtleTtcbiAgICB9KTtcbiAgICB0aGlzLl9wbHVnaW5zRGlmZmVyID0gbmV3IExpc3REaWZmZXIoKTtcbiAgICB0aGlzLl9wcmV2Q2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICB0aGlzLl9iaW5kRXZlbnRzKCk7XG4gICAgdGhpcy5fY2hlY2tQbHVnaW5zKCk7XG4gICAgaWYgKHByb3BzLnN0YXR1cykge1xuICAgICAgZmxpY2tpbmcuc2V0U3RhdHVzKHByb3BzLnN0YXR1cyk7XG4gICAgfVxuICB9O1xuICBfX3Byb3RvLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfYTtcbiAgICAoX2EgPSB0aGlzLl92YW5pbGxhRmxpY2tpbmcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZXN0cm95KCk7XG4gIH07XG4gIF9fcHJvdG8uc2hvdWxkQ29tcG9uZW50VXBkYXRlID0gZnVuY3Rpb24gKG5leHRQcm9wcykge1xuICAgIHZhciB2YW5pbGxhRmxpY2tpbmcgPSB0aGlzLl92YW5pbGxhRmxpY2tpbmc7XG4gICAgdmFyIHByZXZQcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgaWYgKCF2YW5pbGxhRmxpY2tpbmcgfHwgIXZhbmlsbGFGbGlja2luZy5pbml0aWFsaXplZCkgcmV0dXJuIGZhbHNlO1xuICAgIHZhciBjaGlsZHJlbiA9IG5leHRQcm9wcy5jaGlsZHJlbixcbiAgICAgIHJlc3RQcm9wcyA9IF9fcmVzdChuZXh0UHJvcHMsIFtcImNoaWxkcmVuXCJdKTtcbiAgICBmb3IgKHZhciBrZXkgaW4gcmVzdFByb3BzKSB7XG4gICAgICBpZiAocHJldlByb3BzW2tleV0gIT09IG5leHRQcm9wc1trZXldKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgcHJldkNoaWxkcmVuID0gdGhpcy5fcHJldkNoaWxkcmVuO1xuICAgIHZhciBuZXh0Q2hpbGRyZW4gPSB0aGlzLl9nZXRDaGlsZHJlbihjaGlsZHJlbik7XG4gICAgaWYgKG5leHRQcm9wcy5yZW5kZXJPblNhbWVLZXkgfHwgIXRoaXMuX2hhc1NhbWVDaGlsZHJlbihwcmV2Q2hpbGRyZW4sIG5leHRDaGlsZHJlbikpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbiAgX19wcm90by5iZWZvcmVSZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZhbmlsbGFGbGlja2luZyA9IHRoaXMuX3ZhbmlsbGFGbGlja2luZztcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBwcmV2Q2hpbGRyZW4gPSB0aGlzLl9wcmV2Q2hpbGRyZW47XG4gICAgLy8gSWdub3JlIHVwZGF0ZXMgYmVmb3JlIGluaXQsIHRoZXkgd2lsbCBiZSB1cGRhdGVkIGFmdGVyIFwicmVhZHlcIiBldmVudCdzIGZvcmNlIHVwZGF0ZVxuICAgIC8vIEFsc28sIHByZXZlbnQgdXBkYXRlcyB3aGVuIGFub3RoZXIgdXBkYXRlIGlzIGFscmVhZHkgcXVldWVkLlxuICAgIC8vIFRoaXMgdXN1YWxseSBoYXBwZW5zIHdoZW4gcmVuZGVyKCkgY2FsbGVkIHR3aWNlIHdpdGhvdXQgY2FsbGluZyBjb21wb25lbnREaWRNb3VudCwgbGlrZSBpbiB0aGUgY2FzZSBvZiBSZWFjdC5TdHJpY3RNb2RlLlxuICAgIGlmICghdmFuaWxsYUZsaWNraW5nIHx8ICF2YW5pbGxhRmxpY2tpbmcuaW5pdGlhbGl6ZWQgfHwgdGhpcy5fZGlmZlJlc3VsdCkgcmV0dXJuO1xuICAgIHZhciBuZXh0Q2hpbGRyZW4gPSB0aGlzLl9nZXRDaGlsZHJlbihwcm9wcy5jaGlsZHJlbik7XG4gICAgaWYgKHByb3BzLnJlbmRlck9uU2FtZUtleSB8fCAhdGhpcy5faGFzU2FtZUNoaWxkcmVuKHByZXZDaGlsZHJlbiwgbmV4dENoaWxkcmVuKSkge1xuICAgICAgdGhpcy5fcGFuZWxzID0gdGhpcy5fY3JlYXRlUGFuZWxSZWZzKHByb3BzLCBuZXh0Q2hpbGRyZW4pO1xuICAgICAgdGhpcy5fZGlmZlJlc3VsdCA9IHRoaXMuX2pzeERpZmZlci51cGRhdGUobmV4dENoaWxkcmVuKTtcbiAgICAgIHRoaXMuX3ByZXZDaGlsZHJlbiA9IG5leHRDaGlsZHJlbjtcbiAgICB9XG4gIH07XG4gIF9fcHJvdG8uY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBmbGlja2luZyA9IHRoaXMuX3ZhbmlsbGFGbGlja2luZztcbiAgICB2YXIgcmVuZGVyRW1pdHRlciA9IHRoaXMuX3JlbmRlckVtaXR0ZXI7XG4gICAgdmFyIGRpZmZSZXN1bHQgPSB0aGlzLl9kaWZmUmVzdWx0O1xuICAgIHRoaXMuX2NoZWNrUGx1Z2lucygpO1xuICAgIHJlbmRlckVtaXR0ZXIudHJpZ2dlcihcInJlbmRlclwiKTtcbiAgICBmbGlja2luZy5jYW1lcmEudXBkYXRlT2Zmc2V0KCk7XG4gICAgLy8gT21pdCAndmlydHVhbCcsIGFzIGl0IGNhbid0IGhhdmUgYW55IHNldHRlclxuICAgIHZhciBfYSA9IHRoaXMucHJvcHM7XG4gICAgICBfYS52aXJ0dWFsO1xuICAgICAgdmFyIHByb3BzID0gX19yZXN0KF9hLCBbXCJ2aXJ0dWFsXCJdKTtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICAgIGlmIChrZXkgaW4gZmxpY2tpbmcgJiYgZmxpY2tpbmdba2V5XSAhPT0gcHJvcHNba2V5XSkge1xuICAgICAgICBmbGlja2luZ1trZXldID0gcHJvcHNba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFkaWZmUmVzdWx0IHx8ICFmbGlja2luZy5pbml0aWFsaXplZCkgcmV0dXJuO1xuICAgIHN5bmMoZmxpY2tpbmcsIGRpZmZSZXN1bHQsIHRoaXMucmVhY3RQYW5lbHMpO1xuICAgIHRoaXMuX2RpZmZSZXN1bHQgPSBudWxsO1xuICB9O1xuICBfX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHZhciBfYSwgX2I7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgVmlld3BvcnQgPSBwcm9wcy52aWV3cG9ydFRhZztcbiAgICB2YXIgQ2FtZXJhID0gcHJvcHMuY2FtZXJhVGFnO1xuICAgIHZhciBhdHRyaWJ1dGVzID0ge307XG4gICAgdmFyIGZsaWNraW5nID0gdGhpcy5fdmFuaWxsYUZsaWNraW5nO1xuICAgIHRoaXMuYmVmb3JlUmVuZGVyKCk7XG4gICAgZm9yICh2YXIgbmFtZSBpbiBwcm9wcykge1xuICAgICAgaWYgKCEobmFtZSBpbiBERUZBVUxUX1BST1BTKSAmJiAhKG5hbWUgaW4gRmxpY2tpbmcucHJvdG90eXBlKSkge1xuICAgICAgICBhdHRyaWJ1dGVzW25hbWVdID0gcHJvcHNbbmFtZV07XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBpbml0aWFsaXplZCA9IGZsaWNraW5nICYmIGZsaWNraW5nLmluaXRpYWxpemVkO1xuICAgIHZhciB2aWV3cG9ydENsYXNzZXMgPSBbXCJmbGlja2luZy12aWV3cG9ydFwiXTtcbiAgICB2YXIgY2FtZXJhQ2xhc3NlcyA9IFtcImZsaWNraW5nLWNhbWVyYVwiXTtcbiAgICB2YXIgaXNIb3Jpem9udGFsID0gZmxpY2tpbmcgPyBmbGlja2luZy5ob3Jpem9udGFsIDogKF9hID0gcHJvcHMuaG9yaXpvbnRhbCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdHJ1ZTtcbiAgICBpZiAoIWlzSG9yaXpvbnRhbCkge1xuICAgICAgdmlld3BvcnRDbGFzc2VzLnB1c2goXCJ2ZXJ0aWNhbFwiKTtcbiAgICB9XG4gICAgaWYgKHByb3BzLmhpZGVCZWZvcmVJbml0ICYmICFpbml0aWFsaXplZCkge1xuICAgICAgdmlld3BvcnRDbGFzc2VzLnB1c2goXCJmbGlja2luZy1oaWRkZW5cIik7XG4gICAgfVxuICAgIGlmIChhdHRyaWJ1dGVzLmNsYXNzTmFtZSkge1xuICAgICAgdmlld3BvcnRDbGFzc2VzLnB1c2goYXR0cmlidXRlcy5jbGFzc05hbWUpO1xuICAgIH1cbiAgICBpZiAocHJvcHMuY2FtZXJhQ2xhc3MpIHtcbiAgICAgIGNhbWVyYUNsYXNzZXMucHVzaChwcm9wcy5jYW1lcmFDbGFzcyk7XG4gICAgfVxuICAgIHZhciBjYW1lcmFQcm9wcyA9ICFpbml0aWFsaXplZCAmJiBwcm9wcy5maXJzdFBhbmVsU2l6ZSA/IHtcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIHRyYW5zZm9ybTogZ2V0RGVmYXVsdENhbWVyYVRyYW5zZm9ybSh0aGlzLnByb3BzLmFsaWduLCB0aGlzLnByb3BzLmhvcml6b250YWwsIHRoaXMucHJvcHMuZmlyc3RQYW5lbFNpemUpXG4gICAgICB9XG4gICAgfSA6IHt9O1xuICAgIHZhciBwYW5lbHMgPSAhIXByb3BzLnZpcnR1YWwgJiYgKChfYiA9IHByb3BzLnBhbmVsc1BlclZpZXcpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IC0xKSA+IDAgPyB0aGlzLl9nZXRWaXJ0dWFsUGFuZWxzKCkgOiB0aGlzLl9nZXRQYW5lbHMoKTtcbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudChWaWV3cG9ydCwgX19hc3NpZ24kMyh7fSwgYXR0cmlidXRlcywge1xuICAgICAgY2xhc3NOYW1lOiB2aWV3cG9ydENsYXNzZXMuam9pbihcIiBcIiksXG4gICAgICByZWY6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUgJiYgKF90aGlzLl92aWV3cG9ydEVsZW1lbnQgPSBlKTtcbiAgICAgIH1cbiAgICB9KSwgY3JlYXRlRWxlbWVudChDYW1lcmEsIF9fYXNzaWduJDMoe1xuICAgICAgY2xhc3NOYW1lOiBjYW1lcmFDbGFzc2VzLmpvaW4oXCIgXCIpXG4gICAgfSwgY2FtZXJhUHJvcHMpLCBwYW5lbHMpLCB0aGlzLl9nZXRWaWV3cG9ydFNsb3QoKSk7XG4gIH07XG4gIF9fcHJvdG8uX2NyZWF0ZVBhbmVsUmVmcyA9IGZ1bmN0aW9uIChwcm9wcywgY2hpbGRyZW4pIHtcbiAgICB2YXIgX2E7XG4gICAgdmFyIHBhbmVsc1BlclZpZXcgPSAoX2EgPSBwcm9wcy5wYW5lbHNQZXJWaWV3KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAtMTtcbiAgICByZXR1cm4gcGFuZWxzUGVyVmlldyA+IDAgJiYgISFwcm9wcy52aXJ0dWFsID8gcmFuZ2UocGFuZWxzUGVyVmlldyArIDEpLm1hcChmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gY3JlYXRlUmVmKCk7XG4gICAgfSkgOiBjaGlsZHJlbi5tYXAoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZVJlZigpO1xuICAgIH0pO1xuICB9O1xuICBfX3Byb3RvLl9iaW5kRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIGZsaWNraW5nID0gdGhpcy5fdmFuaWxsYUZsaWNraW5nO1xuICAgIE9iamVjdC5rZXlzKEVWRU5UUykuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnRLZXkpIHtcbiAgICAgIHZhciBldmVudE5hbWUgPSBFVkVOVFNbZXZlbnRLZXldO1xuICAgICAgdmFyIHByb3BOYW1lID0gXCJvblwiLmNvbmNhdChldmVudE5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBldmVudE5hbWUuc2xpY2UoMSkpO1xuICAgICAgZmxpY2tpbmcub24oZXZlbnROYW1lLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBlLmN1cnJlbnRUYXJnZXQgPSBfdGhpcztcbiAgICAgICAgdmFyIGV2dEhhbmRsZXIgPSBfdGhpcy5wcm9wc1twcm9wTmFtZV07XG4gICAgICAgIGV2dEhhbmRsZXIoZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBmbGlja2luZy5vbmNlKEVWRU5UUy5SRUFEWSwgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuZm9yY2VVcGRhdGUoKTtcbiAgICB9KTtcbiAgfTtcbiAgX19wcm90by5fY2hlY2tQbHVnaW5zID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBmbGlja2luZyA9IHRoaXMuX3ZhbmlsbGFGbGlja2luZztcbiAgICB2YXIgX2EgPSB0aGlzLl9wbHVnaW5zRGlmZmVyLnVwZGF0ZSh0aGlzLnByb3BzLnBsdWdpbnMpLFxuICAgICAgbGlzdCA9IF9hLmxpc3QsXG4gICAgICBhZGRlZCA9IF9hLmFkZGVkLFxuICAgICAgcmVtb3ZlZCA9IF9hLnJlbW92ZWQsXG4gICAgICBwcmV2TGlzdCA9IF9hLnByZXZMaXN0O1xuICAgIGZsaWNraW5nLmFkZFBsdWdpbnMuYXBwbHkoZmxpY2tpbmcsIGFkZGVkLm1hcChmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgIHJldHVybiBsaXN0W2luZGV4XTtcbiAgICB9KSk7XG4gICAgZmxpY2tpbmcucmVtb3ZlUGx1Z2lucy5hcHBseShmbGlja2luZywgcmVtb3ZlZC5tYXAoZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICByZXR1cm4gcHJldkxpc3RbaW5kZXhdO1xuICAgIH0pKTtcbiAgfTtcbiAgX19wcm90by5faGFzU2FtZUNoaWxkcmVuID0gZnVuY3Rpb24gKHByZXZDaGlsZHJlbiwgbmV4dENoaWxkcmVuKSB7XG4gICAgaWYgKHByZXZDaGlsZHJlbi5sZW5ndGggIT09IG5leHRDaGlsZHJlbi5sZW5ndGggfHwgcHJldkNoaWxkcmVuLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGZhbHNlO1xuICAgIHZhciBzYW1lID0gcHJldkNoaWxkcmVuLmV2ZXJ5KGZ1bmN0aW9uIChjaGlsZCwgaWR4KSB7XG4gICAgICB2YXIgbmV4dENoaWxkID0gbmV4dENoaWxkcmVuW2lkeF07XG4gICAgICBpZiAoY2hpbGQua2V5ICYmIG5leHRDaGlsZC5rZXkpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkLmtleSA9PT0gbmV4dENoaWxkLmtleTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjaGlsZCA9PT0gbmV4dENoaWxkO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBzYW1lO1xuICB9O1xuICBfX3Byb3RvLl9nZXRDaGlsZHJlbiA9IGZ1bmN0aW9uIChjaGlsZHJlbikge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgaWYgKGNoaWxkcmVuID09PSB2b2lkIDApIHtcbiAgICAgIGNoaWxkcmVuID0gdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgICB9XG4gICAgcmV0dXJuIGskMS50b0FycmF5KGNoaWxkcmVuKS5maWx0ZXIoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICByZXR1cm4gY2hpbGQudHlwZSAhPT0gVmlld3BvcnRTbG90O1xuICAgIH0pLnJlZHVjZShmdW5jdGlvbiAoYWxsLCBjaGlsZCkge1xuICAgICAgcmV0dXJuIF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgYWxsLCB0cnVlKSwgX3RoaXMuX3VucGFja0ZyYWdtZW50KGNoaWxkKSwgdHJ1ZSk7XG4gICAgfSwgW10pO1xuICB9O1xuICBfX3Byb3RvLl9nZXRWaWV3cG9ydFNsb3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGskMS50b0FycmF5KHRoaXMucHJvcHMuY2hpbGRyZW4pLmZpbHRlcihmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgIHJldHVybiBjaGlsZC50eXBlID09PSBWaWV3cG9ydFNsb3Q7XG4gICAgfSk7XG4gIH07XG4gIF9fcHJvdG8uX3VucGFja0ZyYWdtZW50ID0gZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICByZXR1cm4gdGhpcy5faXNGcmFnbWVudChjaGlsZCkgPyBrJDEudG9BcnJheShjaGlsZC5wcm9wcy5jaGlsZHJlbikucmVkdWNlKGZ1bmN0aW9uIChhbGxDaGlsZHMsIGZyYWdDaGlsZCkge1xuICAgICAgcmV0dXJuIF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgYWxsQ2hpbGRzLCB0cnVlKSwgX3RoaXMuX3VucGFja0ZyYWdtZW50KGZyYWdDaGlsZCksIHRydWUpO1xuICAgIH0sIFtdKSA6IFtjaGlsZF07XG4gIH07XG4gIF9fcHJvdG8uX2dldFZpcnR1YWxQYW5lbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB2YXIgX2EgPSB0aGlzLnByb3BzLnZpcnR1YWwucGFuZWxDbGFzcyxcbiAgICAgIHBhbmVsQ2xhc3MgPSBfYSA9PT0gdm9pZCAwID8gXCJmbGlja2luZy1wYW5lbFwiIDogX2E7XG4gICAgdmFyIHBhbmVsc1BlclZpZXcgPSB0aGlzLnByb3BzLnBhbmVsc1BlclZpZXc7XG4gICAgdmFyIGZsaWNraW5nID0gdGhpcy5fdmFuaWxsYUZsaWNraW5nO1xuICAgIHZhciBpbml0aWFsaXplZCA9IGZsaWNraW5nICYmIGZsaWNraW5nLmluaXRpYWxpemVkO1xuICAgIHZhciByZW5kZXJpbmdJbmRleGVzID0gaW5pdGlhbGl6ZWQgPyBmbGlja2luZy5yZW5kZXJlci5zdHJhdGVneS5nZXRSZW5kZXJpbmdJbmRleGVzQnlPcmRlcihmbGlja2luZykgOiByYW5nZShwYW5lbHNQZXJWaWV3ICsgMSk7XG4gICAgdmFyIGZpcnN0UGFuZWwgPSBmbGlja2luZyAmJiBmbGlja2luZy5wYW5lbHNbMF07XG4gICAgdmFyIHNpemUgPSBmaXJzdFBhbmVsID8gZmxpY2tpbmcuaG9yaXpvbnRhbCA/IHtcbiAgICAgIHdpZHRoOiBmaXJzdFBhbmVsLnNpemVcbiAgICB9IDoge1xuICAgICAgaGVpZ2h0OiBmaXJzdFBhbmVsLnNpemVcbiAgICB9IDoge307XG4gICAgcmV0dXJuIHJlbmRlcmluZ0luZGV4ZXMubWFwKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAga2V5OiBpZHgsXG4gICAgICAgIFwiZGF0YS1lbGVtZW50LWluZGV4XCI6IGlkeCxcbiAgICAgICAgcmVmOiBfdGhpcy5fcGFuZWxzW2lkeF0sXG4gICAgICAgIGNsYXNzTmFtZTogcGFuZWxDbGFzcyxcbiAgICAgICAgc3R5bGU6IHNpemVcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuICBfX3Byb3RvLl9nZXRQYW5lbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB2YXIgb3JpZ0NoaWxkcmVuID0gdGhpcy5fZ2V0Q2hpbGRyZW4oKTtcbiAgICB2YXIgdmFuaWxsYUZsaWNraW5nID0gdGhpcy5fdmFuaWxsYUZsaWNraW5nO1xuICAgIHZhciBkaWZmUmVzdWx0ID0gdGhpcy5fZGlmZlJlc3VsdDtcbiAgICB2YXIgY2hpbGRyZW4gPSB2YW5pbGxhRmxpY2tpbmcgJiYgdmFuaWxsYUZsaWNraW5nLmluaXRpYWxpemVkID8gZGlmZlJlc3VsdCA/IGdldFJlbmRlcmluZ1BhbmVscyh2YW5pbGxhRmxpY2tpbmcsIGRpZmZSZXN1bHQpIDogZ2V0UmVuZGVyaW5nUGFuZWxzKHZhbmlsbGFGbGlja2luZywgZGlmZihvcmlnQ2hpbGRyZW4sIG9yaWdDaGlsZHJlbikpIDogb3JpZ0NoaWxkcmVuO1xuICAgIHJldHVybiB0aGlzLnByb3BzLnVzZUZpbmRET01Ob2RlID8gY2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChjaGlsZCwgaWR4KSB7XG4gICAgICByZXR1cm4gY3JlYXRlRWxlbWVudChOb25TdHJpY3RQYW5lbCwge1xuICAgICAgICBrZXk6IGNoaWxkLmtleSxcbiAgICAgICAgcmVmOiBfdGhpcy5fcGFuZWxzW2lkeF1cbiAgICAgIH0sIGNoaWxkKTtcbiAgICB9KSA6IGNoaWxkcmVuLm1hcChmdW5jdGlvbiAoY2hpbGQsIGlkeCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoU3RyaWN0UGFuZWwsIHtcbiAgICAgICAga2V5OiBjaGlsZC5rZXksXG4gICAgICAgIHJlZjogX3RoaXMuX3BhbmVsc1tpZHhdXG4gICAgICB9LCBjaGlsZCk7XG4gICAgfSk7XG4gIH07XG4gIF9fcHJvdG8uX2lzRnJhZ21lbnQgPSBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQudHlwZSkge1xuICAgICAgcmV0dXJuIGNoaWxkLnR5cGUgPT09IEZyYWdtZW50O1xuICAgIH1cbiAgICByZXR1cm4gY2hpbGQgPT09IEZyYWdtZW50O1xuICB9O1xuICBGbGlja2luZyQxLmRlZmF1bHRQcm9wcyA9IERFRkFVTFRfUFJPUFM7XG4gIF9fZGVjb3JhdGUkMShbd2l0aEZsaWNraW5nTWV0aG9kc10sIEZsaWNraW5nJDEucHJvdG90eXBlLCBcIl92YW5pbGxhRmxpY2tpbmdcIiwgdm9pZCAwKTtcbiAgcmV0dXJuIEZsaWNraW5nJDE7XG59KENvbXBvbmVudCQxKTtcblxuZXhwb3J0IGRlZmF1bHQgRmxpY2tpbmckMTtcbmV4cG9ydCB7IEFMSUdOLCBBbmNob3JQb2ludCwgQW5pbWF0aW5nU3RhdGUsIEF4ZXNDb250cm9sbGVyLCBCb3VuZENhbWVyYU1vZGUsIENJUkNVTEFSX0ZBTExCQUNLLCBDTEFTUywgQ2FtZXJhLCBDaXJjdWxhckNhbWVyYU1vZGUsIENvbnRyb2wsIERJUkVDVElPTiwgRGlzYWJsZWRTdGF0ZSwgRHJhZ2dpbmdTdGF0ZSwgQ09ERSBhcyBFUlJPUl9DT0RFLCBFVkVOVFMsIEV4dGVybmFsUmVuZGVyZXIsIEZsaWNraW5nRXJyb3IsIEZyZWVDb250cm9sLCBIb2xkaW5nU3RhdGUsIElkbGVTdGF0ZSwgTGluZWFyQ2FtZXJhTW9kZSwgTU9WRV9UWVBFLCBOb3JtYWxSZW5kZXJpbmdTdHJhdGVneSwgT1JERVIsIFBhbmVsLCBSZW5kZXJlciwgU25hcENvbnRyb2wsIFN0YXRlLCBTdGF0ZU1hY2hpbmUsIFN0cmljdENvbnRyb2wsIFZhbmlsbGFFbGVtZW50UHJvdmlkZXIsIFZhbmlsbGFSZW5kZXJlciwgVmlld3BvcnQsIFZpZXdwb3J0U2xvdCwgVmlydHVhbEVsZW1lbnRQcm92aWRlciwgVmlydHVhbE1hbmFnZXIsIFZpcnR1YWxQYW5lbCwgVmlydHVhbFJlbmRlcmluZ1N0cmF0ZWd5LCBjaGVja0V4aXN0ZW5jZSwgY2lyY3VsYXRlSW5kZXgsIGNpcmN1bGF0ZVBvc2l0aW9uLCBjbGFtcCQxIGFzIGNsYW1wLCBmaW5kJDEgYXMgZmluZCwgZmluZEluZGV4LCBmaW5kUmlnaHQsIGdldERlZmF1bHRDYW1lcmFUcmFuc2Zvcm0sIGdldERpcmVjdGlvbiQxIGFzIGdldERpcmVjdGlvbiwgZ2V0RWxlbWVudCwgZ2V0RWxlbWVudFNpemUsIGdldEZsaWNraW5nQXR0YWNoZWQsIGdldE1pbnVzQ29tcGVuc2F0ZWRJbmRleCwgZ2V0UHJvZ3Jlc3MsIGdldFJlbmRlcmluZ1BhbmVscywgZ2V0U3R5bGUsIGluY2x1ZGVzLCBpc0JldHdlZW4sIGlzU3RyaW5nLCBtZXJnZSwgcGFyc2VBbGlnbiQxIGFzIHBhcnNlQWxpZ24sIHBhcnNlQXJpdGhtZXRpY0V4cHJlc3Npb24sIHBhcnNlQXJpdGhtZXRpY1NpemUsIHBhcnNlQm91bmNlLCBwYXJzZUNTU1NpemVWYWx1ZSwgcGFyc2VFbGVtZW50LCBwYXJzZVBhbmVsQWxpZ24sIHJhbmdlLCBzZXRQcm90b3R5cGVPZiwgc2V0U2l6ZSwgc3luYywgdG9BcnJheSQyIGFzIHRvQXJyYXksIHdpdGhGbGlja2luZ01ldGhvZHMgfTtcbiIsIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fIGZyb20gXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvc291cmNlTWFwcy5qc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18pO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIGAvKlxuISB0YWlsd2luZGNzcyB2My40LjcgfCBNSVQgTGljZW5zZSB8IGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tXG4qLy8qXG4xLiBQcmV2ZW50IHBhZGRpbmcgYW5kIGJvcmRlciBmcm9tIGFmZmVjdGluZyBlbGVtZW50IHdpZHRoLiAoaHR0cHM6Ly9naXRodWIuY29tL21vemRldnMvY3NzcmVtZWR5L2lzc3Vlcy80KVxuMi4gQWxsb3cgYWRkaW5nIGEgYm9yZGVyIHRvIGFuIGVsZW1lbnQgYnkganVzdCBhZGRpbmcgYSBib3JkZXItd2lkdGguIChodHRwczovL2dpdGh1Yi5jb20vdGFpbHdpbmRjc3MvdGFpbHdpbmRjc3MvcHVsbC8xMTYpXG4qL1xuXG4qLFxuOjpiZWZvcmUsXG46OmFmdGVyIHtcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDsgLyogMSAqL1xuICBib3JkZXItd2lkdGg6IDA7IC8qIDIgKi9cbiAgYm9yZGVyLXN0eWxlOiBzb2xpZDsgLyogMiAqL1xuICBib3JkZXItY29sb3I6ICNlNWU3ZWI7IC8qIDIgKi9cbn1cblxuOjpiZWZvcmUsXG46OmFmdGVyIHtcbiAgLS10dy1jb250ZW50OiAnJztcbn1cblxuLypcbjEuIFVzZSBhIGNvbnNpc3RlbnQgc2Vuc2libGUgbGluZS1oZWlnaHQgaW4gYWxsIGJyb3dzZXJzLlxuMi4gUHJldmVudCBhZGp1c3RtZW50cyBvZiBmb250IHNpemUgYWZ0ZXIgb3JpZW50YXRpb24gY2hhbmdlcyBpbiBpT1MuXG4zLiBVc2UgYSBtb3JlIHJlYWRhYmxlIHRhYiBzaXplLlxuNC4gVXNlIHRoZSB1c2VyJ3MgY29uZmlndXJlZCBcXGBzYW5zXFxgIGZvbnQtZmFtaWx5IGJ5IGRlZmF1bHQuXG41LiBVc2UgdGhlIHVzZXIncyBjb25maWd1cmVkIFxcYHNhbnNcXGAgZm9udC1mZWF0dXJlLXNldHRpbmdzIGJ5IGRlZmF1bHQuXG42LiBVc2UgdGhlIHVzZXIncyBjb25maWd1cmVkIFxcYHNhbnNcXGAgZm9udC12YXJpYXRpb24tc2V0dGluZ3MgYnkgZGVmYXVsdC5cbjcuIERpc2FibGUgdGFwIGhpZ2hsaWdodHMgb24gaU9TXG4qL1xuXG5odG1sLFxuOmhvc3Qge1xuICBsaW5lLWhlaWdodDogMS41OyAvKiAxICovXG4gIC13ZWJraXQtdGV4dC1zaXplLWFkanVzdDogMTAwJTsgLyogMiAqL1xuICAtbW96LXRhYi1zaXplOiA0OyAvKiAzICovXG4gIC1vLXRhYi1zaXplOiA0O1xuICAgICB0YWItc2l6ZTogNDsgLyogMyAqL1xuICBmb250LWZhbWlseTogdWktc2Fucy1zZXJpZiwgc3lzdGVtLXVpLCBzYW5zLXNlcmlmLCBcIkFwcGxlIENvbG9yIEVtb2ppXCIsIFwiU2Vnb2UgVUkgRW1vamlcIiwgXCJTZWdvZSBVSSBTeW1ib2xcIiwgXCJOb3RvIENvbG9yIEVtb2ppXCI7IC8qIDQgKi9cbiAgZm9udC1mZWF0dXJlLXNldHRpbmdzOiBub3JtYWw7IC8qIDUgKi9cbiAgZm9udC12YXJpYXRpb24tc2V0dGluZ3M6IG5vcm1hbDsgLyogNiAqL1xuICAtd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3I6IHRyYW5zcGFyZW50OyAvKiA3ICovXG59XG5cbi8qXG4xLiBSZW1vdmUgdGhlIG1hcmdpbiBpbiBhbGwgYnJvd3NlcnMuXG4yLiBJbmhlcml0IGxpbmUtaGVpZ2h0IGZyb20gXFxgaHRtbFxcYCBzbyB1c2VycyBjYW4gc2V0IHRoZW0gYXMgYSBjbGFzcyBkaXJlY3RseSBvbiB0aGUgXFxgaHRtbFxcYCBlbGVtZW50LlxuKi9cblxuYm9keSB7XG4gIG1hcmdpbjogMDsgLyogMSAqL1xuICBsaW5lLWhlaWdodDogaW5oZXJpdDsgLyogMiAqL1xufVxuXG4vKlxuMS4gQWRkIHRoZSBjb3JyZWN0IGhlaWdodCBpbiBGaXJlZm94LlxuMi4gQ29ycmVjdCB0aGUgaW5oZXJpdGFuY2Ugb2YgYm9yZGVyIGNvbG9yIGluIEZpcmVmb3guIChodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xOTA2NTUpXG4zLiBFbnN1cmUgaG9yaXpvbnRhbCBydWxlcyBhcmUgdmlzaWJsZSBieSBkZWZhdWx0LlxuKi9cblxuaHIge1xuICBoZWlnaHQ6IDA7IC8qIDEgKi9cbiAgY29sb3I6IGluaGVyaXQ7IC8qIDIgKi9cbiAgYm9yZGVyLXRvcC13aWR0aDogMXB4OyAvKiAzICovXG59XG5cbi8qXG5BZGQgdGhlIGNvcnJlY3QgdGV4dCBkZWNvcmF0aW9uIGluIENocm9tZSwgRWRnZSwgYW5kIFNhZmFyaS5cbiovXG5cbmFiYnI6d2hlcmUoW3RpdGxlXSkge1xuICAtd2Via2l0LXRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lIGRvdHRlZDtcbiAgICAgICAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZSBkb3R0ZWQ7XG59XG5cbi8qXG5SZW1vdmUgdGhlIGRlZmF1bHQgZm9udCBzaXplIGFuZCB3ZWlnaHQgZm9yIGhlYWRpbmdzLlxuKi9cblxuaDEsXG5oMixcbmgzLFxuaDQsXG5oNSxcbmg2IHtcbiAgZm9udC1zaXplOiBpbmhlcml0O1xuICBmb250LXdlaWdodDogaW5oZXJpdDtcbn1cblxuLypcblJlc2V0IGxpbmtzIHRvIG9wdGltaXplIGZvciBvcHQtaW4gc3R5bGluZyBpbnN0ZWFkIG9mIG9wdC1vdXQuXG4qL1xuXG5hIHtcbiAgY29sb3I6IGluaGVyaXQ7XG4gIHRleHQtZGVjb3JhdGlvbjogaW5oZXJpdDtcbn1cblxuLypcbkFkZCB0aGUgY29ycmVjdCBmb250IHdlaWdodCBpbiBFZGdlIGFuZCBTYWZhcmkuXG4qL1xuXG5iLFxuc3Ryb25nIHtcbiAgZm9udC13ZWlnaHQ6IGJvbGRlcjtcbn1cblxuLypcbjEuIFVzZSB0aGUgdXNlcidzIGNvbmZpZ3VyZWQgXFxgbW9ub1xcYCBmb250LWZhbWlseSBieSBkZWZhdWx0LlxuMi4gVXNlIHRoZSB1c2VyJ3MgY29uZmlndXJlZCBcXGBtb25vXFxgIGZvbnQtZmVhdHVyZS1zZXR0aW5ncyBieSBkZWZhdWx0LlxuMy4gVXNlIHRoZSB1c2VyJ3MgY29uZmlndXJlZCBcXGBtb25vXFxgIGZvbnQtdmFyaWF0aW9uLXNldHRpbmdzIGJ5IGRlZmF1bHQuXG40LiBDb3JyZWN0IHRoZSBvZGQgXFxgZW1cXGAgZm9udCBzaXppbmcgaW4gYWxsIGJyb3dzZXJzLlxuKi9cblxuY29kZSxcbmtiZCxcbnNhbXAsXG5wcmUge1xuICBmb250LWZhbWlseTogdWktbW9ub3NwYWNlLCBTRk1vbm8tUmVndWxhciwgTWVubG8sIE1vbmFjbywgQ29uc29sYXMsIFwiTGliZXJhdGlvbiBNb25vXCIsIFwiQ291cmllciBOZXdcIiwgbW9ub3NwYWNlOyAvKiAxICovXG4gIGZvbnQtZmVhdHVyZS1zZXR0aW5nczogbm9ybWFsOyAvKiAyICovXG4gIGZvbnQtdmFyaWF0aW9uLXNldHRpbmdzOiBub3JtYWw7IC8qIDMgKi9cbiAgZm9udC1zaXplOiAxZW07IC8qIDQgKi9cbn1cblxuLypcbkFkZCB0aGUgY29ycmVjdCBmb250IHNpemUgaW4gYWxsIGJyb3dzZXJzLlxuKi9cblxuc21hbGwge1xuICBmb250LXNpemU6IDgwJTtcbn1cblxuLypcblByZXZlbnQgXFxgc3ViXFxgIGFuZCBcXGBzdXBcXGAgZWxlbWVudHMgZnJvbSBhZmZlY3RpbmcgdGhlIGxpbmUgaGVpZ2h0IGluIGFsbCBicm93c2Vycy5cbiovXG5cbnN1YixcbnN1cCB7XG4gIGZvbnQtc2l6ZTogNzUlO1xuICBsaW5lLWhlaWdodDogMDtcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xuICB2ZXJ0aWNhbC1hbGlnbjogYmFzZWxpbmU7XG59XG5cbnN1YiB7XG4gIGJvdHRvbTogLTAuMjVlbTtcbn1cblxuc3VwIHtcbiAgdG9wOiAtMC41ZW07XG59XG5cbi8qXG4xLiBSZW1vdmUgdGV4dCBpbmRlbnRhdGlvbiBmcm9tIHRhYmxlIGNvbnRlbnRzIGluIENocm9tZSBhbmQgU2FmYXJpLiAoaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9OTk5MDg4LCBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjAxMjk3KVxuMi4gQ29ycmVjdCB0YWJsZSBib3JkZXIgY29sb3IgaW5oZXJpdGFuY2UgaW4gYWxsIENocm9tZSBhbmQgU2FmYXJpLiAoaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9OTM1NzI5LCBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTk1MDE2KVxuMy4gUmVtb3ZlIGdhcHMgYmV0d2VlbiB0YWJsZSBib3JkZXJzIGJ5IGRlZmF1bHQuXG4qL1xuXG50YWJsZSB7XG4gIHRleHQtaW5kZW50OiAwOyAvKiAxICovXG4gIGJvcmRlci1jb2xvcjogaW5oZXJpdDsgLyogMiAqL1xuICBib3JkZXItY29sbGFwc2U6IGNvbGxhcHNlOyAvKiAzICovXG59XG5cbi8qXG4xLiBDaGFuZ2UgdGhlIGZvbnQgc3R5bGVzIGluIGFsbCBicm93c2Vycy5cbjIuIFJlbW92ZSB0aGUgbWFyZ2luIGluIEZpcmVmb3ggYW5kIFNhZmFyaS5cbjMuIFJlbW92ZSBkZWZhdWx0IHBhZGRpbmcgaW4gYWxsIGJyb3dzZXJzLlxuKi9cblxuYnV0dG9uLFxuaW5wdXQsXG5vcHRncm91cCxcbnNlbGVjdCxcbnRleHRhcmVhIHtcbiAgZm9udC1mYW1pbHk6IGluaGVyaXQ7IC8qIDEgKi9cbiAgZm9udC1mZWF0dXJlLXNldHRpbmdzOiBpbmhlcml0OyAvKiAxICovXG4gIGZvbnQtdmFyaWF0aW9uLXNldHRpbmdzOiBpbmhlcml0OyAvKiAxICovXG4gIGZvbnQtc2l6ZTogMTAwJTsgLyogMSAqL1xuICBmb250LXdlaWdodDogaW5oZXJpdDsgLyogMSAqL1xuICBsaW5lLWhlaWdodDogaW5oZXJpdDsgLyogMSAqL1xuICBsZXR0ZXItc3BhY2luZzogaW5oZXJpdDsgLyogMSAqL1xuICBjb2xvcjogaW5oZXJpdDsgLyogMSAqL1xuICBtYXJnaW46IDA7IC8qIDIgKi9cbiAgcGFkZGluZzogMDsgLyogMyAqL1xufVxuXG4vKlxuUmVtb3ZlIHRoZSBpbmhlcml0YW5jZSBvZiB0ZXh0IHRyYW5zZm9ybSBpbiBFZGdlIGFuZCBGaXJlZm94LlxuKi9cblxuYnV0dG9uLFxuc2VsZWN0IHtcbiAgdGV4dC10cmFuc2Zvcm06IG5vbmU7XG59XG5cbi8qXG4xLiBDb3JyZWN0IHRoZSBpbmFiaWxpdHkgdG8gc3R5bGUgY2xpY2thYmxlIHR5cGVzIGluIGlPUyBhbmQgU2FmYXJpLlxuMi4gUmVtb3ZlIGRlZmF1bHQgYnV0dG9uIHN0eWxlcy5cbiovXG5cbmJ1dHRvbixcbmlucHV0OndoZXJlKFt0eXBlPSdidXR0b24nXSksXG5pbnB1dDp3aGVyZShbdHlwZT0ncmVzZXQnXSksXG5pbnB1dDp3aGVyZShbdHlwZT0nc3VibWl0J10pIHtcbiAgLXdlYmtpdC1hcHBlYXJhbmNlOiBidXR0b247IC8qIDEgKi9cbiAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7IC8qIDIgKi9cbiAgYmFja2dyb3VuZC1pbWFnZTogbm9uZTsgLyogMiAqL1xufVxuXG4vKlxuVXNlIHRoZSBtb2Rlcm4gRmlyZWZveCBmb2N1cyBzdHlsZSBmb3IgYWxsIGZvY3VzYWJsZSBlbGVtZW50cy5cbiovXG5cbjotbW96LWZvY3VzcmluZyB7XG4gIG91dGxpbmU6IGF1dG87XG59XG5cbi8qXG5SZW1vdmUgdGhlIGFkZGl0aW9uYWwgXFxgOmludmFsaWRcXGAgc3R5bGVzIGluIEZpcmVmb3guIChodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9nZWNrby1kZXYvYmxvYi8yZjllYWNkOWQzZDk5NWM5MzdiNDI1MWE1NTU3ZDk1ZDQ5NGM5YmUxL2xheW91dC9zdHlsZS9yZXMvZm9ybXMuY3NzI0w3MjgtTDczNylcbiovXG5cbjotbW96LXVpLWludmFsaWQge1xuICBib3gtc2hhZG93OiBub25lO1xufVxuXG4vKlxuQWRkIHRoZSBjb3JyZWN0IHZlcnRpY2FsIGFsaWdubWVudCBpbiBDaHJvbWUgYW5kIEZpcmVmb3guXG4qL1xuXG5wcm9ncmVzcyB7XG4gIHZlcnRpY2FsLWFsaWduOiBiYXNlbGluZTtcbn1cblxuLypcbkNvcnJlY3QgdGhlIGN1cnNvciBzdHlsZSBvZiBpbmNyZW1lbnQgYW5kIGRlY3JlbWVudCBidXR0b25zIGluIFNhZmFyaS5cbiovXG5cbjo6LXdlYmtpdC1pbm5lci1zcGluLWJ1dHRvbixcbjo6LXdlYmtpdC1vdXRlci1zcGluLWJ1dHRvbiB7XG4gIGhlaWdodDogYXV0bztcbn1cblxuLypcbjEuIENvcnJlY3QgdGhlIG9kZCBhcHBlYXJhbmNlIGluIENocm9tZSBhbmQgU2FmYXJpLlxuMi4gQ29ycmVjdCB0aGUgb3V0bGluZSBzdHlsZSBpbiBTYWZhcmkuXG4qL1xuXG5bdHlwZT0nc2VhcmNoJ10ge1xuICAtd2Via2l0LWFwcGVhcmFuY2U6IHRleHRmaWVsZDsgLyogMSAqL1xuICBvdXRsaW5lLW9mZnNldDogLTJweDsgLyogMiAqL1xufVxuXG4vKlxuUmVtb3ZlIHRoZSBpbm5lciBwYWRkaW5nIGluIENocm9tZSBhbmQgU2FmYXJpIG9uIG1hY09TLlxuKi9cblxuOjotd2Via2l0LXNlYXJjaC1kZWNvcmF0aW9uIHtcbiAgLXdlYmtpdC1hcHBlYXJhbmNlOiBub25lO1xufVxuXG4vKlxuMS4gQ29ycmVjdCB0aGUgaW5hYmlsaXR5IHRvIHN0eWxlIGNsaWNrYWJsZSB0eXBlcyBpbiBpT1MgYW5kIFNhZmFyaS5cbjIuIENoYW5nZSBmb250IHByb3BlcnRpZXMgdG8gXFxgaW5oZXJpdFxcYCBpbiBTYWZhcmkuXG4qL1xuXG46Oi13ZWJraXQtZmlsZS11cGxvYWQtYnV0dG9uIHtcbiAgLXdlYmtpdC1hcHBlYXJhbmNlOiBidXR0b247IC8qIDEgKi9cbiAgZm9udDogaW5oZXJpdDsgLyogMiAqL1xufVxuXG4vKlxuQWRkIHRoZSBjb3JyZWN0IGRpc3BsYXkgaW4gQ2hyb21lIGFuZCBTYWZhcmkuXG4qL1xuXG5zdW1tYXJ5IHtcbiAgZGlzcGxheTogbGlzdC1pdGVtO1xufVxuXG4vKlxuUmVtb3ZlcyB0aGUgZGVmYXVsdCBzcGFjaW5nIGFuZCBib3JkZXIgZm9yIGFwcHJvcHJpYXRlIGVsZW1lbnRzLlxuKi9cblxuYmxvY2txdW90ZSxcbmRsLFxuZGQsXG5oMSxcbmgyLFxuaDMsXG5oNCxcbmg1LFxuaDYsXG5ocixcbmZpZ3VyZSxcbnAsXG5wcmUge1xuICBtYXJnaW46IDA7XG59XG5cbmZpZWxkc2V0IHtcbiAgbWFyZ2luOiAwO1xuICBwYWRkaW5nOiAwO1xufVxuXG5sZWdlbmQge1xuICBwYWRkaW5nOiAwO1xufVxuXG5vbCxcbnVsLFxubWVudSB7XG4gIGxpc3Qtc3R5bGU6IG5vbmU7XG4gIG1hcmdpbjogMDtcbiAgcGFkZGluZzogMDtcbn1cblxuLypcblJlc2V0IGRlZmF1bHQgc3R5bGluZyBmb3IgZGlhbG9ncy5cbiovXG5kaWFsb2cge1xuICBwYWRkaW5nOiAwO1xufVxuXG4vKlxuUHJldmVudCByZXNpemluZyB0ZXh0YXJlYXMgaG9yaXpvbnRhbGx5IGJ5IGRlZmF1bHQuXG4qL1xuXG50ZXh0YXJlYSB7XG4gIHJlc2l6ZTogdmVydGljYWw7XG59XG5cbi8qXG4xLiBSZXNldCB0aGUgZGVmYXVsdCBwbGFjZWhvbGRlciBvcGFjaXR5IGluIEZpcmVmb3guIChodHRwczovL2dpdGh1Yi5jb20vdGFpbHdpbmRsYWJzL3RhaWx3aW5kY3NzL2lzc3Vlcy8zMzAwKVxuMi4gU2V0IHRoZSBkZWZhdWx0IHBsYWNlaG9sZGVyIGNvbG9yIHRvIHRoZSB1c2VyJ3MgY29uZmlndXJlZCBncmF5IDQwMCBjb2xvci5cbiovXG5cbmlucHV0OjotbW96LXBsYWNlaG9sZGVyLCB0ZXh0YXJlYTo6LW1vei1wbGFjZWhvbGRlciB7XG4gIG9wYWNpdHk6IDE7IC8qIDEgKi9cbiAgY29sb3I6ICM5Y2EzYWY7IC8qIDIgKi9cbn1cblxuaW5wdXQ6OnBsYWNlaG9sZGVyLFxudGV4dGFyZWE6OnBsYWNlaG9sZGVyIHtcbiAgb3BhY2l0eTogMTsgLyogMSAqL1xuICBjb2xvcjogIzljYTNhZjsgLyogMiAqL1xufVxuXG4vKlxuU2V0IHRoZSBkZWZhdWx0IGN1cnNvciBmb3IgYnV0dG9ucy5cbiovXG5cbmJ1dHRvbixcbltyb2xlPVwiYnV0dG9uXCJdIHtcbiAgY3Vyc29yOiBwb2ludGVyO1xufVxuXG4vKlxuTWFrZSBzdXJlIGRpc2FibGVkIGJ1dHRvbnMgZG9uJ3QgZ2V0IHRoZSBwb2ludGVyIGN1cnNvci5cbiovXG46ZGlzYWJsZWQge1xuICBjdXJzb3I6IGRlZmF1bHQ7XG59XG5cbi8qXG4xLiBNYWtlIHJlcGxhY2VkIGVsZW1lbnRzIFxcYGRpc3BsYXk6IGJsb2NrXFxgIGJ5IGRlZmF1bHQuIChodHRwczovL2dpdGh1Yi5jb20vbW96ZGV2cy9jc3NyZW1lZHkvaXNzdWVzLzE0KVxuMi4gQWRkIFxcYHZlcnRpY2FsLWFsaWduOiBtaWRkbGVcXGAgdG8gYWxpZ24gcmVwbGFjZWQgZWxlbWVudHMgbW9yZSBzZW5zaWJseSBieSBkZWZhdWx0LiAoaHR0cHM6Ly9naXRodWIuY29tL2plbnNpbW1vbnMvY3NzcmVtZWR5L2lzc3Vlcy8xNCNpc3N1ZWNvbW1lbnQtNjM0OTM0MjEwKVxuICAgVGhpcyBjYW4gdHJpZ2dlciBhIHBvb3JseSBjb25zaWRlcmVkIGxpbnQgZXJyb3IgaW4gc29tZSB0b29scyBidXQgaXMgaW5jbHVkZWQgYnkgZGVzaWduLlxuKi9cblxuaW1nLFxuc3ZnLFxudmlkZW8sXG5jYW52YXMsXG5hdWRpbyxcbmlmcmFtZSxcbmVtYmVkLFxub2JqZWN0IHtcbiAgZGlzcGxheTogYmxvY2s7IC8qIDEgKi9cbiAgdmVydGljYWwtYWxpZ246IG1pZGRsZTsgLyogMiAqL1xufVxuXG4vKlxuQ29uc3RyYWluIGltYWdlcyBhbmQgdmlkZW9zIHRvIHRoZSBwYXJlbnQgd2lkdGggYW5kIHByZXNlcnZlIHRoZWlyIGludHJpbnNpYyBhc3BlY3QgcmF0aW8uIChodHRwczovL2dpdGh1Yi5jb20vbW96ZGV2cy9jc3NyZW1lZHkvaXNzdWVzLzE0KVxuKi9cblxuaW1nLFxudmlkZW8ge1xuICBtYXgtd2lkdGg6IDEwMCU7XG4gIGhlaWdodDogYXV0bztcbn1cblxuLyogTWFrZSBlbGVtZW50cyB3aXRoIHRoZSBIVE1MIGhpZGRlbiBhdHRyaWJ1dGUgc3RheSBoaWRkZW4gYnkgZGVmYXVsdCAqL1xuW2hpZGRlbl0ge1xuICBkaXNwbGF5OiBub25lO1xufVxuXG4qLCA6OmJlZm9yZSwgOjphZnRlciB7XG4gIC0tdHctYm9yZGVyLXNwYWNpbmcteDogMDtcbiAgLS10dy1ib3JkZXItc3BhY2luZy15OiAwO1xuICAtLXR3LXRyYW5zbGF0ZS14OiAwO1xuICAtLXR3LXRyYW5zbGF0ZS15OiAwO1xuICAtLXR3LXJvdGF0ZTogMDtcbiAgLS10dy1za2V3LXg6IDA7XG4gIC0tdHctc2tldy15OiAwO1xuICAtLXR3LXNjYWxlLXg6IDE7XG4gIC0tdHctc2NhbGUteTogMTtcbiAgLS10dy1wYW4teDogIDtcbiAgLS10dy1wYW4teTogIDtcbiAgLS10dy1waW5jaC16b29tOiAgO1xuICAtLXR3LXNjcm9sbC1zbmFwLXN0cmljdG5lc3M6IHByb3hpbWl0eTtcbiAgLS10dy1ncmFkaWVudC1mcm9tLXBvc2l0aW9uOiAgO1xuICAtLXR3LWdyYWRpZW50LXZpYS1wb3NpdGlvbjogIDtcbiAgLS10dy1ncmFkaWVudC10by1wb3NpdGlvbjogIDtcbiAgLS10dy1vcmRpbmFsOiAgO1xuICAtLXR3LXNsYXNoZWQtemVybzogIDtcbiAgLS10dy1udW1lcmljLWZpZ3VyZTogIDtcbiAgLS10dy1udW1lcmljLXNwYWNpbmc6ICA7XG4gIC0tdHctbnVtZXJpYy1mcmFjdGlvbjogIDtcbiAgLS10dy1yaW5nLWluc2V0OiAgO1xuICAtLXR3LXJpbmctb2Zmc2V0LXdpZHRoOiAwcHg7XG4gIC0tdHctcmluZy1vZmZzZXQtY29sb3I6ICNmZmY7XG4gIC0tdHctcmluZy1jb2xvcjogcmdiKDU5IDEzMCAyNDYgLyAwLjUpO1xuICAtLXR3LXJpbmctb2Zmc2V0LXNoYWRvdzogMCAwICMwMDAwO1xuICAtLXR3LXJpbmctc2hhZG93OiAwIDAgIzAwMDA7XG4gIC0tdHctc2hhZG93OiAwIDAgIzAwMDA7XG4gIC0tdHctc2hhZG93LWNvbG9yZWQ6IDAgMCAjMDAwMDtcbiAgLS10dy1ibHVyOiAgO1xuICAtLXR3LWJyaWdodG5lc3M6ICA7XG4gIC0tdHctY29udHJhc3Q6ICA7XG4gIC0tdHctZ3JheXNjYWxlOiAgO1xuICAtLXR3LWh1ZS1yb3RhdGU6ICA7XG4gIC0tdHctaW52ZXJ0OiAgO1xuICAtLXR3LXNhdHVyYXRlOiAgO1xuICAtLXR3LXNlcGlhOiAgO1xuICAtLXR3LWRyb3Atc2hhZG93OiAgO1xuICAtLXR3LWJhY2tkcm9wLWJsdXI6ICA7XG4gIC0tdHctYmFja2Ryb3AtYnJpZ2h0bmVzczogIDtcbiAgLS10dy1iYWNrZHJvcC1jb250cmFzdDogIDtcbiAgLS10dy1iYWNrZHJvcC1ncmF5c2NhbGU6ICA7XG4gIC0tdHctYmFja2Ryb3AtaHVlLXJvdGF0ZTogIDtcbiAgLS10dy1iYWNrZHJvcC1pbnZlcnQ6ICA7XG4gIC0tdHctYmFja2Ryb3Atb3BhY2l0eTogIDtcbiAgLS10dy1iYWNrZHJvcC1zYXR1cmF0ZTogIDtcbiAgLS10dy1iYWNrZHJvcC1zZXBpYTogIDtcbiAgLS10dy1jb250YWluLXNpemU6ICA7XG4gIC0tdHctY29udGFpbi1sYXlvdXQ6ICA7XG4gIC0tdHctY29udGFpbi1wYWludDogIDtcbiAgLS10dy1jb250YWluLXN0eWxlOiAgO1xufVxuXG46OmJhY2tkcm9wIHtcbiAgLS10dy1ib3JkZXItc3BhY2luZy14OiAwO1xuICAtLXR3LWJvcmRlci1zcGFjaW5nLXk6IDA7XG4gIC0tdHctdHJhbnNsYXRlLXg6IDA7XG4gIC0tdHctdHJhbnNsYXRlLXk6IDA7XG4gIC0tdHctcm90YXRlOiAwO1xuICAtLXR3LXNrZXcteDogMDtcbiAgLS10dy1za2V3LXk6IDA7XG4gIC0tdHctc2NhbGUteDogMTtcbiAgLS10dy1zY2FsZS15OiAxO1xuICAtLXR3LXBhbi14OiAgO1xuICAtLXR3LXBhbi15OiAgO1xuICAtLXR3LXBpbmNoLXpvb206ICA7XG4gIC0tdHctc2Nyb2xsLXNuYXAtc3RyaWN0bmVzczogcHJveGltaXR5O1xuICAtLXR3LWdyYWRpZW50LWZyb20tcG9zaXRpb246ICA7XG4gIC0tdHctZ3JhZGllbnQtdmlhLXBvc2l0aW9uOiAgO1xuICAtLXR3LWdyYWRpZW50LXRvLXBvc2l0aW9uOiAgO1xuICAtLXR3LW9yZGluYWw6ICA7XG4gIC0tdHctc2xhc2hlZC16ZXJvOiAgO1xuICAtLXR3LW51bWVyaWMtZmlndXJlOiAgO1xuICAtLXR3LW51bWVyaWMtc3BhY2luZzogIDtcbiAgLS10dy1udW1lcmljLWZyYWN0aW9uOiAgO1xuICAtLXR3LXJpbmctaW5zZXQ6ICA7XG4gIC0tdHctcmluZy1vZmZzZXQtd2lkdGg6IDBweDtcbiAgLS10dy1yaW5nLW9mZnNldC1jb2xvcjogI2ZmZjtcbiAgLS10dy1yaW5nLWNvbG9yOiByZ2IoNTkgMTMwIDI0NiAvIDAuNSk7XG4gIC0tdHctcmluZy1vZmZzZXQtc2hhZG93OiAwIDAgIzAwMDA7XG4gIC0tdHctcmluZy1zaGFkb3c6IDAgMCAjMDAwMDtcbiAgLS10dy1zaGFkb3c6IDAgMCAjMDAwMDtcbiAgLS10dy1zaGFkb3ctY29sb3JlZDogMCAwICMwMDAwO1xuICAtLXR3LWJsdXI6ICA7XG4gIC0tdHctYnJpZ2h0bmVzczogIDtcbiAgLS10dy1jb250cmFzdDogIDtcbiAgLS10dy1ncmF5c2NhbGU6ICA7XG4gIC0tdHctaHVlLXJvdGF0ZTogIDtcbiAgLS10dy1pbnZlcnQ6ICA7XG4gIC0tdHctc2F0dXJhdGU6ICA7XG4gIC0tdHctc2VwaWE6ICA7XG4gIC0tdHctZHJvcC1zaGFkb3c6ICA7XG4gIC0tdHctYmFja2Ryb3AtYmx1cjogIDtcbiAgLS10dy1iYWNrZHJvcC1icmlnaHRuZXNzOiAgO1xuICAtLXR3LWJhY2tkcm9wLWNvbnRyYXN0OiAgO1xuICAtLXR3LWJhY2tkcm9wLWdyYXlzY2FsZTogIDtcbiAgLS10dy1iYWNrZHJvcC1odWUtcm90YXRlOiAgO1xuICAtLXR3LWJhY2tkcm9wLWludmVydDogIDtcbiAgLS10dy1iYWNrZHJvcC1vcGFjaXR5OiAgO1xuICAtLXR3LWJhY2tkcm9wLXNhdHVyYXRlOiAgO1xuICAtLXR3LWJhY2tkcm9wLXNlcGlhOiAgO1xuICAtLXR3LWNvbnRhaW4tc2l6ZTogIDtcbiAgLS10dy1jb250YWluLWxheW91dDogIDtcbiAgLS10dy1jb250YWluLXBhaW50OiAgO1xuICAtLXR3LWNvbnRhaW4tc3R5bGU6ICA7XG59XHJcbi5wb2ludGVyLWV2ZW50cy1ub25lIHtcbiAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG59XHJcbi52aXNpYmxlIHtcbiAgdmlzaWJpbGl0eTogdmlzaWJsZTtcbn1cclxuLmludmlzaWJsZSB7XG4gIHZpc2liaWxpdHk6IGhpZGRlbjtcbn1cclxuLmNvbGxhcHNlIHtcbiAgdmlzaWJpbGl0eTogY29sbGFwc2U7XG59XHJcbi5zdGF0aWMge1xuICBwb3NpdGlvbjogc3RhdGljO1xufVxyXG4uXFxcXCFmaXhlZCB7XG4gIHBvc2l0aW9uOiBmaXhlZCAhaW1wb3J0YW50O1xufVxyXG4uZml4ZWQge1xuICBwb3NpdGlvbjogZml4ZWQ7XG59XHJcbi5hYnNvbHV0ZSB7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbn1cclxuLnJlbGF0aXZlIHtcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xufVxyXG4uYm90dG9tLVxcXFxbNjhweFxcXFxdIHtcbiAgYm90dG9tOiA2OHB4O1xufVxyXG4ubGVmdC0wIHtcbiAgbGVmdDogMHB4O1xufVxyXG4ubGVmdC1cXFxcWy02N3B4XFxcXF0ge1xuICBsZWZ0OiAtNjdweDtcbn1cclxuLnJpZ2h0LTAge1xuICByaWdodDogMHB4O1xufVxyXG4ucmlnaHQtXFxcXFstNjdweFxcXFxdIHtcbiAgcmlnaHQ6IC02N3B4O1xufVxyXG4ucmlnaHQtXFxcXFsxNTRweFxcXFxdIHtcbiAgcmlnaHQ6IDE1NHB4O1xufVxyXG4udG9wLVxcXFxbMTg2cHhcXFxcXSB7XG4gIHRvcDogMTg2cHg7XG59XHJcbi50b3AtXFxcXFsyMzRweFxcXFxdIHtcbiAgdG9wOiAyMzRweDtcbn1cclxuLmxlZnQtXFxcXFstMzFweFxcXFxdIHtcbiAgbGVmdDogLTMxcHg7XG59XHJcbi50b3AtXFxcXFsxNDVweFxcXFxdIHtcbiAgdG9wOiAxNDVweDtcbn1cclxuLnRvcC1cXFxcWzIxMHB4XFxcXF0ge1xuICB0b3A6IDIxMHB4O1xufVxyXG4udG9wLVxcXFxbMjIwcHhcXFxcXSB7XG4gIHRvcDogMjIwcHg7XG59XHJcbi56LTAge1xuICB6LWluZGV4OiAwO1xufVxyXG4uei00MCB7XG4gIHotaW5kZXg6IDQwO1xufVxyXG4uei1cXFxcWzFcXFxcXSB7XG4gIHotaW5kZXg6IDE7XG59XHJcbi56LVxcXFxbMlxcXFxdIHtcbiAgei1pbmRleDogMjtcbn1cclxuLm14LWF1dG8ge1xuICBtYXJnaW4tbGVmdDogYXV0bztcbiAgbWFyZ2luLXJpZ2h0OiBhdXRvO1xufVxyXG4ubWItXFxcXFsxMTVweFxcXFxdIHtcbiAgbWFyZ2luLWJvdHRvbTogMTE1cHg7XG59XHJcbi5tYi1hdXRvIHtcbiAgbWFyZ2luLWJvdHRvbTogYXV0bztcbn1cclxuLm1sLVxcXFxbLTY3cHhcXFxcXSB7XG4gIG1hcmdpbi1sZWZ0OiAtNjdweDtcbn1cclxuLm1sLVxcXFxbMTY1cHhcXFxcXSB7XG4gIG1hcmdpbi1sZWZ0OiAxNjVweDtcbn1cclxuLm1sLVxcXFxbNTlweFxcXFxdIHtcbiAgbWFyZ2luLWxlZnQ6IDU5cHg7XG59XHJcbi5tbC1cXFxcWzk4cHhcXFxcXSB7XG4gIG1hcmdpbi1sZWZ0OiA5OHB4O1xufVxyXG4ubXItXFxcXFstMTYwcHhcXFxcXSB7XG4gIG1hcmdpbi1yaWdodDogLTE2MHB4O1xufVxyXG4ubXQtXFxcXFstMjAwcHhcXFxcXSB7XG4gIG1hcmdpbi10b3A6IC0yMDBweDtcbn1cclxuLm10LVxcXFxbMTIwcHhcXFxcXSB7XG4gIG1hcmdpbi10b3A6IDEyMHB4O1xufVxyXG4ubXQtXFxcXFsyMDBweFxcXFxdIHtcbiAgbWFyZ2luLXRvcDogMjAwcHg7XG59XHJcbi5tdC1cXFxcWzQ0cHhcXFxcXSB7XG4gIG1hcmdpbi10b3A6IDQ0cHg7XG59XHJcbi5tdC1cXFxcWzc3cHhcXFxcXSB7XG4gIG1hcmdpbi10b3A6IDc3cHg7XG59XHJcbi5tdC1cXFxcWy0xMjBweFxcXFxdIHtcbiAgbWFyZ2luLXRvcDogLTEyMHB4O1xufVxyXG4ubXQtXFxcXFswcHhcXFxcXSB7XG4gIG1hcmdpbi10b3A6IDBweDtcbn1cclxuLmJsb2NrIHtcbiAgZGlzcGxheTogYmxvY2s7XG59XHJcbi5mbGV4IHtcbiAgZGlzcGxheTogZmxleDtcbn1cclxuLnRhYmxlIHtcbiAgZGlzcGxheTogdGFibGU7XG59XHJcbi5ncmlkIHtcbiAgZGlzcGxheTogZ3JpZDtcbn1cclxuLmNvbnRlbnRzIHtcbiAgZGlzcGxheTogY29udGVudHM7XG59XHJcbi5oaWRkZW4ge1xuICBkaXNwbGF5OiBub25lO1xufVxyXG4uc2l6ZS1cXFxcWzQwcHhcXFxcXSB7XG4gIHdpZHRoOiA0MHB4O1xuICBoZWlnaHQ6IDQwcHg7XG59XHJcbi5zaXplLWZ1bGwge1xuICB3aWR0aDogMTAwJTtcbiAgaGVpZ2h0OiAxMDAlO1xufVxyXG4uaC1cXFxcWzExMDBweFxcXFxdIHtcbiAgaGVpZ2h0OiAxMTAwcHg7XG59XHJcbi5oLVxcXFxbMjAwcHhcXFxcXSB7XG4gIGhlaWdodDogMjAwcHg7XG59XHJcbi5oLVxcXFxbMjMzcHhcXFxcXSB7XG4gIGhlaWdodDogMjMzcHg7XG59XHJcbi5oLVxcXFxbNTI4cHhcXFxcXSB7XG4gIGhlaWdodDogNTI4cHg7XG59XHJcbi5oLVxcXFxbNjA2cHhcXFxcXSB7XG4gIGhlaWdodDogNjA2cHg7XG59XHJcbi5oLVxcXFxbNjA4cHhcXFxcXSB7XG4gIGhlaWdodDogNjA4cHg7XG59XHJcbi5oLVxcXFxbNjRweFxcXFxdIHtcbiAgaGVpZ2h0OiA2NHB4O1xufVxyXG4uaC1cXFxcWzcyOHB4XFxcXF0ge1xuICBoZWlnaHQ6IDcyOHB4O1xufVxyXG4uaC1cXFxcWzcycHhcXFxcXSB7XG4gIGhlaWdodDogNzJweDtcbn1cclxuLmgtXFxcXFs3ODRweFxcXFxdIHtcbiAgaGVpZ2h0OiA3ODRweDtcbn1cclxuLmgtXFxcXFs5ODRweFxcXFxdIHtcbiAgaGVpZ2h0OiA5ODRweDtcbn1cclxuLmgtZml0IHtcbiAgaGVpZ2h0OiAtbW96LWZpdC1jb250ZW50O1xuICBoZWlnaHQ6IGZpdC1jb250ZW50O1xufVxyXG4uaC1cXFxcWzI4cHhcXFxcXSB7XG4gIGhlaWdodDogMjhweDtcbn1cclxuLmgtXFxcXFs1MzhweFxcXFxdIHtcbiAgaGVpZ2h0OiA1MzhweDtcbn1cclxuLmgtXFxcXFs1M1xcXFxdIHtcbiAgaGVpZ2h0OiA1Mztcbn1cclxuLmgtXFxcXFs1MzhveFxcXFxdIHtcbiAgaGVpZ2h0OiA1MzhveDtcbn1cclxuLmgtXFxcXFs2NDhweFxcXFxdIHtcbiAgaGVpZ2h0OiA2NDhweDtcbn1cclxuLmgtXFxcXFs3NDhweFxcXFxdIHtcbiAgaGVpZ2h0OiA3NDhweDtcbn1cclxuLmgtXFxcXFs1MThweFxcXFxdIHtcbiAgaGVpZ2h0OiA1MThweDtcbn1cclxuLmgtXFxcXFs0MzhweFxcXFxdIHtcbiAgaGVpZ2h0OiA0MzhweDtcbn1cclxuLmgtXFxcXFs2NThweFxcXFxdIHtcbiAgaGVpZ2h0OiA2NThweDtcbn1cclxuLmgtXFxcXFs0NTBweFxcXFxdIHtcbiAgaGVpZ2h0OiA0NTBweDtcbn1cclxuLm1pbi1oLVxcXFxbNzI4cHhcXFxcXSB7XG4gIG1pbi1oZWlnaHQ6IDcyOHB4O1xufVxyXG4ubWluLWgtZHZoIHtcbiAgbWluLWhlaWdodDogMTAwZHZoO1xufVxyXG4ubWluLWgtc2NyZWVuIHtcbiAgbWluLWhlaWdodDogMTAwdmg7XG59XHJcbi5taW4taC1cXFxcWzc4NHB4XFxcXF0ge1xuICBtaW4taGVpZ2h0OiA3ODRweDtcbn1cclxuLnctXFxcXFsxNzdweFxcXFxdIHtcbiAgd2lkdGg6IDE3N3B4O1xufVxyXG4udy1cXFxcWzE5OXB4XFxcXF0ge1xuICB3aWR0aDogMTk5cHg7XG59XHJcbi53LVxcXFxbNDQ1cHhcXFxcXSB7XG4gIHdpZHRoOiA0NDVweDtcbn1cclxuLnctXFxcXFs1MDRweFxcXFxdIHtcbiAgd2lkdGg6IDUwNHB4O1xufVxyXG4udy1cXFxcWzcwNXB4XFxcXF0ge1xuICB3aWR0aDogNzA1cHg7XG59XHJcbi53LVxcXFxbNzM1cHhcXFxcXSB7XG4gIHdpZHRoOiA3MzVweDtcbn1cclxuLnctXFxcXFs4OTVweFxcXFxdIHtcbiAgd2lkdGg6IDg5NXB4O1xufVxyXG4udy1maXQge1xuICB3aWR0aDogLW1vei1maXQtY29udGVudDtcbiAgd2lkdGg6IGZpdC1jb250ZW50O1xufVxyXG4udy1mdWxsIHtcbiAgd2lkdGg6IDEwMCU7XG59XHJcbi53LVxcXFxbNDAwcHhcXFxcXSB7XG4gIHdpZHRoOiA0MDBweDtcbn1cclxuLnctXFxcXFs1MDBweFxcXFxdIHtcbiAgd2lkdGg6IDUwMHB4O1xufVxyXG4udy1cXFxcWzU0MHB4XFxcXF0ge1xuICB3aWR0aDogNTQwcHg7XG59XHJcbi53LVxcXFxbNTMwcHhcXFxcXSB7XG4gIHdpZHRoOiA1MzBweDtcbn1cclxuLnctXFxcXFs0MzhweFxcXFxdIHtcbiAgd2lkdGg6IDQzOHB4O1xufVxyXG4udy1cXFxcWzYycHhcXFxcXSB7XG4gIHdpZHRoOiA2MnB4O1xufVxyXG4udy1cXFxcWzM1NXB4XFxcXF0ge1xuICB3aWR0aDogMzU1cHg7XG59XHJcbi53LVxcXFxbNTM4cHhcXFxcXSB7XG4gIHdpZHRoOiA1MzhweDtcbn1cclxuLnctXFxcXFs2MzhweFxcXFxdIHtcbiAgd2lkdGg6IDYzOHB4O1xufVxyXG4udy1cXFxcWzM4cHhcXFxcXSB7XG4gIHdpZHRoOiAzOHB4O1xufVxyXG4udy1cXFxcWzM5MHB4XFxcXF0ge1xuICB3aWR0aDogMzkwcHg7XG59XHJcbi5taW4tdy1cXFxcWzE0N3B4XFxcXF0ge1xuICBtaW4td2lkdGg6IDE0N3B4O1xufVxyXG4ubWluLXctXFxcXFs3MzVweFxcXFxdIHtcbiAgbWluLXdpZHRoOiA3MzVweDtcbn1cclxuLm1heC13LVxcXFxbMTM0MnB4XFxcXF0ge1xuICBtYXgtd2lkdGg6IDEzNDJweDtcbn1cclxuLm1heC13LVxcXFxbMTQ0MHB4XFxcXF0ge1xuICBtYXgtd2lkdGg6IDE0NDBweDtcbn1cclxuLm1heC13LVxcXFxbMTkwcHhcXFxcXSB7XG4gIG1heC13aWR0aDogMTkwcHg7XG59XHJcbi5tYXgtdy1cXFxcWzM5OHB4XFxcXF0ge1xuICBtYXgtd2lkdGg6IDM5OHB4O1xufVxyXG4ubWF4LXctXFxcXFs0MzhweFxcXFxdIHtcbiAgbWF4LXdpZHRoOiA0MzhweDtcbn1cclxuLm1heC13LVxcXFxbNTQwcHhcXFxcXSB7XG4gIG1heC13aWR0aDogNTQwcHg7XG59XHJcbi5tYXgtdy1cXFxcWzYzNXB4XFxcXF0ge1xuICBtYXgtd2lkdGg6IDYzNXB4O1xufVxyXG4ubWF4LXctXFxcXFs3MzBweFxcXFxdIHtcbiAgbWF4LXdpZHRoOiA3MzBweDtcbn1cclxuLm1heC13LVxcXFxbY2FsY1xcXFwoMTI3NXB4XFxcXCszOXB4XFxcXClcXFxcXSB7XG4gIG1heC13aWR0aDogY2FsYygxMjc1cHggKyAzOXB4KTtcbn1cclxuLm1heC13LWZ1bGwge1xuICBtYXgtd2lkdGg6IDEwMCU7XG59XHJcbi5tYXgtdy1cXFxcWzI4MXB4XFxcXF0ge1xuICBtYXgtd2lkdGg6IDI4MXB4O1xufVxyXG4ubWF4LXctXFxcXFsyNTBweFxcXFxdIHtcbiAgbWF4LXdpZHRoOiAyNTBweDtcbn1cclxuLmZsZXgtc2hyaW5rIHtcbiAgZmxleC1zaHJpbms6IDE7XG59XHJcbi5ib3JkZXItY29sbGFwc2Uge1xuICBib3JkZXItY29sbGFwc2U6IGNvbGxhcHNlO1xufVxyXG4udHJhbnNmb3JtIHtcbiAgdHJhbnNmb3JtOiB0cmFuc2xhdGUodmFyKC0tdHctdHJhbnNsYXRlLXgpLCB2YXIoLS10dy10cmFuc2xhdGUteSkpIHJvdGF0ZSh2YXIoLS10dy1yb3RhdGUpKSBza2V3WCh2YXIoLS10dy1za2V3LXgpKSBza2V3WSh2YXIoLS10dy1za2V3LXkpKSBzY2FsZVgodmFyKC0tdHctc2NhbGUteCkpIHNjYWxlWSh2YXIoLS10dy1zY2FsZS15KSk7XG59XHJcbi5yZXNpemUge1xuICByZXNpemU6IGJvdGg7XG59XHJcbi5mbGV4LWNvbCB7XG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG59XHJcbi5pdGVtcy1zdGFydCB7XG4gIGFsaWduLWl0ZW1zOiBmbGV4LXN0YXJ0O1xufVxyXG4uaXRlbXMtY2VudGVyIHtcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbn1cclxuLmp1c3RpZnktc3RhcnQge1xuICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtc3RhcnQ7XG59XHJcbi5qdXN0aWZ5LWVuZCB7XG4gIGp1c3RpZnktY29udGVudDogZmxleC1lbmQ7XG59XHJcbi5qdXN0aWZ5LWNlbnRlciB7XG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xufVxyXG4uanVzdGlmeS1iZXR3ZWVuIHtcbiAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xufVxyXG4uZ2FwLVxcXFxbMTZweFxcXFxdIHtcbiAgZ2FwOiAxNnB4O1xufVxyXG4uZ2FwLVxcXFxbMjRweFxcXFxdIHtcbiAgZ2FwOiAyNHB4O1xufVxyXG4uZ2FwLVxcXFxbMjhweFxcXFxdIHtcbiAgZ2FwOiAyOHB4O1xufVxyXG4uZ2FwLVxcXFxbMzlweFxcXFxdIHtcbiAgZ2FwOiAzOXB4O1xufVxyXG4uZ2FwLVxcXFxbNDNweFxcXFxdIHtcbiAgZ2FwOiA0M3B4O1xufVxyXG4uZ2FwLVxcXFxbNDhweFxcXFxdIHtcbiAgZ2FwOiA0OHB4O1xufVxyXG4uZ2FwLVxcXFxbNTFweFxcXFxdIHtcbiAgZ2FwOiA1MXB4O1xufVxyXG4uZ2FwLVxcXFxbNTZweFxcXFxdIHtcbiAgZ2FwOiA1NnB4O1xufVxyXG4uZ2FwLVxcXFxbMzJweFxcXFxdIHtcbiAgZ2FwOiAzMnB4O1xufVxyXG4uc2VsZi1lbmQge1xuICBhbGlnbi1zZWxmOiBmbGV4LWVuZDtcbn1cclxuLm92ZXJmbG93LXgtY2xpcCB7XG4gIG92ZXJmbG93LXg6IGNsaXA7XG59XHJcbi5yb3VuZGVkIHtcbiAgYm9yZGVyLXJhZGl1czogMC4yNXJlbTtcbn1cclxuLmJvcmRlciB7XG4gIGJvcmRlci13aWR0aDogMXB4O1xufVxyXG4uYmctXFxcXFtcXFxcIzE5MTkyMVxcXFxdIHtcbiAgLS10dy1iZy1vcGFjaXR5OiAxO1xuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMjUgMjUgMzMgLyB2YXIoLS10dy1iZy1vcGFjaXR5KSk7XG59XHJcbi5iZy1cXFxcW1xcXFwjRjk0RjRGXFxcXF0ge1xuICAtLXR3LWJnLW9wYWNpdHk6IDE7XG4gIGJhY2tncm91bmQtY29sb3I6IHJnYigyNDkgNzkgNzkgLyB2YXIoLS10dy1iZy1vcGFjaXR5KSk7XG59XHJcbi5zdHJva2UtXFxcXFtcXFxcI0Y5NEY0RlxcXFxdIHtcbiAgc3Ryb2tlOiAjRjk0RjRGO1xufVxyXG4uc3Ryb2tlLVxcXFxbXFxcXCNGRjkzOTNcXFxcXSB7XG4gIHN0cm9rZTogI0ZGOTM5Mztcbn1cclxuLm9iamVjdC1jb3ZlciB7XG4gIC1vLW9iamVjdC1maXQ6IGNvdmVyO1xuICAgICBvYmplY3QtZml0OiBjb3Zlcjtcbn1cclxuLm9iamVjdC1cXFxcWzEwMFxcXFwlXzEwMFxcXFwlXFxcXF0ge1xuICAtby1vYmplY3QtcG9zaXRpb246IDEwMCUgMTAwJTtcbiAgICAgb2JqZWN0LXBvc2l0aW9uOiAxMDAlIDEwMCU7XG59XHJcbi5vYmplY3QtXFxcXFswMFxcXFwlXzEwMFxcXFwlXFxcXF0ge1xuICAtby1vYmplY3QtcG9zaXRpb246IDAwJSAxMDAlO1xuICAgICBvYmplY3QtcG9zaXRpb246IDAwJSAxMDAlO1xufVxyXG4ub2JqZWN0LVxcXFxbMFxcXFwlXzEwMFxcXFwlXFxcXF0ge1xuICAtby1vYmplY3QtcG9zaXRpb246IDAlIDEwMCU7XG4gICAgIG9iamVjdC1wb3NpdGlvbjogMCUgMTAwJTtcbn1cclxuLm9iamVjdC1cXFxcWzEwMFxcXFwlXzBcXFxcJVxcXFxdIHtcbiAgLW8tb2JqZWN0LXBvc2l0aW9uOiAxMDAlIDAlO1xuICAgICBvYmplY3QtcG9zaXRpb246IDEwMCUgMCU7XG59XHJcbi5vYmplY3QtY2VudGVyIHtcbiAgLW8tb2JqZWN0LXBvc2l0aW9uOiBjZW50ZXI7XG4gICAgIG9iamVjdC1wb3NpdGlvbjogY2VudGVyO1xufVxyXG4ucHgtMCB7XG4gIHBhZGRpbmctbGVmdDogMHB4O1xuICBwYWRkaW5nLXJpZ2h0OiAwcHg7XG59XHJcbi5weC1cXFxcWzQzcHhcXFxcXSB7XG4gIHBhZGRpbmctbGVmdDogNDNweDtcbiAgcGFkZGluZy1yaWdodDogNDNweDtcbn1cclxuLnBsLVxcXFxbMTU0cHhcXFxcXSB7XG4gIHBhZGRpbmctbGVmdDogMTU0cHg7XG59XHJcbi5wbC1cXFxcWzMzcHhcXFxcXSB7XG4gIHBhZGRpbmctbGVmdDogMzNweDtcbn1cclxuLnBsLVxcXFxbMzlweFxcXFxdIHtcbiAgcGFkZGluZy1sZWZ0OiAzOXB4O1xufVxyXG4ucHItXFxcXFsxMDZweFxcXFxdIHtcbiAgcGFkZGluZy1yaWdodDogMTA2cHg7XG59XHJcbi5wci1cXFxcWzQwcHhcXFxcXSB7XG4gIHBhZGRpbmctcmlnaHQ6IDQwcHg7XG59XHJcbi5wci0wIHtcbiAgcGFkZGluZy1yaWdodDogMHB4O1xufVxyXG4ucGwtXFxcXFs2OXB4XFxcXF0ge1xuICBwYWRkaW5nLWxlZnQ6IDY5cHg7XG59XHJcbi5wci1cXFxcWzExNnB4XFxcXF0ge1xuICBwYWRkaW5nLXJpZ2h0OiAxMTZweDtcbn1cclxuLnByLVxcXFxbMjBweFxcXFxdIHtcbiAgcGFkZGluZy1yaWdodDogMjBweDtcbn1cclxuLnRleHQtZW5kIHtcbiAgdGV4dC1hbGlnbjogZW5kO1xufVxyXG4uZm9udC1jb21taXNzaW9uZXIge1xuICBmb250LWZhbWlseTogXCJDb21taXNzaW9uZXJcIiwgc2Fucy1zZXJpZjtcbn1cclxuLnRleHQtXFxcXFsxNnB4XFxcXF0ge1xuICBmb250LXNpemU6IDE2cHg7XG59XHJcbi50ZXh0LVxcXFxbMThweFxcXFxdIHtcbiAgZm9udC1zaXplOiAxOHB4O1xufVxyXG4udGV4dC1cXFxcWzgwcHhcXFxcXSB7XG4gIGZvbnQtc2l6ZTogODBweDtcbn1cclxuLnRleHQtXFxcXFsxNXB4XFxcXF0ge1xuICBmb250LXNpemU6IDE1cHg7XG59XHJcbi50ZXh0LVxcXFxbMjBweFxcXFxdIHtcbiAgZm9udC1zaXplOiAyMHB4O1xufVxyXG4udGV4dC1cXFxcWzMycHhcXFxcXSB7XG4gIGZvbnQtc2l6ZTogMzJweDtcbn1cclxuLnRleHQtXFxcXFs1NnB4XFxcXF0ge1xuICBmb250LXNpemU6IDU2cHg7XG59XHJcbi5mb250LWV4dHJhYm9sZCB7XG4gIGZvbnQtd2VpZ2h0OiA4MDA7XG59XHJcbi5sZWFkaW5nLVxcXFxbMzJweFxcXFxdIHtcbiAgbGluZS1oZWlnaHQ6IDMycHg7XG59XHJcbi5sZWFkaW5nLVxcXFxbODhweFxcXFxdIHtcbiAgbGluZS1oZWlnaHQ6IDg4cHg7XG59XHJcbi5sZWFkaW5nLVxcXFxbMjVweFxcXFxdIHtcbiAgbGluZS1oZWlnaHQ6IDI1cHg7XG59XHJcbi5sZWFkaW5nLVxcXFxbNDBweFxcXFxdIHtcbiAgbGluZS1oZWlnaHQ6IDQwcHg7XG59XHJcbi5sZWFkaW5nLVxcXFxbNTZweFxcXFxdIHtcbiAgbGluZS1oZWlnaHQ6IDU2cHg7XG59XHJcbi50ZXh0LVxcXFxbXFxcXCNGOTRGNEZcXFxcXSB7XG4gIC0tdHctdGV4dC1vcGFjaXR5OiAxO1xuICBjb2xvcjogcmdiKDI0OSA3OSA3OSAvIHZhcigtLXR3LXRleHQtb3BhY2l0eSkpO1xufVxyXG4udGV4dC13aGl0ZSB7XG4gIC0tdHctdGV4dC1vcGFjaXR5OiAxO1xuICBjb2xvcjogcmdiKDI1NSAyNTUgMjU1IC8gdmFyKC0tdHctdGV4dC1vcGFjaXR5KSk7XG59XHJcbi50ZXh0LXdoaXRlXFxcXC8yNSB7XG4gIGNvbG9yOiByZ2IoMjU1IDI1NSAyNTUgLyAwLjI1KTtcbn1cclxuLnVuZGVybGluZSB7XG4gIHRleHQtZGVjb3JhdGlvbi1saW5lOiB1bmRlcmxpbmU7XG59XHJcbi5vdmVybGluZSB7XG4gIHRleHQtZGVjb3JhdGlvbi1saW5lOiBvdmVybGluZTtcbn1cclxuLnVuZGVybGluZS1vZmZzZXQtXFxcXFsxMnB4XFxcXF0ge1xuICB0ZXh0LXVuZGVybGluZS1vZmZzZXQ6IDEycHg7XG59XHJcbi5vdXRsaW5lIHtcbiAgb3V0bGluZS1zdHlsZTogc29saWQ7XG59XHJcbi5maWx0ZXIge1xuICBmaWx0ZXI6IHZhcigtLXR3LWJsdXIpIHZhcigtLXR3LWJyaWdodG5lc3MpIHZhcigtLXR3LWNvbnRyYXN0KSB2YXIoLS10dy1ncmF5c2NhbGUpIHZhcigtLXR3LWh1ZS1yb3RhdGUpIHZhcigtLXR3LWludmVydCkgdmFyKC0tdHctc2F0dXJhdGUpIHZhcigtLXR3LXNlcGlhKSB2YXIoLS10dy1kcm9wLXNoYWRvdyk7XG59XHJcbi50cmFuc2l0aW9uIHtcbiAgdHJhbnNpdGlvbi1wcm9wZXJ0eTogY29sb3IsIGJhY2tncm91bmQtY29sb3IsIGJvcmRlci1jb2xvciwgdGV4dC1kZWNvcmF0aW9uLWNvbG9yLCBmaWxsLCBzdHJva2UsIG9wYWNpdHksIGJveC1zaGFkb3csIHRyYW5zZm9ybSwgZmlsdGVyLCAtd2Via2l0LWJhY2tkcm9wLWZpbHRlcjtcbiAgdHJhbnNpdGlvbi1wcm9wZXJ0eTogY29sb3IsIGJhY2tncm91bmQtY29sb3IsIGJvcmRlci1jb2xvciwgdGV4dC1kZWNvcmF0aW9uLWNvbG9yLCBmaWxsLCBzdHJva2UsIG9wYWNpdHksIGJveC1zaGFkb3csIHRyYW5zZm9ybSwgZmlsdGVyLCBiYWNrZHJvcC1maWx0ZXI7XG4gIHRyYW5zaXRpb24tcHJvcGVydHk6IGNvbG9yLCBiYWNrZ3JvdW5kLWNvbG9yLCBib3JkZXItY29sb3IsIHRleHQtZGVjb3JhdGlvbi1jb2xvciwgZmlsbCwgc3Ryb2tlLCBvcGFjaXR5LCBib3gtc2hhZG93LCB0cmFuc2Zvcm0sIGZpbHRlciwgYmFja2Ryb3AtZmlsdGVyLCAtd2Via2l0LWJhY2tkcm9wLWZpbHRlcjtcbiAgdHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLjQsIDAsIDAuMiwgMSk7XG4gIHRyYW5zaXRpb24tZHVyYXRpb246IDE1MG1zO1xufVxyXG4udHJhbnNpdGlvbi1hbGwge1xuICB0cmFuc2l0aW9uLXByb3BlcnR5OiBhbGw7XG4gIHRyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uOiBjdWJpYy1iZXppZXIoMC40LCAwLCAwLjIsIDEpO1xuICB0cmFuc2l0aW9uLWR1cmF0aW9uOiAxNTBtcztcbn1cclxuXHJcbmgxIHtcbiAgZm9udC1zaXplOiA1NnB4O1xuICBmb250LXdlaWdodDogODAwO1xuICBsaW5lLWhlaWdodDogNTZweDtcbn1cclxuXHJcbkBtZWRpYSAobWluLXdpZHRoOiAxMjgwcHgpIHtcblxuICBoMSB7XG4gICAgZm9udC1zaXplOiA4MHB4O1xuICAgIGxpbmUtaGVpZ2h0OiA4OHB4O1xuICB9XG59XHJcblxyXG5oMiB7XG4gIGZvbnQtc2l6ZTogMzJweDtcbiAgZm9udC13ZWlnaHQ6IDgwMDtcbiAgbGluZS1oZWlnaHQ6IDQwcHg7XG59XHJcblxyXG5AbWVkaWEgKG1pbi13aWR0aDogMTI4MHB4KSB7XG5cbiAgaDIge1xuICAgIGZvbnQtc2l6ZTogNTZweDtcbiAgICBsaW5lLWhlaWdodDogNjRweDtcbiAgfVxufVxyXG5cclxuaDMge1xuICBmb250LXNpemU6IDIwcHg7XG4gIGZvbnQtd2VpZ2h0OiA4MDA7XG4gIGxpbmUtaGVpZ2h0OiAzMnB4O1xufVxyXG5cclxucCB7XG4gIGZvbnQtc2l6ZTogMTVweDtcbiAgbGluZS1oZWlnaHQ6IDI1cHg7XG59XHJcblxyXG5AbWVkaWEgKG1pbi13aWR0aDogMTI4MHB4KSB7XG5cbiAgcCB7XG4gICAgZm9udC1zaXplOiAxOHB4O1xuICAgIGxpbmUtaGVpZ2h0OiAzMnB4O1xuICB9XG59XHJcblxyXG5hIHtcbiAgZm9udC1zaXplOiAxNXB4O1xufVxyXG5cclxuQG1lZGlhIChtaW4td2lkdGg6IDEyODBweCkge1xuXG4gIGEge1xuICAgIGZvbnQtc2l6ZTogMTZweDtcbiAgfVxufVxyXG5cclxuLnByZXZpb3VzLFxyXG4ubmV4dCB7XG4gIHN0cm9rZTogI0Y5NEY0RjtcbiAgdHJhbnNpdGlvbi1wcm9wZXJ0eTogYWxsO1xuICB0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbjogY3ViaWMtYmV6aWVyKDAuNCwgMCwgMC4yLCAxKTtcbiAgdHJhbnNpdGlvbi1kdXJhdGlvbjogMTUwbXM7XG59XHJcbi5wcmV2aW91czpob3ZlcixcclxuLm5leHQ6aG92ZXIge1xuICBzdHJva2U6ICNGRjkzOTM7XG59XHJcblxyXG4ucGFuZWwge1xyXG4gIHdpZHRoOiAxMDAlO1xyXG4gIGhlaWdodDogMTAwJTtcclxuICBkaXNwbGF5OiBmbGV4O1xyXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XHJcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XHJcbiAgZm9udC1zaXplOiAyNHB4O1xyXG59XHJcblxyXG4uaW1hZ2UtY29udGFpbmVyIHtcclxuICBwb3NpdGlvbjogcmVsYXRpdmU7XHJcbn1cclxuXHJcbi5pbWFnZS1jb250YWluZXI6OmFmdGVyIHtcclxuICBjb250ZW50OiAnJztcclxuICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbiAgYm90dG9tOiAwO1xyXG4gIGxlZnQ6IDA7XHJcbiAgd2lkdGg6IDEwMCU7XHJcbiAgaGVpZ2h0OiAyMDBweDtcclxuICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQodG8gYm90dG9tLCByZ2JhKDAsIDAsIDAsIDApIDAlLCByZ2JhKDAsIDAsIDAsIDAuNSkgMTAwJSk7XHJcbiAgcG9pbnRlci1ldmVudHM6IG5vbmU7XHJcbn1cclxuXHJcbi5ob3ZlclxcXFw6Y3Vyc29yLWdyYWI6aG92ZXIge1xuICBjdXJzb3I6IGdyYWI7XG59XHJcblxyXG4uaG92ZXJcXFxcOmJnLVxcXFxbXFxcXCM0MzQzNTZcXFxcXTpob3ZlciB7XG4gIC0tdHctYmctb3BhY2l0eTogMTtcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDY3IDY3IDg2IC8gdmFyKC0tdHctYmctb3BhY2l0eSkpO1xufVxyXG5cclxuLmhvdmVyXFxcXDpiZy1cXFxcW1xcXFwjRkY5MzkzXFxcXF06aG92ZXIge1xuICAtLXR3LWJnLW9wYWNpdHk6IDE7XG4gIGJhY2tncm91bmQtY29sb3I6IHJnYigyNTUgMTQ3IDE0NyAvIHZhcigtLXR3LWJnLW9wYWNpdHkpKTtcbn1cclxuXHJcbi5ob3ZlclxcXFw6Zm9udC1ib2xkOmhvdmVyIHtcbiAgZm9udC13ZWlnaHQ6IDcwMDtcbn1cclxuXHJcbi5ob3ZlclxcXFw6dGV4dC1cXFxcW1xcXFwjRkY5MzkzXFxcXF06aG92ZXIge1xuICAtLXR3LXRleHQtb3BhY2l0eTogMTtcbiAgY29sb3I6IHJnYigyNTUgMTQ3IDE0NyAvIHZhcigtLXR3LXRleHQtb3BhY2l0eSkpO1xufVxyXG5cclxuLmFjdGl2ZVxcXFw6Y3Vyc29yLWdyYWJiaW5nOmFjdGl2ZSB7XG4gIGN1cnNvcjogZ3JhYmJpbmc7XG59XHJcblxyXG5AbWVkaWEgKG1pbi13aWR0aDogNzY4cHgpIHtcblxuICAubWRcXFxcOmgtXFxcXFsxNzhweFxcXFxdIHtcbiAgICBoZWlnaHQ6IDE3OHB4O1xuICB9XG5cbiAgLm1kXFxcXDpoLVxcXFxbNjA2cHhcXFxcXSB7XG4gICAgaGVpZ2h0OiA2MDZweDtcbiAgfVxuXG4gIC5tZFxcXFw6bWluLWgtc2NyZWVuIHtcbiAgICBtaW4taGVpZ2h0OiAxMDB2aDtcbiAgfVxufVxyXG5cclxuQG1lZGlhIChtaW4td2lkdGg6IDEwMjRweCkge1xuXG4gIC5sZ1xcXFw6bXQtXFxcXFsyMDBweFxcXFxdIHtcbiAgICBtYXJnaW4tdG9wOiAyMDBweDtcbiAgfVxuXG4gIC5sZ1xcXFw6bXQtXFxcXFstMjAwcHhcXFxcXSB7XG4gICAgbWFyZ2luLXRvcDogLTIwMHB4O1xuICB9XG5cbiAgLmxnXFxcXDpoLVxcXFxbNzUwcHhcXFxcXSB7XG4gICAgaGVpZ2h0OiA3NTBweDtcbiAgfVxuXG4gIC5sZ1xcXFw6aC1cXFxcW1xcXFxdIHtcbiAgICBoZWlnaHQ6IDtcbiAgfVxuXG4gIC5sZ1xcXFw6aC1cXFxcWzU2MHB4XFxcXF0ge1xuICAgIGhlaWdodDogNTYwcHg7XG4gIH1cblxuICAubGdcXFxcOmgtXFxcXFs2NDhweFxcXFxdIHtcbiAgICBoZWlnaHQ6IDY0OHB4O1xuICB9XG5cbiAgLmxnXFxcXDpoLVxcXFxbNTM4cHhcXFxcXSB7XG4gICAgaGVpZ2h0OiA1MzhweDtcbiAgfVxuXG4gIC5sZ1xcXFw6dy1cXFxcWzUzMHB4XFxcXF0ge1xuICAgIHdpZHRoOiA1MzBweDtcbiAgfVxuXG4gIC5sZ1xcXFw6dy1cXFxcWzYzMHB4XFxcXF0ge1xuICAgIHdpZHRoOiA2MzBweDtcbiAgfVxuXG4gIC5sZ1xcXFw6dy1cXFxcWzg5NXB4XFxcXF0ge1xuICAgIHdpZHRoOiA4OTVweDtcbiAgfVxuXG4gIC5sZ1xcXFw6dy1cXFxcWzYwMHB4XFxcXF0ge1xuICAgIHdpZHRoOiA2MDBweDtcbiAgfVxuXG4gIC5sZ1xcXFw6bWF4LXctXFxcXFs1MzBweFxcXFxdIHtcbiAgICBtYXgtd2lkdGg6IDUzMHB4O1xuICB9XG5cbiAgLmxnXFxcXDptYXgtdy1mdWxsIHtcbiAgICBtYXgtd2lkdGg6IDEwMCU7XG4gIH1cblxuICAubGdcXFxcOm1heC13LVxcXFxbNjMwcHhcXFxcXSB7XG4gICAgbWF4LXdpZHRoOiA2MzBweDtcbiAgfVxuXG4gIC5sZ1xcXFw6Z2FwLVxcXFxbNDBweFxcXFxdIHtcbiAgICBnYXA6IDQwcHg7XG4gIH1cblxuICAubGdcXFxcOmdhcC1cXFxcWzYwcHhcXFxcXSB7XG4gICAgZ2FwOiA2MHB4O1xuICB9XG5cbiAgLmxnXFxcXDpnYXAtXFxcXFs1MHB4XFxcXF0ge1xuICAgIGdhcDogNTBweDtcbiAgfVxuXG4gIC5sZ1xcXFw6Z2FwLVxcXFxbNDBcXFxcXSB7XG4gICAgZ2FwOiA0MDtcbiAgfVxuXG4gIC5sZ1xcXFw6cHItXFxcXFs0MHB4XFxcXF0ge1xuICAgIHBhZGRpbmctcmlnaHQ6IDQwcHg7XG4gIH1cblxuICAubGdcXFxcOnByLVxcXFxbMjBweFxcXFxdIHtcbiAgICBwYWRkaW5nLXJpZ2h0OiAyMHB4O1xuICB9XG5cbiAgLmxnXFxcXDpwbC1cXFxcWzgwcHhcXFxcXSB7XG4gICAgcGFkZGluZy1sZWZ0OiA4MHB4O1xuICB9XG5cbiAgLmxnXFxcXDpwci1cXFxcWzYwcHhcXFxcXSB7XG4gICAgcGFkZGluZy1yaWdodDogNjBweDtcbiAgfVxuXG4gIC5sZ1xcXFw6cGwtXFxcXFs5MHB4XFxcXF0ge1xuICAgIHBhZGRpbmctbGVmdDogOTBweDtcbiAgfVxufVxyXG5cclxuQG1lZGlhIChtaW4td2lkdGg6IDEyODBweCkge1xuXG4gIC54bFxcXFw6bGVmdC1cXFxcWy02N3B4XFxcXF0ge1xuICAgIGxlZnQ6IC02N3B4O1xuICB9XG5cbiAgLnhsXFxcXDp0b3AtXFxcXFsyMzRweFxcXFxdIHtcbiAgICB0b3A6IDIzNHB4O1xuICB9XG5cbiAgLnhsXFxcXDptdC1cXFxcWzExMnB4XFxcXF0ge1xuICAgIG1hcmdpbi10b3A6IDExMnB4O1xuICB9XG5cbiAgLnhsXFxcXDptdC1cXFxcWy0yMDBweFxcXFxdIHtcbiAgICBtYXJnaW4tdG9wOiAtMjAwcHg7XG4gIH1cblxuICAueGxcXFxcOmgtXFxcXFs4MDBweFxcXFxdIHtcbiAgICBoZWlnaHQ6IDgwMHB4O1xuICB9XG5cbiAgLnhsXFxcXDpoLVxcXFxbNjFweFxcXFxdIHtcbiAgICBoZWlnaHQ6IDYxcHg7XG4gIH1cblxuICAueGxcXFxcOmgtXFxcXFs3ODRweFxcXFxdIHtcbiAgICBoZWlnaHQ6IDc4NHB4O1xuICB9XG5cbiAgLnhsXFxcXDpoLVxcXFxbOTg0cHhcXFxcXSB7XG4gICAgaGVpZ2h0OiA5ODRweDtcbiAgfVxuXG4gIC54bFxcXFw6dy1cXFxcWzczNXB4XFxcXF0ge1xuICAgIHdpZHRoOiA3MzVweDtcbiAgfVxuXG4gIC54bFxcXFw6dy1cXFxcWzcwNXB4XFxcXF0ge1xuICAgIHdpZHRoOiA3MDVweDtcbiAgfVxuXG4gIC54bFxcXFw6dy1cXFxcWzEzNXB4XFxcXF0ge1xuICAgIHdpZHRoOiAxMzVweDtcbiAgfVxuXG4gIC54bFxcXFw6dy1cXFxcWzg5NXB4XFxcXF0ge1xuICAgIHdpZHRoOiA4OTVweDtcbiAgfVxuXG4gIC54bFxcXFw6dy1cXFxcWzUwNHB4XFxcXF0ge1xuICAgIHdpZHRoOiA1MDRweDtcbiAgfVxuXG4gIC54bFxcXFw6bWluLXctXFxcXFsxOTlweFxcXFxdIHtcbiAgICBtaW4td2lkdGg6IDE5OXB4O1xuICB9XG5cbiAgLnhsXFxcXDptYXgtdy1cXFxcWzIyNXB4XFxcXF0ge1xuICAgIG1heC13aWR0aDogMjI1cHg7XG4gIH1cblxuICAueGxcXFxcOm1heC13LVxcXFxbNDd2d1xcXFxdIHtcbiAgICBtYXgtd2lkdGg6IDQ3dnc7XG4gIH1cblxuICAueGxcXFxcOm1heC13LVxcXFxbNTQwcHhcXFxcXSB7XG4gICAgbWF4LXdpZHRoOiA1NDBweDtcbiAgfVxuXG4gIC54bFxcXFw6bWF4LXctXFxcXFs2ODBcXFxcXSB7XG4gICAgbWF4LXdpZHRoOiA2ODA7XG4gIH1cblxuICAueGxcXFxcOmdhcC1cXFxcWzQ4cHhcXFxcXSB7XG4gICAgZ2FwOiA0OHB4O1xuICB9XG5cbiAgLnhsXFxcXDpnYXAtXFxcXFs0M3B4XFxcXF0ge1xuICAgIGdhcDogNDNweDtcbiAgfVxuXG4gIC54bFxcXFw6b2JqZWN0LWNlbnRlciB7XG4gICAgLW8tb2JqZWN0LXBvc2l0aW9uOiBjZW50ZXI7XG4gICAgICAgb2JqZWN0LXBvc2l0aW9uOiBjZW50ZXI7XG4gIH1cblxuICAueGxcXFxcOnB4LTAge1xuICAgIHBhZGRpbmctbGVmdDogMHB4O1xuICAgIHBhZGRpbmctcmlnaHQ6IDBweDtcbiAgfVxuXG4gIC54bFxcXFw6cGwtXFxcXFs2OXB4XFxcXF0ge1xuICAgIHBhZGRpbmctbGVmdDogNjlweDtcbiAgfVxuXG4gIC54bFxcXFw6cHItMCB7XG4gICAgcGFkZGluZy1yaWdodDogMHB4O1xuICB9XG5cbiAgLnhsXFxcXDpwci1cXFxcWzIwcHhcXFxcXSB7XG4gICAgcGFkZGluZy1yaWdodDogMjBweDtcbiAgfVxuXG4gIC54bFxcXFw6cHItXFxcXFsxMDZweFxcXFxdIHtcbiAgICBwYWRkaW5nLXJpZ2h0OiAxMDZweDtcbiAgfVxuXG4gIC54bFxcXFw6cGwtXFxcXFsxNTRweFxcXFxdIHtcbiAgICBwYWRkaW5nLWxlZnQ6IDE1NHB4O1xuICB9XG5cbiAgLnhsXFxcXDp0ZXh0LVxcXFxbMTZweFxcXFxdIHtcbiAgICBmb250LXNpemU6IDE2cHg7XG4gIH1cblxuICAueGxcXFxcOnRleHQtXFxcXFsxOHB4XFxcXF0ge1xuICAgIGZvbnQtc2l6ZTogMThweDtcbiAgfVxuXG4gIC54bFxcXFw6dGV4dC1cXFxcWzU2cHhcXFxcXSB7XG4gICAgZm9udC1zaXplOiA1NnB4O1xuICB9XG5cbiAgLnhsXFxcXDp0ZXh0LVxcXFxbODBweFxcXFxdIHtcbiAgICBmb250LXNpemU6IDgwcHg7XG4gIH1cblxuICAueGxcXFxcOmxlYWRpbmctXFxcXFszMnB4XFxcXF0ge1xuICAgIGxpbmUtaGVpZ2h0OiAzMnB4O1xuICB9XG5cbiAgLnhsXFxcXDpsZWFkaW5nLVxcXFxbNjRweFxcXFxdIHtcbiAgICBsaW5lLWhlaWdodDogNjRweDtcbiAgfVxuXG4gIC54bFxcXFw6bGVhZGluZy1cXFxcWzg4cHhcXFxcXSB7XG4gICAgbGluZS1oZWlnaHQ6IDg4cHg7XG4gIH1cbn1cclxuXHJcbkBtZWRpYSAobWluLXdpZHRoOiAxNTAwcHgpIHtcblxuICAuc2NyZWVuMTUwMFxcXFw6bWF4LXctXFxcXFs3MDVweFxcXFxdIHtcbiAgICBtYXgtd2lkdGg6IDcwNXB4O1xuICB9XG59XHJcbmAsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovLy4vYXBw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QUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQSxpQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUEsV0FBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxXQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQSx3QkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQSx1QkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUEsa0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsa0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBLG9CQUFtQjtLQUFuQjtBQUFtQjtBQUFuQjtFQUFBLDZCQUFtQjtLQUFuQjtBQUFtQjtBQUFuQjtFQUFBLDRCQUFtQjtLQUFuQjtBQUFtQjtBQUFuQjtFQUFBLDJCQUFtQjtLQUFuQjtBQUFtQjtBQUFuQjtFQUFBLDJCQUFtQjtLQUFuQjtBQUFtQjtBQUFuQjtFQUFBLDBCQUFtQjtLQUFuQjtBQUFtQjtBQUFuQjtFQUFBLGlCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLGtCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFB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SUFBQTtFQXdEQTs7RUF4REE7SUFBQTtFQXdEQTs7RUF4REE7SUFBQTtFQXdEQTs7RUF4REE7SUFBQTtFQXdEQTs7RUF4REE7SUFBQTtFQXdEQTs7RUF4REE7SUFBQTtFQXdEQTs7RUF4REE7SUFBQTtFQXdEQTs7RUF4REE7SUFBQTtFQXdEQTs7RUF4REE7SUFBQTtFQXdEQTs7RUF4REE7SUFBQTtFQXdEQTs7RUF4REE7SUFBQTtFQXdEQTs7RUF4REE7SUFBQTtFQXdEQTs7RUF4REE7SUFBQTtFQXdEQTs7RUF4REE7SUFBQTtFQXdEQTs7RUF4REE7SUFBQSwwQkF3REE7T0F4REE7RUF3REE7O0VBeERBO0lBQUEsaUJBd0RBO0lBeERBO0VBd0RBOztFQXhEQTtJQUFBO0VBd0RBOztFQXhEQTtJQUFBO0VBd0RBOztFQXhEQTtJQUFBO0VBd0RBOztFQXhEQTtJQUFBO0VBd0RBOztFQXhEQTtJQUFBO0VBd0RBOztFQXhEQTtJQUFBO0VBd0RBOztFQXhEQTtJQUFBO0VBd0RBOztFQXhEQTtJQUFBO0VBd0RBOztFQXhEQTtJQUFBO0VBd0RBOztFQXhEQTtJQUFBO0VBd0RBOztFQXhEQTtJQUFBO0VBd0RBOztFQXhEQTtJQUFBO0VBd0RBO0FBQUE7O0FBeERBOztFQUFBO0lBQUE7RUF3REE7QUFBQVwiLFwic291cmNlc0NvbnRlbnRcIjpbXCJAdGFpbHdpbmQgYmFzZTtcXHJcXG5AdGFpbHdpbmQgY29tcG9uZW50cztcXHJcXG5AdGFpbHdpbmQgdXRpbGl0aWVzO1xcclxcblxcclxcbmgxIHtcXHJcXG4gIEBhcHBseSB0ZXh0LVs1NnB4XSBmb250LWV4dHJhYm9sZCBsZWFkaW5nLVs1NnB4XSB4bDp0ZXh0LVs4MHB4XSB4bDpsZWFkaW5nLVs4OHB4XTtcXHJcXG59XFxyXFxuXFxyXFxuaDIge1xcclxcbiAgQGFwcGx5IHRleHQtWzMycHhdIHhsOnRleHQtWzU2cHhdIGZvbnQtZXh0cmFib2xkIGxlYWRpbmctWzQwcHhdIHhsOmxlYWRpbmctWzY0cHhdO1xcclxcbn1cXHJcXG5cXHJcXG5oMyB7XFxyXFxuICBAYXBwbHkgdGV4dC1bMjBweF0gZm9udC1leHRyYWJvbGQgbGVhZGluZy1bMzJweF07XFxyXFxufVxcclxcblxcclxcbnAge1xcclxcbiAgQGFwcGx5IHRleHQtWzE1cHhdIHhsOnRleHQtWzE4cHhdIGxlYWRpbmctWzI1cHhdIHhsOmxlYWRpbmctWzMycHhdO1xcclxcbn1cXHJcXG5cXHJcXG5he1xcclxcbiAgQGFwcGx5IHRleHQtWzE1cHhdIHhsOnRleHQtWzE2cHhdO1xcclxcbn1cXHJcXG5cXHJcXG4ucHJldmlvdXMsXFxyXFxuLm5leHQge1xcclxcbiAgQGFwcGx5IHN0cm9rZS1bI0Y5NEY0Rl0gdHJhbnNpdGlvbi1hbGw7XFxyXFxufVxcclxcbi5wcmV2aW91czpob3ZlcixcXHJcXG4ubmV4dDpob3ZlciB7XFxyXFxuICBAYXBwbHkgc3Ryb2tlLVsjRkY5MzkzXTtcXHJcXG59XFxyXFxuXFxyXFxuLnBhbmVsIHtcXHJcXG4gIHdpZHRoOiAxMDAlO1xcclxcbiAgaGVpZ2h0OiAxMDAlO1xcclxcbiAgZGlzcGxheTogZmxleDtcXHJcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxyXFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXHJcXG4gIGZvbnQtc2l6ZTogMjRweDtcXHJcXG59XFxyXFxuXFxyXFxuLmltYWdlLWNvbnRhaW5lciB7XFxyXFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxyXFxufVxcclxcblxcclxcbi5pbWFnZS1jb250YWluZXI6OmFmdGVyIHtcXHJcXG4gIGNvbnRlbnQ6ICcnO1xcclxcbiAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbiAgYm90dG9tOiAwO1xcclxcbiAgbGVmdDogMDtcXHJcXG4gIHdpZHRoOiAxMDAlO1xcclxcbiAgaGVpZ2h0OiAyMDBweDtcXHJcXG4gIGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudCh0byBib3R0b20sIHJnYmEoMCwgMCwgMCwgMCkgMCUsIHJnYmEoMCwgMCwgMCwgMC41KSAxMDAlKTtcXHJcXG4gIHBvaW50ZXItZXZlbnRzOiBub25lO1xcclxcbn1cXHJcXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIiwiLy8gSW1wb3J0c1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18gZnJvbSBcIi4uLy4uLy4uL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL3NvdXJjZU1hcHMuanNcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uLy4uLy4uL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18pO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIGAuZmxpY2tpbmctdmlld3BvcnQge1xuICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gIG92ZXJmbG93OiBoaWRkZW47XG59XG5cbi5mbGlja2luZy12aWV3cG9ydC52ZXJ0aWNhbCB7XG4gIGRpc3BsYXk6IGlubGluZS1mbGV4O1xufVxuXG4uZmxpY2tpbmctdmlld3BvcnQudmVydGljYWwgPiAuZmxpY2tpbmctY2FtZXJhIHtcbiAgZGlzcGxheTogaW5saW5lLWZsZXg7XG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG59XG5cbi5mbGlja2luZy12aWV3cG9ydC5mbGlja2luZy1oaWRkZW4gPiAuZmxpY2tpbmctY2FtZXJhID4gKiB7XG4gIHZpc2liaWxpdHk6IGhpZGRlbjtcbn1cblxuLmZsaWNraW5nLWNhbWVyYSB7XG4gIHdpZHRoOiAxMDAlO1xuICBoZWlnaHQ6IDEwMCU7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgZmxleC1kaXJlY3Rpb246IHJvdztcbiAgei1pbmRleDogMTtcbiAgd2lsbC1jaGFuZ2U6IHRyYW5zZm9ybTtcbn1cblxuLmZsaWNraW5nLWNhbWVyYSA+ICoge1xuICBmbGV4LXNocmluazogMDtcbn1cbmAsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovLy4vbm9kZV9tb2R1bGVzL0BlZ2pzL3ByZWFjdC1mbGlja2luZy9kaXN0L2ZsaWNraW5nLmNzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQTtFQUNFLGtCQUFrQjtFQUNsQixnQkFBZ0I7QUFDbEI7O0FBRUE7RUFHRSxvQkFBb0I7QUFDdEI7O0FBRUE7RUFHRSxvQkFBb0I7RUFJWixzQkFBc0I7QUFDaEM7O0FBRUE7RUFDRSxrQkFBa0I7QUFDcEI7O0FBRUE7RUFDRSxXQUFXO0VBQ1gsWUFBWTtFQUdaLGFBQWE7RUFDYixrQkFBa0I7RUFJVixtQkFBbUI7RUFDM0IsVUFBVTtFQUNWLHNCQUFzQjtBQUN4Qjs7QUFFQTtFQUVNLGNBQWM7QUFDcEJcIixcInNvdXJjZXNDb250ZW50XCI6W1wiLmZsaWNraW5nLXZpZXdwb3J0IHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxufVxcblxcbi5mbGlja2luZy12aWV3cG9ydC52ZXJ0aWNhbCB7XFxuICBkaXNwbGF5OiAtd2Via2l0LWlubGluZS1ib3g7XFxuICBkaXNwbGF5OiAtbXMtaW5saW5lLWZsZXhib3g7XFxuICBkaXNwbGF5OiBpbmxpbmUtZmxleDtcXG59XFxuXFxuLmZsaWNraW5nLXZpZXdwb3J0LnZlcnRpY2FsID4gLmZsaWNraW5nLWNhbWVyYSB7XFxuICBkaXNwbGF5OiAtd2Via2l0LWlubGluZS1ib3g7XFxuICBkaXNwbGF5OiAtbXMtaW5saW5lLWZsZXhib3g7XFxuICBkaXNwbGF5OiBpbmxpbmUtZmxleDtcXG4gIC13ZWJraXQtYm94LW9yaWVudDogdmVydGljYWw7XFxuICAtd2Via2l0LWJveC1kaXJlY3Rpb246IG5vcm1hbDtcXG4gICAgICAtbXMtZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gICAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG59XFxuXFxuLmZsaWNraW5nLXZpZXdwb3J0LmZsaWNraW5nLWhpZGRlbiA+IC5mbGlja2luZy1jYW1lcmEgPiAqIHtcXG4gIHZpc2liaWxpdHk6IGhpZGRlbjtcXG59XFxuXFxuLmZsaWNraW5nLWNhbWVyYSB7XFxuICB3aWR0aDogMTAwJTtcXG4gIGhlaWdodDogMTAwJTtcXG4gIGRpc3BsYXk6IC13ZWJraXQtYm94O1xcbiAgZGlzcGxheTogLW1zLWZsZXhib3g7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgLXdlYmtpdC1ib3gtb3JpZW50OiBob3Jpem9udGFsO1xcbiAgLXdlYmtpdC1ib3gtZGlyZWN0aW9uOiBub3JtYWw7XFxuICAgICAgLW1zLWZsZXgtZGlyZWN0aW9uOiByb3c7XFxuICAgICAgICAgIGZsZXgtZGlyZWN0aW9uOiByb3c7XFxuICB6LWluZGV4OiAxO1xcbiAgd2lsbC1jaGFuZ2U6IHRyYW5zZm9ybTtcXG59XFxuXFxuLmZsaWNraW5nLWNhbWVyYSA+ICoge1xcbiAgLW1zLWZsZXgtbmVnYXRpdmU6IDA7XFxuICAgICAgZmxleC1zaHJpbms6IDA7XFxufVxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLypcbiAgTUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAgQXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcpIHtcbiAgdmFyIGxpc3QgPSBbXTtcblxuICAvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXG4gIGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHZhciBjb250ZW50ID0gXCJcIjtcbiAgICAgIHZhciBuZWVkTGF5ZXIgPSB0eXBlb2YgaXRlbVs1XSAhPT0gXCJ1bmRlZmluZWRcIjtcbiAgICAgIGlmIChpdGVtWzRdKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJAc3VwcG9ydHMgKFwiLmNvbmNhdChpdGVtWzRdLCBcIikge1wiKTtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVtWzJdKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJAbWVkaWEgXCIuY29uY2F0KGl0ZW1bMl0sIFwiIHtcIik7XG4gICAgICB9XG4gICAgICBpZiAobmVlZExheWVyKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJAbGF5ZXJcIi5jb25jYXQoaXRlbVs1XS5sZW5ndGggPiAwID8gXCIgXCIuY29uY2F0KGl0ZW1bNV0pIDogXCJcIiwgXCIge1wiKTtcbiAgICAgIH1cbiAgICAgIGNvbnRlbnQgKz0gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtKTtcbiAgICAgIGlmIChuZWVkTGF5ZXIpIHtcbiAgICAgICAgY29udGVudCArPSBcIn1cIjtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVtWzJdKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJ9XCI7XG4gICAgICB9XG4gICAgICBpZiAoaXRlbVs0XSkge1xuICAgICAgICBjb250ZW50ICs9IFwifVwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfSkuam9pbihcIlwiKTtcbiAgfTtcblxuICAvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuICBsaXN0LmkgPSBmdW5jdGlvbiBpKG1vZHVsZXMsIG1lZGlhLCBkZWR1cGUsIHN1cHBvcnRzLCBsYXllcikge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgbW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgdW5kZWZpbmVkXV07XG4gICAgfVxuICAgIHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG4gICAgaWYgKGRlZHVwZSkge1xuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCB0aGlzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIHZhciBpZCA9IHRoaXNba11bMF07XG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIF9rID0gMDsgX2sgPCBtb2R1bGVzLmxlbmd0aDsgX2srKykge1xuICAgICAgdmFyIGl0ZW0gPSBbXS5jb25jYXQobW9kdWxlc1tfa10pO1xuICAgICAgaWYgKGRlZHVwZSAmJiBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBsYXllciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBpZiAodHlwZW9mIGl0ZW1bNV0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICBpdGVtWzVdID0gbGF5ZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbVsxXSA9IFwiQGxheWVyXCIuY29uY2F0KGl0ZW1bNV0ubGVuZ3RoID4gMCA/IFwiIFwiLmNvbmNhdChpdGVtWzVdKSA6IFwiXCIsIFwiIHtcIikuY29uY2F0KGl0ZW1bMV0sIFwifVwiKTtcbiAgICAgICAgICBpdGVtWzVdID0gbGF5ZXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChtZWRpYSkge1xuICAgICAgICBpZiAoIWl0ZW1bMl0pIHtcbiAgICAgICAgICBpdGVtWzJdID0gbWVkaWE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbVsxXSA9IFwiQG1lZGlhIFwiLmNvbmNhdChpdGVtWzJdLCBcIiB7XCIpLmNvbmNhdChpdGVtWzFdLCBcIn1cIik7XG4gICAgICAgICAgaXRlbVsyXSA9IG1lZGlhO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc3VwcG9ydHMpIHtcbiAgICAgICAgaWYgKCFpdGVtWzRdKSB7XG4gICAgICAgICAgaXRlbVs0XSA9IFwiXCIuY29uY2F0KHN1cHBvcnRzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtWzFdID0gXCJAc3VwcG9ydHMgKFwiLmNvbmNhdChpdGVtWzRdLCBcIikge1wiKS5jb25jYXQoaXRlbVsxXSwgXCJ9XCIpO1xuICAgICAgICAgIGl0ZW1bNF0gPSBzdXBwb3J0cztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGlzdC5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGxpc3Q7XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gIHZhciBjb250ZW50ID0gaXRlbVsxXTtcbiAgdmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuICBpZiAoIWNzc01hcHBpbmcpIHtcbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuICBpZiAodHlwZW9mIGJ0b2EgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShjc3NNYXBwaW5nKSkpKTtcbiAgICB2YXIgZGF0YSA9IFwic291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsXCIuY29uY2F0KGJhc2U2NCk7XG4gICAgdmFyIHNvdXJjZU1hcHBpbmcgPSBcIi8qIyBcIi5jb25jYXQoZGF0YSwgXCIgKi9cIik7XG4gICAgcmV0dXJuIFtjb250ZW50XS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKFwiXFxuXCIpO1xuICB9XG4gIHJldHVybiBbY29udGVudF0uam9pbihcIlxcblwiKTtcbn07IiwidmFyIG4sbCx1LHQsaSxvLHIsZixlLGMscyxhLGg9e30scD1bXSx2PS9hY2l0fGV4KD86c3xnfG58cHwkKXxycGh8Z3JpZHxvd3N8bW5jfG50d3xpbmVbY2hdfHpvb3xeb3JkfGl0ZXJhL2kseT1BcnJheS5pc0FycmF5O2Z1bmN0aW9uIGQobixsKXtmb3IodmFyIHUgaW4gbCluW3VdPWxbdV07cmV0dXJuIG59ZnVuY3Rpb24gdyhuKXt2YXIgbD1uLnBhcmVudE5vZGU7bCYmbC5yZW1vdmVDaGlsZChuKX1mdW5jdGlvbiBfKGwsdSx0KXt2YXIgaSxvLHIsZj17fTtmb3IociBpbiB1KVwia2V5XCI9PXI/aT11W3JdOlwicmVmXCI9PXI/bz11W3JdOmZbcl09dVtyXTtpZihhcmd1bWVudHMubGVuZ3RoPjImJihmLmNoaWxkcmVuPWFyZ3VtZW50cy5sZW5ndGg+Mz9uLmNhbGwoYXJndW1lbnRzLDIpOnQpLFwiZnVuY3Rpb25cIj09dHlwZW9mIGwmJm51bGwhPWwuZGVmYXVsdFByb3BzKWZvcihyIGluIGwuZGVmYXVsdFByb3BzKXZvaWQgMD09PWZbcl0mJihmW3JdPWwuZGVmYXVsdFByb3BzW3JdKTtyZXR1cm4gZyhsLGYsaSxvLG51bGwpfWZ1bmN0aW9uIGcobix0LGksbyxyKXt2YXIgZj17dHlwZTpuLHByb3BzOnQsa2V5OmkscmVmOm8sX19rOm51bGwsX186bnVsbCxfX2I6MCxfX2U6bnVsbCxfX2Q6dm9pZCAwLF9fYzpudWxsLGNvbnN0cnVjdG9yOnZvaWQgMCxfX3Y6bnVsbD09cj8rK3U6cixfX2k6LTEsX191OjB9O3JldHVybiBudWxsPT1yJiZudWxsIT1sLnZub2RlJiZsLnZub2RlKGYpLGZ9ZnVuY3Rpb24gbSgpe3JldHVybntjdXJyZW50Om51bGx9fWZ1bmN0aW9uIGsobil7cmV0dXJuIG4uY2hpbGRyZW59ZnVuY3Rpb24gYihuLGwpe3RoaXMucHJvcHM9bix0aGlzLmNvbnRleHQ9bH1mdW5jdGlvbiB4KG4sbCl7aWYobnVsbD09bClyZXR1cm4gbi5fXz94KG4uX18sbi5fX2krMSk6bnVsbDtmb3IodmFyIHU7bDxuLl9fay5sZW5ndGg7bCsrKWlmKG51bGwhPSh1PW4uX19rW2xdKSYmbnVsbCE9dS5fX2UpcmV0dXJuIHUuX19lO3JldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIG4udHlwZT94KG4pOm51bGx9ZnVuY3Rpb24gQyhuKXt2YXIgbCx1O2lmKG51bGwhPShuPW4uX18pJiZudWxsIT1uLl9fYyl7Zm9yKG4uX19lPW4uX19jLmJhc2U9bnVsbCxsPTA7bDxuLl9fay5sZW5ndGg7bCsrKWlmKG51bGwhPSh1PW4uX19rW2xdKSYmbnVsbCE9dS5fX2Upe24uX19lPW4uX19jLmJhc2U9dS5fX2U7YnJlYWt9cmV0dXJuIEMobil9fWZ1bmN0aW9uIE0obil7KCFuLl9fZCYmKG4uX19kPSEwKSYmaS5wdXNoKG4pJiYhUC5fX3IrK3x8byE9PWwuZGVib3VuY2VSZW5kZXJpbmcpJiYoKG89bC5kZWJvdW5jZVJlbmRlcmluZyl8fHIpKFApfWZ1bmN0aW9uIFAoKXt2YXIgbix1LHQsbyxyLGUsYyxzO2ZvcihpLnNvcnQoZik7bj1pLnNoaWZ0KCk7KW4uX19kJiYodT1pLmxlbmd0aCxvPXZvaWQgMCxlPShyPSh0PW4pLl9fdikuX19lLGM9W10scz1bXSx0Ll9fUCYmKChvPWQoe30scikpLl9fdj1yLl9fdisxLGwudm5vZGUmJmwudm5vZGUobyksTyh0Ll9fUCxvLHIsdC5fX24sdC5fX1AubmFtZXNwYWNlVVJJLDMyJnIuX191P1tlXTpudWxsLGMsbnVsbD09ZT94KHIpOmUsISEoMzImci5fX3UpLHMpLG8uX192PXIuX192LG8uX18uX19rW28uX19pXT1vLGooYyxvLHMpLG8uX19lIT1lJiZDKG8pKSxpLmxlbmd0aD51JiZpLnNvcnQoZikpO1AuX19yPTB9ZnVuY3Rpb24gUyhuLGwsdSx0LGksbyxyLGYsZSxjLHMpe3ZhciBhLHYseSxkLHcsXz10JiZ0Ll9fa3x8cCxnPWwubGVuZ3RoO2Zvcih1Ll9fZD1lLCQodSxsLF8pLGU9dS5fX2QsYT0wO2E8ZzthKyspbnVsbCE9KHk9dS5fX2tbYV0pJiZcImJvb2xlYW5cIiE9dHlwZW9mIHkmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHkmJih2PS0xPT09eS5fX2k/aDpfW3kuX19pXXx8aCx5Ll9faT1hLE8obix5LHYsaSxvLHIsZixlLGMscyksZD15Ll9fZSx5LnJlZiYmdi5yZWYhPXkucmVmJiYodi5yZWYmJk4odi5yZWYsbnVsbCx5KSxzLnB1c2goeS5yZWYseS5fX2N8fGQseSkpLG51bGw9PXcmJm51bGwhPWQmJih3PWQpLDY1NTM2JnkuX191fHx2Ll9faz09PXkuX19rP2U9SSh5LGUsbik6XCJmdW5jdGlvblwiPT10eXBlb2YgeS50eXBlJiZ2b2lkIDAhPT15Ll9fZD9lPXkuX19kOmQmJihlPWQubmV4dFNpYmxpbmcpLHkuX19kPXZvaWQgMCx5Ll9fdSY9LTE5NjYwOSk7dS5fX2Q9ZSx1Ll9fZT13fWZ1bmN0aW9uICQobixsLHUpe3ZhciB0LGksbyxyLGYsZT1sLmxlbmd0aCxjPXUubGVuZ3RoLHM9YyxhPTA7Zm9yKG4uX19rPVtdLHQ9MDt0PGU7dCsrKXI9dCthLG51bGwhPShpPW4uX19rW3RdPW51bGw9PShpPWxbdF0pfHxcImJvb2xlYW5cIj09dHlwZW9mIGl8fFwiZnVuY3Rpb25cIj09dHlwZW9mIGk/bnVsbDpcInN0cmluZ1wiPT10eXBlb2YgaXx8XCJudW1iZXJcIj09dHlwZW9mIGl8fFwiYmlnaW50XCI9PXR5cGVvZiBpfHxpLmNvbnN0cnVjdG9yPT1TdHJpbmc/ZyhudWxsLGksbnVsbCxudWxsLG51bGwpOnkoaSk/ZyhrLHtjaGlsZHJlbjppfSxudWxsLG51bGwsbnVsbCk6dm9pZCAwPT09aS5jb25zdHJ1Y3RvciYmaS5fX2I+MD9nKGkudHlwZSxpLnByb3BzLGkua2V5LGkucmVmP2kucmVmOm51bGwsaS5fX3YpOmkpPyhpLl9fPW4saS5fX2I9bi5fX2IrMSxmPUwoaSx1LHIscyksaS5fX2k9ZixvPW51bGwsLTEhPT1mJiYocy0tLChvPXVbZl0pJiYoby5fX3V8PTEzMTA3MikpLG51bGw9PW98fG51bGw9PT1vLl9fdj8oLTE9PWYmJmEtLSxcImZ1bmN0aW9uXCIhPXR5cGVvZiBpLnR5cGUmJihpLl9fdXw9NjU1MzYpKTpmIT09ciYmKGY9PXItMT9hPWYtcjpmPT1yKzE/YSsrOmY+cj9zPmUtcj9hKz1mLXI6YS0tOmY8ciYmYSsrLGYhPT10K2EmJihpLl9fdXw9NjU1MzYpKSk6KG89dVtyXSkmJm51bGw9PW8ua2V5JiZvLl9fZSYmMD09KDEzMTA3MiZvLl9fdSkmJihvLl9fZT09bi5fX2QmJihuLl9fZD14KG8pKSxWKG8sbywhMSksdVtyXT1udWxsLHMtLSk7aWYocylmb3IodD0wO3Q8Yzt0KyspbnVsbCE9KG89dVt0XSkmJjA9PSgxMzEwNzImby5fX3UpJiYoby5fX2U9PW4uX19kJiYobi5fX2Q9eChvKSksVihvLG8pKX1mdW5jdGlvbiBJKG4sbCx1KXt2YXIgdCxpO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIG4udHlwZSl7Zm9yKHQ9bi5fX2ssaT0wO3QmJmk8dC5sZW5ndGg7aSsrKXRbaV0mJih0W2ldLl9fPW4sbD1JKHRbaV0sbCx1KSk7cmV0dXJuIGx9bi5fX2UhPWwmJihsJiZuLnR5cGUmJiF1LmNvbnRhaW5zKGwpJiYobD14KG4pKSx1Lmluc2VydEJlZm9yZShuLl9fZSxsfHxudWxsKSxsPW4uX19lKTtkb3tsPWwmJmwubmV4dFNpYmxpbmd9d2hpbGUobnVsbCE9bCYmOD09PWwubm9kZVR5cGUpO3JldHVybiBsfWZ1bmN0aW9uIEgobixsKXtyZXR1cm4gbD1sfHxbXSxudWxsPT1ufHxcImJvb2xlYW5cIj09dHlwZW9mIG58fCh5KG4pP24uc29tZShmdW5jdGlvbihuKXtIKG4sbCl9KTpsLnB1c2gobikpLGx9ZnVuY3Rpb24gTChuLGwsdSx0KXt2YXIgaT1uLmtleSxvPW4udHlwZSxyPXUtMSxmPXUrMSxlPWxbdV07aWYobnVsbD09PWV8fGUmJmk9PWUua2V5JiZvPT09ZS50eXBlJiYwPT0oMTMxMDcyJmUuX191KSlyZXR1cm4gdTtpZih0PihudWxsIT1lJiYwPT0oMTMxMDcyJmUuX191KT8xOjApKWZvcig7cj49MHx8ZjxsLmxlbmd0aDspe2lmKHI+PTApe2lmKChlPWxbcl0pJiYwPT0oMTMxMDcyJmUuX191KSYmaT09ZS5rZXkmJm89PT1lLnR5cGUpcmV0dXJuIHI7ci0tfWlmKGY8bC5sZW5ndGgpe2lmKChlPWxbZl0pJiYwPT0oMTMxMDcyJmUuX191KSYmaT09ZS5rZXkmJm89PT1lLnR5cGUpcmV0dXJuIGY7ZisrfX1yZXR1cm4tMX1mdW5jdGlvbiBUKG4sbCx1KXtcIi1cIj09PWxbMF0/bi5zZXRQcm9wZXJ0eShsLG51bGw9PXU/XCJcIjp1KTpuW2xdPW51bGw9PXU/XCJcIjpcIm51bWJlclwiIT10eXBlb2YgdXx8di50ZXN0KGwpP3U6dStcInB4XCJ9ZnVuY3Rpb24gQShuLGwsdSx0LGkpe3ZhciBvO246aWYoXCJzdHlsZVwiPT09bClpZihcInN0cmluZ1wiPT10eXBlb2YgdSluLnN0eWxlLmNzc1RleHQ9dTtlbHNle2lmKFwic3RyaW5nXCI9PXR5cGVvZiB0JiYobi5zdHlsZS5jc3NUZXh0PXQ9XCJcIiksdClmb3IobCBpbiB0KXUmJmwgaW4gdXx8VChuLnN0eWxlLGwsXCJcIik7aWYodSlmb3IobCBpbiB1KXQmJnVbbF09PT10W2xdfHxUKG4uc3R5bGUsbCx1W2xdKX1lbHNlIGlmKFwib1wiPT09bFswXSYmXCJuXCI9PT1sWzFdKW89bCE9PShsPWwucmVwbGFjZSgvKFBvaW50ZXJDYXB0dXJlKSR8Q2FwdHVyZSQvaSxcIiQxXCIpKSxsPWwudG9Mb3dlckNhc2UoKWluIG58fFwib25Gb2N1c091dFwiPT09bHx8XCJvbkZvY3VzSW5cIj09PWw/bC50b0xvd2VyQ2FzZSgpLnNsaWNlKDIpOmwuc2xpY2UoMiksbi5sfHwobi5sPXt9KSxuLmxbbCtvXT11LHU/dD91LnU9dC51Oih1LnU9ZSxuLmFkZEV2ZW50TGlzdGVuZXIobCxvP3M6YyxvKSk6bi5yZW1vdmVFdmVudExpc3RlbmVyKGwsbz9zOmMsbyk7ZWxzZXtpZihcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI9PWkpbD1sLnJlcGxhY2UoL3hsaW5rKEh8OmgpLyxcImhcIikucmVwbGFjZSgvc05hbWUkLyxcInNcIik7ZWxzZSBpZihcIndpZHRoXCIhPWwmJlwiaGVpZ2h0XCIhPWwmJlwiaHJlZlwiIT1sJiZcImxpc3RcIiE9bCYmXCJmb3JtXCIhPWwmJlwidGFiSW5kZXhcIiE9bCYmXCJkb3dubG9hZFwiIT1sJiZcInJvd1NwYW5cIiE9bCYmXCJjb2xTcGFuXCIhPWwmJlwicm9sZVwiIT1sJiZcInBvcG92ZXJcIiE9bCYmbCBpbiBuKXRyeXtuW2xdPW51bGw9PXU/XCJcIjp1O2JyZWFrIG59Y2F0Y2gobil7fVwiZnVuY3Rpb25cIj09dHlwZW9mIHV8fChudWxsPT11fHwhMT09PXUmJlwiLVwiIT09bFs0XT9uLnJlbW92ZUF0dHJpYnV0ZShsKTpuLnNldEF0dHJpYnV0ZShsLFwicG9wb3ZlclwiPT1sJiYxPT11P1wiXCI6dSkpfX1mdW5jdGlvbiBGKG4pe3JldHVybiBmdW5jdGlvbih1KXtpZih0aGlzLmwpe3ZhciB0PXRoaXMubFt1LnR5cGUrbl07aWYobnVsbD09dS50KXUudD1lKys7ZWxzZSBpZih1LnQ8dC51KXJldHVybjtyZXR1cm4gdChsLmV2ZW50P2wuZXZlbnQodSk6dSl9fX1mdW5jdGlvbiBPKG4sdSx0LGksbyxyLGYsZSxjLHMpe3ZhciBhLGgscCx2LHcsXyxnLG0seCxDLE0sUCwkLEksSCxMLFQ9dS50eXBlO2lmKHZvaWQgMCE9PXUuY29uc3RydWN0b3IpcmV0dXJuIG51bGw7MTI4JnQuX191JiYoYz0hISgzMiZ0Ll9fdSkscj1bZT11Ll9fZT10Ll9fZV0pLChhPWwuX19iKSYmYSh1KTtuOmlmKFwiZnVuY3Rpb25cIj09dHlwZW9mIFQpdHJ5e2lmKG09dS5wcm9wcyx4PVwicHJvdG90eXBlXCJpbiBUJiZULnByb3RvdHlwZS5yZW5kZXIsQz0oYT1ULmNvbnRleHRUeXBlKSYmaVthLl9fY10sTT1hP0M/Qy5wcm9wcy52YWx1ZTphLl9fOmksdC5fX2M/Zz0oaD11Ll9fYz10Ll9fYykuX189aC5fX0U6KHg/dS5fX2M9aD1uZXcgVChtLE0pOih1Ll9fYz1oPW5ldyBiKG0sTSksaC5jb25zdHJ1Y3Rvcj1ULGgucmVuZGVyPXEpLEMmJkMuc3ViKGgpLGgucHJvcHM9bSxoLnN0YXRlfHwoaC5zdGF0ZT17fSksaC5jb250ZXh0PU0saC5fX249aSxwPWguX19kPSEwLGguX19oPVtdLGguX3NiPVtdKSx4JiZudWxsPT1oLl9fcyYmKGguX19zPWguc3RhdGUpLHgmJm51bGwhPVQuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzJiYoaC5fX3M9PWguc3RhdGUmJihoLl9fcz1kKHt9LGguX19zKSksZChoLl9fcyxULmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhtLGguX19zKSkpLHY9aC5wcm9wcyx3PWguc3RhdGUsaC5fX3Y9dSxwKXgmJm51bGw9PVQuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzJiZudWxsIT1oLmNvbXBvbmVudFdpbGxNb3VudCYmaC5jb21wb25lbnRXaWxsTW91bnQoKSx4JiZudWxsIT1oLmNvbXBvbmVudERpZE1vdW50JiZoLl9faC5wdXNoKGguY29tcG9uZW50RGlkTW91bnQpO2Vsc2V7aWYoeCYmbnVsbD09VC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMmJm0hPT12JiZudWxsIT1oLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMmJmguY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhtLE0pLCFoLl9fZSYmKG51bGwhPWguc2hvdWxkQ29tcG9uZW50VXBkYXRlJiYhMT09PWguc2hvdWxkQ29tcG9uZW50VXBkYXRlKG0saC5fX3MsTSl8fHUuX192PT09dC5fX3YpKXtmb3IodS5fX3YhPT10Ll9fdiYmKGgucHJvcHM9bSxoLnN0YXRlPWguX19zLGguX19kPSExKSx1Ll9fZT10Ll9fZSx1Ll9faz10Ll9fayx1Ll9fay5mb3JFYWNoKGZ1bmN0aW9uKG4pe24mJihuLl9fPXUpfSksUD0wO1A8aC5fc2IubGVuZ3RoO1ArKyloLl9faC5wdXNoKGguX3NiW1BdKTtoLl9zYj1bXSxoLl9faC5sZW5ndGgmJmYucHVzaChoKTticmVhayBufW51bGwhPWguY29tcG9uZW50V2lsbFVwZGF0ZSYmaC5jb21wb25lbnRXaWxsVXBkYXRlKG0saC5fX3MsTSkseCYmbnVsbCE9aC5jb21wb25lbnREaWRVcGRhdGUmJmguX19oLnB1c2goZnVuY3Rpb24oKXtoLmNvbXBvbmVudERpZFVwZGF0ZSh2LHcsXyl9KX1pZihoLmNvbnRleHQ9TSxoLnByb3BzPW0saC5fX1A9bixoLl9fZT0hMSwkPWwuX19yLEk9MCx4KXtmb3IoaC5zdGF0ZT1oLl9fcyxoLl9fZD0hMSwkJiYkKHUpLGE9aC5yZW5kZXIoaC5wcm9wcyxoLnN0YXRlLGguY29udGV4dCksSD0wO0g8aC5fc2IubGVuZ3RoO0grKyloLl9faC5wdXNoKGguX3NiW0hdKTtoLl9zYj1bXX1lbHNlIGRve2guX19kPSExLCQmJiQodSksYT1oLnJlbmRlcihoLnByb3BzLGguc3RhdGUsaC5jb250ZXh0KSxoLnN0YXRlPWguX19zfXdoaWxlKGguX19kJiYrK0k8MjUpO2guc3RhdGU9aC5fX3MsbnVsbCE9aC5nZXRDaGlsZENvbnRleHQmJihpPWQoZCh7fSxpKSxoLmdldENoaWxkQ29udGV4dCgpKSkseCYmIXAmJm51bGwhPWguZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUmJihfPWguZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUodix3KSksUyhuLHkoTD1udWxsIT1hJiZhLnR5cGU9PT1rJiZudWxsPT1hLmtleT9hLnByb3BzLmNoaWxkcmVuOmEpP0w6W0xdLHUsdCxpLG8scixmLGUsYyxzKSxoLmJhc2U9dS5fX2UsdS5fX3UmPS0xNjEsaC5fX2gubGVuZ3RoJiZmLnB1c2goaCksZyYmKGguX19FPWguX189bnVsbCl9Y2F0Y2gobil7aWYodS5fX3Y9bnVsbCxjfHxudWxsIT1yKXtmb3IodS5fX3V8PWM/MTYwOjMyO2UmJjg9PT1lLm5vZGVUeXBlJiZlLm5leHRTaWJsaW5nOyllPWUubmV4dFNpYmxpbmc7cltyLmluZGV4T2YoZSldPW51bGwsdS5fX2U9ZX1lbHNlIHUuX19lPXQuX19lLHUuX19rPXQuX19rO2wuX19lKG4sdSx0KX1lbHNlIG51bGw9PXImJnUuX192PT09dC5fX3Y/KHUuX19rPXQuX19rLHUuX19lPXQuX19lKTp1Ll9fZT16KHQuX19lLHUsdCxpLG8scixmLGMscyk7KGE9bC5kaWZmZWQpJiZhKHUpfWZ1bmN0aW9uIGoobix1LHQpe3UuX19kPXZvaWQgMDtmb3IodmFyIGk9MDtpPHQubGVuZ3RoO2krKylOKHRbaV0sdFsrK2ldLHRbKytpXSk7bC5fX2MmJmwuX19jKHUsbiksbi5zb21lKGZ1bmN0aW9uKHUpe3RyeXtuPXUuX19oLHUuX19oPVtdLG4uc29tZShmdW5jdGlvbihuKXtuLmNhbGwodSl9KX1jYXRjaChuKXtsLl9fZShuLHUuX192KX19KX1mdW5jdGlvbiB6KGwsdSx0LGksbyxyLGYsZSxjKXt2YXIgcyxhLHAsdixkLF8sZyxtPXQucHJvcHMsaz11LnByb3BzLGI9dS50eXBlO2lmKFwic3ZnXCI9PT1iP289XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiOlwibWF0aFwiPT09Yj9vPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTFwiOm98fChvPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiKSxudWxsIT1yKWZvcihzPTA7czxyLmxlbmd0aDtzKyspaWYoKGQ9cltzXSkmJlwic2V0QXR0cmlidXRlXCJpbiBkPT0hIWImJihiP2QubG9jYWxOYW1lPT09YjozPT09ZC5ub2RlVHlwZSkpe2w9ZCxyW3NdPW51bGw7YnJlYWt9aWYobnVsbD09bCl7aWYobnVsbD09PWIpcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGspO2w9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG8sYixrLmlzJiZrKSxyPW51bGwsZT0hMX1pZihudWxsPT09YiltPT09a3x8ZSYmbC5kYXRhPT09a3x8KGwuZGF0YT1rKTtlbHNle2lmKHI9ciYmbi5jYWxsKGwuY2hpbGROb2RlcyksbT10LnByb3BzfHxoLCFlJiZudWxsIT1yKWZvcihtPXt9LHM9MDtzPGwuYXR0cmlidXRlcy5sZW5ndGg7cysrKW1bKGQ9bC5hdHRyaWJ1dGVzW3NdKS5uYW1lXT1kLnZhbHVlO2ZvcihzIGluIG0paWYoZD1tW3NdLFwiY2hpbGRyZW5cIj09cyk7ZWxzZSBpZihcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI9PXMpcD1kO2Vsc2UgaWYoXCJrZXlcIiE9PXMmJiEocyBpbiBrKSl7aWYoXCJ2YWx1ZVwiPT1zJiZcImRlZmF1bHRWYWx1ZVwiaW4ga3x8XCJjaGVja2VkXCI9PXMmJlwiZGVmYXVsdENoZWNrZWRcImluIGspY29udGludWU7QShsLHMsbnVsbCxkLG8pfWZvcihzIGluIGspZD1rW3NdLFwiY2hpbGRyZW5cIj09cz92PWQ6XCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiPT1zP2E9ZDpcInZhbHVlXCI9PXM/Xz1kOlwiY2hlY2tlZFwiPT1zP2c9ZDpcImtleVwiPT09c3x8ZSYmXCJmdW5jdGlvblwiIT10eXBlb2YgZHx8bVtzXT09PWR8fEEobCxzLGQsbVtzXSxvKTtpZihhKWV8fHAmJihhLl9faHRtbD09PXAuX19odG1sfHxhLl9faHRtbD09PWwuaW5uZXJIVE1MKXx8KGwuaW5uZXJIVE1MPWEuX19odG1sKSx1Ll9faz1bXTtlbHNlIGlmKHAmJihsLmlubmVySFRNTD1cIlwiKSxTKGwseSh2KT92Olt2XSx1LHQsaSxcImZvcmVpZ25PYmplY3RcIj09PWI/XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCI6byxyLGYscj9yWzBdOnQuX19rJiZ4KHQsMCksZSxjKSxudWxsIT1yKWZvcihzPXIubGVuZ3RoO3MtLTspbnVsbCE9cltzXSYmdyhyW3NdKTtlfHwocz1cInZhbHVlXCIsdm9pZCAwIT09XyYmKF8hPT1sW3NdfHxcInByb2dyZXNzXCI9PT1iJiYhX3x8XCJvcHRpb25cIj09PWImJl8hPT1tW3NdKSYmQShsLHMsXyxtW3NdLG8pLHM9XCJjaGVja2VkXCIsdm9pZCAwIT09ZyYmZyE9PWxbc10mJkEobCxzLGcsbVtzXSxvKSl9cmV0dXJuIGx9ZnVuY3Rpb24gTihuLHUsdCl7dHJ5e2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIG4pe3ZhciBpPVwiZnVuY3Rpb25cIj09dHlwZW9mIG4uX191O2kmJm4uX191KCksaSYmbnVsbD09dXx8KG4uX191PW4odSkpfWVsc2Ugbi5jdXJyZW50PXV9Y2F0Y2gobil7bC5fX2Uobix0KX19ZnVuY3Rpb24gVihuLHUsdCl7dmFyIGksbztpZihsLnVubW91bnQmJmwudW5tb3VudChuKSwoaT1uLnJlZikmJihpLmN1cnJlbnQmJmkuY3VycmVudCE9PW4uX19lfHxOKGksbnVsbCx1KSksbnVsbCE9KGk9bi5fX2MpKXtpZihpLmNvbXBvbmVudFdpbGxVbm1vdW50KXRyeXtpLmNvbXBvbmVudFdpbGxVbm1vdW50KCl9Y2F0Y2gobil7bC5fX2Uobix1KX1pLmJhc2U9aS5fX1A9bnVsbH1pZihpPW4uX19rKWZvcihvPTA7bzxpLmxlbmd0aDtvKyspaVtvXSYmVihpW29dLHUsdHx8XCJmdW5jdGlvblwiIT10eXBlb2Ygbi50eXBlKTt0fHxudWxsPT1uLl9fZXx8dyhuLl9fZSksbi5fX2M9bi5fXz1uLl9fZT1uLl9fZD12b2lkIDB9ZnVuY3Rpb24gcShuLGwsdSl7cmV0dXJuIHRoaXMuY29uc3RydWN0b3Iobix1KX1mdW5jdGlvbiBCKHUsdCxpKXt2YXIgbyxyLGYsZTtsLl9fJiZsLl9fKHUsdCkscj0obz1cImZ1bmN0aW9uXCI9PXR5cGVvZiBpKT9udWxsOmkmJmkuX19rfHx0Ll9fayxmPVtdLGU9W10sTyh0LHU9KCFvJiZpfHx0KS5fX2s9XyhrLG51bGwsW3VdKSxyfHxoLGgsdC5uYW1lc3BhY2VVUkksIW8mJmk/W2ldOnI/bnVsbDp0LmZpcnN0Q2hpbGQ/bi5jYWxsKHQuY2hpbGROb2Rlcyk6bnVsbCxmLCFvJiZpP2k6cj9yLl9fZTp0LmZpcnN0Q2hpbGQsbyxlKSxqKGYsdSxlKX1mdW5jdGlvbiBEKG4sbCl7QihuLGwsRCl9ZnVuY3Rpb24gRShsLHUsdCl7dmFyIGksbyxyLGYsZT1kKHt9LGwucHJvcHMpO2ZvcihyIGluIGwudHlwZSYmbC50eXBlLmRlZmF1bHRQcm9wcyYmKGY9bC50eXBlLmRlZmF1bHRQcm9wcyksdSlcImtleVwiPT1yP2k9dVtyXTpcInJlZlwiPT1yP289dVtyXTplW3JdPXZvaWQgMD09PXVbcl0mJnZvaWQgMCE9PWY/ZltyXTp1W3JdO3JldHVybiBhcmd1bWVudHMubGVuZ3RoPjImJihlLmNoaWxkcmVuPWFyZ3VtZW50cy5sZW5ndGg+Mz9uLmNhbGwoYXJndW1lbnRzLDIpOnQpLGcobC50eXBlLGUsaXx8bC5rZXksb3x8bC5yZWYsbnVsbCl9ZnVuY3Rpb24gRyhuLGwpe3ZhciB1PXtfX2M6bD1cIl9fY0NcIithKyssX186bixDb25zdW1lcjpmdW5jdGlvbihuLGwpe3JldHVybiBuLmNoaWxkcmVuKGwpfSxQcm92aWRlcjpmdW5jdGlvbihuKXt2YXIgdSx0O3JldHVybiB0aGlzLmdldENoaWxkQ29udGV4dHx8KHU9W10sKHQ9e30pW2xdPXRoaXMsdGhpcy5nZXRDaGlsZENvbnRleHQ9ZnVuY3Rpb24oKXtyZXR1cm4gdH0sdGhpcy5jb21wb25lbnRXaWxsVW5tb3VudD1mdW5jdGlvbigpe3U9bnVsbH0sdGhpcy5zaG91bGRDb21wb25lbnRVcGRhdGU9ZnVuY3Rpb24obil7dGhpcy5wcm9wcy52YWx1ZSE9PW4udmFsdWUmJnUuc29tZShmdW5jdGlvbihuKXtuLl9fZT0hMCxNKG4pfSl9LHRoaXMuc3ViPWZ1bmN0aW9uKG4pe3UucHVzaChuKTt2YXIgbD1uLmNvbXBvbmVudFdpbGxVbm1vdW50O24uY29tcG9uZW50V2lsbFVubW91bnQ9ZnVuY3Rpb24oKXt1JiZ1LnNwbGljZSh1LmluZGV4T2YobiksMSksbCYmbC5jYWxsKG4pfX0pLG4uY2hpbGRyZW59fTtyZXR1cm4gdS5Qcm92aWRlci5fXz11LkNvbnN1bWVyLmNvbnRleHRUeXBlPXV9bj1wLnNsaWNlLGw9e19fZTpmdW5jdGlvbihuLGwsdSx0KXtmb3IodmFyIGksbyxyO2w9bC5fXzspaWYoKGk9bC5fX2MpJiYhaS5fXyl0cnl7aWYoKG89aS5jb25zdHJ1Y3RvcikmJm51bGwhPW8uZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yJiYoaS5zZXRTdGF0ZShvLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvcihuKSkscj1pLl9fZCksbnVsbCE9aS5jb21wb25lbnREaWRDYXRjaCYmKGkuY29tcG9uZW50RGlkQ2F0Y2gobix0fHx7fSkscj1pLl9fZCkscilyZXR1cm4gaS5fX0U9aX1jYXRjaChsKXtuPWx9dGhyb3cgbn19LHU9MCx0PWZ1bmN0aW9uKG4pe3JldHVybiBudWxsIT1uJiZudWxsPT1uLmNvbnN0cnVjdG9yfSxiLnByb3RvdHlwZS5zZXRTdGF0ZT1mdW5jdGlvbihuLGwpe3ZhciB1O3U9bnVsbCE9dGhpcy5fX3MmJnRoaXMuX19zIT09dGhpcy5zdGF0ZT90aGlzLl9fczp0aGlzLl9fcz1kKHt9LHRoaXMuc3RhdGUpLFwiZnVuY3Rpb25cIj09dHlwZW9mIG4mJihuPW4oZCh7fSx1KSx0aGlzLnByb3BzKSksbiYmZCh1LG4pLG51bGwhPW4mJnRoaXMuX192JiYobCYmdGhpcy5fc2IucHVzaChsKSxNKHRoaXMpKX0sYi5wcm90b3R5cGUuZm9yY2VVcGRhdGU9ZnVuY3Rpb24obil7dGhpcy5fX3YmJih0aGlzLl9fZT0hMCxuJiZ0aGlzLl9faC5wdXNoKG4pLE0odGhpcykpfSxiLnByb3RvdHlwZS5yZW5kZXI9ayxpPVtdLHI9XCJmdW5jdGlvblwiPT10eXBlb2YgUHJvbWlzZT9Qcm9taXNlLnByb3RvdHlwZS50aGVuLmJpbmQoUHJvbWlzZS5yZXNvbHZlKCkpOnNldFRpbWVvdXQsZj1mdW5jdGlvbihuLGwpe3JldHVybiBuLl9fdi5fX2ItbC5fX3YuX19ifSxQLl9fcj0wLGU9MCxjPUYoITEpLHM9RighMCksYT0wO2V4cG9ydHtiIGFzIENvbXBvbmVudCxrIGFzIEZyYWdtZW50LEUgYXMgY2xvbmVFbGVtZW50LEcgYXMgY3JlYXRlQ29udGV4dCxfIGFzIGNyZWF0ZUVsZW1lbnQsbSBhcyBjcmVhdGVSZWYsXyBhcyBoLEQgYXMgaHlkcmF0ZSx0IGFzIGlzVmFsaWRFbGVtZW50LGwgYXMgb3B0aW9ucyxCIGFzIHJlbmRlcixIIGFzIHRvQ2hpbGRBcnJheX07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcmVhY3QubW9kdWxlLmpzLm1hcFxuIiwiaW1wb3J0e29wdGlvbnMgYXMgbn1mcm9tXCJwcmVhY3RcIjt2YXIgdCxyLHUsaSxvPTAsZj1bXSxjPW4sZT1jLl9fYixhPWMuX19yLHY9Yy5kaWZmZWQsbD1jLl9fYyxtPWMudW5tb3VudCxzPWMuX187ZnVuY3Rpb24gZChuLHQpe2MuX19oJiZjLl9faChyLG4sb3x8dCksbz0wO3ZhciB1PXIuX19IfHwoci5fX0g9e19fOltdLF9faDpbXX0pO3JldHVybiBuPj11Ll9fLmxlbmd0aCYmdS5fXy5wdXNoKHt9KSx1Ll9fW25dfWZ1bmN0aW9uIGgobil7cmV0dXJuIG89MSxwKEQsbil9ZnVuY3Rpb24gcChuLHUsaSl7dmFyIG89ZCh0KyssMik7aWYoby50PW4sIW8uX19jJiYoby5fXz1baT9pKHUpOkQodm9pZCAwLHUpLGZ1bmN0aW9uKG4pe3ZhciB0PW8uX19OP28uX19OWzBdOm8uX19bMF0scj1vLnQodCxuKTt0IT09ciYmKG8uX19OPVtyLG8uX19bMV1dLG8uX19jLnNldFN0YXRlKHt9KSl9XSxvLl9fYz1yLCFyLnUpKXt2YXIgZj1mdW5jdGlvbihuLHQscil7aWYoIW8uX19jLl9fSClyZXR1cm4hMDt2YXIgdT1vLl9fYy5fX0guX18uZmlsdGVyKGZ1bmN0aW9uKG4pe3JldHVybiEhbi5fX2N9KTtpZih1LmV2ZXJ5KGZ1bmN0aW9uKG4pe3JldHVybiFuLl9fTn0pKXJldHVybiFjfHxjLmNhbGwodGhpcyxuLHQscik7dmFyIGk9ITE7cmV0dXJuIHUuZm9yRWFjaChmdW5jdGlvbihuKXtpZihuLl9fTil7dmFyIHQ9bi5fX1swXTtuLl9fPW4uX19OLG4uX19OPXZvaWQgMCx0IT09bi5fX1swXSYmKGk9ITApfX0pLCEoIWkmJm8uX19jLnByb3BzPT09bikmJighY3x8Yy5jYWxsKHRoaXMsbix0LHIpKX07ci51PSEwO3ZhciBjPXIuc2hvdWxkQ29tcG9uZW50VXBkYXRlLGU9ci5jb21wb25lbnRXaWxsVXBkYXRlO3IuY29tcG9uZW50V2lsbFVwZGF0ZT1mdW5jdGlvbihuLHQscil7aWYodGhpcy5fX2Upe3ZhciB1PWM7Yz12b2lkIDAsZihuLHQsciksYz11fWUmJmUuY2FsbCh0aGlzLG4sdCxyKX0sci5zaG91bGRDb21wb25lbnRVcGRhdGU9Zn1yZXR1cm4gby5fX058fG8uX199ZnVuY3Rpb24geShuLHUpe3ZhciBpPWQodCsrLDMpOyFjLl9fcyYmQyhpLl9fSCx1KSYmKGkuX189bixpLmk9dSxyLl9fSC5fX2gucHVzaChpKSl9ZnVuY3Rpb24gXyhuLHUpe3ZhciBpPWQodCsrLDQpOyFjLl9fcyYmQyhpLl9fSCx1KSYmKGkuX189bixpLmk9dSxyLl9faC5wdXNoKGkpKX1mdW5jdGlvbiBBKG4pe3JldHVybiBvPTUsVChmdW5jdGlvbigpe3JldHVybntjdXJyZW50Om59fSxbXSl9ZnVuY3Rpb24gRihuLHQscil7bz02LF8oZnVuY3Rpb24oKXtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiBuPyhuKHQoKSksZnVuY3Rpb24oKXtyZXR1cm4gbihudWxsKX0pOm4/KG4uY3VycmVudD10KCksZnVuY3Rpb24oKXtyZXR1cm4gbi5jdXJyZW50PW51bGx9KTp2b2lkIDB9LG51bGw9PXI/cjpyLmNvbmNhdChuKSl9ZnVuY3Rpb24gVChuLHIpe3ZhciB1PWQodCsrLDcpO3JldHVybiBDKHUuX19ILHIpJiYodS5fXz1uKCksdS5fX0g9cix1Ll9faD1uKSx1Ll9ffWZ1bmN0aW9uIHEobix0KXtyZXR1cm4gbz04LFQoZnVuY3Rpb24oKXtyZXR1cm4gbn0sdCl9ZnVuY3Rpb24geChuKXt2YXIgdT1yLmNvbnRleHRbbi5fX2NdLGk9ZCh0KyssOSk7cmV0dXJuIGkuYz1uLHU/KG51bGw9PWkuX18mJihpLl9fPSEwLHUuc3ViKHIpKSx1LnByb3BzLnZhbHVlKTpuLl9ffWZ1bmN0aW9uIFAobix0KXtjLnVzZURlYnVnVmFsdWUmJmMudXNlRGVidWdWYWx1ZSh0P3Qobik6bil9ZnVuY3Rpb24gYihuKXt2YXIgdT1kKHQrKywxMCksaT1oKCk7cmV0dXJuIHUuX189bixyLmNvbXBvbmVudERpZENhdGNofHwoci5jb21wb25lbnREaWRDYXRjaD1mdW5jdGlvbihuLHQpe3UuX18mJnUuX18obix0KSxpWzFdKG4pfSksW2lbMF0sZnVuY3Rpb24oKXtpWzFdKHZvaWQgMCl9XX1mdW5jdGlvbiBnKCl7dmFyIG49ZCh0KyssMTEpO2lmKCFuLl9fKXtmb3IodmFyIHU9ci5fX3Y7bnVsbCE9PXUmJiF1Ll9fbSYmbnVsbCE9PXUuX187KXU9dS5fXzt2YXIgaT11Ll9fbXx8KHUuX19tPVswLDBdKTtuLl9fPVwiUFwiK2lbMF0rXCItXCIraVsxXSsrfXJldHVybiBuLl9ffWZ1bmN0aW9uIGooKXtmb3IodmFyIG47bj1mLnNoaWZ0KCk7KWlmKG4uX19QJiZuLl9fSCl0cnl7bi5fX0guX19oLmZvckVhY2goeiksbi5fX0guX19oLmZvckVhY2goQiksbi5fX0guX19oPVtdfWNhdGNoKHQpe24uX19ILl9faD1bXSxjLl9fZSh0LG4uX192KX19Yy5fX2I9ZnVuY3Rpb24obil7cj1udWxsLGUmJmUobil9LGMuX189ZnVuY3Rpb24obix0KXtuJiZ0Ll9fayYmdC5fX2suX19tJiYobi5fX209dC5fX2suX19tKSxzJiZzKG4sdCl9LGMuX19yPWZ1bmN0aW9uKG4pe2EmJmEobiksdD0wO3ZhciBpPShyPW4uX19jKS5fX0g7aSYmKHU9PT1yPyhpLl9faD1bXSxyLl9faD1bXSxpLl9fLmZvckVhY2goZnVuY3Rpb24obil7bi5fX04mJihuLl9fPW4uX19OKSxuLmk9bi5fX049dm9pZCAwfSkpOihpLl9faC5mb3JFYWNoKHopLGkuX19oLmZvckVhY2goQiksaS5fX2g9W10sdD0wKSksdT1yfSxjLmRpZmZlZD1mdW5jdGlvbihuKXt2JiZ2KG4pO3ZhciB0PW4uX19jO3QmJnQuX19IJiYodC5fX0guX19oLmxlbmd0aCYmKDEhPT1mLnB1c2godCkmJmk9PT1jLnJlcXVlc3RBbmltYXRpb25GcmFtZXx8KChpPWMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKXx8dykoaikpLHQuX19ILl9fLmZvckVhY2goZnVuY3Rpb24obil7bi5pJiYobi5fX0g9bi5pKSxuLmk9dm9pZCAwfSkpLHU9cj1udWxsfSxjLl9fYz1mdW5jdGlvbihuLHQpe3Quc29tZShmdW5jdGlvbihuKXt0cnl7bi5fX2guZm9yRWFjaCh6KSxuLl9faD1uLl9faC5maWx0ZXIoZnVuY3Rpb24obil7cmV0dXJuIW4uX198fEIobil9KX1jYXRjaChyKXt0LnNvbWUoZnVuY3Rpb24obil7bi5fX2gmJihuLl9faD1bXSl9KSx0PVtdLGMuX19lKHIsbi5fX3YpfX0pLGwmJmwobix0KX0sYy51bm1vdW50PWZ1bmN0aW9uKG4pe20mJm0obik7dmFyIHQscj1uLl9fYztyJiZyLl9fSCYmKHIuX19ILl9fLmZvckVhY2goZnVuY3Rpb24obil7dHJ5e3oobil9Y2F0Y2gobil7dD1ufX0pLHIuX19IPXZvaWQgMCx0JiZjLl9fZSh0LHIuX192KSl9O3ZhciBrPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVlc3RBbmltYXRpb25GcmFtZTtmdW5jdGlvbiB3KG4pe3ZhciB0LHI9ZnVuY3Rpb24oKXtjbGVhclRpbWVvdXQodSksayYmY2FuY2VsQW5pbWF0aW9uRnJhbWUodCksc2V0VGltZW91dChuKX0sdT1zZXRUaW1lb3V0KHIsMTAwKTtrJiYodD1yZXF1ZXN0QW5pbWF0aW9uRnJhbWUocikpfWZ1bmN0aW9uIHoobil7dmFyIHQ9cix1PW4uX19jO1wiZnVuY3Rpb25cIj09dHlwZW9mIHUmJihuLl9fYz12b2lkIDAsdSgpKSxyPXR9ZnVuY3Rpb24gQihuKXt2YXIgdD1yO24uX19jPW4uX18oKSxyPXR9ZnVuY3Rpb24gQyhuLHQpe3JldHVybiFufHxuLmxlbmd0aCE9PXQubGVuZ3RofHx0LnNvbWUoZnVuY3Rpb24odCxyKXtyZXR1cm4gdCE9PW5bcl19KX1mdW5jdGlvbiBEKG4sdCl7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgdD90KG4pOnR9ZXhwb3J0e3EgYXMgdXNlQ2FsbGJhY2sseCBhcyB1c2VDb250ZXh0LFAgYXMgdXNlRGVidWdWYWx1ZSx5IGFzIHVzZUVmZmVjdCxiIGFzIHVzZUVycm9yQm91bmRhcnksZyBhcyB1c2VJZCxGIGFzIHVzZUltcGVyYXRpdmVIYW5kbGUsXyBhcyB1c2VMYXlvdXRFZmZlY3QsVCBhcyB1c2VNZW1vLHAgYXMgdXNlUmVkdWNlcixBIGFzIHVzZVJlZixoIGFzIHVzZVN0YXRlfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhvb2tzLm1vZHVsZS5qcy5tYXBcbiIsImltcG9ydHtvcHRpb25zIGFzIHIsRnJhZ21lbnQgYXMgZX1mcm9tXCJwcmVhY3RcIjtleHBvcnR7RnJhZ21lbnR9ZnJvbVwicHJlYWN0XCI7dmFyIHQ9L1tcIiY8XS87ZnVuY3Rpb24gbihyKXtpZigwPT09ci5sZW5ndGh8fCExPT09dC50ZXN0KHIpKXJldHVybiByO2Zvcih2YXIgZT0wLG49MCxvPVwiXCIsZj1cIlwiO248ci5sZW5ndGg7bisrKXtzd2l0Y2goci5jaGFyQ29kZUF0KG4pKXtjYXNlIDM0OmY9XCImcXVvdDtcIjticmVhaztjYXNlIDM4OmY9XCImYW1wO1wiO2JyZWFrO2Nhc2UgNjA6Zj1cIiZsdDtcIjticmVhaztkZWZhdWx0OmNvbnRpbnVlfW4hPT1lJiYobys9ci5zbGljZShlLG4pKSxvKz1mLGU9bisxfXJldHVybiBuIT09ZSYmKG8rPXIuc2xpY2UoZSxuKSksb312YXIgbz0vYWNpdHxleCg/OnN8Z3xufHB8JCl8cnBofGdyaWR8b3dzfG1uY3xudHd8aW5lW2NoXXx6b298Xm9yZHxpdGVyYS9pLGY9MCxpPUFycmF5LmlzQXJyYXk7ZnVuY3Rpb24gdShlLHQsbixvLGksdSl7dHx8KHQ9e30pO3ZhciBhLGMscD10O2lmKFwicmVmXCJpbiBwKWZvcihjIGluIHA9e30sdClcInJlZlwiPT1jP2E9dFtjXTpwW2NdPXRbY107dmFyIGw9e3R5cGU6ZSxwcm9wczpwLGtleTpuLHJlZjphLF9fazpudWxsLF9fOm51bGwsX19iOjAsX19lOm51bGwsX19kOnZvaWQgMCxfX2M6bnVsbCxjb25zdHJ1Y3Rvcjp2b2lkIDAsX192Oi0tZixfX2k6LTEsX191OjAsX19zb3VyY2U6aSxfX3NlbGY6dX07aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgZSYmKGE9ZS5kZWZhdWx0UHJvcHMpKWZvcihjIGluIGEpdm9pZCAwPT09cFtjXSYmKHBbY109YVtjXSk7cmV0dXJuIHIudm5vZGUmJnIudm5vZGUobCksbH1mdW5jdGlvbiBhKHIpe3ZhciB0PXUoZSx7dHBsOnIsZXhwcnM6W10uc2xpY2UuY2FsbChhcmd1bWVudHMsMSl9KTtyZXR1cm4gdC5rZXk9dC5fX3YsdH12YXIgYz17fSxwPS9bQS1aXS9nO2Z1bmN0aW9uIGwoZSx0KXtpZihyLmF0dHIpe3ZhciBmPXIuYXR0cihlLHQpO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBmKXJldHVybiBmfWlmKFwicmVmXCI9PT1lfHxcImtleVwiPT09ZSlyZXR1cm5cIlwiO2lmKFwic3R5bGVcIj09PWUmJlwib2JqZWN0XCI9PXR5cGVvZiB0KXt2YXIgaT1cIlwiO2Zvcih2YXIgdSBpbiB0KXt2YXIgYT10W3VdO2lmKG51bGwhPWEmJlwiXCIhPT1hKXt2YXIgbD1cIi1cIj09dVswXT91OmNbdV18fChjW3VdPXUucmVwbGFjZShwLFwiLSQmXCIpLnRvTG93ZXJDYXNlKCkpLF89XCI7XCI7XCJudW1iZXJcIiE9dHlwZW9mIGF8fGwuc3RhcnRzV2l0aChcIi0tXCIpfHxvLnRlc3QobCl8fChfPVwicHg7XCIpLGk9aStsK1wiOlwiK2ErX319cmV0dXJuIGUrJz1cIicraSsnXCInfXJldHVybiBudWxsPT10fHwhMT09PXR8fFwiZnVuY3Rpb25cIj09dHlwZW9mIHR8fFwib2JqZWN0XCI9PXR5cGVvZiB0P1wiXCI6ITA9PT10P2U6ZSsnPVwiJytuKHQpKydcIid9ZnVuY3Rpb24gXyhyKXtpZihudWxsPT1yfHxcImJvb2xlYW5cIj09dHlwZW9mIHJ8fFwiZnVuY3Rpb25cIj09dHlwZW9mIHIpcmV0dXJuIG51bGw7aWYoXCJvYmplY3RcIj09dHlwZW9mIHIpe2lmKHZvaWQgMD09PXIuY29uc3RydWN0b3IpcmV0dXJuIHI7aWYoaShyKSl7Zm9yKHZhciBlPTA7ZTxyLmxlbmd0aDtlKyspcltlXT1fKHJbZV0pO3JldHVybiByfX1yZXR1cm4gbihcIlwiK3IpfWV4cG9ydHt1IGFzIGpzeCxsIGFzIGpzeEF0dHIsdSBhcyBqc3hERVYsXyBhcyBqc3hFc2NhcGUsYSBhcyBqc3hUZW1wbGF0ZSx1IGFzIGpzeHN9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9anN4UnVudGltZS5tb2R1bGUuanMubWFwXG4iLCJcbiAgICAgIGltcG9ydCBBUEkgZnJvbSBcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIjtcbiAgICAgIGltcG9ydCBkb21BUEkgZnJvbSBcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZURvbUFQSS5qc1wiO1xuICAgICAgaW1wb3J0IGluc2VydEZuIGZyb20gXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5zZXJ0QnlTZWxlY3Rvci5qc1wiO1xuICAgICAgaW1wb3J0IHNldEF0dHJpYnV0ZXMgZnJvbSBcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXMuanNcIjtcbiAgICAgIGltcG9ydCBpbnNlcnRTdHlsZUVsZW1lbnQgZnJvbSBcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRTdHlsZUVsZW1lbnQuanNcIjtcbiAgICAgIGltcG9ydCBzdHlsZVRhZ1RyYW5zZm9ybUZuIGZyb20gXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc3R5bGVUYWdUcmFuc2Zvcm0uanNcIjtcbiAgICAgIGltcG9ydCBjb250ZW50LCAqIGFzIG5hbWVkRXhwb3J0IGZyb20gXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL2dsb2JhbHMuY3NzXCI7XG4gICAgICBcbiAgICAgIFxuXG52YXIgb3B0aW9ucyA9IHt9O1xuXG5vcHRpb25zLnN0eWxlVGFnVHJhbnNmb3JtID0gc3R5bGVUYWdUcmFuc2Zvcm1Gbjtcbm9wdGlvbnMuc2V0QXR0cmlidXRlcyA9IHNldEF0dHJpYnV0ZXM7XG5cbiAgICAgIG9wdGlvbnMuaW5zZXJ0ID0gaW5zZXJ0Rm4uYmluZChudWxsLCBcImhlYWRcIik7XG4gICAgXG5vcHRpb25zLmRvbUFQSSA9IGRvbUFQSTtcbm9wdGlvbnMuaW5zZXJ0U3R5bGVFbGVtZW50ID0gaW5zZXJ0U3R5bGVFbGVtZW50O1xuXG52YXIgdXBkYXRlID0gQVBJKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cbmlmIChtb2R1bGUuaG90KSB7XG4gIGlmICghY29udGVudC5sb2NhbHMgfHwgbW9kdWxlLmhvdC5pbnZhbGlkYXRlKSB7XG4gICAgdmFyIGlzRXF1YWxMb2NhbHMgPSBmdW5jdGlvbiBpc0VxdWFsTG9jYWxzKGEsIGIsIGlzTmFtZWRFeHBvcnQpIHtcbiAgaWYgKCFhICYmIGIgfHwgYSAmJiAhYikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcDtcbiAgZm9yIChwIGluIGEpIHtcbiAgICBpZiAoaXNOYW1lZEV4cG9ydCAmJiBwID09PSBcImRlZmF1bHRcIikge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRpbnVlXG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGFbcF0gIT09IGJbcF0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZm9yIChwIGluIGIpIHtcbiAgICBpZiAoaXNOYW1lZEV4cG9ydCAmJiBwID09PSBcImRlZmF1bHRcIikge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRpbnVlXG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKCFhW3BdKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufTtcbiAgICB2YXIgaXNOYW1lZEV4cG9ydCA9ICFjb250ZW50LmxvY2FscztcbiAgICB2YXIgb2xkTG9jYWxzID0gaXNOYW1lZEV4cG9ydCA/IG5hbWVkRXhwb3J0IDogY29udGVudC5sb2NhbHM7XG5cbiAgICBtb2R1bGUuaG90LmFjY2VwdChcbiAgICAgIFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvZGlzdC9janMuanMhLi9nbG9iYWxzLmNzc1wiLFxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWlzRXF1YWxMb2NhbHMob2xkTG9jYWxzLCBpc05hbWVkRXhwb3J0ID8gbmFtZWRFeHBvcnQgOiBjb250ZW50LmxvY2FscywgaXNOYW1lZEV4cG9ydCkpIHtcbiAgICAgICAgICAgICAgICBtb2R1bGUuaG90LmludmFsaWRhdGUoKTtcblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG9sZExvY2FscyA9IGlzTmFtZWRFeHBvcnQgPyBuYW1lZEV4cG9ydCA6IGNvbnRlbnQubG9jYWxzO1xuXG4gICAgICAgICAgICAgIHVwZGF0ZShjb250ZW50KTtcbiAgICAgIH1cbiAgICApXG4gIH1cblxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7XG4gICAgdXBkYXRlKCk7XG4gIH0pO1xufVxuXG5cbmV4cG9ydCAqIGZyb20gXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL2dsb2JhbHMuY3NzXCI7XG4gICAgICAgZXhwb3J0IGRlZmF1bHQgY29udGVudCAmJiBjb250ZW50LmxvY2FscyA/IGNvbnRlbnQubG9jYWxzIDogdW5kZWZpbmVkO1xuIiwiXG4gICAgICBpbXBvcnQgQVBJIGZyb20gXCIhLi4vLi4vLi4vc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIjtcbiAgICAgIGltcG9ydCBkb21BUEkgZnJvbSBcIiEuLi8uLi8uLi9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3N0eWxlRG9tQVBJLmpzXCI7XG4gICAgICBpbXBvcnQgaW5zZXJ0Rm4gZnJvbSBcIiEuLi8uLi8uLi9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydEJ5U2VsZWN0b3IuanNcIjtcbiAgICAgIGltcG9ydCBzZXRBdHRyaWJ1dGVzIGZyb20gXCIhLi4vLi4vLi4vc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXMuanNcIjtcbiAgICAgIGltcG9ydCBpbnNlcnRTdHlsZUVsZW1lbnQgZnJvbSBcIiEuLi8uLi8uLi9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydFN0eWxlRWxlbWVudC5qc1wiO1xuICAgICAgaW1wb3J0IHN0eWxlVGFnVHJhbnNmb3JtRm4gZnJvbSBcIiEuLi8uLi8uLi9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3N0eWxlVGFnVHJhbnNmb3JtLmpzXCI7XG4gICAgICBpbXBvcnQgY29udGVudCwgKiBhcyBuYW1lZEV4cG9ydCBmcm9tIFwiISEuLi8uLi8uLi9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uLy4uL3Bvc3Rjc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vZmxpY2tpbmcuY3NzXCI7XG4gICAgICBcbiAgICAgIFxuXG52YXIgb3B0aW9ucyA9IHt9O1xuXG5vcHRpb25zLnN0eWxlVGFnVHJhbnNmb3JtID0gc3R5bGVUYWdUcmFuc2Zvcm1Gbjtcbm9wdGlvbnMuc2V0QXR0cmlidXRlcyA9IHNldEF0dHJpYnV0ZXM7XG5cbiAgICAgIG9wdGlvbnMuaW5zZXJ0ID0gaW5zZXJ0Rm4uYmluZChudWxsLCBcImhlYWRcIik7XG4gICAgXG5vcHRpb25zLmRvbUFQSSA9IGRvbUFQSTtcbm9wdGlvbnMuaW5zZXJ0U3R5bGVFbGVtZW50ID0gaW5zZXJ0U3R5bGVFbGVtZW50O1xuXG52YXIgdXBkYXRlID0gQVBJKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cbmlmIChtb2R1bGUuaG90KSB7XG4gIGlmICghY29udGVudC5sb2NhbHMgfHwgbW9kdWxlLmhvdC5pbnZhbGlkYXRlKSB7XG4gICAgdmFyIGlzRXF1YWxMb2NhbHMgPSBmdW5jdGlvbiBpc0VxdWFsTG9jYWxzKGEsIGIsIGlzTmFtZWRFeHBvcnQpIHtcbiAgaWYgKCFhICYmIGIgfHwgYSAmJiAhYikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcDtcbiAgZm9yIChwIGluIGEpIHtcbiAgICBpZiAoaXNOYW1lZEV4cG9ydCAmJiBwID09PSBcImRlZmF1bHRcIikge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRpbnVlXG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGFbcF0gIT09IGJbcF0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZm9yIChwIGluIGIpIHtcbiAgICBpZiAoaXNOYW1lZEV4cG9ydCAmJiBwID09PSBcImRlZmF1bHRcIikge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRpbnVlXG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKCFhW3BdKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufTtcbiAgICB2YXIgaXNOYW1lZEV4cG9ydCA9ICFjb250ZW50LmxvY2FscztcbiAgICB2YXIgb2xkTG9jYWxzID0gaXNOYW1lZEV4cG9ydCA/IG5hbWVkRXhwb3J0IDogY29udGVudC5sb2NhbHM7XG5cbiAgICBtb2R1bGUuaG90LmFjY2VwdChcbiAgICAgIFwiISEuLi8uLi8uLi9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uLy4uL3Bvc3Rjc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vZmxpY2tpbmcuY3NzXCIsXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghaXNFcXVhbExvY2FscyhvbGRMb2NhbHMsIGlzTmFtZWRFeHBvcnQgPyBuYW1lZEV4cG9ydCA6IGNvbnRlbnQubG9jYWxzLCBpc05hbWVkRXhwb3J0KSkge1xuICAgICAgICAgICAgICAgIG1vZHVsZS5ob3QuaW52YWxpZGF0ZSgpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgb2xkTG9jYWxzID0gaXNOYW1lZEV4cG9ydCA/IG5hbWVkRXhwb3J0IDogY29udGVudC5sb2NhbHM7XG5cbiAgICAgICAgICAgICAgdXBkYXRlKGNvbnRlbnQpO1xuICAgICAgfVxuICAgIClcbiAgfVxuXG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHtcbiAgICB1cGRhdGUoKTtcbiAgfSk7XG59XG5cblxuZXhwb3J0ICogZnJvbSBcIiEhLi4vLi4vLi4vY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi8uLi9wb3N0Y3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL2ZsaWNraW5nLmNzc1wiO1xuICAgICAgIGV4cG9ydCBkZWZhdWx0IGNvbnRlbnQgJiYgY29udGVudC5sb2NhbHMgPyBjb250ZW50LmxvY2FscyA6IHVuZGVmaW5lZDtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgc3R5bGVzSW5ET00gPSBbXTtcbmZ1bmN0aW9uIGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpIHtcbiAgdmFyIHJlc3VsdCA9IC0xO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlc0luRE9NLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHN0eWxlc0luRE9NW2ldLmlkZW50aWZpZXIgPT09IGlkZW50aWZpZXIpIHtcbiAgICAgIHJlc3VsdCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKSB7XG4gIHZhciBpZENvdW50TWFwID0ge307XG4gIHZhciBpZGVudGlmaWVycyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IGxpc3RbaV07XG4gICAgdmFyIGlkID0gb3B0aW9ucy5iYXNlID8gaXRlbVswXSArIG9wdGlvbnMuYmFzZSA6IGl0ZW1bMF07XG4gICAgdmFyIGNvdW50ID0gaWRDb3VudE1hcFtpZF0gfHwgMDtcbiAgICB2YXIgaWRlbnRpZmllciA9IFwiXCIuY29uY2F0KGlkLCBcIiBcIikuY29uY2F0KGNvdW50KTtcbiAgICBpZENvdW50TWFwW2lkXSA9IGNvdW50ICsgMTtcbiAgICB2YXIgaW5kZXhCeUlkZW50aWZpZXIgPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICB2YXIgb2JqID0ge1xuICAgICAgY3NzOiBpdGVtWzFdLFxuICAgICAgbWVkaWE6IGl0ZW1bMl0sXG4gICAgICBzb3VyY2VNYXA6IGl0ZW1bM10sXG4gICAgICBzdXBwb3J0czogaXRlbVs0XSxcbiAgICAgIGxheWVyOiBpdGVtWzVdXG4gICAgfTtcbiAgICBpZiAoaW5kZXhCeUlkZW50aWZpZXIgIT09IC0xKSB7XG4gICAgICBzdHlsZXNJbkRPTVtpbmRleEJ5SWRlbnRpZmllcl0ucmVmZXJlbmNlcysrO1xuICAgICAgc3R5bGVzSW5ET01baW5kZXhCeUlkZW50aWZpZXJdLnVwZGF0ZXIob2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHVwZGF0ZXIgPSBhZGRFbGVtZW50U3R5bGUob2JqLCBvcHRpb25zKTtcbiAgICAgIG9wdGlvbnMuYnlJbmRleCA9IGk7XG4gICAgICBzdHlsZXNJbkRPTS5zcGxpY2UoaSwgMCwge1xuICAgICAgICBpZGVudGlmaWVyOiBpZGVudGlmaWVyLFxuICAgICAgICB1cGRhdGVyOiB1cGRhdGVyLFxuICAgICAgICByZWZlcmVuY2VzOiAxXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWRlbnRpZmllcnMucHVzaChpZGVudGlmaWVyKTtcbiAgfVxuICByZXR1cm4gaWRlbnRpZmllcnM7XG59XG5mdW5jdGlvbiBhZGRFbGVtZW50U3R5bGUob2JqLCBvcHRpb25zKSB7XG4gIHZhciBhcGkgPSBvcHRpb25zLmRvbUFQSShvcHRpb25zKTtcbiAgYXBpLnVwZGF0ZShvYmopO1xuICB2YXIgdXBkYXRlciA9IGZ1bmN0aW9uIHVwZGF0ZXIobmV3T2JqKSB7XG4gICAgaWYgKG5ld09iaikge1xuICAgICAgaWYgKG5ld09iai5jc3MgPT09IG9iai5jc3MgJiYgbmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiYgbmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcCAmJiBuZXdPYmouc3VwcG9ydHMgPT09IG9iai5zdXBwb3J0cyAmJiBuZXdPYmoubGF5ZXIgPT09IG9iai5sYXllcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBhcGkudXBkYXRlKG9iaiA9IG5ld09iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFwaS5yZW1vdmUoKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiB1cGRhdGVyO1xufVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobGlzdCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgbGlzdCA9IGxpc3QgfHwgW107XG4gIHZhciBsYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obGlzdCwgb3B0aW9ucyk7XG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGUobmV3TGlzdCkge1xuICAgIG5ld0xpc3QgPSBuZXdMaXN0IHx8IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGFzdElkZW50aWZpZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaWRlbnRpZmllciA9IGxhc3RJZGVudGlmaWVyc1tpXTtcbiAgICAgIHZhciBpbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgICAgc3R5bGVzSW5ET01baW5kZXhdLnJlZmVyZW5jZXMtLTtcbiAgICB9XG4gICAgdmFyIG5ld0xhc3RJZGVudGlmaWVycyA9IG1vZHVsZXNUb0RvbShuZXdMaXN0LCBvcHRpb25zKTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbGFzdElkZW50aWZpZXJzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIF9pZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW19pXTtcbiAgICAgIHZhciBfaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihfaWRlbnRpZmllcik7XG4gICAgICBpZiAoc3R5bGVzSW5ET01bX2luZGV4XS5yZWZlcmVuY2VzID09PSAwKSB7XG4gICAgICAgIHN0eWxlc0luRE9NW19pbmRleF0udXBkYXRlcigpO1xuICAgICAgICBzdHlsZXNJbkRPTS5zcGxpY2UoX2luZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGFzdElkZW50aWZpZXJzID0gbmV3TGFzdElkZW50aWZpZXJzO1xuICB9O1xufTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIG1lbW8gPSB7fTtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBnZXRUYXJnZXQodGFyZ2V0KSB7XG4gIGlmICh0eXBlb2YgbWVtb1t0YXJnZXRdID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdmFyIHN0eWxlVGFyZ2V0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpO1xuXG4gICAgLy8gU3BlY2lhbCBjYXNlIHRvIHJldHVybiBoZWFkIG9mIGlmcmFtZSBpbnN0ZWFkIG9mIGlmcmFtZSBpdHNlbGZcbiAgICBpZiAod2luZG93LkhUTUxJRnJhbWVFbGVtZW50ICYmIHN0eWxlVGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50KSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFjY2VzcyB0byBpZnJhbWUgaXMgYmxvY2tlZFxuICAgICAgICAvLyBkdWUgdG8gY3Jvc3Mtb3JpZ2luIHJlc3RyaWN0aW9uc1xuICAgICAgICBzdHlsZVRhcmdldCA9IHN0eWxlVGFyZ2V0LmNvbnRlbnREb2N1bWVudC5oZWFkO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICBzdHlsZVRhcmdldCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIG1lbW9bdGFyZ2V0XSA9IHN0eWxlVGFyZ2V0O1xuICB9XG4gIHJldHVybiBtZW1vW3RhcmdldF07XG59XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gaW5zZXJ0QnlTZWxlY3RvcihpbnNlcnQsIHN0eWxlKSB7XG4gIHZhciB0YXJnZXQgPSBnZXRUYXJnZXQoaW5zZXJ0KTtcbiAgaWYgKCF0YXJnZXQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGEgc3R5bGUgdGFyZ2V0LiBUaGlzIHByb2JhYmx5IG1lYW5zIHRoYXQgdGhlIHZhbHVlIGZvciB0aGUgJ2luc2VydCcgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO1xuICB9XG4gIHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGluc2VydEJ5U2VsZWN0b3I7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpIHtcbiAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gIG9wdGlvbnMuc2V0QXR0cmlidXRlcyhlbGVtZW50LCBvcHRpb25zLmF0dHJpYnV0ZXMpO1xuICBvcHRpb25zLmluc2VydChlbGVtZW50LCBvcHRpb25zLm9wdGlvbnMpO1xuICByZXR1cm4gZWxlbWVudDtcbn1cbm1vZHVsZS5leHBvcnRzID0gaW5zZXJ0U3R5bGVFbGVtZW50OyIsIlwidXNlIHN0cmljdFwiO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cbmZ1bmN0aW9uIHNldEF0dHJpYnV0ZXNXaXRob3V0QXR0cmlidXRlcyhzdHlsZUVsZW1lbnQpIHtcbiAgdmFyIG5vbmNlID0gdHlwZW9mIF9fd2VicGFja19ub25jZV9fICE9PSBcInVuZGVmaW5lZFwiID8gX193ZWJwYWNrX25vbmNlX18gOiBudWxsO1xuICBpZiAobm9uY2UpIHtcbiAgICBzdHlsZUVsZW1lbnQuc2V0QXR0cmlidXRlKFwibm9uY2VcIiwgbm9uY2UpO1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IHNldEF0dHJpYnV0ZXNXaXRob3V0QXR0cmlidXRlczsiLCJcInVzZSBzdHJpY3RcIjtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBhcHBseShzdHlsZUVsZW1lbnQsIG9wdGlvbnMsIG9iaikge1xuICB2YXIgY3NzID0gXCJcIjtcbiAgaWYgKG9iai5zdXBwb3J0cykge1xuICAgIGNzcyArPSBcIkBzdXBwb3J0cyAoXCIuY29uY2F0KG9iai5zdXBwb3J0cywgXCIpIHtcIik7XG4gIH1cbiAgaWYgKG9iai5tZWRpYSkge1xuICAgIGNzcyArPSBcIkBtZWRpYSBcIi5jb25jYXQob2JqLm1lZGlhLCBcIiB7XCIpO1xuICB9XG4gIHZhciBuZWVkTGF5ZXIgPSB0eXBlb2Ygb2JqLmxheWVyICE9PSBcInVuZGVmaW5lZFwiO1xuICBpZiAobmVlZExheWVyKSB7XG4gICAgY3NzICs9IFwiQGxheWVyXCIuY29uY2F0KG9iai5sYXllci5sZW5ndGggPiAwID8gXCIgXCIuY29uY2F0KG9iai5sYXllcikgOiBcIlwiLCBcIiB7XCIpO1xuICB9XG4gIGNzcyArPSBvYmouY3NzO1xuICBpZiAobmVlZExheWVyKSB7XG4gICAgY3NzICs9IFwifVwiO1xuICB9XG4gIGlmIChvYmoubWVkaWEpIHtcbiAgICBjc3MgKz0gXCJ9XCI7XG4gIH1cbiAgaWYgKG9iai5zdXBwb3J0cykge1xuICAgIGNzcyArPSBcIn1cIjtcbiAgfVxuICB2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcbiAgaWYgKHNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIuY29uY2F0KGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSksIFwiICovXCIpO1xuICB9XG5cbiAgLy8gRm9yIG9sZCBJRVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgICovXG4gIG9wdGlvbnMuc3R5bGVUYWdUcmFuc2Zvcm0oY3NzLCBzdHlsZUVsZW1lbnQsIG9wdGlvbnMub3B0aW9ucyk7XG59XG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KSB7XG4gIC8vIGlzdGFuYnVsIGlnbm9yZSBpZlxuICBpZiAoc3R5bGVFbGVtZW50LnBhcmVudE5vZGUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc3R5bGVFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50KTtcbn1cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBkb21BUEkob3B0aW9ucykge1xuICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKCkge30sXG4gICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHt9XG4gICAgfTtcbiAgfVxuICB2YXIgc3R5bGVFbGVtZW50ID0gb3B0aW9ucy5pbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG4gIHJldHVybiB7XG4gICAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUob2JqKSB7XG4gICAgICBhcHBseShzdHlsZUVsZW1lbnQsIG9wdGlvbnMsIG9iaik7XG4gICAgfSxcbiAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpO1xuICAgIH1cbiAgfTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZG9tQVBJOyIsIlwidXNlIHN0cmljdFwiO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cbmZ1bmN0aW9uIHN0eWxlVGFnVHJhbnNmb3JtKGNzcywgc3R5bGVFbGVtZW50KSB7XG4gIGlmIChzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKSB7XG4gICAgICBzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgICBzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gc3R5bGVUYWdUcmFuc2Zvcm07IiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBCbG9jazE7XG52YXIganN4X3J1bnRpbWVfMSA9IHJlcXVpcmUoXCJwcmVhY3QvanN4LXJ1bnRpbWVcIik7XG52YXIgcHJlYWN0X3JvdXRlcl8xID0gcmVxdWlyZShcInByZWFjdC1yb3V0ZXJcIik7XG52YXIgaW1hZ2VfaGVyb19qcGdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vYXNzZXRzL2Rlc2t0b3AvaW1hZ2UtaGVyby5qcGdcIikpO1xudmFyIGltYWdlX2hlcm9fanBnXzIgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uLy4uL2Fzc2V0cy90YWJsZXQvaW1hZ2UtaGVyby5qcGdcIikpO1xudmFyIGltYWdlX2hlcm9fanBnXzMgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uLy4uL2Fzc2V0cy9tb2JpbGUvaW1hZ2UtaGVyby5qcGdcIikpO1xudmFyIGl0ZW1zID0ge1xuICAgIHRpdGxlOiAnQnJhbmRpbmcgJiB3ZWJzaXRlIGRlc2lnbiBhZ2VuY3knLFxuICAgIGRlc2NyaXB0aW9uOiAnV2Ugc3BlY2lhbGl6ZSBpbiB2aXN1YWwgc3Rvcnl0ZWxsaW5nIGJ5IGNyZWF0aW5nIGNvaGVzaXZlIGJyYW5kIGFuZCB3ZWJzaXRlIGRlc2lnbiBzb2x1dGlvbnMgZm9yIHNtYWxsIGJ1c2luZXNzZXMsIGdpdmluZyBsYXN0aW5nIGltcHJlc3Npb25zIHRvIGF1ZGllbmNlcyBpbiBhIGRpZ2l0YWwgd29ybGQuJyxcbiAgICBidXR0b246ICdMZWFybiBNb3JlJyxcbn07XG52YXIgbGlua0l0ZW1zID0ge1xuICAgIHRpdGxlOiAnTGVhcm4gTW9yZScsXG4gICAgaHJlZjogJyMnLFxufTtcbmZ1bmN0aW9uIEJsb2NrMSgpIHtcbiAgICByZXR1cm4gKCgwLCBqc3hfcnVudGltZV8xLmpzeHMpKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJlbGF0aXZlIGZsZXggaC1bNjA2cHhdIHctZnVsbCBtYXgtdy1bY2FsYygxMjc1cHgrMzlweCldIGl0ZW1zLXN0YXJ0IGp1c3RpZnktYmV0d2VlbiBzZWxmLWVuZCBwbC1bMzlweF0geGw6aC1bODAwcHhdXCIsIGNoaWxkcmVuOiBbKDAsIGpzeF9ydW50aW1lXzEuanN4cykoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwicmVsYXRpdmUgei1bMV0gbXQtWzc3cHhdIGZsZXggdy1mdWxsIG1heC13LVs3MzBweF0gZmxleC1jb2wgZ2FwLVs0OHB4XSB4bDptdC1bMTEycHhdXCIsIGNoaWxkcmVuOiBbKDAsIGpzeF9ydW50aW1lXzEuanN4cykoXCJzZWN0aW9uXCIsIHsgY2xhc3NOYW1lOiBcImZsZXggZmxleC1jb2wgZ2FwLVszOXB4XVwiLCBjaGlsZHJlbjogWygwLCBqc3hfcnVudGltZV8xLmpzeCkoXCJoMVwiLCB7IGNsYXNzTmFtZTogXCJ3LWZ1bGwgbWF4LXctWzM5OHB4XSB4bDptYXgtdy1bNjgwXVwiLCBjaGlsZHJlbjogaXRlbXMudGl0bGUgfSksICgwLCBqc3hfcnVudGltZV8xLmpzeCkoXCJwXCIsIHsgY2xhc3NOYW1lOiBcInctZnVsbCBtYXgtdy1bMzk4cHhdIHhsOm1heC13LVs1NDBweF1cIiwgY2hpbGRyZW46IGl0ZW1zLmRlc2NyaXB0aW9uIH0pXSB9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4KShwcmVhY3Rfcm91dGVyXzEuTGluaywgeyBjbGFzc05hbWU6IFwiZmxleCBoLVs3MnB4XSB3LVsxNzdweF0gaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIGJnLVsjRjk0RjRGXSB0ZXh0LVsxOHB4XSBmb250LWV4dHJhYm9sZCB0ZXh0LXdoaXRlIHRyYW5zaXRpb24gaG92ZXI6YmctWyNGRjkzOTNdXCIsIGhyZWY6IGxpbmtJdGVtcy5ocmVmLCBjaGlsZHJlbjogbGlua0l0ZW1zLnRpdGxlIH0pXSB9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4cykoXCJwaWN0dXJlXCIsIHsgY2xhc3NOYW1lOiBcImFic29sdXRlIHJpZ2h0LTAgaC1bNjA4cHhdIHctZml0IHhsOmgtWzgwMHB4XVwiLCBjaGlsZHJlbjogWygwLCBqc3hfcnVudGltZV8xLmpzeCkoXCJzb3VyY2VcIiwgeyBtZWRpYTogXCIobWF4LXdpZHRoOiA2NDBweClcIiwgc3JjU2V0OiBpbWFnZV9oZXJvX2pwZ18zLmRlZmF1bHQgfSksICgwLCBqc3hfcnVudGltZV8xLmpzeCkoXCJzb3VyY2VcIiwgeyBtZWRpYTogXCIobWF4LXdpZHRoOiAxMDI0cHgpXCIsIHNyY1NldDogaW1hZ2VfaGVyb19qcGdfMi5kZWZhdWx0IH0pLCAoMCwganN4X3J1bnRpbWVfMS5qc3gpKFwiaW1nXCIsIHsgY2xhc3NOYW1lOiBcIm1kOm9iamVjdC1maXQgb2JqZWN0LWNvdmVyIG1kOmgtWzYwNnB4XSB4bDpoLVs4MDBweF1cIiwgc3JjOiBpbWFnZV9oZXJvX2pwZ18xLmRlZmF1bHQsIGFsdDogXCJtZW4gd29ya2luZyBvbiBjb21wdXRlcnNcIiB9KV0gfSldIH0pKTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gQmxvY2syO1xudmFyIGpzeF9ydW50aW1lXzEgPSByZXF1aXJlKFwicHJlYWN0L2pzeC1ydW50aW1lXCIpO1xudmFyIHByZWFjdF9yb3V0ZXJfMSA9IHJlcXVpcmUoXCJwcmVhY3Qtcm91dGVyXCIpO1xudmFyIGltYWdlX3N0cmF0ZWdpY19qcGdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vYXNzZXRzL2Rlc2t0b3AvaW1hZ2Utc3RyYXRlZ2ljLmpwZ1wiKSk7XG52YXIgYmdfcGF0dGVybl93YXZlX3JlZF9zdmdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vYXNzZXRzL2Rlc2t0b3AvYmctcGF0dGVybi13YXZlLXJlZC5zdmdcIikpO1xudmFyIGl0ZW1zID0ge1xuICAgIHRpdGxlOiAnRGVzaWduIGlzIHN0cmF0ZWdpYy4nLFxuICAgIGRlc2NyaXB0aW9uOiAn4oCcQSB3ZWxsLWNyYWZ0ZWQgZGVzaWduIHN0cmF0ZWd5IGNvbnNpc3RlbnRseSBwcm9kdWNlcyBkZXNpcmVkIG91dGNvbWVzIGFuZCBicmFuZCBhd2FyZW5lc3MuIFdlIGFyZSBmaXJtIGJlbGlldmVycyB0aGF0IHN1Y2Nlc3MgbGllcyBpbiBjcmVhdGl2ZSBjb2xsYWJvcmF0aW9uIHdpdGggb3VyIGNsaWVudHMu4oCdJyxcbiAgICBsaW5rVGl0bGU6ICdTY2hlZHVsZSBhIENhbGwnLFxufTtcbmZ1bmN0aW9uIEJsb2NrMigpIHtcbiAgICByZXR1cm4gKCgwLCBqc3hfcnVudGltZV8xLmpzeHMpKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJlbGF0aXZlIGZsZXggaC1bNjQ4cHhdIHctZnVsbCAganVzdGlmeS1lbmQgbGc6aC1bNzUwcHhdIHhsOmgtWzk4NHB4XVwiLCBjaGlsZHJlbjogWygwLCBqc3hfcnVudGltZV8xLmpzeCkoXCJpbWdcIiwgeyBjbGFzc05hbWU6IFwiYWJzb2x1dGUgbGVmdC0wIGgtWzY1OHB4XSB3LVs3MzVweF0gb2JqZWN0LWNvdmVyIG9iamVjdC1bMTAwJV8wJV0geGw6aC1bOTg0cHhdIHhsOm9iamVjdC1jZW50ZXJcIiwgaGVpZ2h0OiA5ODQsIHdpZHRoOiA3MzUsIHNyYzogaW1hZ2Vfc3RyYXRlZ2ljX2pwZ18xLmRlZmF1bHQsIGFsdDogXCJzdHJhdGVnaWNcIiB9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4KShcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJyZWxhdGl2ZSBmbGV4IGgtWzUzOHB4XSB3LVszOTBweF0gaXRlbXMtY2VudGVyIGJnLVsjMTkxOTIxXSBwbC1bNjlweF0gcHItWzQwcHhdIGxnOmgtWzU2MHB4XSBsZzp3LVs1MzBweF0gbGc6cGwtWzkwcHhdIGxnOnByLVs2MHB4XSB4bDpoLVs3ODRweF0geGw6dy1bNzA1cHhdIHhsOnBsLVsxNTRweF0geGw6cHItWzEwNnB4XVwiLCBjaGlsZHJlbjogKDAsIGpzeF9ydW50aW1lXzEuanN4cykoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmxleCBmbGV4LWNvbCBnYXAtWzQ4cHhdIFwiLCBjaGlsZHJlbjogWygwLCBqc3hfcnVudGltZV8xLmpzeCkoXCJpbWdcIiwgeyBjbGFzc05hbWU6IFwiYWJzb2x1dGUgbGVmdC1bLTMxcHhdIHRvcC1bMjIwcHhdIGgtWzI4cHhdIHctWzYycHhdIHhsOmxlZnQtWy02N3B4XSB4bDp0b3AtWzIzNHB4XSB4bDpoLVs2MXB4XSB4bDp3LVsxMzVweF1cIiwgd2lkdGg6IDEzNSwgaGVpZ2h0OiA2MSwgc3JjOiBiZ19wYXR0ZXJuX3dhdmVfcmVkX3N2Z18xLmRlZmF1bHQsIGFsdDogXCJwYXR0ZXJuXCIgfSksICgwLCBqc3hfcnVudGltZV8xLmpzeHMpKFwic2VjdGlvblwiLCB7IGNsYXNzTmFtZTogXCJmbGV4IG1heC13LVsyODFweF0gZmxleC1jb2wgZ2FwLVszMnB4XSBsZzptYXgtdy1mdWxsIHhsOmdhcC1bNDNweF1cIiwgY2hpbGRyZW46IFsoMCwganN4X3J1bnRpbWVfMS5qc3hzKShcImgyXCIsIHsgY2xhc3NOYW1lOiBcIm1heC13LVsyNTBweF0gdGV4dC13aGl0ZSBsZzptYXgtdy1mdWxsXCIsIGNoaWxkcmVuOiBbKDAsIGpzeF9ydW50aW1lXzEuanN4KShcInNwYW5cIiwgeyBjbGFzc05hbWU6IFwidGV4dC1bI0Y5NEY0Rl1cIiwgY2hpbGRyZW46IGl0ZW1zLnRpdGxlLnNwbGl0KCcgJylbMF0gfSksIFwiIFwiLmNvbmNhdChpdGVtcy50aXRsZS5zcGxpdCgnICcpLnNsaWNlKDEpLmpvaW4oJyAnKSldIH0pLCAoMCwganN4X3J1bnRpbWVfMS5qc3gpKFwicFwiLCB7IGNsYXNzTmFtZTogXCJ0ZXh0LXdoaXRlXCIsIGNoaWxkcmVuOiBpdGVtcy5kZXNjcmlwdGlvbiB9KV0gfSksICgwLCBqc3hfcnVudGltZV8xLmpzeCkocHJlYWN0X3JvdXRlcl8xLkxpbmssIHsgY2xhc3NOYW1lOiBcImZvbnQtZXh0cmFib2xkIHRleHQtWyNGOTRGNEZdIHVuZGVybGluZSB1bmRlcmxpbmUtb2Zmc2V0LVsxMnB4XSB0cmFuc2l0aW9uIGhvdmVyOnRleHQtWyNGRjkzOTNdXCIsIGhyZWY6IFwiI1wiLCBjaGlsZHJlbjogaXRlbXMubGlua1RpdGxlIH0pXSB9KSB9KV0gfSkpO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBCbG9jazM7XG52YXIganN4X3J1bnRpbWVfMSA9IHJlcXVpcmUoXCJwcmVhY3QvanN4LXJ1bnRpbWVcIik7XG52YXIgdGl0bGUgPSAnT3VyIGFwcHJvYWNoIGZvciBjcmVhdGluZyBhIHdpbm5pbmcgYnJhbmQnO1xudmFyIGl0ZW1zID0gW1xuICAgIHtcbiAgICAgICAgdGl0bGU6ICdCcmFuZCBTdHJhdGVneScsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnQnJhbmQgc3RyYXRlZ3kgaXMgY3JpdGljYWwgZm9yIGxvbmctdGVybSBzdWNjZXNzLiBPdXRzaGluaW5nIGNvbXBldGl0b3JzIGFuZCBjYXB0dXJpbmcgdGhlIHRhcmdldCBhdWRpZW5jZSBhcmUga2V5LicsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHRpdGxlOiAnQnJhbmQgRGVzaWduJyxcbiAgICAgICAgZGVzY3JpcHRpb246ICdLZWVwaW5nIHRoZSBicmFuZCBkZXNpZ24gdW5pcXVlIGFuZCBtZWFuaW5nZnVsIGhlbHBzIGluIGNvbW11bmljYXRpbmcgdGhlIGJyYW5k4oCZcyB0aW1lbGVzcyB2YWx1ZSBlZmZlY3RpdmVseS4nLFxuICAgIH0sXG4gICAge1xuICAgICAgICB0aXRsZTogJ1dlYiBEZXNpZ24nLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ0EgYmVhdXRpZnVsbHkgY3JhZnRlZCB3ZWJzaXRlIGlzIHRoZSBiZXN0IHRvb2wgZm9yIGJyYW5kIGF3YXJlbmVzcywgYW5kIHVsdGltYXRlbHkgcmVzdWx0cyBpbiBpbmNyZWFzZWQgcmV2ZW51ZXMuICcsXG4gICAgfSxcbl07XG5mdW5jdGlvbiBCbG9jazMoKSB7XG4gICAgcmV0dXJuICgoMCwganN4X3J1bnRpbWVfMS5qc3hzKShcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmbGV4IHctZnVsbCBqdXN0aWZ5LWVuZCBwbC1bMzlweF1cIiwgY2hpbGRyZW46IFsoMCwganN4X3J1bnRpbWVfMS5qc3gpKFwiaDJcIiwgeyBjbGFzc05hbWU6IFwiei1bMl0gbXItWy0xNjBweF0gbXQtWzIwMHB4XSBoLWZpdCB3LWZ1bGwgbWF4LXctWzI4MXB4XSB4bDptYXgtdy1bNTQwcHhdXCIsIGNoaWxkcmVuOiB0aXRsZSB9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4KShcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJ6LVsxXSBtdC1bLTEyMHB4XSBmbGV4IGgtWzExMDBweF0gaXRlbXMtY2VudGVyIGp1c3RpZnktZW5kIGJnLVsjRjk0RjRGXSBwci1bMTA2cHhdIGxnOm10LVstMjAwcHhdIGxnOnctWzYwMHB4XSB4bDp3LVs4OTVweF1cIiwgY2hpbGRyZW46ICgwLCBqc3hfcnVudGltZV8xLmpzeCkoXCJ1bFwiLCB7IGNsYXNzTmFtZTogXCJmbGV4IGZsZXgtY29sIGdhcC1bNTZweF1cIiwgY2hpbGRyZW46IGl0ZW1zLm1hcChmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHsgcmV0dXJuICgoMCwganN4X3J1bnRpbWVfMS5qc3hzKShcImxpXCIsIHsgY2xhc3NOYW1lOiBcImZsZXggaC1bMjAwcHhdIHctWzM1NXB4XSBmbGV4LWNvbCBnYXAtWzI0cHhdIHhsOnctWzUwNHB4XVwiLCBjaGlsZHJlbjogWygwLCBqc3hfcnVudGltZV8xLmpzeCkoXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBcImFic29sdXRlIHRleHQtWzgwcHhdIGZvbnQtZXh0cmFib2xkIGxlYWRpbmctWzg4cHhdIHRleHQtd2hpdGUvMjVcIiwgY2hpbGRyZW46IChpbmRleCArIDEpLnRvTG9jYWxlU3RyaW5nKCdlbi1VUycsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbmltdW1JbnRlZ2VyRGlnaXRzOiAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlR3JvdXBpbmc6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSB9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4cykoXCJzZWN0aW9uXCIsIHsgY2xhc3NOYW1lOiBcIm1sLVs1OXB4XSBtdC1bNDRweF0gZmxleCBmbGV4LWNvbCBnYXAtWzI0cHhdXCIsIGNoaWxkcmVuOiBbKDAsIGpzeF9ydW50aW1lXzEuanN4KShcImgzXCIsIHsgY2xhc3NOYW1lOiBcInRleHQtd2hpdGVcIiwgY2hpbGRyZW46IGl0ZW0udGl0bGUgfSksICgwLCBqc3hfcnVudGltZV8xLmpzeCkoXCJwXCIsIHsgY2xhc3NOYW1lOiBcInRleHQtd2hpdGVcIiwgY2hpbGRyZW46IGl0ZW0uZGVzY3JpcHRpb24gfSldIH0pXSB9LCBpdGVtKSk7IH0pIH0pIH0pXSB9KSk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbnZhciBfYTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IEJsb2NrNDtcbnZhciBqc3hfcnVudGltZV8xID0gcmVxdWlyZShcInByZWFjdC9qc3gtcnVudGltZVwiKTtcbnZhciBpbWFnZV9zbGlkZV8xX2pwZ18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi8uLi9hc3NldHMvZGVza3RvcC9pbWFnZS1zbGlkZS0xLmpwZ1wiKSk7XG52YXIgaW1hZ2Vfc2xpZGVfMl9qcGdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vYXNzZXRzL2Rlc2t0b3AvaW1hZ2Utc2xpZGUtMi5qcGdcIikpO1xudmFyIGltYWdlX3NsaWRlXzNfanBnXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uLy4uL2Fzc2V0cy9kZXNrdG9wL2ltYWdlLXNsaWRlLTMuanBnXCIpKTtcbnZhciBiZ19wYXR0ZXJuX3dhdnlfd2hpdGVfc3ZnXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uLy4uL2Fzc2V0cy9kZXNrdG9wL2JnLXBhdHRlcm4td2F2eS13aGl0ZS5zdmdcIikpO1xudmFyIGhvb2tzXzEgPSByZXF1aXJlKFwicHJlYWN0L2hvb2tzXCIpO1xudmFyIHByZWFjdF9mbGlja2luZ18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJAZWdqcy9wcmVhY3QtZmxpY2tpbmdcIikpO1xucmVxdWlyZShcIkBlZ2pzL3ByZWFjdC1mbGlja2luZy9kaXN0L2ZsaWNraW5nLmNzc1wiKTtcbnZhciBUaXRsZUtleTtcbihmdW5jdGlvbiAoVGl0bGVLZXkpIHtcbiAgICBUaXRsZUtleVtUaXRsZUtleVtcImd1aWRlbGluZXNcIl0gPSAwXSA9IFwiZ3VpZGVsaW5lc1wiO1xuICAgIFRpdGxlS2V5W1RpdGxlS2V5W1wibWVyY2hhbmRpc2VcIl0gPSAxXSA9IFwibWVyY2hhbmRpc2VcIjtcbiAgICBUaXRsZUtleVtUaXRsZUtleVtcImRlc2lnblwiXSA9IDJdID0gXCJkZXNpZ25cIjtcbn0pKFRpdGxlS2V5IHx8IChUaXRsZUtleSA9IHt9KSk7XG52YXIgdGl0bGUgPSAoX2EgPSB7fSxcbiAgICBfYVtUaXRsZUtleS5ndWlkZWxpbmVzXSA9IHtcbiAgICAgICAgbWFpblRpdGxlOiAnQnJhbmQgbmFtaW5nICYgZ3VpZGVsaW5lcycsXG4gICAgICAgIHRpdGxlOiAnTGVhbiBQcm9kdWN0IFJvYWRtYXAnLFxuICAgICAgICBkZXNjcmlwdGlvbjogJzIwMTkgUHJvamVjdCcsXG4gICAgfSxcbiAgICBfYVtUaXRsZUtleS5tZXJjaGFuZGlzZV0gPSB7XG4gICAgICAgIG1haW5UaXRsZTogJ0JyYW5kIGlkZW50aXR5ICYgbWVyY2hhbmRpc2UnLFxuICAgICAgICB0aXRsZTogJ05ldyBNYWplc3RpYyBIb3RlbCcsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnMjAxOCBQcm9qZWN0JyxcbiAgICB9LFxuICAgIF9hW1RpdGxlS2V5LmRlc2lnbl0gPSB7XG4gICAgICAgIG1haW5UaXRsZTogJ0JyYW5kIGlkZW50aXR5ICYgd2ViIGRlc2lnbicsXG4gICAgICAgIHRpdGxlOiAnQ3J5cHRvIERhc2hib2FyZCcsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnMjAxNiBQcm9qZWN0JyxcbiAgICB9LFxuICAgIF9hKTtcbnZhciB0aXRsZXNCdXR0b25zID0ge1xuICAgIHByZXZpb3VzOiAncHJldmlvdXMgc2xpZGUnLFxuICAgIG5leHQ6ICduZXh0IHNsaWRlJyxcbn07XG5mdW5jdGlvbiBCbG9jazQoKSB7XG4gICAgdmFyIGZsaWNraW5nID0gKDAsIGhvb2tzXzEudXNlUmVmKSgpO1xuICAgIHZhciBfYSA9ICgwLCBob29rc18xLnVzZVN0YXRlKShUaXRsZUtleS5ndWlkZWxpbmVzKSwgY3VycmVudFNsaWRlID0gX2FbMF0sIHNldEN1cnJlbnRTbGlkZSA9IF9hWzFdO1xuICAgIHZhciBfYiA9ICgwLCBob29rc18xLnVzZVN0YXRlKShmYWxzZSksIGlzUGxheWluZyA9IF9iWzBdLCBzZXRJc1BsYXlpbmcgPSBfYlsxXTtcbiAgICByZXR1cm4gKCgwLCBqc3hfcnVudGltZV8xLmpzeHMpKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJlbGF0aXZlIGZsZXggbWluLWgtWzcyOHB4XSB3LWZ1bGwganVzdGlmeS1zdGFydFwiLCBjaGlsZHJlbjogWygwLCBqc3hfcnVudGltZV8xLmpzeHMpKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJlbGF0aXZlIHotWzFdIGZsZXggaC1bNTI4cHhdIG1pbi13LVs3MzVweF0gaXRlbXMtY2VudGVyIGJnLVsjMTkxOTIxXVwiLCBjaGlsZHJlbjogWygwLCBqc3hfcnVudGltZV8xLmpzeCkoXCJpbWdcIiwgeyBhbHQ6IFwicGF0dGVyblwiLCBjbGFzc05hbWU6IFwiYWJzb2x1dGUgcmlnaHQtWy02N3B4XSB0b3AtWzE4NnB4XSB6LVsyXVwiLCBzcmM6IGJnX3BhdHRlcm5fd2F2eV93aGl0ZV9zdmdfMS5kZWZhdWx0LCB3aWR0aDogMTM0LCBoZWlnaHQ6IDYwIH0pLCAoMCwganN4X3J1bnRpbWVfMS5qc3hzKShcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJtbC1bMTY1cHhdIGZsZXggaC1bMjMzcHhdIHctWzQ0NXB4XSBmbGV4LWNvbCBnYXAtWzUxcHhdXCIsIGNoaWxkcmVuOiBbKDAsIGpzeF9ydW50aW1lXzEuanN4KShcImgyXCIsIHsgY2xhc3NOYW1lOiBcInRleHQtd2hpdGVcIiwgY2hpbGRyZW46IHRpdGxlW2N1cnJlbnRTbGlkZV0ubWFpblRpdGxlIH0pLCAoMCwganN4X3J1bnRpbWVfMS5qc3hzKShcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmbGV4IGdhcC1bMTZweF1cIiwgY2hpbGRyZW46IFsoMCwganN4X3J1bnRpbWVfMS5qc3gpKFwiYnV0dG9uXCIsIHsgZGlzYWJsZWQ6IGlzUGxheWluZywgb25DbGljazogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZvaWQgKChfYSA9IGZsaWNraW5nLmN1cnJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wcmV2KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHRpdGxlOiBcInByZXZpb3VzIHNsaWRlXCIsIHR5cGU6IFwiYnV0dG9uXCIsIGNsYXNzTmFtZTogXCJwcmV2aW91cyByZWxhdGl2ZSB6LTQwIHNpemUtWzQwcHhdXCIsIGNoaWxkcmVuOiAoMCwganN4X3J1bnRpbWVfMS5qc3hzKShcInN2Z1wiLCB7IHdpZHRoOiBcIjQwXCIsIGhlaWdodDogXCI0MFwiLCB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBjaGlsZHJlbjogWygwLCBqc3hfcnVudGltZV8xLmpzeCkoXCJ0aXRsZVwiLCB7IGNoaWxkcmVuOiB0aXRsZXNCdXR0b25zLnByZXZpb3VzIH0pLCAoMCwganN4X3J1bnRpbWVfMS5qc3hzKShcImdcIiwgeyB0cmFuc2Zvcm06IFwibWF0cml4KC0xIDAgMCAxIDQwIDApXCIsIGZpbGw6IFwibm9uZVwiLCBmaWxsUnVsZTogXCJldmVub2RkXCIsIGNoaWxkcmVuOiBbKDAsIGpzeF9ydW50aW1lXzEuanN4KShcImNpcmNsZVwiLCB7IGN4OiBcIjIwXCIsIGN5OiBcIjIwXCIsIHI6IFwiMTkuNVwiIH0pLCAoMCwganN4X3J1bnRpbWVfMS5qc3gpKFwicGF0aFwiLCB7IHN0cm9rZVdpZHRoOiBcIjJcIiwgZDogXCJNMTcuNSAxNWw1IDUtNSA1XCIgfSldIH0pXSB9KSB9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4KShcImJ1dHRvblwiLCB7IGRpc2FibGVkOiBpc1BsYXlpbmcsIG9uQ2xpY2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2b2lkICgoX2EgPSBmbGlja2luZy5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubmV4dCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCB0aXRsZTogXCJuZXh0IHNsaWRlXCIsIHR5cGU6IFwiYnV0dG9uXCIsIGNsYXNzTmFtZTogXCJwcmV2aW91cyByZWxhdGl2ZSB6LTQwIHNpemUtWzQwcHhdXCIsIGNoaWxkcmVuOiAoMCwganN4X3J1bnRpbWVfMS5qc3hzKShcInN2Z1wiLCB7IHdpZHRoOiBcIjQwXCIsIGhlaWdodDogXCI0MFwiLCB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBjaGlsZHJlbjogWygwLCBqc3hfcnVudGltZV8xLmpzeCkoXCJ0aXRsZVwiLCB7IGNoaWxkcmVuOiB0aXRsZXNCdXR0b25zLm5leHQgfSksICgwLCBqc3hfcnVudGltZV8xLmpzeHMpKFwiZ1wiLCB7IGZpbGw6IFwibm9uZVwiLCBmaWxsUnVsZTogXCJldmVub2RkXCIsIGNoaWxkcmVuOiBbKDAsIGpzeF9ydW50aW1lXzEuanN4KShcImNpcmNsZVwiLCB7IGN4OiBcIjIwXCIsIGN5OiBcIjIwXCIsIHI6IFwiMTkuNVwiIH0pLCAoMCwganN4X3J1bnRpbWVfMS5qc3gpKFwicGF0aFwiLCB7IHN0cm9rZVdpZHRoOiBcIjJcIiwgZDogXCJNMTcuNSAxNWw1IDUtNSA1XCIgfSldIH0pXSB9KSB9KV0gfSldIH0pXSB9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4cykoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiYWJzb2x1dGUgcmlnaHQtMCB6LTAgaC1bNzI4cHhdIHctWzg5NXB4XSBcIiwgY2hpbGRyZW46IFsoMCwganN4X3J1bnRpbWVfMS5qc3hzKShwcmVhY3RfZmxpY2tpbmdfMS5kZWZhdWx0LCB7IG9uTW92ZVN0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0SXNQbGF5aW5nKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgb25Nb3ZlRW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0SXNQbGF5aW5nKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHJlZjogZmxpY2tpbmcsIGNpcmN1bGFyOiB0cnVlLCBvbkNoYW5nZWQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0Q3VycmVudFNsaWRlKGUuaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgY2hpbGRyZW46IFsoMCwganN4X3J1bnRpbWVfMS5qc3gpKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInBhbmVsIGltYWdlLWNvbnRhaW5lciBob3ZlcjpjdXJzb3ItZ3JhYiBhY3RpdmU6Y3Vyc29yLWdyYWJiaW5nXCIsIGNoaWxkcmVuOiAoMCwganN4X3J1bnRpbWVfMS5qc3gpKFwiaW1nXCIsIHsgY2xhc3NOYW1lOiBcInBvaW50ZXItZXZlbnRzLW5vbmVcIiwgc3JjOiBpbWFnZV9zbGlkZV8xX2pwZ18xLmRlZmF1bHQsIGFsdDogXCJTbGlkZSAxXCIgfSkgfSwgVGl0bGVLZXkuZ3VpZGVsaW5lcyksICgwLCBqc3hfcnVudGltZV8xLmpzeCkoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwicGFuZWwgaW1hZ2UtY29udGFpbmVyIGhvdmVyOmN1cnNvci1ncmFiIGFjdGl2ZTpjdXJzb3ItZ3JhYmJpbmdcIiwgY2hpbGRyZW46ICgwLCBqc3hfcnVudGltZV8xLmpzeCkoXCJpbWdcIiwgeyBjbGFzc05hbWU6IFwicG9pbnRlci1ldmVudHMtbm9uZVwiLCBzcmM6IGltYWdlX3NsaWRlXzJfanBnXzEuZGVmYXVsdCwgYWx0OiBcIlNsaWRlIDJcIiB9KSB9LCBUaXRsZUtleS5tZXJjaGFuZGlzZSksICgwLCBqc3hfcnVudGltZV8xLmpzeCkoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwicGFuZWwgaW1hZ2UtY29udGFpbmVyIGhvdmVyOmN1cnNvci1ncmFiIGFjdGl2ZTpjdXJzb3ItZ3JhYmJpbmdcIiwgY2hpbGRyZW46ICgwLCBqc3hfcnVudGltZV8xLmpzeCkoXCJpbWdcIiwgeyBjbGFzc05hbWU6IFwicG9pbnRlci1ldmVudHMtbm9uZVwiLCBzcmM6IGltYWdlX3NsaWRlXzNfanBnXzEuZGVmYXVsdCwgYWx0OiBcIlNsaWRlIDNcIiB9KSB9LCBUaXRsZUtleS5kZXNpZ24pXSB9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4KShcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJhYnNvbHV0ZSBib3R0b20tWzY4cHhdIHJpZ2h0LVsxNTRweF0gei1bMV1cIiwgY2hpbGRyZW46ICgwLCBqc3hfcnVudGltZV8xLmpzeHMpKFwic2VjdGlvblwiLCB7IGNsYXNzTmFtZTogXCJmbGV4IGZsZXgtY29sIHRleHQtZW5kXCIsIGNoaWxkcmVuOiBbKDAsIGpzeF9ydW50aW1lXzEuanN4KShcImgzXCIsIHsgY2xhc3NOYW1lOiBcInRleHQtd2hpdGVcIiwgY2hpbGRyZW46IHRpdGxlW2N1cnJlbnRTbGlkZV0udGl0bGUgfSksICgwLCBqc3hfcnVudGltZV8xLmpzeCkoXCJwXCIsIHsgY2xhc3NOYW1lOiBcInRleHQtd2hpdGVcIiwgY2hpbGRyZW46IHRpdGxlW2N1cnJlbnRTbGlkZV0uZGVzY3JpcHRpb24gfSldIH0pIH0pXSB9KV0gfSkpO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBGb290ZXI7XG52YXIganN4X3J1bnRpbWVfMSA9IHJlcXVpcmUoXCJwcmVhY3QvanN4LXJ1bnRpbWVcIik7XG52YXIgYmdfcGF0dGVybl93YXZlX3JlZF9zdmdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vYXNzZXRzL2Rlc2t0b3AvYmctcGF0dGVybi13YXZlLXJlZC5zdmdcIikpO1xudmFyIGl0ZW1zID0ge1xuICAgIHRpdGxlOiAnTGV04oCZcyBidWlsZCBzb21ldGhpbmcgZ3JlYXQgdG9nZXRoZXIuJyxcbiAgICBidXR0b25EZXNjcmlwdGlvbjogJ1NjaGVkdWxlIGEgQ2FsbCcsXG59O1xuZnVuY3Rpb24gRm9vdGVyKCkge1xuICAgIHJldHVybiAoKDAsIGpzeF9ydW50aW1lXzEuanN4cykoXCJmb290ZXJcIiwgeyBjbGFzc05hbWU6IFwibXgtYXV0byBtYi1bMTE1cHhdIG1sLVstNjdweF0gbXQtWzEyMHB4XSBmbGV4IHctZnVsbCBtYXgtdy1bMTM0MnB4XSBpdGVtcy1jZW50ZXJcIiwgY2hpbGRyZW46IFsoMCwganN4X3J1bnRpbWVfMS5qc3gpKFwiaW1nXCIsIHsgYWx0OiBcInBhdHRlcm5cIiwgc3JjOiBiZ19wYXR0ZXJuX3dhdmVfcmVkX3N2Z18xLmRlZmF1bHQsIHdpZHRoOiAxMzQsIGhlaWdodDogNjAgfSksICgwLCBqc3hfcnVudGltZV8xLmpzeHMpKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcIm1sLVs5OHB4XSBmbGV4IHctZnVsbCBpdGVtcy1jZW50ZXIganVzdGlmeS1iZXR3ZWVuXCIsIGNoaWxkcmVuOiBbKDAsIGpzeF9ydW50aW1lXzEuanN4KShcImgyXCIsIHsgY2xhc3NOYW1lOiBcIm1heC13LVs2MzVweF1cIiwgY2hpbGRyZW46IGl0ZW1zLnRpdGxlIH0pLCAoMCwganN4X3J1bnRpbWVfMS5qc3gpKFwiYnV0dG9uXCIsIHsgdHlwZTogXCJidXR0b25cIiwgY2xhc3NOYW1lOiBcImgtWzY0cHhdIHctWzE5OXB4XSBiZy1bI0Y5NEY0Rl0gdGV4dC1bMTZweF0gZm9udC1leHRyYWJvbGQgdGV4dC13aGl0ZSB0cmFuc2l0aW9uIGhvdmVyOmJnLVsjRkY5MzkzXVwiLCBjaGlsZHJlbjogaXRlbXMuYnV0dG9uRGVzY3JpcHRpb24gfSldIH0pXSB9KSk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IE5hdmJhcjtcbnZhciBqc3hfcnVudGltZV8xID0gcmVxdWlyZShcInByZWFjdC9qc3gtcnVudGltZVwiKTtcbnZhciBsb2dvX3N2Z18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi8uLi9hc3NldHMvZGVza3RvcC9sb2dvLnN2Z1wiKSk7XG52YXIgcHJlYWN0X3JvdXRlcl8xID0gcmVxdWlyZShcInByZWFjdC1yb3V0ZXJcIik7XG52YXIgaXRlbXMgPSBbXG4gICAge1xuICAgICAgICB0aXRsZTogJ0Fib3V0JyxcbiAgICAgICAgaHJlZjogJyMnLFxuICAgIH0sXG4gICAge1xuICAgICAgICB0aXRsZTogJ1NlcnZpY2UnLFxuICAgICAgICBocmVmOiAnIycsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHRpdGxlOiAnUHJvamVjdHMnLFxuICAgICAgICBocmVmOiAnIycsXG4gICAgfSxcbl07XG52YXIgYnV0dG9uVGl0bGUgPSAnU2NoZWR1bGUgYSBDYWxsJztcbmZ1bmN0aW9uIE5hdmJhcigpIHtcbiAgICByZXR1cm4gKCgwLCBqc3hfcnVudGltZV8xLmpzeHMpKFwibmF2XCIsIHsgY2xhc3NOYW1lOiBcInotWzJdIGZsZXggaC1bNjRweF0gdy1mdWxsIG1heC13LVtjYWxjKDEyNzVweCszOXB4KV0gaXRlbXMtY2VudGVyIGp1c3RpZnktYmV0d2VlbiBzZWxmLWVuZCBvdmVyZmxvdy14LWNsaXAgcGwtWzM5cHhdIG1kOmgtWzE3OHB4XVwiLCBjaGlsZHJlbjogWygwLCBqc3hfcnVudGltZV8xLmpzeCkoXCJpbWdcIiwgeyBzcmM6IGxvZ29fc3ZnXzEuZGVmYXVsdCwgYWx0OiBcImxvZ29cIiB9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4cykoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmxleCBzaXplLWZ1bGwgbWF4LXctWzQzOHB4XSBpdGVtcy1jZW50ZXIgZ2FwLVsyOHB4XSBiZy1bI0Y5NEY0Rl0gcGwtWzMzcHhdIHByLVs0MHB4XSBsZzptYXgtdy1bNTMwcHhdIGxnOmdhcC1bNTBweF0gbGc6cHItWzIwcHhdIHhsOm1heC13LVs0N3Z3XSB4bDpnYXAtWzQ4cHhdIHhsOnBsLVs2OXB4XSB4bDpwci0wIHNjcmVlbjE1MDA6bWF4LXctWzcwNXB4XVwiLCBjaGlsZHJlbjogWygwLCBqc3hfcnVudGltZV8xLmpzeCkoXCJ1bFwiLCB7IGNsYXNzTmFtZTogXCJmbGV4IHctZnVsbCBtYXgtdy1bMTkwcHhdIGp1c3RpZnktYmV0d2VlbiB4bDptYXgtdy1bMjI1cHhdXCIsIGNoaWxkcmVuOiBpdGVtcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuICgoMCwganN4X3J1bnRpbWVfMS5qc3gpKFwibGlcIiwgeyBjaGlsZHJlbjogKDAsIGpzeF9ydW50aW1lXzEuanN4KShwcmVhY3Rfcm91dGVyXzEuTGluaywgeyBjbGFzc05hbWU6IFwiIGxlYWRpbmctWzMycHhdIHRleHQtd2hpdGUgdHJhbnNpdGlvbi1hbGwgaG92ZXI6Zm9udC1ib2xkXCIsIGhyZWY6IGl0ZW0uaHJlZiwgY2hpbGRyZW46IGl0ZW0udGl0bGUgfSkgfSwgaXRlbS50aXRsZSkpOyB9KSB9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4KShcImJ1dHRvblwiLCB7IHR5cGU6IFwiYnV0dG9uXCIsIGNsYXNzTmFtZTogXCJoLVs2NHB4XSBtaW4tdy1bMTQ3cHhdIGJnLVsjMTkxOTIxXSB0ZXh0LVsxNnB4XSBmb250LWV4dHJhYm9sZCB0ZXh0LXdoaXRlIHRyYW5zaXRpb24gaG92ZXI6YmctWyM0MzQzNTZdIHhsOm1pbi13LVsxOTlweF1cIiwgY2hpbGRyZW46IGJ1dHRvblRpdGxlIH0pXSB9KV0gfSkpO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIganN4X3J1bnRpbWVfMSA9IHJlcXVpcmUoXCJwcmVhY3QvanN4LXJ1bnRpbWVcIik7XG52YXIgcHJlYWN0XzEgPSByZXF1aXJlKFwicHJlYWN0XCIpO1xuLy8gaW1wb3J0IERhdGFDb250ZXh0IGZyb20gJy4vX2xpYi9EYXRhQ29udGV4dCc7IC8vIHBsYWNlaG9sZGVyXG52YXIgTmF2YmFyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vY29tcG9uZW50cy9OYXZiYXJcIikpO1xudmFyIHBhZ2VfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9wYWdlXCIpKTtcbnZhciBGb290ZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9jb21wb25lbnRzL0Zvb3RlclwiKSk7XG5yZXF1aXJlKFwiLi9nbG9iYWxzLmNzc1wiKTtcbmRvY3VtZW50LmJvZHkuY2xhc3NOYW1lID1cbiAgICAnbWluLWgtZHZoIG14LWF1dG8gbWQ6bWluLWgtc2NyZWVuIG1heC13LVsxNDQwcHhdIGZsZXggZmxleC1jb2wgaXRlbXMtY2VudGVyIGZvbnQtY29tbWlzc2lvbmVyIGp1c3RpZnktc3BhY2UtYmV0d2Vlbic7XG5mdW5jdGlvbiBBcHAoKSB7XG4gICAgcmV0dXJuICgoMCwganN4X3J1bnRpbWVfMS5qc3hzKShqc3hfcnVudGltZV8xLkZyYWdtZW50LCB7IGNoaWxkcmVuOiBbKDAsIGpzeF9ydW50aW1lXzEuanN4KShOYXZiYXJfMS5kZWZhdWx0LCB7fSksICgwLCBqc3hfcnVudGltZV8xLmpzeCkoXCJtYWluXCIsIHsgY2xhc3NOYW1lOiBcIm14LWF1dG8gbWItYXV0byBmbGV4IHctZnVsbCBmbGV4LWNvbCBpdGVtcy1jZW50ZXIgb3ZlcmZsb3cteC1jbGlwXCIsIGNoaWxkcmVuOiAoMCwganN4X3J1bnRpbWVfMS5qc3gpKHBhZ2VfMS5kZWZhdWx0LCB7fSkgfSksICgwLCBqc3hfcnVudGltZV8xLmpzeCkoRm9vdGVyXzEuZGVmYXVsdCwge30pXSB9KSk7XG59XG5mdW5jdGlvbiBCb2R5KCkge1xuICAgIHJldHVybiAoMCwganN4X3J1bnRpbWVfMS5qc3gpKEFwcCwge30pO1xufVxuKDAsIHByZWFjdF8xLnJlbmRlcikoKDAsIGpzeF9ydW50aW1lXzEuanN4KShCb2R5LCB7fSksIGRvY3VtZW50LmJvZHkpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIganN4X3J1bnRpbWVfMSA9IHJlcXVpcmUoXCJwcmVhY3QvanN4LXJ1bnRpbWVcIik7XG52YXIgQmxvY2sxXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vY29tcG9uZW50cy9CbG9jazFcIikpO1xudmFyIEJsb2NrMl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2NvbXBvbmVudHMvQmxvY2syXCIpKTtcbnZhciBCbG9jazNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9jb21wb25lbnRzL0Jsb2NrM1wiKSk7XG52YXIgQmxvY2s0XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vY29tcG9uZW50cy9CbG9jazRcIikpO1xudmFyIEhvbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICgoMCwganN4X3J1bnRpbWVfMS5qc3hzKShqc3hfcnVudGltZV8xLkZyYWdtZW50LCB7IGNoaWxkcmVuOiBbKDAsIGpzeF9ydW50aW1lXzEuanN4KShCbG9jazFfMS5kZWZhdWx0LCB7fSksICgwLCBqc3hfcnVudGltZV8xLmpzeCkoQmxvY2syXzEuZGVmYXVsdCwge30pLCAoMCwganN4X3J1bnRpbWVfMS5qc3gpKEJsb2NrM18xLmRlZmF1bHQsIHt9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4KShCbG9jazRfMS5kZWZhdWx0LCB7fSldIH0pKTtcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBIb21lO1xuIiwiaW1wb3J0e2NyZWF0ZUNvbnRleHQgYXMgbixDb21wb25lbnQgYXMgdCx0b0NoaWxkQXJyYXkgYXMgcixjbG9uZUVsZW1lbnQgYXMgaSxoIGFzIG99ZnJvbVwicHJlYWN0XCI7aW1wb3J0e3VzZUNvbnRleHQgYXMgZSx1c2VTdGF0ZSBhcyB1LHVzZUVmZmVjdCBhcyBmfWZyb21cInByZWFjdC9ob29rc1wiO3ZhciBhPXt9O2Z1bmN0aW9uIGMobix0KXtmb3IodmFyIHIgaW4gdCluW3JdPXRbcl07cmV0dXJuIG59ZnVuY3Rpb24gcyhuLHQscil7dmFyIGksbz0vKD86XFw/KFteI10qKSk/KCMuKik/JC8sZT1uLm1hdGNoKG8pLHU9e307aWYoZSYmZVsxXSlmb3IodmFyIGY9ZVsxXS5zcGxpdChcIiZcIiksYz0wO2M8Zi5sZW5ndGg7YysrKXt2YXIgcz1mW2NdLnNwbGl0KFwiPVwiKTt1W2RlY29kZVVSSUNvbXBvbmVudChzWzBdKV09ZGVjb2RlVVJJQ29tcG9uZW50KHMuc2xpY2UoMSkuam9pbihcIj1cIikpfW49ZChuLnJlcGxhY2UobyxcIlwiKSksdD1kKHR8fFwiXCIpO2Zvcih2YXIgaD1NYXRoLm1heChuLmxlbmd0aCx0Lmxlbmd0aCksdj0wO3Y8aDt2KyspaWYodFt2XSYmXCI6XCI9PT10W3ZdLmNoYXJBdCgwKSl7dmFyIGw9dFt2XS5yZXBsYWNlKC8oXjp8WysqP10rJCkvZyxcIlwiKSxwPSh0W3ZdLm1hdGNoKC9bKyo/XSskLyl8fGEpWzBdfHxcIlwiLG09fnAuaW5kZXhPZihcIitcIikseT1+cC5pbmRleE9mKFwiKlwiKSxVPW5bdl18fFwiXCI7aWYoIVUmJiF5JiYocC5pbmRleE9mKFwiP1wiKTwwfHxtKSl7aT0hMTticmVha31pZih1W2xdPWRlY29kZVVSSUNvbXBvbmVudChVKSxtfHx5KXt1W2xdPW4uc2xpY2UodikubWFwKGRlY29kZVVSSUNvbXBvbmVudCkuam9pbihcIi9cIik7YnJlYWt9fWVsc2UgaWYodFt2XSE9PW5bdl0pe2k9ITE7YnJlYWt9cmV0dXJuKCEwPT09ci5kZWZhdWx0fHwhMSE9PWkpJiZ1fWZ1bmN0aW9uIGgobix0KXtyZXR1cm4gbi5yYW5rPHQucmFuaz8xOm4ucmFuaz50LnJhbms/LTE6bi5pbmRleC10LmluZGV4fWZ1bmN0aW9uIHYobix0KXtyZXR1cm4gbi5pbmRleD10LG4ucmFuaz1mdW5jdGlvbihuKXtyZXR1cm4gbi5wcm9wcy5kZWZhdWx0PzA6ZChuLnByb3BzLnBhdGgpLm1hcChsKS5qb2luKFwiXCIpfShuKSxuLnByb3BzfWZ1bmN0aW9uIGQobil7cmV0dXJuIG4ucmVwbGFjZSgvKF5cXC8rfFxcLyskKS9nLFwiXCIpLnNwbGl0KFwiL1wiKX1mdW5jdGlvbiBsKG4pe3JldHVyblwiOlwiPT1uLmNoYXJBdCgwKT8xK1wiKis/XCIuaW5kZXhPZihuLmNoYXJBdChuLmxlbmd0aC0xKSl8fDQ6NX12YXIgcD17fSxtPVtdLHk9W10sVT1udWxsLGc9e3VybDpSKCl9LGs9bihnKTtmdW5jdGlvbiBDKCl7dmFyIG49ZShrKTtpZihuPT09Zyl7dmFyIHQ9dSgpWzFdO2YoZnVuY3Rpb24oKXtyZXR1cm4geS5wdXNoKHQpLGZ1bmN0aW9uKCl7cmV0dXJuIHkuc3BsaWNlKHkuaW5kZXhPZih0KSwxKX19LFtdKX1yZXR1cm5bbiwkXX1mdW5jdGlvbiBSKCl7dmFyIG47cmV0dXJuXCJcIisoKG49VSYmVS5sb2NhdGlvbj9VLmxvY2F0aW9uOlUmJlUuZ2V0Q3VycmVudExvY2F0aW9uP1UuZ2V0Q3VycmVudExvY2F0aW9uKCk6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGxvY2F0aW9uP2xvY2F0aW9uOnApLnBhdGhuYW1lfHxcIlwiKSsobi5zZWFyY2h8fFwiXCIpfWZ1bmN0aW9uICQobix0KXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9ITEpLFwic3RyaW5nXCIhPXR5cGVvZiBuJiZuLnVybCYmKHQ9bi5yZXBsYWNlLG49bi51cmwpLGZ1bmN0aW9uKG4pe2Zvcih2YXIgdD1tLmxlbmd0aDt0LS07KWlmKG1bdF0uY2FuUm91dGUobikpcmV0dXJuITA7cmV0dXJuITF9KG4pJiZmdW5jdGlvbihuLHQpe3ZvaWQgMD09PXQmJih0PVwicHVzaFwiKSxVJiZVW3RdP1VbdF0obik6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGhpc3RvcnkmJmhpc3RvcnlbdCtcIlN0YXRlXCJdJiZoaXN0b3J5W3QrXCJTdGF0ZVwiXShudWxsLG51bGwsbil9KG4sdD9cInJlcGxhY2VcIjpcInB1c2hcIiksSShuKX1mdW5jdGlvbiBJKG4pe2Zvcih2YXIgdD0hMSxyPTA7cjxtLmxlbmd0aDtyKyspbVtyXS5yb3V0ZVRvKG4pJiYodD0hMCk7cmV0dXJuIHR9ZnVuY3Rpb24gTShuKXtpZihuJiZuLmdldEF0dHJpYnV0ZSl7dmFyIHQ9bi5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpLHI9bi5nZXRBdHRyaWJ1dGUoXCJ0YXJnZXRcIik7aWYodCYmdC5tYXRjaCgvXlxcLy9nKSYmKCFyfHxyLm1hdGNoKC9eXz9zZWxmJC9pKSkpcmV0dXJuICQodCl9fWZ1bmN0aW9uIGIobil7cmV0dXJuIG4uc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uJiZuLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpLG4uc3RvcFByb3BhZ2F0aW9uJiZuLnN0b3BQcm9wYWdhdGlvbigpLG4ucHJldmVudERlZmF1bHQoKSwhMX1mdW5jdGlvbiBXKG4pe2lmKCEobi5jdHJsS2V5fHxuLm1ldGFLZXl8fG4uYWx0S2V5fHxuLnNoaWZ0S2V5fHxuLmJ1dHRvbikpe3ZhciB0PW4udGFyZ2V0O2Rve2lmKFwiYVwiPT09dC5sb2NhbE5hbWUmJnQuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSl7aWYodC5oYXNBdHRyaWJ1dGUoXCJkYXRhLW5hdGl2ZVwiKXx8dC5oYXNBdHRyaWJ1dGUoXCJuYXRpdmVcIikpcmV0dXJuO2lmKE0odCkpcmV0dXJuIGIobil9fXdoaWxlKHQ9dC5wYXJlbnROb2RlKX19dmFyIHc9ITE7ZnVuY3Rpb24gRChuKXtuLmhpc3RvcnkmJihVPW4uaGlzdG9yeSksdGhpcy5zdGF0ZT17dXJsOm4udXJsfHxSKCl9fWMoRC5wcm90b3R5cGU9bmV3IHQse3Nob3VsZENvbXBvbmVudFVwZGF0ZTpmdW5jdGlvbihuKXtyZXR1cm4hMCE9PW4uc3RhdGljfHxuLnVybCE9PXRoaXMucHJvcHMudXJsfHxuLm9uQ2hhbmdlIT09dGhpcy5wcm9wcy5vbkNoYW5nZX0sY2FuUm91dGU6ZnVuY3Rpb24obil7dmFyIHQ9cih0aGlzLnByb3BzLmNoaWxkcmVuKTtyZXR1cm4gdm9pZCAwIT09dGhpcy5nKHQsbil9LHJvdXRlVG86ZnVuY3Rpb24obil7dGhpcy5zZXRTdGF0ZSh7dXJsOm59KTt2YXIgdD10aGlzLmNhblJvdXRlKG4pO3JldHVybiB0aGlzLnB8fHRoaXMuZm9yY2VVcGRhdGUoKSx0fSxjb21wb25lbnRXaWxsTW91bnQ6ZnVuY3Rpb24oKXt0aGlzLnA9ITB9LGNvbXBvbmVudERpZE1vdW50OmZ1bmN0aW9uKCl7dmFyIG49dGhpczt3fHwodz0hMCxVfHxhZGRFdmVudExpc3RlbmVyKFwicG9wc3RhdGVcIixmdW5jdGlvbigpe0koUigpKX0pLGFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLFcpKSxtLnB1c2godGhpcyksVSYmKHRoaXMudT1VLmxpc3RlbihmdW5jdGlvbih0KXt2YXIgcj10LmxvY2F0aW9ufHx0O24ucm91dGVUbyhcIlwiKyhyLnBhdGhuYW1lfHxcIlwiKSsoci5zZWFyY2h8fFwiXCIpKX0pKSx0aGlzLnA9ITF9LGNvbXBvbmVudFdpbGxVbm1vdW50OmZ1bmN0aW9uKCl7XCJmdW5jdGlvblwiPT10eXBlb2YgdGhpcy51JiZ0aGlzLnUoKSxtLnNwbGljZShtLmluZGV4T2YodGhpcyksMSl9LGNvbXBvbmVudFdpbGxVcGRhdGU6ZnVuY3Rpb24oKXt0aGlzLnA9ITB9LGNvbXBvbmVudERpZFVwZGF0ZTpmdW5jdGlvbigpe3RoaXMucD0hMX0sZzpmdW5jdGlvbihuLHQpe249bi5maWx0ZXIodikuc29ydChoKTtmb3IodmFyIHI9MDtyPG4ubGVuZ3RoO3IrKyl7dmFyIGk9bltyXSxvPXModCxpLnByb3BzLnBhdGgsaS5wcm9wcyk7aWYobylyZXR1cm5baSxvXX19LHJlbmRlcjpmdW5jdGlvbihuLHQpe3ZhciBlLHUsZj1uLm9uQ2hhbmdlLGE9dC51cmwscz10aGlzLmMsaD10aGlzLmcocihuLmNoaWxkcmVuKSxhKTtpZihoJiYodT1pKGhbMF0sYyhjKHt1cmw6YSxtYXRjaGVzOmU9aFsxXX0sZSkse2tleTp2b2lkIDAscmVmOnZvaWQgMH0pKSksYSE9PShzJiZzLnVybCkpe2MoZyxzPXRoaXMuYz17dXJsOmEscHJldmlvdXM6cyYmcy51cmwsY3VycmVudDp1LHBhdGg6dT91LnByb3BzLnBhdGg6bnVsbCxtYXRjaGVzOmV9KSxzLnJvdXRlcj10aGlzLHMuYWN0aXZlPXU/W3VdOltdO2Zvcih2YXIgdj15Lmxlbmd0aDt2LS07KXlbdl0oe30pO1wiZnVuY3Rpb25cIj09dHlwZW9mIGYmJmYocyl9cmV0dXJuIG8oay5Qcm92aWRlcix7dmFsdWU6c30sdSl9fSk7dmFyIEU9ZnVuY3Rpb24obil7cmV0dXJuIG8oXCJhXCIsYyh7b25DbGljazpXfSxuKSl9LEw9ZnVuY3Rpb24obil7cmV0dXJuIG8obi5jb21wb25lbnQsbil9O2V4cG9ydHtFIGFzIExpbmssTCBhcyBSb3V0ZSxEIGFzIFJvdXRlcixEIGFzIGRlZmF1bHQscyBhcyBleGVjLFIgYXMgZ2V0Q3VycmVudFVybCwkIGFzIHJvdXRlLEMgYXMgdXNlUm91dGVyfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByZWFjdC1yb3V0ZXIubW9kdWxlLmpzLm1hcFxuIiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdGlmIChjYWNoZWRNb2R1bGUuZXJyb3IgIT09IHVuZGVmaW5lZCkgdGhyb3cgY2FjaGVkTW9kdWxlLmVycm9yO1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHRpZDogbW9kdWxlSWQsXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHR0cnkge1xuXHRcdHZhciBleGVjT3B0aW9ucyA9IHsgaWQ6IG1vZHVsZUlkLCBtb2R1bGU6IG1vZHVsZSwgZmFjdG9yeTogX193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0sIHJlcXVpcmU6IF9fd2VicGFja19yZXF1aXJlX18gfTtcblx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmkuZm9yRWFjaChmdW5jdGlvbihoYW5kbGVyKSB7IGhhbmRsZXIoZXhlY09wdGlvbnMpOyB9KTtcblx0XHRtb2R1bGUgPSBleGVjT3B0aW9ucy5tb2R1bGU7XG5cdFx0ZXhlY09wdGlvbnMuZmFjdG9yeS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBleGVjT3B0aW9ucy5yZXF1aXJlKTtcblx0fSBjYXRjaChlKSB7XG5cdFx0bW9kdWxlLmVycm9yID0gZTtcblx0XHR0aHJvdyBlO1xuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4vLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuX193ZWJwYWNrX3JlcXVpcmVfXy5tID0gX193ZWJwYWNrX21vZHVsZXNfXztcblxuLy8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbl9fd2VicGFja19yZXF1aXJlX18uYyA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfXztcblxuLy8gZXhwb3NlIHRoZSBtb2R1bGUgZXhlY3V0aW9uIGludGVyY2VwdG9yXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmkgPSBbXTtcblxuIiwiLy8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbl9fd2VicGFja19yZXF1aXJlX18ubiA9IChtb2R1bGUpID0+IHtcblx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG5cdFx0KCkgPT4gKG1vZHVsZVsnZGVmYXVsdCddKSA6XG5cdFx0KCkgPT4gKG1vZHVsZSk7XG5cdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsIHsgYTogZ2V0dGVyIH0pO1xuXHRyZXR1cm4gZ2V0dGVyO1xufTsiLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCIvLyBUaGlzIGZ1bmN0aW9uIGFsbG93IHRvIHJlZmVyZW5jZSBhbGwgY2h1bmtzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmh1ID0gKGNodW5rSWQpID0+IHtcblx0Ly8gcmV0dXJuIHVybCBmb3IgZmlsZW5hbWVzIGJhc2VkIG9uIHRlbXBsYXRlXG5cdHJldHVybiBcIlwiICsgY2h1bmtJZCArIFwiLlwiICsgX193ZWJwYWNrX3JlcXVpcmVfXy5oKCkgKyBcIi5ob3QtdXBkYXRlLmpzXCI7XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18uaG1yRiA9ICgpID0+IChcIm1haW4uXCIgKyBfX3dlYnBhY2tfcmVxdWlyZV9fLmgoKSArIFwiLmhvdC11cGRhdGUuanNvblwiKTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLmggPSAoKSA9PiAoXCI1YzNjNDk2NjNhY2FiNmNlMDFmMFwiKSIsIl9fd2VicGFja19yZXF1aXJlX18uZyA9IChmdW5jdGlvbigpIHtcblx0aWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSAnb2JqZWN0JykgcmV0dXJuIGdsb2JhbFRoaXM7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIHRoaXMgfHwgbmV3IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcpIHJldHVybiB3aW5kb3c7XG5cdH1cbn0pKCk7IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSIsInZhciBpblByb2dyZXNzID0ge307XG52YXIgZGF0YVdlYnBhY2tQcmVmaXggPSBcImZsYXNrLXByZWFjdC10eXBlc2NyaXB0LXRhaWx3aW5kLXRlbXBsYXRlOlwiO1xuLy8gbG9hZFNjcmlwdCBmdW5jdGlvbiB0byBsb2FkIGEgc2NyaXB0IHZpYSBzY3JpcHQgdGFnXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmwgPSAodXJsLCBkb25lLCBrZXksIGNodW5rSWQpID0+IHtcblx0aWYoaW5Qcm9ncmVzc1t1cmxdKSB7IGluUHJvZ3Jlc3NbdXJsXS5wdXNoKGRvbmUpOyByZXR1cm47IH1cblx0dmFyIHNjcmlwdCwgbmVlZEF0dGFjaDtcblx0aWYoa2V5ICE9PSB1bmRlZmluZWQpIHtcblx0XHR2YXIgc2NyaXB0cyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic2NyaXB0XCIpO1xuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBzY3JpcHRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgcyA9IHNjcmlwdHNbaV07XG5cdFx0XHRpZihzLmdldEF0dHJpYnV0ZShcInNyY1wiKSA9PSB1cmwgfHwgcy5nZXRBdHRyaWJ1dGUoXCJkYXRhLXdlYnBhY2tcIikgPT0gZGF0YVdlYnBhY2tQcmVmaXggKyBrZXkpIHsgc2NyaXB0ID0gczsgYnJlYWs7IH1cblx0XHR9XG5cdH1cblx0aWYoIXNjcmlwdCkge1xuXHRcdG5lZWRBdHRhY2ggPSB0cnVlO1xuXHRcdHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuXG5cdFx0c2NyaXB0LmNoYXJzZXQgPSAndXRmLTgnO1xuXHRcdHNjcmlwdC50aW1lb3V0ID0gMTIwO1xuXHRcdGlmIChfX3dlYnBhY2tfcmVxdWlyZV9fLm5jKSB7XG5cdFx0XHRzY3JpcHQuc2V0QXR0cmlidXRlKFwibm9uY2VcIiwgX193ZWJwYWNrX3JlcXVpcmVfXy5uYyk7XG5cdFx0fVxuXHRcdHNjcmlwdC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXdlYnBhY2tcIiwgZGF0YVdlYnBhY2tQcmVmaXggKyBrZXkpO1xuXG5cdFx0c2NyaXB0LnNyYyA9IHVybDtcblx0fVxuXHRpblByb2dyZXNzW3VybF0gPSBbZG9uZV07XG5cdHZhciBvblNjcmlwdENvbXBsZXRlID0gKHByZXYsIGV2ZW50KSA9PiB7XG5cdFx0Ly8gYXZvaWQgbWVtIGxlYWtzIGluIElFLlxuXHRcdHNjcmlwdC5vbmVycm9yID0gc2NyaXB0Lm9ubG9hZCA9IG51bGw7XG5cdFx0Y2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuXHRcdHZhciBkb25lRm5zID0gaW5Qcm9ncmVzc1t1cmxdO1xuXHRcdGRlbGV0ZSBpblByb2dyZXNzW3VybF07XG5cdFx0c2NyaXB0LnBhcmVudE5vZGUgJiYgc2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcblx0XHRkb25lRm5zICYmIGRvbmVGbnMuZm9yRWFjaCgoZm4pID0+IChmbihldmVudCkpKTtcblx0XHRpZihwcmV2KSByZXR1cm4gcHJldihldmVudCk7XG5cdH1cblx0dmFyIHRpbWVvdXQgPSBzZXRUaW1lb3V0KG9uU2NyaXB0Q29tcGxldGUuYmluZChudWxsLCB1bmRlZmluZWQsIHsgdHlwZTogJ3RpbWVvdXQnLCB0YXJnZXQ6IHNjcmlwdCB9KSwgMTIwMDAwKTtcblx0c2NyaXB0Lm9uZXJyb3IgPSBvblNjcmlwdENvbXBsZXRlLmJpbmQobnVsbCwgc2NyaXB0Lm9uZXJyb3IpO1xuXHRzY3JpcHQub25sb2FkID0gb25TY3JpcHRDb21wbGV0ZS5iaW5kKG51bGwsIHNjcmlwdC5vbmxvYWQpO1xuXHRuZWVkQXR0YWNoICYmIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbn07IiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwidmFyIGN1cnJlbnRNb2R1bGVEYXRhID0ge307XG52YXIgaW5zdGFsbGVkTW9kdWxlcyA9IF9fd2VicGFja19yZXF1aXJlX18uYztcblxuLy8gbW9kdWxlIGFuZCByZXF1aXJlIGNyZWF0aW9uXG52YXIgY3VycmVudENoaWxkTW9kdWxlO1xudmFyIGN1cnJlbnRQYXJlbnRzID0gW107XG5cbi8vIHN0YXR1c1xudmFyIHJlZ2lzdGVyZWRTdGF0dXNIYW5kbGVycyA9IFtdO1xudmFyIGN1cnJlbnRTdGF0dXMgPSBcImlkbGVcIjtcblxuLy8gd2hpbGUgZG93bmxvYWRpbmdcbnZhciBibG9ja2luZ1Byb21pc2VzID0gMDtcbnZhciBibG9ja2luZ1Byb21pc2VzV2FpdGluZyA9IFtdO1xuXG4vLyBUaGUgdXBkYXRlIGluZm9cbnZhciBjdXJyZW50VXBkYXRlQXBwbHlIYW5kbGVycztcbnZhciBxdWV1ZWRJbnZhbGlkYXRlZE1vZHVsZXM7XG5cbl9fd2VicGFja19yZXF1aXJlX18uaG1yRCA9IGN1cnJlbnRNb2R1bGVEYXRhO1xuXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmkucHVzaChmdW5jdGlvbiAob3B0aW9ucykge1xuXHR2YXIgbW9kdWxlID0gb3B0aW9ucy5tb2R1bGU7XG5cdHZhciByZXF1aXJlID0gY3JlYXRlUmVxdWlyZShvcHRpb25zLnJlcXVpcmUsIG9wdGlvbnMuaWQpO1xuXHRtb2R1bGUuaG90ID0gY3JlYXRlTW9kdWxlSG90T2JqZWN0KG9wdGlvbnMuaWQsIG1vZHVsZSk7XG5cdG1vZHVsZS5wYXJlbnRzID0gY3VycmVudFBhcmVudHM7XG5cdG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xuXHRjdXJyZW50UGFyZW50cyA9IFtdO1xuXHRvcHRpb25zLnJlcXVpcmUgPSByZXF1aXJlO1xufSk7XG5cbl9fd2VicGFja19yZXF1aXJlX18uaG1yQyA9IHt9O1xuX193ZWJwYWNrX3JlcXVpcmVfXy5obXJJID0ge307XG5cbmZ1bmN0aW9uIGNyZWF0ZVJlcXVpcmUocmVxdWlyZSwgbW9kdWxlSWQpIHtcblx0dmFyIG1lID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF07XG5cdGlmICghbWUpIHJldHVybiByZXF1aXJlO1xuXHR2YXIgZm4gPSBmdW5jdGlvbiAocmVxdWVzdCkge1xuXHRcdGlmIChtZS5ob3QuYWN0aXZlKSB7XG5cdFx0XHRpZiAoaW5zdGFsbGVkTW9kdWxlc1tyZXF1ZXN0XSkge1xuXHRcdFx0XHR2YXIgcGFyZW50cyA9IGluc3RhbGxlZE1vZHVsZXNbcmVxdWVzdF0ucGFyZW50cztcblx0XHRcdFx0aWYgKHBhcmVudHMuaW5kZXhPZihtb2R1bGVJZCkgPT09IC0xKSB7XG5cdFx0XHRcdFx0cGFyZW50cy5wdXNoKG1vZHVsZUlkKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y3VycmVudFBhcmVudHMgPSBbbW9kdWxlSWRdO1xuXHRcdFx0XHRjdXJyZW50Q2hpbGRNb2R1bGUgPSByZXF1ZXN0O1xuXHRcdFx0fVxuXHRcdFx0aWYgKG1lLmNoaWxkcmVuLmluZGV4T2YocmVxdWVzdCkgPT09IC0xKSB7XG5cdFx0XHRcdG1lLmNoaWxkcmVuLnB1c2gocmVxdWVzdCk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnNvbGUud2Fybihcblx0XHRcdFx0XCJbSE1SXSB1bmV4cGVjdGVkIHJlcXVpcmUoXCIgK1xuXHRcdFx0XHRcdHJlcXVlc3QgK1xuXHRcdFx0XHRcdFwiKSBmcm9tIGRpc3Bvc2VkIG1vZHVsZSBcIiArXG5cdFx0XHRcdFx0bW9kdWxlSWRcblx0XHRcdCk7XG5cdFx0XHRjdXJyZW50UGFyZW50cyA9IFtdO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVxdWlyZShyZXF1ZXN0KTtcblx0fTtcblx0dmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciA9IGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0cmV0dXJuIHJlcXVpcmVbbmFtZV07XG5cdFx0XHR9LFxuXHRcdFx0c2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdFx0cmVxdWlyZVtuYW1lXSA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH07XG5cdH07XG5cdGZvciAodmFyIG5hbWUgaW4gcmVxdWlyZSkge1xuXHRcdGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocmVxdWlyZSwgbmFtZSkgJiYgbmFtZSAhPT0gXCJlXCIpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbiwgbmFtZSwgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKG5hbWUpKTtcblx0XHR9XG5cdH1cblx0Zm4uZSA9IGZ1bmN0aW9uIChjaHVua0lkLCBmZXRjaFByaW9yaXR5KSB7XG5cdFx0cmV0dXJuIHRyYWNrQmxvY2tpbmdQcm9taXNlKHJlcXVpcmUuZShjaHVua0lkLCBmZXRjaFByaW9yaXR5KSk7XG5cdH07XG5cdHJldHVybiBmbjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTW9kdWxlSG90T2JqZWN0KG1vZHVsZUlkLCBtZSkge1xuXHR2YXIgX21haW4gPSBjdXJyZW50Q2hpbGRNb2R1bGUgIT09IG1vZHVsZUlkO1xuXHR2YXIgaG90ID0ge1xuXHRcdC8vIHByaXZhdGUgc3R1ZmZcblx0XHRfYWNjZXB0ZWREZXBlbmRlbmNpZXM6IHt9LFxuXHRcdF9hY2NlcHRlZEVycm9ySGFuZGxlcnM6IHt9LFxuXHRcdF9kZWNsaW5lZERlcGVuZGVuY2llczoge30sXG5cdFx0X3NlbGZBY2NlcHRlZDogZmFsc2UsXG5cdFx0X3NlbGZEZWNsaW5lZDogZmFsc2UsXG5cdFx0X3NlbGZJbnZhbGlkYXRlZDogZmFsc2UsXG5cdFx0X2Rpc3Bvc2VIYW5kbGVyczogW10sXG5cdFx0X21haW46IF9tYWluLFxuXHRcdF9yZXF1aXJlU2VsZjogZnVuY3Rpb24gKCkge1xuXHRcdFx0Y3VycmVudFBhcmVudHMgPSBtZS5wYXJlbnRzLnNsaWNlKCk7XG5cdFx0XHRjdXJyZW50Q2hpbGRNb2R1bGUgPSBfbWFpbiA/IHVuZGVmaW5lZCA6IG1vZHVsZUlkO1xuXHRcdFx0X193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCk7XG5cdFx0fSxcblxuXHRcdC8vIE1vZHVsZSBBUElcblx0XHRhY3RpdmU6IHRydWUsXG5cdFx0YWNjZXB0OiBmdW5jdGlvbiAoZGVwLCBjYWxsYmFjaywgZXJyb3JIYW5kbGVyKSB7XG5cdFx0XHRpZiAoZGVwID09PSB1bmRlZmluZWQpIGhvdC5fc2VsZkFjY2VwdGVkID0gdHJ1ZTtcblx0XHRcdGVsc2UgaWYgKHR5cGVvZiBkZXAgPT09IFwiZnVuY3Rpb25cIikgaG90Ll9zZWxmQWNjZXB0ZWQgPSBkZXA7XG5cdFx0XHRlbHNlIGlmICh0eXBlb2YgZGVwID09PSBcIm9iamVjdFwiICYmIGRlcCAhPT0gbnVsbCkge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGRlcC5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGhvdC5fYWNjZXB0ZWREZXBlbmRlbmNpZXNbZGVwW2ldXSA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9O1xuXHRcdFx0XHRcdGhvdC5fYWNjZXB0ZWRFcnJvckhhbmRsZXJzW2RlcFtpXV0gPSBlcnJvckhhbmRsZXI7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGhvdC5fYWNjZXB0ZWREZXBlbmRlbmNpZXNbZGVwXSA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9O1xuXHRcdFx0XHRob3QuX2FjY2VwdGVkRXJyb3JIYW5kbGVyc1tkZXBdID0gZXJyb3JIYW5kbGVyO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZGVjbGluZTogZnVuY3Rpb24gKGRlcCkge1xuXHRcdFx0aWYgKGRlcCA9PT0gdW5kZWZpbmVkKSBob3QuX3NlbGZEZWNsaW5lZCA9IHRydWU7XG5cdFx0XHRlbHNlIGlmICh0eXBlb2YgZGVwID09PSBcIm9iamVjdFwiICYmIGRlcCAhPT0gbnVsbClcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkZXAubGVuZ3RoOyBpKyspXG5cdFx0XHRcdFx0aG90Ll9kZWNsaW5lZERlcGVuZGVuY2llc1tkZXBbaV1dID0gdHJ1ZTtcblx0XHRcdGVsc2UgaG90Ll9kZWNsaW5lZERlcGVuZGVuY2llc1tkZXBdID0gdHJ1ZTtcblx0XHR9LFxuXHRcdGRpc3Bvc2U6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuXHRcdFx0aG90Ll9kaXNwb3NlSGFuZGxlcnMucHVzaChjYWxsYmFjayk7XG5cdFx0fSxcblx0XHRhZGREaXNwb3NlSGFuZGxlcjogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG5cdFx0XHRob3QuX2Rpc3Bvc2VIYW5kbGVycy5wdXNoKGNhbGxiYWNrKTtcblx0XHR9LFxuXHRcdHJlbW92ZURpc3Bvc2VIYW5kbGVyOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcblx0XHRcdHZhciBpZHggPSBob3QuX2Rpc3Bvc2VIYW5kbGVycy5pbmRleE9mKGNhbGxiYWNrKTtcblx0XHRcdGlmIChpZHggPj0gMCkgaG90Ll9kaXNwb3NlSGFuZGxlcnMuc3BsaWNlKGlkeCwgMSk7XG5cdFx0fSxcblx0XHRpbnZhbGlkYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGlzLl9zZWxmSW52YWxpZGF0ZWQgPSB0cnVlO1xuXHRcdFx0c3dpdGNoIChjdXJyZW50U3RhdHVzKSB7XG5cdFx0XHRcdGNhc2UgXCJpZGxlXCI6XG5cdFx0XHRcdFx0Y3VycmVudFVwZGF0ZUFwcGx5SGFuZGxlcnMgPSBbXTtcblx0XHRcdFx0XHRPYmplY3Qua2V5cyhfX3dlYnBhY2tfcmVxdWlyZV9fLmhtckkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHRcdFx0XHRcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5obXJJW2tleV0oXG5cdFx0XHRcdFx0XHRcdG1vZHVsZUlkLFxuXHRcdFx0XHRcdFx0XHRjdXJyZW50VXBkYXRlQXBwbHlIYW5kbGVyc1xuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRzZXRTdGF0dXMoXCJyZWFkeVwiKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcInJlYWR5XCI6XG5cdFx0XHRcdFx0T2JqZWN0LmtleXMoX193ZWJwYWNrX3JlcXVpcmVfXy5obXJJKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0XHRcdFx0XHRcdF9fd2VicGFja19yZXF1aXJlX18uaG1ySVtrZXldKFxuXHRcdFx0XHRcdFx0XHRtb2R1bGVJZCxcblx0XHRcdFx0XHRcdFx0Y3VycmVudFVwZGF0ZUFwcGx5SGFuZGxlcnNcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgXCJwcmVwYXJlXCI6XG5cdFx0XHRcdGNhc2UgXCJjaGVja1wiOlxuXHRcdFx0XHRjYXNlIFwiZGlzcG9zZVwiOlxuXHRcdFx0XHRjYXNlIFwiYXBwbHlcIjpcblx0XHRcdFx0XHQocXVldWVkSW52YWxpZGF0ZWRNb2R1bGVzID0gcXVldWVkSW52YWxpZGF0ZWRNb2R1bGVzIHx8IFtdKS5wdXNoKFxuXHRcdFx0XHRcdFx0bW9kdWxlSWRcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdC8vIGlnbm9yZSByZXF1ZXN0cyBpbiBlcnJvciBzdGF0ZXNcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Ly8gTWFuYWdlbWVudCBBUElcblx0XHRjaGVjazogaG90Q2hlY2ssXG5cdFx0YXBwbHk6IGhvdEFwcGx5LFxuXHRcdHN0YXR1czogZnVuY3Rpb24gKGwpIHtcblx0XHRcdGlmICghbCkgcmV0dXJuIGN1cnJlbnRTdGF0dXM7XG5cdFx0XHRyZWdpc3RlcmVkU3RhdHVzSGFuZGxlcnMucHVzaChsKTtcblx0XHR9LFxuXHRcdGFkZFN0YXR1c0hhbmRsZXI6IGZ1bmN0aW9uIChsKSB7XG5cdFx0XHRyZWdpc3RlcmVkU3RhdHVzSGFuZGxlcnMucHVzaChsKTtcblx0XHR9LFxuXHRcdHJlbW92ZVN0YXR1c0hhbmRsZXI6IGZ1bmN0aW9uIChsKSB7XG5cdFx0XHR2YXIgaWR4ID0gcmVnaXN0ZXJlZFN0YXR1c0hhbmRsZXJzLmluZGV4T2YobCk7XG5cdFx0XHRpZiAoaWR4ID49IDApIHJlZ2lzdGVyZWRTdGF0dXNIYW5kbGVycy5zcGxpY2UoaWR4LCAxKTtcblx0XHR9LFxuXG5cdFx0Ly9pbmhlcml0IGZyb20gcHJldmlvdXMgZGlzcG9zZSBjYWxsXG5cdFx0ZGF0YTogY3VycmVudE1vZHVsZURhdGFbbW9kdWxlSWRdXG5cdH07XG5cdGN1cnJlbnRDaGlsZE1vZHVsZSA9IHVuZGVmaW5lZDtcblx0cmV0dXJuIGhvdDtcbn1cblxuZnVuY3Rpb24gc2V0U3RhdHVzKG5ld1N0YXR1cykge1xuXHRjdXJyZW50U3RhdHVzID0gbmV3U3RhdHVzO1xuXHR2YXIgcmVzdWx0cyA9IFtdO1xuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgcmVnaXN0ZXJlZFN0YXR1c0hhbmRsZXJzLmxlbmd0aDsgaSsrKVxuXHRcdHJlc3VsdHNbaV0gPSByZWdpc3RlcmVkU3RhdHVzSGFuZGxlcnNbaV0uY2FsbChudWxsLCBuZXdTdGF0dXMpO1xuXG5cdHJldHVybiBQcm9taXNlLmFsbChyZXN1bHRzKS50aGVuKGZ1bmN0aW9uICgpIHt9KTtcbn1cblxuZnVuY3Rpb24gdW5ibG9jaygpIHtcblx0aWYgKC0tYmxvY2tpbmdQcm9taXNlcyA9PT0gMCkge1xuXHRcdHNldFN0YXR1cyhcInJlYWR5XCIpLnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKGJsb2NraW5nUHJvbWlzZXMgPT09IDApIHtcblx0XHRcdFx0dmFyIGxpc3QgPSBibG9ja2luZ1Byb21pc2VzV2FpdGluZztcblx0XHRcdFx0YmxvY2tpbmdQcm9taXNlc1dhaXRpbmcgPSBbXTtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0bGlzdFtpXSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gdHJhY2tCbG9ja2luZ1Byb21pc2UocHJvbWlzZSkge1xuXHRzd2l0Y2ggKGN1cnJlbnRTdGF0dXMpIHtcblx0XHRjYXNlIFwicmVhZHlcIjpcblx0XHRcdHNldFN0YXR1cyhcInByZXBhcmVcIik7XG5cdFx0LyogZmFsbHRocm91Z2ggKi9cblx0XHRjYXNlIFwicHJlcGFyZVwiOlxuXHRcdFx0YmxvY2tpbmdQcm9taXNlcysrO1xuXHRcdFx0cHJvbWlzZS50aGVuKHVuYmxvY2ssIHVuYmxvY2spO1xuXHRcdFx0cmV0dXJuIHByb21pc2U7XG5cdFx0ZGVmYXVsdDpcblx0XHRcdHJldHVybiBwcm9taXNlO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHdhaXRGb3JCbG9ja2luZ1Byb21pc2VzKGZuKSB7XG5cdGlmIChibG9ja2luZ1Byb21pc2VzID09PSAwKSByZXR1cm4gZm4oKTtcblx0cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG5cdFx0YmxvY2tpbmdQcm9taXNlc1dhaXRpbmcucHVzaChmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXNvbHZlKGZuKCkpO1xuXHRcdH0pO1xuXHR9KTtcbn1cblxuZnVuY3Rpb24gaG90Q2hlY2soYXBwbHlPblVwZGF0ZSkge1xuXHRpZiAoY3VycmVudFN0YXR1cyAhPT0gXCJpZGxlXCIpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJjaGVjaygpIGlzIG9ubHkgYWxsb3dlZCBpbiBpZGxlIHN0YXR1c1wiKTtcblx0fVxuXHRyZXR1cm4gc2V0U3RhdHVzKFwiY2hlY2tcIilcblx0XHQudGhlbihfX3dlYnBhY2tfcmVxdWlyZV9fLmhtck0pXG5cdFx0LnRoZW4oZnVuY3Rpb24gKHVwZGF0ZSkge1xuXHRcdFx0aWYgKCF1cGRhdGUpIHtcblx0XHRcdFx0cmV0dXJuIHNldFN0YXR1cyhhcHBseUludmFsaWRhdGVkTW9kdWxlcygpID8gXCJyZWFkeVwiIDogXCJpZGxlXCIpLnRoZW4oXG5cdFx0XHRcdFx0ZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gc2V0U3RhdHVzKFwicHJlcGFyZVwiKS50aGVuKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dmFyIHVwZGF0ZWRNb2R1bGVzID0gW107XG5cdFx0XHRcdGN1cnJlbnRVcGRhdGVBcHBseUhhbmRsZXJzID0gW107XG5cblx0XHRcdFx0cmV0dXJuIFByb21pc2UuYWxsKFxuXHRcdFx0XHRcdE9iamVjdC5rZXlzKF9fd2VicGFja19yZXF1aXJlX18uaG1yQykucmVkdWNlKGZ1bmN0aW9uIChcblx0XHRcdFx0XHRcdHByb21pc2VzLFxuXHRcdFx0XHRcdFx0a2V5XG5cdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmhtckNba2V5XShcblx0XHRcdFx0XHRcdFx0dXBkYXRlLmMsXG5cdFx0XHRcdFx0XHRcdHVwZGF0ZS5yLFxuXHRcdFx0XHRcdFx0XHR1cGRhdGUubSxcblx0XHRcdFx0XHRcdFx0cHJvbWlzZXMsXG5cdFx0XHRcdFx0XHRcdGN1cnJlbnRVcGRhdGVBcHBseUhhbmRsZXJzLFxuXHRcdFx0XHRcdFx0XHR1cGRhdGVkTW9kdWxlc1xuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdHJldHVybiBwcm9taXNlcztcblx0XHRcdFx0XHR9LCBbXSlcblx0XHRcdFx0KS50aGVuKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRyZXR1cm4gd2FpdEZvckJsb2NraW5nUHJvbWlzZXMoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0aWYgKGFwcGx5T25VcGRhdGUpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGludGVybmFsQXBwbHkoYXBwbHlPblVwZGF0ZSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gc2V0U3RhdHVzKFwicmVhZHlcIikudGhlbihmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHVwZGF0ZWRNb2R1bGVzO1xuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblx0XHR9KTtcbn1cblxuZnVuY3Rpb24gaG90QXBwbHkob3B0aW9ucykge1xuXHRpZiAoY3VycmVudFN0YXR1cyAhPT0gXCJyZWFkeVwiKSB7XG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0XHRcImFwcGx5KCkgaXMgb25seSBhbGxvd2VkIGluIHJlYWR5IHN0YXR1cyAoc3RhdGU6IFwiICtcblx0XHRcdFx0XHRjdXJyZW50U3RhdHVzICtcblx0XHRcdFx0XHRcIilcIlxuXHRcdFx0KTtcblx0XHR9KTtcblx0fVxuXHRyZXR1cm4gaW50ZXJuYWxBcHBseShvcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gaW50ZXJuYWxBcHBseShvcHRpb25zKSB7XG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdGFwcGx5SW52YWxpZGF0ZWRNb2R1bGVzKCk7XG5cblx0dmFyIHJlc3VsdHMgPSBjdXJyZW50VXBkYXRlQXBwbHlIYW5kbGVycy5tYXAoZnVuY3Rpb24gKGhhbmRsZXIpIHtcblx0XHRyZXR1cm4gaGFuZGxlcihvcHRpb25zKTtcblx0fSk7XG5cdGN1cnJlbnRVcGRhdGVBcHBseUhhbmRsZXJzID0gdW5kZWZpbmVkO1xuXG5cdHZhciBlcnJvcnMgPSByZXN1bHRzXG5cdFx0Lm1hcChmdW5jdGlvbiAocikge1xuXHRcdFx0cmV0dXJuIHIuZXJyb3I7XG5cdFx0fSlcblx0XHQuZmlsdGVyKEJvb2xlYW4pO1xuXG5cdGlmIChlcnJvcnMubGVuZ3RoID4gMCkge1xuXHRcdHJldHVybiBzZXRTdGF0dXMoXCJhYm9ydFwiKS50aGVuKGZ1bmN0aW9uICgpIHtcblx0XHRcdHRocm93IGVycm9yc1swXTtcblx0XHR9KTtcblx0fVxuXG5cdC8vIE5vdyBpbiBcImRpc3Bvc2VcIiBwaGFzZVxuXHR2YXIgZGlzcG9zZVByb21pc2UgPSBzZXRTdGF0dXMoXCJkaXNwb3NlXCIpO1xuXG5cdHJlc3VsdHMuZm9yRWFjaChmdW5jdGlvbiAocmVzdWx0KSB7XG5cdFx0aWYgKHJlc3VsdC5kaXNwb3NlKSByZXN1bHQuZGlzcG9zZSgpO1xuXHR9KTtcblxuXHQvLyBOb3cgaW4gXCJhcHBseVwiIHBoYXNlXG5cdHZhciBhcHBseVByb21pc2UgPSBzZXRTdGF0dXMoXCJhcHBseVwiKTtcblxuXHR2YXIgZXJyb3I7XG5cdHZhciByZXBvcnRFcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcblx0XHRpZiAoIWVycm9yKSBlcnJvciA9IGVycjtcblx0fTtcblxuXHR2YXIgb3V0ZGF0ZWRNb2R1bGVzID0gW107XG5cdHJlc3VsdHMuZm9yRWFjaChmdW5jdGlvbiAocmVzdWx0KSB7XG5cdFx0aWYgKHJlc3VsdC5hcHBseSkge1xuXHRcdFx0dmFyIG1vZHVsZXMgPSByZXN1bHQuYXBwbHkocmVwb3J0RXJyb3IpO1xuXHRcdFx0aWYgKG1vZHVsZXMpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0b3V0ZGF0ZWRNb2R1bGVzLnB1c2gobW9kdWxlc1tpXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXG5cdHJldHVybiBQcm9taXNlLmFsbChbZGlzcG9zZVByb21pc2UsIGFwcGx5UHJvbWlzZV0pLnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdC8vIGhhbmRsZSBlcnJvcnMgaW4gYWNjZXB0IGhhbmRsZXJzIGFuZCBzZWxmIGFjY2VwdGVkIG1vZHVsZSBsb2FkXG5cdFx0aWYgKGVycm9yKSB7XG5cdFx0XHRyZXR1cm4gc2V0U3RhdHVzKFwiZmFpbFwiKS50aGVuKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRpZiAocXVldWVkSW52YWxpZGF0ZWRNb2R1bGVzKSB7XG5cdFx0XHRyZXR1cm4gaW50ZXJuYWxBcHBseShvcHRpb25zKS50aGVuKGZ1bmN0aW9uIChsaXN0KSB7XG5cdFx0XHRcdG91dGRhdGVkTW9kdWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChtb2R1bGVJZCkge1xuXHRcdFx0XHRcdGlmIChsaXN0LmluZGV4T2YobW9kdWxlSWQpIDwgMCkgbGlzdC5wdXNoKG1vZHVsZUlkKTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHJldHVybiBsaXN0O1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNldFN0YXR1cyhcImlkbGVcIikudGhlbihmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gb3V0ZGF0ZWRNb2R1bGVzO1xuXHRcdH0pO1xuXHR9KTtcbn1cblxuZnVuY3Rpb24gYXBwbHlJbnZhbGlkYXRlZE1vZHVsZXMoKSB7XG5cdGlmIChxdWV1ZWRJbnZhbGlkYXRlZE1vZHVsZXMpIHtcblx0XHRpZiAoIWN1cnJlbnRVcGRhdGVBcHBseUhhbmRsZXJzKSBjdXJyZW50VXBkYXRlQXBwbHlIYW5kbGVycyA9IFtdO1xuXHRcdE9iamVjdC5rZXlzKF9fd2VicGFja19yZXF1aXJlX18uaG1ySSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0XHRxdWV1ZWRJbnZhbGlkYXRlZE1vZHVsZXMuZm9yRWFjaChmdW5jdGlvbiAobW9kdWxlSWQpIHtcblx0XHRcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5obXJJW2tleV0oXG5cdFx0XHRcdFx0bW9kdWxlSWQsXG5cdFx0XHRcdFx0Y3VycmVudFVwZGF0ZUFwcGx5SGFuZGxlcnNcblx0XHRcdFx0KTtcblx0XHRcdH0pO1xuXHRcdH0pO1xuXHRcdHF1ZXVlZEludmFsaWRhdGVkTW9kdWxlcyA9IHVuZGVmaW5lZDtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxufSIsInZhciBzY3JpcHRVcmw7XG5pZiAoX193ZWJwYWNrX3JlcXVpcmVfXy5nLmltcG9ydFNjcmlwdHMpIHNjcmlwdFVybCA9IF9fd2VicGFja19yZXF1aXJlX18uZy5sb2NhdGlvbiArIFwiXCI7XG52YXIgZG9jdW1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLmcuZG9jdW1lbnQ7XG5pZiAoIXNjcmlwdFVybCAmJiBkb2N1bWVudCkge1xuXHRpZiAoZG9jdW1lbnQuY3VycmVudFNjcmlwdClcblx0XHRzY3JpcHRVcmwgPSBkb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYztcblx0aWYgKCFzY3JpcHRVcmwpIHtcblx0XHR2YXIgc2NyaXB0cyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic2NyaXB0XCIpO1xuXHRcdGlmKHNjcmlwdHMubGVuZ3RoKSB7XG5cdFx0XHR2YXIgaSA9IHNjcmlwdHMubGVuZ3RoIC0gMTtcblx0XHRcdHdoaWxlIChpID4gLTEgJiYgKCFzY3JpcHRVcmwgfHwgIS9eaHR0cChzPyk6Ly50ZXN0KHNjcmlwdFVybCkpKSBzY3JpcHRVcmwgPSBzY3JpcHRzW2ktLV0uc3JjO1xuXHRcdH1cblx0fVxufVxuLy8gV2hlbiBzdXBwb3J0aW5nIGJyb3dzZXJzIHdoZXJlIGFuIGF1dG9tYXRpYyBwdWJsaWNQYXRoIGlzIG5vdCBzdXBwb3J0ZWQgeW91IG11c3Qgc3BlY2lmeSBhbiBvdXRwdXQucHVibGljUGF0aCBtYW51YWxseSB2aWEgY29uZmlndXJhdGlvblxuLy8gb3IgcGFzcyBhbiBlbXB0eSBzdHJpbmcgKFwiXCIpIGFuZCBzZXQgdGhlIF9fd2VicGFja19wdWJsaWNfcGF0aF9fIHZhcmlhYmxlIGZyb20geW91ciBjb2RlIHRvIHVzZSB5b3VyIG93biBsb2dpYy5cbmlmICghc2NyaXB0VXJsKSB0aHJvdyBuZXcgRXJyb3IoXCJBdXRvbWF0aWMgcHVibGljUGF0aCBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlclwiKTtcbnNjcmlwdFVybCA9IHNjcmlwdFVybC5yZXBsYWNlKC8jLiokLywgXCJcIikucmVwbGFjZSgvXFw/LiokLywgXCJcIikucmVwbGFjZSgvXFwvW15cXC9dKyQvLCBcIi9cIik7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBzY3JpcHRVcmw7IiwiLy8gbm8gYmFzZVVSSVxuXG4vLyBvYmplY3QgdG8gc3RvcmUgbG9hZGVkIGFuZCBsb2FkaW5nIGNodW5rc1xuLy8gdW5kZWZpbmVkID0gY2h1bmsgbm90IGxvYWRlZCwgbnVsbCA9IGNodW5rIHByZWxvYWRlZC9wcmVmZXRjaGVkXG4vLyBbcmVzb2x2ZSwgcmVqZWN0LCBQcm9taXNlXSA9IGNodW5rIGxvYWRpbmcsIDAgPSBjaHVuayBsb2FkZWRcbnZhciBpbnN0YWxsZWRDaHVua3MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLmhtclNfanNvbnAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLmhtclNfanNvbnAgfHwge1xuXHRcIm1haW5cIjogMFxufTtcblxuLy8gbm8gY2h1bmsgb24gZGVtYW5kIGxvYWRpbmdcblxuLy8gbm8gcHJlZmV0Y2hpbmdcblxuLy8gbm8gcHJlbG9hZGVkXG5cbnZhciBjdXJyZW50VXBkYXRlZE1vZHVsZXNMaXN0O1xudmFyIHdhaXRpbmdVcGRhdGVSZXNvbHZlcyA9IHt9O1xuZnVuY3Rpb24gbG9hZFVwZGF0ZUNodW5rKGNodW5rSWQsIHVwZGF0ZWRNb2R1bGVzTGlzdCkge1xuXHRjdXJyZW50VXBkYXRlZE1vZHVsZXNMaXN0ID0gdXBkYXRlZE1vZHVsZXNMaXN0O1xuXHRyZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRcdHdhaXRpbmdVcGRhdGVSZXNvbHZlc1tjaHVua0lkXSA9IHJlc29sdmU7XG5cdFx0Ly8gc3RhcnQgdXBkYXRlIGNodW5rIGxvYWRpbmdcblx0XHR2YXIgdXJsID0gX193ZWJwYWNrX3JlcXVpcmVfXy5wICsgX193ZWJwYWNrX3JlcXVpcmVfXy5odShjaHVua0lkKTtcblx0XHQvLyBjcmVhdGUgZXJyb3IgYmVmb3JlIHN0YWNrIHVud291bmQgdG8gZ2V0IHVzZWZ1bCBzdGFja3RyYWNlIGxhdGVyXG5cdFx0dmFyIGVycm9yID0gbmV3IEVycm9yKCk7XG5cdFx0dmFyIGxvYWRpbmdFbmRlZCA9IChldmVudCkgPT4ge1xuXHRcdFx0aWYod2FpdGluZ1VwZGF0ZVJlc29sdmVzW2NodW5rSWRdKSB7XG5cdFx0XHRcdHdhaXRpbmdVcGRhdGVSZXNvbHZlc1tjaHVua0lkXSA9IHVuZGVmaW5lZFxuXHRcdFx0XHR2YXIgZXJyb3JUeXBlID0gZXZlbnQgJiYgKGV2ZW50LnR5cGUgPT09ICdsb2FkJyA/ICdtaXNzaW5nJyA6IGV2ZW50LnR5cGUpO1xuXHRcdFx0XHR2YXIgcmVhbFNyYyA9IGV2ZW50ICYmIGV2ZW50LnRhcmdldCAmJiBldmVudC50YXJnZXQuc3JjO1xuXHRcdFx0XHRlcnJvci5tZXNzYWdlID0gJ0xvYWRpbmcgaG90IHVwZGF0ZSBjaHVuayAnICsgY2h1bmtJZCArICcgZmFpbGVkLlxcbignICsgZXJyb3JUeXBlICsgJzogJyArIHJlYWxTcmMgKyAnKSc7XG5cdFx0XHRcdGVycm9yLm5hbWUgPSAnQ2h1bmtMb2FkRXJyb3InO1xuXHRcdFx0XHRlcnJvci50eXBlID0gZXJyb3JUeXBlO1xuXHRcdFx0XHRlcnJvci5yZXF1ZXN0ID0gcmVhbFNyYztcblx0XHRcdFx0cmVqZWN0KGVycm9yKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdF9fd2VicGFja19yZXF1aXJlX18ubCh1cmwsIGxvYWRpbmdFbmRlZCk7XG5cdH0pO1xufVxuXG5zZWxmW1wid2VicGFja0hvdFVwZGF0ZWZsYXNrX3ByZWFjdF90eXBlc2NyaXB0X3RhaWx3aW5kX3RlbXBsYXRlXCJdID0gKGNodW5rSWQsIG1vcmVNb2R1bGVzLCBydW50aW1lKSA9PiB7XG5cdGZvcih2YXIgbW9kdWxlSWQgaW4gbW9yZU1vZHVsZXMpIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8obW9yZU1vZHVsZXMsIG1vZHVsZUlkKSkge1xuXHRcdFx0Y3VycmVudFVwZGF0ZVttb2R1bGVJZF0gPSBtb3JlTW9kdWxlc1ttb2R1bGVJZF07XG5cdFx0XHRpZihjdXJyZW50VXBkYXRlZE1vZHVsZXNMaXN0KSBjdXJyZW50VXBkYXRlZE1vZHVsZXNMaXN0LnB1c2gobW9kdWxlSWQpO1xuXHRcdH1cblx0fVxuXHRpZihydW50aW1lKSBjdXJyZW50VXBkYXRlUnVudGltZS5wdXNoKHJ1bnRpbWUpO1xuXHRpZih3YWl0aW5nVXBkYXRlUmVzb2x2ZXNbY2h1bmtJZF0pIHtcblx0XHR3YWl0aW5nVXBkYXRlUmVzb2x2ZXNbY2h1bmtJZF0oKTtcblx0XHR3YWl0aW5nVXBkYXRlUmVzb2x2ZXNbY2h1bmtJZF0gPSB1bmRlZmluZWQ7XG5cdH1cbn07XG5cbnZhciBjdXJyZW50VXBkYXRlQ2h1bmtzO1xudmFyIGN1cnJlbnRVcGRhdGU7XG52YXIgY3VycmVudFVwZGF0ZVJlbW92ZWRDaHVua3M7XG52YXIgY3VycmVudFVwZGF0ZVJ1bnRpbWU7XG5mdW5jdGlvbiBhcHBseUhhbmRsZXIob3B0aW9ucykge1xuXHRpZiAoX193ZWJwYWNrX3JlcXVpcmVfXy5mKSBkZWxldGUgX193ZWJwYWNrX3JlcXVpcmVfXy5mLmpzb25wSG1yO1xuXHRjdXJyZW50VXBkYXRlQ2h1bmtzID0gdW5kZWZpbmVkO1xuXHRmdW5jdGlvbiBnZXRBZmZlY3RlZE1vZHVsZUVmZmVjdHModXBkYXRlTW9kdWxlSWQpIHtcblx0XHR2YXIgb3V0ZGF0ZWRNb2R1bGVzID0gW3VwZGF0ZU1vZHVsZUlkXTtcblx0XHR2YXIgb3V0ZGF0ZWREZXBlbmRlbmNpZXMgPSB7fTtcblxuXHRcdHZhciBxdWV1ZSA9IG91dGRhdGVkTW9kdWxlcy5tYXAoZnVuY3Rpb24gKGlkKSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRjaGFpbjogW2lkXSxcblx0XHRcdFx0aWQ6IGlkXG5cdFx0XHR9O1xuXHRcdH0pO1xuXHRcdHdoaWxlIChxdWV1ZS5sZW5ndGggPiAwKSB7XG5cdFx0XHR2YXIgcXVldWVJdGVtID0gcXVldWUucG9wKCk7XG5cdFx0XHR2YXIgbW9kdWxlSWQgPSBxdWV1ZUl0ZW0uaWQ7XG5cdFx0XHR2YXIgY2hhaW4gPSBxdWV1ZUl0ZW0uY2hhaW47XG5cdFx0XHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXy5jW21vZHVsZUlkXTtcblx0XHRcdGlmIChcblx0XHRcdFx0IW1vZHVsZSB8fFxuXHRcdFx0XHQobW9kdWxlLmhvdC5fc2VsZkFjY2VwdGVkICYmICFtb2R1bGUuaG90Ll9zZWxmSW52YWxpZGF0ZWQpXG5cdFx0XHQpXG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0aWYgKG1vZHVsZS5ob3QuX3NlbGZEZWNsaW5lZCkge1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdHR5cGU6IFwic2VsZi1kZWNsaW5lZFwiLFxuXHRcdFx0XHRcdGNoYWluOiBjaGFpbixcblx0XHRcdFx0XHRtb2R1bGVJZDogbW9kdWxlSWRcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdGlmIChtb2R1bGUuaG90Ll9tYWluKSB7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0dHlwZTogXCJ1bmFjY2VwdGVkXCIsXG5cdFx0XHRcdFx0Y2hhaW46IGNoYWluLFxuXHRcdFx0XHRcdG1vZHVsZUlkOiBtb2R1bGVJZFxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBtb2R1bGUucGFyZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR2YXIgcGFyZW50SWQgPSBtb2R1bGUucGFyZW50c1tpXTtcblx0XHRcdFx0dmFyIHBhcmVudCA9IF9fd2VicGFja19yZXF1aXJlX18uY1twYXJlbnRJZF07XG5cdFx0XHRcdGlmICghcGFyZW50KSBjb250aW51ZTtcblx0XHRcdFx0aWYgKHBhcmVudC5ob3QuX2RlY2xpbmVkRGVwZW5kZW5jaWVzW21vZHVsZUlkXSkge1xuXHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHR0eXBlOiBcImRlY2xpbmVkXCIsXG5cdFx0XHRcdFx0XHRjaGFpbjogY2hhaW4uY29uY2F0KFtwYXJlbnRJZF0pLFxuXHRcdFx0XHRcdFx0bW9kdWxlSWQ6IG1vZHVsZUlkLFxuXHRcdFx0XHRcdFx0cGFyZW50SWQ6IHBhcmVudElkXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAob3V0ZGF0ZWRNb2R1bGVzLmluZGV4T2YocGFyZW50SWQpICE9PSAtMSkgY29udGludWU7XG5cdFx0XHRcdGlmIChwYXJlbnQuaG90Ll9hY2NlcHRlZERlcGVuZGVuY2llc1ttb2R1bGVJZF0pIHtcblx0XHRcdFx0XHRpZiAoIW91dGRhdGVkRGVwZW5kZW5jaWVzW3BhcmVudElkXSlcblx0XHRcdFx0XHRcdG91dGRhdGVkRGVwZW5kZW5jaWVzW3BhcmVudElkXSA9IFtdO1xuXHRcdFx0XHRcdGFkZEFsbFRvU2V0KG91dGRhdGVkRGVwZW5kZW5jaWVzW3BhcmVudElkXSwgW21vZHVsZUlkXSk7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGVsZXRlIG91dGRhdGVkRGVwZW5kZW5jaWVzW3BhcmVudElkXTtcblx0XHRcdFx0b3V0ZGF0ZWRNb2R1bGVzLnB1c2gocGFyZW50SWQpO1xuXHRcdFx0XHRxdWV1ZS5wdXNoKHtcblx0XHRcdFx0XHRjaGFpbjogY2hhaW4uY29uY2F0KFtwYXJlbnRJZF0pLFxuXHRcdFx0XHRcdGlkOiBwYXJlbnRJZFxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0dHlwZTogXCJhY2NlcHRlZFwiLFxuXHRcdFx0bW9kdWxlSWQ6IHVwZGF0ZU1vZHVsZUlkLFxuXHRcdFx0b3V0ZGF0ZWRNb2R1bGVzOiBvdXRkYXRlZE1vZHVsZXMsXG5cdFx0XHRvdXRkYXRlZERlcGVuZGVuY2llczogb3V0ZGF0ZWREZXBlbmRlbmNpZXNcblx0XHR9O1xuXHR9XG5cblx0ZnVuY3Rpb24gYWRkQWxsVG9TZXQoYSwgYikge1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBiW2ldO1xuXHRcdFx0aWYgKGEuaW5kZXhPZihpdGVtKSA9PT0gLTEpIGEucHVzaChpdGVtKTtcblx0XHR9XG5cdH1cblxuXHQvLyBhdCBiZWdpbiBhbGwgdXBkYXRlcyBtb2R1bGVzIGFyZSBvdXRkYXRlZFxuXHQvLyB0aGUgXCJvdXRkYXRlZFwiIHN0YXR1cyBjYW4gcHJvcGFnYXRlIHRvIHBhcmVudHMgaWYgdGhleSBkb24ndCBhY2NlcHQgdGhlIGNoaWxkcmVuXG5cdHZhciBvdXRkYXRlZERlcGVuZGVuY2llcyA9IHt9O1xuXHR2YXIgb3V0ZGF0ZWRNb2R1bGVzID0gW107XG5cdHZhciBhcHBsaWVkVXBkYXRlID0ge307XG5cblx0dmFyIHdhcm5VbmV4cGVjdGVkUmVxdWlyZSA9IGZ1bmN0aW9uIHdhcm5VbmV4cGVjdGVkUmVxdWlyZShtb2R1bGUpIHtcblx0XHRjb25zb2xlLndhcm4oXG5cdFx0XHRcIltITVJdIHVuZXhwZWN0ZWQgcmVxdWlyZShcIiArIG1vZHVsZS5pZCArIFwiKSB0byBkaXNwb3NlZCBtb2R1bGVcIlxuXHRcdCk7XG5cdH07XG5cblx0Zm9yICh2YXIgbW9kdWxlSWQgaW4gY3VycmVudFVwZGF0ZSkge1xuXHRcdGlmIChfX3dlYnBhY2tfcmVxdWlyZV9fLm8oY3VycmVudFVwZGF0ZSwgbW9kdWxlSWQpKSB7XG5cdFx0XHR2YXIgbmV3TW9kdWxlRmFjdG9yeSA9IGN1cnJlbnRVcGRhdGVbbW9kdWxlSWRdO1xuXHRcdFx0LyoqIEB0eXBlIHtUT0RPfSAqL1xuXHRcdFx0dmFyIHJlc3VsdDtcblx0XHRcdGlmIChuZXdNb2R1bGVGYWN0b3J5KSB7XG5cdFx0XHRcdHJlc3VsdCA9IGdldEFmZmVjdGVkTW9kdWxlRWZmZWN0cyhtb2R1bGVJZCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXN1bHQgPSB7XG5cdFx0XHRcdFx0dHlwZTogXCJkaXNwb3NlZFwiLFxuXHRcdFx0XHRcdG1vZHVsZUlkOiBtb2R1bGVJZFxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0LyoqIEB0eXBlIHtFcnJvcnxmYWxzZX0gKi9cblx0XHRcdHZhciBhYm9ydEVycm9yID0gZmFsc2U7XG5cdFx0XHR2YXIgZG9BcHBseSA9IGZhbHNlO1xuXHRcdFx0dmFyIGRvRGlzcG9zZSA9IGZhbHNlO1xuXHRcdFx0dmFyIGNoYWluSW5mbyA9IFwiXCI7XG5cdFx0XHRpZiAocmVzdWx0LmNoYWluKSB7XG5cdFx0XHRcdGNoYWluSW5mbyA9IFwiXFxuVXBkYXRlIHByb3BhZ2F0aW9uOiBcIiArIHJlc3VsdC5jaGFpbi5qb2luKFwiIC0+IFwiKTtcblx0XHRcdH1cblx0XHRcdHN3aXRjaCAocmVzdWx0LnR5cGUpIHtcblx0XHRcdFx0Y2FzZSBcInNlbGYtZGVjbGluZWRcIjpcblx0XHRcdFx0XHRpZiAob3B0aW9ucy5vbkRlY2xpbmVkKSBvcHRpb25zLm9uRGVjbGluZWQocmVzdWx0KTtcblx0XHRcdFx0XHRpZiAoIW9wdGlvbnMuaWdub3JlRGVjbGluZWQpXG5cdFx0XHRcdFx0XHRhYm9ydEVycm9yID0gbmV3IEVycm9yKFxuXHRcdFx0XHRcdFx0XHRcIkFib3J0ZWQgYmVjYXVzZSBvZiBzZWxmIGRlY2xpbmU6IFwiICtcblx0XHRcdFx0XHRcdFx0XHRyZXN1bHQubW9kdWxlSWQgK1xuXHRcdFx0XHRcdFx0XHRcdGNoYWluSW5mb1xuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcImRlY2xpbmVkXCI6XG5cdFx0XHRcdFx0aWYgKG9wdGlvbnMub25EZWNsaW5lZCkgb3B0aW9ucy5vbkRlY2xpbmVkKHJlc3VsdCk7XG5cdFx0XHRcdFx0aWYgKCFvcHRpb25zLmlnbm9yZURlY2xpbmVkKVxuXHRcdFx0XHRcdFx0YWJvcnRFcnJvciA9IG5ldyBFcnJvcihcblx0XHRcdFx0XHRcdFx0XCJBYm9ydGVkIGJlY2F1c2Ugb2YgZGVjbGluZWQgZGVwZW5kZW5jeTogXCIgK1xuXHRcdFx0XHRcdFx0XHRcdHJlc3VsdC5tb2R1bGVJZCArXG5cdFx0XHRcdFx0XHRcdFx0XCIgaW4gXCIgK1xuXHRcdFx0XHRcdFx0XHRcdHJlc3VsdC5wYXJlbnRJZCArXG5cdFx0XHRcdFx0XHRcdFx0Y2hhaW5JbmZvXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIFwidW5hY2NlcHRlZFwiOlxuXHRcdFx0XHRcdGlmIChvcHRpb25zLm9uVW5hY2NlcHRlZCkgb3B0aW9ucy5vblVuYWNjZXB0ZWQocmVzdWx0KTtcblx0XHRcdFx0XHRpZiAoIW9wdGlvbnMuaWdub3JlVW5hY2NlcHRlZClcblx0XHRcdFx0XHRcdGFib3J0RXJyb3IgPSBuZXcgRXJyb3IoXG5cdFx0XHRcdFx0XHRcdFwiQWJvcnRlZCBiZWNhdXNlIFwiICsgbW9kdWxlSWQgKyBcIiBpcyBub3QgYWNjZXB0ZWRcIiArIGNoYWluSW5mb1xuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcImFjY2VwdGVkXCI6XG5cdFx0XHRcdFx0aWYgKG9wdGlvbnMub25BY2NlcHRlZCkgb3B0aW9ucy5vbkFjY2VwdGVkKHJlc3VsdCk7XG5cdFx0XHRcdFx0ZG9BcHBseSA9IHRydWU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgXCJkaXNwb3NlZFwiOlxuXHRcdFx0XHRcdGlmIChvcHRpb25zLm9uRGlzcG9zZWQpIG9wdGlvbnMub25EaXNwb3NlZChyZXN1bHQpO1xuXHRcdFx0XHRcdGRvRGlzcG9zZSA9IHRydWU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiVW5leGNlcHRpb24gdHlwZSBcIiArIHJlc3VsdC50eXBlKTtcblx0XHRcdH1cblx0XHRcdGlmIChhYm9ydEVycm9yKSB7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0ZXJyb3I6IGFib3J0RXJyb3Jcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdGlmIChkb0FwcGx5KSB7XG5cdFx0XHRcdGFwcGxpZWRVcGRhdGVbbW9kdWxlSWRdID0gbmV3TW9kdWxlRmFjdG9yeTtcblx0XHRcdFx0YWRkQWxsVG9TZXQob3V0ZGF0ZWRNb2R1bGVzLCByZXN1bHQub3V0ZGF0ZWRNb2R1bGVzKTtcblx0XHRcdFx0Zm9yIChtb2R1bGVJZCBpbiByZXN1bHQub3V0ZGF0ZWREZXBlbmRlbmNpZXMpIHtcblx0XHRcdFx0XHRpZiAoX193ZWJwYWNrX3JlcXVpcmVfXy5vKHJlc3VsdC5vdXRkYXRlZERlcGVuZGVuY2llcywgbW9kdWxlSWQpKSB7XG5cdFx0XHRcdFx0XHRpZiAoIW91dGRhdGVkRGVwZW5kZW5jaWVzW21vZHVsZUlkXSlcblx0XHRcdFx0XHRcdFx0b3V0ZGF0ZWREZXBlbmRlbmNpZXNbbW9kdWxlSWRdID0gW107XG5cdFx0XHRcdFx0XHRhZGRBbGxUb1NldChcblx0XHRcdFx0XHRcdFx0b3V0ZGF0ZWREZXBlbmRlbmNpZXNbbW9kdWxlSWRdLFxuXHRcdFx0XHRcdFx0XHRyZXN1bHQub3V0ZGF0ZWREZXBlbmRlbmNpZXNbbW9kdWxlSWRdXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGRvRGlzcG9zZSkge1xuXHRcdFx0XHRhZGRBbGxUb1NldChvdXRkYXRlZE1vZHVsZXMsIFtyZXN1bHQubW9kdWxlSWRdKTtcblx0XHRcdFx0YXBwbGllZFVwZGF0ZVttb2R1bGVJZF0gPSB3YXJuVW5leHBlY3RlZFJlcXVpcmU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGN1cnJlbnRVcGRhdGUgPSB1bmRlZmluZWQ7XG5cblx0Ly8gU3RvcmUgc2VsZiBhY2NlcHRlZCBvdXRkYXRlZCBtb2R1bGVzIHRvIHJlcXVpcmUgdGhlbSBsYXRlciBieSB0aGUgbW9kdWxlIHN5c3RlbVxuXHR2YXIgb3V0ZGF0ZWRTZWxmQWNjZXB0ZWRNb2R1bGVzID0gW107XG5cdGZvciAodmFyIGogPSAwOyBqIDwgb3V0ZGF0ZWRNb2R1bGVzLmxlbmd0aDsgaisrKSB7XG5cdFx0dmFyIG91dGRhdGVkTW9kdWxlSWQgPSBvdXRkYXRlZE1vZHVsZXNbal07XG5cdFx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18uY1tvdXRkYXRlZE1vZHVsZUlkXTtcblx0XHRpZiAoXG5cdFx0XHRtb2R1bGUgJiZcblx0XHRcdChtb2R1bGUuaG90Ll9zZWxmQWNjZXB0ZWQgfHwgbW9kdWxlLmhvdC5fbWFpbikgJiZcblx0XHRcdC8vIHJlbW92ZWQgc2VsZi1hY2NlcHRlZCBtb2R1bGVzIHNob3VsZCBub3QgYmUgcmVxdWlyZWRcblx0XHRcdGFwcGxpZWRVcGRhdGVbb3V0ZGF0ZWRNb2R1bGVJZF0gIT09IHdhcm5VbmV4cGVjdGVkUmVxdWlyZSAmJlxuXHRcdFx0Ly8gd2hlbiBjYWxsZWQgaW52YWxpZGF0ZSBzZWxmLWFjY2VwdGluZyBpcyBub3QgcG9zc2libGVcblx0XHRcdCFtb2R1bGUuaG90Ll9zZWxmSW52YWxpZGF0ZWRcblx0XHQpIHtcblx0XHRcdG91dGRhdGVkU2VsZkFjY2VwdGVkTW9kdWxlcy5wdXNoKHtcblx0XHRcdFx0bW9kdWxlOiBvdXRkYXRlZE1vZHVsZUlkLFxuXHRcdFx0XHRyZXF1aXJlOiBtb2R1bGUuaG90Ll9yZXF1aXJlU2VsZixcblx0XHRcdFx0ZXJyb3JIYW5kbGVyOiBtb2R1bGUuaG90Ll9zZWxmQWNjZXB0ZWRcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxuXG5cdHZhciBtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llcztcblxuXHRyZXR1cm4ge1xuXHRcdGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcblx0XHRcdGN1cnJlbnRVcGRhdGVSZW1vdmVkQ2h1bmtzLmZvckVhY2goZnVuY3Rpb24gKGNodW5rSWQpIHtcblx0XHRcdFx0ZGVsZXRlIGluc3RhbGxlZENodW5rc1tjaHVua0lkXTtcblx0XHRcdH0pO1xuXHRcdFx0Y3VycmVudFVwZGF0ZVJlbW92ZWRDaHVua3MgPSB1bmRlZmluZWQ7XG5cblx0XHRcdHZhciBpZHg7XG5cdFx0XHR2YXIgcXVldWUgPSBvdXRkYXRlZE1vZHVsZXMuc2xpY2UoKTtcblx0XHRcdHdoaWxlIChxdWV1ZS5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdHZhciBtb2R1bGVJZCA9IHF1ZXVlLnBvcCgpO1xuXHRcdFx0XHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXy5jW21vZHVsZUlkXTtcblx0XHRcdFx0aWYgKCFtb2R1bGUpIGNvbnRpbnVlO1xuXG5cdFx0XHRcdHZhciBkYXRhID0ge307XG5cblx0XHRcdFx0Ly8gQ2FsbCBkaXNwb3NlIGhhbmRsZXJzXG5cdFx0XHRcdHZhciBkaXNwb3NlSGFuZGxlcnMgPSBtb2R1bGUuaG90Ll9kaXNwb3NlSGFuZGxlcnM7XG5cdFx0XHRcdGZvciAoaiA9IDA7IGogPCBkaXNwb3NlSGFuZGxlcnMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0XHRkaXNwb3NlSGFuZGxlcnNbal0uY2FsbChudWxsLCBkYXRhKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmhtckRbbW9kdWxlSWRdID0gZGF0YTtcblxuXHRcdFx0XHQvLyBkaXNhYmxlIG1vZHVsZSAodGhpcyBkaXNhYmxlcyByZXF1aXJlcyBmcm9tIHRoaXMgbW9kdWxlKVxuXHRcdFx0XHRtb2R1bGUuaG90LmFjdGl2ZSA9IGZhbHNlO1xuXG5cdFx0XHRcdC8vIHJlbW92ZSBtb2R1bGUgZnJvbSBjYWNoZVxuXHRcdFx0XHRkZWxldGUgX193ZWJwYWNrX3JlcXVpcmVfXy5jW21vZHVsZUlkXTtcblxuXHRcdFx0XHQvLyB3aGVuIGRpc3Bvc2luZyB0aGVyZSBpcyBubyBuZWVkIHRvIGNhbGwgZGlzcG9zZSBoYW5kbGVyXG5cdFx0XHRcdGRlbGV0ZSBvdXRkYXRlZERlcGVuZGVuY2llc1ttb2R1bGVJZF07XG5cblx0XHRcdFx0Ly8gcmVtb3ZlIFwicGFyZW50c1wiIHJlZmVyZW5jZXMgZnJvbSBhbGwgY2hpbGRyZW5cblx0XHRcdFx0Zm9yIChqID0gMDsgaiA8IG1vZHVsZS5jaGlsZHJlbi5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRcdHZhciBjaGlsZCA9IF9fd2VicGFja19yZXF1aXJlX18uY1ttb2R1bGUuY2hpbGRyZW5bal1dO1xuXHRcdFx0XHRcdGlmICghY2hpbGQpIGNvbnRpbnVlO1xuXHRcdFx0XHRcdGlkeCA9IGNoaWxkLnBhcmVudHMuaW5kZXhPZihtb2R1bGVJZCk7XG5cdFx0XHRcdFx0aWYgKGlkeCA+PSAwKSB7XG5cdFx0XHRcdFx0XHRjaGlsZC5wYXJlbnRzLnNwbGljZShpZHgsIDEpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyByZW1vdmUgb3V0ZGF0ZWQgZGVwZW5kZW5jeSBmcm9tIG1vZHVsZSBjaGlsZHJlblxuXHRcdFx0dmFyIGRlcGVuZGVuY3k7XG5cdFx0XHRmb3IgKHZhciBvdXRkYXRlZE1vZHVsZUlkIGluIG91dGRhdGVkRGVwZW5kZW5jaWVzKSB7XG5cdFx0XHRcdGlmIChfX3dlYnBhY2tfcmVxdWlyZV9fLm8ob3V0ZGF0ZWREZXBlbmRlbmNpZXMsIG91dGRhdGVkTW9kdWxlSWQpKSB7XG5cdFx0XHRcdFx0bW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXy5jW291dGRhdGVkTW9kdWxlSWRdO1xuXHRcdFx0XHRcdGlmIChtb2R1bGUpIHtcblx0XHRcdFx0XHRcdG1vZHVsZU91dGRhdGVkRGVwZW5kZW5jaWVzID1cblx0XHRcdFx0XHRcdFx0b3V0ZGF0ZWREZXBlbmRlbmNpZXNbb3V0ZGF0ZWRNb2R1bGVJZF07XG5cdFx0XHRcdFx0XHRmb3IgKGogPSAwOyBqIDwgbW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0XHRcdFx0ZGVwZW5kZW5jeSA9IG1vZHVsZU91dGRhdGVkRGVwZW5kZW5jaWVzW2pdO1xuXHRcdFx0XHRcdFx0XHRpZHggPSBtb2R1bGUuY2hpbGRyZW4uaW5kZXhPZihkZXBlbmRlbmN5KTtcblx0XHRcdFx0XHRcdFx0aWYgKGlkeCA+PSAwKSBtb2R1bGUuY2hpbGRyZW4uc3BsaWNlKGlkeCwgMSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRhcHBseTogZnVuY3Rpb24gKHJlcG9ydEVycm9yKSB7XG5cdFx0XHQvLyBpbnNlcnQgbmV3IGNvZGVcblx0XHRcdGZvciAodmFyIHVwZGF0ZU1vZHVsZUlkIGluIGFwcGxpZWRVcGRhdGUpIHtcblx0XHRcdFx0aWYgKF9fd2VicGFja19yZXF1aXJlX18ubyhhcHBsaWVkVXBkYXRlLCB1cGRhdGVNb2R1bGVJZCkpIHtcblx0XHRcdFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLm1bdXBkYXRlTW9kdWxlSWRdID0gYXBwbGllZFVwZGF0ZVt1cGRhdGVNb2R1bGVJZF07XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gcnVuIG5ldyBydW50aW1lIG1vZHVsZXNcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY3VycmVudFVwZGF0ZVJ1bnRpbWUubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0Y3VycmVudFVwZGF0ZVJ1bnRpbWVbaV0oX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGNhbGwgYWNjZXB0IGhhbmRsZXJzXG5cdFx0XHRmb3IgKHZhciBvdXRkYXRlZE1vZHVsZUlkIGluIG91dGRhdGVkRGVwZW5kZW5jaWVzKSB7XG5cdFx0XHRcdGlmIChfX3dlYnBhY2tfcmVxdWlyZV9fLm8ob3V0ZGF0ZWREZXBlbmRlbmNpZXMsIG91dGRhdGVkTW9kdWxlSWQpKSB7XG5cdFx0XHRcdFx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18uY1tvdXRkYXRlZE1vZHVsZUlkXTtcblx0XHRcdFx0XHRpZiAobW9kdWxlKSB7XG5cdFx0XHRcdFx0XHRtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llcyA9XG5cdFx0XHRcdFx0XHRcdG91dGRhdGVkRGVwZW5kZW5jaWVzW291dGRhdGVkTW9kdWxlSWRdO1xuXHRcdFx0XHRcdFx0dmFyIGNhbGxiYWNrcyA9IFtdO1xuXHRcdFx0XHRcdFx0dmFyIGVycm9ySGFuZGxlcnMgPSBbXTtcblx0XHRcdFx0XHRcdHZhciBkZXBlbmRlbmNpZXNGb3JDYWxsYmFja3MgPSBbXTtcblx0XHRcdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgbW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0XHRcdFx0dmFyIGRlcGVuZGVuY3kgPSBtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llc1tqXTtcblx0XHRcdFx0XHRcdFx0dmFyIGFjY2VwdENhbGxiYWNrID1cblx0XHRcdFx0XHRcdFx0XHRtb2R1bGUuaG90Ll9hY2NlcHRlZERlcGVuZGVuY2llc1tkZXBlbmRlbmN5XTtcblx0XHRcdFx0XHRcdFx0dmFyIGVycm9ySGFuZGxlciA9XG5cdFx0XHRcdFx0XHRcdFx0bW9kdWxlLmhvdC5fYWNjZXB0ZWRFcnJvckhhbmRsZXJzW2RlcGVuZGVuY3ldO1xuXHRcdFx0XHRcdFx0XHRpZiAoYWNjZXB0Q2FsbGJhY2spIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoY2FsbGJhY2tzLmluZGV4T2YoYWNjZXB0Q2FsbGJhY2spICE9PSAtMSkgY29udGludWU7XG5cdFx0XHRcdFx0XHRcdFx0Y2FsbGJhY2tzLnB1c2goYWNjZXB0Q2FsbGJhY2spO1xuXHRcdFx0XHRcdFx0XHRcdGVycm9ySGFuZGxlcnMucHVzaChlcnJvckhhbmRsZXIpO1xuXHRcdFx0XHRcdFx0XHRcdGRlcGVuZGVuY2llc0ZvckNhbGxiYWNrcy5wdXNoKGRlcGVuZGVuY3kpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRmb3IgKHZhciBrID0gMDsgayA8IGNhbGxiYWNrcy5sZW5ndGg7IGsrKykge1xuXHRcdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRcdGNhbGxiYWNrc1trXS5jYWxsKG51bGwsIG1vZHVsZU91dGRhdGVkRGVwZW5kZW5jaWVzKTtcblx0XHRcdFx0XHRcdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKHR5cGVvZiBlcnJvckhhbmRsZXJzW2tdID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGVycm9ySGFuZGxlcnNba10oZXJyLCB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bW9kdWxlSWQ6IG91dGRhdGVkTW9kdWxlSWQsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVwZW5kZW5jeUlkOiBkZXBlbmRlbmNpZXNGb3JDYWxsYmFja3Nba11cblx0XHRcdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9IGNhdGNoIChlcnIyKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmIChvcHRpb25zLm9uRXJyb3JlZCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnMub25FcnJvcmVkKHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYWNjZXB0LWVycm9yLWhhbmRsZXItZXJyb3JlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0bW9kdWxlSWQ6IG91dGRhdGVkTW9kdWxlSWQsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkZXBlbmRlbmN5SWQ6IGRlcGVuZGVuY2llc0ZvckNhbGxiYWNrc1trXSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGVycm9yOiBlcnIyLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0b3JpZ2luYWxFcnJvcjogZXJyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCFvcHRpb25zLmlnbm9yZUVycm9yZWQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXBvcnRFcnJvcihlcnIyKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXBvcnRFcnJvcihlcnIpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmIChvcHRpb25zLm9uRXJyb3JlZCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRvcHRpb25zLm9uRXJyb3JlZCh7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJhY2NlcHQtZXJyb3JlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1vZHVsZUlkOiBvdXRkYXRlZE1vZHVsZUlkLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRlcGVuZGVuY3lJZDogZGVwZW5kZW5jaWVzRm9yQ2FsbGJhY2tzW2tdLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGVycm9yOiBlcnJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIW9wdGlvbnMuaWdub3JlRXJyb3JlZCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXBvcnRFcnJvcihlcnIpO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBMb2FkIHNlbGYgYWNjZXB0ZWQgbW9kdWxlc1xuXHRcdFx0Zm9yICh2YXIgbyA9IDA7IG8gPCBvdXRkYXRlZFNlbGZBY2NlcHRlZE1vZHVsZXMubGVuZ3RoOyBvKyspIHtcblx0XHRcdFx0dmFyIGl0ZW0gPSBvdXRkYXRlZFNlbGZBY2NlcHRlZE1vZHVsZXNbb107XG5cdFx0XHRcdHZhciBtb2R1bGVJZCA9IGl0ZW0ubW9kdWxlO1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGl0ZW0ucmVxdWlyZShtb2R1bGVJZCk7XG5cdFx0XHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0XHRcdGlmICh0eXBlb2YgaXRlbS5lcnJvckhhbmRsZXIgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0aXRlbS5lcnJvckhhbmRsZXIoZXJyLCB7XG5cdFx0XHRcdFx0XHRcdFx0bW9kdWxlSWQ6IG1vZHVsZUlkLFxuXHRcdFx0XHRcdFx0XHRcdG1vZHVsZTogX193ZWJwYWNrX3JlcXVpcmVfXy5jW21vZHVsZUlkXVxuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdH0gY2F0Y2ggKGVycjIpIHtcblx0XHRcdFx0XHRcdFx0aWYgKG9wdGlvbnMub25FcnJvcmVkKSB7XG5cdFx0XHRcdFx0XHRcdFx0b3B0aW9ucy5vbkVycm9yZWQoe1xuXHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzZWxmLWFjY2VwdC1lcnJvci1oYW5kbGVyLWVycm9yZWRcIixcblx0XHRcdFx0XHRcdFx0XHRcdG1vZHVsZUlkOiBtb2R1bGVJZCxcblx0XHRcdFx0XHRcdFx0XHRcdGVycm9yOiBlcnIyLFxuXHRcdFx0XHRcdFx0XHRcdFx0b3JpZ2luYWxFcnJvcjogZXJyXG5cdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYgKCFvcHRpb25zLmlnbm9yZUVycm9yZWQpIHtcblx0XHRcdFx0XHRcdFx0XHRyZXBvcnRFcnJvcihlcnIyKTtcblx0XHRcdFx0XHRcdFx0XHRyZXBvcnRFcnJvcihlcnIpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGlmIChvcHRpb25zLm9uRXJyb3JlZCkge1xuXHRcdFx0XHRcdFx0XHRvcHRpb25zLm9uRXJyb3JlZCh7XG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzZWxmLWFjY2VwdC1lcnJvcmVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0bW9kdWxlSWQ6IG1vZHVsZUlkLFxuXHRcdFx0XHRcdFx0XHRcdGVycm9yOiBlcnJcblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIW9wdGlvbnMuaWdub3JlRXJyb3JlZCkge1xuXHRcdFx0XHRcdFx0XHRyZXBvcnRFcnJvcihlcnIpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gb3V0ZGF0ZWRNb2R1bGVzO1xuXHRcdH1cblx0fTtcbn1cbl9fd2VicGFja19yZXF1aXJlX18uaG1ySS5qc29ucCA9IGZ1bmN0aW9uIChtb2R1bGVJZCwgYXBwbHlIYW5kbGVycykge1xuXHRpZiAoIWN1cnJlbnRVcGRhdGUpIHtcblx0XHRjdXJyZW50VXBkYXRlID0ge307XG5cdFx0Y3VycmVudFVwZGF0ZVJ1bnRpbWUgPSBbXTtcblx0XHRjdXJyZW50VXBkYXRlUmVtb3ZlZENodW5rcyA9IFtdO1xuXHRcdGFwcGx5SGFuZGxlcnMucHVzaChhcHBseUhhbmRsZXIpO1xuXHR9XG5cdGlmICghX193ZWJwYWNrX3JlcXVpcmVfXy5vKGN1cnJlbnRVcGRhdGUsIG1vZHVsZUlkKSkge1xuXHRcdGN1cnJlbnRVcGRhdGVbbW9kdWxlSWRdID0gX193ZWJwYWNrX3JlcXVpcmVfXy5tW21vZHVsZUlkXTtcblx0fVxufTtcbl9fd2VicGFja19yZXF1aXJlX18uaG1yQy5qc29ucCA9IGZ1bmN0aW9uIChcblx0Y2h1bmtJZHMsXG5cdHJlbW92ZWRDaHVua3MsXG5cdHJlbW92ZWRNb2R1bGVzLFxuXHRwcm9taXNlcyxcblx0YXBwbHlIYW5kbGVycyxcblx0dXBkYXRlZE1vZHVsZXNMaXN0XG4pIHtcblx0YXBwbHlIYW5kbGVycy5wdXNoKGFwcGx5SGFuZGxlcik7XG5cdGN1cnJlbnRVcGRhdGVDaHVua3MgPSB7fTtcblx0Y3VycmVudFVwZGF0ZVJlbW92ZWRDaHVua3MgPSByZW1vdmVkQ2h1bmtzO1xuXHRjdXJyZW50VXBkYXRlID0gcmVtb3ZlZE1vZHVsZXMucmVkdWNlKGZ1bmN0aW9uIChvYmosIGtleSkge1xuXHRcdG9ialtrZXldID0gZmFsc2U7XG5cdFx0cmV0dXJuIG9iajtcblx0fSwge30pO1xuXHRjdXJyZW50VXBkYXRlUnVudGltZSA9IFtdO1xuXHRjaHVua0lkcy5mb3JFYWNoKGZ1bmN0aW9uIChjaHVua0lkKSB7XG5cdFx0aWYgKFxuXHRcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vKGluc3RhbGxlZENodW5rcywgY2h1bmtJZCkgJiZcblx0XHRcdGluc3RhbGxlZENodW5rc1tjaHVua0lkXSAhPT0gdW5kZWZpbmVkXG5cdFx0KSB7XG5cdFx0XHRwcm9taXNlcy5wdXNoKGxvYWRVcGRhdGVDaHVuayhjaHVua0lkLCB1cGRhdGVkTW9kdWxlc0xpc3QpKTtcblx0XHRcdGN1cnJlbnRVcGRhdGVDaHVua3NbY2h1bmtJZF0gPSB0cnVlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdXJyZW50VXBkYXRlQ2h1bmtzW2NodW5rSWRdID0gZmFsc2U7XG5cdFx0fVxuXHR9KTtcblx0aWYgKF9fd2VicGFja19yZXF1aXJlX18uZikge1xuXHRcdF9fd2VicGFja19yZXF1aXJlX18uZi5qc29ucEhtciA9IGZ1bmN0aW9uIChjaHVua0lkLCBwcm9taXNlcykge1xuXHRcdFx0aWYgKFxuXHRcdFx0XHRjdXJyZW50VXBkYXRlQ2h1bmtzICYmXG5cdFx0XHRcdF9fd2VicGFja19yZXF1aXJlX18ubyhjdXJyZW50VXBkYXRlQ2h1bmtzLCBjaHVua0lkKSAmJlxuXHRcdFx0XHQhY3VycmVudFVwZGF0ZUNodW5rc1tjaHVua0lkXVxuXHRcdFx0KSB7XG5cdFx0XHRcdHByb21pc2VzLnB1c2gobG9hZFVwZGF0ZUNodW5rKGNodW5rSWQpKTtcblx0XHRcdFx0Y3VycmVudFVwZGF0ZUNodW5rc1tjaHVua0lkXSA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxufTtcblxuX193ZWJwYWNrX3JlcXVpcmVfXy5obXJNID0gKCkgPT4ge1xuXHRpZiAodHlwZW9mIGZldGNoID09PSBcInVuZGVmaW5lZFwiKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBicm93c2VyIHN1cHBvcnQ6IG5lZWQgZmV0Y2ggQVBJXCIpO1xuXHRyZXR1cm4gZmV0Y2goX193ZWJwYWNrX3JlcXVpcmVfXy5wICsgX193ZWJwYWNrX3JlcXVpcmVfXy5obXJGKCkpLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG5cdFx0aWYocmVzcG9uc2Uuc3RhdHVzID09PSA0MDQpIHJldHVybjsgLy8gbm8gdXBkYXRlIGF2YWlsYWJsZVxuXHRcdGlmKCFyZXNwb25zZS5vaykgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGZldGNoIHVwZGF0ZSBtYW5pZmVzdCBcIiArIHJlc3BvbnNlLnN0YXR1c1RleHQpO1xuXHRcdHJldHVybiByZXNwb25zZS5qc29uKCk7XG5cdH0pO1xufTtcblxuLy8gbm8gb24gY2h1bmtzIGxvYWRlZFxuXG4vLyBubyBqc29ucCBmdW5jdGlvbiIsIl9fd2VicGFja19yZXF1aXJlX18ubmMgPSB1bmRlZmluZWQ7IiwiIiwiLy8gbW9kdWxlIGNhY2hlIGFyZSB1c2VkIHNvIGVudHJ5IGlubGluaW5nIGlzIGRpc2FibGVkXG4vLyBzdGFydHVwXG4vLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vYXBwL3N0YXRpYy9wYWdlcy9sYXlvdXQudHN4XCIpO1xuIiwiIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9