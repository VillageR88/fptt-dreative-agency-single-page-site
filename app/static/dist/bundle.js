/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@egjs/preact-flicking/dist/flicking.esm.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@egjs/preact-flicking/dist/flicking.esm.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ALIGN: () => (/* binding */ ALIGN),
/* harmony export */   AnchorPoint: () => (/* binding */ AnchorPoint),
/* harmony export */   AnimatingState: () => (/* binding */ AnimatingState),
/* harmony export */   AxesController: () => (/* binding */ AxesController),
/* harmony export */   BoundCameraMode: () => (/* binding */ BoundCameraMode),
/* harmony export */   CIRCULAR_FALLBACK: () => (/* binding */ CIRCULAR_FALLBACK),
/* harmony export */   CLASS: () => (/* binding */ CLASS),
/* harmony export */   Camera: () => (/* binding */ Camera),
/* harmony export */   CircularCameraMode: () => (/* binding */ CircularCameraMode),
/* harmony export */   Control: () => (/* binding */ Control),
/* harmony export */   DIRECTION: () => (/* binding */ DIRECTION),
/* harmony export */   DisabledState: () => (/* binding */ DisabledState),
/* harmony export */   DraggingState: () => (/* binding */ DraggingState),
/* harmony export */   ERROR_CODE: () => (/* binding */ CODE),
/* harmony export */   EVENTS: () => (/* binding */ EVENTS),
/* harmony export */   ExternalRenderer: () => (/* binding */ ExternalRenderer),
/* harmony export */   FlickingError: () => (/* binding */ FlickingError),
/* harmony export */   FreeControl: () => (/* binding */ FreeControl),
/* harmony export */   HoldingState: () => (/* binding */ HoldingState),
/* harmony export */   IdleState: () => (/* binding */ IdleState),
/* harmony export */   LinearCameraMode: () => (/* binding */ LinearCameraMode),
/* harmony export */   MOVE_TYPE: () => (/* binding */ MOVE_TYPE),
/* harmony export */   NormalRenderingStrategy: () => (/* binding */ NormalRenderingStrategy),
/* harmony export */   ORDER: () => (/* binding */ ORDER),
/* harmony export */   Panel: () => (/* binding */ Panel),
/* harmony export */   Renderer: () => (/* binding */ Renderer),
/* harmony export */   SnapControl: () => (/* binding */ SnapControl),
/* harmony export */   State: () => (/* binding */ State),
/* harmony export */   StateMachine: () => (/* binding */ StateMachine),
/* harmony export */   StrictControl: () => (/* binding */ StrictControl),
/* harmony export */   VanillaElementProvider: () => (/* binding */ VanillaElementProvider),
/* harmony export */   VanillaRenderer: () => (/* binding */ VanillaRenderer),
/* harmony export */   Viewport: () => (/* binding */ Viewport),
/* harmony export */   ViewportSlot: () => (/* binding */ ViewportSlot),
/* harmony export */   VirtualElementProvider: () => (/* binding */ VirtualElementProvider),
/* harmony export */   VirtualManager: () => (/* binding */ VirtualManager),
/* harmony export */   VirtualPanel: () => (/* binding */ VirtualPanel),
/* harmony export */   VirtualRenderingStrategy: () => (/* binding */ VirtualRenderingStrategy),
/* harmony export */   checkExistence: () => (/* binding */ checkExistence),
/* harmony export */   circulateIndex: () => (/* binding */ circulateIndex),
/* harmony export */   circulatePosition: () => (/* binding */ circulatePosition),
/* harmony export */   clamp: () => (/* binding */ clamp$1),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   find: () => (/* binding */ find$1),
/* harmony export */   findIndex: () => (/* binding */ findIndex),
/* harmony export */   findRight: () => (/* binding */ findRight),
/* harmony export */   getDefaultCameraTransform: () => (/* binding */ getDefaultCameraTransform),
/* harmony export */   getDirection: () => (/* binding */ getDirection$1),
/* harmony export */   getElement: () => (/* binding */ getElement),
/* harmony export */   getElementSize: () => (/* binding */ getElementSize),
/* harmony export */   getFlickingAttached: () => (/* binding */ getFlickingAttached),
/* harmony export */   getMinusCompensatedIndex: () => (/* binding */ getMinusCompensatedIndex),
/* harmony export */   getProgress: () => (/* binding */ getProgress),
/* harmony export */   getRenderingPanels: () => (/* binding */ getRenderingPanels),
/* harmony export */   getStyle: () => (/* binding */ getStyle),
/* harmony export */   includes: () => (/* binding */ includes),
/* harmony export */   isBetween: () => (/* binding */ isBetween),
/* harmony export */   isString: () => (/* binding */ isString),
/* harmony export */   merge: () => (/* binding */ merge),
/* harmony export */   parseAlign: () => (/* binding */ parseAlign$1),
/* harmony export */   parseArithmeticExpression: () => (/* binding */ parseArithmeticExpression),
/* harmony export */   parseArithmeticSize: () => (/* binding */ parseArithmeticSize),
/* harmony export */   parseBounce: () => (/* binding */ parseBounce),
/* harmony export */   parseCSSSizeValue: () => (/* binding */ parseCSSSizeValue),
/* harmony export */   parseElement: () => (/* binding */ parseElement),
/* harmony export */   parsePanelAlign: () => (/* binding */ parsePanelAlign),
/* harmony export */   range: () => (/* binding */ range),
/* harmony export */   setPrototypeOf: () => (/* binding */ setPrototypeOf),
/* harmony export */   setSize: () => (/* binding */ setSize),
/* harmony export */   sync: () => (/* binding */ sync),
/* harmony export */   toArray: () => (/* binding */ toArray$2),
/* harmony export */   withFlickingMethods: () => (/* binding */ withFlickingMethods)
/* harmony export */ });
/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.module.js");
/*
Copyright (c) 2021-present NAVER Corp.
name: @egjs/preact-flicking
license: MIT
author: NAVER Corp.
repository: https://github.com/naver/egjs-flicking/blob/master/packages/preact-flicking
version: 4.11.4
*/


var t,u,r,o=0,i=[],c=preact__WEBPACK_IMPORTED_MODULE_0__.options.__b,f=preact__WEBPACK_IMPORTED_MODULE_0__.options.__r,e=preact__WEBPACK_IMPORTED_MODULE_0__.options.diffed,a=preact__WEBPACK_IMPORTED_MODULE_0__.options.__c,v=preact__WEBPACK_IMPORTED_MODULE_0__.options.unmount;function m(t,r){preact__WEBPACK_IMPORTED_MODULE_0__.options.__h&&preact__WEBPACK_IMPORTED_MODULE_0__.options.__h(u,t,o||r),o=0;var i=u.__H||(u.__H={__:[],__h:[]});return t>=i.__.length&&i.__.push({}),i.__[t]}function l(n){return o=1,p(w,n)}function p(n,r,o){var i=m(t++,2);return i.t=n,i.__c||(i.__=[o?o(r):w(void 0,r),function(n){var t=i.t(i.__[0],n);i.__[0]!==t&&(i.__=[t,i.__[1]],i.__c.setState({}));}],i.__c=u),i.__}function y(r,o){var i=m(t++,3);!preact__WEBPACK_IMPORTED_MODULE_0__.options.__s&&k(i.__H,o)&&(i.__=r,i.__H=o,u.__H.__h.push(i));}function h(r,o){var i=m(t++,4);!preact__WEBPACK_IMPORTED_MODULE_0__.options.__s&&k(i.__H,o)&&(i.__=r,i.__H=o,u.__h.push(i));}function s(n){return o=5,d(function(){return {current:n}},[])}function _(n,t,u){o=6,h(function(){"function"==typeof n?n(t()):n&&(n.current=t());},null==u?u:u.concat(n));}function d(n,u){var r=m(t++,7);return k(r.__H,u)&&(r.__=n(),r.__H=u,r.__h=n),r.__}function A(n,t){return o=8,d(function(){return n},t)}function F(n){var r=u.context[n.__c],o=m(t++,9);return o.c=n,r?(null==o.__&&(o.__=!0,r.sub(u)),r.props.value):n.__}function T(t,u){preact__WEBPACK_IMPORTED_MODULE_0__.options.useDebugValue&&preact__WEBPACK_IMPORTED_MODULE_0__.options.useDebugValue(u?u(t):t);}function x(){var t;for(i.sort(function(n,t){return n.__v.__b-t.__v.__b});t=i.pop();)if(t.__P)try{t.__H.__h.forEach(g),t.__H.__h.forEach(j),t.__H.__h=[];}catch(u){t.__H.__h=[],preact__WEBPACK_IMPORTED_MODULE_0__.options.__e(u,t.__v);}}preact__WEBPACK_IMPORTED_MODULE_0__.options.__b=function(n){u=null,c&&c(n);},preact__WEBPACK_IMPORTED_MODULE_0__.options.__r=function(n){f&&f(n),t=0;var r=(u=n.__c).__H;r&&(r.__h.forEach(g),r.__h.forEach(j),r.__h=[]);},preact__WEBPACK_IMPORTED_MODULE_0__.options.diffed=function(t){e&&e(t);var o=t.__c;o&&o.__H&&o.__H.__h.length&&(1!==i.push(o)&&r===preact__WEBPACK_IMPORTED_MODULE_0__.options.requestAnimationFrame||((r=preact__WEBPACK_IMPORTED_MODULE_0__.options.requestAnimationFrame)||function(n){var t,u=function(){clearTimeout(r),b&&cancelAnimationFrame(t),setTimeout(n);},r=setTimeout(u,100);b&&(t=requestAnimationFrame(u));})(x)),u=null;},preact__WEBPACK_IMPORTED_MODULE_0__.options.__c=function(t,u){u.some(function(t){try{t.__h.forEach(g),t.__h=t.__h.filter(function(n){return !n.__||j(n)});}catch(r){u.some(function(n){n.__h&&(n.__h=[]);}),u=[],preact__WEBPACK_IMPORTED_MODULE_0__.options.__e(r,t.__v);}}),a&&a(t,u);},preact__WEBPACK_IMPORTED_MODULE_0__.options.unmount=function(t){v&&v(t);var u,r=t.__c;r&&r.__H&&(r.__H.__.forEach(function(n){try{g(n);}catch(n){u=n;}}),u&&preact__WEBPACK_IMPORTED_MODULE_0__.options.__e(u,r.__v));};var b="function"==typeof requestAnimationFrame;function g(n){var t=u,r=n.__c;"function"==typeof r&&(n.__c=void 0,r()),u=t;}function j(n){var t=u;n.__c=n.__(),u=t;}function k(n,t){return !n||n.length!==t.length||t.some(function(t,u){return t!==n[u]})}function w(n,t){return "function"==typeof t?t(n):t}

function S(n,t){for(var e in t)n[e]=t[e];return n}function C(n,t){for(var e in n)if("__source"!==e&&!(e in t))return !0;for(var r in t)if("__source"!==r&&n[r]!==t[r])return !0;return !1}function E(n){this.props=n;}function g$1(n,t){function e(n){var e=this.props.ref,r=e==n.ref;return !r&&e&&(e.call?e(null):e.current=null),t?!t(this.props,n)||!r:C(this.props,n)}function r(t){return this.shouldComponentUpdate=e,(0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(n,t)}return r.displayName="Memo("+(n.displayName||n.name)+")",r.prototype.isReactComponent=!0,r.__f=!0,r}(E.prototype=new preact__WEBPACK_IMPORTED_MODULE_0__.Component).isPureReactComponent=!0,E.prototype.shouldComponentUpdate=function(n,t){return C(this.props,n)||C(this.state,t)};var w$1=preact__WEBPACK_IMPORTED_MODULE_0__.options.__b;preact__WEBPACK_IMPORTED_MODULE_0__.options.__b=function(n){n.type&&n.type.__f&&n.ref&&(n.props.ref=n.ref,n.ref=null),w$1&&w$1(n);};var R="undefined"!=typeof Symbol&&Symbol.for&&Symbol.for("react.forward_ref")||3911;function x$1(n){function t(t,e){var r=S({},t);return delete r.ref,n(r,(e=t.ref||e)&&("object"!=typeof e||"current"in e)?e:null)}return t.$$typeof=R,t.render=t,t.prototype.isReactComponent=t.__f=!0,t.displayName="ForwardRef("+(n.displayName||n.name)+")",t}var N=function(n,t){return null==n?null:(0,preact__WEBPACK_IMPORTED_MODULE_0__.toChildArray)((0,preact__WEBPACK_IMPORTED_MODULE_0__.toChildArray)(n).map(t))},k$1={map:N,forEach:N,count:function(n){return n?(0,preact__WEBPACK_IMPORTED_MODULE_0__.toChildArray)(n).length:0},only:function(n){var t=(0,preact__WEBPACK_IMPORTED_MODULE_0__.toChildArray)(n);if(1!==t.length)throw "Children.only";return t[0]},toArray:preact__WEBPACK_IMPORTED_MODULE_0__.toChildArray},A$1=preact__WEBPACK_IMPORTED_MODULE_0__.options.__e;preact__WEBPACK_IMPORTED_MODULE_0__.options.__e=function(n,t,e){if(n.then)for(var r,u=t;u=u.__;)if((r=u.__c)&&r.__c)return null==t.__e&&(t.__e=e.__e,t.__k=e.__k),r.__c(n,t);A$1(n,t,e);};var O=preact__WEBPACK_IMPORTED_MODULE_0__.options.unmount;function L(){this.__u=0,this.t=null,this.__b=null;}function U(n){var t=n.__.__c;return t&&t.__e&&t.__e(n)}function F$1(n){var t,e,r;function u(u){if(t||(t=n()).then(function(n){e=n.default||n;},function(n){r=n;}),r)throw r;if(!e)throw t;return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(e,u)}return u.displayName="Lazy",u.__f=!0,u}function M(){this.u=null,this.o=null;}preact__WEBPACK_IMPORTED_MODULE_0__.options.unmount=function(n){var t=n.__c;t&&t.__R&&t.__R(),t&&!0===n.__h&&(n.type=null),O&&O(n);},(L.prototype=new preact__WEBPACK_IMPORTED_MODULE_0__.Component).__c=function(n,t){var e=t.__c,r=this;null==r.t&&(r.t=[]),r.t.push(e);var u=U(r.__v),o=!1,i=function(){o||(o=!0,e.__R=null,u?u(l):l());};e.__R=i;var l=function(){if(!--r.__u){if(r.state.__e){var n=r.state.__e;r.__v.__k[0]=function n(t,e,r){return t&&(t.__v=null,t.__k=t.__k&&t.__k.map(function(t){return n(t,e,r)}),t.__c&&t.__c.__P===e&&(t.__e&&r.insertBefore(t.__e,t.__d),t.__c.__e=!0,t.__c.__P=r)),t}(n,n.__c.__P,n.__c.__O);}var t;for(r.setState({__e:r.__b=null});t=r.t.pop();)t.forceUpdate();}},c=!0===t.__h;r.__u++||c||r.setState({__e:r.__b=r.__v.__k[0]}),n.then(i,i);},L.prototype.componentWillUnmount=function(){this.t=[];},L.prototype.render=function(n,t){if(this.__b){if(this.__v.__k){var e=document.createElement("div"),r=this.__v.__k[0].__c;this.__v.__k[0]=function n(t,e,r){return t&&(t.__c&&t.__c.__H&&(t.__c.__H.__.forEach(function(n){"function"==typeof n.__c&&n.__c();}),t.__c.__H=null),null!=(t=S({},t)).__c&&(t.__c.__P===r&&(t.__c.__P=e),t.__c=null),t.__k=t.__k&&t.__k.map(function(t){return n(t,e,r)})),t}(this.__b,e,r.__O=r.__P);}this.__b=null;}var u=t.__e&&(0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(preact__WEBPACK_IMPORTED_MODULE_0__.Fragment,null,n.fallback);return u&&(u.__h=null),[(0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(preact__WEBPACK_IMPORTED_MODULE_0__.Fragment,null,t.__e?null:n.children),u]};var T$1=function(n,t,e){if(++e[1]===e[0]&&n.o.delete(t),n.props.revealOrder&&("t"!==n.props.revealOrder[0]||!n.o.size))for(e=n.u;e;){for(;e.length>3;)e.pop()();if(e[1]<e[0])break;n.u=e=e[2];}};function D(n){return this.getChildContext=function(){return n.context},n.children}function I(n){var t=this,e=n.i;t.componentWillUnmount=function(){(0,preact__WEBPACK_IMPORTED_MODULE_0__.render)(null,t.l),t.l=null,t.i=null;},t.i&&t.i!==e&&t.componentWillUnmount(),n.__v?(t.l||(t.i=e,t.l={nodeType:1,parentNode:e,childNodes:[],appendChild:function(n){this.childNodes.push(n),t.i.appendChild(n);},insertBefore:function(n,e){this.childNodes.push(n),t.i.appendChild(n);},removeChild:function(n){this.childNodes.splice(this.childNodes.indexOf(n)>>>1,1),t.i.removeChild(n);}}),(0,preact__WEBPACK_IMPORTED_MODULE_0__.render)((0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(D,{context:t.context},n.__v),t.l)):t.l&&t.componentWillUnmount();}function W(n,t){return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(I,{__v:n,i:t})}(M.prototype=new preact__WEBPACK_IMPORTED_MODULE_0__.Component).__e=function(n){var t=this,e=U(t.__v),r=t.o.get(n);return r[0]++,function(u){var o=function(){t.props.revealOrder?(r.push(u),T$1(t,n,r)):u();};e?e(o):o();}},M.prototype.render=function(n){this.u=null,this.o=new Map;var t=(0,preact__WEBPACK_IMPORTED_MODULE_0__.toChildArray)(n.children);n.revealOrder&&"b"===n.revealOrder[0]&&t.reverse();for(var e=t.length;e--;)this.o.set(t[e],this.u=[1,0,this.u]);return n.children},M.prototype.componentDidUpdate=M.prototype.componentDidMount=function(){var n=this;this.o.forEach(function(t,e){T$1(n,e,t);});};var j$1="undefined"!=typeof Symbol&&Symbol.for&&Symbol.for("react.element")||60103,P=/^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|marker(?!H|W|U)|overline|paint|stop|strikethrough|stroke|text(?!L)|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/,V="undefined"!=typeof document,z=function(n){return ("undefined"!=typeof Symbol&&"symbol"==typeof Symbol()?/fil|che|rad/i:/fil|che|ra/i).test(n)};function B(n,t,e){return null==t.__k&&(t.textContent=""),(0,preact__WEBPACK_IMPORTED_MODULE_0__.render)(n,t),"function"==typeof e&&e(),n?n.__c:null}function $(n,t,e){return (0,preact__WEBPACK_IMPORTED_MODULE_0__.hydrate)(n,t),"function"==typeof e&&e(),n?n.__c:null}preact__WEBPACK_IMPORTED_MODULE_0__.Component.prototype.isReactComponent={},["componentWillMount","componentWillReceiveProps","componentWillUpdate"].forEach(function(n){Object.defineProperty(preact__WEBPACK_IMPORTED_MODULE_0__.Component.prototype,n,{configurable:!0,get:function(){return this["UNSAFE_"+n]},set:function(t){Object.defineProperty(this,n,{configurable:!0,writable:!0,value:t});}});});var H=preact__WEBPACK_IMPORTED_MODULE_0__.options.event;function Z(){}function Y(){return this.cancelBubble}function q(){return this.defaultPrevented}preact__WEBPACK_IMPORTED_MODULE_0__.options.event=function(n){return H&&(n=H(n)),n.persist=Z,n.isPropagationStopped=Y,n.isDefaultPrevented=q,n.nativeEvent=n};var G,J={configurable:!0,get:function(){return this.class}},K=preact__WEBPACK_IMPORTED_MODULE_0__.options.vnode;preact__WEBPACK_IMPORTED_MODULE_0__.options.vnode=function(n){var t=n.type,e=n.props,r=e;if("string"==typeof t){var u=-1===t.indexOf("-");for(var o in r={},e){var i=e[o];V&&"children"===o&&"noscript"===t||"value"===o&&"defaultValue"in e&&null==i||("defaultValue"===o&&"value"in e&&null==e.value?o="value":"download"===o&&!0===i?i="":/ondoubleclick/i.test(o)?o="ondblclick":/^onchange(textarea|input)/i.test(o+t)&&!z(e.type)?o="oninput":/^onfocus$/i.test(o)?o="onfocusin":/^onblur$/i.test(o)?o="onfocusout":/^on(Ani|Tra|Tou|BeforeInp)/.test(o)?o=o.toLowerCase():u&&P.test(o)?o=o.replace(/[A-Z0-9]/,"-$&").toLowerCase():null===i&&(i=void 0),r[o]=i);}"select"==t&&r.multiple&&Array.isArray(r.value)&&(r.value=(0,preact__WEBPACK_IMPORTED_MODULE_0__.toChildArray)(e.children).forEach(function(n){n.props.selected=-1!=r.value.indexOf(n.props.value);})),"select"==t&&null!=r.defaultValue&&(r.value=(0,preact__WEBPACK_IMPORTED_MODULE_0__.toChildArray)(e.children).forEach(function(n){n.props.selected=r.multiple?-1!=r.defaultValue.indexOf(n.props.value):r.defaultValue==n.props.value;})),n.props=r,e.class!=e.className&&(J.enumerable="className"in e,null!=e.className&&(r.class=e.className),Object.defineProperty(r,"className",J));}n.$$typeof=j$1,K&&K(n);};var Q=preact__WEBPACK_IMPORTED_MODULE_0__.options.__r;preact__WEBPACK_IMPORTED_MODULE_0__.options.__r=function(n){Q&&Q(n),G=n.__c;};var X={ReactCurrentDispatcher:{current:{readContext:function(n){return G.__n[n.__c].props.value}}}};function tn(n){return preact__WEBPACK_IMPORTED_MODULE_0__.createElement.bind(null,n)}function en(n){return !!n&&n.$$typeof===j$1}function rn(n){return en(n)?preact__WEBPACK_IMPORTED_MODULE_0__.cloneElement.apply(null,arguments):n}function un(n){return !!n.__k&&((0,preact__WEBPACK_IMPORTED_MODULE_0__.render)(null,n),!0)}function on(n){return n&&(n.base||1===n.nodeType&&n)||null}var ln=function(n,t){return n(t)},cn=function(n,t){return n(t)};var React__default = {useState:l,useReducer:p,useEffect:y,useLayoutEffect:h,useRef:s,useImperativeHandle:_,useMemo:d,useCallback:A,useContext:F,useDebugValue:T,version:"17.0.2",Children:k$1,render:B,hydrate:$,unmountComponentAtNode:un,createPortal:W,createElement:preact__WEBPACK_IMPORTED_MODULE_0__.createElement,createContext:preact__WEBPACK_IMPORTED_MODULE_0__.createContext,createFactory:tn,cloneElement:rn,createRef:preact__WEBPACK_IMPORTED_MODULE_0__.createRef,Fragment:preact__WEBPACK_IMPORTED_MODULE_0__.Fragment,isValidElement:en,findDOMNode:on,Component:preact__WEBPACK_IMPORTED_MODULE_0__.Component,PureComponent:E,memo:g$1,forwardRef:x$1,flushSync:cn,unstable_batchedUpdates:ln,StrictMode:preact__WEBPACK_IMPORTED_MODULE_0__.Fragment,Suspense:L,SuspenseList:M,lazy:F$1,__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED:X};

/*
Copyright (c) NAVER Corp.
name: @egjs/component
license: MIT
author: NAVER Corp.
repository: https://github.com/naver/egjs-component
version: 3.0.4
*/
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator,
    m = s && o[s],
    i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function () {
      if (o && i >= o.length) o = void 0;
      return {
        value: o && o[i++],
        done: !o
      };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o),
    r,
    ar = [],
    e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = {
      error: error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
  return ar;
}

/*
 * Copyright (c) 2015 NAVER Corp.
 * egjs projects are licensed under the MIT license
 */
var isUndefined = function (value) {
  return typeof value === "undefined";
};

// This class name is not matched to file name intentionally
/**
 * Event class to provide additional properties
 * @ko Component에서 추가적인 프로퍼티를 제공하는 이벤트 클래스
 */
var ComponentEvent = /*#__PURE__*/function () {
  /**
   * Create a new instance of ComponentEvent.
   * @ko ComponentEvent의 새로운 인스턴스를 생성한다.
   * @param eventType The name of the event.<ko>이벤트 이름.</ko>
   * @param props An object that contains additional event properties.<ko>추가적인 이벤트 프로퍼티 오브젝트.</ko>
   */
  function ComponentEvent(eventType, props) {
    var e_1, _a;
    this._canceled = false;
    if (props) {
      try {
        for (var _b = __values(Object.keys(props)), _c = _b.next(); !_c.done; _c = _b.next()) {
          var key = _c.value;
          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
          this[key] = props[key];
        }
      } catch (e_1_1) {
        e_1 = {
          error: e_1_1
        };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        } finally {
          if (e_1) throw e_1.error;
        }
      }
    }
    this.eventType = eventType;
  }
  /**
   * Stop the event. {@link ComponentEvent#isCanceled} will return `true` after.
   * @ko 이벤트를 중단한다. 이후 {@link ComponentEvent#isCanceled}가 `true`를 반환한다.
   */
  var __proto = ComponentEvent.prototype;
  __proto.stop = function () {
    this._canceled = true;
  };
  /**
   * Returns a boolean value that indicates whether {@link ComponentEvent#stop} is called before.
   * @ko {@link ComponentEvent#stop}이 호출되었는지 여부를 반환한다.
   * @return {boolean} A boolean value that indicates whether {@link ComponentEvent#stop} is called before.<ko>이전에 {@link ComponentEvent#stop}이 불려졌는지 여부를 반환한다.</ko>
   */
  __proto.isCanceled = function () {
    return this._canceled;
  };
  return ComponentEvent;
}();

/**
 * A class used to manage events in a component
 * @ko 컴포넌트의 이벤트을 관리할 수 있게 하는 클래스
 */
var Component = /*#__PURE__*/function () {
  /**
   * @support {"ie": "7+", "ch" : "latest", "ff" : "latest",  "sf" : "latest", "edge" : "latest", "ios" : "7+", "an" : "2.1+ (except 3.x)"}
   */
  function Component() {
    this._eventHandler = {};
  }
  /**
   * Trigger a custom event.
   * @ko 커스텀 이벤트를 발생시킨다
   * @param {string | ComponentEvent} event The name of the custom event to be triggered or an instance of the ComponentEvent<ko>발생할 커스텀 이벤트의 이름 또는 ComponentEvent의 인스턴스</ko>
   * @param {any[]} params Event data to be sent when triggering a custom event <ko>커스텀 이벤트가 발생할 때 전달할 데이터</ko>
   * @return An instance of the component itself<ko>컴포넌트 자신의 인스턴스</ko>
   * @example
   * ```ts
   * import Component, { ComponentEvent } from "@egjs/component";
   *
   * class Some extends Component<{
   *   beforeHi: ComponentEvent<{ foo: number; bar: string }>;
   *   hi: { foo: { a: number; b: boolean } };
   *   someEvent: (foo: number, bar: string) => void;
   *   someOtherEvent: void; // When there's no event argument
   * }> {
   *   some(){
   *     if(this.trigger("beforeHi")){ // When event call to stop return false.
   *       this.trigger("hi");// fire hi event.
   *     }
   *   }
   * }
   *
   * const some = new Some();
   * some.on("beforeHi", e => {
   *   if(condition){
   *     e.stop(); // When event call to stop, `hi` event not call.
   *   }
   *   // `currentTarget` is component instance.
   *   console.log(some === e.currentTarget); // true
   *
   *   typeof e.foo; // number
   *   typeof e.bar; // string
   * });
   * some.on("hi", e => {
   *   typeof e.foo.b; // boolean
   * });
   * // If you want to more know event design. You can see article.
   * // https://github.com/naver/egjs-component/wiki/How-to-make-Component-event-design%3F
   * ```
   */
  var __proto = Component.prototype;
  __proto.trigger = function (event) {
    var params = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      params[_i - 1] = arguments[_i];
    }
    var eventName = event instanceof ComponentEvent ? event.eventType : event;
    var handlers = __spread(this._eventHandler[eventName] || []);
    if (handlers.length <= 0) {
      return this;
    }
    if (event instanceof ComponentEvent) {
      event.currentTarget = this;
      handlers.forEach(function (handler) {
        handler(event);
      });
    } else {
      handlers.forEach(function (handler) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-call
        handler.apply(void 0, __spread(params));
      });
    }
    return this;
  };
  /**
   * Executed event just one time.
   * @ko 이벤트가 한번만 실행된다.
   * @param {string} eventName The name of the event to be attached or an event name - event handler mapped object.<ko>등록할 이벤트의 이름 또는 이벤트 이름-핸들러 오브젝트</ko>
   * @param {function} handlerToAttach The handler function of the event to be attached <ko>등록할 이벤트의 핸들러 함수</ko>
   * @return An instance of the component itself<ko>컴포넌트 자신의 인스턴스</ko>
   * @example
   * ```ts
   * import Component, { ComponentEvent } from "@egjs/component";
   *
   * class Some extends Component<{
   *   hi: ComponentEvent;
   * }> {
   *   hi() {
   *     alert("hi");
   *   }
   *   thing() {
   *     this.once("hi", this.hi);
   *   }
   * }
   *
   * var some = new Some();
   * some.thing();
   * some.trigger(new ComponentEvent("hi"));
   * // fire alert("hi");
   * some.trigger(new ComponentEvent("hi"));
   * // Nothing happens
   * ```
   */
  __proto.once = function (eventName, handlerToAttach) {
    var _this = this;
    if (typeof eventName === "object" && isUndefined(handlerToAttach)) {
      var eventHash = eventName;
      for (var key in eventHash) {
        this.once(key, eventHash[key]);
      }
      return this;
    } else if (typeof eventName === "string" && typeof handlerToAttach === "function") {
      var listener_1 = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        // eslint-disable-next-line @typescript-eslint/no-unsafe-call
        handlerToAttach.apply(void 0, __spread(args));
        _this.off(eventName, listener_1);
      };
      this.on(eventName, listener_1);
    }
    return this;
  };
  /**
   * Checks whether an event has been attached to a component.
   * @ko 컴포넌트에 이벤트가 등록됐는지 확인한다.
   * @param {string} eventName The name of the event to be attached <ko>등록 여부를 확인할 이벤트의 이름</ko>
   * @return {boolean} Indicates whether the event is attached. <ko>이벤트 등록 여부</ko>
   * @example
   * ```ts
   * import Component from "@egjs/component";
   *
   * class Some extends Component<{
   *   hi: void;
   * }> {
   *   some() {
   *     this.hasOn("hi");// check hi event.
   *   }
   * }
   * ```
   */
  __proto.hasOn = function (eventName) {
    return !!this._eventHandler[eventName];
  };
  /**
   * Attaches an event to a component.
   * @ko 컴포넌트에 이벤트를 등록한다.
   * @param {string} eventName The name of the event to be attached or an event name - event handler mapped object.<ko>등록할 이벤트의 이름 또는 이벤트 이름-핸들러 오브젝트</ko>
   * @param {function} handlerToAttach The handler function of the event to be attached <ko>등록할 이벤트의 핸들러 함수</ko>
   * @return An instance of a component itself<ko>컴포넌트 자신의 인스턴스</ko>
   * @example
   * ```ts
   * import Component, { ComponentEvent } from "@egjs/component";
   *
   * class Some extends Component<{
   *   hi: void;
   * }> {
   *   hi() {
   *     console.log("hi");
   *   }
   *   some() {
   *     this.on("hi",this.hi); //attach event
   *   }
   * }
   * ```
   */
  __proto.on = function (eventName, handlerToAttach) {
    if (typeof eventName === "object" && isUndefined(handlerToAttach)) {
      var eventHash = eventName;
      for (var name in eventHash) {
        this.on(name, eventHash[name]);
      }
      return this;
    } else if (typeof eventName === "string" && typeof handlerToAttach === "function") {
      var handlerList = this._eventHandler[eventName];
      if (isUndefined(handlerList)) {
        this._eventHandler[eventName] = [];
        handlerList = this._eventHandler[eventName];
      }
      handlerList.push(handlerToAttach);
    }
    return this;
  };
  /**
   * Detaches an event from the component.<br/>If the `eventName` is not given this will detach all event handlers attached.<br/>If the `handlerToDetach` is not given, this will detach all event handlers for `eventName`.
   * @ko 컴포넌트에 등록된 이벤트를 해제한다.<br/>`eventName`이 주어지지 않았을 경우 모든 이벤트 핸들러를 제거한다.<br/>`handlerToAttach`가 주어지지 않았을 경우 `eventName`에 해당하는 모든 이벤트 핸들러를 제거한다.
   * @param {string?} eventName The name of the event to be detached <ko>해제할 이벤트의 이름</ko>
   * @param {function?} handlerToDetach The handler function of the event to be detached <ko>해제할 이벤트의 핸들러 함수</ko>
   * @return An instance of a component itself <ko>컴포넌트 자신의 인스턴스</ko>
   * @example
   * ```ts
   * import Component, { ComponentEvent } from "@egjs/component";
   *
   * class Some extends Component<{
   *   hi: void;
   * }> {
   *   hi() {
   *     console.log("hi");
   *   }
   *   some() {
   *     this.off("hi",this.hi); //detach event
   *   }
   * }
   * ```
   */
  __proto.off = function (eventName, handlerToDetach) {
    var e_1, _a;
    // Detach all event handlers.
    if (isUndefined(eventName)) {
      this._eventHandler = {};
      return this;
    }
    // Detach all handlers for eventname or detach event handlers by object.
    if (isUndefined(handlerToDetach)) {
      if (typeof eventName === "string") {
        delete this._eventHandler[eventName];
        return this;
      } else {
        var eventHash = eventName;
        for (var name in eventHash) {
          this.off(name, eventHash[name]);
        }
        return this;
      }
    }
    // Detach single event handler
    var handlerList = this._eventHandler[eventName];
    if (handlerList) {
      var idx = 0;
      try {
        for (var handlerList_1 = __values(handlerList), handlerList_1_1 = handlerList_1.next(); !handlerList_1_1.done; handlerList_1_1 = handlerList_1.next()) {
          var handlerFunction = handlerList_1_1.value;
          if (handlerFunction === handlerToDetach) {
            handlerList.splice(idx, 1);
            if (handlerList.length <= 0) {
              delete this._eventHandler[eventName];
            }
            break;
          }
          idx++;
        }
      } catch (e_1_1) {
        e_1 = {
          error: e_1_1
        };
      } finally {
        try {
          if (handlerList_1_1 && !handlerList_1_1.done && (_a = handlerList_1.return)) _a.call(handlerList_1);
        } finally {
          if (e_1) throw e_1.error;
        }
      }
    }
    return this;
  };
  /**
   * Version info string
   * @ko 버전정보 문자열
   * @name VERSION
   * @static
   * @example
   * Component.VERSION;  // ex) 3.0.0
   * @memberof Component
   */
  Component.VERSION = "3.0.4";
  return Component;
}();

/*
 * Copyright (c) 2015 NAVER Corp.
 * egjs projects are licensed under the MIT license
 */
// eslint-disable-next-line @typescript-eslint/naming-convention, @typescript-eslint/no-unsafe-assignment
var ComponentEvent$1 = ComponentEvent;

/*
Copyright (c) 2019-present NAVER Corp.
name: @egjs/list-differ
license: MIT
author: NAVER Corp.
repository: https://github.com/naver/egjs-list-differ
version: 1.0.1
*/
/*
egjs-list-differ
Copyright (c) 2019-present NAVER Corp.
MIT license
*/
var PolyMap =
/*#__PURE__*/
function () {
  function PolyMap() {
    this.keys = [];
    this.values = [];
  }

  var __proto = PolyMap.prototype;

  __proto.get = function (key) {
    return this.values[this.keys.indexOf(key)];
  };

  __proto.set = function (key, value) {
    var keys = this.keys;
    var values = this.values;
    var prevIndex = keys.indexOf(key);
    var index = prevIndex === -1 ? keys.length : prevIndex;
    keys[index] = key;
    values[index] = value;
  };

  return PolyMap;
}();

/*
egjs-list-differ
Copyright (c) 2019-present NAVER Corp.
MIT license
*/
var HashMap =
/*#__PURE__*/
function () {
  function HashMap() {
    this.object = {};
  }

  var __proto = HashMap.prototype;

  __proto.get = function (key) {
    return this.object[key];
  };

  __proto.set = function (key, value) {
    this.object[key] = value;
  };

  return HashMap;
}();

/*
egjs-list-differ
Copyright (c) 2019-present NAVER Corp.
MIT license
*/
var SUPPORT_MAP = typeof Map === "function";

/*
egjs-list-differ
Copyright (c) 2019-present NAVER Corp.
MIT license
*/
var Link =
/*#__PURE__*/
function () {
  function Link() {}

  var __proto = Link.prototype;

  __proto.connect = function (prevLink, nextLink) {
    this.prev = prevLink;
    this.next = nextLink;
    prevLink && (prevLink.next = this);
    nextLink && (nextLink.prev = this);
  };

  __proto.disconnect = function () {
    // In double linked list, diconnect the interconnected relationship.
    var prevLink = this.prev;
    var nextLink = this.next;
    prevLink && (prevLink.next = nextLink);
    nextLink && (nextLink.prev = prevLink);
  };

  __proto.getIndex = function () {
    var link = this;
    var index = -1;

    while (link) {
      link = link.prev;
      ++index;
    }

    return index;
  };

  return Link;
}();

/*
egjs-list-differ
Copyright (c) 2019-present NAVER Corp.
MIT license
*/

function orderChanged(changed, fixed) {
  // It is roughly in the order of these examples.
  // 4, 6, 0, 2, 1, 3, 5, 7
  var fromLinks = []; // 0, 1, 2, 3, 4, 5, 6, 7

  var toLinks = [];
  changed.forEach(function (_a) {
    var from = _a[0],
        to = _a[1];
    var link = new Link();
    fromLinks[from] = link;
    toLinks[to] = link;
  }); // `fromLinks` are connected to each other by double linked list.

  fromLinks.forEach(function (link, i) {
    link.connect(fromLinks[i - 1]);
  });
  return changed.filter(function (_, i) {
    return !fixed[i];
  }).map(function (_a, i) {
    var from = _a[0],
        to = _a[1];

    if (from === to) {
      return [0, 0];
    }

    var fromLink = fromLinks[from];
    var toLink = toLinks[to - 1];
    var fromIndex = fromLink.getIndex(); // Disconnect the link connected to `fromLink`.

    fromLink.disconnect(); // Connect `fromLink` to the right of `toLink`.

    if (!toLink) {
      fromLink.connect(undefined, fromLinks[0]);
    } else {
      fromLink.connect(toLink, toLink.next);
    }

    var toIndex = fromLink.getIndex();
    return [fromIndex, toIndex];
  });
}

var Result =
/*#__PURE__*/
function () {
  function Result(prevList, list, added, removed, changed, maintained, changedBeforeAdded, fixed) {
    this.prevList = prevList;
    this.list = list;
    this.added = added;
    this.removed = removed;
    this.changed = changed;
    this.maintained = maintained;
    this.changedBeforeAdded = changedBeforeAdded;
    this.fixed = fixed;
  }

  var __proto = Result.prototype;
  Object.defineProperty(__proto, "ordered", {
    get: function () {
      if (!this.cacheOrdered) {
        this.caculateOrdered();
      }

      return this.cacheOrdered;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(__proto, "pureChanged", {
    get: function () {
      if (!this.cachePureChanged) {
        this.caculateOrdered();
      }

      return this.cachePureChanged;
    },
    enumerable: true,
    configurable: true
  });

  __proto.caculateOrdered = function () {
    var ordered = orderChanged(this.changedBeforeAdded, this.fixed);
    var changed = this.changed;
    var pureChanged = [];
    this.cacheOrdered = ordered.filter(function (_a, i) {
      var from = _a[0],
          to = _a[1];
      var _b = changed[i],
          fromBefore = _b[0],
          toBefore = _b[1];

      if (from !== to) {
        pureChanged.push([fromBefore, toBefore]);
        return true;
      }
    });
    this.cachePureChanged = pureChanged;
  };

  return Result;
}();

/**
 *
 * @memberof eg.ListDiffer
 * @static
 * @function
 * @param - Previous List <ko> 이전 목록 </ko>
 * @param - List to Update <ko> 업데이트 할 목록 </ko>
 * @param - This callback function returns the key of the item. <ko> 아이템의 키를 반환하는 콜백 함수입니다.</ko>
 * @return - Returns the diff between `prevList` and `list` <ko> `prevList`와 `list`의 다른 점을 반환한다.</ko>
 * @example
 * import { diff } from "@egjs/list-differ";
 * // script => eg.ListDiffer.diff
 * const result = diff([0, 1, 2, 3, 4, 5], [7, 8, 0, 4, 3, 6, 2, 1], e => e);
 * // List before update
 * // [1, 2, 3, 4, 5]
 * console.log(result.prevList);
 * // Updated list
 * // [4, 3, 6, 2, 1]
 * console.log(result.list);
 * // Index array of values added to `list`
 * // [0, 1, 5]
 * console.log(result.added);
 * // Index array of values removed in `prevList`
 * // [5]
 * console.log(result.removed);
 * // An array of index pairs of `prevList` and `list` with different indexes from `prevList` and `list`
 * // [[0, 2], [4, 3], [3, 4], [2, 6], [1, 7]]
 * console.log(result.changed);
 * // The subset of `changed` and an array of index pairs that moved data directly. Indicate an array of absolute index pairs of `ordered`.(Formatted by: Array<[index of prevList, index of list]>)
 * // [[4, 3], [3, 4], [2, 6]]
 * console.log(result.pureChanged);
 * // An array of index pairs to be `ordered` that can synchronize `list` before adding data. (Formatted by: Array<[prevIndex, nextIndex]>)
 * // [[4, 1], [4, 2], [4, 3]]
 * console.log(result.ordered);
 * // An array of index pairs of `prevList` and `list` that have not been added/removed so data is preserved
 * // [[0, 2], [4, 3], [3, 4], [2, 6], [1, 7]]
 * console.log(result.maintained);
 */

function diff(prevList, list, findKeyCallback) {
  var mapClass = SUPPORT_MAP ? Map : findKeyCallback ? HashMap : PolyMap;

  var callback = findKeyCallback || function (e) {
    return e;
  };

  var added = [];
  var removed = [];
  var maintained = [];
  var prevKeys = prevList.map(callback);
  var keys = list.map(callback);
  var prevKeyMap = new mapClass();
  var keyMap = new mapClass();
  var changedBeforeAdded = [];
  var fixed = [];
  var removedMap = {};
  var changed = [];
  var addedCount = 0;
  var removedCount = 0; // Add prevKeys and keys to the hashmap.

  prevKeys.forEach(function (key, prevListIndex) {
    prevKeyMap.set(key, prevListIndex);
  });
  keys.forEach(function (key, listIndex) {
    keyMap.set(key, listIndex);
  }); // Compare `prevKeys` and `keys` and add them to `removed` if they are not in `keys`.

  prevKeys.forEach(function (key, prevListIndex) {
    var listIndex = keyMap.get(key); // In prevList, but not in list, it is removed.

    if (typeof listIndex === "undefined") {
      ++removedCount;
      removed.push(prevListIndex);
    } else {
      removedMap[listIndex] = removedCount;
    }
  }); // Compare `prevKeys` and `keys` and add them to `added` if they are not in `prevKeys`.

  keys.forEach(function (key, listIndex) {
    var prevListIndex = prevKeyMap.get(key); // In list, but not in prevList, it is added.

    if (typeof prevListIndex === "undefined") {
      added.push(listIndex);
      ++addedCount;
    } else {
      maintained.push([prevListIndex, listIndex]);
      removedCount = removedMap[listIndex] || 0;
      changedBeforeAdded.push([prevListIndex - removedCount, listIndex - addedCount]);
      fixed.push(listIndex === prevListIndex);

      if (prevListIndex !== listIndex) {
        changed.push([prevListIndex, listIndex]);
      }
    }
  }); // Sort by ascending order of 'to(list's index).

  removed.reverse();
  return new Result(prevList, list, added, removed, changed, maintained, changedBeforeAdded, fixed);
}

/**
 * A module that checks diff when values are added, removed, or changed in an array.
 * @ko 배열 또는 오브젝트에서 값이 추가되거나 삭제되거나 순서가 변경사항을 체크하는 모듈입니다.
 * @memberof eg
 */

var ListDiffer =
/*#__PURE__*/
function () {
  /**
   * @param - Initializing Data Array. <ko> 초기 설정할 데이터 배열.</ko>
   * @param - This callback function returns the key of the item. <ko> 아이템의 키를 반환하는 콜백 함수입니다.</ko>
   * @example
   * import ListDiffer from "@egjs/list-differ";
   * // script => eg.ListDiffer
   * const differ = new ListDiffer([0, 1, 2, 3, 4, 5], e => e);
   * const result = differ.update([7, 8, 0, 4, 3, 6, 2, 1]);
   * // List before update
   * // [1, 2, 3, 4, 5]
   * console.log(result.prevList);
   * // Updated list
   * // [4, 3, 6, 2, 1]
   * console.log(result.list);
   * // Index array of values added to `list`.
   * // [0, 1, 5]
   * console.log(result.added);
   * // Index array of values removed in `prevList`.
   * // [5]
   * console.log(result.removed);
   * // An array of index pairs of `prevList` and `list` with different indexes from `prevList` and `list`.
   * // [[0, 2], [4, 3], [3, 4], [2, 6], [1, 7]]
   * console.log(result.changed);
   * // The subset of `changed` and an array of index pairs that moved data directly. Indicate an array of absolute index pairs of `ordered`.(Formatted by: Array<[index of prevList, index of list]>)
   * // [[4, 3], [3, 4], [2, 6]]
   * console.log(result.pureChanged);
   * // An array of index pairs to be `ordered` that can synchronize `list` before adding data. (Formatted by: Array<[prevIndex, nextIndex]>)
   * // [[4, 1], [4, 2], [4, 3]]
   * console.log(result.ordered);
   * // An array of index pairs of `prevList` and `list` that have not been added/removed so data is preserved.
   * // [[0, 2], [4, 3], [3, 4], [2, 6], [1, 7]]
   * console.log(result.maintained);
   */
  function ListDiffer(list, findKeyCallback) {
    if (list === void 0) {
      list = [];
    }

    this.findKeyCallback = findKeyCallback;
    this.list = [].slice.call(list);
  }
  /**
   * Update list.
   * @ko 리스트를 업데이트를 합니다.
   * @param - List to update <ko> 업데이트할 리스트 </ko>
   * @return - Returns the results of an update from `prevList` to `list`.<ko> `prevList`에서 `list`로 업데이트한 결과를 반환한다. </ko>
   */


  var __proto = ListDiffer.prototype;

  __proto.update = function (list) {
    var newData = [].slice.call(list);
    var result = diff(this.list, newData, this.findKeyCallback);
    this.list = newData;
    return result;
  };

  return ListDiffer;
}();

/*
Copyright (c) 2015 NAVER Corp.
name: @egjs/agent
license: MIT
author: NAVER Corp.
repository: git+https://github.com/naver/agent.git
version: 2.4.3
*/
function some(arr, callback) {
  var length = arr.length;

  for (var i = 0; i < length; ++i) {
    if (callback(arr[i], i)) {
      return true;
    }
  }

  return false;
}
function find(arr, callback) {
  var length = arr.length;

  for (var i = 0; i < length; ++i) {
    if (callback(arr[i], i)) {
      return arr[i];
    }
  }

  return null;
}
function getUserAgentString(agent) {
  var userAgent = agent;

  if (typeof userAgent === "undefined") {
    if (typeof navigator === "undefined" || !navigator) {
      return "";
    }

    userAgent = navigator.userAgent || "";
  }

  return userAgent.toLowerCase();
}
function execRegExp(pattern, text) {
  try {
    return new RegExp(pattern, "g").exec(text);
  } catch (e) {
    return null;
  }
}
function hasUserAgentData() {
  if (typeof navigator === "undefined" || !navigator || !navigator.userAgentData) {
    return false;
  }

  var userAgentData = navigator.userAgentData;
  var brands = userAgentData.brands || userAgentData.uaList;
  return !!(brands && brands.length);
}
function findVersion(versionTest, userAgent) {
  var result = execRegExp("(" + versionTest + ")((?:\\/|\\s|:)([0-9|\\.|_]+))", userAgent);
  return result ? result[3] : "";
}
function convertVersion(text) {
  return text.replace(/_/g, ".");
}
function findPreset(presets, userAgent) {
  var userPreset = null;
  var version = "-1";
  some(presets, function (preset) {
    var result = execRegExp("(" + preset.test + ")((?:\\/|\\s|:)([0-9|\\.|_]+))?", userAgent);

    if (!result || preset.brand) {
      return false;
    }

    userPreset = preset;
    version = result[3] || "-1";

    if (preset.versionAlias) {
      version = preset.versionAlias;
    } else if (preset.versionTest) {
      version = findVersion(preset.versionTest.toLowerCase(), userAgent) || version;
    }

    version = convertVersion(version);
    return true;
  });
  return {
    preset: userPreset,
    version: version
  };
}
function findPresetBrand(presets, brands) {
  var brandInfo = {
    brand: "",
    version: "-1"
  };
  some(presets, function (preset) {
    var result = findBrand(brands, preset);

    if (!result) {
      return false;
    }

    brandInfo.brand = preset.id;
    brandInfo.version = preset.versionAlias || result.version;
    return brandInfo.version !== "-1";
  });
  return brandInfo;
}
function findBrand(brands, preset) {
  return find(brands, function (_a) {
    var brand = _a.brand;
    return execRegExp("" + preset.test, brand.toLowerCase());
  });
}

var BROWSER_PRESETS = [{
  test: "phantomjs",
  id: "phantomjs"
}, {
  test: "whale",
  id: "whale"
}, {
  test: "edgios|edge|edg",
  id: "edge"
}, {
  test: "msie|trident|windows phone",
  id: "ie",
  versionTest: "iemobile|msie|rv"
}, {
  test: "miuibrowser",
  id: "miui browser"
}, {
  test: "samsungbrowser",
  id: "samsung internet"
}, {
  test: "samsung",
  id: "samsung internet",
  versionTest: "version"
}, {
  test: "chrome|crios",
  id: "chrome"
}, {
  test: "firefox|fxios",
  id: "firefox"
}, {
  test: "android",
  id: "android browser",
  versionTest: "version"
}, {
  test: "safari|iphone|ipad|ipod",
  id: "safari",
  versionTest: "version"
}]; // chromium's engine(blink) is based on applewebkit 537.36.

var CHROMIUM_PRESETS = [{
  test: "(?=.*applewebkit/(53[0-7]|5[0-2]|[0-4]))(?=.*\\schrome)",
  id: "chrome",
  versionTest: "chrome"
}, {
  test: "chromium",
  id: "chrome"
}, {
  test: "whale",
  id: "chrome",
  versionAlias: "-1",
  brand: true
}];
var WEBKIT_PRESETS = [{
  test: "applewebkit",
  id: "webkit",
  versionTest: "applewebkit|safari"
}];
var WEBVIEW_PRESETS = [{
  test: "(?=(iphone|ipad))(?!(.*version))",
  id: "webview"
}, {
  test: "(?=(android|iphone|ipad))(?=.*(naver|daum|; wv))",
  id: "webview"
}, {
  // test webview
  test: "webview",
  id: "webview"
}];
var OS_PRESETS = [{
  test: "windows phone",
  id: "windows phone"
}, {
  test: "windows 2000",
  id: "window",
  versionAlias: "5.0"
}, {
  test: "windows nt",
  id: "window"
}, {
  test: "win32|windows",
  id: "window"
}, {
  test: "iphone|ipad|ipod",
  id: "ios",
  versionTest: "iphone os|cpu os"
}, {
  test: "macos|macintel|mac os x",
  id: "mac"
}, {
  test: "android|linux armv81",
  id: "android"
}, {
  test: "tizen",
  id: "tizen"
}, {
  test: "webos|web0s",
  id: "webos"
}];

function isWebView(userAgent) {
  return !!findPreset(WEBVIEW_PRESETS, userAgent).preset;
}
function getLegacyAgent(userAgent) {
  var nextAgent = getUserAgentString(userAgent);
  var isMobile = !!/mobi/g.exec(nextAgent);
  var browser = {
    name: "unknown",
    version: "-1",
    majorVersion: -1,
    webview: isWebView(nextAgent),
    chromium: false,
    chromiumVersion: "-1",
    webkit: false,
    webkitVersion: "-1"
  };
  var os = {
    name: "unknown",
    version: "-1",
    majorVersion: -1
  };

  var _a = findPreset(BROWSER_PRESETS, nextAgent),
      browserPreset = _a.preset,
      browserVersion = _a.version;

  var _b = findPreset(OS_PRESETS, nextAgent),
      osPreset = _b.preset,
      osVersion = _b.version;

  var chromiumPreset = findPreset(CHROMIUM_PRESETS, nextAgent);
  browser.chromium = !!chromiumPreset.preset;
  browser.chromiumVersion = chromiumPreset.version;

  if (!browser.chromium) {
    var webkitPreset = findPreset(WEBKIT_PRESETS, nextAgent);
    browser.webkit = !!webkitPreset.preset;
    browser.webkitVersion = webkitPreset.version;
  }

  if (osPreset) {
    os.name = osPreset.id;
    os.version = osVersion;
    os.majorVersion = parseInt(osVersion, 10);
  }

  if (browserPreset) {
    browser.name = browserPreset.id;
    browser.version = browserVersion; // Early whale bugs

    if (browser.webview && os.name === "ios" && browser.name !== "safari") {
      browser.webview = false;
    }
  }

  browser.majorVersion = parseInt(browser.version, 10);
  return {
    browser: browser,
    os: os,
    isMobile: isMobile,
    isHints: false
  };
}

function getClientHintsAgent(osData) {
  var userAgentData = navigator.userAgentData;
  var brands = (userAgentData.uaList || userAgentData.brands).slice();
  var fullVersionList = osData && osData.fullVersionList;
  var isMobile = userAgentData.mobile || false;
  var firstBrand = brands[0];
  var platform = (osData && osData.platform || userAgentData.platform || navigator.platform).toLowerCase();
  var browser = {
    name: firstBrand.brand,
    version: firstBrand.version,
    majorVersion: -1,
    webkit: false,
    webkitVersion: "-1",
    chromium: false,
    chromiumVersion: "-1",
    webview: !!findPresetBrand(WEBVIEW_PRESETS, brands).brand || isWebView(getUserAgentString())
  };
  var os = {
    name: "unknown",
    version: "-1",
    majorVersion: -1
  };
  browser.webkit = !browser.chromium && some(WEBKIT_PRESETS, function (preset) {
    return findBrand(brands, preset);
  });
  var chromiumBrand = findPresetBrand(CHROMIUM_PRESETS, brands);
  browser.chromium = !!chromiumBrand.brand;
  browser.chromiumVersion = chromiumBrand.version;

  if (!browser.chromium) {
    var webkitBrand = findPresetBrand(WEBKIT_PRESETS, brands);
    browser.webkit = !!webkitBrand.brand;
    browser.webkitVersion = webkitBrand.version;
  }

  var platfomResult = find(OS_PRESETS, function (preset) {
    return new RegExp("" + preset.test, "g").exec(platform);
  });
  os.name = platfomResult ? platfomResult.id : "";

  if (osData) {
    os.version = osData.platformVersion;
  }

  if (fullVersionList && fullVersionList.length) {
    var browserBrandByFullVersionList = findPresetBrand(BROWSER_PRESETS, fullVersionList);
    browser.name = browserBrandByFullVersionList.brand || browser.name;
    browser.version = browserBrandByFullVersionList.version || browser.version;
  } else {
    var browserBrand = findPresetBrand(BROWSER_PRESETS, brands);
    browser.name = browserBrand.brand || browser.name;
    browser.version = browserBrand.brand && osData ? osData.uaFullVersion : browserBrand.version;
  }

  if (browser.webkit) {
    os.name = isMobile ? "ios" : "mac";
  }

  if (os.name === "ios" && browser.webview) {
    browser.version = "-1";
  }

  os.version = convertVersion(os.version);
  browser.version = convertVersion(browser.version);
  os.majorVersion = parseInt(os.version, 10);
  browser.majorVersion = parseInt(browser.version, 10);
  return {
    browser: browser,
    os: os,
    isMobile: isMobile,
    isHints: true
  };
}
/**
 * Extracts browser and operating system information from the user agent string.
 * @ko 유저 에이전트 문자열에서 브라우저와 운영체제 정보를 추출한다.
 * @function eg.agent#agent
 * @param - user agent string to parse <ko>파싱할 유저에이전트 문자열</ko>
 * @return - agent Info <ko> 에이전트 정보 </ko>
 * @example
import agent from "@egjs/agent";
// eg.agent();
const { os, browser, isMobile } = agent();
 */

function agent(userAgent) {
  if (typeof userAgent === "undefined" && hasUserAgentData()) {
    return getClientHintsAgent();
  } else {
    return getLegacyAgent(userAgent);
  }
}

/*
Copyright (c) 2022-present NAVER Corp.
name: @cfcs/core
license: MIT
author: NAVER Crop.
repository: https://github.com/naver/cfcs/tree/main/packages/core
version: 0.1.0
*/

/**
 * cfcs
 * Copyright (c) 2022-present NAVER Corp.
 * MIT license
 */

/**
 * @hidden
 */
function keys(obj) {
  return Object.keys(obj);
}

/**
 * cfcs
 * Copyright (c) 2022-present NAVER Corp.
 * MIT license
 */
var OBSERVERS_PATH = "__observers__";
var COMPUTED_PATH = "__computed__";
var CFCS_DETECTED_DEPENDENCIES_VERSION = 1;
var CFCS_DETECTED_DEPENDENCIES = "__CFCS_DETECTED_DEPENDENCIES__";

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

/* global Reflect, Promise */
var extendStatics = function (d, b) {
  extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
  };

  return extendStatics(d, b);
};

function __extends(d, b) {
  if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);

  function __() {
    this.constructor = d;
  }

  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

/**
 * cfcs
 * Copyright (c) 2022-present NAVER Corp.
 * MIT license
 */
function getDetectedStack() {
  // Version issues do not occur when you access the native object in the global.
  Object[CFCS_DETECTED_DEPENDENCIES] = Object[CFCS_DETECTED_DEPENDENCIES] || {};
  var versionList = Object[CFCS_DETECTED_DEPENDENCIES];
  versionList[CFCS_DETECTED_DEPENDENCIES_VERSION] = versionList[CFCS_DETECTED_DEPENDENCIES_VERSION] || [];
  return versionList[CFCS_DETECTED_DEPENDENCIES_VERSION];
}
function getCurrentDetected() {
  var stack = getDetectedStack();
  return stack[stack.length - 1];
}
function detectDependencies(host) {
  var stack = getDetectedStack();
  var observers = [];
  var detected = {
    host: host,
    observers: observers,
    push: function (observer) {
      if (host !== observer && observers.indexOf(observer) === -1) {
        observers.push(observer);
      }
    }
  };
  stack.push(detected);
  return detected;
}
function endDetectDependencies() {
  var stack = getDetectedStack();
  return stack.pop();
}

/**
 * cfcs
 * Copyright (c) 2022-present NAVER Corp.
 * MIT license
 */
/**
 * Creates a mutable ref object. You can access the `.current` value and detect the value change through `.subscribe`.
 * @category Reactive
 * @see observe
 */

var Observer =
/*#__PURE__*/
function () {
  /**
   *
   */
  function Observer(value) {
    this._emitter = new Component();
    this._current = value;
  }

  var __proto = Observer.prototype;
  Object.defineProperty(__proto, "current", {
    /**
     * return the current value.
     */
    get: function () {
      var currentDetected = getCurrentDetected();
      currentDetected === null || currentDetected === void 0 ? void 0 : currentDetected.push(this);
      return this._current;
    },
    set: function (value) {
      this._setCurrent(value);
    },
    enumerable: false,
    configurable: true
  });
  /**
   * When the current value changes, the callback function is called.
   */

  __proto.subscribe = function (callback) {
    this.current;

    this._emitter.on("update", callback);

    return this;
  };
  /**
   * Cancel the registered subscription through callback.
   */


  __proto.unsubscribe = function (callback) {
    this._emitter.off("update", callback);

    return this;
  };

  __proto._setCurrent = function (value) {
    var prevValue = this._current;
    var isUpdate = value !== prevValue;
    this._current = value;

    if (isUpdate) {
      this._emitter.trigger("update", value, prevValue);
    }
  };
  /**
   * @hidden
   */


  __proto.toString = function () {
    return "".concat(this.current);
  };
  /**
   * @hidden
   */


  __proto.valueOf = function () {
    return this.current;
  };

  return Observer;
}();

/**
 * @category Reactive
 * @hidden
 */

var ComputedObserver =
/*#__PURE__*/
function (_super) {
  __extends(ComputedObserver, _super);
  /**
   * @description Creates a new computed observer from the values of other observers.
   * It is read-only and if you change the value of the observer used inside the callback, its value will be automatically updated.
   * @param _computedCallback A function for observers to be computed.
   */


  function ComputedObserver(_computedCallback) {
    var _this = _super.call(this) || this;

    _this._computedCallback = _computedCallback;
    _this._registered = [];

    _this._onCheckUpdate = function () {
      _this._setCurrent(_this.current);
    };

    _this._current = _this.current;
    return _this;
  }

  var __proto = ComputedObserver.prototype;
  Object.defineProperty(__proto, "current", {
    get: function () {
      var _this = this;

      detectDependencies(this);

      var value = this._computedCallback();

      var results = endDetectDependencies();

      this._registered.forEach(function (observer) {
        observer.unsubscribe(_this._onCheckUpdate);
      });

      results.observers.forEach(function (observer) {
        observer.subscribe(_this._onCheckUpdate);
      });
      this._registered = results.observers;
      return value;
    },
    enumerable: false,
    configurable: true
  });
  return ComputedObserver;
}(Observer);

/**
 * cfcs
 * Copyright (c) 2022-present NAVER Corp.
 * MIT license
 */

function injectObserve(prototype, memberName, publicName) {
  if (publicName === void 0) {
    publicName = memberName;
  }

  var nextAttributes = {
    configurable: true,
    get: function () {
      return getObserver(this, publicName).current;
    },
    set: function (value) {
      getObserver(this, publicName, value).current = value;
    }
  };
  Object.defineProperty(prototype, memberName, nextAttributes);

  if (publicName !== memberName) {
    Object.defineProperty(prototype, publicName, {
      configurable: true,
      get: function () {
        return getObserver(this, publicName).current;
      }
    });
  }
}
/**
 * @description `Observe` is a property decorator and converts the property into a `reactive state`. You can detect its status through `.subscribe`.
 * @category Reactive-Decorator
 * @see ReactiveSubscribe
 * @example
* ```ts
import { ReactiveSubscribe, Observe } from "@cfcs/core";

@ReactiveSubscribe
class Component {
  // The public name and state name are the same.
  @Observe value1 = 1;
  // If you want to set public name and private properties separately
  @Observe("value2") _value2 = 1;

  constructor() {
    requestAnimationFrame(() => {
      this.value1 = 2;
    });
  }
}
interface C
```
 */


function Observe() {
  var args = [];

  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }

  if (args.length > 1) {
    return injectObserve(args[0], args[1]);
  }

  return function (prototype, memberName) {
    return injectObserve(prototype, memberName, args[0]);
  };
}

/**
 * cfcs
 * Copyright (c) 2022-present NAVER Corp.
 * MIT license
 */
/**
 * @hidden
 */

function injectReactiveSubscribe(object) {
  object["subscribe"] = function (name, callback) {
    this[name];
    getObserver(this, name).subscribe(callback);
  };

  object["unsubscribe"] = function (name, callback) {
    var _this = this;

    if (!name) {
      keys(getObservers(this)).forEach(function (observerName) {
        _this.unsubscribe(observerName);
      });
      return;
    }

    if (!(name in this)) {
      return;
    }

    getObserver(this, name).unsubscribe(callback);
  };
}
/**
 * @description `ReactiveSubscribe` is a class decorator and adds `.subscribe` and `.unsubscribe` methods.
 * @category Reactive-Decorator
 * @see Observe
 * @example
 * ```ts
import { ReactiveSubscribe, Observe } from "@cfcs/core";

@ReactiveSubscribe
class Component {
  @Observe value1 = 1;

  constructor() {
    requestAnimationFrame(() => {
      this.value1 = 2;
    });
  }
}

interface Component extends ReactiveSubscribe<{
  value1: number;
  value2: number;
}> {}

const component = new Component();

// 1
console.log(component.value1);

component.subscribe("value1", nextValue => {
  // When the change event occurs => (2, 2)
  console.log(nextValue, component.value2);
});
```
 */

function ReactiveSubscribe(Constructor) {
  var prototype = Constructor.prototype;
  injectReactiveSubscribe(prototype);
}
/**
 * @description Creates a mutable ref object. You can access the `.current` value and detect the value change through `.subscribe`.
 * @category Reactive
 * @example
 * ```ts
 * import { observe } from "@cfcs/core";
 *
 * const ob1 = observe(1);
 *
 * ob1.subscribe(nextValue => {
 *   console.log(nextValue);
 * });
 *
 * ob1.current = 2;
 * ```
 */

function observe(defaultValue) {
  return new Observer(defaultValue);
}
/**
 * @hidden
 */

function computed(computedCallback) {
  return new ComputedObserver(computedCallback);
}
/**
 * @hidden
 */

function defineObservers(instance) {
  var observers = {};
  Object.defineProperty(instance, OBSERVERS_PATH, {
    get: function () {
      return observers;
    }
  });
  return observers;
}
/**
 * @hidden
 */

function getObservers(instance, isComputed) {
  var _a, _b;

  if (!instance[OBSERVERS_PATH]) {
    defineObservers(instance);
  }

  var observers = instance[OBSERVERS_PATH];

  if (!isComputed) {
    var computedList = (_b = (_a = instance === null || instance === void 0 ? void 0 : instance.constructor) === null || _a === void 0 ? void 0 : _a.prototype) === null || _b === void 0 ? void 0 : _b[COMPUTED_PATH];

    if (computedList) {
      computedList.forEach(function (name) {
        if (!(name in observers) && name in instance) {
          instance[name];
        }
      });
    }
  }

  return observers;
}
/**
 * @hidden
 */

function getObserver(instance, name, defaultValue) {
  var observers = getObservers(instance);

  if (!observers[name]) {
    observers[name] = observe(defaultValue);
  }

  return observers[name];
}

/**
 * cfcs
 * Copyright (c) 2022-present NAVER Corp.
 * MIT license
 */
/**
 * @description `Computed` is a property decorator.
 * Changes in computed state values are also recognized according to changes in observers used within the getter function.
 * You can detect its status through `.subscribe`.
 * @hidden
 * @category Reactive-Decorator
 * @see ReactiveSubscribe
 * @example
 * ```ts
const ob1 = observe(0);
const ob2 = observe(1);

// When
@ReactiveSubscribe
class TestComputed {
  @Computed
  get ob3() {
    return ob1.current + ob2.current;
  }
}
const inst = new TestComputed();

inst.subscribe("ob3", ob3 => {
  console.log(ob3);
});

ob1.current = 1;
```
 */

function Computed(prototype, memberName, attributes) {
  var get = attributes.get;

  function getComputed() {
    var observers = getObservers(this, true);

    if (!(memberName in observers)) {
      observers[memberName] = computed(get.bind(this));
    }

    return getObserver(this, memberName).current;
  }

  var nextAttributes = {
    configurable: true,
    get: getComputed
  };
  prototype[COMPUTED_PATH] || (prototype[COMPUTED_PATH] = []);
  var computedList = prototype[COMPUTED_PATH];

  if (computedList.indexOf(memberName) === -1) {
    computedList.push(memberName);
  }

  Object.defineProperty(prototype, memberName, nextAttributes);
  return nextAttributes;
}

/*
Copyright (c) NAVER Corp.
name: @egjs/axes
license: MIT
author: NAVER Corp.
repository: https://github.com/naver/egjs-axes
version: 3.9.1
*/

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics$1 = function (d, b) {
  extendStatics$1 = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
  };
  return extendStatics$1(d, b);
};
function __extends$1(d, b) {
  extendStatics$1(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function () {
  __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __decorate(decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}

/*
 * Copyright (c) 2015 NAVER Corp.
 * egjs projects are licensed under the MIT license
 */
/* eslint-disable no-new-func, no-nested-ternary */
var win;
if (typeof window === "undefined") {
  // window is undefined in node.js
  win = {
    navigator: {
      userAgent: ""
    }
  };
} else {
  win = window;
}

/*
 * Copyright (c) 2015 NAVER Corp.
 * egjs projects are licensed under the MIT license
 */
var DIRECTION_NONE = 1;
var DIRECTION_LEFT = 2;
var DIRECTION_RIGHT = 4;
var DIRECTION_HORIZONTAL = 2 | 4;
var DIRECTION_UP = 8;
var DIRECTION_DOWN = 16;
var DIRECTION_VERTICAL = 8 | 16;
var DIRECTION_ALL = 2 | 4 | 8 | 16;
var MOUSE_LEFT = "left";
var MOUSE_RIGHT = "right";
var MOUSE_MIDDLE = "middle";
var MOUSE_BUTTON_CODE_MAP = {
  1: MOUSE_LEFT,
  2: MOUSE_MIDDLE,
  3: MOUSE_RIGHT
};
var ANY = "any";
var NONE = "none";
var SHIFT = "shift";
var CTRL = "ctrl";
var ALT = "alt";
var META = "meta";
var VELOCITY_INTERVAL = 16;
var IOS_EDGE_THRESHOLD = 30;
var IS_IOS_SAFARI = "ontouchstart" in win && agent().browser.name === "safari";
var TRANSFORM = function () {
  if (typeof document === "undefined") {
    return "";
  }
  var bodyStyle = (document.head || document.getElementsByTagName("head")[0]).style;
  var target = ["transform", "webkitTransform", "msTransform", "mozTransform"];
  for (var i = 0, len = target.length; i < len; i++) {
    if (target[i] in bodyStyle) {
      return target[i];
    }
  }
  return "";
}();
var PREVENT_DRAG_CSSPROPS = {
  "-webkit-user-select": "none",
  "-ms-user-select": "none",
  "-moz-user-select": "none",
  "user-select": "none",
  "-webkit-user-drag": "none"
};

var toArray = function (nodes) {
  // const el = Array.prototype.slice.call(nodes);
  // for IE8
  var el = [];
  for (var i = 0, len = nodes.length; i < len; i++) {
    el.push(nodes[i]);
  }
  return el;
};
var $$1 = function (param, multi) {
  if (multi === void 0) {
    multi = false;
  }
  var el;
  if (typeof param === "string") {
    // String (HTML, Selector)
    // check if string is HTML tag format
    var match = param.match(/^<([a-z]+)\s*([^>]*)>/);
    // creating element
    if (match) {
      // HTML
      var dummy = document.createElement("div");
      dummy.innerHTML = param;
      el = toArray(dummy.childNodes);
    } else {
      // Selector
      el = toArray(document.querySelectorAll(param));
    }
    if (!multi) {
      el = el.length >= 1 ? el[0] : undefined;
    }
  } else if (param === win) {
    // window
    el = param;
  } else if ("value" in param || "current" in param) {
    el = param.value || param.current;
  } else if (param.nodeName && (param.nodeType === 1 || param.nodeType === 9)) {
    // HTMLElement, Document
    el = param;
  } else if ("jQuery" in win && param instanceof jQuery || param.constructor.prototype.jquery) {
    // jQuery
    el = multi ? param.toArray() : param.get(0);
  } else if (Array.isArray(param)) {
    el = param.map(function (v) {
      return $$1(v);
    });
    if (!multi) {
      el = el.length >= 1 ? el[0] : undefined;
    }
  }
  return el;
};
var raf = win.requestAnimationFrame || win.webkitRequestAnimationFrame;
var caf = win.cancelAnimationFrame || win.webkitCancelAnimationFrame;
if (raf && !caf) {
  var keyInfo_1 = {};
  var oldraf_1 = raf;
  raf = function (callback) {
    var wrapCallback = function (timestamp) {
      if (keyInfo_1[key]) {
        callback(timestamp);
      }
    };
    var key = oldraf_1(wrapCallback);
    keyInfo_1[key] = true;
    return key;
  };
  caf = function (key) {
    delete keyInfo_1[key];
  };
} else if (!(raf && caf)) {
  raf = function (callback) {
    return win.setTimeout(function () {
      callback(win.performance && win.performance.now && win.performance.now() || new Date().getTime());
    }, 16);
  };
  caf = win.clearTimeout;
}
/**
 * A polyfill for the window.requestAnimationFrame() method.
 * @see  https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame
 * @private
 */
var requestAnimationFrame$1 = function (fp) {
  return raf(fp);
};
/**
 * A polyfill for the window.cancelAnimationFrame() method. It cancels an animation executed through a call to the requestAnimationFrame() method.
 * @param {Number} key −  The ID value returned through a call to the requestAnimationFrame() method. <ko>requestAnimationFrame() 메서드가 반환한 아이디 값</ko>
 * @see  https://developer.mozilla.org/en-US/docs/Web/API/Window/cancelAnimationFrame
 * @private
 */
var cancelAnimationFrame$1 = function (key) {
  caf(key);
};
var map = function (obj, callback) {
  var tranformed = {};
  for (var k in obj) {
    if (k) {
      tranformed[k] = callback(obj[k], k);
    }
  }
  return tranformed;
};
var filter = function (obj, callback) {
  var filtered = {};
  for (var k in obj) {
    if (k && callback(obj[k], k)) {
      filtered[k] = obj[k];
    }
  }
  return filtered;
};
var every = function (obj, callback) {
  for (var k in obj) {
    if (k && !callback(obj[k], k)) {
      return false;
    }
  }
  return true;
};
var equal = function (target, base) {
  return every(target, function (v, k) {
    return v === base[k];
  });
};
var roundNumFunc = {};
var roundNumber = function (num, roundUnit) {
  // Cache for performance
  if (!roundNumFunc[roundUnit]) {
    roundNumFunc[roundUnit] = getRoundFunc(roundUnit);
  }
  return roundNumFunc[roundUnit](num);
};
var roundNumbers = function (num, roundUnit) {
  if (!num || !roundUnit) {
    return num;
  }
  return map(num, function (value, key) {
    return roundNumber(value, typeof roundUnit === "number" ? roundUnit : roundUnit[key]);
  });
};
var getDecimalPlace = function (val) {
  if (!isFinite(val)) {
    return 0;
  }
  var v = "".concat(val);
  if (v.indexOf("e") >= 0) {
    // Exponential Format
    // 1e-10, 1e-12
    var p = 0;
    var e = 1;
    while (Math.round(val * e) / e !== val) {
      e *= 10;
      p++;
    }
    return p;
  }
  // In general, following has performance benefit.
  // https://jsperf.com/precision-calculation
  return v.indexOf(".") >= 0 ? v.length - v.indexOf(".") - 1 : 0;
};
var inversePow = function (n) {
  // replace Math.pow(10, -n) to solve floating point issue.
  // eg. Math.pow(10, -4) => 0.00009999999999999999
  return 1 / Math.pow(10, n);
};
var getRoundFunc = function (v) {
  var p = v < 1 ? Math.pow(10, getDecimalPlace(v)) : 1;
  return function (n) {
    if (v === 0) {
      return 0;
    }
    return Math.round(Math.round(n / v) * v * p) / p;
  };
};
var getAngle = function (posX, posY) {
  return Math.atan2(posY, posX) * 180 / Math.PI;
};
var isCssPropsFromAxes = function (originalCssProps) {
  var same = true;
  Object.keys(PREVENT_DRAG_CSSPROPS).forEach(function (prop) {
    if (!originalCssProps || originalCssProps[prop] !== PREVENT_DRAG_CSSPROPS[prop]) {
      same = false;
    }
  });
  return same;
};
var getDirection = function (useHorizontal, useVertical) {
  if (useHorizontal && useVertical) {
    return DIRECTION_ALL;
  } else if (useHorizontal) {
    return DIRECTION_HORIZONTAL;
  } else if (useVertical) {
    return DIRECTION_VERTICAL;
  } else {
    return DIRECTION_NONE;
  }
};
var useDirection = function (checkType, direction, userDirection) {
  if (userDirection) {
    return !!(direction === DIRECTION_ALL || direction & checkType && userDirection & checkType);
  } else {
    return !!(direction & checkType);
  }
};
var setCssProps = function (element, option, direction) {
  var _a;
  var touchActionMap = (_a = {}, _a[DIRECTION_NONE] = "auto", _a[DIRECTION_ALL] = "none", _a[DIRECTION_VERTICAL] = "pan-x", _a[DIRECTION_HORIZONTAL] = "pan-y", _a);
  var oldCssProps = {};
  if (element && element.style) {
    var touchAction = option.touchAction ? option.touchAction : touchActionMap[direction];
    var newCssProps_1 = __assign(__assign({}, PREVENT_DRAG_CSSPROPS), {
      "touch-action": element.style["touch-action"] === "none" ? "none" : touchAction
    });
    Object.keys(newCssProps_1).forEach(function (prop) {
      oldCssProps[prop] = element.style[prop];
    });
    // Old style props like user-select can be corrupted if you change the style directly in the logic above.
    Object.keys(newCssProps_1).forEach(function (prop) {
      element.style[prop] = newCssProps_1[prop];
    });
  }
  return oldCssProps;
};
var revertCssProps = function (element, originalCssProps) {
  if (element && element.style && originalCssProps) {
    Object.keys(originalCssProps).forEach(function (prop) {
      element.style[prop] = originalCssProps[prop];
    });
  }
  return;
};

var EventManager = /*#__PURE__*/function () {
  function EventManager(_axes) {
    this._axes = _axes;
    this.holdingCount = 0;
  }
  /**
   * This event is fired when a user holds an element on the screen of the device.
   * @ko 사용자가 기기의 화면에 손을 대고 있을 때 발생하는 이벤트
   * @event Axes#hold
   * @type {object}
   * @property {Object.<string, number>} pos coordinate <ko>좌표 정보</ko>
   * @property {Object} input The instance of inputType where the event occurred<ko>이벤트가 발생한 inputType 인스턴스</ko>
   * @property {Object} inputEvent The event object received from inputType <ko>inputType으로 부터 받은 이벤트 객체</ko>
   * @property {Boolean} isTrusted Returns true if an event was generated by the user action, or false if it was caused by a script or API call <ko>사용자의 액션에 의해 이벤트가 발생하였으면 true, 스크립트나 API호출에 의해 발생하였을 경우에는 false를 반환한다.</ko>
   *
   * @example
   * ```js
   * const axes = new eg.Axes({
   *   "x": {
   *      range: [0, 100]
   *   },
   *   "zoom": {
   *      range: [50, 30]
   *   }
   * }).on("hold", function(event) {
   *   // event.pos
   *   // event.input
   *   // event.inputEvent
   *   // isTrusted
   * });
   * ```
   */
  var __proto = EventManager.prototype;
  __proto.hold = function (pos, option) {
    var roundPos = this._getRoundPos(pos).roundPos;
    this._axes.trigger(new ComponentEvent$1("hold", {
      pos: roundPos,
      input: option.input || null,
      inputEvent: option.event || null,
      isTrusted: true
    }));
  };
  /**
   * Specifies the coordinates to move after the 'change' event. It works when the holding value of the change event is true.
   * @ko 'change' 이벤트 이후 이동할 좌표를 지정한다. change이벤트의 holding 값이 true일 경우에 동작한다
   * @param {Object.<string, number>} pos The coordinate to move to <ko>이동할 좌표</ko>
   * @example
   * ```js
   * const axes = new eg.Axes({
   *   "x": {
   *      range: [0, 100]
   *   },
   *   "zoom": {
   *      range: [50, 30]
   *   }
   * }).on("change", function(event) {
   *   event.holding && event.set({x: 10});
   * });
   * ```
   */
  /** Specifies the animation coordinates to move after the 'release' or 'animationStart' events.
   * @ko 'release' 또는 'animationStart' 이벤트 이후 이동할 좌표를 지정한다.
   * @param {Object.<string, number>} pos The coordinate to move to <ko>이동할 좌표</ko>
   * @param {Number} [duration=0] Duration of the animation (unit: ms) <ko>애니메이션 진행 시간(단위: ms)</ko>
   * @example
   * ```js
   * const axes = new eg.Axes({
   *   "x": {
   *      range: [0, 100]
   *   },
   *   "zoom": {
   *      range: [50, 30]
   *   }
   * }).on("animationStart", function(event) {
   *   event.setTo({x: 10}, 2000);
   * });
   * ```
   */
  /**
   * This event is fired when a user release an element on the screen of the device.
   * @ko 사용자가 기기의 화면에서 손을 뗐을 때 발생하는 이벤트
   * @event Axes#release
   * @type {object}
   * @property {Object.<string, number>} depaPos The coordinates when releasing an element<ko>손을 뗐을 때의 좌표 </ko>
   * @property {Object.<string, number>} destPos The coordinates to move to after releasing an element<ko>손을 뗀 뒤에 이동할 좌표</ko>
   * @property {Object.<string, number>} delta  The movement variation of coordinate <ko>좌표의 변화량</ko>
   * @property {Object.<string, number>} bounceRatio If the coordinates at the time of release are in the bounce area, the current bounce value divided by the maximum bounce value <ko>손을 뗐을 때의 좌표가 bounce 영역에 있는 경우 현재 bounce된 값을 최대 bounce 값으로 나눈 수치.</ko>
   * @property {Object} inputEvent The event object received from inputType <ko>inputType으로 부터 받은 이벤트 객체</ko>
   * @property {Object} input The instance of inputType where the event occurred<ko>이벤트가 발생한 inputType 인스턴스</ko>
   * @property {setTo} setTo Specifies the animation coordinates to move after the event <ko>이벤트 이후 이동할 애니메이션 좌표를 지정한다</ko>
   * @property {Boolean} isTrusted Returns true if an event was generated by the user action, or false if it was caused by a script or API call <ko>사용자의 액션에 의해 이벤트가 발생하였으면 true, 스크립트나 API호출에 의해 발생하였을 경우에는 false를 반환한다.</ko>
   *
   * @example
   * ```js
   * const axes = new eg.Axes({
   *   "x": {
   *      range: [0, 100]
   *   },
   *   "zoom": {
   *      range: [50, 30]
   *   }
   * }).on("release", function(event) {
   *   // event.depaPos
   *   // event.destPos
   *   // event.delta
   *   // event.input
   *   // event.inputEvent
   *   // event.setTo
   *   // event.isTrusted
   *
   *   // if you want to change the animation coordinates to move after the 'release' event.
   *   event.setTo({x: 10}, 2000);
   * });
   * ```
   */
  __proto.triggerRelease = function (param) {
    var _a = this._getRoundPos(param.destPos, param.depaPos),
      roundPos = _a.roundPos,
      roundDepa = _a.roundDepa;
    param.destPos = roundPos;
    param.depaPos = roundDepa;
    param.setTo = this._createUserControll(param.destPos, param.duration);
    this._axes.trigger(new ComponentEvent$1("release", __assign(__assign({}, param), {
      bounceRatio: this._getBounceRatio(roundPos)
    })));
  };
  /**
   * This event is fired when coordinate changes.
   * @ko 좌표가 변경됐을 때 발생하는 이벤트
   * @event Axes#change
   * @type {object}
   * @property {Object.<string, number>} pos  The coordinate <ko>좌표</ko>
   * @property {Object.<string, number>} delta  The movement variation of coordinate <ko>좌표의 변화량</ko>
   * @property {Object.<string, number>} bounceRatio If the current coordinates are in the bounce area, the current bounce value divided by the maximum bounce value <ko>현재 좌표가 bounce 영역에 있는 경우 현재 bounce된 값을 최대 bounce 값으로 나눈 수치.</ko>
   * @property {Boolean} holding Indicates whether a user holds an element on the screen of the device.<ko>사용자가 기기의 화면을 누르고 있는지 여부</ko>
   * @property {Object} input The instance of inputType where the event occurred. If the value is changed by animation, it returns 'null'.<ko>이벤트가 발생한 inputType 인스턴스. 애니메이션에 의해 값이 변경될 경우에는 'null'을 반환한다.</ko>
   * @property {Object} inputEvent The event object received from inputType. If the value is changed by animation, it returns 'null'.<ko>inputType으로 부터 받은 이벤트 객체. 애니메이션에 의해 값이 변경될 경우에는 'null'을 반환한다.</ko>
   * @property {set} set Specifies the coordinates to move after the event. It works when the holding value is true <ko>이벤트 이후 이동할 좌표를 지정한다. holding 값이 true일 경우에 동작한다.</ko>
   * @property {Boolean} isTrusted Returns true if an event was generated by the user action, or false if it was caused by a script or API call <ko>사용자의 액션에 의해 이벤트가 발생하였으면 true, 스크립트나 API호출에 의해 발생하였을 경우에는 false를 반환한다.</ko>
   *
   * @example
   * ```js
   * const axes = new eg.Axes({
   *   "x": {
   *      range: [0, 100]
   *   },
   *   "zoom": {
   *      range: [50, 30]
   *   }
   * }).on("change", function(event) {
   *   // event.pos
   *   // event.delta
   *   // event.input
   *   // event.inputEvent
   *   // event.holding
   *   // event.set
   *   // event.isTrusted
   *
   *   // if you want to change the coordinates to move after the 'change' event.
   *   // it works when the holding value of the change event is true.
   *   event.holding && event.set({x: 10});
   * });
   * ```
   */
  __proto.triggerChange = function (pos, depaPos, option, holding) {
    var _this = this;
    if (holding === void 0) {
      holding = false;
    }
    var animationManager = this.animationManager;
    var axisManager = animationManager.axisManager;
    var eventInfo = animationManager.getEventInfo();
    var _a = this._getRoundPos(pos, depaPos),
      roundPos = _a.roundPos,
      roundDepa = _a.roundDepa;
    var moveTo = axisManager.moveTo(roundPos, roundDepa);
    var inputEvent = (option === null || option === void 0 ? void 0 : option.event) || (eventInfo === null || eventInfo === void 0 ? void 0 : eventInfo.event) || null;
    var param = {
      pos: moveTo.pos,
      delta: moveTo.delta,
      bounceRatio: this._getBounceRatio(moveTo.pos),
      holding: holding,
      inputEvent: inputEvent,
      isTrusted: !!inputEvent,
      input: (option === null || option === void 0 ? void 0 : option.input) || (eventInfo === null || eventInfo === void 0 ? void 0 : eventInfo.input) || null,
      set: inputEvent ? this._createUserControll(moveTo.pos) : function () {} // eslint-disable-line @typescript-eslint/no-empty-function
    };

    var event = new ComponentEvent$1("change", param);
    this._axes.trigger(event);
    Object.keys(moveTo.pos).forEach(function (axis) {
      var p = moveTo.pos[axis];
      getObserver(_this._axes, axis, p).current = p;
    });
    if (inputEvent) {
      axisManager.set(param.set().destPos);
    }
    return !event.isCanceled();
  };
  /**
   * This event is fired when animation starts.
   * @ko 에니메이션이 시작할 때 발생한다.
   * @event Axes#animationStart
   * @type {object}
   * @property {Object.<string, number>} depaPos The coordinates when animation starts<ko>애니메이션이 시작 되었을 때의 좌표 </ko>
   * @property {Object.<string, number>} destPos The coordinates to move to. If you change this value, you can run the animation<ko>이동할 좌표. 이값을 변경하여 애니메이션을 동작시킬수 있다</ko>
   * @property {Object.<string, number>} delta  The movement variation of coordinate <ko>좌표의 변화량</ko>
   * @property {Number} duration Duration of the animation (unit: ms). If you change this value, you can control the animation duration time.<ko>애니메이션 진행 시간(단위: ms). 이값을 변경하여 애니메이션의 이동시간을 조절할 수 있다.</ko>
   * @property {Object} input The instance of inputType where the event occurred. If the value is changed by animation, it returns 'null'.<ko>이벤트가 발생한 inputType 인스턴스. 애니메이션에 의해 값이 변경될 경우에는 'null'을 반환한다.</ko>
   * @property {Object} inputEvent The event object received from inputType <ko>inputType으로 부터 받은 이벤트 객체</ko>
   * @property {setTo} setTo Specifies the animation coordinates to move after the event <ko>이벤트 이후 이동할 애니메이션 좌표를 지정한다</ko>
   * @property {Boolean} isTrusted Returns true if an event was generated by the user action, or false if it was caused by a script or API call <ko>사용자의 액션에 의해 이벤트가 발생하였으면 true, 스크립트나 API호출에 의해 발생하였을 경우에는 false를 반환한다.</ko>
   *
   * @example
   * ```js
   * const axes = new eg.Axes({
   *   "x": {
   *      range: [0, 100]
   *   },
   *   "zoom": {
   *      range: [50, 30]
   *   }
   * }).on("release", function(event) {
   *   // event.depaPos
   *   // event.destPos
   *   // event.delta
   *   // event.input
   *   // event.inputEvent
   *   // event.setTo
   *   // event.isTrusted
   *
   *   // if you want to change the animation coordinates to move after the 'animationStart' event.
   *   event.setTo({x: 10}, 2000);
   * });
   * ```
   */
  __proto.triggerAnimationStart = function (param) {
    var _a = this._getRoundPos(param.destPos, param.depaPos),
      roundPos = _a.roundPos,
      roundDepa = _a.roundDepa;
    param.destPos = roundPos;
    param.depaPos = roundDepa;
    param.setTo = this._createUserControll(param.destPos, param.duration);
    var event = new ComponentEvent$1("animationStart", param);
    this._axes.trigger(event);
    return !event.isCanceled();
  };
  /**
   * This event is fired when animation ends.
   * @ko 에니메이션이 끝났을 때 발생한다.
   * @event Axes#animationEnd
   * @type {object}
   * @property {Boolean} isTrusted Returns true if an event was generated by the user action, or false if it was caused by a script or API call <ko>사용자의 액션에 의해 이벤트가 발생하였으면 true, 스크립트나 API호출에 의해 발생하였을 경우에는 false를 반환한다.</ko>
   *
   * @example
   * ```js
   * const axes = new eg.Axes({
   *   "x": {
   *      range: [0, 100]
   *   },
   *   "zoom": {
   *      range: [50, 30]
   *   }
   * }).on("animationEnd", function(event) {
   *   // event.isTrusted
   * });
   * ```
   */
  __proto.triggerAnimationEnd = function (isTrusted) {
    if (isTrusted === void 0) {
      isTrusted = false;
    }
    this._axes.trigger(new ComponentEvent$1("animationEnd", {
      isTrusted: isTrusted
    }));
  };
  /**
   * This event is fired when all actions have been completed.
   * @ko 에니메이션이 끝났을 때 발생한다.
   * @event Axes#finish
   * @type {object}
   * @property {Boolean} isTrusted Returns true if an event was generated by the user action, or false if it was caused by a script or API call <ko>사용자의 액션에 의해 이벤트가 발생하였으면 true, 스크립트나 API호출에 의해 발생하였을 경우에는 false를 반환한다.</ko>
   *
   * @example
   * ```js
   * const axes = new eg.Axes({
   *   "x": {
   *      range: [0, 100]
   *   },
   *   "zoom": {
   *      range: [50, 30]
   *   }
   * }).on("finish", function(event) {
   *   // event.isTrusted
   * });
   * ```
   */
  __proto.triggerFinish = function (isTrusted) {
    if (isTrusted === void 0) {
      isTrusted = false;
    }
    this._axes.trigger(new ComponentEvent$1("finish", {
      isTrusted: isTrusted
    }));
  };
  __proto.setAnimationManager = function (animationManager) {
    this.animationManager = animationManager;
  };
  __proto.destroy = function () {
    this._axes.off();
  };
  __proto._createUserControll = function (pos, duration) {
    if (duration === void 0) {
      duration = 0;
    }
    // to controll
    var userControl = {
      destPos: __assign({}, pos),
      duration: duration
    };
    return function (toPos, userDuration) {
      if (toPos) {
        userControl.destPos = __assign({}, toPos);
      }
      if (userDuration !== undefined) {
        userControl.duration = userDuration;
      }
      return userControl;
    };
  };
  __proto._getRoundPos = function (pos, depaPos) {
    // round value if round exist
    var roundUnit = this._axes.options.round;
    // if (round == null) {
    //   return {pos, depaPos}; // undefined, undefined
    // }
    return {
      roundPos: roundNumbers(pos, roundUnit),
      roundDepa: roundNumbers(depaPos, roundUnit)
    };
  };
  __proto._getBounceRatio = function (pos) {
    return this._axes.axisManager.map(pos, function (v, opt) {
      if (v < opt.range[0] && opt.bounce[0] !== 0) {
        return (opt.range[0] - v) / opt.bounce[0];
      } else if (v > opt.range[1] && opt.bounce[1] !== 0) {
        return (v - opt.range[1]) / opt.bounce[1];
      } else {
        return 0;
      }
    });
  };
  __decorate([Observe], EventManager.prototype, "holdingCount", void 0);
  return EventManager;
}();

var InterruptManager = /*#__PURE__*/function () {
  function InterruptManager(_options) {
    this._options = _options;
    this._prevented = false; //  check whether the animation event was prevented
  }
  var __proto = InterruptManager.prototype;
  __proto.isInterrupting = function () {
    // when interruptable is 'true', return value is always 'true'.
    return this._options.interruptable || this._prevented;
  };
  __proto.isInterrupted = function () {
    return !this._options.interruptable && this._prevented;
  };
  __proto.setInterrupt = function (prevented) {
    if (!this._options.interruptable) {
      this._prevented = prevented;
    }
  };
  return InterruptManager;
}();

/*
 * Copyright (c) 2015 NAVER Corp.
 * egjs projects are licensed under the MIT license
 */
var getInsidePosition = function (destPos, range, circular, bounce) {
  var toDestPos = destPos;
  var targetRange = [circular[0] ? range[0] : bounce ? range[0] - bounce[0] : range[0], circular[1] ? range[1] : bounce ? range[1] + bounce[1] : range[1]];
  toDestPos = Math.max(targetRange[0], toDestPos);
  toDestPos = Math.min(targetRange[1], toDestPos);
  return toDestPos;
};
// determine outside
var isOutside = function (pos, range) {
  return pos < range[0] || pos > range[1];
};
// determine whether position has reached the maximum moveable area
var isEndofBounce = function (pos, range, bounce, circular) {
  return !circular[0] && pos === range[0] - bounce[0] || !circular[1] && pos === range[1] + bounce[1];
};
var getDuration = function (distance, deceleration) {
  var duration = Math.sqrt(distance / deceleration * 2);
  // when duration is under 100, then value is zero
  return duration < 100 ? 0 : duration;
};
var isCircularable = function (destPos, range, circular) {
  return circular[1] && destPos > range[1] || circular[0] && destPos < range[0];
};
var getCirculatedPos = function (pos, range, circular) {
  var toPos = pos;
  var min = range[0];
  var max = range[1];
  var length = max - min;
  if (circular[1] && pos > max) {
    // right
    toPos = (toPos - max) % length + min;
  }
  if (circular[0] && pos < min) {
    // left
    toPos = (toPos - min) % length + max;
  }
  return toPos;
};

var AxisManager = /*#__PURE__*/function () {
  function AxisManager(_axis) {
    var _this = this;
    this._axis = _axis;
    this._complementOptions();
    this._pos = Object.keys(this._axis).reduce(function (pos, v) {
      pos[v] = _this._axis[v].startPos;
      return pos;
    }, {});
  }
  var __proto = AxisManager.prototype;
  __proto.getDelta = function (depaPos, destPos) {
    var fullDepaPos = this.get(depaPos);
    return map(this.get(destPos), function (v, k) {
      return v - fullDepaPos[k];
    });
  };
  __proto.get = function (axes) {
    var _this = this;
    if (axes && Array.isArray(axes)) {
      return axes.reduce(function (acc, v) {
        if (v && v in _this._pos) {
          acc[v] = _this._pos[v];
        }
        return acc;
      }, {});
    } else {
      return __assign(__assign({}, this._pos), axes || {});
    }
  };
  __proto.moveTo = function (pos, depaPos) {
    if (depaPos === void 0) {
      depaPos = this._pos;
    }
    var delta = map(this._pos, function (v, key) {
      return key in pos && key in depaPos ? pos[key] - depaPos[key] : 0;
    });
    this.set(this.map(pos, function (v, opt) {
      return opt ? getCirculatedPos(v, opt.range, opt.circular) : 0;
    }));
    return {
      pos: __assign({}, this._pos),
      delta: delta
    };
  };
  __proto.set = function (pos) {
    for (var k in pos) {
      if (k && k in this._pos) {
        this._pos[k] = pos[k];
      }
    }
  };
  __proto.every = function (pos, callback) {
    var axisOptions = this._axis;
    return every(pos, function (value, key) {
      return callback(value, axisOptions[key], key);
    });
  };
  __proto.filter = function (pos, callback) {
    var axisOptions = this._axis;
    return filter(pos, function (value, key) {
      return callback(value, axisOptions[key], key);
    });
  };
  __proto.map = function (pos, callback) {
    var axisOptions = this._axis;
    return map(pos, function (value, key) {
      return callback(value, axisOptions[key], key);
    });
  };
  __proto.isOutside = function (axes) {
    return !this.every(axes ? this.get(axes) : this._pos, function (v, opt) {
      return !isOutside(v, opt.range);
    });
  };
  __proto.getAxisOptions = function (key) {
    return this._axis[key];
  };
  __proto.setAxis = function (axis) {
    var _this = this;
    Object.keys(axis).forEach(function (key) {
      if (!_this._axis[key]) {
        throw new Error("Axis ".concat(key, " does not exist in Axes instance"));
      }
      _this._axis[key] = __assign(__assign({}, _this._axis[key]), axis[key]);
    });
    this._complementOptions();
  };
  /**
   * set up 'css' expression
   * @private
   */
  __proto._complementOptions = function () {
    var _this = this;
    Object.keys(this._axis).forEach(function (axis) {
      _this._axis[axis] = __assign({
        range: [0, 100],
        startPos: _this._axis[axis].range[0],
        bounce: [0, 0],
        circular: [false, false]
      }, _this._axis[axis]);
      ["bounce", "circular"].forEach(function (v) {
        var axisOption = _this._axis;
        var key = axisOption[axis][v];
        if (/string|number|boolean/.test(typeof key)) {
          axisOption[axis][v] = [key, key];
        }
      });
    });
  };
  return AxisManager;
}();

var SUPPORT_TOUCH = ("ontouchstart" in win);
var SUPPORT_POINTER = ("PointerEvent" in win);
var SUPPORT_MSPOINTER = ("MSPointerEvent" in win);
var SUPPORT_POINTER_EVENTS = SUPPORT_POINTER || SUPPORT_MSPOINTER;
var isValidKey = function (event, inputKey) {
  if (!inputKey || inputKey.indexOf(ANY) > -1 || inputKey.indexOf(NONE) > -1 && !event.shiftKey && !event.ctrlKey && !event.altKey && !event.metaKey || inputKey.indexOf(SHIFT) > -1 && event.shiftKey || inputKey.indexOf(CTRL) > -1 && event.ctrlKey || inputKey.indexOf(ALT) > -1 && event.altKey || inputKey.indexOf(META) > -1 && event.metaKey) {
    return true;
  }
  return false;
};
var EventInput = /*#__PURE__*/function () {
  function EventInput() {
    var _this = this;
    this._stopContextMenu = function (event) {
      event.preventDefault();
      win.removeEventListener("contextmenu", _this._stopContextMenu);
    };
  }
  var __proto = EventInput.prototype;
  __proto.extendEvent = function (event) {
    var _a;
    var prevEvent = this.prevEvent;
    var center = this._getCenter(event);
    var movement = prevEvent ? this._getMovement(event) : {
      x: 0,
      y: 0
    };
    var scale = prevEvent ? this._getScale(event) : 1;
    var angle = prevEvent ? getAngle(center.x - prevEvent.center.x, center.y - prevEvent.center.y) : 0;
    var deltaX = prevEvent ? prevEvent.deltaX + movement.x : movement.x;
    var deltaY = prevEvent ? prevEvent.deltaY + movement.y : movement.y;
    var offsetX = movement.x;
    var offsetY = movement.y;
    var latestInterval = this._latestInterval;
    var timeStamp = Date.now();
    var deltaTime = latestInterval ? timeStamp - latestInterval.timestamp : 0;
    var velocityX = prevEvent ? prevEvent.velocityX : 0;
    var velocityY = prevEvent ? prevEvent.velocityY : 0;
    if (!latestInterval || deltaTime >= VELOCITY_INTERVAL) {
      if (latestInterval) {
        _a = [(deltaX - latestInterval.deltaX) / deltaTime, (deltaY - latestInterval.deltaY) / deltaTime], velocityX = _a[0], velocityY = _a[1];
      }
      this._latestInterval = {
        timestamp: timeStamp,
        deltaX: deltaX,
        deltaY: deltaY
      };
    }
    return {
      srcEvent: event,
      scale: scale,
      angle: angle,
      center: center,
      deltaX: deltaX,
      deltaY: deltaY,
      offsetX: offsetX,
      offsetY: offsetY,
      velocityX: velocityX,
      velocityY: velocityY,
      preventSystemEvent: true
    };
  };
  __proto._getDistance = function (start, end) {
    var x = end.clientX - start.clientX;
    var y = end.clientY - start.clientY;
    return Math.sqrt(x * x + y * y);
  };
  __proto._getButton = function (event) {
    var buttonCodeMap = {
      1: MOUSE_LEFT,
      2: MOUSE_RIGHT,
      4: MOUSE_MIDDLE
    };
    var button = this._isTouchEvent(event) ? MOUSE_LEFT : buttonCodeMap[event.buttons];
    return button ? button : null;
  };
  __proto._isTouchEvent = function (event) {
    return event.type && event.type.indexOf("touch") > -1;
  };
  __proto._isValidButton = function (button, inputButton) {
    return inputButton.indexOf(button) > -1;
  };
  __proto._isValidEvent = function (event, inputKey, inputButton) {
    return (!inputKey || isValidKey(event, inputKey)) && (!inputButton || this._isValidButton(this._getButton(event), inputButton));
  };
  __proto._preventMouseButton = function (event, button) {
    if (button === MOUSE_RIGHT) {
      win.addEventListener("contextmenu", this._stopContextMenu);
    } else if (button === MOUSE_MIDDLE) {
      event.preventDefault();
    }
  };
  return EventInput;
}();

var MouseEventInput = /*#__PURE__*/function (_super) {
  __extends$1(MouseEventInput, _super);
  function MouseEventInput() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.start = ["mousedown"];
    _this.move = ["mousemove"];
    _this.end = ["mouseup"];
    return _this;
  }
  var __proto = MouseEventInput.prototype;
  __proto.onEventStart = function (event, inputKey, inputButton) {
    var button = this._getButton(event);
    if (!this._isValidEvent(event, inputKey, inputButton)) {
      return null;
    }
    this._preventMouseButton(event, button);
    return this.extendEvent(event);
  };
  __proto.onEventMove = function (event, inputKey, inputButton) {
    if (!this._isValidEvent(event, inputKey, inputButton)) {
      return null;
    }
    return this.extendEvent(event);
  };
  __proto.onEventEnd = function () {
    return;
  };
  __proto.onRelease = function () {
    this.prevEvent = null;
    return;
  };
  __proto.getTouches = function (event, inputButton) {
    if (inputButton) {
      return this._isValidButton(MOUSE_BUTTON_CODE_MAP[event.which], inputButton) && this.end.indexOf(event.type) === -1 ? 1 : 0;
    }
    return 0;
  };
  __proto._getScale = function () {
    return 1;
  };
  __proto._getCenter = function (event) {
    return {
      x: event.clientX,
      y: event.clientY
    };
  };
  __proto._getMovement = function (event) {
    var prev = this.prevEvent.srcEvent;
    return {
      x: event.clientX - prev.clientX,
      y: event.clientY - prev.clientY
    };
  };
  return MouseEventInput;
}(EventInput);

var TouchEventInput = /*#__PURE__*/function (_super) {
  __extends$1(TouchEventInput, _super);
  function TouchEventInput() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.start = ["touchstart"];
    _this.move = ["touchmove"];
    _this.end = ["touchend", "touchcancel"];
    return _this;
  }
  var __proto = TouchEventInput.prototype;
  __proto.onEventStart = function (event, inputKey) {
    this._baseTouches = event.touches;
    if (!this._isValidEvent(event, inputKey)) {
      return null;
    }
    return this.extendEvent(event);
  };
  __proto.onEventMove = function (event, inputKey) {
    if (!this._isValidEvent(event, inputKey)) {
      return null;
    }
    return this.extendEvent(event);
  };
  __proto.onEventEnd = function (event) {
    this._baseTouches = event.touches;
    return;
  };
  __proto.onRelease = function () {
    this.prevEvent = null;
    this._baseTouches = null;
    return;
  };
  __proto.getTouches = function (event) {
    return event.touches.length;
  };
  __proto._getScale = function (event) {
    if (event.touches.length !== 2 || this._baseTouches.length < 2) {
      return null; // TODO: consider calculating non-pinch gesture scale
    }

    return this._getDistance(event.touches[0], event.touches[1]) / this._getDistance(this._baseTouches[0], this._baseTouches[1]);
  };
  __proto._getCenter = function (event) {
    return {
      x: event.touches[0].clientX,
      y: event.touches[0].clientY
    };
  };
  __proto._getMovement = function (event) {
    var prev = this.prevEvent.srcEvent;
    if (event.touches[0].identifier !== prev.touches[0].identifier) {
      return {
        x: 0,
        y: 0
      };
    }
    return {
      x: event.touches[0].clientX - prev.touches[0].clientX,
      y: event.touches[0].clientY - prev.touches[0].clientY
    };
  };
  return TouchEventInput;
}(EventInput);

var PointerEventInput = /*#__PURE__*/function (_super) {
  __extends$1(PointerEventInput, _super);
  function PointerEventInput() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.start = SUPPORT_POINTER ? ["pointerdown"] : ["MSPointerDown"];
    _this.move = SUPPORT_POINTER ? ["pointermove"] : ["MSPointerMove"];
    _this.end = SUPPORT_POINTER ? ["pointerup", "pointercancel"] : ["MSPointerUp", "MSPointerCancel"];
    // store first, recent inputs for each event id
    _this._firstInputs = [];
    _this._recentInputs = [];
    return _this;
  }
  var __proto = PointerEventInput.prototype;
  __proto.onEventStart = function (event, inputKey, inputButton) {
    var button = this._getButton(event);
    if (!this._isValidEvent(event, inputKey, inputButton)) {
      return null;
    }
    this._preventMouseButton(event, button);
    this._updatePointerEvent(event);
    return this.extendEvent(event);
  };
  __proto.onEventMove = function (event, inputKey, inputButton) {
    if (!this._isValidEvent(event, inputKey, inputButton)) {
      return null;
    }
    this._updatePointerEvent(event);
    return this.extendEvent(event);
  };
  __proto.onEventEnd = function (event) {
    this._removePointerEvent(event);
  };
  __proto.onRelease = function () {
    this.prevEvent = null;
    this._firstInputs = [];
    this._recentInputs = [];
    return;
  };
  __proto.getTouches = function () {
    return this._recentInputs.length;
  };
  __proto._getScale = function () {
    if (this._recentInputs.length !== 2) {
      return null; // TODO: consider calculating non-pinch gesture scale
    }

    return this._getDistance(this._recentInputs[0], this._recentInputs[1]) / this._getDistance(this._firstInputs[0], this._firstInputs[1]);
  };
  __proto._getCenter = function (event) {
    return {
      x: event.clientX,
      y: event.clientY
    };
  };
  __proto._getMovement = function (event) {
    var prev = this.prevEvent.srcEvent;
    if (event.pointerId !== prev.pointerId) {
      return {
        x: 0,
        y: 0
      };
    }
    return {
      x: event.clientX - prev.clientX,
      y: event.clientY - prev.clientY
    };
  };
  __proto._updatePointerEvent = function (event) {
    var _this = this;
    var addFlag = false;
    this._recentInputs.forEach(function (e, i) {
      if (e.pointerId === event.pointerId) {
        addFlag = true;
        _this._recentInputs[i] = event;
      }
    });
    if (!addFlag) {
      this._firstInputs.push(event);
      this._recentInputs.push(event);
    }
  };
  __proto._removePointerEvent = function (event) {
    this._firstInputs = this._firstInputs.filter(function (x) {
      return x.pointerId !== event.pointerId;
    });
    this._recentInputs = this._recentInputs.filter(function (x) {
      return x.pointerId !== event.pointerId;
    });
  };
  return PointerEventInput;
}(EventInput);

var TouchMouseEventInput = /*#__PURE__*/function (_super) {
  __extends$1(TouchMouseEventInput, _super);
  function TouchMouseEventInput() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.start = ["mousedown", "touchstart"];
    _this.move = ["mousemove", "touchmove"];
    _this.end = ["mouseup", "touchend", "touchcancel"];
    return _this;
  }
  var __proto = TouchMouseEventInput.prototype;
  __proto.onEventStart = function (event, inputKey, inputButton) {
    var button = this._getButton(event);
    if (this._isTouchEvent(event)) {
      this._baseTouches = event.touches;
    }
    if (!this._isValidEvent(event, inputKey, inputButton)) {
      return null;
    }
    this._preventMouseButton(event, button);
    return this.extendEvent(event);
  };
  __proto.onEventMove = function (event, inputKey, inputButton) {
    if (!this._isValidEvent(event, inputKey, inputButton)) {
      return null;
    }
    return this.extendEvent(event);
  };
  __proto.onEventEnd = function (event) {
    if (this._isTouchEvent(event)) {
      this._baseTouches = event.touches;
    }
    return;
  };
  __proto.onRelease = function () {
    this.prevEvent = null;
    this._baseTouches = null;
    return;
  };
  __proto.getTouches = function (event, inputButton) {
    if (this._isTouchEvent(event)) {
      return event.touches.length;
    } else {
      return this._isValidButton(MOUSE_BUTTON_CODE_MAP[event.which], inputButton) && this.end.indexOf(event.type) === -1 ? 1 : 0;
    }
  };
  __proto._getScale = function (event) {
    if (this._isTouchEvent(event)) {
      if (event.touches.length !== 2 || this._baseTouches.length < 2) {
        return 1; // TODO: consider calculating non-pinch gesture scale
      }

      return this._getDistance(event.touches[0], event.touches[1]) / this._getDistance(this._baseTouches[0], this._baseTouches[1]);
    }
    return this.prevEvent.scale;
  };
  __proto._getCenter = function (event) {
    if (this._isTouchEvent(event)) {
      return {
        x: event.touches[0].clientX,
        y: event.touches[0].clientY
      };
    }
    return {
      x: event.clientX,
      y: event.clientY
    };
  };
  __proto._getMovement = function (event) {
    var _this = this;
    var prev = this.prevEvent.srcEvent;
    var _a = [event, prev].map(function (e) {
        if (_this._isTouchEvent(e)) {
          return {
            id: e.touches[0].identifier,
            x: e.touches[0].clientX,
            y: e.touches[0].clientY
          };
        }
        return {
          id: null,
          x: e.clientX,
          y: e.clientY
        };
      }),
      nextSpot = _a[0],
      prevSpot = _a[1];
    return nextSpot.id === prevSpot.id ? {
      x: nextSpot.x - prevSpot.x,
      y: nextSpot.y - prevSpot.y
    } : {
      x: 0,
      y: 0
    };
  };
  return TouchMouseEventInput;
}(EventInput);

var toAxis = function (source, offset) {
  return offset.reduce(function (acc, v, i) {
    if (source[i]) {
      acc[source[i]] = v;
    }
    return acc;
  }, {});
};
var convertInputType = function (inputType) {
  if (inputType === void 0) {
    inputType = [];
  }
  var hasTouch = false;
  var hasMouse = false;
  var hasPointer = false;
  inputType.forEach(function (v) {
    switch (v) {
      case "mouse":
        hasMouse = true;
        break;
      case "touch":
        hasTouch = SUPPORT_TOUCH;
        break;
      case "pointer":
        hasPointer = SUPPORT_POINTER_EVENTS;
      // no default
    }
  });

  if (hasPointer) {
    return new PointerEventInput();
  } else if (hasTouch && hasMouse) {
    return new TouchMouseEventInput();
  } else if (hasTouch) {
    return new TouchEventInput();
  } else if (hasMouse) {
    return new MouseEventInput();
  }
  return null;
};
function getAddEventOptions(eventName) {
  // The passive default value of the touch event is true.
  // If not a touch event, return false to support ie11
  return eventName.indexOf("touch") > -1 ? {
    passive: false
  } : false;
}

var InputObserver = /*#__PURE__*/function () {
  function InputObserver(_a) {
    var options = _a.options,
      interruptManager = _a.interruptManager,
      eventManager = _a.eventManager,
      axisManager = _a.axisManager,
      animationManager = _a.animationManager;
    this._isOutside = false;
    this._moveDistance = null;
    this._isStopped = false;
    this.options = options;
    this._interruptManager = interruptManager;
    this._eventManager = eventManager;
    this._axisManager = axisManager;
    this._animationManager = animationManager;
  }
  var __proto = InputObserver.prototype;
  __proto.get = function (input) {
    return this._axisManager.get(input.axes);
  };
  __proto.hold = function (input, event) {
    if (this._interruptManager.isInterrupted() || !input.axes.length) {
      return;
    }
    var changeOption = {
      input: input,
      event: event
    };
    this._isStopped = false;
    this._interruptManager.setInterrupt(true);
    this._animationManager.stopAnimation(changeOption);
    ++this._eventManager.holdingCount;
    if (!this._moveDistance) {
      this._eventManager.hold(this._axisManager.get(), changeOption);
    }
    this._isOutside = this._axisManager.isOutside(input.axes);
    this._moveDistance = this._axisManager.get(input.axes);
  };
  __proto.change = function (input, event, offset, useAnimation) {
    if (this._isStopped || !this._interruptManager.isInterrupting() || this._axisManager.every(offset, function (v) {
      return v === 0;
    })) {
      return;
    }
    var nativeEvent = event.srcEvent ? event.srcEvent : event;
    if (nativeEvent.__childrenAxesAlreadyChanged) {
      return;
    }
    var depaPos = this._moveDistance || this._axisManager.get(input.axes);
    var destPos;
    // for outside logic
    destPos = map(depaPos, function (v, k) {
      return v + (offset[k] || 0);
    });
    if (this._moveDistance) {
      this._moveDistance = this._axisManager.map(destPos, function (v, _a) {
        var circular = _a.circular,
          range = _a.range;
        return circular && (circular[0] || circular[1]) ? getCirculatedPos(v, range, circular) : v;
      });
    }
    // from outside to inside
    if (this._isOutside && this._axisManager.every(depaPos, function (v, opt) {
      return !isOutside(v, opt.range);
    })) {
      this._isOutside = false;
    }
    depaPos = this._atOutside(depaPos);
    destPos = this._atOutside(destPos);
    if (!this.options.nested || !this._isEndofAxis(offset, depaPos, destPos)) {
      nativeEvent.__childrenAxesAlreadyChanged = true;
    }
    var changeOption = {
      input: input,
      event: event
    };
    if (useAnimation) {
      var duration = this._animationManager.getDuration(destPos, depaPos);
      this._animationManager.animateTo(destPos, duration, changeOption);
    } else {
      var isCanceled = !this._eventManager.triggerChange(destPos, depaPos, changeOption, true);
      if (isCanceled) {
        this._isStopped = true;
        this._moveDistance = null;
        this._animationManager.finish(false);
      }
    }
  };
  __proto.release = function (input, event, velocity, inputDuration) {
    if (this._isStopped || !this._interruptManager.isInterrupting() || !this._moveDistance) {
      return;
    }
    var nativeEvent = event.srcEvent ? event.srcEvent : event;
    if (nativeEvent.__childrenAxesAlreadyReleased) {
      velocity = velocity.map(function () {
        return 0;
      });
    }
    var pos = this._axisManager.get(input.axes);
    var depaPos = this._axisManager.get();
    var displacement = this._animationManager.getDisplacement(velocity);
    var offset = toAxis(input.axes, displacement);
    var destPos = this._axisManager.get(this._axisManager.map(offset, function (v, opt, k) {
      if (opt.circular && (opt.circular[0] || opt.circular[1])) {
        return pos[k] + v;
      } else {
        return getInsidePosition(pos[k] + v, opt.range, opt.circular, opt.bounce);
      }
    }));
    nativeEvent.__childrenAxesAlreadyReleased = true;
    var duration = this._animationManager.getDuration(destPos, pos, inputDuration);
    if (duration === 0) {
      destPos = __assign({}, depaPos);
    }
    // prepare params
    var param = {
      depaPos: depaPos,
      destPos: destPos,
      duration: duration,
      delta: this._axisManager.getDelta(depaPos, destPos),
      inputEvent: event,
      input: input,
      isTrusted: true
    };
    --this._eventManager.holdingCount;
    this._eventManager.triggerRelease(param);
    if (this._eventManager.holdingCount === 0) {
      this._moveDistance = null;
    }
    // to contol
    var userWish = this._animationManager.getUserControl(param);
    var isEqual = equal(userWish.destPos, depaPos);
    var changeOption = {
      input: input,
      event: event
    };
    if (isEqual || userWish.duration === 0) {
      if (!isEqual) {
        this._eventManager.triggerChange(userWish.destPos, depaPos, changeOption, true);
      }
      this._interruptManager.setInterrupt(false);
      if (this._axisManager.isOutside()) {
        this._animationManager.restore(changeOption);
      } else {
        this._eventManager.triggerFinish(true);
      }
    } else {
      this._animationManager.animateTo(userWish.destPos, userWish.duration, changeOption);
    }
  };
  // when move pointer is held in outside
  __proto._atOutside = function (pos) {
    var _this = this;
    if (this._isOutside) {
      return this._axisManager.map(pos, function (v, opt) {
        var tn = opt.range[0] - opt.bounce[0];
        var tx = opt.range[1] + opt.bounce[1];
        return v > tx ? tx : v < tn ? tn : v;
      });
    } else {
      return this._axisManager.map(pos, function (v, opt) {
        var min = opt.range[0];
        var max = opt.range[1];
        var out = opt.bounce;
        var circular = opt.circular;
        if (circular[0] && v < min || circular[1] && v > max) {
          return v;
        } else if (v < min) {
          // left
          return min - _this._animationManager.interpolate(min - v, out[0]);
        } else if (v > max) {
          // right
          return max + _this._animationManager.interpolate(v - max, out[1]);
        }
        return v;
      });
    }
  };
  __proto._isEndofAxis = function (offset, depaPos, destPos) {
    return this._axisManager.every(depaPos, function (value, option, key) {
      return offset[key] === 0 || depaPos[key] === destPos[key] && isEndofBounce(value, option.range, option.bounce, option.circular);
    });
  };
  return InputObserver;
}();

var clamp = function (value, min, max) {
  return Math.max(Math.min(value, max), min);
};
var AnimationManager = /*#__PURE__*/function () {
  function AnimationManager(_a) {
    var options = _a.options,
      interruptManager = _a.interruptManager,
      eventManager = _a.eventManager,
      axisManager = _a.axisManager;
    this._options = options;
    this.interruptManager = interruptManager;
    this.eventManager = eventManager;
    this.axisManager = axisManager;
    this.animationEnd = this.animationEnd.bind(this);
  }
  var __proto = AnimationManager.prototype;
  __proto.getDuration = function (depaPos, destPos, wishDuration) {
    var _this = this;
    var duration;
    if (typeof wishDuration !== "undefined") {
      duration = wishDuration;
    } else {
      var durations_1 = map(destPos, function (v, k) {
        return getDuration(Math.abs(v - depaPos[k]), _this._options.deceleration);
      });
      duration = Object.keys(durations_1).reduce(function (max, v) {
        return Math.max(max, durations_1[v]);
      }, -Infinity);
    }
    return clamp(duration, this._options.minimumDuration, this._options.maximumDuration);
  };
  __proto.getDisplacement = function (velocity) {
    var totalVelocity = Math.pow(velocity.reduce(function (total, v) {
      return total + v * v;
    }, 0), 1 / velocity.length);
    var duration = Math.abs(totalVelocity / -this._options.deceleration);
    return velocity.map(function (v) {
      return v / 2 * duration;
    });
  };
  __proto.stopAnimation = function (option) {
    if (this._animateParam) {
      var orgPos_1 = this.axisManager.get();
      var pos = this.axisManager.map(orgPos_1, function (v, opt) {
        return getCirculatedPos(v, opt.range, opt.circular);
      });
      if (!every(pos, function (v, k) {
        return orgPos_1[k] === v;
      })) {
        this.eventManager.triggerChange(pos, orgPos_1, option, !!option);
      }
      this._animateParam = null;
      if (this._raf) {
        cancelAnimationFrame$1(this._raf);
      }
      this._raf = null;
      this.eventManager.triggerAnimationEnd(!!(option === null || option === void 0 ? void 0 : option.event));
    }
  };
  __proto.getEventInfo = function () {
    if (this._animateParam && this._animateParam.input && this._animateParam.inputEvent) {
      return {
        input: this._animateParam.input,
        event: this._animateParam.inputEvent
      };
    } else {
      return null;
    }
  };
  __proto.restore = function (option) {
    var pos = this.axisManager.get();
    var destPos = this.axisManager.map(pos, function (v, opt) {
      return Math.min(opt.range[1], Math.max(opt.range[0], v));
    });
    this.stopAnimation();
    this.animateTo(destPos, this.getDuration(pos, destPos), option);
  };
  __proto.animationEnd = function () {
    var beforeParam = this.getEventInfo();
    this._animateParam = null;
    // for Circular
    var circularTargets = this.axisManager.filter(this.axisManager.get(), function (v, opt) {
      return isCircularable(v, opt.range, opt.circular);
    });
    if (Object.keys(circularTargets).length > 0) {
      this.setTo(this.axisManager.map(circularTargets, function (v, opt) {
        return getCirculatedPos(v, opt.range, opt.circular);
      }));
    }
    this.interruptManager.setInterrupt(false);
    this.eventManager.triggerAnimationEnd(!!beforeParam);
    if (this.axisManager.isOutside()) {
      this.restore(beforeParam);
    } else {
      this.finish(!!beforeParam);
    }
  };
  __proto.finish = function (isTrusted) {
    this._animateParam = null;
    this.interruptManager.setInterrupt(false);
    this.eventManager.triggerFinish(isTrusted);
  };
  __proto.getUserControl = function (param) {
    var userWish = param.setTo();
    userWish.destPos = this.axisManager.get(userWish.destPos);
    userWish.duration = clamp(userWish.duration, this._options.minimumDuration, this._options.maximumDuration);
    return userWish;
  };
  __proto.animateTo = function (destPos, duration, option) {
    var _this = this;
    this.stopAnimation();
    var param = this._createAnimationParam(destPos, duration, option);
    var depaPos = __assign({}, param.depaPos);
    var retTrigger = this.eventManager.triggerAnimationStart(param);
    // to control
    var userWish = this.getUserControl(param);
    // You can't stop the 'animationStart' event when 'circular' is true.
    if (!retTrigger && this.axisManager.every(userWish.destPos, function (v, opt) {
      return isCircularable(v, opt.range, opt.circular);
    })) {
      console.warn("You can't stop the 'animation' event when 'circular' is true.");
    }
    if (retTrigger && !equal(userWish.destPos, depaPos)) {
      var inputEvent = (option === null || option === void 0 ? void 0 : option.event) || null;
      this._animateLoop({
        depaPos: depaPos,
        destPos: userWish.destPos,
        duration: userWish.duration,
        delta: this.axisManager.getDelta(depaPos, userWish.destPos),
        isTrusted: !!inputEvent,
        inputEvent: inputEvent,
        input: (option === null || option === void 0 ? void 0 : option.input) || null
      }, function () {
        return _this.animationEnd();
      });
    }
  };
  __proto.setTo = function (pos, duration) {
    if (duration === void 0) {
      duration = 0;
    }
    var axes = Object.keys(pos);
    var orgPos = this.axisManager.get(axes);
    if (equal(pos, orgPos)) {
      return this;
    }
    this.interruptManager.setInterrupt(true);
    var movedPos = filter(pos, function (v, k) {
      return orgPos[k] !== v;
    });
    if (!Object.keys(movedPos).length) {
      return this;
    }
    movedPos = this.axisManager.map(movedPos, function (v, opt) {
      var range = opt.range,
        circular = opt.circular;
      if (circular && (circular[0] || circular[1])) {
        return v;
      } else {
        return getInsidePosition(v, range, circular);
      }
    });
    if (equal(movedPos, orgPos)) {
      return this;
    }
    if (duration > 0) {
      this.animateTo(movedPos, duration);
    } else {
      this.stopAnimation();
      this.eventManager.triggerChange(movedPos);
      this.finish(false);
    }
    return this;
  };
  __proto.setBy = function (pos, duration) {
    if (duration === void 0) {
      duration = 0;
    }
    return this.setTo(map(this.axisManager.get(Object.keys(pos)), function (v, k) {
      return v + pos[k];
    }), duration);
  };
  __proto.setOptions = function (options) {
    this._options = __assign(__assign({}, this._options), options);
  };
  __proto._createAnimationParam = function (pos, duration, option) {
    var depaPos = this.axisManager.get();
    var destPos = pos;
    var inputEvent = (option === null || option === void 0 ? void 0 : option.event) || null;
    return {
      depaPos: depaPos,
      destPos: destPos,
      duration: clamp(duration, this._options.minimumDuration, this._options.maximumDuration),
      delta: this.axisManager.getDelta(depaPos, destPos),
      inputEvent: inputEvent,
      input: (option === null || option === void 0 ? void 0 : option.input) || null,
      isTrusted: !!inputEvent,
      done: this.animationEnd
    };
  };
  __proto._animateLoop = function (param, complete) {
    var _this = this;
    if (param.duration) {
      this._animateParam = __assign(__assign({}, param), {
        startTime: new Date().getTime()
      });
      var originalIntendedPos_1 = map(param.destPos, function (v) {
        return v;
      });
      var state_1 = this._initState(this._animateParam);
      var loop_1 = function () {
        _this._raf = null;
        var animateParam = _this._animateParam;
        var nextState = _this._getNextState(state_1);
        var isCanceled = !_this.eventManager.triggerChange(nextState.pos, state_1.pos);
        state_1 = nextState;
        if (nextState.finished) {
          animateParam.destPos = _this._getFinalPos(animateParam.destPos, originalIntendedPos_1);
          if (!equal(animateParam.destPos, _this.axisManager.get(Object.keys(animateParam.destPos)))) {
            _this.eventManager.triggerChange(animateParam.destPos, nextState.pos);
          }
          complete();
          return;
        } else if (isCanceled) {
          _this.finish(false);
        } else {
          _this._raf = requestAnimationFrame$1(loop_1);
        }
      };
      loop_1();
    } else {
      this.eventManager.triggerChange(param.destPos);
      complete();
    }
  };
  /**
   * Get estimated final value.
   *
   * If destPos is within the 'error range' of the original intended position, the initial intended position is returned.
   *   - eg. original intended pos: 100, destPos: 100.0000000004 ==> return 100;
   * If dest Pos is outside the 'range of error' compared to the originally intended pos, it is returned rounded based on the originally intended pos.
   *   - eg. original intended pos: 100.123 destPos: 50.12345 => return 50.123
   * @param originalIntendedPos
   * @param destPos
   */
  __proto._getFinalPos = function (destPos, originalIntendedPos) {
    var _this = this;
    // compare destPos and originalIntendedPos
    // eslint-disable-next-line @typescript-eslint/naming-convention
    var ERROR_LIMIT = 0.000001;
    var finalPos = map(destPos, function (value, key) {
      if (value >= originalIntendedPos[key] - ERROR_LIMIT && value <= originalIntendedPos[key] + ERROR_LIMIT) {
        // In error range, return original intended
        return originalIntendedPos[key];
      } else {
        // Out of error range, return rounded pos.
        var roundUnit = _this._getRoundUnit(value, key);
        var result = roundNumber(value, roundUnit);
        return result;
      }
    });
    return finalPos;
  };
  __proto._getRoundUnit = function (val, key) {
    var roundUnit = this._options.round; // manual mode
    var minRoundUnit = null; // auto mode
    // auto mode
    if (!roundUnit) {
      // Get minimum round unit
      var options = this.axisManager.getAxisOptions(key);
      minRoundUnit = inversePow(Math.max(getDecimalPlace(options.range[0]), getDecimalPlace(options.range[1]), getDecimalPlace(val)));
    }
    return minRoundUnit || roundUnit;
  };
  return AnimationManager;
}();

var EasingManager = /*#__PURE__*/function (_super) {
  __extends$1(EasingManager, _super);
  function EasingManager() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._useDuration = true;
    return _this;
  }
  var __proto = EasingManager.prototype;
  __proto.interpolate = function (displacement, threshold) {
    var initSlope = this._easing(0.00001) / 0.00001;
    return this._easing(displacement / (threshold * initSlope)) * threshold;
  };
  __proto.updateAnimation = function (options) {
    var _a;
    var animateParam = this._animateParam;
    if (!animateParam) {
      return;
    }
    var diffTime = new Date().getTime() - animateParam.startTime;
    var pos = (options === null || options === void 0 ? void 0 : options.destPos) || animateParam.destPos;
    var duration = (_a = options === null || options === void 0 ? void 0 : options.duration) !== null && _a !== void 0 ? _a : animateParam.duration;
    if ((options === null || options === void 0 ? void 0 : options.restart) || duration <= diffTime) {
      this.setTo(pos, duration - diffTime);
      return;
    }
    if (options === null || options === void 0 ? void 0 : options.destPos) {
      var currentPos = this.axisManager.get();
      // When destination is changed, new delta should be calculated as remaining percent.
      // For example, moving x:0, y:0 to x:200, y:200 and it has current easing percent of 92%. coordinate is x:184 and y:184
      // If destination changes to x:300, y:300. xdelta:200, ydelta:200 changes to xdelta:116, ydelta:116 and use remaining easingPer as 100%, not 8% as previous.
      // Therefore, original easingPer by time is kept. And divided by (1 - self._initialEasingPer) which means new total easing percent. Like calculating 8% as 100%.
      this._initialEasingPer = this._prevEasingPer;
      animateParam.delta = this.axisManager.getDelta(currentPos, pos);
      animateParam.destPos = pos;
    }
    if (options === null || options === void 0 ? void 0 : options.duration) {
      var ratio = (diffTime + this._durationOffset) / animateParam.duration;
      // Use durationOffset for keeping animation ratio after duration is changed.
      // newRatio = (diffTime + newDurationOffset) / newDuration = oldRatio
      // newDurationOffset = oldRatio * newDuration - diffTime
      this._durationOffset = ratio * duration - diffTime;
      animateParam.duration = duration;
    }
  };
  __proto._initState = function (info) {
    this._initialEasingPer = 0;
    this._prevEasingPer = 0;
    this._durationOffset = 0;
    return {
      pos: info.depaPos,
      easingPer: 0,
      finished: false
    };
  };
  __proto._getNextState = function (prevState) {
    var _this = this;
    var animateParam = this._animateParam;
    var prevPos = prevState.pos;
    var destPos = animateParam.destPos;
    var directions = map(prevPos, function (value, key) {
      return value <= destPos[key] ? 1 : -1;
    });
    var diffTime = new Date().getTime() - animateParam.startTime;
    var ratio = (diffTime + this._durationOffset) / animateParam.duration;
    var easingPer = this._easing(ratio);
    var toPos = this.axisManager.map(prevPos, function (pos, options, key) {
      var nextPos = ratio >= 1 ? destPos[key] : pos + animateParam.delta[key] * (easingPer - _this._prevEasingPer) / (1 - _this._initialEasingPer);
      // Subtract distance from distance already moved.
      // Recalculate the remaining distance.
      // Fix the bouncing phenomenon by changing the range.
      var circulatedPos = getCirculatedPos(nextPos, options.range, options.circular);
      if (nextPos !== circulatedPos) {
        // circular
        var rangeOffset = directions[key] * (options.range[1] - options.range[0]);
        destPos[key] -= rangeOffset;
        prevPos[key] -= rangeOffset;
      }
      return circulatedPos;
    });
    this._prevEasingPer = easingPer;
    return {
      pos: toPos,
      easingPer: easingPer,
      finished: easingPer >= 1
    };
  };
  __proto._easing = function (p) {
    return p > 1 ? 1 : this._options.easing(p);
  };
  return EasingManager;
}(AnimationManager);

/**
 * @typedef {Object} AxisOption The Axis information. The key of the axis specifies the name to use as the logical virtual coordinate system.
 * @ko 축 정보. 축의 키는 논리적인 가상 좌표계로 사용할 이름을 지정한다.
 * @param {Number[]} [range] The range of coordinate <ko>좌표 범위</ko>
 * @param {Number} [range[0]=0] The coordinate of the minimum <ko>최소 좌표</ko>
 * @param {Number} [range[1]=0] The coordinate of the maximum <ko>최대 좌표</ko>
 * @param {Number} [startPos=range[0]] The coordinates to be moved when creating an instance <ko>인스턴스 생성시 이동할 좌표</ko>
 * @param {Number[]} [bounce] The size of bouncing area. The coordinates can exceed the coordinate area as much as the bouncing area based on user action. If the coordinates does not exceed the bouncing area when an element is dragged, the coordinates where bouncing effects are applied are retuned back into the coordinate area<ko>바운스 영역의 크기. 사용자의 동작에 따라 좌표가 좌표 영역을 넘어 바운스 영역의 크기만큼 더 이동할 수 있다. 사용자가 끌어다 놓는 동작을 했을 때 좌표가 바운스 영역에 있으면, 바운스 효과가 적용된 좌표가 다시 좌표 영역 안으로 들어온다</ko>
 * @param {Number} [bounce[0]=0] The size of coordinate of the minimum area <ko>최소 좌표 바운스 영역의 크기</ko>
 * @param {Number} [bounce[1]=0] The size of coordinate of the maximum area <ko>최대 좌표 바운스 영역의 크기</ko>
 * @param {Boolean[]} [circular] Indicates whether a circular element is available. If it is set to "true" and an element is dragged outside the coordinate area, the element will appear on the other side.<ko>순환 여부. 'true'로 설정한 방향의 좌표 영역 밖으로 엘리먼트가 이동하면 반대 방향에서 엘리먼트가 나타난다</ko>
 * @param {Boolean} [circular[0]=false] Indicates whether to circulate to the coordinate of the minimum <ko>최소 좌표 방향의 순환 여부</ko>
 * @param {Boolean} [circular[1]=false] Indicates whether to circulate to the coordinate of the maximum <ko>최대 좌표 방향의 순환 여부</ko>
 **/
/**
 * @typedef {Object} AxesOption The option object of the eg.Axes module
 * @ko eg.Axes 모듈의 옵션 객체
 * @param {Function} [easing=easing.easeOutCubic] The easing function to apply to an animation <ko>애니메이션에 적용할 easing 함수</ko>
 * @param {Number} [maximumDuration=Infinity] Maximum duration of the animation <ko>가속도에 의해 애니메이션이 동작할 때의 최대 좌표 이동 시간</ko>
 * @param {Number} [minimumDuration=0] Minimum duration of the animation <ko>가속도에 의해 애니메이션이 동작할 때의 최소 좌표 이동 시간</ko>
 * @param {Number} [deceleration=0.0006] Deceleration of the animation where acceleration is manually enabled by user. A higher value indicates shorter running time. <ko>사용자의 동작으로 가속도가 적용된 애니메이션의 감속도. 값이 높을수록 애니메이션 실행 시간이 짧아진다</ko>
 * @param {Boolean} [interruptable=true] Indicates whether an animation is interruptible.
 * - true: It can be paused or stopped by user action or the API.
 * - false: It cannot be paused or stopped by user action or the API while it is running.
 * <ko>진행 중인 애니메이션 중지 가능 여부.
 * - true: 사용자의 동작이나 API로 애니메이션을 중지할 수 있다.
 * - false: 애니메이션이 진행 중일 때는 사용자의 동작이나 API가 적용되지 않는다</ko>
 * @param {Number} [round=null] Rounding unit. For example, 0.1 rounds to 0.1 decimal point(6.1234 => 6.1), 5 rounds to 5 (93 => 95)
 * [Details](https://github.com/naver/egjs-axes/wiki/round-option)<ko>반올림 단위. 예를 들어 0.1 은 소숫점 0.1 까지 반올림(6.1234 => 6.1), 5 는 5 단위로 반올림(93 => 95).
 * [상세내용](https://github.com/naver/egjs-axes/wiki/round-option)</ko>
 * @param {Boolean} [nested=false] Whether the event propagates to other instances when the coordinates reach the end of the movable area <ko>좌표가 이동 가능한 영역의 끝까지 도달했을 때 다른 인스턴스들로의 이벤트 전파 여부</ko>
 **/
/**
 * A module used to change the information of user action entered by various input devices such as touch screen or mouse into the logical virtual coordinates. You can easily create a UI that responds to user actions.
 * @ko 터치 입력 장치나 마우스와 같은 다양한 입력 장치를 통해 전달 받은 사용자의 동작을 논리적인 가상 좌표로 변경하는 모듈이다. 사용자 동작에 반응하는 UI를 손쉽게 만들수 있다.
 * @extends eg.Component
 *
 * @param {Object.<string, AxisOption>} axis Axis information managed by eg.Axes. The key of the axis specifies the name to use as the logical virtual coordinate system.  <ko>eg.Axes가 관리하는 축 정보. 축의 키는 논리적인 가상 좌표계로 사용할 이름을 지정한다.</ko>
 * @param {AxesOption} [options={}] The option object of the eg.Axes module<ko>eg.Axes 모듈의 옵션 객체</ko>
 * @param {Object.<string, number>} [startPos={}] The coordinates to be moved when creating an instance. It is applied with higher priority than startPos of axisOption.<ko>인스턴스 생성시 이동할 좌표, axisOption의 startPos보다 높은 우선순위로 적용된다.</ko>
 *
 * @support {"ie": "10+", "ch" : "latest", "ff" : "latest",  "sf" : "latest", "edge" : "latest", "ios" : "7+", "an" : "2.3+ (except 3.x)"}
 * @example
 * ```js
 * // 1. Initialize eg.Axes
 * const axes = new eg.Axes({
 *  something1: {
 *    range: [0, 150],
 *    bounce: 50
 *  },
 *  something2: {
 *    range: [0, 200],
 *    bounce: 100
 *  },
 *  somethingN: {
 *    range: [1, 10],
 *  }
 * }, {
 *  deceleration : 0.0024
 * });
 *
 * // 2. attach event handler
 * axes.on({
 *  "hold" : function(evt) {
 *  },
 *  "release" : function(evt) {
 *  },
 *  "animationStart" : function(evt) {
 *  },
 *  "animationEnd" : function(evt) {
 *  },
 *  "change" : function(evt) {
 *  }
 * });
 *
 * // 3. Initialize inputTypes
 * const panInputArea = new eg.Axes.PanInput("#area", {
 *  scale: [0.5, 1]
 * });
 * const panInputHmove = new eg.Axes.PanInput("#hmove");
 * const panInputVmove = new eg.Axes.PanInput("#vmove");
 * const pinchInputArea = new eg.Axes.PinchInput("#area", {
 *  scale: 1.5
 * });
 *
 * // 4. Connect eg.Axes and InputTypes
 * // [PanInput] When the mouse or touchscreen is down and moved.
 * // Connect the 'something2' axis to the mouse or touchscreen x position and
 * // connect the 'somethingN' axis to the mouse or touchscreen y position.
 * axes.connect(["something2", "somethingN"], panInputArea); // or axes.connect("something2 somethingN", panInputArea);
 *
 * // Connect only one 'something1' axis to the mouse or touchscreen x position.
 * axes.connect(["something1"], panInputHmove); // or axes.connect("something1", panInputHmove);
 *
 * // Connect only one 'something2' axis to the mouse or touchscreen y position.
 * axes.connect(["", "something2"], panInputVmove); // or axes.connect(" something2", panInputVmove);
 *
 * // [PinchInput] Connect 'something2' axis when two pointers are moving toward (zoom-in) or away from each other (zoom-out).
 * axes.connect("something2", pinchInputArea);
 * ```
 */
var Axes = /*#__PURE__*/function (_super) {
  __extends$1(Axes, _super);
  /**
   *
   */
  function Axes(axis, options, startPos) {
    if (axis === void 0) {
      axis = {};
    }
    if (options === void 0) {
      options = {};
    }
    if (startPos === void 0) {
      startPos = {};
    }
    var _this = _super.call(this) || this;
    _this.axis = axis;
    _this._inputs = [];
    _this.options = __assign({
      easing: function (x) {
        return 1 - Math.pow(1 - x, 3);
      },
      interruptable: true,
      maximumDuration: Infinity,
      minimumDuration: 0,
      deceleration: 0.0006,
      round: null,
      nested: false
    }, options);
    Object.keys(startPos).forEach(function (key) {
      _this.axis[key].startPos = startPos[key];
    });
    _this.interruptManager = new InterruptManager(_this.options);
    _this.axisManager = new AxisManager(_this.axis);
    _this.eventManager = new EventManager(_this);
    _this.animationManager = new EasingManager(_this);
    _this.inputObserver = new InputObserver(_this);
    _this.eventManager.setAnimationManager(_this.animationManager);
    _this.eventManager.triggerChange(_this.axisManager.get());
    return _this;
  }
  var __proto = Axes.prototype;
  Object.defineProperty(__proto, "holding", {
    /**
     * @name Axes#holding
     * @desc Returns true if at least one input is in progress.
     * @ko 입력이 하나 이상 진행 중인지 여부를 반환한다.
     *
     * @readonly
     * @type {boolean}
     * @example
     * ```js
     * const axes = new eg.Axes({
     *  x: {
     *    range: [0, 100],
     *  },
     * });
     *
     * axes.holding
     * ```
     */
    get: function () {
      return this.eventManager.holdingCount > 0;
    },
    enumerable: false,
    configurable: true
  });
  /**
   * Connect the axis of eg.Axes to the inputType.
   * @ko eg.Axes의 축과 inputType을 연결한다
   * @param {(String[]|String)} axes The name of the axis to associate with inputType <ko>inputType과 연결할 축의 이름</ko>
   * @param {Object} inputType The inputType instance to associate with the axis of eg.Axes <ko>eg.Axes의 축과 연결할 inputType 인스턴스</ko>
   * @return {eg.Axes} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>
   * @example
   * ```js
   * const axes = new eg.Axes({
   *   "x": {
   *      range: [0, 100]
   *   },
   *   "xOther": {
   *      range: [-100, 100]
   *   }
   * });
   *
   * axes.connect("x", new eg.Axes.PanInput("#area1"))
   *    .connect("x xOther", new eg.Axes.PanInput("#area2"))
   *    .connect(" xOther", new eg.Axes.PanInput("#area3"))
   *    .connect(["x"], new eg.Axes.PanInput("#area4"))
   *    .connect(["xOther", "x"], new eg.Axes.PanInput("#area5"))
   *    .connect(["", "xOther"], new eg.Axes.PanInput("#area6"));
   * ```
   */
  __proto.connect = function (axes, inputType) {
    var mapped;
    if (typeof axes === "string") {
      mapped = axes.split(" ");
    } else {
      mapped = axes.concat();
    }
    // check same instance
    if (~this._inputs.indexOf(inputType)) {
      this.disconnect(inputType);
    }
    inputType.mapAxes(mapped);
    inputType.connect(this.inputObserver);
    this._inputs.push(inputType);
    return this;
  };
  /**
   * Disconnect the axis of eg.Axes from the inputType.
   * @ko eg.Axes의 축과 inputType의 연결을 끊는다.
   * @param {Object} [inputType] An inputType instance associated with the axis of eg.Axes <ko>eg.Axes의 축과 연결한 inputType 인스턴스</ko>
   * @return {eg.Axes} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>
   * @example
   * ```js
   * const axes = new eg.Axes({
   *   "x": {
   *      range: [0, 100]
   *   },
   *   "xOther": {
   *      range: [-100, 100]
   *   }
   * });
   *
   * const input1 = new eg.Axes.PanInput("#area1");
   * const input2 = new eg.Axes.PanInput("#area2");
   * const input3 = new eg.Axes.PanInput("#area3");
   *
   * axes.connect("x", input1);
   *    .connect("x xOther", input2)
   *    .connect(["xOther", "x"], input3);
   *
   * axes.disconnect(input1); // disconnects input1
   * axes.disconnect(); // disconnects all of them
   * ```
   */
  __proto.disconnect = function (inputType) {
    if (inputType) {
      var index = this._inputs.indexOf(inputType);
      if (index >= 0) {
        this._inputs[index].disconnect();
        this._inputs.splice(index, 1);
      }
    } else {
      this._inputs.forEach(function (v) {
        return v.disconnect();
      });
      this._inputs = [];
    }
    return this;
  };
  /**
   * Returns the current position of the coordinates.
   * @ko 좌표의 현재 위치를 반환한다
   * @param {Object} [axes] The names of the axis <ko>축 이름들</ko>
   * @return {Object.<string, number>} Axis coordinate information <ko>축 좌표 정보</ko>
   * @example
   * ```js
   * const axes = new eg.Axes({
   *   "x": {
   *      range: [0, 100]
   *   },
   *   "xOther": {
   *      range: [-100, 100]
   *   },
   *    "zoom": {
   *      range: [50, 30]
   *   }
   * });
   *
   * axes.get(); // {"x": 0, "xOther": -100, "zoom": 50}
   * axes.get(["x", "zoom"]); // {"x": 0, "zoom": 50}
   * ```
   */
  __proto.get = function (axes) {
    return this.axisManager.get(axes);
  };
  /**
   * Moves an axis to specific coordinates.
   * @ko 좌표를 이동한다.
   * @param {Object.<string, number>} pos The coordinate to move to <ko>이동할 좌표</ko>
   * @param {Number} [duration=0] Duration of the animation (unit: ms) <ko>애니메이션 진행 시간(단위: ms)</ko>
   * @return {eg.Axes} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>
   * @example
   * ```js
   * const axes = new eg.Axes({
   *   "x": {
   *      range: [0, 100]
   *   },
   *   "xOther": {
   *      range: [-100, 100]
   *   },
   *    "zoom": {
   *      range: [50, 30]
   *   }
   * });
   *
   * axes.setTo({"x": 30, "zoom": 60});
   * axes.get(); // {"x": 30, "xOther": -100, "zoom": 60}
   *
   * axes.setTo({"x": 100, "xOther": 60}, 1000); // animatation
   *
   * // after 1000 ms
   * axes.get(); // {"x": 100, "xOther": 60, "zoom": 60}
   * ```
   */
  __proto.setTo = function (pos, duration) {
    if (duration === void 0) {
      duration = 0;
    }
    this.animationManager.setTo(pos, duration);
    return this;
  };
  /**
   * Moves an axis from the current coordinates to specific coordinates.
   * @ko 현재 좌표를 기준으로 좌표를 이동한다.
   * @param {Object.<string, number>} pos The coordinate to move to <ko>이동할 좌표</ko>
   * @param {Number} [duration=0] Duration of the animation (unit: ms) <ko>애니메이션 진행 시간(단위: ms)</ko>
   * @return {eg.Axes} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>
   * @example
   * ```js
   * const axes = new eg.Axes({
   *   "x": {
   *      range: [0, 100]
   *   },
   *   "xOther": {
   *      range: [-100, 100]
   *   },
   *    "zoom": {
   *      range: [50, 30]
   *   }
   * });
   *
   * axes.setBy({"x": 30, "zoom": 10});
   * axes.get(); // {"x": 30, "xOther": -100, "zoom": 60}
   *
   * axes.setBy({"x": 70, "xOther": 60}, 1000); // animatation
   *
   * // after 1000 ms
   * axes.get(); // {"x": 100, "xOther": -40, "zoom": 60}
   * ```
   */
  __proto.setBy = function (pos, duration) {
    if (duration === void 0) {
      duration = 0;
    }
    this.animationManager.setBy(pos, duration);
    return this;
  };
  /**
   * Change the options of Axes instance.
   * @ko 인스턴스의 옵션을 변경한다.
   * @param {AxesOption} options Axes options to change <ko>변경할 옵션 목록</ko>
   * @return {eg.Axes} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>
   * @example
   * ```js
   * const axes = new eg.Axes({
   *   "x": {
   *      range: [0, 100]
   *   },
   * }, {
   *   round: 10,
   * });
   *
   * axes.setTo({"x": 48});
   * axes.get(); // {"x": 50}
   *
   * axes.setOptions({
   *   round: 1,
   * });
   *
   * axes.setTo({"x": 48});
   * axes.get(); // {"x": 48}
   * ```
   */
  __proto.setOptions = function (options) {
    this.options = __assign(__assign({}, this.options), options);
    this.animationManager.setOptions(options);
    return this;
  };
  /**
   * Change the information of an existing axis.
   * @ko 존재하는 축의 정보를 변경한다.
   * @param {Object.<string, AxisOption>} axis Axis options to change <ko>변경할 축의 정보</ko>
   * @return {eg.Axes} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>
   * @example
   * ```js
   * const axes = new eg.Axes({
   *   "x": {
   *      range: [0, 100]
   *   },
   * });
   *
   * axes.setTo({"x": 150});
   * axes.get(); // {"x": 100}
   *
   * axes.setAxis({
   *   "x": {
   *      range: [0, 200]
   *   },
   * });
   *
   * axes.setTo({"x": 150});
   * axes.get(); // {"x": 150}
   * ```
   */
  __proto.setAxis = function (axis) {
    this.axisManager.setAxis(axis);
    return this;
  };
  /**
   * Stop an animation in progress.
   * @ko 재생 중인 애니메이션을 정지한다.
   * @return {eg.Axes} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>
   * @example
   * ```js
   * const axes = new eg.Axes({
   *   "x": {
   *      range: [0, 100]
   *   },
   * });
   *
   * axes.setTo({"x": 10}, 1000); // start animatation
   *
   * // after 500 ms
   * axes.stopAnimation(); // stop animation during movement.
   * ```
   */
  __proto.stopAnimation = function () {
    this.animationManager.stopAnimation();
    this.animationManager.finish(false);
    return this;
  };
  /**
   * Change the destination of an animation in progress.
   * @ko 재생 중인 애니메이션의 목적지와 진행 시간을 변경한다.
   * @param {UpdateAnimationOption} pos The coordinate to move to <ko>이동할 좌표</ko>
   * @return {eg.Axes} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>
   * @example
   * ```js
   * const axes = new eg.Axes({
   *   "x": {
   *      range: [0, 200]
   *   },
   *   "y": {
   *      range: [0, 200]
   *   }
   * });
   *
   * axes.setTo({"x": 50, "y": 50}, 1000); // trigger animation by setTo
   *
   * // after 500 ms
   * axes.updateAnimation({destPos: {"x": 100, "y": 100}}); // animation will end after 500 ms, at {"x": 100, "y": 100}
   *
   * // after 500 ms
   * axes.setTo({"x": 50, "y": 50}, 1000); // trigger animation by setTo
   *
   * // after 700 ms
   * axes.updateAnimation({destPos: {"x": 100, "y": 100}, duration: 1500, restart: true}); // this works same as axes.setTo({"x": 100, "y": 100}, 800) since restart is true.
   * ```
   */
  __proto.updateAnimation = function (options) {
    this.animationManager.updateAnimation(options);
    return this;
  };
  /**
   * Returns whether there is a coordinate in the bounce area of ​​the target axis.
   * @ko 대상 축 중 bounce영역에 좌표가 존재하는지를 반환한다
   * @param {Object} [axes] The names of the axis <ko>축 이름들</ko>
   * @return {Boolen} Whether the bounce area exists. <ko>bounce 영역 존재 여부</ko>
   * @example
   * ```js
   * const axes = new eg.Axes({
   *   "x": {
   *      range: [0, 100]
   *   },
   *   "xOther": {
   *      range: [-100, 100]
   *   },
   *    "zoom": {
   *      range: [50, 30]
   *   }
   * });
   *
   * axes.isBounceArea(["x"]);
   * axes.isBounceArea(["x", "zoom"]);
   * axes.isBounceArea();
   * ```
   */
  __proto.isBounceArea = function (axes) {
    return this.axisManager.isOutside(axes);
  };
  /**
   * Destroys properties, and events used in a module and disconnect all connections to inputTypes.
   * @ko 모듈에 사용한 속성, 이벤트를 해제한다. 모든 inputType과의 연결을 끊는다.
   */
  __proto.destroy = function () {
    this.disconnect();
    this.eventManager.destroy();
  };
  /**
   * @name VERSION
   * @desc Version info string
   * @ko 버전정보 문자열
   *
   * @constant
   * @type {String}
   * @example
   * ```js
   * eg.Axes.VERSION;  // ex) 3.3.3
   * ```
   */
  Axes.VERSION = "3.9.1";
  /* eslint-enable */
  /**
   * @name TRANSFORM
   * @desc Returns the transform attribute with CSS vendor prefixes.
   * @ko CSS vendor prefixes를 붙인 transform 속성을 반환한다.
   *
   * @constant
   * @type {String}
   * @example
   * ```js
   * eg.Axes.TRANSFORM; // "transform" or "webkitTransform"
   * ```
   */
  Axes.TRANSFORM = TRANSFORM;
  /**
   * @name DIRECTION_NONE
   * @constant
   * @type {Number}
   */
  Axes.DIRECTION_NONE = DIRECTION_NONE;
  /**
   * @name DIRECTION_LEFT
   * @constant
   * @type {Number}
   */
  Axes.DIRECTION_LEFT = DIRECTION_LEFT;
  /**
   * @name DIRECTION_RIGHT
   * @constant
   * @type {Number}
   */
  Axes.DIRECTION_RIGHT = DIRECTION_RIGHT;
  /**
   * @name DIRECTION_UP
   * @constant
   * @type {Number}
   */
  Axes.DIRECTION_UP = DIRECTION_UP;
  /**
   * @name DIRECTION_DOWN
   * @constant
   * @type {Number}
   */
  Axes.DIRECTION_DOWN = DIRECTION_DOWN;
  /**
   * @name DIRECTION_HORIZONTAL
   * @constant
   * @type {Number}
   */
  Axes.DIRECTION_HORIZONTAL = DIRECTION_HORIZONTAL;
  /**
   * @name DIRECTION_VERTICAL
   * @constant
   * @type {Number}
   */
  Axes.DIRECTION_VERTICAL = DIRECTION_VERTICAL;
  /**
   * @name DIRECTION_ALL
   * @constant
   * @type {Number}
   */
  Axes.DIRECTION_ALL = DIRECTION_ALL;
  __decorate([Computed], Axes.prototype, "holding", null);
  Axes = __decorate([ReactiveSubscribe], Axes);
  return Axes;
}(Component);

/*
 * Copyright (c) 2015 NAVER Corp.
 * egjs projects are licensed under the MIT license
 */
// get user's direction
var getDirectionByAngle = function (angle, thresholdAngle) {
  if (thresholdAngle < 0 || thresholdAngle > 90) {
    return DIRECTION_NONE;
  }
  var toAngle = Math.abs(angle);
  return toAngle > thresholdAngle && toAngle < 180 - thresholdAngle ? DIRECTION_VERTICAL : DIRECTION_HORIZONTAL;
};
/**
 * @typedef {Object} PanInputOption The option object of the eg.Axes.PanInput module.
 * @ko eg.Axes.PanInput 모듈의 옵션 객체
 * @param {String[]} [inputType=["touch", "mouse", "pointer"]] Types of input devices
 * - touch: Touch screen
 * - mouse: Mouse
 * - pointer: Mouse and touch <ko>입력 장치 종류
 * - touch: 터치 입력 장치
 * - mouse: 마우스
 * - pointer: 마우스 및 터치</ko>
 * @param {String[]} [inputKey=["any"]] List of key combinations to allow input
 * - any: any key
 * - shift: shift key
 * - ctrl: ctrl key and pinch gesture on the trackpad
 * - alt: alt key
 * - meta: meta key
 * - none: none of these keys are pressed <ko>입력을 허용할 키 조합 목록
 * - any: 아무 키
 * - shift: shift 키
 * - ctrl: ctrl 키 및 트랙패드의 pinch 제스쳐
 * - alt: alt 키
 * - meta: meta 키
 * - none: 아무 키도 눌리지 않은 상태 </ko>
 * @param {String[]} [inputButton=["left"]] List of buttons to allow input
 * - left: Left mouse button and normal touch
 * - middle: Mouse wheel press
 * - right: Right mouse button <ko>입력을 허용할 버튼 목록
 * - left: 마우스 왼쪽 버튼
 * - middle: 마우스 휠 눌림
 * - right: 마우스 오른쪽 버튼 </ko>
 * @param {Number[]} [scale] Coordinate scale that a user can move<ko>사용자의 동작으로 이동하는 좌표의 배율</ko>
 * @param {Number} [scale[0]=1] horizontal axis scale <ko>수평축 배율</ko>
 * @param {Number} [scale[1]=1] vertical axis scale <ko>수직축 배율</ko>
 * @param {Number} [thresholdAngle=45] The threshold value that determines whether user action is horizontal or vertical (0~90) <ko>사용자의 동작이 가로 방향인지 세로 방향인지 판단하는 기준 각도(0~90)</ko>
 * @param {Number} [threshold=0] Minimal pan distance required before recognizing <ko>사용자의 Pan 동작을 인식하기 위해산 최소한의 거리</ko>
 * @param {Boolean} [preventClickOnDrag=false] Whether to cancel the {@link https://developer.mozilla.org/en/docs/Web/API/Element/click_event click} event when the user finishes dragging more than 1 pixel <ko>사용자가 1픽셀 이상 드래그를 마쳤을 때 {@link https://developer.mozilla.org/ko/docs/Web/API/Element/click_event click} 이벤트 취소 여부</ko>
 * @param {Boolean} [preventDefaultOnDrag=false] Whether to use the {@link https://developer.mozilla.org/ko/docs/Web/API/Event/preventDefault preventDefault} when the user starts dragging <ko>사용자가 드래그를 시작할 때 {@link https://developer.mozilla.org/ko/docs/Web/API/Event/preventDefault preventDefault} 실행 여부</ko>
 * @param {Number} [iOSEdgeSwipeThreshold=30] Area (px) that can go to the next page when swiping the right edge in iOS safari <ko>iOS Safari에서 오른쪽 엣지를 스와이프 하는 경우 다음 페이지로 넘어갈 수 있는 영역(px)</ko>
 * @param {String} [touchAction=null] Value that overrides the element's "touch-action" css property. If set to null, it is automatically set to prevent scrolling in the direction of the connected axis. <ko>엘리먼트의 "touch-action" CSS 속성을 덮어쓰는 값. 만약 null로 설정된 경우, 연결된 축 방향으로의 스크롤을 방지하게끔 자동으로 설정된다.</ko>
 **/
/**
 * A module that passes the amount of change to eg.Axes when the mouse or touchscreen is down and moved. use less than two axes.
 * @ko 마우스나 터치 스크린을 누르고 움직일때의 변화량을 eg.Axes에 전달하는 모듈. 두개 이하의 축을 사용한다.
 *
 * @example
 * ```js
 * const pan = new eg.Axes.PanInput("#area", {
 *     inputType: ["touch"],
 *     scale: [1, 1.3],
 * });
 *
 * // Connect the 'something2' axis to the mouse or touchscreen x position when the mouse or touchscreen is down and moved.
 * // Connect the 'somethingN' axis to the mouse or touchscreen y position when the mouse or touchscreen is down and moved.
 * axes.connect(["something2", "somethingN"], pan); // or axes.connect("something2 somethingN", pan);
 *
 * // Connect only one 'something1' axis to the mouse or touchscreen x position when the mouse or touchscreen is down and moved.
 * axes.connect(["something1"], pan); // or axes.connect("something1", pan);
 *
 * // Connect only one 'something2' axis to the mouse or touchscreen y position when the mouse or touchscreen is down and moved.
 * axes.connect(["", "something2"], pan); // or axes.connect(" something2", pan);
 * ```
 * @param {String|HTMLElement|Ref<HTMLElement>|jQuery} element An element to use the eg.Axes.PanInput module <ko>eg.Axes.PanInput 모듈을 사용할 엘리먼트</ko>
 * @param {PanInputOption} [options={}] The option object of the eg.Axes.PanInput module<ko>eg.Axes.PanInput 모듈의 옵션 객체</ko>
 */
var PanInput = /*#__PURE__*/function () {
  /**
   *
   */
  function PanInput(el, options) {
    var _this = this;
    this.axes = [];
    this.element = null;
    this._enabled = false;
    this._activeEvent = null;
    this._atRightEdge = false;
    this._rightEdgeTimer = 0;
    this._dragged = false;
    this._isOverThreshold = false;
    this._preventClickWhenDragged = function (e) {
      if (_this._dragged) {
        e.preventDefault();
        e.stopPropagation();
      }
      _this._dragged = false;
    };
    this._voidFunction = function () {};
    this.element = $$1(el);
    this.options = __assign({
      inputType: ["touch", "mouse", "pointer"],
      inputKey: [ANY],
      inputButton: [MOUSE_LEFT],
      scale: [1, 1],
      thresholdAngle: 45,
      threshold: 0,
      preventClickOnDrag: false,
      preventDefaultOnDrag: false,
      iOSEdgeSwipeThreshold: IOS_EDGE_THRESHOLD,
      releaseOnScroll: false,
      touchAction: null
    }, options);
    this._onPanstart = this._onPanstart.bind(this);
    this._onPanmove = this._onPanmove.bind(this);
    this._onPanend = this._onPanend.bind(this);
  }
  var __proto = PanInput.prototype;
  __proto.mapAxes = function (axes) {
    this._direction = getDirection(!!axes[0], !!axes[1]);
    this.axes = axes;
  };
  __proto.connect = function (observer) {
    if (this._activeEvent) {
      this._detachElementEvent();
      this._detachWindowEvent(this._activeEvent);
    }
    this._attachElementEvent(observer);
    return this;
  };
  __proto.disconnect = function () {
    this._detachElementEvent();
    this._detachWindowEvent(this._activeEvent);
    this._direction = DIRECTION_NONE;
    return this;
  };
  /**
   * Destroys elements, properties, and events used in a module.
   * @ko 모듈에 사용한 엘리먼트와 속성, 이벤트를 해제한다.
   */
  __proto.destroy = function () {
    this.disconnect();
    this.element = null;
  };
  /**
   * Enables input devices
   * @ko 입력 장치를 사용할 수 있게 한다
   * @return {PanInput} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>
   */
  __proto.enable = function () {
    if (!this._enabled) {
      this._enabled = true;
      this._originalCssProps = setCssProps(this.element, this.options, this._direction);
    }
    return this;
  };
  /**
   * Disables input devices
   * @ko 입력 장치를 사용할 수 없게 한다.
   * @return {PanInput} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>
   */
  __proto.disable = function () {
    if (this._enabled) {
      this._enabled = false;
      if (!isCssPropsFromAxes(this._originalCssProps)) {
        revertCssProps(this.element, this._originalCssProps);
      }
    }
    return this;
  };
  /**
   * Returns whether to use an input device
   * @ko 입력 장치 사용 여부를 반환한다.
   * @return {Boolean} Whether to use an input device <ko>입력장치 사용여부</ko>
   */
  __proto.isEnabled = function () {
    return this._enabled;
  };
  /**
   * Releases current user input.
   * @ko 사용자의 입력을 강제로 중단시킨다.
   * @return {PanInput} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>
   */
  __proto.release = function () {
    var activeEvent = this._activeEvent;
    var prevEvent = activeEvent.prevEvent;
    activeEvent.onRelease();
    this._observer.release(this, prevEvent, [0, 0]);
    this._detachWindowEvent(activeEvent);
    return this;
  };
  __proto._onPanstart = function (event) {
    var _a = this.options,
      inputKey = _a.inputKey,
      inputButton = _a.inputButton,
      preventDefaultOnDrag = _a.preventDefaultOnDrag;
    var activeEvent = this._activeEvent;
    var panEvent = activeEvent.onEventStart(event, inputKey, inputButton);
    if (!panEvent || !this._enabled || activeEvent.getTouches(event, inputButton) > 1) {
      return;
    }
    if (panEvent.srcEvent.cancelable !== false) {
      var edgeThreshold = this.options.iOSEdgeSwipeThreshold;
      this._dragged = false;
      this._isOverThreshold = false;
      this._observer.hold(this, panEvent);
      this._atRightEdge = IS_IOS_SAFARI && panEvent.center.x > window.innerWidth - edgeThreshold;
      this._attachWindowEvent(activeEvent);
      preventDefaultOnDrag && panEvent.srcEvent.type !== "touchstart" && panEvent.srcEvent.preventDefault();
      activeEvent.prevEvent = panEvent;
    }
  };
  __proto._onPanmove = function (event) {
    var _this = this;
    var _a = this.options,
      iOSEdgeSwipeThreshold = _a.iOSEdgeSwipeThreshold,
      preventClickOnDrag = _a.preventClickOnDrag,
      releaseOnScroll = _a.releaseOnScroll,
      inputKey = _a.inputKey,
      inputButton = _a.inputButton,
      threshold = _a.threshold,
      thresholdAngle = _a.thresholdAngle;
    var activeEvent = this._activeEvent;
    var panEvent = activeEvent.onEventMove(event, inputKey, inputButton);
    var touches = activeEvent.getTouches(event, inputButton);
    if (touches === 0 || releaseOnScroll && panEvent && !panEvent.srcEvent.cancelable) {
      this._onPanend(event);
      return;
    }
    if (!panEvent || !this._enabled || touches > 1) {
      return;
    }
    var userDirection = getDirectionByAngle(panEvent.angle, thresholdAngle);
    var useHorizontal = useDirection(DIRECTION_HORIZONTAL, this._direction, userDirection);
    var useVertical = useDirection(DIRECTION_VERTICAL, this._direction, userDirection);
    if (activeEvent.prevEvent && IS_IOS_SAFARI) {
      var swipeLeftToRight = panEvent.center.x < 0;
      if (swipeLeftToRight) {
        // iOS swipe left => right
        this.release();
        return;
      } else if (this._atRightEdge) {
        clearTimeout(this._rightEdgeTimer);
        // - is right to left
        var swipeRightToLeft = panEvent.deltaX < -iOSEdgeSwipeThreshold;
        if (swipeRightToLeft) {
          this._atRightEdge = false;
        } else {
          // iOS swipe right => left
          this._rightEdgeTimer = window.setTimeout(function () {
            return _this.release();
          }, 100);
        }
      }
    }
    var distance = this._getDistance([panEvent.deltaX, panEvent.deltaY], [useHorizontal, useVertical]);
    var offset = this._getOffset([panEvent.offsetX, panEvent.offsetY], [useHorizontal, useVertical]);
    var prevent = offset.some(function (v) {
      return v !== 0;
    });
    if (prevent) {
      if (panEvent.srcEvent.cancelable !== false) {
        panEvent.srcEvent.preventDefault();
      }
      panEvent.srcEvent.stopPropagation();
    }
    panEvent.preventSystemEvent = prevent;
    if (prevent && (this._isOverThreshold || distance >= threshold)) {
      this._dragged = preventClickOnDrag;
      this._isOverThreshold = true;
      this._observer.change(this, panEvent, toAxis(this.axes, offset));
    }
    activeEvent.prevEvent = panEvent;
  };
  __proto._onPanend = function (event) {
    var inputButton = this.options.inputButton;
    var activeEvent = this._activeEvent;
    activeEvent.onEventEnd(event);
    if (!this._enabled || activeEvent.getTouches(event, inputButton) !== 0) {
      return;
    }
    this._detachWindowEvent(activeEvent);
    clearTimeout(this._rightEdgeTimer);
    var prevEvent = activeEvent.prevEvent;
    var velocity = this._isOverThreshold ? this._getOffset([Math.abs(prevEvent.velocityX) * (prevEvent.offsetX < 0 ? -1 : 1), Math.abs(prevEvent.velocityY) * (prevEvent.offsetY < 0 ? -1 : 1)], [useDirection(DIRECTION_HORIZONTAL, this._direction), useDirection(DIRECTION_VERTICAL, this._direction)]) : [0, 0];
    activeEvent.onRelease();
    this._observer.release(this, prevEvent, velocity);
  };
  __proto._attachWindowEvent = function (activeEvent) {
    var _this = this;
    activeEvent === null || activeEvent === void 0 ? void 0 : activeEvent.move.forEach(function (event) {
      window.addEventListener(event, _this._onPanmove, getAddEventOptions(event));
    });
    activeEvent === null || activeEvent === void 0 ? void 0 : activeEvent.end.forEach(function (event) {
      window.addEventListener(event, _this._onPanend, getAddEventOptions(event));
    });
  };
  __proto._detachWindowEvent = function (activeEvent) {
    var _this = this;
    activeEvent === null || activeEvent === void 0 ? void 0 : activeEvent.move.forEach(function (event) {
      window.removeEventListener(event, _this._onPanmove);
    });
    activeEvent === null || activeEvent === void 0 ? void 0 : activeEvent.end.forEach(function (event) {
      window.removeEventListener(event, _this._onPanend);
    });
  };
  __proto._getOffset = function (properties, direction) {
    var scale = this.options.scale;
    return [direction[0] ? properties[0] * scale[0] : 0, direction[1] ? properties[1] * scale[1] : 0];
  };
  __proto._getDistance = function (delta, direction) {
    return Math.sqrt(Number(direction[0]) * Math.pow(delta[0], 2) + Number(direction[1]) * Math.pow(delta[1], 2));
  };
  __proto._attachElementEvent = function (observer) {
    var _this = this;
    var activeEvent = convertInputType(this.options.inputType);
    var element = this.element;
    if (!activeEvent) {
      return;
    }
    if (!element) {
      throw new Error("Element to connect input does not exist.");
    }
    this._observer = observer;
    this.enable();
    this._activeEvent = activeEvent;
    element.addEventListener("click", this._preventClickWhenDragged, true);
    activeEvent.start.forEach(function (event) {
      element.addEventListener(event, _this._onPanstart);
    });
    // adding event listener to element prevents invalid behavior in iOS Safari
    activeEvent.move.forEach(function (event) {
      element.addEventListener(event, _this._voidFunction);
    });
  };
  __proto._detachElementEvent = function () {
    var _this = this;
    var activeEvent = this._activeEvent;
    var element = this.element;
    if (element) {
      element.removeEventListener("click", this._preventClickWhenDragged, true);
      activeEvent === null || activeEvent === void 0 ? void 0 : activeEvent.start.forEach(function (event) {
        element.removeEventListener(event, _this._onPanstart);
      });
      activeEvent === null || activeEvent === void 0 ? void 0 : activeEvent.move.forEach(function (event) {
        element.removeEventListener(event, _this._voidFunction);
      });
    }
    this.disable();
    this._observer = null;
  };
  return PanInput;
}();

/*
Copyright (c) 2020-present NAVER Corp.
name: @egjs/imready
license: MIT
author: NAVER Corp.
repository: https://github.com/naver/egjs-imready
version: 1.3.1
*/

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

/* global Reflect, Promise */
var extendStatics$2 = function (d, b) {
  extendStatics$2 = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
  };

  return extendStatics$2(d, b);
};

function __extends$2(d, b) {
  extendStatics$2(d, b);

  function __() {
    this.constructor = d;
  }

  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign$1 = function () {
  __assign$1 = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign$1.apply(this, arguments);
};
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;

  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];

  return r;
}

/*
egjs-imready
Copyright (c) 2020-present NAVER Corp.
MIT license
*/
var isWindow = typeof window !== "undefined";
var ua = isWindow ? window.navigator.userAgent : "";
var SUPPORT_COMPUTEDSTYLE = isWindow ? !!("getComputedStyle" in window) : false;
var IS_IE = /MSIE|Trident|Windows Phone|Edge/.test(ua);
var SUPPORT_ADDEVENTLISTENER = isWindow ? !!("addEventListener" in document) : false;
var WIDTH = "width";
var HEIGHT = "height";

function getAttribute(el, name) {
  return el.getAttribute(name) || "";
}
function toArray$1(arr) {
  return [].slice.call(arr);
}
function hasSizeAttribute(target, prefix) {
  if (prefix === void 0) {
    prefix = "data-";
  }

  return !!target.getAttribute(prefix + "width");
}
function hasLoadingAttribute(target, prefix) {
  if (prefix === void 0) {
    prefix = "data-";
  }

  return "loading" in target && target.getAttribute("loading") === "lazy" || !!target.getAttribute(prefix + "lazy");
}
function hasSkipAttribute(target, prefix) {
  if (prefix === void 0) {
    prefix = "data-";
  }

  return !!target.getAttribute(prefix + "skip");
}
function addEvent(element, type, handler) {
  if (SUPPORT_ADDEVENTLISTENER) {
    element.addEventListener(type, handler, false);
  } else if (element.attachEvent) {
    element.attachEvent("on" + type, handler);
  } else {
    element["on" + type] = handler;
  }
}
function removeEvent(element, type, handler) {
  if (element.removeEventListener) {
    element.removeEventListener(type, handler, false);
  } else if (element.detachEvent) {
    element.detachEvent("on" + type, handler);
  } else {
    element["on" + type] = null;
  }
}
function innerWidth(el) {
  return getSize(el, "Width");
}
function innerHeight(el) {
  return getSize(el, "Height");
}
function getStyles(el) {
  return (SUPPORT_COMPUTEDSTYLE ? window.getComputedStyle(el) : el.currentStyle) || {};
}

function getSize(el, name) {
  var size = el["client" + name] || el["offset" + name];
  return parseFloat(size || getStyles(el)[name.toLowerCase()]) || 0;
}

function getContentElements(element, tags, prefix) {
  var skipElements = toArray$1(element.querySelectorAll(__spreadArrays(["[" + prefix + "skip] [" + prefix + "width]"], tags.map(function (tag) {
    return ["[" + prefix + "skip] " + tag, tag + "[" + prefix + "skip]", "[" + prefix + "width] " + tag].join(", ");
  })).join(", ")));
  return toArray$1(element.querySelectorAll("[" + prefix + "width], " + tags.join(", "))).filter(function (el) {
    return skipElements.indexOf(el) === -1;
  });
}

/*
egjs-imready
Copyright (c) 2020-present NAVER Corp.
MIT license
*/
var elements = [];
function addAutoSizer(element, prefix) {
  !elements.length && addEvent(window, "resize", resizeAllAutoSizers);
  element.__PREFIX__ = prefix;
  elements.push(element);
  resize(element);
}
function removeAutoSizer(element, prefix) {
  var index = elements.indexOf(element);

  if (index < 0) {
    return;
  }

  var fixed = getAttribute(element, prefix + "fixed");
  delete element.__PREFIX__;
  element.style[fixed === HEIGHT ? WIDTH : HEIGHT] = "";
  elements.splice(index, 1);
  !elements.length && removeEvent(window, "resize", resizeAllAutoSizers);
}

function resize(element, prefix) {
  if (prefix === void 0) {
    prefix = "data-";
  }

  var elementPrefix = element.__PREFIX__ || prefix;
  var dataWidth = parseInt(getAttribute(element, "" + elementPrefix + WIDTH), 10) || 0;
  var dataHeight = parseInt(getAttribute(element, "" + elementPrefix + HEIGHT), 10) || 0;
  var fixed = getAttribute(element, elementPrefix + "fixed");

  if (fixed === HEIGHT) {
    var size = innerHeight(element) || dataHeight;
    element.style[WIDTH] = dataWidth / dataHeight * size + "px";
  } else {
    var size = innerWidth(element) || dataWidth;
    element.style[HEIGHT] = dataHeight / dataWidth * size + "px";
  }
}

function resizeAllAutoSizers() {
  elements.forEach(function (element) {
    resize(element);
  });
}

var Loader =
/*#__PURE__*/
function (_super) {
  __extends$2(Loader, _super);

  function Loader(element, options) {
    if (options === void 0) {
      options = {};
    }

    var _this = _super.call(this) || this;

    _this.isReady = false;
    _this.isPreReady = false;
    _this.hasDataSize = false;
    _this.hasLoading = false;
    _this.isSkip = false;

    _this.onCheck = function (e) {
      _this.clear();

      if (e && e.type === "error") {
        _this.onError(_this.element);
      }

      if (_this.hasLoading && _this.checkElement()) {
        // I'm not ready
        return;
      } // I'm pre-ready and ready!


      var withPreReady = !_this.hasDataSize && !_this.hasLoading;

      _this.onReady(withPreReady);
    };

    _this.options = __assign$1({
      prefix: "data-"
    }, options);
    _this.element = element;
    var prefix = _this.options.prefix;
    _this.hasDataSize = hasSizeAttribute(element, prefix);
    _this.isSkip = hasSkipAttribute(element, prefix);
    _this.hasLoading = hasLoadingAttribute(element, prefix);
    return _this;
  }

  var __proto = Loader.prototype;

  __proto.check = function () {
    if (this.isSkip || !this.checkElement()) {
      // I'm Ready
      this.onAlreadyReady(true);
      return false;
    }

    if (this.hasDataSize) {
      addAutoSizer(this.element, this.options.prefix);
    }

    if (this.hasDataSize || this.hasLoading) {
      // I'm Pre Ready
      this.onAlreadyPreReady();
    } // Wati Pre Ready, Ready


    return true;
  };

  __proto.addEvents = function () {
    var _this = this;

    var element = this.element;
    this.constructor.EVENTS.forEach(function (name) {
      addEvent(element, name, _this.onCheck);
    });
  };

  __proto.clear = function () {
    var _this = this;

    var element = this.element;
    this.constructor.EVENTS.forEach(function (name) {
      removeEvent(element, name, _this.onCheck);
    });
    this.removeAutoSizer();
  };

  __proto.destroy = function () {
    this.clear();
    this.off();
  };

  __proto.removeAutoSizer = function () {
    if (this.hasDataSize) {
      // I'm already ready.
      var prefix = this.options.prefix;
      removeAutoSizer(this.element, prefix);
    }
  };

  __proto.onError = function (target) {
    this.trigger("error", {
      element: this.element,
      target: target
    });
  };

  __proto.onPreReady = function () {
    if (this.isPreReady) {
      return;
    }

    this.isPreReady = true;
    this.trigger("preReady", {
      element: this.element,
      hasLoading: this.hasLoading,
      isSkip: this.isSkip
    });
  };

  __proto.onReady = function (withPreReady) {
    if (this.isReady) {
      return;
    }

    withPreReady = !this.isPreReady && withPreReady;

    if (withPreReady) {
      this.isPreReady = true;
    }

    this.removeAutoSizer();
    this.isReady = true;
    this.trigger("ready", {
      element: this.element,
      withPreReady: withPreReady,
      hasLoading: this.hasLoading,
      isSkip: this.isSkip
    });
  };

  __proto.onAlreadyError = function (target) {
    var _this = this;

    setTimeout(function () {
      _this.onError(target);
    });
  };

  __proto.onAlreadyPreReady = function () {
    var _this = this;

    setTimeout(function () {
      _this.onPreReady();
    });
  };

  __proto.onAlreadyReady = function (withPreReady) {
    var _this = this;

    setTimeout(function () {
      _this.onReady(withPreReady);
    });
  };

  Loader.EVENTS = [];
  return Loader;
}(Component);

var ElementLoader =
/*#__PURE__*/
function (_super) {
  __extends$2(ElementLoader, _super);

  function ElementLoader() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  var __proto = ElementLoader.prototype;

  __proto.setHasLoading = function (hasLoading) {
    this.hasLoading = hasLoading;
  };

  __proto.check = function () {
    if (this.isSkip) {
      // I'm Ready
      this.onAlreadyReady(true);
      return false;
    }

    if (this.hasDataSize) {
      addAutoSizer(this.element, this.options.prefix);
      this.onAlreadyPreReady();
    } else {
      // has not data size
      this.trigger("requestChildren");
    }

    return true;
  };

  __proto.checkElement = function () {
    return true;
  };

  __proto.destroy = function () {
    this.clear();
    this.trigger("requestDestroy");
    this.off();
  };

  __proto.onAlreadyPreReady = function () {
    // has data size
    _super.prototype.onAlreadyPreReady.call(this);

    this.trigger("reqeustReadyChildren");
  };

  ElementLoader.EVENTS = [];
  return ElementLoader;
}(Loader);

/**
 * @alias eg.ImReady
 * @extends eg.Component
 */

var ImReadyManager =
/*#__PURE__*/
function (_super) {
  __extends$2(ImReadyManager, _super);
  /**
   * @param - ImReady's options
   */


  function ImReadyManager(options) {
    if (options === void 0) {
      options = {};
    }

    var _this = _super.call(this) || this;

    _this.readyCount = 0;
    _this.preReadyCount = 0;
    _this.totalCount = 0;
    _this.totalErrorCount = 0;
    _this.isPreReadyOver = true;
    _this.elementInfos = [];
    _this.options = __assign$1({
      loaders: {},
      prefix: "data-"
    }, options);
    return _this;
  }
  /**
   * Checks whether elements are in the ready state.
   * @ko 엘리먼트가 준비 상태인지 체크한다.
   * @elements - Elements to check ready status. <ko> 준비 상태를 체크할 엘리먼트들.</ko>
   * @example
     * ```html
     * <div>
     *    <img src="./1.jpg" data-width="1280" data-height="853" style="width:100%"/>
     *    <img src="./2.jpg" data-width="1280" data-height="853"/>
     *    <img src="ERR" data-width="1280" data-height="853"/>
     * </div>
     * ```
     * ## Javascript
     * ```js
     * import ImReady from "@egjs/imready";
     *
     * const im = new ImReady(); // umd: eg.ImReady
     * im.check(document.querySelectorAll("img")).on({
     *   preReadyElement: e => {
     *     // 1, 3
     *     // 2, 3
     *     // 3, 3
     *     console.log(e.preReadyCount, e.totalCount),
     *   },
     * });
     * ```
   */


  var __proto = ImReadyManager.prototype;

  __proto.check = function (elements) {
    var _this = this;

    var prefix = this.options.prefix;
    this.clear();
    this.elementInfos = toArray$1(elements).map(function (element, index) {
      var loader = _this.getLoader(element, {
        prefix: prefix
      });

      loader.check();
      loader.on("error", function (e) {
        _this.onError(index, e.target);
      }).on("preReady", function (e) {
        var info = _this.elementInfos[index];
        info.hasLoading = e.hasLoading;
        info.isSkip = e.isSkip;

        var isPreReady = _this.checkPreReady(index);

        _this.onPreReadyElement(index);

        isPreReady && _this.onPreReady();
      }).on("ready", function (_a) {
        var withPreReady = _a.withPreReady,
            hasLoading = _a.hasLoading,
            isSkip = _a.isSkip;
        var info = _this.elementInfos[index];
        info.hasLoading = hasLoading;
        info.isSkip = isSkip;

        var isPreReady = withPreReady && _this.checkPreReady(index);

        var isReady = _this.checkReady(index); // Pre-ready and ready occur simultaneously


        withPreReady && _this.onPreReadyElement(index);

        _this.onReadyElement(index);

        isPreReady && _this.onPreReady();
        isReady && _this.onReady();
      });
      return {
        loader: loader,
        element: element,
        hasLoading: false,
        hasError: false,
        isPreReady: false,
        isReady: false,
        isSkip: false
      };
    });
    var length = this.elementInfos.length;
    this.totalCount = length;

    if (!length) {
      setTimeout(function () {
        _this.onPreReady();

        _this.onReady();
      });
    }

    return this;
  };
  /**
   * Gets the total count of elements to be checked.
   * @ko 체크하는 element의 총 개수를 가져온다.
   */


  __proto.getTotalCount = function () {
    return this.totalCount;
  };
  /**
   * Whether the elements are all pre-ready. (all sizes are known)
   * @ko 엘리먼트들이 모두 사전 준비가 됐는지 (사이즈를 전부 알 수 있는지) 여부.
   */


  __proto.isPreReady = function () {
    return this.elementInfos.every(function (info) {
      return info.isPreReady;
    });
  };
  /**
   * Whether the elements are all ready.
   * @ko 엘리먼트들이 모두 준비가 됐는지 여부.
   */


  __proto.isReady = function () {
    return this.elementInfos.every(function (info) {
      return info.isReady;
    });
  };
  /**
   * Whether an error has occurred in the elements in the current state.
   * @ko 현재 상태에서 엘리먼트들이 에러가 발생했는지 여부.
   */


  __proto.hasError = function () {
    return this.totalErrorCount > 0;
  };
  /**
   * Clears events of elements being checked.
   * @ko 체크 중인 엘리먼트들의 이벤트를 해제 한다.
   */


  __proto.clear = function () {
    this.isPreReadyOver = false;
    this.totalCount = 0;
    this.preReadyCount = 0;
    this.readyCount = 0;
    this.totalErrorCount = 0;
    this.elementInfos.forEach(function (info) {
      if (info.loader) {
        info.loader.destroy();
      }
    });
    this.elementInfos = [];
  };
  /**
   * Destory all events.
   * @ko 모든 이벤트를 해제 한다.
   */


  __proto.destroy = function () {
    this.clear();
    this.off();
  };

  __proto.getLoader = function (element, options) {
    var _this = this;

    var tagName = element.tagName.toLowerCase();
    var loaders = this.options.loaders;
    var prefix = options.prefix;
    var tags = Object.keys(loaders);

    if (loaders[tagName]) {
      return new loaders[tagName](element, options);
    }

    var loader = new ElementLoader(element, options);
    var children = toArray$1(element.querySelectorAll(tags.join(", ")));
    loader.setHasLoading(children.some(function (el) {
      return hasLoadingAttribute(el, prefix);
    }));
    var withPreReady = false;
    var childrenImReady = this.clone().on("error", function (e) {
      loader.onError(e.target);
    }).on("ready", function () {
      loader.onReady(withPreReady);
    });
    loader.on("requestChildren", function () {
      // has not data size
      var contentElements = getContentElements(element, tags, _this.options.prefix);
      childrenImReady.check(contentElements).on("preReady", function (e) {
        withPreReady = e.isReady;

        if (!withPreReady) {
          loader.onPreReady();
        }
      });
    }).on("reqeustReadyChildren", function () {
      // has data size
      // loader call preReady
      // check only video, image elements
      childrenImReady.check(children);
    }).on("requestDestroy", function () {
      childrenImReady.destroy();
    });
    return loader;
  };

  __proto.clone = function () {
    return new ImReadyManager(__assign$1({}, this.options));
  };

  __proto.checkPreReady = function (index) {
    this.elementInfos[index].isPreReady = true;
    ++this.preReadyCount;

    if (this.preReadyCount < this.totalCount) {
      return false;
    }

    return true;
  };

  __proto.checkReady = function (index) {
    this.elementInfos[index].isReady = true;
    ++this.readyCount;

    if (this.readyCount < this.totalCount) {
      return false;
    }

    return true;
  };

  __proto.onError = function (index, target) {
    var info = this.elementInfos[index];
    info.hasError = true;
    /**
     * An event occurs if the image, video fails to load.
     * @ko 이미지, 비디오가 로딩에 실패하면 이벤트가 발생한다.
     * @event eg.ImReady#error
     * @param {eg.ImReady.OnError} e - The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>
     * @example
     * ```html
     * <div>
     *    <img src="./1.jpg" data-width="1280" data-height="853" style="width:100%"/>
     *    <img src="./2.jpg"/>
     *    <img src="ERR"/>
     * </div>
     * ```
     * ## Javascript
     * ```js
     * import ImReady from "@egjs/imready";
     *
     * const im = new ImReady(); // umd: eg.ImReady
     * im.check([document.querySelector("div")]).on({
     *   error: e => {
     *     // <div>...</div>, 0, <img src="ERR"/>
     *     console.log(e.element, e.index, e.target),
     *   },
     * });
     * ```
     */

    this.trigger(new ComponentEvent$1("error", {
      element: info.element,
      index: index,
      target: target,
      errorCount: this.getErrorCount(),
      totalErrorCount: ++this.totalErrorCount
    }));
  };

  __proto.onPreReadyElement = function (index) {
    var info = this.elementInfos[index];
    /**
     * An event occurs when the element is pre-ready (when the loading attribute is applied or the size is known)
     * @ko 해당 엘리먼트가 사전 준비되었을 때(loading 속성이 적용되었거나 사이즈를 알 수 있을 때) 이벤트가 발생한다.
     * @event eg.ImReady#preReadyElement
     * @param {eg.ImReady.OnPreReadyElement} e - The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>
     * @example
     * ```html
     * <div>
     *    <img src="./1.jpg" data-width="1280" data-height="853" style="width:100%"/>
     *    <img src="./2.jpg" data-width="1280" data-height="853"/>
     *    <img src="ERR" data-width="1280" data-height="853"/>
     * </div>
     * ```
     * ## Javascript
     * ```js
     * import ImReady from "@egjs/imready";
     *
     * const im = new ImReady(); // umd: eg.ImReady
     * im.check(document.querySelectorAll("img")).on({
     *   preReadyElement: e => {
     *     // 1, 3
     *     // 2, 3
     *     // 3, 3
     *     console.log(e.preReadyCount, e.totalCount),
     *   },
     * });
     * ```
     */

    this.trigger(new ComponentEvent$1("preReadyElement", {
      element: info.element,
      index: index,
      preReadyCount: this.preReadyCount,
      readyCount: this.readyCount,
      totalCount: this.totalCount,
      isPreReady: this.isPreReady(),
      isReady: this.isReady(),
      hasLoading: info.hasLoading,
      isSkip: info.isSkip
    }));
  };

  __proto.onPreReady = function () {
    this.isPreReadyOver = true;
    /**
     * An event occurs when all element are pre-ready (When all elements have the loading attribute applied or the size is known)
     * @ko 모든 엘리먼트들이 사전 준비된 경우 (모든 엘리먼트들이 loading 속성이 적용되었거나 사이즈를 알 수 있는 경우) 이벤트가 발생한다.
     * @event eg.ImReady#preReady
     * @param {eg.ImReady.OnPreReady} e - The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>
     * @example
     * ```html
     * <div>
     *    <img src="./1.jpg" data-width="1280" data-height="853" style="width:100%"/>
     *    <img src="./2.jpg" data-width="1280" data-height="853"/>
     *    <img src="ERR" data-width="1280" data-height="853"/>
     * </div>
     * ```
     * ## Javascript
     * ```js
     * import ImReady from "@egjs/imready";
     *
     * const im = new ImReady(); // umd: eg.ImReady
     * im.check(document.querySelectorAll("img")).on({
     *   preReady: e => {
     *     // 0, 3
     *     console.log(e.readyCount, e.totalCount),
     *   },
     * });
     * ```
     */

    this.trigger(new ComponentEvent$1("preReady", {
      readyCount: this.readyCount,
      totalCount: this.totalCount,
      isReady: this.isReady(),
      hasLoading: this.hasLoading()
    }));
  };

  __proto.onReadyElement = function (index) {
    var info = this.elementInfos[index];
    /**
     * An event occurs when the element is ready
     * @ko 해당 엘리먼트가 준비가 되었을 때 이벤트가 발생한다.
     * @event eg.ImReady#readyElement
     * @param {eg.ImReady.OnReadyElement} e - The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>
     * @example
     * ```html
     * <div>
     *    <img src="./1.jpg" data-width="1280" data-height="853" style="width:100%"/>
     *    <img src="./2.jpg" data-width="1280" data-height="853"/>
     *    <img src="ERR" data-width="1280" data-height="853"/>
     * </div>
     * ```
     * ## Javascript
     * ```js
     * import ImReady from "@egjs/imready";
     *
     * const im = new ImReady(); // umd: eg.ImReady
     * im.check(document.querySelectorAll("img")).on({
     *   readyElement: e => {
     *     // 1, 0, false, 3
     *     // 2, 1, false, 3
     *     // 3, 2, true, 3
     *     console.log(e.readyCount, e.index, e.hasError, e.totalCount),
     *   },
     * });
     * ```
     */

    this.trigger(new ComponentEvent$1("readyElement", {
      index: index,
      element: info.element,
      hasError: info.hasError,
      errorCount: this.getErrorCount(),
      totalErrorCount: this.totalErrorCount,
      preReadyCount: this.preReadyCount,
      readyCount: this.readyCount,
      totalCount: this.totalCount,
      isPreReady: this.isPreReady(),
      isReady: this.isReady(),
      hasLoading: info.hasLoading,
      isPreReadyOver: this.isPreReadyOver,
      isSkip: info.isSkip
    }));
  };

  __proto.onReady = function () {
    /**
     * An event occurs when all element are ready
     * @ko 모든 엘리먼트들이 준비된 경우 이벤트가 발생한다.
     * @event eg.ImReady#ready
     * @param {eg.ImReady.OnReady} e - The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>
     * @example
     * ```html
     * <div>
     *    <img src="./1.jpg" data-width="1280" data-height="853" style="width:100%"/>
     *    <img src="./2.jpg" data-width="1280" data-height="853"/>
     *    <img src="ERR" data-width="1280" data-height="853"/>
     * </div>
     * ```
     * ## Javascript
     * ```js
     * import ImReady from "@egjs/imready";
     *
     * const im = new ImReady(); // umd: eg.ImReady
     * im.check(document.querySelectorAll("img")).on({
     *   preReady: e => {
     *     // 0, 3
     *     console.log(e.readyCount, e.totalCount),
     *   },
     *   ready: e => {
     *     // 1, 3
     *     console.log(e.errorCount, e.totalCount),
     *   },
     * });
     * ```
     */
    this.trigger(new ComponentEvent$1("ready", {
      errorCount: this.getErrorCount(),
      totalErrorCount: this.totalErrorCount,
      totalCount: this.totalCount
    }));
  };

  __proto.getErrorCount = function () {
    return this.elementInfos.filter(function (info) {
      return info.hasError;
    }).length;
  };

  __proto.hasLoading = function () {
    return this.elementInfos.some(function (info) {
      return info.hasLoading;
    });
  };

  return ImReadyManager;
}(Component);

var ImageLoader =
/*#__PURE__*/
function (_super) {
  __extends$2(ImageLoader, _super);

  function ImageLoader() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  var __proto = ImageLoader.prototype;

  __proto.checkElement = function () {
    var element = this.element;
    var src = element.getAttribute("src");

    if (element.complete) {
      if (src) {
        // complete
        if (!element.naturalWidth) {
          this.onAlreadyError(element);
        }

        return false;
      } else {
        // Using an external lazy loading module
        this.onAlreadyPreReady();
      }
    }

    this.addEvents();
    IS_IE && element.setAttribute("src", src);
    return true;
  };

  ImageLoader.EVENTS = ["load", "error"];
  return ImageLoader;
}(Loader);

var VideoLoader =
/*#__PURE__*/
function (_super) {
  __extends$2(VideoLoader, _super);

  function VideoLoader() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  var __proto = VideoLoader.prototype;

  __proto.checkElement = function () {
    var element = this.element; // HAVE_NOTHING: 0, no information whether or not the audio/video is ready
    // HAVE_METADATA: 1, HAVE_METADATA - metadata for the audio/video is ready
    // HAVE_CURRENT_DATA: 2, data for the current playback position is available, but not enough data to play next frame/millisecond
    // HAVE_FUTURE_DATA: 3, data for the current and at least the next frame is available
    // HAVE_ENOUGH_DATA: 4, enough data available to start playing

    if (element.readyState >= 1) {
      return false;
    }

    if (element.error) {
      this.onAlreadyError(element);
      return false;
    }

    this.addEvents();
    return true;
  };

  VideoLoader.EVENTS = ["loadedmetadata", "error"];
  return VideoLoader;
}(Loader);

var ImReady =
/*#__PURE__*/
function (_super) {
  __extends$2(ImReady, _super);

  function ImReady(options) {
    if (options === void 0) {
      options = {};
    }

    return _super.call(this, __assign$1({
      loaders: {
        img: ImageLoader,
        video: VideoLoader
      }
    }, options)) || this;
  }

  return ImReady;
}(ImReadyManager);

/*
Copyright (c) 2015-present NAVER Corp.
name: @egjs/flicking
license: MIT
author: NAVER Corp.
repository: https://github.com/naver/egjs-flicking
version: 4.11.4
*/

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol */

var extendStatics$3 = function (d, b) {
  extendStatics$3 = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
  };
  return extendStatics$3(d, b);
};
function __extends$3(d, b) {
  if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics$3(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign$2 = function () {
  __assign$2 = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign$2.apply(this, arguments);
};
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = {
      label: 0,
      sent: function () {
        if (t[0] & 1) throw t[1];
        return t[1];
      },
      trys: [],
      ops: []
    },
    f,
    y,
    t,
    g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;
  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return {
            value: op[1],
            done: false
          };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
}
function __values$1(o) {
  var s = typeof Symbol === "function" && Symbol.iterator,
    m = s && o[s],
    i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function () {
      if (o && i >= o.length) o = void 0;
      return {
        value: o && o[i++],
        done: !o
      };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read$1(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o),
    r,
    ar = [],
    e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = {
      error: error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
}

/** @deprecated */
function __spread$1() {
  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read$1(arguments[i]));
  return ar;
}
typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

/*
 * Copyright (c) 2015 NAVER Corp.
 * egjs projects are licensed under the MIT license
 */
/* eslint-disable @typescript-eslint/restrict-template-expressions */
/**
 * Error codes of {@link FlickingError}. Below are the conditions where each error code occurs.
 * @ko {@link FlickingError}의 에러 코드. 아래는 각각의 에러 코드가 발생하는 조건입니다.
 * @name ERROR_CODE
 * @constant
 * @type object
 * @property {number} WRONG_TYPE Parameter type is wrong<ko>패러미터의 타입이 잘못되었을 경우</ko>
 * @property {number} ELEMENT_NOT_FOUND Element is not found inside page with the given CSS selector<ko>주어진 CSS selector로 페이지 내에서 해당 엘리먼트를 찾지 못했을 경우</ko>
 * @property {number} VAL_MUST_NOT_NULL Expected non-null value, but given `null` or `undefined`<ko>값을 기대했으나, `null`이나 `undefined`를 받은 경우</ko>
 * @property {number} NOT_ATTACHED_TO_FLICKING When Flicking's component is not initialized (i.e. {@link Flicking#init} is not called)<ko>Flicking 내부 컴포넌트가 초기화되지 않은 경우 ({@link Flicking#init}이 호출되지 않은 경우)</ko>
 * @property {number} WRONG_OPTION One of the options is wrong<ko>옵션들 중 잘못된 값이 있을 때</ko>
 * @property {number} INDEX_OUT_OF_RANGE When the given index is out of possible range<ko>인덱스가 주어진 범위를 벗어난 경우</ko>
 * @property {number} POSITION_NOT_REACHABLE When {@link Control#moveToPosition}'s position parameter is out of possible range.<ko>{@link Control#moveToPosition}의 `position` 패러미터가 도달 가능한 범위를 벗어난 경우</ko>
 * @property {number} TRANSFORM_NOT_SUPPORTED CSS `transform` property is not available(<=IE8) <ko>CSS `transform` 속성을 사용할 수 없는 경우(<=IE8)</ko>
 * @property {number} STOP_CALLED_BY_USER When the event's `stop()` is called by user.<ko>사용자에 의해 이벤트의 `stop()`이 호출된 경우</ko>
 * @property {number} ANIMATION_INTERRUPTED When the animation is interrupted by user.<ko>사용자에 의해 애니메이션이 중단된 경우</ko>
 * @property {number} ANIMATION_ALREADY_PLAYING When the animation is already playing.<ko>현재 애니메이션이 이미 진행중인 경우</ko>
 * @property {number} NOT_ALLOWED_IN_FRAMEWORK When the non-allowed method is called from frameworks (React, Angular, Vue...)
 * <ko>프레임워크(React, Angular, Vue ...)에서 사용 불가능한 메소드를 호출했을 경우</ko>
 * @property {number} NOT_INITIALIZED When the {@link Flicking#init} is not called before but is needed<ko>{@link Flicking#init}의 호출이 필요하나, 아직 호출되지 않았을 경우</ko>
 * @property {number} NO_ACTIVE When there're no active panel that flicking has selected. This may be due to the absence of any panels<ko>현재 Flicking이 선택한 패널이 없을 경우. 일반적으로 패널이 하나도 없는 경우에 발생할 수 있습니다</ko>
 * @property {number} NOT_ALLOWED_IN_VIRTUAL When the non-allowed method is called while the virtual option is enabled<ko>virtual 옵션이 활성화된 상태에서 사용 불가능한 메소드가 호출되었을 경우</ko>
 */
var CODE = {
  WRONG_TYPE: 0,
  ELEMENT_NOT_FOUND: 1,
  VAL_MUST_NOT_NULL: 2,
  NOT_ATTACHED_TO_FLICKING: 3,
  WRONG_OPTION: 4,
  INDEX_OUT_OF_RANGE: 5,
  POSITION_NOT_REACHABLE: 6,
  TRANSFORM_NOT_SUPPORTED: 7,
  STOP_CALLED_BY_USER: 8,
  ANIMATION_INTERRUPTED: 9,
  ANIMATION_ALREADY_PLAYING: 10,
  NOT_ALLOWED_IN_FRAMEWORK: 11,
  NOT_INITIALIZED: 12,
  NO_ACTIVE: 13,
  NOT_ALLOWED_IN_VIRTUAL: 14
};
var MESSAGE = {
  WRONG_TYPE: function (wrongVal, correctTypes) {
    return wrongVal + "(" + typeof wrongVal + ") is not a " + correctTypes.map(function (type) {
      return "\"" + type + "\"";
    }).join(" or ") + ".";
  },
  ELEMENT_NOT_FOUND: function (selector) {
    return "Element with selector \"" + selector + "\" not found.";
  },
  VAL_MUST_NOT_NULL: function (val, name) {
    return name + " should be provided. Given: " + val;
  },
  NOT_ATTACHED_TO_FLICKING: "This module is not attached to the Flicking instance. \"init()\" should be called first.",
  WRONG_OPTION: function (optionName, val) {
    return "Option \"" + optionName + "\" is not in correct format, given: " + val;
  },
  INDEX_OUT_OF_RANGE: function (val, min, max) {
    return "Index \"" + val + "\" is out of range: should be between " + min + " and " + max + ".";
  },
  POSITION_NOT_REACHABLE: function (position) {
    return "Position \"" + position + "\" is not reachable.";
  },
  TRANSFORM_NOT_SUPPORTED: "Browser does not support CSS transform.",
  STOP_CALLED_BY_USER: "Event stop() is called by user.",
  ANIMATION_INTERRUPTED: "Animation is interrupted by user input.",
  ANIMATION_ALREADY_PLAYING: "Animation is already playing.",
  NOT_ALLOWED_IN_FRAMEWORK: "This behavior is not allowed in the frameworks like React, Vue, or Angular.",
  NOT_INITIALIZED: "Flicking is not initialized yet, call init() first.",
  NO_ACTIVE: "There's no active panel that Flicking has selected. This may be due to the absence of any panels.",
  NOT_ALLOWED_IN_VIRTUAL: "This behavior is not allowed when the virtual option is enabled"
};

/*
 * Copyright (c) 2015 NAVER Corp.
 * egjs projects are licensed under the MIT license
 */
/**
 * Event type object with event name strings of {@link Flicking}
 * @ko {@link Flicking}의 이벤트 이름 문자열들을 담은 객체
 * @type {object}
 * @property {"holdStart"} HOLD_START holdStart event<ko>holdStart 이벤트</ko>
 * @property {"holdEnd"} HOLD_END holdEnd event<ko>holdEnd 이벤트</ko>
 * @property {"moveStart"} MOVE_START moveStart event<ko>moveStart 이벤트</ko>
 * @property {"move"} MOVE move event<ko>move 이벤트</ko>
 * @property {"moveEnd"} MOVE_END moveEnd event<ko>moveEnd 이벤트</ko>
 * @property {"willChange"} WILL_CHANGE willChange event<ko>willChange 이벤트</ko>
 * @property {"changed"} CHANGED changed event<ko>changed 이벤트</ko>
 * @property {"willRestore"} WILL_RESTORE willRestore event<ko>willRestore 이벤트</ko>
 * @property {"restored"} RESTORED restored event<ko>restored 이벤트</ko>
 * @property {"select"} SELECT select event<ko>select 이벤트</ko>
 * @property {"needPanel"} NEED_PANEL needPanel event<ko>needPanel 이벤트</ko>
 * @property {"panelChange"} PANEL_CHANGE panelChange event<ko>panelChange 이벤트</ko>
 * @example
 * ```ts
 * import { EVENTS } from "@egjs/flicking";
 * EVENTS.MOVE_START; // "moveStart"
 * ```
 */
var EVENTS = {
  READY: "ready",
  BEFORE_RESIZE: "beforeResize",
  AFTER_RESIZE: "afterResize",
  HOLD_START: "holdStart",
  HOLD_END: "holdEnd",
  MOVE_START: "moveStart",
  MOVE: "move",
  MOVE_END: "moveEnd",
  WILL_CHANGE: "willChange",
  CHANGED: "changed",
  WILL_RESTORE: "willRestore",
  RESTORED: "restored",
  SELECT: "select",
  NEED_PANEL: "needPanel",
  VISIBLE_CHANGE: "visibleChange",
  REACH_EDGE: "reachEdge",
  PANEL_CHANGE: "panelChange"
};
/**
 * An object with all possible predefined literal string for the {@link Flicking#align align} option
 * @ko {@link Flicking#align align} 옵션에 사용되는 미리 정의된 리터럴 상수들을 담고 있는 객체
 * @type {object}
 * @property {"prev"} PREV left/top align<ko>좌/상 정렬</ko>
 * @property {"center"} CENTER center align<ko>중앙 정렬</ko>
 * @property {"next"} NEXT right/bottom align<ko>우/하 정렬</ko>
 */
var ALIGN = {
  PREV: "prev",
  CENTER: "center",
  NEXT: "next"
};
/**
 * An object of directions
 * @ko 방향을 나타내는 값들을 담고 있는 객체
 * @type {object}
 * @property {"PREV"} PREV "left" when {@link Flicking#horizontal horizontal} is true, and "top" when {@link Flicking#horizontal horizontal} is false
 * <ko>{@link Flicking#horizontal horizontal}가 `true`일 경우 왼쪽, {@link Flicking#horizontal horizontal}가 `false`일 경우 위쪽을 의미합니다</ko>
 * @property {"NEXT"} NEXT "right" when {@link Flicking#horizontal horizontal} is true, and "bottom" when {@link Flicking#horizontal horizontal} is false
 * <ko>{@link Flicking#horizontal horizontal}가 `true`일 경우 오른쪽, {@link Flicking#horizontal horizontal}가 `false`일 경우 아래쪽을 의미합니다</ko>
 * @property {null} NONE This value usually means it's the same position<ko>주로 제자리인 경우를 의미합니다</ko>
 */
var DIRECTION = {
  PREV: "PREV",
  NEXT: "NEXT",
  NONE: null
};
/**
 * An object with all possible {@link Flicking#moveType moveType}s
 * @ko Flicking이 제공하는 {@link Flicking#moveType moveType}들을 담고 있는 객체
 * @type {object}
 * @property {"snap"} SNAP Flicking's {@link Flicking#moveType moveType} that enables {@link SnapControl} as a Flicking's {@link Flicking#control control}
 * <ko>Flicking의 {@link Flicking#control control}을 {@link SnapControl}로 설정하게 하는 {@link Flicking#moveType moveType}</ko>
 * @property {"freeScroll"} FREE_SCROLL Flicking's {@link Flicking#moveType moveType} that enables {@link FreeControl} as a Flicking's {@link Flicking#control control}
 * <ko>Flicking의 {@link Flicking#control control}을 {@link FreeControl}로 설정하게 하는 {@link Flicking#moveType moveType}</ko>
 * @property {"strict"} STRICT Flicking's {@link Flicking#moveType moveType} that enables {@link StrictControl} as a Flicking's {@link Flicking#control control}
 * <ko>Flicking의 {@link Flicking#control control}을 {@link StrictControl}로 설정하게 하는 {@link Flicking#moveType moveType}</ko>
 */
var MOVE_TYPE = {
  SNAP: "snap",
  FREE_SCROLL: "freeScroll",
  STRICT: "strict"
};
var CLASS = {
  VERTICAL: "vertical",
  HIDDEN: "flicking-hidden",
  DEFAULT_VIRTUAL: "flicking-panel"
};
/**
 * An object with all possible {@link Flicking#circularFallback circularFallback}s
 * @ko Flicking의 {@link Flicking#circularFallback circularFallback}에 설정 가능한 값들을 담고 있는 객체
 * @type {object}
 * @property {string} LINEAR "linear"
 * @property {string} BOUND "bound"
 */
var CIRCULAR_FALLBACK = {
  LINEAR: "linear",
  BOUND: "bound"
};
/**
 * An object for identifying {@link https://developer.mozilla.org/en-US/docs/Web/CSS/direction direction} CSS property applied to the camera element(`.flicking-camera`)
 * @ko 카메라 엘리먼트(`.flicking-camera`)에 적용된 {@link https://developer.mozilla.org/en-US/docs/Web/CSS/direction direction} CSS 속성을 구분하기 위한 객체
 * @type {object}
 * @property {string} LTR "ltr"
 * @property {string} RTL "rtl"
 */
var ORDER = {
  LTR: "ltr",
  RTL: "rtl"
};

// eslint-disable-next-line @typescript-eslint/ban-types
var merge = function (target) {
  var sources = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    sources[_i - 1] = arguments[_i];
  }
  sources.forEach(function (source) {
    Object.keys(source).forEach(function (key) {
      target[key] = source[key];
    });
  });
  return target;
};
var getElement = function (el, parent) {
  var targetEl = null;
  if (isString(el)) {
    var parentEl = parent ? parent : document;
    var queryResult = parentEl.querySelector(el);
    if (!queryResult) {
      throw new FlickingError(MESSAGE.ELEMENT_NOT_FOUND(el), CODE.ELEMENT_NOT_FOUND);
    }
    targetEl = queryResult;
  } else if (el && el.nodeType === Node.ELEMENT_NODE) {
    targetEl = el;
  }
  if (!targetEl) {
    throw new FlickingError(MESSAGE.WRONG_TYPE(el, ["HTMLElement", "string"]), CODE.WRONG_TYPE);
  }
  return targetEl;
};
var checkExistence = function (value, nameOnErrMsg) {
  if (value == null) {
    throw new FlickingError(MESSAGE.VAL_MUST_NOT_NULL(value, nameOnErrMsg), CODE.VAL_MUST_NOT_NULL);
  }
};
var clamp$1 = function (x, min, max) {
  return Math.max(Math.min(x, max), min);
};
var getFlickingAttached = function (val) {
  if (!val) {
    throw new FlickingError(MESSAGE.NOT_ATTACHED_TO_FLICKING, CODE.NOT_ATTACHED_TO_FLICKING);
  }
  return val;
};
var toArray$2 = function (iterable) {
  return [].slice.call(iterable);
};
var parseAlign$1 = function (align, size) {
  var alignPoint;
  if (isString(align)) {
    switch (align) {
      case ALIGN.PREV:
        alignPoint = 0;
        break;
      case ALIGN.CENTER:
        alignPoint = 0.5 * size;
        break;
      case ALIGN.NEXT:
        alignPoint = size;
        break;
      default:
        alignPoint = parseArithmeticSize(align, size);
        if (alignPoint == null) {
          throw new FlickingError(MESSAGE.WRONG_OPTION("align", align), CODE.WRONG_OPTION);
        }
    }
  } else {
    alignPoint = align;
  }
  return alignPoint;
};
var parseBounce = function (bounce, size) {
  var parsedBounce;
  if (Array.isArray(bounce)) {
    parsedBounce = bounce.map(function (val) {
      return parseArithmeticSize(val, size);
    });
  } else {
    var parsedVal = parseArithmeticSize(bounce, size);
    parsedBounce = [parsedVal, parsedVal];
  }
  return parsedBounce.map(function (val) {
    if (val == null) {
      throw new FlickingError(MESSAGE.WRONG_OPTION("bounce", bounce), CODE.WRONG_OPTION);
    }
    return val;
  });
};
var parseArithmeticSize = function (cssValue, base) {
  var parsed = parseArithmeticExpression(cssValue);
  if (parsed == null) return null;
  return parsed.percentage * base + parsed.absolute;
};
var parseArithmeticExpression = function (cssValue) {
  var cssRegex = /(?:(\+|\-)\s*)?(\d+(?:\.\d+)?(%|px)?)/g;
  if (typeof cssValue === "number") {
    return {
      percentage: 0,
      absolute: cssValue
    };
  }
  var parsed = {
    percentage: 0,
    absolute: 0
  };
  var idx = 0;
  var matchResult = cssRegex.exec(cssValue);
  while (matchResult != null) {
    var sign = matchResult[1];
    var value = matchResult[2];
    var unit = matchResult[3];
    var parsedValue = parseFloat(value);
    if (idx <= 0) {
      sign = sign || "+";
    }
    // Return default value for values not in good form
    if (!sign) {
      return null;
    }
    var signMultiplier = sign === "+" ? 1 : -1;
    if (unit === "%") {
      parsed.percentage += signMultiplier * (parsedValue / 100);
    } else {
      parsed.absolute += signMultiplier * parsedValue;
    }
    // Match next occurrence
    ++idx;
    matchResult = cssRegex.exec(cssValue);
  }
  // None-matched
  if (idx === 0) {
    return null;
  }
  return parsed;
};
var parseCSSSizeValue = function (val) {
  return isString(val) ? val : val + "px";
};
var parsePanelAlign = function (align) {
  return typeof align === "object" ? align.panel : align;
};
var getDirection$1 = function (start, end) {
  if (start === end) return DIRECTION.NONE;
  return start < end ? DIRECTION.NEXT : DIRECTION.PREV;
};
var parseElement = function (element) {
  if (!Array.isArray(element)) {
    element = [element];
  }
  var elements = [];
  element.forEach(function (el) {
    if (isString(el)) {
      var tempDiv = document.createElement("div");
      tempDiv.innerHTML = el;
      elements.push.apply(elements, __spread$1(toArray$2(tempDiv.children)));
      while (tempDiv.firstChild) {
        tempDiv.removeChild(tempDiv.firstChild);
      }
    } else if (el && el.nodeType === Node.ELEMENT_NODE) {
      elements.push(el);
    } else {
      throw new FlickingError(MESSAGE.WRONG_TYPE(el, ["HTMLElement", "string"]), CODE.WRONG_TYPE);
    }
  });
  return elements;
};
var getMinusCompensatedIndex = function (idx, max) {
  return idx < 0 ? clamp$1(idx + max, 0, max) : clamp$1(idx, 0, max);
};
var includes = function (array, target) {
  var e_1, _a;
  try {
    for (var array_1 = __values$1(array), array_1_1 = array_1.next(); !array_1_1.done; array_1_1 = array_1.next()) {
      var val = array_1_1.value;
      if (val === target) return true;
    }
  } catch (e_1_1) {
    e_1 = {
      error: e_1_1
    };
  } finally {
    try {
      if (array_1_1 && !array_1_1.done && (_a = array_1.return)) _a.call(array_1);
    } finally {
      if (e_1) throw e_1.error;
    }
  }
  return false;
};
var isString = function (val) {
  return typeof val === "string";
};
var circulatePosition = function (pos, min, max) {
  var size = max - min;
  if (pos < min) {
    var offset = (min - pos) % size;
    pos = max - offset;
  } else if (pos > max) {
    var offset = (pos - max) % size;
    pos = min + offset;
  }
  return pos;
};
var find$1 = function (array, checker) {
  var e_2, _a;
  try {
    for (var array_2 = __values$1(array), array_2_1 = array_2.next(); !array_2_1.done; array_2_1 = array_2.next()) {
      var val = array_2_1.value;
      if (checker(val)) {
        return val;
      }
    }
  } catch (e_2_1) {
    e_2 = {
      error: e_2_1
    };
  } finally {
    try {
      if (array_2_1 && !array_2_1.done && (_a = array_2.return)) _a.call(array_2);
    } finally {
      if (e_2) throw e_2.error;
    }
  }
  return null;
};
var findRight = function (array, checker) {
  for (var idx = array.length - 1; idx >= 0; idx--) {
    var val = array[idx];
    if (checker(val)) {
      return val;
    }
  }
  return null;
};
var findIndex = function (array, checker) {
  for (var idx = 0; idx < array.length; idx++) {
    if (checker(array[idx])) {
      return idx;
    }
  }
  return -1;
};
var getProgress = function (pos, prev, next) {
  return (pos - prev) / (next - prev);
};
// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
var getStyle = function (el) {
  return window.getComputedStyle(el) || el.currentStyle;
};
var setSize = function (el, _a) {
  var width = _a.width,
    height = _a.height;
  if (width != null) {
    if (isString(width)) {
      el.style.width = width;
    } else {
      el.style.width = width + "px";
    }
  }
  if (height != null) {
    if (isString(height)) {
      el.style.height = height;
    } else {
      el.style.height = height + "px";
    }
  }
};
var isBetween = function (val, min, max) {
  return val >= min && val <= max;
};
var circulateIndex = function (index, max) {
  if (index >= max) {
    return index % max;
  } else if (index < 0) {
    return getMinusCompensatedIndex((index + 1) % max - 1, max);
  } else {
    return index;
  }
};
var range = function (end) {
  var arr = new Array(end);
  for (var i = 0; i < end; i++) {
    arr[i] = i;
  }
  return arr;
};
var getElementSize = function (_a) {
  var el = _a.el,
    horizontal = _a.horizontal,
    useFractionalSize = _a.useFractionalSize,
    useOffset = _a.useOffset,
    style = _a.style;
  var size = 0;
  if (useFractionalSize) {
    var baseSize = parseFloat(horizontal ? style.width : style.height) || 0;
    var isBorderBoxSizing = style.boxSizing === "border-box";
    var border = horizontal ? parseFloat(style.borderLeftWidth || "0") + parseFloat(style.borderRightWidth || "0") : parseFloat(style.borderTopWidth || "0") + parseFloat(style.borderBottomWidth || "0");
    if (isBorderBoxSizing) {
      size = useOffset ? baseSize : baseSize - border;
    } else {
      var padding = horizontal ? parseFloat(style.paddingLeft || "0") + parseFloat(style.paddingRight || "0") : parseFloat(style.paddingTop || "0") + parseFloat(style.paddingBottom || "0");
      size = useOffset ? baseSize + padding + border : baseSize + padding;
    }
  } else {
    var sizeStr = horizontal ? "Width" : "Height";
    size = useOffset ? el["offset" + sizeStr] : el["client" + sizeStr];
  }
  return Math.max(size, 0);
};
var setPrototypeOf = Object.setPrototypeOf || function (obj, proto) {
  obj.__proto__ = proto;
  return obj;
};

/*
 * Copyright (c) 2015 NAVER Corp.
 * egjs projects are licensed under the MIT license
 */
/**
 * Special type of known error that {@link Flicking} throws.
 * @ko Flicking 내부에서 알려진 오류 발생시 throw되는 에러
 * @property {number} code Error code<ko>에러 코드</ko>
 * @property {string} message Error message<ko>에러 메시지</ko>
 * @see {@link ERROR_CODE ERROR_CODE}
 * @example
 * ```ts
 * import Flicking, { FlickingError, ERROR_CODES } from "@egjs/flicking";
 * try {
 *   const flicking = new Flicking(".flicking-viewport")
 * } catch (e) {
 *   if (e instanceof FlickingError && e.code === ERROR_CODES.ELEMENT_NOT_FOUND) {
 *     console.error("Element not found")
 *   }
 * }
 * ```
 */
var FlickingError = /*#__PURE__*/function (_super) {
  __extends$3(FlickingError, _super);
  /**
   * @param message Error message<ko>에러 메시지</ko>
   * @param code Error code<ko>에러 코드</ko>
   */
  function FlickingError(message, code) {
    var _this = _super.call(this, message) || this;
    setPrototypeOf(_this, FlickingError.prototype);
    _this.name = "FlickingError";
    _this.code = code;
    return _this;
  }
  return FlickingError;
}(Error);

/**
 * A component that manages viewport size
 * @ko 뷰포트 크기 정보를 담당하는 컴포넌트
 */
var Viewport = /*#__PURE__*/function () {
  /**
   * @param el A viewport element<ko>뷰포트 엘리먼트</ko>
   */
  function Viewport(flicking, el) {
    this._flicking = flicking;
    this._el = el;
    this._width = 0;
    this._height = 0;
    this._padding = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    };
    this._isBorderBoxSizing = false;
  }
  var __proto = Viewport.prototype;
  Object.defineProperty(__proto, "element", {
    /**
     * A viewport(root) element
     * @ko 뷰포트(root) 엘리먼트
     * @type {HTMLElement}
     * @readonly
     */
    get: function () {
      return this._el;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "width", {
    /**
     * Viewport width, without paddings
     * @ko 뷰포트 너비
     * @type {number}
     * @readonly
     */
    get: function () {
      return this._width - this._padding.left - this._padding.right;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "height", {
    /**
     * Viewport height, without paddings
     * @ko 뷰포트 높이
     * @type {number}
     * @readonly
     */
    get: function () {
      return this._height - this._padding.top - this._padding.bottom;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "padding", {
    /**
     * Viewport paddings
     * @ko 뷰포트 CSS padding 값
     * @type {object}
     * @property {number} left CSS `padding-left`
     * @property {number} right CSS `padding-right`
     * @property {number} top CSS `padding-top`
     * @property {number} bottom CSS `padding-bottom`
     * @readonly
     */
    get: function () {
      return this._padding;
    },
    enumerable: false,
    configurable: true
  });
  /**
   * Change viewport's size.
   * This will change the actual size of `.flicking-viewport` element by changing its CSS width/height property
   * @ko 뷰포트 크기를 변경합니다.
   * `.flicking-viewport` 엘리먼트에 해당 크기의 CSS width/height를 적용합니다
   * @param {object} [size] New viewport size<ko>새 뷰포트 크기</ko>
   * @param {number|string} [size.width] CSS string or number(in px)<ko>CSS 문자열 또는 숫자(px)</ko>
   * @param {number|string} [size.height] CSS string or number(in px)<ko>CSS 문자열 또는 숫자(px)</ko>
   */
  __proto.setSize = function (_a) {
    var width = _a.width,
      height = _a.height;
    var el = this._el;
    var padding = this._padding;
    var isBorderBoxSizing = this._isBorderBoxSizing;
    if (width != null) {
      if (isString(width)) {
        el.style.width = width;
      } else {
        var newWidth = isBorderBoxSizing ? width + padding.left + padding.right : width;
        el.style.width = newWidth + "px";
      }
    }
    if (height != null) {
      if (isString(height)) {
        el.style.height = height;
      } else {
        var newHeight = isBorderBoxSizing ? height + padding.top + padding.bottom : height;
        el.style.height = newHeight + "px";
      }
    }
    this.resize();
  };
  /**
   * Update width/height to the current viewport element's size
   * @ko 현재 뷰포트 엘리먼트의 크기로 너비/높이를 업데이트합니다
   */
  __proto.resize = function () {
    var el = this._el;
    var elStyle = getStyle(el);
    var useFractionalSize = this._flicking.useFractionalSize;
    this._width = getElementSize({
      el: el,
      horizontal: true,
      useFractionalSize: useFractionalSize,
      useOffset: false,
      style: elStyle
    });
    this._height = getElementSize({
      el: el,
      horizontal: false,
      useFractionalSize: useFractionalSize,
      useOffset: false,
      style: elStyle
    });
    this._padding = {
      left: elStyle.paddingLeft ? parseFloat(elStyle.paddingLeft) : 0,
      right: elStyle.paddingRight ? parseFloat(elStyle.paddingRight) : 0,
      top: elStyle.paddingTop ? parseFloat(elStyle.paddingTop) : 0,
      bottom: elStyle.paddingBottom ? parseFloat(elStyle.paddingBottom) : 0
    };
    this._isBorderBoxSizing = elStyle.boxSizing === "border-box";
  };
  return Viewport;
}();

var AutoResizer = /*#__PURE__*/function () {
  function AutoResizer(flicking) {
    var _this = this;
    this._onResize = function () {
      var flicking = _this._flicking;
      var resizeDebounce = flicking.resizeDebounce;
      var maxResizeDebounce = flicking.maxResizeDebounce;
      if (resizeDebounce <= 0) {
        void flicking.resize();
      } else {
        if (_this._maxResizeDebounceTimer <= 0) {
          if (maxResizeDebounce > 0 && maxResizeDebounce >= resizeDebounce) {
            _this._maxResizeDebounceTimer = window.setTimeout(_this._doScheduledResize, maxResizeDebounce);
          }
        }
        if (_this._resizeTimer > 0) {
          clearTimeout(_this._resizeTimer);
          _this._resizeTimer = 0;
        }
        _this._resizeTimer = window.setTimeout(_this._doScheduledResize, resizeDebounce);
      }
    };
    this._doScheduledResize = function () {
      clearTimeout(_this._resizeTimer);
      clearTimeout(_this._maxResizeDebounceTimer);
      _this._maxResizeDebounceTimer = -1;
      _this._resizeTimer = -1;
      void _this._flicking.resize();
    };
    // eslint-disable-next-line @typescript-eslint/member-ordering
    this._skipFirstResize = function () {
      var isFirstResize = true;
      return function () {
        if (isFirstResize) {
          isFirstResize = false;
          return;
        }
        _this._onResize();
      };
    }();
    this._flicking = flicking;
    this._enabled = false;
    this._resizeObserver = null;
    this._resizeTimer = -1;
    this._maxResizeDebounceTimer = -1;
  }
  var __proto = AutoResizer.prototype;
  Object.defineProperty(__proto, "enabled", {
    get: function () {
      return this._enabled;
    },
    enumerable: false,
    configurable: true
  });
  __proto.enable = function () {
    var flicking = this._flicking;
    var viewport = flicking.viewport;
    if (this._enabled) {
      this.disable();
    }
    if (flicking.useResizeObserver && !!window.ResizeObserver) {
      var viewportSizeNot0 = viewport.width !== 0 || viewport.height !== 0;
      var resizeObserver = viewportSizeNot0 ? new ResizeObserver(this._skipFirstResize) : new ResizeObserver(this._onResize);
      resizeObserver.observe(flicking.viewport.element);
      this._resizeObserver = resizeObserver;
    } else {
      window.addEventListener("resize", this._onResize);
    }
    this._enabled = true;
    return this;
  };
  __proto.disable = function () {
    if (!this._enabled) return this;
    var resizeObserver = this._resizeObserver;
    if (resizeObserver) {
      resizeObserver.disconnect();
      this._resizeObserver = null;
    } else {
      window.removeEventListener("resize", this._onResize);
    }
    this._enabled = false;
    return this;
  };
  return AutoResizer;
}();

/**
 * @internal
 */
var VanillaElementProvider = /*#__PURE__*/function () {
  function VanillaElementProvider(element) {
    this._element = element;
    this._rendered = true;
  }
  var __proto = VanillaElementProvider.prototype;
  Object.defineProperty(__proto, "element", {
    get: function () {
      return this._element;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "rendered", {
    get: function () {
      return this._rendered;
    },
    enumerable: false,
    configurable: true
  });
  __proto.show = function (flicking) {
    var el = this.element;
    var cameraEl = flicking.camera.element;
    if (el.parentElement !== cameraEl) {
      cameraEl.appendChild(el);
      this._rendered = true;
    }
  };
  __proto.hide = function (flicking) {
    var el = this.element;
    var cameraEl = flicking.camera.element;
    if (el.parentElement === cameraEl) {
      cameraEl.removeChild(el);
      this._rendered = false;
    }
  };
  return VanillaElementProvider;
}();

/*
 * Copyright (c) 2015 NAVER Corp.
 * egjs projects are licensed under the MIT license
 */
/**
 * @internal
 */
var VirtualElementProvider = /*#__PURE__*/function () {
  function VirtualElementProvider(flicking) {
    this._flicking = flicking;
  }
  var __proto = VirtualElementProvider.prototype;
  Object.defineProperty(__proto, "element", {
    get: function () {
      return this._virtualElement.nativeElement;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "rendered", {
    get: function () {
      return this._virtualElement.visible;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "_virtualElement", {
    get: function () {
      var flicking = this._flicking;
      var elIndex = this._panel.elementIndex;
      var virtualElements = flicking.virtual.elements;
      return virtualElements[elIndex];
    },
    enumerable: false,
    configurable: true
  });
  __proto.init = function (panel) {
    this._panel = panel;
  };
  __proto.show = function () {
    // DO_NOTHING
    // Actual element visibility is controlled by VirtualManager
  };
  __proto.hide = function () {
    // DO_NOTHING
    // Actual element visibility is controlled by VirtualManager
  };
  return VirtualElementProvider;
}();

/**
 * A manager class to add / remove virtual panels
 */
var VirtualManager = /*#__PURE__*/function () {
  function VirtualManager(flicking, options) {
    var _a, _b, _c, _d;
    this._flicking = flicking;
    this._renderPanel = (_a = options === null || options === void 0 ? void 0 : options.renderPanel) !== null && _a !== void 0 ? _a : function () {
      return "";
    };
    this._initialPanelCount = (_b = options === null || options === void 0 ? void 0 : options.initialPanelCount) !== null && _b !== void 0 ? _b : -1;
    this._cache = (_c = options === null || options === void 0 ? void 0 : options.cache) !== null && _c !== void 0 ? _c : false;
    this._panelClass = (_d = options === null || options === void 0 ? void 0 : options.panelClass) !== null && _d !== void 0 ? _d : CLASS.DEFAULT_VIRTUAL;
    this._elements = [];
  }
  var __proto = VirtualManager.prototype;
  Object.defineProperty(__proto, "elements", {
    get: function () {
      return this._elements;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "renderPanel", {
    // Options
    /**
     * A rendering function for the panel element's innerHTML
     * @ko 패널 엘리먼트의 innerHTML을 렌더링하는 함수
     * @type {function}
     * @param {VirtualPanel} panel Instance of the panel<ko>패널 인스턴스</ko>
     * @param {number} index Index of the panel<ko>패널 인덱스</ko>
     * @default "() => {}"
     */
    get: function () {
      return this._renderPanel;
    },
    set: function (val) {
      this._renderPanel = val;
      this._flicking.renderer.panels.forEach(function (panel) {
        return panel.uncacheRenderResult();
      });
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "initialPanelCount", {
    /**
     * Initial panel count to render
     * @ko 최초로 렌더링할 패널의 개수
     * @readonly
     * @type {number}
     * @default -1
     */
    get: function () {
      return this._initialPanelCount;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "cache", {
    /**
     * Whether to cache rendered panel's innerHTML
     * @ko 렌더링된 패널의 innerHTML 정보를 캐시할지 여부
     * @type {boolean}
     * @default false
     */
    get: function () {
      return this._cache;
    },
    set: function (val) {
      this._cache = val;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "panelClass", {
    /**
     * The class name that will be applied to rendered panel elements
     * @ko 렌더링되는 패널 엘리먼트에 적용될 클래스 이름
     * @type {string}
     * @default "flicking-panel"
     */
    get: function () {
      return this._panelClass;
    },
    set: function (val) {
      this._panelClass = val;
    },
    enumerable: false,
    configurable: true
  });
  __proto.init = function () {
    var flicking = this._flicking;
    if (!flicking.virtualEnabled) return;
    if (!flicking.externalRenderer && !flicking.renderExternal) {
      this._initVirtualElements();
    }
    var virtualElements = flicking.camera.children;
    this._elements = virtualElements.map(function (el) {
      return {
        nativeElement: el,
        visible: true
      };
    });
  };
  __proto.show = function (index) {
    var el = this._elements[index];
    var nativeEl = el.nativeElement;
    el.visible = true;
    if (nativeEl.style.display) {
      nativeEl.style.display = "";
    }
  };
  __proto.hide = function (index) {
    var el = this._elements[index];
    var nativeEl = el.nativeElement;
    el.visible = false;
    nativeEl.style.display = "none";
  };
  /**
   * Add new virtual panels at the end of the list
   * @ko 새로운 가상 패널들을 리스트의 끝에 추가합니다
   * @param {number} count The number of panels to add<ko>추가할 패널의 개수</ko>
   * @returns {Array<VirtualPanel>} The new panels added<ko>새롭게 추가된 패널들</ko>
   */
  __proto.append = function (count) {
    if (count === void 0) {
      count = 1;
    }
    var flicking = this._flicking;
    return this.insert(flicking.panels.length, count);
  };
  /**
   * Add new virtual panels at the start of the list
   * @ko 새로운 가상 패널들을 리스트의 시작에 추가합니다
   * @param {number} count The number of panels to add<ko>추가할 패널의 개수</ko>
   * @returns {Array<VirtualPanel>} The new panels added<ko>새롭게 추가된 패널들</ko>
   */
  __proto.prepend = function (count) {
    if (count === void 0) {
      count = 1;
    }
    return this.insert(0, count);
  };
  /**
   * Add new virtual panels at the given index
   * @ko 새로운 가상 패널들을 주어진 인덱스에 추가합니다
   * @param {number} count The number of panels to add<ko>추가할 패널의 개수</ko>
   * @returns {Array<VirtualPanel>} The new panels added<ko>새롭게 추가된 패널들</ko>
   */
  __proto.insert = function (index, count) {
    if (count === void 0) {
      count = 1;
    }
    if (count <= 0) return [];
    var flicking = this._flicking;
    return flicking.renderer.batchInsert({
      index: index,
      elements: range(count),
      hasDOMInElements: false
    });
  };
  /**
   * Remove panels at the given index
   * @ko 주어진 인덱스에서 패널들을 삭제합니다
   * @param {number} count The number of panels to remove<ko>삭제할 패널의 개수</ko>
   * @returns {Array<VirtualPanel>} The panels removed<ko>삭제된 패널들</ko>
   */
  __proto.remove = function (index, count) {
    if (count <= 0) return [];
    var flicking = this._flicking;
    return flicking.renderer.batchRemove({
      index: index,
      deleteCount: count,
      hasDOMInElements: false
    });
  };
  __proto._initVirtualElements = function () {
    var _this = this;
    var flicking = this._flicking;
    var cameraElement = flicking.camera.element;
    var panelsPerView = flicking.panelsPerView;
    var fragment = document.createDocumentFragment();
    var newElements = range(panelsPerView + 1).map(function (idx) {
      var panelEl = document.createElement("div");
      panelEl.className = _this._panelClass;
      panelEl.dataset.elementIndex = idx.toString();
      return panelEl;
    });
    newElements.forEach(function (el) {
      fragment.appendChild(el);
    });
    cameraElement.appendChild(fragment);
  };
  return VirtualManager;
}();

/**
 * All possible @egjs/axes event keys
 * @internal
 */
var EVENT = {
  HOLD: "hold",
  CHANGE: "change",
  RELEASE: "release",
  ANIMATION_END: "animationEnd",
  FINISH: "finish"
};
/**
 * An Axis key that Flicking uses
 * @internal
 */
var POSITION_KEY = "flick";

var STATE_TYPE;
(function (STATE_TYPE) {
  STATE_TYPE[STATE_TYPE["IDLE"] = 0] = "IDLE";
  STATE_TYPE[STATE_TYPE["HOLDING"] = 1] = "HOLDING";
  STATE_TYPE[STATE_TYPE["DRAGGING"] = 2] = "DRAGGING";
  STATE_TYPE[STATE_TYPE["ANIMATING"] = 3] = "ANIMATING";
  STATE_TYPE[STATE_TYPE["DISABLED"] = 4] = "DISABLED";
})(STATE_TYPE || (STATE_TYPE = {}));
/**
 * A component that shows the current status of the user input or the animation
 * @ko 현재 사용자 입력 또는 애니메이션 상태를 나타내는 컴포넌트
 * @internal
 */
var State = /*#__PURE__*/function () {
  function State() {
    this._delta = 0;
    this._targetPanel = null;
  }
  var __proto = State.prototype;
  Object.defineProperty(__proto, "delta", {
    /**
     * A sum of delta values of change events from the last hold event of Axes
     * @ko 이전 hold이벤트부터 change에 의해 발생한 이동 delta값의 합산
     * @type {number}
     * @readonly
     */
    get: function () {
      return this._delta;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "targetPanel", {
    /**
     * A panel to set as {@link Control#activePanel} after the animation is finished
     * @ko 애니메이션 종료시 {@link Control#activePanel}로 설정할 패널
     * @type {number}
     * @readonly
     */
    get: function () {
      return this._targetPanel;
    },
    set: function (val) {
      this._targetPanel = val;
    },
    enumerable: false,
    configurable: true
  });
  /**
   * An callback which is called when state has changed to this state
   * @ko 현재 상태로 돌입했을때 호출되는 콜백 함수
   * @param {State} prevState An previous state<ko>이전 상태값</ko>
   * @return {void}
   */
  __proto.onEnter = function (prevState) {
    this._delta = prevState._delta;
    this._targetPanel = prevState._targetPanel;
  };
  /**
   * An event handler for Axes's {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:hold hold} event
   * @ko Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:hold hold} 이벤트 핸들러
   * @param {object} [ctx] Event context<ko>이벤트 콘텍스트</ko>
   * @param {Flicking} [ctx.flicking] An instance of Flicking<ko>Flicking 인스턴스</ko>
   * @param {object} [ctx.axesEvent] A {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:hold hold} event of Axes
   * <ko>Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:hold hold} 이벤트</ko>
   * @param {function} [ctx.transitTo] A function for changing current state to other state<ko>다른 상태로 변경하기 위한 함수</ko>
   * @return {void}
   */
  __proto.onHold = function (ctx) {
    // DO NOTHING
  };
  /**
   * An event handler for Axes's {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:change change} event
   * @ko Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:change change} 이벤트 핸들러
   * @param {object} [ctx] Event context<ko>이벤트 콘텍스트</ko>
   * @param {Flicking} [ctx.flicking] An instance of Flicking<ko>Flicking 인스턴스</ko>
   * @param {object} [ctx.axesEvent] A {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:change change} event of Axes
   * <ko>Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:change change} 이벤트</ko>
   * @param {function} [ctx.transitTo] A function for changing current state to other state<ko>다른 상태로 변경하기 위한 함수</ko>
   * @return {void}
   */
  __proto.onChange = function (ctx) {
    // DO NOTHING
  };
  /**
   * An event handler for Axes's {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} event
   * @ko Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} 이벤트 핸들러
   * @param {object} [ctx] Event context<ko>이벤트 콘텍스트</ko>
   * @param {Flicking} [ctx.flicking] An instance of Flicking<ko>Flicking 인스턴스</ko>
   * @param {object} [ctx.axesEvent] A {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} event of Axes
   * <ko>Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} 이벤트</ko>
   * @param {function} [ctx.transitTo] A function for changing current state to other state<ko>다른 상태로 변경하기 위한 함수</ko>
   * @return {void}
   */
  __proto.onRelease = function (ctx) {
    // DO NOTHING
  };
  /**
   * An event handler for Axes's {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:animationEnd animationEnd} event
   * @ko Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:animationEnd animationEnd} 이벤트 핸들러
   * @param {object} [ctx] Event context<ko>이벤트 콘텍스트</ko>
   * @param {Flicking} [ctx.flicking] An instance of Flicking<ko>Flicking 인스턴스</ko>
   * @param {object} [ctx.axesEvent] A {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:animationEnd animationEnd} event of Axes
   * <ko>Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:animationEnd animationEnd} 이벤트</ko>
   * @param {function} [ctx.transitTo] A function for changing current state to other state<ko>다른 상태로 변경하기 위한 함수</ko>
   * @return {void}
   */
  __proto.onAnimationEnd = function (ctx) {
    // DO NOTHING
  };
  /**
   * An event handler for Axes's {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:finish finish} event
   * @ko Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:finish finish} 이벤트 핸들러
   * @param {object} [ctx] Event context<ko>이벤트 콘텍스트</ko>
   * @param {Flicking} [ctx.flicking] An instance of Flicking<ko>Flicking 인스턴스</ko>
   * @param {object} [ctx.axesEvent] A {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:finish finish} event of Axes<ko>Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:finish finish} 이벤트</ko>
   * @param {function} [ctx.transitTo] A function for changing current state to other state<ko>다른 상태로 변경하기 위한 함수</ko>
   * @return {void}
   */
  __proto.onFinish = function (ctx) {
    // DO NOTHING
  };
  __proto._moveToChangedPosition = function (ctx) {
    var flicking = ctx.flicking,
      axesEvent = ctx.axesEvent,
      transitTo = ctx.transitTo;
    var delta = axesEvent.delta[POSITION_KEY];
    if (!delta) {
      return;
    }
    this._delta += delta;
    var camera = flicking.camera;
    var prevPosition = camera.position;
    var position = axesEvent.pos[POSITION_KEY];
    var newPosition = flicking.circularEnabled ? circulatePosition(position, camera.range.min, camera.range.max) : position;
    camera.lookAt(newPosition);
    var moveEvent = new ComponentEvent$1(EVENTS.MOVE, {
      isTrusted: axesEvent.isTrusted,
      holding: this.holding,
      direction: getDirection$1(0, axesEvent.delta[POSITION_KEY]),
      axesEvent: axesEvent
    });
    flicking.trigger(moveEvent);
    if (moveEvent.isCanceled()) {
      // Return to previous position
      camera.lookAt(prevPosition);
      transitTo(STATE_TYPE.DISABLED);
    }
  };
  return State;
}();

/**
 * A default state when there's no user input and no animation's playing
 * @ko 사용자의 입력이 없고, 애니메이션이 동작하고있지 않은 기본 상태
 * @internal
 */
var IdleState = /*#__PURE__*/function (_super) {
  __extends$3(IdleState, _super);
  function IdleState() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    /**
     * Whether user is clicking or touching
     * @ko 현재 사용자가 클릭/터치중인지 여부
     * @type {false}
     * @readonly
     */
    _this.holding = false;
    /**
     * Whether Flicking's animating
     * @ko 현재 애니메이션 동작 여부
     * @type {false}
     * @readonly
     */
    _this.animating = false;
    return _this;
  }
  var __proto = IdleState.prototype;
  __proto.onEnter = function () {
    this._delta = 0;
    this._targetPanel = null;
  };
  __proto.onHold = function (ctx) {
    // Shouldn't do any action until any panels on flicking area
    var flicking = ctx.flicking,
      axesEvent = ctx.axesEvent,
      transitTo = ctx.transitTo;
    if (flicking.renderer.panelCount <= 0) {
      transitTo(STATE_TYPE.DISABLED);
      return;
    }
    var holdStartEvent = new ComponentEvent$1(EVENTS.HOLD_START, {
      axesEvent: axesEvent
    });
    flicking.trigger(holdStartEvent);
    if (holdStartEvent.isCanceled()) {
      transitTo(STATE_TYPE.DISABLED);
    } else {
      transitTo(STATE_TYPE.HOLDING);
    }
  };
  // By methods call
  __proto.onChange = function (ctx) {
    var flicking = ctx.flicking,
      axesEvent = ctx.axesEvent,
      transitTo = ctx.transitTo;
    var controller = flicking.control.controller;
    var animatingContext = controller.animatingContext;
    var moveStartEvent = new ComponentEvent$1(EVENTS.MOVE_START, {
      isTrusted: axesEvent.isTrusted,
      holding: this.holding,
      direction: getDirection$1(animatingContext.start, animatingContext.end),
      axesEvent: axesEvent
    });
    flicking.trigger(moveStartEvent);
    if (moveStartEvent.isCanceled()) {
      transitTo(STATE_TYPE.DISABLED);
    } else {
      // Trigger AnimatingState's onChange, to trigger "move" event immediately
      transitTo(STATE_TYPE.ANIMATING).onChange(ctx);
    }
  };
  return IdleState;
}(State);

/**
 * A state that activates when user's holding the Flicking area, but not moved a single pixel yet
 * @ko 사용자의 입력이 시작되었으나, 아직 움직이지는 않은 상태
 * @internal
 */
var HoldingState = /*#__PURE__*/function (_super) {
  __extends$3(HoldingState, _super);
  function HoldingState() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    /**
     * Whether user is clicking or touching
     * @ko 현재 사용자가 클릭/터치중인지 여부
     * @type {true}
     * @readonly
     */
    _this.holding = true;
    /**
     * Whether Flicking's animating
     * @ko 현재 애니메이션 동작 여부
     * @type {false}
     * @readonly
     */
    _this.animating = false;
    _this._releaseEvent = null;
    return _this;
  }
  var __proto = HoldingState.prototype;
  __proto.onChange = function (ctx) {
    var flicking = ctx.flicking,
      axesEvent = ctx.axesEvent,
      transitTo = ctx.transitTo;
    var inputEvent = axesEvent.inputEvent;
    var offset = flicking.horizontal ? inputEvent.offsetX : inputEvent.offsetY;
    var moveStartEvent = new ComponentEvent$1(EVENTS.MOVE_START, {
      isTrusted: axesEvent.isTrusted,
      holding: this.holding,
      direction: getDirection$1(0, -offset),
      axesEvent: axesEvent
    });
    flicking.trigger(moveStartEvent);
    if (moveStartEvent.isCanceled()) {
      transitTo(STATE_TYPE.DISABLED);
    } else {
      // Trigger DraggingState's onChange, to trigger "move" event immediately
      transitTo(STATE_TYPE.DRAGGING).onChange(ctx);
    }
  };
  __proto.onRelease = function (ctx) {
    var flicking = ctx.flicking,
      axesEvent = ctx.axesEvent,
      transitTo = ctx.transitTo;
    flicking.trigger(new ComponentEvent$1(EVENTS.HOLD_END, {
      axesEvent: axesEvent
    }));
    if (axesEvent.delta.flick !== 0) {
      // Sometimes "release" event on axes triggered before "change" event
      // Especially if user flicked panel fast in really short amount of time
      // if delta is not zero, that means above case happened.
      // Event flow should be HOLD_START -> MOVE_START -> MOVE -> HOLD_END
      // At least one move event should be included between holdStart and holdEnd
      axesEvent.setTo({
        flick: flicking.camera.position
      }, 0);
      transitTo(STATE_TYPE.IDLE);
      return;
    }
    // Can't handle select event here,
    // As "finish" axes event happens
    this._releaseEvent = axesEvent;
  };
  __proto.onFinish = function (ctx) {
    var e_1, _a;
    var flicking = ctx.flicking,
      transitTo = ctx.transitTo;
    // Should transite to IDLE state before select event
    // As user expects hold is already finished
    transitTo(STATE_TYPE.IDLE);
    if (!this._releaseEvent) {
      return;
    }
    // Handle release event here
    // To prevent finish event called twice
    var releaseEvent = this._releaseEvent;
    // Static click
    /* eslint-disable @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access */
    var srcEvent = releaseEvent.inputEvent.srcEvent;
    var clickedElement;
    if (srcEvent.type === "touchend") {
      var touchEvent = srcEvent;
      var touch = touchEvent.changedTouches[0];
      clickedElement = document.elementFromPoint(touch.clientX, touch.clientY);
    } else {
      clickedElement = srcEvent.target;
    }
    /* eslint-enable */
    var panels = flicking.renderer.panels;
    var clickedPanel = null;
    try {
      for (var panels_1 = __values$1(panels), panels_1_1 = panels_1.next(); !panels_1_1.done; panels_1_1 = panels_1.next()) {
        var panel = panels_1_1.value;
        if (panel.contains(clickedElement)) {
          clickedPanel = panel;
          break;
        }
      }
    } catch (e_1_1) {
      e_1 = {
        error: e_1_1
      };
    } finally {
      try {
        if (panels_1_1 && !panels_1_1.done && (_a = panels_1.return)) _a.call(panels_1);
      } finally {
        if (e_1) throw e_1.error;
      }
    }
    if (clickedPanel) {
      var cameraPosition = flicking.camera.position;
      var clickedPanelPosition = clickedPanel.position;
      flicking.trigger(new ComponentEvent$1(EVENTS.SELECT, {
        index: clickedPanel.index,
        panel: clickedPanel,
        // Direction to the clicked panel
        direction: getDirection$1(cameraPosition, clickedPanelPosition)
      }));
    }
  };
  return HoldingState;
}(State);

/**
 * A state that activates when user's dragging the Flicking area
 * @ko 사용자가 드래깅중인 상태
 * @internal
 */
var DraggingState = /*#__PURE__*/function (_super) {
  __extends$3(DraggingState, _super);
  function DraggingState() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    /**
     * Whether user is clicking or touching
     * @ko 현재 사용자가 클릭/터치중인지 여부
     * @type {true}
     * @readonly
     */
    _this.holding = true;
    /**
     * Whether Flicking's animating
     * @ko 현재 애니메이션 동작 여부
     * @type {true}
     * @readonly
     */
    _this.animating = true;
    return _this;
  }
  var __proto = DraggingState.prototype;
  __proto.onChange = function (ctx) {
    this._moveToChangedPosition(ctx);
  };
  __proto.onRelease = function (ctx) {
    var _a;
    var flicking = ctx.flicking,
      axesEvent = ctx.axesEvent,
      transitTo = ctx.transitTo;
    // Update last position to cope with Axes's animating behavior
    // Axes uses start position when animation start
    flicking.trigger(new ComponentEvent$1(EVENTS.HOLD_END, {
      axesEvent: axesEvent
    }));
    if (flicking.renderer.panelCount <= 0) {
      // There're no panels
      transitTo(STATE_TYPE.IDLE);
      return;
    }
    transitTo(STATE_TYPE.ANIMATING);
    var control = flicking.control;
    var position = axesEvent.destPos[POSITION_KEY];
    var duration = Math.max(axesEvent.duration, flicking.duration);
    try {
      void control.moveToPosition(position, duration, axesEvent);
    } catch (err) {
      transitTo(STATE_TYPE.IDLE);
      axesEvent.setTo((_a = {}, _a[POSITION_KEY] = flicking.camera.position, _a), 0);
    }
  };
  return DraggingState;
}(State);

/**
 * A state that activates when Flicking's animating by user input or method call
 * @ko 사용자 입력이나 메소드 호출에 의해 Flicking의 애니메이션이 동작중인 상태
 * @internal
 */
var AnimatingState = /*#__PURE__*/function (_super) {
  __extends$3(AnimatingState, _super);
  function AnimatingState() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    /**
     * Whether user is clicking or touching
     * @ko 현재 사용자가 클릭/터치중인지 여부
     * @type {false}
     * @readonly
     */
    _this.holding = false;
    /**
     * Whether Flicking's animating
     * @ko 현재 애니메이션 동작 여부
     * @type {true}
     * @readonly
     */
    _this.animating = true;
    return _this;
  }
  var __proto = AnimatingState.prototype;
  __proto.onHold = function (ctx) {
    var flicking = ctx.flicking,
      axesEvent = ctx.axesEvent,
      transitTo = ctx.transitTo;
    var targetPanel = this._targetPanel;
    var control = flicking.control;
    this._delta = 0;
    flicking.control.updateInput();
    if (flicking.changeOnHold && targetPanel) {
      control.setActive(targetPanel, control.activePanel, axesEvent.isTrusted);
    }
    var holdStartEvent = new ComponentEvent$1(EVENTS.HOLD_START, {
      axesEvent: axesEvent
    });
    flicking.trigger(holdStartEvent);
    if (holdStartEvent.isCanceled()) {
      transitTo(STATE_TYPE.DISABLED);
    } else {
      transitTo(STATE_TYPE.DRAGGING);
    }
  };
  __proto.onChange = function (ctx) {
    this._moveToChangedPosition(ctx);
  };
  __proto.onFinish = function (ctx) {
    var flicking = ctx.flicking,
      axesEvent = ctx.axesEvent,
      transitTo = ctx.transitTo;
    var control = flicking.control;
    var controller = control.controller;
    var animatingContext = controller.animatingContext;
    transitTo(STATE_TYPE.IDLE);
    flicking.trigger(new ComponentEvent$1(EVENTS.MOVE_END, {
      isTrusted: axesEvent.isTrusted,
      direction: getDirection$1(animatingContext.start, animatingContext.end),
      axesEvent: axesEvent
    }));
    var targetPanel = this._targetPanel;
    if (targetPanel) {
      control.setActive(targetPanel, control.activePanel, axesEvent.isTrusted);
    }
  };
  return AnimatingState;
}(State);

/**
 * A state that activates when Flicking is stopped by event's `stop` method
 * @ko 이벤트의 `stop`호출에 의해 Flicking이 정지된 상태
 * @internal
 */
var DisabledState = /*#__PURE__*/function (_super) {
  __extends$3(DisabledState, _super);
  function DisabledState() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    /**
     * Whether user is clicking or touching
     * @ko 현재 사용자가 클릭/터치중인지 여부
     * @type {false}
     * @readonly
     */
    _this.holding = false;
    /**
     * Whether Flicking's animating
     * @ko 현재 애니메이션 동작 여부
     * @type {true}
     * @readonly
     */
    _this.animating = true;
    return _this;
  }
  var __proto = DisabledState.prototype;
  __proto.onAnimationEnd = function (ctx) {
    var transitTo = ctx.transitTo;
    transitTo(STATE_TYPE.IDLE);
  };
  __proto.onChange = function (ctx) {
    var axesEvent = ctx.axesEvent,
      transitTo = ctx.transitTo;
    // Can stop Axes's change event
    axesEvent.stop();
    transitTo(STATE_TYPE.IDLE);
  };
  __proto.onRelease = function (ctx) {
    var axesEvent = ctx.axesEvent,
      transitTo = ctx.transitTo;
    // This is needed when stopped hold start event
    if (axesEvent.delta.flick === 0) {
      transitTo(STATE_TYPE.IDLE);
    }
  };
  return DisabledState;
}(State);

/**
 * @internal
 */
var StateMachine = /*#__PURE__*/function () {
  function StateMachine() {
    var _this = this;
    this.transitTo = function (nextStateType) {
      var nextState;
      switch (nextStateType) {
        case STATE_TYPE.IDLE:
          nextState = new IdleState();
          break;
        case STATE_TYPE.HOLDING:
          nextState = new HoldingState();
          break;
        case STATE_TYPE.DRAGGING:
          nextState = new DraggingState();
          break;
        case STATE_TYPE.ANIMATING:
          nextState = new AnimatingState();
          break;
        case STATE_TYPE.DISABLED:
          nextState = new DisabledState();
          break;
      }
      nextState.onEnter(_this._state);
      _this._state = nextState;
      return _this._state;
    };
    this._state = new IdleState();
  }
  var __proto = StateMachine.prototype;
  Object.defineProperty(__proto, "state", {
    get: function () {
      return this._state;
    },
    enumerable: false,
    configurable: true
  });
  __proto.fire = function (eventType, externalCtx) {
    var currentState = this._state;
    var ctx = __assign$2(__assign$2({}, externalCtx), {
      transitTo: this.transitTo
    });
    switch (eventType) {
      case EVENT.HOLD:
        currentState.onHold(ctx);
        break;
      case EVENT.CHANGE:
        currentState.onChange(ctx);
        break;
      case EVENT.RELEASE:
        currentState.onRelease(ctx);
        break;
      case EVENT.ANIMATION_END:
        currentState.onAnimationEnd(ctx);
        break;
      case EVENT.FINISH:
        currentState.onFinish(ctx);
        break;
    }
  };
  return StateMachine;
}();

/**
 * A controller that handles the {@link https://naver.github.io/egjs-axes/ @egjs/axes} events
 * @ko {@link https://naver.github.io/egjs-axes/ @egjs/axes}의 이벤트를 처리하는 컨트롤러 컴포넌트
 * @internal
 */
var AxesController = /*#__PURE__*/function () {
  /** */
  function AxesController() {
    var _this = this;
    this._onAxesHold = function () {
      _this._dragged = false;
    };
    this._onAxesChange = function () {
      var _a;
      _this._dragged = !!((_a = _this._panInput) === null || _a === void 0 ? void 0 : _a.isEnabled());
    };
    this._preventClickWhenDragged = function (e) {
      if (_this._dragged) {
        e.preventDefault();
        e.stopPropagation();
      }
      _this._dragged = false;
    };
    this._resetInternalValues();
    this._stateMachine = new StateMachine();
  }
  var __proto = AxesController.prototype;
  Object.defineProperty(__proto, "axes", {
    /**
     * An {@link https://naver.github.io/egjs-axes/docs/api/Axes Axes} instance
     * @ko {@link https://naver.github.io/egjs-axes/docs/api/Axes Axes}의 인스턴스
     * @type {Axes | null}
     * @see https://naver.github.io/egjs-axes/docs/api/Axes
     * @readonly
     */
    get: function () {
      return this._axes;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "panInput", {
    /**
     * An {@link https://naver.github.io/egjs-axes/docs/api/PanInput PanInput} instance
     * @ko {@link https://naver.github.io/egjs-axes/docs/api/PanInput PanInput}의 인스턴스
     * @type {PanInput | null}
     * @see https://naver.github.io/egjs-axes/docs/api/PanInput
     * @readonly
     */
    get: function () {
      return this._panInput;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "stateMachine", {
    /**
     * @internal
     */
    get: function () {
      return this._stateMachine;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "state", {
    /**
     * A activated {@link State} that shows the current status of the user input or the animation
     * @ko 현재 활성화된 {@link State} 인스턴스로 사용자 입력 또는 애니메이션 상태를 나타냅니다
     * @type {State}
     */
    get: function () {
      return this._stateMachine.state;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "animatingContext", {
    /**
     * A context of the current animation playing
     * @ko 현재 재생중인 애니메이션 정보
     * @type {object}
     * @property {number} start A start position of the animation<ko>애니메이션 시작 지점</ko>
     * @property {number} end A end position of the animation<ko>애니메이션 끝 지점</ko>
     * @property {number} offset camera offset<ko>카메라 오프셋</ko>
     * @readonly
     */
    get: function () {
      return this._animatingContext;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "controlParams", {
    /**
     * A current control parameters of the Axes instance
     * @ko 활성화된 현재 Axes 패러미터들
     * @type {ControlParams}
     */
    get: function () {
      var axes = this._axes;
      if (!axes) {
        return {
          range: {
            min: 0,
            max: 0
          },
          position: 0,
          circular: false
        };
      }
      var axis = axes.axis[POSITION_KEY];
      return {
        range: {
          min: axis.range[0],
          max: axis.range[1]
        },
        circular: axis.circular[0],
        position: this.position
      };
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "enabled", {
    /**
     * A Boolean indicating whether the user input is enabled
     * @ko 현재 사용자 입력이 활성화되었는지를 나타내는 값
     * @type {boolean}
     * @readonly
     */
    get: function () {
      var _a, _b;
      return (_b = (_a = this._panInput) === null || _a === void 0 ? void 0 : _a.isEnabled()) !== null && _b !== void 0 ? _b : false;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "position", {
    /**
     * Current position value in {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html Axes} instance
     * @ko {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html Axes} 인스턴스 내부의 현재 좌표 값
     * @type {number}
     * @readonly
     */
    get: function () {
      var _a, _b;
      return (_b = (_a = this._axes) === null || _a === void 0 ? void 0 : _a.get([POSITION_KEY])[POSITION_KEY]) !== null && _b !== void 0 ? _b : 0;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "range", {
    /**
     * Current range value in {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html Axes} instance
     * @ko {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html Axes} 인스턴스 내부의 현재 이동 범위 값
     * @type {number[]}
     * @readonly
     */
    get: function () {
      var _a, _b;
      return (_b = (_a = this._axes) === null || _a === void 0 ? void 0 : _a.axis[POSITION_KEY].range) !== null && _b !== void 0 ? _b : [0, 0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "bounce", {
    /**
     * Actual bounce size(px)
     * @ko 적용된 bounce 크기(px 단위)
     * @type {number[]}
     * @readonly
     */
    get: function () {
      var _a;
      return (_a = this._axes) === null || _a === void 0 ? void 0 : _a.axis[POSITION_KEY].bounce;
    },
    enumerable: false,
    configurable: true
  });
  /**
   * Initialize AxesController
   * @ko AxesController를 초기화합니다
   * @param {Flicking} flicking An instance of Flicking
   * @chainable
   * @return {this}
   */
  __proto.init = function (flicking) {
    var _a;
    var _this = this;
    this._flicking = flicking;
    this._axes = new Axes((_a = {}, _a[POSITION_KEY] = {
      range: [0, 0],
      circular: false,
      bounce: [0, 0]
    }, _a), {
      deceleration: flicking.deceleration,
      interruptable: flicking.interruptable,
      nested: flicking.nested,
      easing: flicking.easing
    });
    this._panInput = new PanInput(flicking.viewport.element, {
      inputType: flicking.inputType,
      threshold: 1,
      iOSEdgeSwipeThreshold: flicking.iOSEdgeSwipeThreshold,
      preventDefaultOnDrag: flicking.preventDefaultOnDrag,
      scale: flicking.horizontal ? [flicking.camera.panelOrder === ORDER.RTL ? 1 : -1, 0] : [0, -1],
      releaseOnScroll: true
    });
    var axes = this._axes;
    axes.connect(flicking.horizontal ? [POSITION_KEY, ""] : ["", POSITION_KEY], this._panInput);
    var _loop_1 = function (key) {
      var eventType = EVENT[key];
      axes.on(eventType, function (e) {
        _this._stateMachine.fire(eventType, {
          flicking: flicking,
          axesEvent: e
        });
      });
    };
    for (var key in EVENT) {
      _loop_1(key);
    }
    return this;
  };
  /**
   * Destroy AxesController and return to initial state
   * @ko AxesController를 초기 상태로 되돌립니다
   * @return {void}
   */
  __proto.destroy = function () {
    var _a;
    if (this._axes) {
      this.removePreventClickHandler();
      this._axes.destroy();
    }
    (_a = this._panInput) === null || _a === void 0 ? void 0 : _a.destroy();
    this._resetInternalValues();
  };
  /**
   * Enable input from the user (mouse/touch)
   * @ko 사용자의 입력(마우스/터치)를 활성화합니다
   * @chainable
   * @return {this}
   */
  __proto.enable = function () {
    var _a;
    (_a = this._panInput) === null || _a === void 0 ? void 0 : _a.enable();
    return this;
  };
  /**
   * Disable input from the user (mouse/touch)
   * @ko 사용자의 입력(마우스/터치)를 막습니다
   * @chainable
   * @return {this}
   */
  __proto.disable = function () {
    var _a;
    (_a = this._panInput) === null || _a === void 0 ? void 0 : _a.disable();
    return this;
  };
  /**
   * Releases ongoing user input (mouse/touch)
   * @ko 사용자의 현재 입력(마우스/터치)를 중단시킵니다
   * @chainable
   * @return {this}
   */
  __proto.release = function () {
    var _a;
    (_a = this._panInput) === null || _a === void 0 ? void 0 : _a.release();
    return this;
  };
  /**
   * Change the destination and duration of the animation currently playing
   * @ko 재생 중인 애니메이션의 목적지와 재생 시간을 변경합니다
   * @param {number} position A position to move<ko>이동할 좌표</ko>
   * @param {number} duration Duration of the animation (unit: ms)<ko>애니메이션 진행 시간 (단위: ms)</ko>
   * @chainable
   * @return {this}
   */
  __proto.updateAnimation = function (position, duration) {
    var _a;
    var _b;
    this._animatingContext = __assign$2(__assign$2({}, this._animatingContext), {
      end: position
    });
    (_b = this._axes) === null || _b === void 0 ? void 0 : _b.updateAnimation({
      destPos: (_a = {}, _a[POSITION_KEY] = position, _a),
      duration: duration
    });
    return this;
  };
  /**
   * Stops the animation currently playing
   * @ko 재생 중인 애니메이션을 중단시킵니다
   * @chainable
   * @return {this}
   */
  __proto.stopAnimation = function () {
    var _a;
    (_a = this._axes) === null || _a === void 0 ? void 0 : _a.stopAnimation();
    return this;
  };
  /**
   * Update {@link https://naver.github.io/egjs-axes/ @egjs/axes}'s state
   * @ko {@link https://naver.github.io/egjs-axes/ @egjs/axes}의 상태를 갱신합니다
   * @chainable
   * @throws {FlickingError}
   * {@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} When {@link AxesController#init init} is not called before
   * <ko>{@link AxesController#init init}이 이전에 호출되지 않은 경우</ko>
   * @return {this}
   */
  __proto.update = function (controlParams) {
    var _a;
    var flicking = getFlickingAttached(this._flicking);
    var camera = flicking.camera;
    var axes = this._axes;
    var axis = axes.axis[POSITION_KEY];
    axis.circular = [controlParams.circular, controlParams.circular];
    axis.range = [controlParams.range.min, controlParams.range.max];
    axis.bounce = parseBounce(flicking.bounce, camera.size);
    axes.axisManager.set((_a = {}, _a[POSITION_KEY] = controlParams.position, _a));
    return this;
  };
  /**
   * Attach a handler to the camera element to prevent click events during animation
   * @ko 카메라 엘리먼트에 애니메이션 도중에 클릭 이벤트를 방지하는 핸들러를 부착합니다
   * @return {this}
   */
  __proto.addPreventClickHandler = function () {
    var flicking = getFlickingAttached(this._flicking);
    var axes = this._axes;
    var cameraEl = flicking.camera.element;
    axes.on(EVENT.HOLD, this._onAxesHold);
    axes.on(EVENT.CHANGE, this._onAxesChange);
    cameraEl.addEventListener("click", this._preventClickWhenDragged, true);
    return this;
  };
  /**
   * Detach a handler to the camera element to prevent click events during animation
   * @ko 카메라 엘리먼트에 애니메이션 도중에 클릭 이벤트를 방지하는 핸들러를 탈착합니다
   * @return {this}
   */
  __proto.removePreventClickHandler = function () {
    var flicking = getFlickingAttached(this._flicking);
    var axes = this._axes;
    var cameraEl = flicking.camera.element;
    axes.off(EVENT.HOLD, this._onAxesHold);
    axes.off(EVENT.CHANGE, this._onAxesChange);
    cameraEl.removeEventListener("click", this._preventClickWhenDragged, true);
    return this;
  };
  /**
   * Run Axes's {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#setTo setTo} using the given position
   * @ko Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#setTo setTo} 메소드를 주어진 좌표를 이용하여 수행합니다
   * @param {number} position A position to move<ko>이동할 좌표</ko>
   * @param {number} duration Duration of the animation (unit: ms)<ko>애니메이션 진행 시간 (단위: ms)</ko>
   * @param {number} [axesEvent] If provided, it'll use its {@link https://naver#github#io/egjs-axes/release/latest/doc/eg#Axes#html#setTo setTo} method instead<ko>이 값이 주어졌을 경우, 해당 이벤트의 {@link https://naver#github#io/egjs-axes/release/latest/doc/eg#Axes#html#setTo setTo} 메소드를 대신해서 사용합니다.</ko>
   * @throws {FlickingError}
   * |code|condition|
   * |---|---|
   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|When {@link Control#init init} is not called before|
   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|When the animation is interrupted by user input|
   * <ko>
   *
   * |code|condition|
   * |---|---|
   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|{@link Control#init init}이 이전에 호출되지 않은 경우|
   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|사용자 입력에 의해 애니메이션이 중단된 경우|
   *
   * </ko>
   * @return {Promise<void>} A Promise which will be resolved after reaching the target position<ko>해당 좌표 도달시에 resolve되는 Promise</ko>
   */
  __proto.animateTo = function (position, duration, axesEvent) {
    var _this = this;
    var _a;
    var axes = this._axes;
    var state = this._stateMachine.state;
    if (!axes) {
      return Promise.reject(new FlickingError(MESSAGE.NOT_ATTACHED_TO_FLICKING, CODE.NOT_ATTACHED_TO_FLICKING));
    }
    var startPos = axes.get([POSITION_KEY])[POSITION_KEY];
    if (startPos === position) {
      var flicking = getFlickingAttached(this._flicking);
      flicking.camera.lookAt(position);
      if (state.targetPanel) {
        flicking.control.setActive(state.targetPanel, flicking.control.activePanel, (_a = axesEvent === null || axesEvent === void 0 ? void 0 : axesEvent.isTrusted) !== null && _a !== void 0 ? _a : false);
      }
      return Promise.resolve();
    }
    this._animatingContext = {
      start: startPos,
      end: position,
      offset: 0
    };
    var animate = function () {
      var _a, _b;
      var resetContext = function () {
        _this._animatingContext = {
          start: 0,
          end: 0,
          offset: 0
        };
      };
      axes.once(EVENT.FINISH, resetContext);
      if (axesEvent) {
        axesEvent.setTo((_a = {}, _a[POSITION_KEY] = position, _a), duration);
      } else {
        axes.setTo((_b = {}, _b[POSITION_KEY] = position, _b), duration);
      }
    };
    return new Promise(function (resolve, reject) {
      var animationFinishHandler = function () {
        axes.off(EVENT.HOLD, interruptionHandler);
        resolve();
      };
      var interruptionHandler = function () {
        axes.off(EVENT.FINISH, animationFinishHandler);
        reject(new FlickingError(MESSAGE.ANIMATION_INTERRUPTED, CODE.ANIMATION_INTERRUPTED));
      };
      axes.once(EVENT.FINISH, animationFinishHandler);
      axes.once(EVENT.HOLD, interruptionHandler);
      animate();
    });
  };
  __proto.updateDirection = function () {
    var flicking = getFlickingAttached(this._flicking);
    var axes = this._axes;
    var panInput = this._panInput;
    axes.disconnect(panInput);
    axes.connect(flicking.horizontal ? [POSITION_KEY, ""] : ["", POSITION_KEY], panInput);
    panInput.options.scale = flicking.horizontal ? [flicking.camera.panelOrder === ORDER.RTL ? 1 : -1, 0] : [0, -1];
  };
  __proto._resetInternalValues = function () {
    this._flicking = null;
    this._axes = null;
    this._panInput = null;
    this._animatingContext = {
      start: 0,
      end: 0,
      offset: 0
    };
    this._dragged = false;
  };
  return AxesController;
}();

/**
 * A component that manages inputs and animation of Flicking
 * @ko Flicking의 입력 장치 & 애니메이션을 담당하는 컴포넌트
 */
var Control = /*#__PURE__*/function () {
  /** */
  function Control() {
    this._flicking = null;
    this._controller = new AxesController();
    this._activePanel = null;
  }
  var __proto = Control.prototype;
  Object.defineProperty(__proto, "controller", {
    /**
     * A controller that handles the {@link https://naver.github.io/egjs-axes/ @egjs/axes} events
     * @ko {@link https://naver.github.io/egjs-axes/ @egjs/axes}의 이벤트를 처리하는 컨트롤러 컴포넌트
     * @type {AxesController}
     * @readonly
     */
    get: function () {
      return this._controller;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "activeIndex", {
    /**
     * Index number of the {@link Flicking#currentPanel currentPanel}
     * @ko {@link Flicking#currentPanel currentPanel}의 인덱스 번호
     * @type {number}
     * @default 0
     * @readonly
     */
    get: function () {
      var _a, _b;
      return (_b = (_a = this._activePanel) === null || _a === void 0 ? void 0 : _a.index) !== null && _b !== void 0 ? _b : -1;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "activePanel", {
    /**
     * An active panel
     * @ko 현재 선택된 패널
     * @type {Panel | null}
     * @readonly
     */
    get: function () {
      return this._activePanel;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "animating", {
    /**
     * Whether Flicking's animating
     * @ko 현재 애니메이션 동작 여부
     * @type {boolean}
     * @readonly
     */
    get: function () {
      return this._controller.state.animating;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "holding", {
    /**
     * Whether user is clicking or touching
     * @ko 현재 사용자가 클릭/터치중인지 여부
     * @type {boolean}
     * @readonly
     */
    get: function () {
      return this._controller.state.holding;
    },
    enumerable: false,
    configurable: true
  });
  /**
   * Initialize Control
   * @ko Control을 초기화합니다
   * @param {Flicking} flicking An instance of {@link Flicking}<ko>Flicking의 인스턴스</ko>
   * @chainable
   * @return {this}
   */
  __proto.init = function (flicking) {
    this._flicking = flicking;
    this._controller.init(flicking);
    return this;
  };
  /**
   * Destroy Control and return to initial state
   * @ko Control을 초기 상태로 되돌립니다
   * @return {void}
   */
  __proto.destroy = function () {
    this._controller.destroy();
    this._flicking = null;
    this._activePanel = null;
  };
  /**
   * Enable input from the user (mouse/touch)
   * @ko 사용자의 입력(마우스/터치)를 활성화합니다
   * @chainable
   * @return {this}
   */
  __proto.enable = function () {
    this._controller.enable();
    return this;
  };
  /**
   * Disable input from the user (mouse/touch)
   * @ko 사용자의 입력(마우스/터치)를 막습니다
   * @chainable
   * @return {this}
   */
  __proto.disable = function () {
    this._controller.disable();
    return this;
  };
  /**
   * Releases ongoing user input (mouse/touch)
   * @ko 사용자의 현재 입력(마우스/터치)를 중단시킵니다
   * @chainable
   * @return {this}
   */
  __proto.release = function () {
    this._controller.release();
    return this;
  };
  /**
   * Change the destination and duration of the animation currently playing
   * @ko 재생 중인 애니메이션의 목적지와 재생 시간을 변경합니다
   * @param {Panel} panel The target panel to move<ko>이동할 패널</ko>
   * @param {number} duration Duration of the animation (unit: ms)<ko>애니메이션 진행 시간 (단위: ms)</ko>
   * @param {DIRECTION} direction Direction to move, only available in the {@link Flicking#circular circular} mode<ko>이동할 방향. {@link Flicking#circular circular} 옵션 활성화시에만 사용 가능합니다</ko>
   * @chainable
   * @throws {FlickingError}
   * {@link ERROR_CODE POSITION_NOT_REACHABLE} When the given panel is already removed or not in the Camera's {@link Camera#range range}
   * <ko>{@link ERROR_CODE POSITION_NOT_REACHABLE} 주어진 패널이 제거되었거나, Camera의 {@link Camera#range range} 밖에 있을 경우</ko>
   * @return {this}
   */
  __proto.updateAnimation = function (panel, duration, direction) {
    var state = this._controller.state;
    var position = this._getPosition(panel, direction !== null && direction !== void 0 ? direction : DIRECTION.NONE);
    state.targetPanel = panel;
    this._controller.updateAnimation(position, duration);
    return this;
  };
  /**
   * Stops the animation currently playing
   * @ko 재생 중인 애니메이션을 중단시킵니다
   * @chainable
   * @return {this}
   */
  __proto.stopAnimation = function () {
    var state = this._controller.state;
    state.targetPanel = null;
    this._controller.stopAnimation();
    return this;
  };
  /**
   * Update position after resizing
   * @ko resize 이후에 position을 업데이트합니다
   * @param {number} progressInPanel Previous camera's progress in active panel before resize<ko>Resize 이전 현재 선택된 패널 내에서의 카메라 progress 값</ko>
   * @throws {FlickingError}
   * {@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} When {@link Camera#init init} is not called before
   * <ko>{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} {@link Camera#init init}이 이전에 호출되지 않은 경우</ko>
   * @chainable
   * @return {Promise<void>}
   */
  __proto.updatePosition = function (progressInPanel) {
    var flicking = getFlickingAttached(this._flicking);
    var camera = flicking.camera;
    var activePanel = this._activePanel;
    if (activePanel) {
      camera.lookAt(camera.clampToReachablePosition(activePanel.position));
    }
  };
  /**
   * Update {@link Control#controller controller}'s state
   * @ko {@link Control#controller controller}의 내부 상태를 갱신합니다
   * @chainable
   * @return {this}
   */
  __proto.updateInput = function () {
    var flicking = getFlickingAttached(this._flicking);
    var camera = flicking.camera;
    this._controller.update(camera.controlParams);
    return this;
  };
  /**
   * Reset {@link Control#activePanel activePanel} to `null`
   * @ko {@link Control#activePanel activePanel}을 `null`로 초기화합니다
   * @chainable
   * @return {this}
   */
  __proto.resetActive = function () {
    this._activePanel = null;
    return this;
  };
  /**
   * Move {@link Camera} to the given panel
   * @ko {@link Camera}를 해당 패널 위로 이동합니다
   * @param {Panel} panel The target panel to move<ko>이동할 패널</ko>
   * @param {object} options An options object<ko>옵션 오브젝트</ko>
   * @param {number} duration Duration of the animation (unit: ms)<ko>애니메이션 진행 시간 (단위: ms)</ko>
   * @param {object} [axesEvent] {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} event of {@link https://naver.github.io/egjs-axes/ Axes}
   * <ko>{@link https://naver.github.io/egjs-axes/ Axes}의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} 이벤트</ko>
   * @param {DIRECTION} [direction=DIRECTION.NONE] Direction to move, only available in the {@link Flicking#circular circular} mode<ko>이동할 방향. {@link Flicking#circular circular} 옵션 활성화시에만 사용 가능합니다</ko>
   * @fires Flicking#moveStart
   * @fires Flicking#move
   * @fires Flicking#moveEnd
   * @fires Flicking#willChange
   * @fires Flicking#changed
   * @fires Flicking#willRestore
   * @fires Flicking#restored
   * @fires Flicking#needPanel
   * @fires Flicking#visibleChange
   * @fires Flicking#reachEdge
   * @throws {FlickingError}
   * |code|condition|
   * |---|---|
   * |{@link ERROR_CODE POSITION_NOT_REACHABLE}|When the given panel is already removed or not in the Camera's {@link Camera#range range}|
   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|When {@link Control#init init} is not called before|
   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|When the animation is interrupted by user input|
   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|When the animation is interrupted by user input|
   * <ko>
   *
   * |code|condition|
   * |---|---|
   * |{@link ERROR_CODE POSITION_NOT_REACHABLE}|주어진 패널이 제거되었거나, Camera의 {@link Camera#range range} 밖에 있을 경우|
   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|{@link Control#init init}이 이전에 호출되지 않은 경우|
   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|사용자 입력에 의해 애니메이션이 중단된 경우|
   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|발생된 이벤트들 중 하나라도 `stop()`이 호출된 경우|
   *
   * </ko>
   * @return {Promise<void>} A Promise which will be resolved after reaching the target panel<ko>해당 패널 도달시에 resolve되는 Promise</ko>
   */
  __proto.moveToPanel = function (panel, _a) {
    var duration = _a.duration,
      _b = _a.direction,
      direction = _b === void 0 ? DIRECTION.NONE : _b,
      axesEvent = _a.axesEvent;
    return __awaiter(this, void 0, void 0, function () {
      var position;
      return __generator(this, function (_c) {
        position = this._getPosition(panel, direction);
        this._triggerIndexChangeEvent(panel, panel.position, axesEvent, direction);
        return [2 /*return*/, this._animateToPosition({
          position: position,
          duration: duration,
          newActivePanel: panel,
          axesEvent: axesEvent
        })];
      });
    });
  };
  /**
   * @internal
   */
  __proto.setActive = function (newActivePanel, prevActivePanel, isTrusted) {
    var _a;
    var flicking = getFlickingAttached(this._flicking);
    this._activePanel = newActivePanel;
    this._nextPanel = null;
    flicking.camera.updateAdaptiveHeight();
    if (newActivePanel !== prevActivePanel) {
      flicking.trigger(new ComponentEvent$1(EVENTS.CHANGED, {
        index: newActivePanel.index,
        panel: newActivePanel,
        prevIndex: (_a = prevActivePanel === null || prevActivePanel === void 0 ? void 0 : prevActivePanel.index) !== null && _a !== void 0 ? _a : -1,
        prevPanel: prevActivePanel,
        isTrusted: isTrusted,
        direction: prevActivePanel ? getDirection$1(prevActivePanel.position, newActivePanel.position) : DIRECTION.NONE
      }));
    } else {
      flicking.trigger(new ComponentEvent$1(EVENTS.RESTORED, {
        isTrusted: isTrusted
      }));
    }
  };
  /**
   * @internal
   */
  __proto.copy = function (control) {
    this._flicking = control._flicking;
    this._activePanel = control._activePanel;
    this._controller = control._controller;
  };
  __proto._triggerIndexChangeEvent = function (panel, position, axesEvent, direction) {
    var _a;
    var flicking = getFlickingAttached(this._flicking);
    var triggeringEvent = panel !== this._activePanel ? EVENTS.WILL_CHANGE : EVENTS.WILL_RESTORE;
    var camera = flicking.camera;
    var activePanel = this._activePanel;
    var event = new ComponentEvent$1(triggeringEvent, {
      index: panel.index,
      panel: panel,
      isTrusted: (axesEvent === null || axesEvent === void 0 ? void 0 : axesEvent.isTrusted) || false,
      direction: direction !== null && direction !== void 0 ? direction : getDirection$1((_a = activePanel === null || activePanel === void 0 ? void 0 : activePanel.position) !== null && _a !== void 0 ? _a : camera.position, position)
    });
    this._nextPanel = panel;
    flicking.trigger(event);
    if (event.isCanceled()) {
      throw new FlickingError(MESSAGE.STOP_CALLED_BY_USER, CODE.STOP_CALLED_BY_USER);
    }
  };
  __proto._animateToPosition = function (_a) {
    var position = _a.position,
      duration = _a.duration,
      newActivePanel = _a.newActivePanel,
      axesEvent = _a.axesEvent;
    return __awaiter(this, void 0, void 0, function () {
      var flicking, animate, state;
      var _this = this;
      return __generator(this, function (_b) {
        flicking = getFlickingAttached(this._flicking);
        animate = function () {
          return _this._controller.animateTo(position, duration, axesEvent);
        };
        state = this._controller.state;
        state.targetPanel = newActivePanel;
        if (duration <= 0) {
          return [2 /*return*/, animate()];
        } else {
          return [2 /*return*/, animate().then(function () {
            return __awaiter(_this, void 0, void 0, function () {
              return __generator(this, function (_a) {
                switch (_a.label) {
                  case 0:
                    return [4 /*yield*/, flicking.renderer.render()];
                  case 1:
                    _a.sent();
                    return [2 /*return*/];
                }
              });
            });
          }).catch(function (err) {
            if (axesEvent && err instanceof FlickingError && err.code === CODE.ANIMATION_INTERRUPTED) return;
            throw err;
          })];
        }
      });
    });
  };

  __proto._getPosition = function (panel, direction) {
    if (direction === void 0) {
      direction = DIRECTION.NONE;
    }
    var flicking = getFlickingAttached(this._flicking);
    var camera = flicking.camera;
    var position = panel.position;
    var nearestAnchor = camera.findNearestAnchor(position);
    if (panel.removed || !nearestAnchor) {
      throw new FlickingError(MESSAGE.POSITION_NOT_REACHABLE(panel.position), CODE.POSITION_NOT_REACHABLE);
    }
    if (!camera.canReach(panel)) {
      // Override position & panel if that panel is not reachable
      position = nearestAnchor.position;
      panel = nearestAnchor.panel;
    } else if (flicking.circularEnabled) {
      // Circular mode is enabled, find nearest distance to panel
      var camPos_1 = this._controller.position; // Actual position of the Axes
      var camRangeDiff = camera.rangeDiff;
      var possiblePositions = [position, position + camRangeDiff, position - camRangeDiff].filter(function (pos) {
        if (direction === DIRECTION.NONE) return true;
        return direction === DIRECTION.PREV ? pos <= camPos_1 : pos >= camPos_1;
      });
      position = possiblePositions.reduce(function (nearestPosition, pos) {
        if (Math.abs(camPos_1 - pos) < Math.abs(camPos_1 - nearestPosition)) {
          return pos;
        } else {
          return nearestPosition;
        }
      }, Infinity);
    }
    return position;
  };
  return Control;
}();

/**
 * A data component that has actual position where the camera should be stopped at
 * @ko 카메라가 정지해야하는 실제 위치를 담고 있는 데이터 컴포넌트
 */
var AnchorPoint = /*#__PURE__*/function () {
  /**
   * @param {object} options An options object<ko>옵션 객체</ko>
   * @param {number} [options.index] Index of AnchorPoint<ko>AnchorPoint의 인덱스</ko>
   * @param {number} [options.position] Position of AnchorPoint<ko>AnchorPoint의 좌표</ko>
   * @param {Panel} [options.panel] A {@link Panel} instance AnchorPoint is referencing to<ko>AnchorPoint가 참조하고 있는 {@link Panel}</ko>
   */
  function AnchorPoint(_a) {
    var index = _a.index,
      position = _a.position,
      panel = _a.panel;
    this._index = index;
    this._pos = position;
    this._panel = panel;
  }
  var __proto = AnchorPoint.prototype;
  Object.defineProperty(__proto, "index", {
    /**
     * Index of AnchorPoint
     * @ko AnchorPoint의 인덱스
     * @type {number}
     * @readonly
     */
    get: function () {
      return this._index;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "position", {
    /**
     * Position of AnchorPoint
     * @ko AnchorPoint의 좌표
     * @type {number}
     * @readonly
     */
    get: function () {
      return this._pos;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "panel", {
    /**
     * A {@link Panel} instance AnchorPoint is referencing to
     * @ko AnchorPoint가 참조하고 있는 {@link Panel}
     * @type {Panel}
     * @readonly
     */
    get: function () {
      return this._panel;
    },
    enumerable: false,
    configurable: true
  });
  return AnchorPoint;
}();

/**
 * A {@link Control} that uses a release momentum to choose destination panel
 * @ko 입력을 중단한 시점의 가속도에 영향받아 도달할 패널을 계산하는 이동 방식을 사용하는 {@link Control}
 */
var SnapControl = /*#__PURE__*/function (_super) {
  __extends$3(SnapControl, _super);
  /** */
  function SnapControl(_a) {
    var _b = (_a === void 0 ? {} : _a).count,
      count = _b === void 0 ? Infinity : _b;
    var _this = _super.call(this) || this;
    _this._count = count;
    return _this;
  }
  var __proto = SnapControl.prototype;
  Object.defineProperty(__proto, "count", {
    /**
     * Maximum number of panels can go after release
     * @ko 입력 중단 이후 통과하여 이동할 수 있는 패널의 최대 갯수
     * @type {number}
     * @default Infinity
     */
    get: function () {
      return this._count;
    },
    set: function (val) {
      this._count = val;
    },
    enumerable: false,
    configurable: true
  });
  /**
   * Move {@link Camera} to the given position
   * @ko {@link Camera}를 주어진 좌표로 이동합니다
   * @param {number} position The target position to move<ko>이동할 좌표</ko>
   * @param {number} duration Duration of the panel movement animation (unit: ms).<ko>패널 이동 애니메이션 진행 시간 (단위: ms)</ko>
   * @param {object} [axesEvent] {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} event of {@link https://naver.github.io/egjs-axes/ Axes}
   * <ko>{@link https://naver.github.io/egjs-axes/ Axes}의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} 이벤트</ko>
   * @fires Flicking#moveStart
   * @fires Flicking#move
   * @fires Flicking#moveEnd
   * @fires Flicking#willChange
   * @fires Flicking#changed
   * @fires Flicking#willRestore
   * @fires Flicking#restored
   * @fires Flicking#needPanel
   * @fires Flicking#visibleChange
   * @fires Flicking#reachEdge
   * @throws {FlickingError}
   * |code|condition|
   * |---|---|
   * |{@link ERROR_CODE POSITION_NOT_REACHABLE}|When the given panel is already removed or not in the Camera's {@link Camera#range range}|
   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|When {@link Control#init init} is not called before|
   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|When the animation is interrupted by user input|
   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|When the animation is interrupted by user input|
   * <ko>
   *
   * |code|condition|
   * |---|---|
   * |{@link ERROR_CODE POSITION_NOT_REACHABLE}|주어진 패널이 제거되었거나, Camera의 {@link Camera#range range} 밖에 있을 경우|
   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|{@link Control#init init}이 이전에 호출되지 않은 경우|
   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|사용자 입력에 의해 애니메이션이 중단된 경우|
   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|발생된 이벤트들 중 하나라도 `stop()`이 호출된 경우|
   *
   * </ko>
   * @return {Promise<void>} A Promise which will be resolved after reaching the target position<ko>해당 좌표 도달시에 resolve되는 Promise</ko>
   */
  __proto.moveToPosition = function (position, duration, axesEvent) {
    var flicking = getFlickingAttached(this._flicking);
    var camera = flicking.camera;
    var activeAnchor = camera.findActiveAnchor();
    var anchorAtCamera = camera.findNearestAnchor(camera.position);
    var state = this._controller.state;
    if (!activeAnchor || !anchorAtCamera) {
      return Promise.reject(new FlickingError(MESSAGE.POSITION_NOT_REACHABLE(position), CODE.POSITION_NOT_REACHABLE));
    }
    var snapThreshold = this._calcSnapThreshold(flicking.threshold, position, activeAnchor);
    var posDelta = flicking.animating ? state.delta : position - camera.position;
    var absPosDelta = Math.abs(posDelta);
    var snapDelta = axesEvent && axesEvent.delta[POSITION_KEY] !== 0 ? Math.abs(axesEvent.delta[POSITION_KEY]) : absPosDelta;
    var targetAnchor;
    if (snapDelta >= snapThreshold && snapDelta > 0) {
      // Move to anchor at position
      targetAnchor = this._findSnappedAnchor(position, anchorAtCamera);
    } else if (absPosDelta >= flicking.threshold && absPosDelta > 0) {
      // Move to the adjacent panel
      targetAnchor = this._findAdjacentAnchor(position, posDelta, anchorAtCamera);
    } else {
      // Fallback to nearest panel from current camera
      return this.moveToPanel(anchorAtCamera.panel, {
        duration: duration,
        axesEvent: axesEvent
      });
    }
    this._triggerIndexChangeEvent(targetAnchor.panel, position, axesEvent);
    return this._animateToPosition({
      position: camera.clampToReachablePosition(targetAnchor.position),
      duration: duration,
      newActivePanel: targetAnchor.panel,
      axesEvent: axesEvent
    });
  };
  __proto._findSnappedAnchor = function (position, anchorAtCamera) {
    var flicking = getFlickingAttached(this._flicking);
    var camera = flicking.camera;
    var count = this._count;
    var currentPos = camera.position;
    var clampedPosition = camera.clampToReachablePosition(position);
    var anchorAtPosition = camera.findAnchorIncludePosition(clampedPosition);
    if (!anchorAtCamera || !anchorAtPosition) {
      throw new FlickingError(MESSAGE.POSITION_NOT_REACHABLE(position), CODE.POSITION_NOT_REACHABLE);
    }
    if (!isFinite(count)) {
      return anchorAtPosition;
    }
    var panelCount = flicking.panelCount;
    var anchors = camera.anchorPoints;
    var loopCount = Math.sign(position - currentPos) * Math.floor(Math.abs(position - currentPos) / camera.rangeDiff);
    if (position > currentPos && anchorAtPosition.index < anchorAtCamera.index || anchorAtPosition.position > anchorAtCamera.position && anchorAtPosition.index === anchorAtCamera.index) {
      loopCount += 1;
    } else if (position < currentPos && anchorAtPosition.index > anchorAtCamera.index || anchorAtPosition.position < anchorAtCamera.position && anchorAtPosition.index === anchorAtCamera.index) {
      loopCount -= 1;
    }
    var circularIndexOffset = loopCount * panelCount;
    var anchorAtPositionIndex = anchorAtPosition.index + circularIndexOffset;
    if (Math.abs(anchorAtPositionIndex - anchorAtCamera.index) <= count) {
      var anchor = anchors[anchorAtPosition.index];
      return new AnchorPoint({
        index: anchor.index,
        position: anchor.position + loopCount * camera.rangeDiff,
        panel: anchor.panel
      });
    }
    if (flicking.circularEnabled) {
      var targetAnchor = anchors[circulateIndex(anchorAtCamera.index + Math.sign(position - currentPos) * count, panelCount)];
      var loop = Math.floor(count / panelCount);
      if (position > currentPos && targetAnchor.index < anchorAtCamera.index) {
        loop += 1;
      } else if (position < currentPos && targetAnchor.index > anchorAtCamera.index) {
        loop -= 1;
      }
      return new AnchorPoint({
        index: targetAnchor.index,
        position: targetAnchor.position + loop * camera.rangeDiff,
        panel: targetAnchor.panel
      });
    } else {
      return anchors[clamp$1(anchorAtCamera.index + Math.sign(position - currentPos) * count, 0, anchors.length - 1)];
    }
  };
  __proto._findAdjacentAnchor = function (position, posDelta, anchorAtCamera) {
    var _a;
    var flicking = getFlickingAttached(this._flicking);
    var camera = flicking.camera;
    if (camera.circularEnabled) {
      var anchorIncludePosition = camera.findAnchorIncludePosition(position);
      if (anchorIncludePosition && anchorIncludePosition.position !== anchorAtCamera.position) {
        return anchorIncludePosition;
      }
    }
    var adjacentAnchor = (_a = posDelta > 0 ? camera.getNextAnchor(anchorAtCamera) : camera.getPrevAnchor(anchorAtCamera)) !== null && _a !== void 0 ? _a : anchorAtCamera;
    return adjacentAnchor;
  };
  __proto._calcSnapThreshold = function (threshold, position, activeAnchor) {
    var isNextDirection = position > activeAnchor.position;
    var panel = activeAnchor.panel;
    var panelSize = panel.size;
    var alignPos = panel.alignPosition;
    // Minimum distance needed to decide prev/next panel as nearest
    /*
     * |  Prev  |     Next     |
     * |<------>|<------------>|
     * [        |<-Anchor      ]
     */
    return Math.max(threshold, isNextDirection ? panelSize - alignPos + panel.margin.next : alignPos + panel.margin.prev);
  };
  return SnapControl;
}(Control);

/**
 * A {@link Control} that can be scrolled freely without alignment
 * @ko 패널이 정해진 지점에 정렬되지 않고, 자유롭게 스크롤할 수 있는 이동 방식을 사용하는 {@link Control}
 */
var FreeControl = /*#__PURE__*/function (_super) {
  __extends$3(FreeControl, _super);
  /** */
  function FreeControl(_a) {
    var _b = (_a === void 0 ? {} : _a).stopAtEdge,
      stopAtEdge = _b === void 0 ? true : _b;
    var _this = _super.call(this) || this;
    _this._stopAtEdge = stopAtEdge;
    return _this;
  }
  var __proto = FreeControl.prototype;
  Object.defineProperty(__proto, "stopAtEdge", {
    /**
     * Make scroll animation to stop at the start/end of the scroll area, not going out the bounce area
     * @ko 스크롤 애니메이션을 스크롤 영역의 시작과 끝부분에서 멈추도록 하여, 바운스 영역을 넘어가지 않도록 합니다
     * @type {boolean}
     * @default true
     */
    get: function () {
      return this._stopAtEdge;
    },
    set: function (val) {
      this._stopAtEdge = val;
    },
    enumerable: false,
    configurable: true
  });
  /**
   * Update position after resizing
   * @ko resize 이후에 position을 업데이트합니다
   * @param {number} progressInPanel Previous camera's progress in active panel before resize<ko>Resize 이전 현재 선택된 패널 내에서의 카메라 progress 값</ko>
   * @throws {FlickingError}
   * {@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} When {@link Camera#init init} is not called before
   * <ko>{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} {@link Camera#init init}이 이전에 호출되지 않은 경우</ko>
   * @chainable
   * @return {Promise<void>}
   */
  __proto.updatePosition = function (progressInPanel) {
    var flicking = getFlickingAttached(this._flicking);
    var camera = flicking.camera;
    var activePanel = this._activePanel;
    if (activePanel) {
      var panelRange = activePanel.range;
      var newPosition = panelRange.min + (panelRange.max - panelRange.min) * progressInPanel;
      camera.lookAt(camera.clampToReachablePosition(newPosition));
    }
  };
  /**
   * Move {@link Camera} to the given position
   * @ko {@link Camera}를 주어진 좌표로 이동합니다
   * @param {number} position The target position to move<ko>이동할 좌표</ko>
   * @param {number} duration Duration of the panel movement animation (unit: ms).<ko>패널 이동 애니메이션 진행 시간 (단위: ms)</ko>
   * @param {object} [axesEvent] {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} event of {@link https://naver.github.io/egjs-axes/ Axes}
   * <ko>{@link https://naver.github.io/egjs-axes/ Axes}의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} 이벤트</ko>
   * @fires Flicking#moveStart
   * @fires Flicking#move
   * @fires Flicking#moveEnd
   * @fires Flicking#willChange
   * @fires Flicking#changed
   * @fires Flicking#willRestore
   * @fires Flicking#restored
   * @fires Flicking#needPanel
   * @fires Flicking#visibleChange
   * @fires Flicking#reachEdge
   * @throws {FlickingError}
   * |code|condition|
   * |---|---|
   * |{@link ERROR_CODE POSITION_NOT_REACHABLE}|When the given panel is already removed or not in the Camera's {@link Camera#range range}|
   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|When {@link Control#init init} is not called before|
   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|When the animation is interrupted by user input|
   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|When the animation is interrupted by user input|
   * <ko>
   *
   * |code|condition|
   * |---|---|
   * |{@link ERROR_CODE POSITION_NOT_REACHABLE}|주어진 패널이 제거되었거나, Camera의 {@link Camera#range range} 밖에 있을 경우|
   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|{@link Control#init init}이 이전에 호출되지 않은 경우|
   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|사용자 입력에 의해 애니메이션이 중단된 경우|
   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|발생된 이벤트들 중 하나라도 `stop()`이 호출된 경우|
   *
   * </ko>
   * @return {Promise<void>} A Promise which will be resolved after reaching the target position<ko>해당 좌표 도달시에 resolve되는 Promise</ko>
   */
  __proto.moveToPosition = function (position, duration, axesEvent) {
    var flicking = getFlickingAttached(this._flicking);
    var camera = flicking.camera;
    var targetPos = camera.clampToReachablePosition(position);
    var anchorAtPosition = camera.findAnchorIncludePosition(targetPos);
    if (!anchorAtPosition) {
      return Promise.reject(new FlickingError(MESSAGE.POSITION_NOT_REACHABLE(position), CODE.POSITION_NOT_REACHABLE));
    }
    var targetPanel = anchorAtPosition.panel;
    // Trigger only change event
    if (targetPanel !== this._activePanel) {
      this._triggerIndexChangeEvent(targetPanel, position, axesEvent);
    }
    return this._animateToPosition({
      position: this._stopAtEdge ? targetPos : position,
      duration: duration,
      newActivePanel: targetPanel,
      axesEvent: axesEvent
    });
  };
  return FreeControl;
}(Control);

/**
 * A {@link Control} that allow you to select the maximum number of panels to move at a time
 * @ko 한번에 최대로 이동할 패널의 개수를 선택 가능한 {@link Control}
 */
var StrictControl = /*#__PURE__*/function (_super) {
  __extends$3(StrictControl, _super);
  /** */
  function StrictControl(_a) {
    var _b = (_a === void 0 ? {} : _a).count,
      count = _b === void 0 ? 1 : _b;
    var _this = _super.call(this) || this;
    _this.setActive = function (newActivePanel, prevActivePanel, isTrusted) {
      _super.prototype.setActive.call(_this, newActivePanel, prevActivePanel, isTrusted);
      _this.updateInput();
    };
    _this._count = count;
    _this._resetIndexRange();
    return _this;
  }
  var __proto = StrictControl.prototype;
  Object.defineProperty(__proto, "count", {
    /**
     * Maximum number of panels that can be moved at a time
     * @ko 최대로 움직일 수 있는 패널의 개수
     * @type {number}
     * @default 1
     */
    get: function () {
      return this._count;
    },
    set: function (val) {
      this._count = val;
    },
    enumerable: false,
    configurable: true
  });
  /**
   * Destroy Control and return to initial state
   * @ko Control을 초기 상태로 되돌립니다
   * @return {void}
   */
  __proto.destroy = function () {
    _super.prototype.destroy.call(this);
    this._resetIndexRange();
  };
  /**
   * Update {@link Control#controller controller}'s state
   * @ko {@link Control#controller controller}의 내부 상태를 갱신합니다
   * @chainable
   * @return {this}
   */
  __proto.updateInput = function () {
    var _a;
    var flicking = getFlickingAttached(this._flicking);
    var camera = flicking.camera;
    var renderer = flicking.renderer;
    var controller = this._controller;
    var controlParams = camera.controlParams;
    var count = this._count;
    var activePanel = controller.state.animating ? (_a = camera.findNearestAnchor(camera.position)) === null || _a === void 0 ? void 0 : _a.panel : this._activePanel;
    if (!activePanel) {
      controller.update(controlParams);
      this._resetIndexRange();
      return this;
    }
    var cameraRange = controlParams.range;
    var currentPos = activePanel.position;
    var currentIndex = activePanel.index;
    var panelCount = renderer.panelCount;
    var prevPanelIndex = currentIndex - count;
    var nextPanelIndex = currentIndex + count;
    if (prevPanelIndex < 0) {
      prevPanelIndex = flicking.circularEnabled ? getMinusCompensatedIndex((prevPanelIndex + 1) % panelCount - 1, panelCount) : clamp$1(prevPanelIndex, 0, panelCount - 1);
    }
    if (nextPanelIndex >= panelCount) {
      nextPanelIndex = flicking.circularEnabled ? nextPanelIndex % panelCount : clamp$1(nextPanelIndex, 0, panelCount - 1);
    }
    var prevPanel = renderer.panels[prevPanelIndex];
    var nextPanel = renderer.panels[nextPanelIndex];
    var prevPos = Math.max(prevPanel.position, cameraRange.min);
    var nextPos = Math.min(nextPanel.position, cameraRange.max);
    if (prevPos > currentPos) {
      prevPos -= camera.rangeDiff;
    }
    if (nextPos < currentPos) {
      nextPos += camera.rangeDiff;
    }
    controlParams.range = {
      min: prevPos,
      max: nextPos
    };
    if (controlParams.circular) {
      if (controlParams.position < prevPos) {
        controlParams.position += camera.rangeDiff;
      }
      if (controlParams.position > nextPos) {
        controlParams.position -= camera.rangeDiff;
      }
    }
    controlParams.circular = false;
    controller.update(controlParams);
    this._indexRange = {
      min: prevPanel.index,
      max: nextPanel.index
    };
    return this;
  };
  __proto.moveToPanel = function (panel, options) {
    return __awaiter(this, void 0, void 0, function () {
      var flicking, camera, controller;
      return __generator(this, function (_a) {
        flicking = getFlickingAttached(this._flicking);
        camera = flicking.camera;
        controller = this._controller;
        controller.update(camera.controlParams);
        return [2 /*return*/, _super.prototype.moveToPanel.call(this, panel, options)];
      });
    });
  };
  /**
   * Move {@link Camera} to the given position
   * @ko {@link Camera}를 주어진 좌표로 이동합니다
   * @param {number} position The target position to move<ko>이동할 좌표</ko>
   * @param {number} duration Duration of the panel movement animation (unit: ms).<ko>패널 이동 애니메이션 진행 시간 (단위: ms)</ko>
   * @param {object} [axesEvent] {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} event of {@link https://naver.github.io/egjs-axes/ Axes}
   * <ko>{@link https://naver.github.io/egjs-axes/ Axes}의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} 이벤트</ko>
   * @fires Flicking#moveStart
   * @fires Flicking#move
   * @fires Flicking#moveEnd
   * @fires Flicking#willChange
   * @fires Flicking#changed
   * @fires Flicking#willRestore
   * @fires Flicking#restored
   * @fires Flicking#needPanel
   * @fires Flicking#visibleChange
   * @fires Flicking#reachEdge
   * @throws {FlickingError}
   * |code|condition|
   * |---|---|
   * |{@link ERROR_CODE POSITION_NOT_REACHABLE}|When the given panel is already removed or not in the Camera's {@link Camera#range range}|
   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|When {@link Control#init init} is not called before|
   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|When the animation is interrupted by user input|
   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|When the animation is interrupted by user input|
   * <ko>
   *
   * |code|condition|
   * |---|---|
   * |{@link ERROR_CODE POSITION_NOT_REACHABLE}|주어진 패널이 제거되었거나, Camera의 {@link Camera#range range} 밖에 있을 경우|
   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|{@link Control#init init}이 이전에 호출되지 않은 경우|
   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|사용자 입력에 의해 애니메이션이 중단된 경우|
   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|발생된 이벤트들 중 하나라도 `stop()`이 호출된 경우|
   *
   * </ko>
   * @return {Promise<void>} A Promise which will be resolved after reaching the target position<ko>해당 좌표 도달시에 resolve되는 Promise</ko>
   */
  __proto.moveToPosition = function (position, duration, axesEvent) {
    var _a;
    var flicking = getFlickingAttached(this._flicking);
    var camera = flicking.camera;
    var currentPanel = (_a = this._nextPanel) !== null && _a !== void 0 ? _a : this._activePanel;
    var axesRange = this._controller.range;
    var indexRange = this._indexRange;
    var cameraRange = camera.range;
    var state = this._controller.state;
    var clampedPosition = clamp$1(camera.clampToReachablePosition(position), axesRange[0], axesRange[1]);
    var anchorAtPosition = camera.findAnchorIncludePosition(clampedPosition);
    if (!anchorAtPosition || !currentPanel) {
      return Promise.reject(new FlickingError(MESSAGE.POSITION_NOT_REACHABLE(position), CODE.POSITION_NOT_REACHABLE));
    }
    var prevPos = currentPanel.position;
    var posDelta = flicking.animating ? state.delta : position - camera.position;
    var isOverThreshold = Math.abs(posDelta) >= flicking.threshold;
    var adjacentAnchor = position > prevPos ? camera.getNextAnchor(anchorAtPosition) : camera.getPrevAnchor(anchorAtPosition);
    var targetPos;
    var targetPanel;
    var anchors = camera.anchorPoints;
    var firstAnchor = anchors[0];
    var lastAnchor = anchors[anchors.length - 1];
    var shouldBounceToFirst = position <= cameraRange.min && isBetween(firstAnchor.panel.index, indexRange.min, indexRange.max);
    var shouldBounceToLast = position >= cameraRange.max && isBetween(lastAnchor.panel.index, indexRange.min, indexRange.max);
    var isAdjacent = adjacentAnchor && (indexRange.min <= indexRange.max ? isBetween(adjacentAnchor.index, indexRange.min, indexRange.max) : adjacentAnchor.index >= indexRange.min || adjacentAnchor.index <= indexRange.max);
    if (shouldBounceToFirst || shouldBounceToLast) {
      // In bounce area
      var targetAnchor = position < cameraRange.min ? firstAnchor : lastAnchor;
      targetPanel = targetAnchor.panel;
      targetPos = targetAnchor.position;
    } else if (isOverThreshold && anchorAtPosition.position !== currentPanel.position) {
      // Move to anchor at position
      targetPanel = anchorAtPosition.panel;
      targetPos = anchorAtPosition.position;
    } else if (isOverThreshold && isAdjacent) {
      // Move to adjacent anchor
      targetPanel = adjacentAnchor.panel;
      targetPos = adjacentAnchor.position;
    } else {
      // Fallback to nearest panel from current camera
      var anchorAtCamera = camera.findNearestAnchor(camera.position);
      if (!anchorAtCamera) {
        return Promise.reject(new FlickingError(MESSAGE.POSITION_NOT_REACHABLE(position), CODE.POSITION_NOT_REACHABLE));
      }
      return this.moveToPanel(anchorAtCamera.panel, {
        duration: duration,
        axesEvent: axesEvent
      });
    }
    this._triggerIndexChangeEvent(targetPanel, position, axesEvent);
    return this._animateToPosition({
      position: targetPos,
      duration: duration,
      newActivePanel: targetPanel,
      axesEvent: axesEvent
    });
  };
  __proto._resetIndexRange = function () {
    this._indexRange = {
      min: 0,
      max: 0
    };
  };
  return StrictControl;
}(Control);

/**
 * A mode of camera
 */
var CameraMode = /*#__PURE__*/function () {
  /** */
  function CameraMode(flicking) {
    this._flicking = flicking;
  }
  var __proto = CameraMode.prototype;
  __proto.getAnchors = function () {
    var panels = this._flicking.renderer.panels;
    return panels.map(function (panel, index) {
      return new AnchorPoint({
        index: index,
        position: panel.position,
        panel: panel
      });
    });
  };
  __proto.findAnchorIncludePosition = function (position) {
    var anchors = this._flicking.camera.anchorPoints;
    var anchorsIncludingPosition = anchors.filter(function (anchor) {
      return anchor.panel.includePosition(position, true);
    });
    return anchorsIncludingPosition.reduce(function (nearest, anchor) {
      if (!nearest) return anchor;
      return Math.abs(nearest.position - position) < Math.abs(anchor.position - position) ? nearest : anchor;
    }, null);
  };
  __proto.findNearestAnchor = function (position) {
    var anchors = this._flicking.camera.anchorPoints;
    if (anchors.length <= 0) return null;
    var prevDist = Infinity;
    for (var anchorIdx = 0; anchorIdx < anchors.length; anchorIdx++) {
      var anchor = anchors[anchorIdx];
      var dist = Math.abs(anchor.position - position);
      if (dist > prevDist) {
        // Return previous anchor
        return anchors[anchorIdx - 1];
      }
      prevDist = dist;
    }
    // Return last anchor
    return anchors[anchors.length - 1];
  };
  __proto.clampToReachablePosition = function (position) {
    var camera = this._flicking.camera;
    var range = camera.range;
    return clamp$1(position, range.min, range.max);
  };
  __proto.getCircularOffset = function () {
    return 0;
  };
  __proto.canReach = function (panel) {
    var camera = this._flicking.camera;
    var range = camera.range;
    if (panel.removed) return false;
    var panelPos = panel.position;
    return panelPos >= range.min && panelPos <= range.max;
  };
  __proto.canSee = function (panel) {
    var camera = this._flicking.camera;
    var visibleRange = camera.visibleRange;
    // Should not include margin, as we don't declare what the margin is visible as what the panel is visible.
    return panel.isVisibleOnRange(visibleRange.min, visibleRange.max);
  };
  return CameraMode;
}();

var LinearCameraMode = /*#__PURE__*/function (_super) {
  __extends$3(LinearCameraMode, _super);
  function LinearCameraMode() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  var __proto = LinearCameraMode.prototype;
  __proto.checkAvailability = function () {
    // It's always available
    return true;
  };
  __proto.getRange = function () {
    var _a, _b;
    var renderer = this._flicking.renderer;
    var firstPanel = renderer.getPanel(0);
    var lastPanel = renderer.getPanel(renderer.panelCount - 1);
    return {
      min: (_a = firstPanel === null || firstPanel === void 0 ? void 0 : firstPanel.position) !== null && _a !== void 0 ? _a : 0,
      max: (_b = lastPanel === null || lastPanel === void 0 ? void 0 : lastPanel.position) !== null && _b !== void 0 ? _b : 0
    };
  };
  return LinearCameraMode;
}(CameraMode);

/**
 * A {@link Camera} mode that connects the last panel and the first panel, enabling continuous loop
 * @ko 첫번째 패널과 마지막 패널이 이어진 상태로, 무한히 회전할 수 있는 종류의 {@link Camera} 모드
 */
var CircularCameraMode = /*#__PURE__*/function (_super) {
  __extends$3(CircularCameraMode, _super);
  function CircularCameraMode() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  var __proto = CircularCameraMode.prototype;
  __proto.checkAvailability = function () {
    var flicking = this._flicking;
    var renderer = flicking.renderer;
    var panels = renderer.panels;
    if (panels.length <= 0) {
      return false;
    }
    var firstPanel = panels[0];
    var lastPanel = panels[panels.length - 1];
    var firstPanelPrev = firstPanel.range.min - firstPanel.margin.prev;
    var lastPanelNext = lastPanel.range.max + lastPanel.margin.next;
    var visibleSize = flicking.camera.size;
    var panelSizeSum = lastPanelNext - firstPanelPrev;
    var canSetCircularMode = panels.every(function (panel) {
      return panelSizeSum - panel.size >= visibleSize;
    });
    return canSetCircularMode;
  };
  __proto.getRange = function () {
    var flicking = this._flicking;
    var panels = flicking.renderer.panels;
    if (panels.length <= 0) {
      return {
        min: 0,
        max: 0
      };
    }
    var firstPanel = panels[0];
    var lastPanel = panels[panels.length - 1];
    var firstPanelPrev = firstPanel.range.min - firstPanel.margin.prev;
    var lastPanelNext = lastPanel.range.max + lastPanel.margin.next;
    return {
      min: firstPanelPrev,
      max: lastPanelNext
    };
  };
  __proto.getAnchors = function () {
    var flicking = this._flicking;
    var panels = flicking.renderer.panels;
    return panels.map(function (panel, index) {
      return new AnchorPoint({
        index: index,
        position: panel.position,
        panel: panel
      });
    });
  };
  __proto.findNearestAnchor = function (position) {
    var camera = this._flicking.camera;
    var anchors = camera.anchorPoints;
    if (anchors.length <= 0) return null;
    var camRange = camera.range;
    var minDist = Infinity;
    var minDistIndex = -1;
    for (var anchorIdx = 0; anchorIdx < anchors.length; anchorIdx++) {
      var anchor = anchors[anchorIdx];
      var dist = Math.min(Math.abs(anchor.position - position), Math.abs(anchor.position - camRange.min + camRange.max - position), Math.abs(position - camRange.min + camRange.max - anchor.position));
      if (dist < minDist) {
        minDist = dist;
        minDistIndex = anchorIdx;
      }
    }
    // Return last anchor
    return anchors[minDistIndex];
  };
  __proto.findAnchorIncludePosition = function (position) {
    var camera = this._flicking.camera;
    var range = camera.range;
    var anchors = camera.anchorPoints;
    var rangeDiff = camera.rangeDiff;
    var anchorCount = anchors.length;
    var positionInRange = circulatePosition(position, range.min, range.max);
    var anchorInRange = _super.prototype.findAnchorIncludePosition.call(this, positionInRange);
    if (anchorCount > 0 && (position === range.min || position === range.max)) {
      var possibleAnchors = [anchorInRange, new AnchorPoint({
        index: 0,
        position: anchors[0].position + rangeDiff,
        panel: anchors[0].panel
      }), new AnchorPoint({
        index: anchorCount - 1,
        position: anchors[anchorCount - 1].position - rangeDiff,
        panel: anchors[anchorCount - 1].panel
      })].filter(function (anchor) {
        return !!anchor;
      });
      anchorInRange = possibleAnchors.reduce(function (nearest, anchor) {
        if (!nearest) return anchor;
        return Math.abs(nearest.position - position) < Math.abs(anchor.position - position) ? nearest : anchor;
      }, null);
    }
    if (!anchorInRange) return null;
    if (position < range.min) {
      var loopCount = -Math.floor((range.min - position) / rangeDiff) - 1;
      return new AnchorPoint({
        index: anchorInRange.index,
        position: anchorInRange.position + rangeDiff * loopCount,
        panel: anchorInRange.panel
      });
    } else if (position > range.max) {
      var loopCount = Math.floor((position - range.max) / rangeDiff) + 1;
      return new AnchorPoint({
        index: anchorInRange.index,
        position: anchorInRange.position + rangeDiff * loopCount,
        panel: anchorInRange.panel
      });
    }
    return anchorInRange;
  };
  __proto.getCircularOffset = function () {
    var flicking = this._flicking;
    var camera = flicking.camera;
    if (!camera.circularEnabled) return 0;
    var toggled = flicking.panels.filter(function (panel) {
      return panel.toggled;
    });
    var toggledPrev = toggled.filter(function (panel) {
      return panel.toggleDirection === DIRECTION.PREV;
    });
    var toggledNext = toggled.filter(function (panel) {
      return panel.toggleDirection === DIRECTION.NEXT;
    });
    return this._calcPanelAreaSum(toggledPrev) - this._calcPanelAreaSum(toggledNext);
  };
  __proto.clampToReachablePosition = function (position) {
    // Basically all position is reachable for circular camera
    return position;
  };
  __proto.canReach = function (panel) {
    if (panel.removed) return false;
    // Always reachable on circular mode
    return true;
  };
  __proto.canSee = function (panel) {
    var camera = this._flicking.camera;
    var range = camera.range;
    var rangeDiff = camera.rangeDiff;
    var visibleRange = camera.visibleRange;
    var visibleInCurrentRange = _super.prototype.canSee.call(this, panel);
    // Check looped visible area for circular case
    if (visibleRange.min < range.min) {
      return visibleInCurrentRange || panel.isVisibleOnRange(visibleRange.min + rangeDiff, visibleRange.max + rangeDiff);
    } else if (visibleRange.max > range.max) {
      return visibleInCurrentRange || panel.isVisibleOnRange(visibleRange.min - rangeDiff, visibleRange.max - rangeDiff);
    }
    return visibleInCurrentRange;
  };
  __proto._calcPanelAreaSum = function (panels) {
    return panels.reduce(function (sum, panel) {
      return sum + panel.sizeIncludingMargin;
    }, 0);
  };
  return CircularCameraMode;
}(CameraMode);

var BoundCameraMode = /*#__PURE__*/function (_super) {
  __extends$3(BoundCameraMode, _super);
  function BoundCameraMode() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  var __proto = BoundCameraMode.prototype;
  __proto.checkAvailability = function () {
    var flicking = this._flicking;
    var renderer = flicking.renderer;
    var firstPanel = renderer.getPanel(0);
    var lastPanel = renderer.getPanel(renderer.panelCount - 1);
    if (!firstPanel || !lastPanel) {
      return false;
    }
    var viewportSize = flicking.camera.size;
    var firstPanelPrev = firstPanel.range.min;
    var lastPanelNext = lastPanel.range.max;
    var panelAreaSize = lastPanelNext - firstPanelPrev;
    var isBiggerThanViewport = viewportSize < panelAreaSize;
    return isBiggerThanViewport;
  };
  __proto.getRange = function () {
    var flicking = this._flicking;
    var renderer = flicking.renderer;
    var alignPos = flicking.camera.alignPosition;
    var firstPanel = renderer.getPanel(0);
    var lastPanel = renderer.getPanel(renderer.panelCount - 1);
    if (!firstPanel || !lastPanel) {
      return {
        min: 0,
        max: 0
      };
    }
    var viewportSize = flicking.camera.size;
    var firstPanelPrev = firstPanel.range.min;
    var lastPanelNext = lastPanel.range.max;
    var panelAreaSize = lastPanelNext - firstPanelPrev;
    var isBiggerThanViewport = viewportSize < panelAreaSize;
    var firstPos = firstPanelPrev + alignPos;
    var lastPos = lastPanelNext - viewportSize + alignPos;
    if (isBiggerThanViewport) {
      return {
        min: firstPos,
        max: lastPos
      };
    } else {
      var align = flicking.camera.align;
      var alignVal = typeof align === "object" ? align.camera : align;
      var pos = firstPos + parseAlign$1(alignVal, lastPos - firstPos);
      return {
        min: pos,
        max: pos
      };
    }
  };
  __proto.getAnchors = function () {
    var flicking = this._flicking;
    var camera = flicking.camera;
    var panels = flicking.renderer.panels;
    if (panels.length <= 0) {
      return [];
    }
    var range = flicking.camera.range;
    var reachablePanels = panels.filter(function (panel) {
      return camera.canReach(panel);
    });
    if (reachablePanels.length > 0) {
      var shouldPrependBoundAnchor = reachablePanels[0].position !== range.min;
      var shouldAppendBoundAnchor = reachablePanels[reachablePanels.length - 1].position !== range.max;
      var indexOffset_1 = shouldPrependBoundAnchor ? 1 : 0;
      var newAnchors = reachablePanels.map(function (panel, idx) {
        return new AnchorPoint({
          index: idx + indexOffset_1,
          position: panel.position,
          panel: panel
        });
      });
      if (shouldPrependBoundAnchor) {
        newAnchors.splice(0, 0, new AnchorPoint({
          index: 0,
          position: range.min,
          panel: panels[reachablePanels[0].index - 1]
        }));
      }
      if (shouldAppendBoundAnchor) {
        newAnchors.push(new AnchorPoint({
          index: newAnchors.length,
          position: range.max,
          panel: panels[reachablePanels[reachablePanels.length - 1].index + 1]
        }));
      }
      return newAnchors;
    } else if (range.min !== range.max) {
      // There're more than 2 panels
      var nearestPanelAtMin = this._findNearestPanel(range.min, panels);
      var panelAtMin = nearestPanelAtMin.index === panels.length - 1 ? nearestPanelAtMin.prev() : nearestPanelAtMin;
      var panelAtMax = panelAtMin.next();
      return [new AnchorPoint({
        index: 0,
        position: range.min,
        panel: panelAtMin
      }), new AnchorPoint({
        index: 1,
        position: range.max,
        panel: panelAtMax
      })];
    } else {
      return [new AnchorPoint({
        index: 0,
        position: range.min,
        panel: this._findNearestPanel(range.min, panels)
      })];
    }
  };
  __proto.findAnchorIncludePosition = function (position) {
    var camera = this._flicking.camera;
    var range = camera.range;
    var anchors = camera.anchorPoints;
    if (anchors.length <= 0) return null;
    if (position <= range.min) {
      return anchors[0];
    } else if (position >= range.max) {
      return anchors[anchors.length - 1];
    } else {
      return _super.prototype.findAnchorIncludePosition.call(this, position);
    }
  };
  __proto._findNearestPanel = function (pos, panels) {
    var prevDist = Infinity;
    for (var panelIdx = 0; panelIdx < panels.length; panelIdx++) {
      var panel = panels[panelIdx];
      var dist = Math.abs(panel.position - pos);
      if (dist > prevDist) {
        // Return previous anchor
        return panels[panelIdx - 1];
      }
      prevDist = dist;
    }
    // Return last anchor
    return panels[panels.length - 1];
  };
  return BoundCameraMode;
}(CameraMode);

/**
 * A component that manages actual movement inside the viewport
 * @ko 뷰포트 내에서의 실제 움직임을 담당하는 컴포넌트
 */
var Camera = /*#__PURE__*/function () {
  /** */
  function Camera(flicking, _a) {
    var _this = this;
    var _b = (_a === void 0 ? {} : _a).align,
      align = _b === void 0 ? ALIGN.CENTER : _b;
    this._checkTranslateSupport = function () {
      var e_1, _a;
      var transforms = ["webkitTransform", "msTransform", "MozTransform", "OTransform", "transform"];
      var supportedStyle = document.documentElement.style;
      var transformName = "";
      try {
        for (var transforms_1 = __values$1(transforms), transforms_1_1 = transforms_1.next(); !transforms_1_1.done; transforms_1_1 = transforms_1.next()) {
          var prefixedTransform = transforms_1_1.value;
          if (prefixedTransform in supportedStyle) {
            transformName = prefixedTransform;
          }
        }
      } catch (e_1_1) {
        e_1 = {
          error: e_1_1
        };
      } finally {
        try {
          if (transforms_1_1 && !transforms_1_1.done && (_a = transforms_1.return)) _a.call(transforms_1);
        } finally {
          if (e_1) throw e_1.error;
        }
      }
      if (!transformName) {
        throw new FlickingError(MESSAGE.TRANSFORM_NOT_SUPPORTED, CODE.TRANSFORM_NOT_SUPPORTED);
      }
      _this._transform = transformName;
    };
    this._flicking = flicking;
    this._resetInternalValues();
    // Options
    this._align = align;
  }
  var __proto = Camera.prototype;
  Object.defineProperty(__proto, "element", {
    // Internal states getter
    /**
     * The camera element(`.flicking-camera`)
     * @ko 카메라 엘리먼트(`.flicking-camera`)
     * @type {HTMLElement}
     * @readonly
     */
    get: function () {
      return this._el;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "children", {
    /**
     * An array of the child elements of the camera element(`.flicking-camera`)
     * @ko 카메라 엘리먼트(`.flicking-camera`)의 자식 엘리먼트 배열
     * @type {HTMLElement[]}
     * @readonly
     */
    get: function () {
      return toArray$2(this._el.children);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "position", {
    /**
     * Current position of the camera
     * @ko Camera의 현재 좌표
     * @type {number}
     * @readonly
     */
    get: function () {
      return this._position;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "alignPosition", {
    /**
     * Align position inside the viewport where {@link Panel}'s {@link Panel#alignPosition alignPosition} should be located at
     * @ko 패널의 정렬 기준 위치. 뷰포트 내에서 {@link Panel}의 {@link Panel#alignPosition alignPosition}이 위치해야 하는 곳입니다
     * @type {number}
     * @readonly
     */
    get: function () {
      return this._alignPos;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "offset", {
    /**
     * Position offset, used for the {@link Flicking#renderOnlyVisible renderOnlyVisible} option
     * @ko Camera의 좌표 오프셋. {@link Flicking#renderOnlyVisible renderOnlyVisible} 옵션을 위해 사용됩니다.
     * @type {number}
     * @default 0
     * @readonly
     */
    get: function () {
      return this._offset - this._circularOffset;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "circularEnabled", {
    /**
     * Whether the `circular` option is enabled.
     * The {@link Flicking#circular circular} option can't be enabled when sum of the panel sizes are too small.
     * @ko {@link Flicking#circular circular} 옵션이 활성화되었는지 여부를 나타내는 멤버 변수.
     * {@link Flicking#circular circular} 옵션은 패널의 크기의 합이 충분하지 않을 경우 비활성화됩니다.
     * @type {boolean}
     * @default false
     * @readonly
     */
    get: function () {
      return this._circularEnabled;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "mode", {
    /**
     * A current camera mode
     * @type {CameraMode}
     * @readonly
     */
    get: function () {
      return this._mode;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "range", {
    /**
     * A range that Camera's {@link Camera#position position} can reach
     * @ko Camera의 {@link Camera#position position}이 도달 가능한 범위
     * @type {object}
     * @property {number} min A minimum position<ko>최소 위치</ko>
     * @property {number} max A maximum position<ko>최대 위치</ko>
     * @readonly
     */
    get: function () {
      return this._range;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "rangeDiff", {
    /**
     * A difference between Camera's minimum and maximum position that can reach
     * @ko Camera가 도달 가능한 최소/최대 좌표의 차이
     * @type {number}
     * @readonly
     */
    get: function () {
      return this._range.max - this._range.min;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "visiblePanels", {
    /**
     * An array of visible panels from the current position
     * @ko 현재 보이는 패널들의 배열
     * @type {Panel[]}
     * @readonly
     */
    get: function () {
      return this._visiblePanels;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "visibleRange", {
    /**
     * A range of the visible area from the current position
     * @ko 현재 위치에서 보이는 범위
     * @type {object}
     * @property {number} min A minimum position<ko>최소 위치</ko>
     * @property {number} min A maximum position<ko>최대 위치</ko>
     * @readonly
     */
    get: function () {
      return {
        min: this._position - this._alignPos,
        max: this._position - this._alignPos + this.size
      };
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "anchorPoints", {
    /**
     * An array of {@link AnchorPoint}s that Camera can be stopped at
     * @ko 카메라가 도달 가능한 {@link AnchorPoint}의 목록
     * @type {AnchorPoint[]}
     * @readonly
     */
    get: function () {
      return this._anchors;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "controlParams", {
    /**
     * A current parameters of the Camera for updating {@link AxesController}
     * @ko {@link AxesController}를 업데이트하기 위한 현재 Camera 패러미터들
     * @type {ControlParams}
     * @readonly
     */
    get: function () {
      return {
        range: this._range,
        position: this._position,
        circular: this._circularEnabled
      };
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "atEdge", {
    /**
     * A Boolean value indicating whether Camera's over the minimum or maximum position reachable
     * @ko 현재 카메라가 도달 가능한 범위의 최소 혹은 최대점을 넘어섰는지를 나타냅니다
     * @type {boolean}
     * @readonly
     */
    get: function () {
      return this._position <= this._range.min || this._position >= this._range.max;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "size", {
    /**
     * Return the size of the viewport
     * @ko 뷰포트 크기를 반환합니다
     * @type {number}
     * @readonly
     */
    get: function () {
      var flicking = this._flicking;
      return flicking ? flicking.horizontal ? flicking.viewport.width : flicking.viewport.height : 0;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "progress", {
    /**
     * Return the camera's position progress from the first panel to last panel
     * Range is from 0 to last panel's index
     * @ko 첫번째 패널로부터 마지막 패널까지의 카메라 위치의 진행도를 반환합니다
     * 범위는 0부터 마지막 패널의 인덱스까지입니다
     * @type {number}
     * @readonly
     */
    get: function () {
      var flicking = this._flicking;
      var position = this._position + this._offset;
      var nearestAnchor = this.findNearestAnchor(this._position);
      if (!flicking || !nearestAnchor) {
        return NaN;
      }
      var nearestPanel = nearestAnchor.panel;
      var panelPos = nearestPanel.position + nearestPanel.offset;
      var bounceSize = flicking.control.controller.bounce;
      var _a = this.range,
        prevRange = _a.min,
        nextRange = _a.max;
      var rangeDiff = this.rangeDiff;
      if (position === panelPos) {
        return nearestPanel.index;
      }
      if (position < panelPos) {
        var prevPanel = nearestPanel.prev();
        var prevPosition = prevPanel ? prevPanel.position + prevPanel.offset : prevRange - bounceSize[0];
        // Looped
        if (prevPosition > panelPos) {
          prevPosition -= rangeDiff;
        }
        return nearestPanel.index - 1 + getProgress(position, prevPosition, panelPos);
      } else {
        var nextPanel = nearestPanel.next();
        var nextPosition = nextPanel ? nextPanel.position + nextPanel.offset : nextRange + bounceSize[1];
        // Looped
        if (nextPosition < panelPos) {
          nextPosition += rangeDiff;
        }
        return nearestPanel.index + getProgress(position, panelPos, nextPosition);
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "panelOrder", {
    /**
     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/direction direction} CSS property applied to the camera element(`.flicking-camera`)
     * @ko 카메라 엘리먼트(`.flicking-camera`)에 적용된 {@link https://developer.mozilla.org/en-US/docs/Web/CSS/direction direction} CSS 속성
     * @type {string}
     * @readonly
     */
    get: function () {
      return this._panelOrder;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "align", {
    // Options Getter
    /**
     * A value indicating where the {@link Camera#alignPosition alignPosition} should be located at inside the viewport element
     * @ko {@link Camera#alignPosition alignPosition}이 뷰포트 엘리먼트 내의 어디에 위치해야 하는지를 나타내는 값
     * @type {ALIGN | string | number}
     */
    get: function () {
      return this._align;
    },
    // Options Setter
    set: function (val) {
      this._align = val;
    },
    enumerable: false,
    configurable: true
  });
  /**
   * Initialize Camera
   * @ko Camera를 초기화합니다
   * @throws {FlickingError}
   * {@link ERROR_CODE VAL_MUST_NOT_NULL} If the camera element(`.flicking-camera`) does not exist inside viewport element
   * <ko>{@link ERROR_CODE VAL_MUST_NOT_NULL} 뷰포트 엘리먼트 내부에 카메라 엘리먼트(`.flicking-camera`)가 존재하지 않을 경우</ko>
   * @return {this}
   */
  __proto.init = function () {
    var viewportEl = this._flicking.viewport.element;
    checkExistence(viewportEl.firstElementChild, "First element child of the viewport element");
    this._el = viewportEl.firstElementChild;
    this._checkTranslateSupport();
    this._updateMode();
    this.updatePanelOrder();
    return this;
  };
  /**
   * Destroy Camera and return to initial state
   * @ko Camera를 초기 상태로 되돌립니다
   * @return {void}
   */
  __proto.destroy = function () {
    this._resetInternalValues();
    return this;
  };
  /**
   * Move to the given position and apply CSS transform
   * @ko 해당 좌표로 이동하고, CSS transform을 적용합니다
   * @param {number} pos A new position<ko>움직일 위치</ko>
   * @throws {FlickingError}
   * {@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} When {@link Camera#init init} is not called before
   * <ko>{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} {@link Camera#init init}이 이전에 호출되지 않은 경우</ko>
   * @return {this}
   */
  __proto.lookAt = function (pos) {
    var _this = this;
    var flicking = getFlickingAttached(this._flicking);
    var prevPos = this._position;
    this._position = pos;
    var toggled = this._togglePanels(prevPos, pos);
    this._refreshVisiblePanels();
    this._checkNeedPanel();
    this._checkReachEnd(prevPos, pos);
    if (toggled) {
      void flicking.renderer.render().then(function () {
        _this.updateOffset();
      });
    } else {
      this.applyTransform();
    }
  };
  /**
   * Return a previous {@link AnchorPoint} of given {@link AnchorPoint}
   * If it does not exist, return `null` instead
   * @ko 주어진 {@link AnchorPoint}의 이전 {@link AnchorPoint}를 반환합니다
   * 존재하지 않을 경우 `null`을 반환합니다
   * @param {AnchorPoint} anchor A reference {@link AnchorPoint}<ko>기준 {@link AnchorPoint}</ko>
   * @return {AnchorPoint | null} The previous {@link AnchorPoint}<ko>이전 {@link AnchorPoint}</ko>
   */
  __proto.getPrevAnchor = function (anchor) {
    if (!this._circularEnabled || anchor.index !== 0) {
      return this._anchors[anchor.index - 1] || null;
    } else {
      var anchors = this._anchors;
      var rangeDiff = this.rangeDiff;
      var lastAnchor = anchors[anchors.length - 1];
      return new AnchorPoint({
        index: lastAnchor.index,
        position: lastAnchor.position - rangeDiff,
        panel: lastAnchor.panel
      });
    }
  };
  /**
   * Return a next {@link AnchorPoint} of given {@link AnchorPoint}
   * If it does not exist, return `null` instead
   * @ko 주어진 {@link AnchorPoint}의 다음 {@link AnchorPoint}를 반환합니다
   * 존재하지 않을 경우 `null`을 반환합니다
   * @param {AnchorPoint} anchor A reference {@link AnchorPoint}<ko>기준 {@link AnchorPoint}</ko>
   * @return {AnchorPoint | null} The next {@link AnchorPoint}<ko>다음 {@link AnchorPoint}</ko>
   */
  __proto.getNextAnchor = function (anchor) {
    var anchors = this._anchors;
    if (!this._circularEnabled || anchor.index !== anchors.length - 1) {
      return anchors[anchor.index + 1] || null;
    } else {
      var rangeDiff = this.rangeDiff;
      var firstAnchor = anchors[0];
      return new AnchorPoint({
        index: firstAnchor.index,
        position: firstAnchor.position + rangeDiff,
        panel: firstAnchor.panel
      });
    }
  };
  /**
   * Return the camera's position progress in the panel below
   * Value is from 0 to 1 when the camera's inside panel
   * Value can be lower than 0 or bigger than 1 when it's in the margin area
   * @ko 현재 카메라 아래 패널에서의 위치 진행도를 반환합니다
   * 반환값은 카메라가 패널 내부에 있을 경우 0부터 1까지의 값을 갖습니다
   * 패널의 margin 영역에 있을 경우 0보다 작거나 1보다 큰 값을 반환할 수 있습니다
   */
  __proto.getProgressInPanel = function (panel) {
    var panelRange = panel.range;
    return (this._position - panelRange.min) / (panelRange.max - panelRange.min);
  };
  /**
   * Return {@link AnchorPoint} that includes given position
   * If there's no {@link AnchorPoint} that includes the given position, return `null` instead
   * @ko 주어진 좌표를 포함하는 {@link AnchorPoint}를 반환합니다
   * 주어진 좌표를 포함하는 {@link AnchorPoint}가 없을 경우 `null`을 반환합니다
   * @param {number} position A position to check<ko>확인할 좌표</ko>
   * @return {AnchorPoint | null} The {@link AnchorPoint} that includes the given position<ko>해당 좌표를 포함하는 {@link AnchorPoint}</ko>
   */
  __proto.findAnchorIncludePosition = function (position) {
    return this._mode.findAnchorIncludePosition(position);
  };
  /**
   * Return {@link AnchorPoint} nearest to given position
   * If there're no {@link AnchorPoint}s, return `null` instead
   * @ko 해당 좌표에서 가장 가까운 {@link AnchorPoint}를 반환합니다
   * {@link AnchorPoint}가 하나도 없을 경우 `null`을 반환합니다
   * @param {number} position A position to check<ko>확인할 좌표</ko>
   * @return {AnchorPoint | null} The {@link AnchorPoint} nearest to the given position<ko>해당 좌표에 가장 인접한 {@link AnchorPoint}</ko>
   */
  __proto.findNearestAnchor = function (position) {
    return this._mode.findNearestAnchor(position);
  };
  /**
   * Return {@link AnchorPoint} that matches {@link Flicking#currentPanel}
   * @ko 현재 {@link Flicking#currentPanel}에 해당하는 {@link AnchorPoint}를 반환합니다
   * @return {AnchorPoint | null}
   */
  __proto.findActiveAnchor = function () {
    var _a;
    var flicking = getFlickingAttached(this._flicking);
    var activePanel = flicking.control.activePanel;
    if (!activePanel) return null;
    return (_a = find$1(this._anchors, function (anchor) {
      return anchor.panel.index === activePanel.index;
    })) !== null && _a !== void 0 ? _a : this.findNearestAnchor(activePanel.position);
  };
  /**
   * Clamp the given position between camera's range
   * @ko 주어진 좌표를 Camera가 도달 가능한 범위 사이의 값으로 만듭니다
   * @param {number} position A position to clamp<ko>범위를 제한할 좌표</ko>
   * @return {number} A clamped position<ko>범위 제한된 좌표</ko>
   */
  __proto.clampToReachablePosition = function (position) {
    return this._mode.clampToReachablePosition(position);
  };
  /**
   * Check whether the given panel is inside of the Camera's range
   * @ko 해당 {@link Panel}이 Camera가 도달 가능한 범위 내에 있는지를 반환합니다
   * @param panel An instance of {@link Panel} to check<ko>확인할 {@link Panel}의 인스턴스</ko>
   * @return {boolean} Whether the panel's inside Camera's range<ko>도달 가능한 범위 내에 해당 패널이 존재하는지 여부</ko>
   */
  __proto.canReach = function (panel) {
    return this._mode.canReach(panel);
  };
  /**
   * Check whether the given panel element is visible at the current position
   * @ko 현재 좌표에서 해당 패널 엘리먼트를 볼 수 있는지 여부를 반환합니다
   * @param panel An instance of {@link Panel} to check<ko>확인할 {@link Panel}의 인스턴스</ko>
   * @return Whether the panel element is visible at the current position<ko>현재 위치에서 해당 패널 엘리먼트가 보이는지 여부</ko>
   */
  __proto.canSee = function (panel) {
    return this._mode.canSee(panel);
  };
  /**
   * Update {@link Camera#range range} of Camera
   * @ko Camera의 {@link Camera#range range}를 업데이트합니다
   * @method
   * @abstract
   * @memberof Camera
   * @instance
   * @name updateRange
   * @chainable
   * @throws {FlickingError}
   * {@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} When {@link Camera#init init} is not called before
   * <ko>{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} {@link Camera#init init}이 이전에 호출되지 않은 경우</ko>
   * @return {this}
   */
  __proto.updateRange = function () {
    var flicking = getFlickingAttached(this._flicking);
    var renderer = flicking.renderer;
    var panels = renderer.panels;
    this._updateMode();
    this._range = this._mode.getRange();
    panels.forEach(function (panel) {
      return panel.updateCircularToggleDirection();
    });
    return this;
  };
  /**
   * Update Camera's {@link Camera#alignPosition alignPosition}
   * @ko Camera의 {@link Camera#alignPosition alignPosition}을 업데이트합니다
   * @chainable
   * @return {this}
   */
  __proto.updateAlignPos = function () {
    var align = this._align;
    var alignVal = typeof align === "object" ? align.camera : align;
    this._alignPos = parseAlign$1(alignVal, this.size);
    return this;
  };
  /**
   * Update Camera's {@link Camera#anchorPoints anchorPoints}
   * @ko Camera의 {@link Camera#anchorPoints anchorPoints}를 업데이트합니다
   * @throws {FlickingError}
   * {@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} When {@link Camera#init init} is not called before
   * <ko>{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} {@link Camera#init init}이 이전에 호출되지 않은 경우</ko>
   * @chainable
   * @return {this}
   */
  __proto.updateAnchors = function () {
    this._anchors = this._mode.getAnchors();
    return this;
  };
  /**
   * Update Viewport's height to active panel's height
   * @ko 현재 선택된 패널의 높이와 동일하도록 뷰포트의 높이를 업데이트합니다
   * @throws {FlickingError}
   * {@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} When {@link Camera#init init} is not called before
   * <ko>{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} {@link Camera#init init}이 이전에 호출되지 않은 경우</ko>
   * @chainable
   * @return {this}
   */
  __proto.updateAdaptiveHeight = function () {
    var flicking = getFlickingAttached(this._flicking);
    var activePanel = flicking.control.activePanel;
    if (!flicking.horizontal || !flicking.adaptive || !activePanel) return;
    flicking.viewport.setSize({
      height: activePanel.height
    });
  };
  /**
   * Update current offset of the camera
   * @ko 현재 카메라의 오프셋을 업데이트합니다
   * @chainable
   * @return {this}
   */
  __proto.updateOffset = function () {
    var flicking = getFlickingAttached(this._flicking);
    var position = this._position;
    var unRenderedPanels = flicking.panels.filter(function (panel) {
      return !panel.rendered;
    });
    this._offset = unRenderedPanels.filter(function (panel) {
      return panel.position + panel.offset < position;
    }).reduce(function (offset, panel) {
      return offset + panel.sizeIncludingMargin;
    }, 0);
    this._circularOffset = this._mode.getCircularOffset();
    this.applyTransform();
    return this;
  };
  /**
   * Update direction to match the {@link https://developer.mozilla.org/en-US/docs/Web/CSS/direction direction} CSS property applied to the camera element
   * @ko 카메라 엘리먼트에 적용된 {@link https://developer.mozilla.org/en-US/docs/Web/CSS/direction direction} CSS 속성에 맞게 방향을 업데이트합니다
   * @return {this}
   */
  __proto.updatePanelOrder = function () {
    var flicking = getFlickingAttached(this._flicking);
    if (!flicking.horizontal) return this;
    var el = this._el;
    var direction = getStyle(el).direction;
    if (direction !== this._panelOrder) {
      this._panelOrder = direction === ORDER.RTL ? ORDER.RTL : ORDER.LTR;
      if (flicking.initialized) {
        flicking.control.controller.updateDirection();
      }
    }
    return this;
  };
  /**
   * Reset the history of {@link Flicking#event:needPanel needPanel} events so it can be triggered again
   * @ko 발생한 {@link Flicking#event:needPanel needPanel} 이벤트들을 초기화하여 다시 발생할 수 있도록 합니다
   * @chainable
   * @return {this}
   */
  __proto.resetNeedPanelHistory = function () {
    this._needPanelTriggered = {
      prev: false,
      next: false
    };
    return this;
  };
  /**
   * Apply "transform" style with the current position to camera element
   * @ko 현재 위치를 기준으로한 transform 스타일을 카메라 엘리먼트에 적용합니다.
   * @return {this}
   */
  __proto.applyTransform = function () {
    var el = this._el;
    var flicking = getFlickingAttached(this._flicking);
    var renderer = flicking.renderer;
    if (renderer.rendering || !flicking.initialized) return this;
    var actualPosition = this._position - this._alignPos - this._offset + this._circularOffset;
    el.style[this._transform] = flicking.horizontal ? "translate(" + (this._panelOrder === ORDER.RTL ? actualPosition : -actualPosition) + "px)" : "translate(0, " + -actualPosition + "px)";
    return this;
  };
  __proto._resetInternalValues = function () {
    this._position = 0;
    this._alignPos = 0;
    this._offset = 0;
    this._circularOffset = 0;
    this._circularEnabled = false;
    this._range = {
      min: 0,
      max: 0
    };
    this._visiblePanels = [];
    this._anchors = [];
    this._needPanelTriggered = {
      prev: false,
      next: false
    };
  };
  __proto._refreshVisiblePanels = function () {
    var _this = this;
    var flicking = getFlickingAttached(this._flicking);
    var panels = flicking.renderer.panels;
    var newVisiblePanels = panels.filter(function (panel) {
      return _this.canSee(panel);
    });
    var prevVisiblePanels = this._visiblePanels;
    this._visiblePanels = newVisiblePanels;
    var added = newVisiblePanels.filter(function (panel) {
      return !includes(prevVisiblePanels, panel);
    });
    var removed = prevVisiblePanels.filter(function (panel) {
      return !includes(newVisiblePanels, panel);
    });
    if (added.length > 0 || removed.length > 0) {
      void flicking.renderer.render().then(function () {
        flicking.trigger(new ComponentEvent$1(EVENTS.VISIBLE_CHANGE, {
          added: added,
          removed: removed,
          visiblePanels: newVisiblePanels
        }));
      });
    }
  };
  __proto._checkNeedPanel = function () {
    var needPanelTriggered = this._needPanelTriggered;
    if (needPanelTriggered.prev && needPanelTriggered.next) return;
    var flicking = getFlickingAttached(this._flicking);
    var panels = flicking.renderer.panels;
    if (panels.length <= 0) {
      if (!needPanelTriggered.prev) {
        flicking.trigger(new ComponentEvent$1(EVENTS.NEED_PANEL, {
          direction: DIRECTION.PREV
        }));
        needPanelTriggered.prev = true;
      }
      if (!needPanelTriggered.next) {
        flicking.trigger(new ComponentEvent$1(EVENTS.NEED_PANEL, {
          direction: DIRECTION.NEXT
        }));
        needPanelTriggered.next = true;
      }
      return;
    }
    var cameraPosition = this._position;
    var cameraSize = this.size;
    var cameraRange = this._range;
    var needPanelThreshold = flicking.needPanelThreshold;
    var cameraPrev = cameraPosition - this._alignPos;
    var cameraNext = cameraPrev + cameraSize;
    var firstPanel = panels[0];
    var lastPanel = panels[panels.length - 1];
    if (!needPanelTriggered.prev) {
      var firstPanelPrev = firstPanel.range.min;
      if (cameraPrev <= firstPanelPrev + needPanelThreshold || cameraPosition <= cameraRange.min + needPanelThreshold) {
        flicking.trigger(new ComponentEvent$1(EVENTS.NEED_PANEL, {
          direction: DIRECTION.PREV
        }));
        needPanelTriggered.prev = true;
      }
    }
    if (!needPanelTriggered.next) {
      var lastPanelNext = lastPanel.range.max;
      if (cameraNext >= lastPanelNext - needPanelThreshold || cameraPosition >= cameraRange.max - needPanelThreshold) {
        flicking.trigger(new ComponentEvent$1(EVENTS.NEED_PANEL, {
          direction: DIRECTION.NEXT
        }));
        needPanelTriggered.next = true;
      }
    }
  };
  __proto._checkReachEnd = function (prevPos, newPos) {
    var flicking = getFlickingAttached(this._flicking);
    var range = this._range;
    var wasBetweenRange = prevPos > range.min && prevPos < range.max;
    var isBetweenRange = newPos > range.min && newPos < range.max;
    if (!wasBetweenRange || isBetweenRange) return;
    var direction = newPos <= range.min ? DIRECTION.PREV : DIRECTION.NEXT;
    flicking.trigger(new ComponentEvent$1(EVENTS.REACH_EDGE, {
      direction: direction
    }));
  };
  __proto._updateMode = function () {
    var flicking = getFlickingAttached(this._flicking);
    if (flicking.circular) {
      var circularMode = new CircularCameraMode(flicking);
      var canSetCircularMode = circularMode.checkAvailability();
      if (canSetCircularMode) {
        this._mode = circularMode;
      } else {
        var fallbackMode = flicking.circularFallback;
        this._mode = fallbackMode === CIRCULAR_FALLBACK.BOUND ? new BoundCameraMode(flicking) : new LinearCameraMode(flicking);
      }
      this._circularEnabled = canSetCircularMode;
    } else {
      this._mode = flicking.bound ? new BoundCameraMode(flicking) : new LinearCameraMode(flicking);
      this._circularEnabled = false;
    }
  };
  __proto._togglePanels = function (prevPos, pos) {
    if (pos === prevPos) return false;
    var flicking = getFlickingAttached(this._flicking);
    var panels = flicking.renderer.panels;
    var toggled = panels.map(function (panel) {
      return panel.toggle(prevPos, pos);
    });
    return toggled.some(function (isToggled) {
      return isToggled;
    });
  };
  return Camera;
}();

/**
 * A component that manages {@link Panel} and its elements
 * @ko {@link Panel}과 그 엘리먼트들을 관리하는 컴포넌트
 */
var Renderer = /*#__PURE__*/function () {
  /**
   * @param {object} options An options object<ko>옵션 오브젝트</ko>
   * @param {Constants.ALIGN | string | number} [options.align="center"] An {@link Flicking#align align} value that will be applied to all panels<ko>전체 패널에 적용될 {@link Flicking#align align} 값</ko>
   * @param {object} [options.strategy] An instance of RenderingStrategy(internal module)<ko>RenderingStrategy의 인스턴스(내부 모듈)</ko>
   */
  function Renderer(_a) {
    var _b = _a.align,
      align = _b === void 0 ? ALIGN.CENTER : _b,
      strategy = _a.strategy;
    this._flicking = null;
    this._panels = [];
    this._rendering = false;
    // Bind options
    this._align = align;
    this._strategy = strategy;
  }
  var __proto = Renderer.prototype;
  Object.defineProperty(__proto, "panels", {
    // Internal states Getter
    /**
     * Array of panels
     * @ko 전체 패널들의 배열
     * @type {Panel[]}
     * @readonly
     * @see Panel
     */
    get: function () {
      return this._panels;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "rendering", {
    /**
     * A boolean value indicating whether rendering is in progress
     * @ko 현재 렌더링이 시작되어 끝나기 전까지의 상태인지의 여부
     * @type {boolean}
     * @readonly
     * @internal
     */
    get: function () {
      return this._rendering;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "panelCount", {
    /**
     * Count of panels
     * @ko 전체 패널의 개수
     * @type {number}
     * @readonly
     */
    get: function () {
      return this._panels.length;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "strategy", {
    /**
     * @internal
     */
    get: function () {
      return this._strategy;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "align", {
    // Options Getter
    /**
     * A {@link Panel}'s {@link Panel#align align} value that applied to all panels
     * @ko {@link Panel}에 공통적으로 적용할 {@link Panel#align align} 값
     * @type {Constants.ALIGN | string | number}
     */
    get: function () {
      return this._align;
    },
    // Options Setter
    set: function (val) {
      this._align = val;
      var panelAlign = parsePanelAlign(val);
      this._panels.forEach(function (panel) {
        panel.align = panelAlign;
      });
    },
    enumerable: false,
    configurable: true
  });
  /**
   * Initialize Renderer
   * @ko Renderer를 초기화합니다
   * @param {Flicking} flicking An instance of {@link Flicking}<ko>Flicking의 인스턴스</ko>
   * @chainable
   * @return {this}
   */
  __proto.init = function (flicking) {
    this._flicking = flicking;
    this._collectPanels();
    return this;
  };
  /**
   * Destroy Renderer and return to initial state
   * @ko Renderer를 초기 상태로 되돌립니다
   * @return {void}
   */
  __proto.destroy = function () {
    this._flicking = null;
    this._panels = [];
  };
  /**
   * Return the {@link Panel} at the given index. `null` if it doesn't exists.
   * @ko 주어진 인덱스에 해당하는 {@link Panel}을 반환합니다. 주어진 인덱스에 해당하는 패널이 존재하지 않을 경우 `null`을 반환합니다.
   * @return {Panel | null} Panel at the given index<ko>주어진 인덱스에 해당하는 패널</ko>
   * @see Panel
   */
  __proto.getPanel = function (index) {
    return this._panels[index] || null;
  };
  __proto.forceRenderAllPanels = function () {
    this._panels.forEach(function (panel) {
      return panel.markForShow();
    });
    return Promise.resolve();
  };
  /**
   * Update all panel sizes
   * @ko 모든 패널의 크기를 업데이트합니다
   * @chainable
   * @return {this}
   */
  __proto.updatePanelSize = function () {
    var flicking = getFlickingAttached(this._flicking);
    var panels = this._panels;
    if (panels.length <= 0) return this;
    if (flicking.panelsPerView > 0) {
      var firstPanel = panels[0];
      firstPanel.resize();
      this._updatePanelSizeByGrid(firstPanel, panels);
    } else {
      flicking.panels.forEach(function (panel) {
        return panel.resize();
      });
    }
    return this;
  };
  /**
   * Insert new panels at given index
   * This will increase index of panels after by the number of panels added
   * @ko 주어진 인덱스에 새로운 패널들을 추가합니다
   * 해당 인덱스보다 같거나 큰 인덱스를 가진 기존 패널들은 추가한 패널의 개수만큼 인덱스가 증가합니다.
   * @param {Array<object>} items An array of items to insert<ko>추가할 아이템들의 배열</ko>
   * @param {number} [items.index] Index to insert new panels at<ko>새로 패널들을 추가할 인덱스</ko>
   * @param {any[]} [items.elements] An array of element or framework component with element in it<ko>엘리먼트의 배열 혹은 프레임워크에서 엘리먼트를 포함한 컴포넌트들의 배열</ko>
   * @param {boolean} [items.hasDOMInElements] Whether it contains actual DOM elements. If set to true, renderer will add them to the camera element<ko>내부에 실제 DOM 엘리먼트들을 포함하고 있는지 여부. true로 설정할 경우, 렌더러는 해당 엘리먼트들을 카메라 엘리먼트 내부에 추가합니다</ko>
   * @return {Panel[]} An array of prepended panels<ko>추가된 패널들의 배열</ko>
   */
  __proto.batchInsert = function () {
    var items = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      items[_i] = arguments[_i];
    }
    var allPanelsInserted = this.batchInsertDefer.apply(this, __spread$1(items));
    if (allPanelsInserted.length <= 0) return [];
    this.updateAfterPanelChange(allPanelsInserted, []);
    return allPanelsInserted;
  };
  /**
   * Defers update
   * camera position & others will be updated after calling updateAfterPanelChange
   * @internal
   */
  __proto.batchInsertDefer = function () {
    var _this = this;
    var items = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      items[_i] = arguments[_i];
    }
    var panels = this._panels;
    var flicking = getFlickingAttached(this._flicking);
    var prevFirstPanel = panels[0];
    var align = parsePanelAlign(this._align);
    var allPanelsInserted = items.reduce(function (addedPanels, item) {
      var _a;
      var insertingIdx = getMinusCompensatedIndex(item.index, panels.length);
      var panelsPushed = panels.slice(insertingIdx);
      var panelsInserted = item.elements.map(function (el, idx) {
        return _this._createPanel(el, {
          index: insertingIdx + idx,
          align: align,
          flicking: flicking
        });
      });
      panels.splice.apply(panels, __spread$1([insertingIdx, 0], panelsInserted));
      if (item.hasDOMInElements) {
        // Insert the actual elements as camera element's children
        _this._insertPanelElements(panelsInserted, (_a = panelsPushed[0]) !== null && _a !== void 0 ? _a : null);
      }
      // Resize the newly added panels
      if (flicking.panelsPerView > 0) {
        var firstPanel = prevFirstPanel || panelsInserted[0].resize();
        _this._updatePanelSizeByGrid(firstPanel, panelsInserted);
      } else {
        panelsInserted.forEach(function (panel) {
          return panel.resize();
        });
      }
      // Update panel indexes & positions
      panelsPushed.forEach(function (panel) {
        panel.increaseIndex(panelsInserted.length);
        panel.updatePosition();
      });
      return __spread$1(addedPanels, panelsInserted);
    }, []);
    return allPanelsInserted;
  };
  /**
   * Remove the panel at the given index
   * This will decrease index of panels after by the number of panels removed
   * @ko 주어진 인덱스의 패널을 제거합니다
   * 해당 인덱스보다 큰 인덱스를 가진 기존 패널들은 제거한 패널의 개수만큼 인덱스가 감소합니다
   * @param {Array<object>} items An array of items to remove<ko>제거할 아이템들의 배열</ko>
   * @param {number} [items.index] Index of panel to remove<ko>제거할 패널의 인덱스</ko>
   * @param {number} [items.deleteCount=1] Number of panels to remove from index<ko>`index` 이후로 제거할 패널의 개수</ko>
   * @param {boolean} [items.hasDOMInElements=1] Whether it contains actual DOM elements. If set to true, renderer will remove them from the camera element<ko>내부에 실제 DOM 엘리먼트들을 포함하고 있는지 여부. true로 설정할 경우, 렌더러는 해당 엘리먼트들을 카메라 엘리먼트 내부에서 제거합니다</ko>
   * @return An array of removed panels<ko>제거된 패널들의 배열</ko>
   */
  __proto.batchRemove = function () {
    var items = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      items[_i] = arguments[_i];
    }
    var allPanelsRemoved = this.batchRemoveDefer.apply(this, __spread$1(items));
    if (allPanelsRemoved.length <= 0) return [];
    this.updateAfterPanelChange([], allPanelsRemoved);
    return allPanelsRemoved;
  };
  /**
   * Defers update
   * camera position & others will be updated after calling updateAfterPanelChange
   * @internal
   */
  __proto.batchRemoveDefer = function () {
    var _this = this;
    var items = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      items[_i] = arguments[_i];
    }
    var panels = this._panels;
    var flicking = getFlickingAttached(this._flicking);
    var control = flicking.control;
    var activePanel = control.activePanel;
    var allPanelsRemoved = items.reduce(function (removed, item) {
      var index = item.index,
        deleteCount = item.deleteCount;
      var removingIdx = getMinusCompensatedIndex(index, panels.length);
      var panelsPulled = panels.slice(removingIdx + deleteCount);
      var panelsRemoved = panels.splice(removingIdx, deleteCount);
      if (panelsRemoved.length <= 0) return [];
      // Update panel indexes & positions
      panelsPulled.forEach(function (panel) {
        panel.decreaseIndex(panelsRemoved.length);
        panel.updatePosition();
      });
      if (item.hasDOMInElements) {
        _this._removePanelElements(panelsRemoved);
      }
      // Remove panel elements
      panelsRemoved.forEach(function (panel) {
        return panel.destroy();
      });
      if (includes(panelsRemoved, activePanel)) {
        control.resetActive();
      }
      return __spread$1(removed, panelsRemoved);
    }, []);
    return allPanelsRemoved;
  };
  /**
   * @internal
   */
  __proto.updateAfterPanelChange = function (panelsAdded, panelsRemoved) {
    var _a;
    var flicking = getFlickingAttached(this._flicking);
    var camera = flicking.camera,
      control = flicking.control;
    var panels = this._panels;
    var activePanel = control.activePanel;
    // Update camera & control
    this._updateCameraAndControl();
    void this.render();
    if (!flicking.animating) {
      if (!activePanel || activePanel.removed) {
        if (panels.length <= 0) {
          // All panels removed
          camera.lookAt(0);
        } else {
          var targetIndex = (_a = activePanel === null || activePanel === void 0 ? void 0 : activePanel.index) !== null && _a !== void 0 ? _a : 0;
          if (targetIndex > panels.length - 1) {
            targetIndex = panels.length - 1;
          }
          void control.moveToPanel(panels[targetIndex], {
            duration: 0
          }).catch(function () {
            return void 0;
          });
        }
      } else {
        void control.moveToPanel(activePanel, {
          duration: 0
        }).catch(function () {
          return void 0;
        });
      }
    }
    flicking.camera.updateOffset();
    if (panelsAdded.length > 0 || panelsRemoved.length > 0) {
      flicking.trigger(new ComponentEvent$1(EVENTS.PANEL_CHANGE, {
        added: panelsAdded,
        removed: panelsRemoved
      }));
      this.checkPanelContentsReady(__spread$1(panelsAdded, panelsRemoved));
    }
  };
  /**
   * @internal
   */
  __proto.checkPanelContentsReady = function (checkingPanels) {
    var _this = this;
    var flicking = getFlickingAttached(this._flicking);
    var resizeOnContentsReady = flicking.resizeOnContentsReady;
    var panels = this._panels;
    if (!resizeOnContentsReady || flicking.virtualEnabled) return;
    var hasContents = function (panel) {
      return panel.element && !!panel.element.querySelector("img, video");
    };
    checkingPanels = checkingPanels.filter(function (panel) {
      return hasContents(panel);
    });
    if (checkingPanels.length <= 0) return;
    var contentsReadyChecker = new ImReady();
    checkingPanels.forEach(function (panel) {
      panel.loading = true;
    });
    contentsReadyChecker.on("readyElement", function (e) {
      if (!_this._flicking) {
        // Renderer's destroy() is called before
        contentsReadyChecker.destroy();
        return;
      }
      var panel = checkingPanels[e.index];
      var camera = flicking.camera;
      var control = flicking.control;
      var prevProgressInPanel = control.activePanel ? camera.getProgressInPanel(control.activePanel) : 0;
      panel.loading = false;
      panel.resize();
      panels.slice(panel.index + 1).forEach(function (panelBehind) {
        return panelBehind.updatePosition();
      });
      if (!flicking.initialized) return;
      camera.updateRange();
      camera.updateOffset();
      camera.updateAnchors();
      if (control.animating) ; else {
        control.updatePosition(prevProgressInPanel);
        control.updateInput();
      }
    });
    contentsReadyChecker.on("preReady", function (e) {
      if (_this._flicking) {
        void _this.render();
      }
      if (e.readyCount === e.totalCount) {
        contentsReadyChecker.destroy();
      }
    });
    contentsReadyChecker.on("ready", function () {
      if (_this._flicking) {
        void _this.render();
      }
      contentsReadyChecker.destroy();
    });
    contentsReadyChecker.check(checkingPanels.map(function (panel) {
      return panel.element;
    }));
  };
  __proto._updateCameraAndControl = function () {
    var flicking = getFlickingAttached(this._flicking);
    var camera = flicking.camera,
      control = flicking.control;
    camera.updateRange();
    camera.updateOffset();
    camera.updateAnchors();
    camera.resetNeedPanelHistory();
    control.updateInput();
  };
  __proto._showOnlyVisiblePanels = function (flicking) {
    var panels = flicking.renderer.panels;
    var camera = flicking.camera;
    var visibleIndexes = camera.visiblePanels.reduce(function (visibles, panel) {
      visibles[panel.index] = true;
      return visibles;
    }, {});
    panels.forEach(function (panel) {
      if (panel.index in visibleIndexes || panel.loading) {
        panel.markForShow();
      } else if (!flicking.holding) {
        // During the input sequence,
        // Do not remove panel elements as it won't trigger touchend event.
        panel.markForHide();
      }
    });
  };
  __proto._updatePanelSizeByGrid = function (referencePanel, panels) {
    var flicking = getFlickingAttached(this._flicking);
    var panelsPerView = flicking.panelsPerView;
    if (panelsPerView <= 0) {
      throw new FlickingError(MESSAGE.WRONG_OPTION("panelsPerView", panelsPerView), CODE.WRONG_OPTION);
    }
    if (panels.length <= 0) return;
    var viewportSize = flicking.camera.size;
    var gap = referencePanel.margin.prev + referencePanel.margin.next;
    var panelSize = (viewportSize - gap * (panelsPerView - 1)) / panelsPerView;
    var panelSizeObj = flicking.horizontal ? {
      width: panelSize
    } : {
      height: panelSize
    };
    var firstPanelSizeObj = __assign$2({
      size: panelSize,
      margin: referencePanel.margin
    }, !flicking.horizontal && {
      height: referencePanel.height
    });
    if (!flicking.noPanelStyleOverride) {
      this._strategy.updatePanelSizes(flicking, panelSizeObj);
    }
    flicking.panels.forEach(function (panel) {
      return panel.resize(firstPanelSizeObj);
    });
  };
  __proto._removeAllChildsFromCamera = function () {
    var flicking = getFlickingAttached(this._flicking);
    var cameraElement = flicking.camera.element;
    // Remove other elements
    while (cameraElement.firstChild) {
      cameraElement.removeChild(cameraElement.firstChild);
    }
  };
  __proto._insertPanelElements = function (panels, nextSibling) {
    if (nextSibling === void 0) {
      nextSibling = null;
    }
    var flicking = getFlickingAttached(this._flicking);
    var camera = flicking.camera;
    var cameraElement = camera.element;
    var nextSiblingElement = (nextSibling === null || nextSibling === void 0 ? void 0 : nextSibling.element) || null;
    var fragment = document.createDocumentFragment();
    panels.forEach(function (panel) {
      return fragment.appendChild(panel.element);
    });
    cameraElement.insertBefore(fragment, nextSiblingElement);
  };
  __proto._removePanelElements = function (panels) {
    var flicking = getFlickingAttached(this._flicking);
    var cameraElement = flicking.camera.element;
    panels.forEach(function (panel) {
      cameraElement.removeChild(panel.element);
    });
  };
  __proto._afterRender = function () {
    var flicking = getFlickingAttached(this._flicking);
    flicking.camera.applyTransform();
  };
  return Renderer;
}();

/**
 *
 */
var VanillaRenderer = /*#__PURE__*/function (_super) {
  __extends$3(VanillaRenderer, _super);
  function VanillaRenderer() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  // eslint-disable-next-line @typescript-eslint/require-await
  var __proto = VanillaRenderer.prototype;
  __proto.render = function () {
    return __awaiter(this, void 0, void 0, function () {
      var flicking, strategy;
      return __generator(this, function (_a) {
        flicking = getFlickingAttached(this._flicking);
        strategy = this._strategy;
        strategy.updateRenderingPanels(flicking);
        strategy.renderPanels(flicking);
        this._resetPanelElementOrder();
        this._afterRender();
        return [2 /*return*/];
      });
    });
  };

  __proto._collectPanels = function () {
    var flicking = getFlickingAttached(this._flicking);
    var camera = flicking.camera;
    this._removeAllTextNodes();
    this._panels = this._strategy.collectPanels(flicking, camera.children);
  };
  __proto._createPanel = function (el, options) {
    return this._strategy.createPanel(el, options);
  };
  __proto._resetPanelElementOrder = function () {
    var flicking = getFlickingAttached(this._flicking);
    var cameraEl = flicking.camera.element;
    // We're using reversed panels here as last panel should be the last element of camera element
    var reversedElements = this._strategy.getRenderingElementsByOrder(flicking).reverse();
    reversedElements.forEach(function (el, idx) {
      var nextEl = reversedElements[idx - 1] ? reversedElements[idx - 1] : null;
      if (el.nextElementSibling !== nextEl) {
        cameraEl.insertBefore(el, nextEl);
      }
    });
  };
  __proto._removeAllTextNodes = function () {
    var flicking = getFlickingAttached(this._flicking);
    var cameraElement = flicking.camera.element;
    // Remove all text nodes in the camera element
    toArray$2(cameraElement.childNodes).forEach(function (node) {
      if (node.nodeType === Node.TEXT_NODE) {
        cameraElement.removeChild(node);
      }
    });
  };
  return VanillaRenderer;
}(Renderer);

/**
 * @internal
 */
var ExternalRenderer = /*#__PURE__*/function (_super) {
  __extends$3(ExternalRenderer, _super);
  function ExternalRenderer() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  /* eslint-disable @typescript-eslint/no-unused-vars */
  var __proto = ExternalRenderer.prototype;
  __proto._removePanelElements = function (panels) {
    // DO NOTHING, overrided to prevent an unexpected error
  };
  __proto._removeAllChildsFromCamera = function () {
    // DO NOTHING, overrided to prevent an unexpected error
  };
  return ExternalRenderer;
}(Renderer);

/**
 * A slide data component that holds information of a single HTMLElement
 * @ko 슬라이드 데이터 컴포넌트로, 단일 HTMLElement의 정보를 갖고 있습니다
 */
var Panel = /*#__PURE__*/function () {
  /**
   * @param {object} options An options object<ko>옵션 오브젝트</ko>
   * @param {number} [options.index] An initial index of the panel<ko>패널의 초기 인덱스</ko>
   * @param {Constants.ALIGN | string | number} [options.align] An initial {@link Flicking#align align} value of the panel<ko>패널의 초기 {@link Flicking#align align}값</ko>
   * @param {Flicking} [options.flicking] A Flicking instance panel's referencing<ko>패널이 참조하는 {@link Flicking} 인스턴스</ko>
   * @param {Flicking} [options.elementProvider] A provider instance that redirects elements<ko>실제 엘리먼트를 반환하는 엘리먼트 공급자의 인스턴스</ko>
   */
  function Panel(_a) {
    var index = _a.index,
      align = _a.align,
      flicking = _a.flicking,
      elementProvider = _a.elementProvider;
    this._index = index;
    this._flicking = flicking;
    this._elProvider = elementProvider;
    this._align = align;
    this._removed = false;
    this._rendered = true;
    this._loading = false;
    this._resetInternalStates();
  }
  var __proto = Panel.prototype;
  Object.defineProperty(__proto, "element", {
    // Internal States Getter
    /**
     * `HTMLElement` that panel's referencing
     * @ko 패널이 참조하고 있는 `HTMLElement`
     * @type {HTMLElement}
     * @readonly
     */
    get: function () {
      return this._elProvider.element;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "elementProvider", {
    /**
     * @internal
     * @readonly
     */
    get: function () {
      return this._elProvider;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "index", {
    /**
     * Index of the panel
     * @ko 패널의 인덱스
     * @type {number}
     * @readonly
     */
    get: function () {
      return this._index;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "position", {
    /**
     * Position of the panel, including {@link Panel#alignPosition alignPosition}
     * @ko 패널의 현재 좌표, {@link Panel#alignPosition alignPosition}을 포함하고 있습니다
     * @type {number}
     * @readonly
     */
    get: function () {
      return this._pos + this._alignPos;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "size", {
    /**
     * Cached size of the panel element
     * This is equal to {@link Panel#element element}'s `offsetWidth` if {@link Flicking#horizontal horizontal} is `true`, and `offsetHeight` else
     * @ko 패널 엘리먼트의 캐시된 크기
     * 이 값은 {@link Flicking#horizontal horizontal}이 `true`일 경우 {@link Panel#element element}의 `offsetWidth`와 동일하고, `false`일 경우 `offsetHeight`와 동일합니다
     * @type {number}
     * @readonly
     */
    get: function () {
      return this._size;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "sizeIncludingMargin", {
    /**
     * Panel's size including CSS `margin`
     * This value includes {@link Panel#element element}'s margin left/right if {@link Flicking#horizontal horizontal} is `true`, and margin top/bottom else
     * @ko CSS `margin`을 포함한 패널의 크기
     * 이 값은 {@link Flicking#horizontal horizontal}이 `true`일 경우 margin left/right을 포함하고, `false`일 경우 margin top/bottom을 포함합니다
     * @type {number}
     * @readonly
     */
    get: function () {
      return this._size + this._margin.prev + this._margin.next;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "height", {
    /**
     * Height of the panel element
     * @ko 패널 엘리먼트의 높이
     * @type {number}
     * @readonly
     */
    get: function () {
      return this._height;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "margin", {
    /**
     * Cached CSS `margin` value of the panel element
     * @ko 패널 엘리먼트의 CSS `margin` 값
     * @type {object}
     * @property {number} prev CSS `margin-left` when the {@link Flicking#horizontal horizontal} is `true`, and `margin-top` else
     * <ko>{@link Flicking#horizontal horizontal}이 `true`일 경우 `margin-left`, `false`일 경우 `margin-top`에 해당하는 값</ko>
     * @property {number} next CSS `margin-right` when the {@link Flicking#horizontal horizontal} is `true`, and `margin-bottom` else
     * <ko>{@link Flicking#horizontal horizontal}이 `true`일 경우 `margin-right`, `false`일 경우 `margin-bottom`에 해당하는 값</ko>
     * @readonly
     */
    get: function () {
      return this._margin;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "alignPosition", {
    /**
     * Align position inside the panel where {@link Camera}'s {@link Camera#alignPosition alignPosition} inside viewport should be located at
     * @ko 패널의 정렬 기준 위치. {@link Camera}의 뷰포트 내에서의 {@link Camera#alignPosition alignPosition}이 위치해야 하는 곳입니다
     * @type {number}
     * @readonly
     */
    get: function () {
      return this._alignPos;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "removed", {
    /**
     * A value indicating whether the panel's {@link Flicking#remove remove}d
     * @ko 패널이 {@link Flicking#remove remove}되었는지 여부를 나타내는 값
     * @type {boolean}
     * @readonly
     */
    get: function () {
      return this._removed;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "rendered", {
    /**
     * A value indicating whether the panel's element is being rendered on the screen
     * @ko 패널의 엘리먼트가 화면상에 렌더링되고있는지 여부를 나타내는 값
     * @type {boolean}
     * @readonly
     */
    get: function () {
      return this._rendered;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "loading", {
    /**
     * A value indicating whether the panel's image/video is not loaded and waiting for resize
     * @ko 패널 내부의 이미지/비디오가 아직 로드되지 않아 {@link Panel#resize resize}될 것인지를 나타내는 값
     * @type {boolean}
     * @readonly
     */
    get: function () {
      return this._loading;
    },
    set: function (val) {
      this._loading = val;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "range", {
    /**
     * Panel element's range of the bounding box
     * @ko 패널 엘리먼트의 Bounding box 범위
     * @type {object}
     * @property {number} [min] Bounding box's left({@link Flicking#horizontal horizontal}: true) / top({@link Flicking#horizontal horizontal}: false)
     * @property {number} [max] Bounding box's right({@link Flicking#horizontal horizontal}: true) / bottom({@link Flicking#horizontal horizontal}: false)
     * @readonly
     */
    get: function () {
      return {
        min: this._pos,
        max: this._pos + this._size
      };
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "toggled", {
    /**
     * A value indicating whether the panel's position is toggled by circular behavior
     * @ko 패널의 위치가 circular 동작에 의해 토글되었는지 여부를 나타내는 값
     * @type {boolean}
     * @readonly
     */
    get: function () {
      return this._toggled;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "toggleDirection", {
    /**
     * A direction where the panel's position is toggled
     * @ko 패널의 위치가 circular 동작에 의해 토글되는 방향
     * @type {DIRECTION}
     * @readonly
     */
    get: function () {
      return this._toggleDirection;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "offset", {
    /**
     * Actual position offset determined by {@link Panel#order}
     * @ko {@link Panel#order}에 의한 실제 위치 변경값
     * @type {number}
     * @readonly
     */
    get: function () {
      var toggleDirection = this._toggleDirection;
      var cameraRangeDiff = this._flicking.camera.rangeDiff;
      return toggleDirection === DIRECTION.NONE || !this._toggled ? 0 : toggleDirection === DIRECTION.PREV ? -cameraRangeDiff : cameraRangeDiff;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "progress", {
    /**
     * Progress of movement between previous or next panel relative to current panel
     * @ko 이 패널로부터 이전/다음 패널으로의 이동 진행률
     * @type {number}
     * @readonly
     */
    get: function () {
      var flicking = this._flicking;
      return this.index - flicking.camera.progress;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "outsetProgress", {
    /**
     * Progress of movement between points that panel is completely invisible outside of viewport(prev direction: -1, selected point: 0, next direction: 1)
     * @ko 현재 패널이 뷰포트 영역 밖으로 완전히 사라지는 지점을 기준으로 하는 진행도(prev방향: -1, 선택 지점: 0, next방향: 1)
     * @type {number}
     * @readonly
     */
    get: function () {
      var position = this.position + this.offset;
      var alignPosition = this._alignPos;
      var camera = this._flicking.camera;
      var camPos = camera.position;
      if (camPos === position) {
        return 0;
      }
      if (camPos < position) {
        var disappearPosNext = position + (camera.size - camera.alignPosition) + alignPosition;
        return -getProgress(camPos, position, disappearPosNext);
      } else {
        var disappearPosPrev = position - (camera.alignPosition + this._size - alignPosition);
        return 1 - getProgress(camPos, disappearPosPrev, position);
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "visibleRatio", {
    /**
     * Percentage of area where panel is visible in the viewport
     * @ko 뷰포트 안에서 패널이 보이는 영역의 비율
     * @type {number}
     * @readonly
     */
    get: function () {
      var range = this.range;
      var size = this._size;
      var offset = this.offset;
      var visibleRange = this._flicking.camera.visibleRange;
      var checkingRange = {
        min: range.min + offset,
        max: range.max + offset
      };
      if (checkingRange.max <= visibleRange.min || checkingRange.min >= visibleRange.max) {
        return 0;
      }
      var visibleSize = size;
      if (visibleRange.min > checkingRange.min) {
        visibleSize -= visibleRange.min - checkingRange.min;
      }
      if (visibleRange.max < checkingRange.max) {
        visibleSize -= checkingRange.max - visibleRange.max;
      }
      return visibleSize / size;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "align", {
    // Options Getter
    /**
     * A value indicating where the {@link Panel#alignPosition alignPosition} should be located at inside the panel element
     * @ko {@link Panel#alignPosition alignPosition}이 패널 내의 어디에 위치해야 하는지를 나타내는 값
     * @type {Constants.ALIGN | string | number}
     */
    get: function () {
      return this._align;
    },
    // Options Setter
    set: function (val) {
      this._align = val;
      this._updateAlignPos();
    },
    enumerable: false,
    configurable: true
  });
  /**
   * Mark panel element to be appended on the camera element
   * @internal
   */
  __proto.markForShow = function () {
    this._rendered = true;
    this._elProvider.show(this._flicking);
  };
  /**
   * Mark panel element to be removed from the camera element
   * @internal
   */
  __proto.markForHide = function () {
    this._rendered = false;
    this._elProvider.hide(this._flicking);
  };
  /**
   * Update size of the panel
   * @ko 패널의 크기를 갱신합니다
   * @param {object} cached Predefined cached size of the panel<ko>사전에 캐시된 패널의 크기 정보</ko>
   * @chainable
   * @return {this}
   */
  __proto.resize = function (cached) {
    var _a;
    var el = this.element;
    var flicking = this._flicking;
    var horizontal = flicking.horizontal,
      useFractionalSize = flicking.useFractionalSize;
    if (cached) {
      this._size = cached.size;
      this._margin = __assign$2({}, cached.margin);
      this._height = (_a = cached.height) !== null && _a !== void 0 ? _a : getElementSize({
        el: el,
        horizontal: false,
        useFractionalSize: useFractionalSize,
        useOffset: true,
        style: getStyle(el)
      });
    } else {
      var elStyle = getStyle(el);
      this._size = getElementSize({
        el: el,
        horizontal: horizontal,
        useFractionalSize: useFractionalSize,
        useOffset: true,
        style: elStyle
      });
      this._margin = horizontal ? {
        prev: parseFloat(elStyle.marginLeft || "0"),
        next: parseFloat(elStyle.marginRight || "0")
      } : {
        prev: parseFloat(elStyle.marginTop || "0"),
        next: parseFloat(elStyle.marginBottom || "0")
      };
      this._height = horizontal ? getElementSize({
        el: el,
        horizontal: false,
        useFractionalSize: useFractionalSize,
        useOffset: true,
        style: elStyle
      }) : this._size;
    }
    this.updatePosition();
    this._updateAlignPos();
    return this;
  };
  /**
   * Change panel's size. This will change the actual size of the panel element by changing its CSS width/height property
   * @ko 패널 크기를 변경합니다. 패널 엘리먼트에 해당 크기의 CSS width/height를 적용합니다
   * @param {object} [size] New panel size<ko>새 패널 크기</ko>
   * @param {number|string} [size.width] CSS string or number(in px)<ko>CSS 문자열 또는 숫자(px)</ko>
   * @param {number|string} [size.height] CSS string or number(in px)<ko>CSS 문자열 또는 숫자(px)</ko>
   * @chainable
   * @return {this}
   */
  __proto.setSize = function (size) {
    setSize(this.element, size);
    return this;
  };
  /**
   * Check whether the given element is inside of this panel's {@link Panel#element element}
   * @ko 해당 엘리먼트가 이 패널의 {@link Panel#element element} 내에 포함되어 있는지를 반환합니다
   * @param {HTMLElement} element The HTMLElement to check<ko>확인하고자 하는 HTMLElement</ko>
   * @return {boolean} A Boolean value indicating the element is inside of this panel {@link Panel#element element}<ko>패널의 {@link Panel#element element}내에 해당 엘리먼트 포함 여부</ko>
   */
  __proto.contains = function (element) {
    var _a;
    return !!((_a = this.element) === null || _a === void 0 ? void 0 : _a.contains(element));
  };
  /**
   * Reset internal state and set {@link Panel#removed removed} to `true`
   * @ko 내부 상태를 초기화하고 {@link Panel#removed removed}를 `true`로 설정합니다.
   * @return {void}
   */
  __proto.destroy = function () {
    this._resetInternalStates();
    this._removed = true;
  };
  /**
   * Check whether the given position is inside of this panel's {@link Panel#range range}
   * @ko 주어진 좌표가 현재 패널의 {@link Panel#range range}내에 속해있는지를 반환합니다.
   * @param {number} pos A position to check<ko>확인하고자 하는 좌표</ko>
   * @param {boolean} [includeMargin=false] Include {@link Panel#margin margin} to the range<ko>패널 영역에 {@link Panel#margin margin}값을 포함시킵니다</ko>
   * @return {boolean} A Boolean value indicating whether the given position is included in the panel range<ko>해당 좌표가 패널 영역 내에 속해있는지 여부</ko>
   */
  __proto.includePosition = function (pos, includeMargin) {
    if (includeMargin === void 0) {
      includeMargin = false;
    }
    return this.includeRange(pos, pos, includeMargin);
  };
  /**
   * Check whether the given range is fully included in this panel's area (inclusive)
   * @ko 주어진 범위가 이 패널 내부에 완전히 포함되는지를 반환합니다
   * @param {number} min Minimum value of the range to check<ko>확인하고자 하는 최소 범위</ko>
   * @param {number} max Maximum value of the range to check<ko>확인하고자 하는 최대 범위</ko>
   * @param {boolean} [includeMargin=false] Include {@link Panel#margin margin} to the range<ko>패널 영역에 {@link Panel#margin margin}값을 포함시킵니다</ko>
   * @returns {boolean} A Boolean value indicating whether the given range is fully included in the panel range<ko>해당 범위가 패널 영역 내에 완전히 속해있는지 여부</ko>
   */
  __proto.includeRange = function (min, max, includeMargin) {
    if (includeMargin === void 0) {
      includeMargin = false;
    }
    var margin = this._margin;
    var panelRange = this.range;
    if (includeMargin) {
      panelRange.min -= margin.prev;
      panelRange.max += margin.next;
    }
    return max >= panelRange.min && min <= panelRange.max;
  };
  /**
   * Check whether the panel is visble in the given range (exclusive)
   * @ko 주어진 범위 내에서 이 패널의 일부가 보여지는지를 반환합니다
   * @param {number} min Minimum value of the range to check<ko>확인하고자 하는 최소 범위</ko>
   * @param {number} max Maximum value of the range to check<ko>확인하고자 하는 최대 범위</ko>
   * @returns {boolean} A Boolean value indicating whether the panel is visible<ko>해당 범위 내에서 패널을 볼 수 있는지 여부</ko>
   */
  __proto.isVisibleOnRange = function (min, max) {
    var panelRange = this.range;
    return max > panelRange.min && min < panelRange.max;
  };
  /**
   * Move {@link Camera} to this panel
   * @ko {@link Camera}를 이 패널로 이동합니다
   * @param {number} [duration] Duration of the animation (unit: ms)<ko>애니메이션 진행 시간 (단위: ms)</ko>
   * @returns {Promise<void>} A Promise which will be resolved after reaching the panel<ko>패널 도달시에 resolve되는 Promise</ko>
   */
  __proto.focus = function (duration) {
    return this._flicking.moveTo(this._index, duration);
  };
  /**
   * Get previous(`index - 1`) panel. When the previous panel does not exist, this will return `null` instead
   * If the {@link Flicking#circularEnabled circular} is enabled, this will return the last panel if called from the first panel
   * @ko 이전(`index - 1`) 패널을 반환합니다. 이전 패널이 없을 경우 `null`을 반환합니다
   * {@link Flicking#circularEnabled circular} 모드가 활성화되었을 때 첫번째 패널에서 이 메소드를 호출할 경우 마지막 패널을 반환합니다
   * @returns {Panel | null} The previous panel<ko>이전 패널</ko>
   */
  __proto.prev = function () {
    var index = this._index;
    var flicking = this._flicking;
    var renderer = flicking.renderer;
    var panelCount = renderer.panelCount;
    if (panelCount === 1) return null;
    return flicking.circularEnabled ? renderer.getPanel(index === 0 ? panelCount - 1 : index - 1) : renderer.getPanel(index - 1);
  };
  /**
   * Get next(`index + 1`) panel. When the next panel does not exist, this will return `null` instead
   * If the {@link Flicking#circularEnabled circular} is enabled, this will return the first panel if called from the last panel
   * @ko 다음(`index + 1`) 패널을 반환합니다. 다음 패널이 없을 경우 `null`을 반환합니다
   * {@link Flicking#circularEnabled circular} 모드가 활성화되었을 때 마지막 패널에서 이 메소드를 호출할 경우 첫번째 패널을 반환합니다
   * @returns {Panel | null} The previous panel<ko>다음 패널</ko>
   */
  __proto.next = function () {
    var index = this._index;
    var flicking = this._flicking;
    var renderer = flicking.renderer;
    var panelCount = renderer.panelCount;
    if (panelCount === 1) return null;
    return flicking.circularEnabled ? renderer.getPanel(index === panelCount - 1 ? 0 : index + 1) : renderer.getPanel(index + 1);
  };
  /**
   * Increase panel's index by the given value
   * @ko 패널의 인덱스를 주어진 값만큼 증가시킵니다
   * @internal
   * @chainable
   * @param val An integer greater than or equal to 0<ko>0보다 같거나 큰 정수</ko>
   * @returns {this}
   */
  __proto.increaseIndex = function (val) {
    this._index += Math.max(val, 0);
    return this;
  };
  /**
   * Decrease panel's index by the given value
   * @ko 패널의 인덱스를 주어진 값만큼 감소시킵니다
   * @internal
   * @chainable
   * @param val An integer greater than or equal to 0<ko>0보다 같거나 큰 정수</ko>
   * @returns {this}
   */
  __proto.decreaseIndex = function (val) {
    this._index -= Math.max(val, 0);
    return this;
  };
  /**
   * @internal
   */
  __proto.updatePosition = function () {
    var prevPanel = this._flicking.renderer.panels[this._index - 1];
    this._pos = prevPanel ? prevPanel.range.max + prevPanel.margin.next + this._margin.prev : this._margin.prev;
    return this;
  };
  /**
   * @internal
   * @return {boolean} toggled
   */
  __proto.toggle = function (prevPos, newPos) {
    var toggleDirection = this._toggleDirection;
    var togglePosition = this._togglePosition;
    if (toggleDirection === DIRECTION.NONE || newPos === prevPos) return false;
    var prevToggled = this._toggled;
    if (newPos > prevPos) {
      if (togglePosition >= prevPos && togglePosition <= newPos) {
        this._toggled = toggleDirection === DIRECTION.NEXT;
      }
    } else {
      if (togglePosition <= prevPos && togglePosition >= newPos) {
        this._toggled = toggleDirection !== DIRECTION.NEXT;
      }
    }
    return prevToggled !== this._toggled;
  };
  /**
   * @internal
   */
  __proto.updateCircularToggleDirection = function () {
    var flicking = this._flicking;
    if (!flicking.circularEnabled) {
      this._toggleDirection = DIRECTION.NONE;
      this._togglePosition = 0;
      this._toggled = false;
      return this;
    }
    var camera = flicking.camera;
    var camRange = camera.range;
    var camAlignPosition = camera.alignPosition;
    var camVisibleRange = camera.visibleRange;
    var camVisibleSize = camVisibleRange.max - camVisibleRange.min;
    var minimumVisible = camRange.min - camAlignPosition;
    var maximumVisible = camRange.max - camAlignPosition + camVisibleSize;
    var shouldBeVisibleAtMin = this.includeRange(maximumVisible - camVisibleSize, maximumVisible, false);
    var shouldBeVisibleAtMax = this.includeRange(minimumVisible, minimumVisible + camVisibleSize, false);
    this._toggled = false;
    if (shouldBeVisibleAtMin) {
      this._toggleDirection = DIRECTION.PREV;
      this._togglePosition = this.range.max + camRange.min - camRange.max + camAlignPosition;
      this.toggle(Infinity, camera.position);
    } else if (shouldBeVisibleAtMax) {
      this._toggleDirection = DIRECTION.NEXT;
      this._togglePosition = this.range.min + camRange.max - camVisibleSize + camAlignPosition;
      this.toggle(-Infinity, camera.position);
    } else {
      this._toggleDirection = DIRECTION.NONE;
      this._togglePosition = 0;
    }
    return this;
  };
  __proto._updateAlignPos = function () {
    this._alignPos = parseAlign$1(this._align, this._size);
  };
  __proto._resetInternalStates = function () {
    this._size = 0;
    this._pos = 0;
    this._margin = {
      prev: 0,
      next: 0
    };
    this._height = 0;
    this._alignPos = 0;
    this._toggled = false;
    this._togglePosition = 0;
    this._toggleDirection = DIRECTION.NONE;
  };
  return Panel;
}();

var NormalRenderingStrategy = /*#__PURE__*/function () {
  function NormalRenderingStrategy(_a) {
    var providerCtor = _a.providerCtor;
    this._providerCtor = providerCtor;
  }
  var __proto = NormalRenderingStrategy.prototype;
  __proto.renderPanels = function () {
    // DO_NOTHING
  };
  __proto.getRenderingIndexesByOrder = function (flicking) {
    var renderedPanels = flicking.renderer.panels.filter(function (panel) {
      return panel.rendered;
    });
    var toggledPrev = renderedPanels.filter(function (panel) {
      return panel.toggled && panel.toggleDirection === DIRECTION.PREV;
    });
    var toggledNext = renderedPanels.filter(function (panel) {
      return panel.toggled && panel.toggleDirection === DIRECTION.NEXT;
    });
    var notToggled = renderedPanels.filter(function (panel) {
      return !panel.toggled;
    });
    return __spread$1(toggledPrev, notToggled, toggledNext).map(function (panel) {
      return panel.index;
    });
  };
  __proto.getRenderingElementsByOrder = function (flicking) {
    var panels = flicking.panels;
    return this.getRenderingIndexesByOrder(flicking).map(function (index) {
      return panels[index].element;
    });
  };
  __proto.updateRenderingPanels = function (flicking) {
    if (flicking.renderOnlyVisible) {
      this._showOnlyVisiblePanels(flicking);
    } else {
      flicking.panels.forEach(function (panel) {
        return panel.markForShow();
      });
    }
  };
  __proto.collectPanels = function (flicking, elements) {
    var _this = this;
    var align = parsePanelAlign(flicking.renderer.align);
    return elements.map(function (el, index) {
      return new Panel({
        index: index,
        elementProvider: new _this._providerCtor(el),
        align: align,
        flicking: flicking
      });
    });
  };
  __proto.createPanel = function (element, options) {
    return new Panel(__assign$2(__assign$2({}, options), {
      elementProvider: new this._providerCtor(element)
    }));
  };
  __proto.updatePanelSizes = function (flicking, size) {
    flicking.panels.forEach(function (panel) {
      return panel.setSize(size);
    });
  };
  __proto._showOnlyVisiblePanels = function (flicking) {
    var panels = flicking.renderer.panels;
    var camera = flicking.camera;
    var visibleIndexes = camera.visiblePanels.reduce(function (visibles, panel) {
      visibles[panel.index] = true;
      return visibles;
    }, {});
    panels.forEach(function (panel) {
      if (panel.index in visibleIndexes || panel.loading) {
        panel.markForShow();
      } else if (!flicking.holding) {
        // During the input sequence,
        // Do not remove panel elements as it won't trigger touchend event.
        panel.markForHide();
      }
    });
    camera.updateOffset();
  };
  return NormalRenderingStrategy;
}();

/**
 * An slide data component that holds information of a single HTMLElement
 * @ko 슬라이드 데이터 컴포넌트로, 단일 HTMLElement의 정보를 갖고 있습니다
 */
var VirtualPanel = /*#__PURE__*/function (_super) {
  __extends$3(VirtualPanel, _super);
  /**
   * @param {object} options An options object<ko>옵션 오브젝트</ko>
   * @param {number} [options.index] An initial index of the panel<ko>패널의 초기 인덱스</ko>
   * @param {Constants.ALIGN | string | number} [options.align] An initial {@link Flicking#align align} value of the panel<ko>패널의 초기 {@link Flicking#align align}값</ko>
   * @param {Flicking} [options.flicking] A Flicking instance panel's referencing<ko>패널이 참조하는 {@link Flicking} 인스턴스</ko>
   */
  function VirtualPanel(options) {
    var _this = _super.call(this, options) || this;
    options.elementProvider.init(_this);
    _this._elProvider = options.elementProvider;
    _this._cachedInnerHTML = null;
    return _this;
  }
  var __proto = VirtualPanel.prototype;
  Object.defineProperty(__proto, "element", {
    /**
     * `HTMLElement` that panel's referencing
     * @ko 패널이 참조하고 있는 `HTMLElement`
     * @type {HTMLElement}
     * @readonly
     */
    get: function () {
      return this._elProvider.element;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "cachedInnerHTML", {
    /**
     * Cached innerHTML by the previous render function
     * @ko 이전 렌더링에서 캐시된 innerHTML 정보
     * @type {string|null}
     * @readonly
     */
    get: function () {
      return this._cachedInnerHTML;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "elementIndex", {
    /**
     * An number for indexing which element it will be rendered on
     * @ko 몇 번째 엘리먼트에 렌더링될 것인지를 나타내는 숫자
     * @type {number}
     * @readonly
     */
    get: function () {
      var flicking = this._flicking;
      var virtualElCount = flicking.panelsPerView + 1;
      var panelCount = flicking.panelCount;
      var index = this._index;
      if (this._toggled) {
        // To prevent element duplication
        index = this._toggleDirection === DIRECTION.NEXT ? index + panelCount : index - panelCount;
      }
      return circulateIndex(index, virtualElCount);
    },
    enumerable: false,
    configurable: true
  });
  __proto.cacheRenderResult = function (result) {
    this._cachedInnerHTML = result;
  };
  __proto.uncacheRenderResult = function () {
    this._cachedInnerHTML = null;
  };
  __proto.render = function () {
    var flicking = this._flicking;
    var _a = flicking.virtual,
      renderPanel = _a.renderPanel,
      cache = _a.cache;
    var element = this._elProvider.element;
    var newInnerHTML = this._cachedInnerHTML || renderPanel(this, this._index);
    if (newInnerHTML === element.innerHTML) return;
    element.innerHTML = newInnerHTML;
    if (cache) {
      this.cacheRenderResult(newInnerHTML);
    }
  };
  __proto.increaseIndex = function (val) {
    this.uncacheRenderResult();
    return _super.prototype.increaseIndex.call(this, val);
  };
  __proto.decreaseIndex = function (val) {
    this.uncacheRenderResult();
    return _super.prototype.decreaseIndex.call(this, val);
  };
  return VirtualPanel;
}(Panel);

var VirtualRenderingStrategy = /*#__PURE__*/function () {
  function VirtualRenderingStrategy() {}
  var __proto = VirtualRenderingStrategy.prototype;
  __proto.renderPanels = function (flicking) {
    var virtualManager = flicking.virtual;
    var visiblePanels = flicking.visiblePanels;
    var invisibleIndexes = range(flicking.panelsPerView + 1);
    visiblePanels.forEach(function (panel) {
      var elementIndex = panel.elementIndex;
      panel.render();
      virtualManager.show(elementIndex);
      invisibleIndexes[elementIndex] = -1;
    });
    invisibleIndexes.filter(function (val) {
      return val >= 0;
    }).forEach(function (idx) {
      virtualManager.hide(idx);
    });
  };
  __proto.getRenderingIndexesByOrder = function (flicking) {
    var virtualManager = flicking.virtual;
    var visiblePanels = __spread$1(flicking.visiblePanels).filter(function (panel) {
      return panel.rendered;
    }).sort(function (panel1, panel2) {
      return panel1.position + panel1.offset - (panel2.position + panel2.offset);
    });
    if (visiblePanels.length <= 0) return virtualManager.elements.map(function (_, idx) {
      return idx;
    });
    var visibleIndexes = visiblePanels.map(function (panel) {
      return panel.elementIndex;
    });
    var invisibleIndexes = virtualManager.elements.map(function (el, idx) {
      return __assign$2(__assign$2({}, el), {
        idx: idx
      });
    }).filter(function (el) {
      return !el.visible;
    }).map(function (el) {
      return el.idx;
    });
    return __spread$1(visibleIndexes, invisibleIndexes);
  };
  __proto.getRenderingElementsByOrder = function (flicking) {
    var virtualManager = flicking.virtual;
    var elements = virtualManager.elements;
    return this.getRenderingIndexesByOrder(flicking).map(function (index) {
      return elements[index].nativeElement;
    });
  };
  __proto.updateRenderingPanels = function (flicking) {
    var panels = flicking.renderer.panels;
    var camera = flicking.camera;
    var visibleIndexes = camera.visiblePanels.reduce(function (visibles, panel) {
      visibles[panel.index] = true;
      return visibles;
    }, {});
    panels.forEach(function (panel) {
      if (panel.index in visibleIndexes || panel.loading) {
        panel.markForShow();
      } else {
        panel.markForHide();
      }
    });
    camera.updateOffset();
  };
  __proto.collectPanels = function (flicking) {
    var align = parsePanelAlign(flicking.renderer.align);
    return range(flicking.virtual.initialPanelCount).map(function (index) {
      return new VirtualPanel({
        index: index,
        elementProvider: new VirtualElementProvider(flicking),
        align: align,
        flicking: flicking
      });
    });
  };
  __proto.createPanel = function (_el, options) {
    return new VirtualPanel(__assign$2(__assign$2({}, options), {
      elementProvider: new VirtualElementProvider(options.flicking)
    }));
  };
  __proto.updatePanelSizes = function (flicking, size) {
    flicking.virtual.elements.forEach(function (el) {
      setSize(el.nativeElement, size);
    });
    flicking.panels.forEach(function (panel) {
      return panel.setSize(size);
    });
  };
  return VirtualRenderingStrategy;
}();

/**
 * @extends Component
 * @support {"ie": "9+(with polyfill)", "ch" : "latest", "ff" : "latest",  "sf" : "latest", "edge" : "latest", "ios" : "7+", "an" : "4.X+"}
 * @requires {@link https://github.com/naver/egjs-component|@egjs/component}
 * @requires {@link https://github.com/naver/egjs-axes|@egjs/axes}
 */
var Flicking = /*#__PURE__*/function (_super) {
  __extends$3(Flicking, _super);
  /**
   * @param root A root HTMLElement to initialize Flicking on it. When it's a typeof `string`, it should be a css selector string
   * <ko>Flicking을 초기화할 HTMLElement로, `string` 타입으로 지정시 css 선택자 문자열을 지정해야 합니다.</ko>
   * @param {object} [options={}] An options object for Flicking.<ko>Flicking에 적용할 옵션 오브젝트</ko>
   * @throws {FlickingError}
   * |code|condition|
   * |---|---|
   * |{@link ERROR_CODE WRONG_TYPE}|When the root is not either string or HTMLElement|
   * |{@link ERROR_CODE ELEMENT_NOT_FOUND}|When the element with given CSS selector does not exist|
   * <ko>
   *
   * |code|조건|
   * |---|---|
   * |{@link ERROR_CODE WRONG_TYPE}|루트 엘리먼트가 string이나 HTMLElement가 아닐 경우|
   * |{@link ERROR_CODE ELEMENT_NOT_FOUND}|주어진 CSS selector로 엘리먼트를 찾지 못했을 경우|
   *
   * </ko>
   * @example
   * ```ts
   * import Flicking from "@egjs/flicking";
   *
   * // Creating new instance of Flicking with HTMLElement
   * const flicking = new Flicking(document.querySelector(".flicking-viewport"), { circular: true });
   *
   * // Creating new instance of Flicking with CSS selector
   * const flicking2 = new Flicking(".flicking-viewport", { circular: true });
   * ```
   */
  function Flicking(root, _a) {
    var _b = _a === void 0 ? {} : _a,
      _c = _b.align,
      align = _c === void 0 ? ALIGN.CENTER : _c,
      _d = _b.defaultIndex,
      defaultIndex = _d === void 0 ? 0 : _d,
      _e = _b.horizontal,
      horizontal = _e === void 0 ? true : _e,
      _f = _b.circular,
      circular = _f === void 0 ? false : _f,
      _g = _b.circularFallback,
      circularFallback = _g === void 0 ? CIRCULAR_FALLBACK.LINEAR : _g,
      _h = _b.bound,
      bound = _h === void 0 ? false : _h,
      _j = _b.adaptive,
      adaptive = _j === void 0 ? false : _j,
      _k = _b.panelsPerView,
      panelsPerView = _k === void 0 ? -1 : _k,
      _l = _b.noPanelStyleOverride,
      noPanelStyleOverride = _l === void 0 ? false : _l,
      _m = _b.resizeOnContentsReady,
      resizeOnContentsReady = _m === void 0 ? false : _m,
      _o = _b.nested,
      nested = _o === void 0 ? false : _o,
      _p = _b.needPanelThreshold,
      needPanelThreshold = _p === void 0 ? 0 : _p,
      _q = _b.preventEventsBeforeInit,
      preventEventsBeforeInit = _q === void 0 ? true : _q,
      _r = _b.deceleration,
      deceleration = _r === void 0 ? 0.0075 : _r,
      _s = _b.duration,
      duration = _s === void 0 ? 500 : _s,
      _t = _b.easing,
      easing = _t === void 0 ? function (x) {
        return 1 - Math.pow(1 - x, 3);
      } : _t,
      _u = _b.inputType,
      inputType = _u === void 0 ? ["mouse", "touch"] : _u,
      _v = _b.moveType,
      moveType = _v === void 0 ? "snap" : _v,
      _w = _b.threshold,
      threshold = _w === void 0 ? 40 : _w,
      _x = _b.interruptable,
      interruptable = _x === void 0 ? true : _x,
      _y = _b.bounce,
      bounce = _y === void 0 ? "20%" : _y,
      _z = _b.iOSEdgeSwipeThreshold,
      iOSEdgeSwipeThreshold = _z === void 0 ? 30 : _z,
      _0 = _b.preventClickOnDrag,
      preventClickOnDrag = _0 === void 0 ? true : _0,
      _1 = _b.preventDefaultOnDrag,
      preventDefaultOnDrag = _1 === void 0 ? false : _1,
      _2 = _b.disableOnInit,
      disableOnInit = _2 === void 0 ? false : _2,
      _3 = _b.changeOnHold,
      changeOnHold = _3 === void 0 ? false : _3,
      _4 = _b.renderOnlyVisible,
      renderOnlyVisible = _4 === void 0 ? false : _4,
      _5 = _b.virtual,
      virtual = _5 === void 0 ? null : _5,
      _6 = _b.autoInit,
      autoInit = _6 === void 0 ? true : _6,
      _7 = _b.autoResize,
      autoResize = _7 === void 0 ? true : _7,
      _8 = _b.useResizeObserver,
      useResizeObserver = _8 === void 0 ? true : _8,
      _9 = _b.resizeDebounce,
      resizeDebounce = _9 === void 0 ? 0 : _9,
      _10 = _b.maxResizeDebounce,
      maxResizeDebounce = _10 === void 0 ? 100 : _10,
      _11 = _b.useFractionalSize,
      useFractionalSize = _11 === void 0 ? false : _11,
      _12 = _b.externalRenderer,
      externalRenderer = _12 === void 0 ? null : _12,
      _13 = _b.renderExternal,
      renderExternal = _13 === void 0 ? null : _13;
    var _this = _super.call(this) || this;
    // Internal states
    _this._initialized = false;
    _this._plugins = [];
    // Bind options
    _this._align = align;
    _this._defaultIndex = defaultIndex;
    _this._horizontal = horizontal;
    _this._circular = circular;
    _this._circularFallback = circularFallback;
    _this._bound = bound;
    _this._adaptive = adaptive;
    _this._panelsPerView = panelsPerView;
    _this._noPanelStyleOverride = noPanelStyleOverride;
    _this._resizeOnContentsReady = resizeOnContentsReady;
    _this._nested = nested;
    _this._virtual = virtual;
    _this._needPanelThreshold = needPanelThreshold;
    _this._preventEventsBeforeInit = preventEventsBeforeInit;
    _this._deceleration = deceleration;
    _this._duration = duration;
    _this._easing = easing;
    _this._inputType = inputType;
    _this._moveType = moveType;
    _this._threshold = threshold;
    _this._interruptable = interruptable;
    _this._bounce = bounce;
    _this._iOSEdgeSwipeThreshold = iOSEdgeSwipeThreshold;
    _this._preventClickOnDrag = preventClickOnDrag;
    _this._preventDefaultOnDrag = preventDefaultOnDrag;
    _this._disableOnInit = disableOnInit;
    _this._changeOnHold = changeOnHold;
    _this._renderOnlyVisible = renderOnlyVisible;
    _this._autoInit = autoInit;
    _this._autoResize = autoResize;
    _this._useResizeObserver = useResizeObserver;
    _this._resizeDebounce = resizeDebounce;
    _this._maxResizeDebounce = maxResizeDebounce;
    _this._useFractionalSize = useFractionalSize;
    _this._externalRenderer = externalRenderer;
    _this._renderExternal = renderExternal;
    // Create core components
    _this._viewport = new Viewport(_this, getElement(root));
    _this._autoResizer = new AutoResizer(_this);
    _this._renderer = _this._createRenderer();
    _this._camera = _this._createCamera();
    _this._control = _this._createControl();
    _this._virtualManager = new VirtualManager(_this, virtual);
    if (_this._autoInit) {
      void _this.init();
    }
    return _this;
  }
  var __proto = Flicking.prototype;
  Object.defineProperty(__proto, "control", {
    // Components
    /**
     * {@link Control} instance of the Flicking
     * @ko 현재 Flicking에 활성화된 {@link Control} 인스턴스
     * @type {Control}
     * @default SnapControl
     * @readonly
     * @see Control
     * @see SnapControl
     * @see FreeControl
     */
    get: function () {
      return this._control;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "camera", {
    /**
     * {@link Camera} instance of the Flicking
     * @ko 현재 Flicking에 활성화된 {@link Camera} 인스턴스
     * @type {Camera}
     * @default LinearCamera
     * @readonly
     * @see Camera
     * @see LinearCamera
     * @see BoundCamera
     * @see CircularCamera
     */
    get: function () {
      return this._camera;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "renderer", {
    /**
     * {@link Renderer} instance of the Flicking
     * @ko 현재 Flicking에 활성화된 {@link Renderer} 인스턴스
     * @type {Renderer}
     * @default VanillaRenderer
     * @readonly
     * @see Renderer
     * @see VanillaRenderer
     * @see ExternalRenderer
     */
    get: function () {
      return this._renderer;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "viewport", {
    /**
     * A component that manages viewport size
     * @ko 뷰포트 크기 정보를 담당하는 컴포넌트
     * @type {Viewport}
     * @readonly
     * @see Viewport
     */
    get: function () {
      return this._viewport;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "initialized", {
    // Internal States
    /**
     * Whether Flicking's {@link Flicking#init init()} is called.
     * This is `true` when {@link Flicking#init init()} is called, and is `false` after calling {@link Flicking#destroy destroy()}.
     * @ko Flicking의 {@link Flicking#init init()}이 호출되었는지를 나타내는 멤버 변수.
     * 이 값은 {@link Flicking#init init()}이 호출되었으면 `true`로 변하고, {@link Flicking#destroy destroy()}호출 이후에 다시 `false`로 변경됩니다.
     * @type {boolean}
     * @default false
     * @readonly
     */
    get: function () {
      return this._initialized;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "circularEnabled", {
    /**
     * Whether the `circular` option is enabled.
     * The {@link Flicking#circular circular} option can't be enabled when sum of the panel sizes are too small.
     * @ko {@link Flicking#circular circular} 옵션이 활성화되었는지 여부를 나타내는 멤버 변수.
     * {@link Flicking#circular circular} 옵션은 패널의 크기의 합이 충분하지 않을 경우 비활성화됩니다.
     * @type {boolean}
     * @default false
     * @readonly
     */
    get: function () {
      return this._camera.circularEnabled;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "virtualEnabled", {
    /**
     * Whether the `virtual` option is enabled.
     * The {@link Flicking#virtual virtual} option can't be enabled when  {@link Flicking#panelsPerView panelsPerView} is less or equal than zero.
     * @ko {@link Flicking#virtual virtual} 옵션이 활성화되었는지 여부를 나타내는 멤버 변수.
     * {@link Flicking#virtual virtual} 옵션은 {@link Flicking#panelsPerView panelsPerView} 옵션의 값이 0보다 같거나 작으면 비활성화됩니다.
     * @type {boolean}
     * @default false
     * @readonly
     */
    get: function () {
      return this._panelsPerView > 0 && this._virtual != null;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "index", {
    /**
     * Index number of the {@link Flicking#currentPanel currentPanel}
     * @ko {@link Flicking#currentPanel currentPanel}의 인덱스 번호
     * @type {number}
     * @default 0
     * @readonly
     */
    get: function () {
      return this._control.activeIndex;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "element", {
    /**
     * The root(`.flicking-viewport`) element
     * @ko root(`.flicking-viewport`) 엘리먼트
     * @type {HTMLElement}
     * @readonly
     */
    get: function () {
      return this._viewport.element;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "currentPanel", {
    /**
     * Currently active panel
     * @ko 현재 선택된 패널
     * @type {Panel}
     * @readonly
     * @see Panel
     */
    get: function () {
      return this._control.activePanel;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "panels", {
    /**
     * Array of panels
     * @ko 전체 패널들의 배열
     * @type {Panel[]}
     * @readonly
     * @see Panel
     */
    get: function () {
      return this._renderer.panels;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "panelCount", {
    /**
     * Count of panels
     * @ko 전체 패널의 개수
     * @type {number}
     * @readonly
     */
    get: function () {
      return this._renderer.panelCount;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "visiblePanels", {
    /**
     * Array of panels that is visible at the current position
     * @ko 현재 보이는 패널의 배열
     * @type {Panel[]}
     * @readonly
     * @see Panel
     */
    get: function () {
      return this._camera.visiblePanels;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "animating", {
    /**
     * Whether Flicking's animating
     * @ko 현재 애니메이션 동작 여부
     * @type {boolean}
     * @readonly
     */
    get: function () {
      return this._control.animating;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "holding", {
    /**
     * Whether user is clicking or touching
     * @ko 현재 사용자가 클릭/터치중인지 여부
     * @type {boolean}
     * @readonly
     */
    get: function () {
      return this._control.holding;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "activePlugins", {
    /**
     * A current list of activated plugins
     * @ko 현재 활성화된 플러그인 목록
     * @type {Plugin[]}
     * @readonly
     */
    get: function () {
      return this._plugins;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "align", {
    // Options Getter
    // UI / LAYOUT
    /**
     * Align position of the panels within viewport. You can set different values each for the panel and camera
     * @ko 뷰포트 내에서 패널 정렬방식을 설정하는 옵션. 카메라와 패널 개별로 옵션을 설정할 수도 있습니다
     * @type {ALIGN | string | number | { panel: string | number, camera: string | number }}
     * @property {ALIGN | string | number} panel The align value for each {@link Panel}s<ko>개개의 {@link Panel}에 적용할 값</ko>
     * @property {ALIGN | string | number} camera The align value for {@link Camera}<ko>{@link Camera}에 적용할 값</ko>
     * @default "center"
     * @see {@link https://naver.github.io/egjs-flicking/Options#align align ( Options )}
     * @example
     * ```ts
     * const possibleOptions = [
     *   // Literal strings
     *   "prev", "center", "next",
     *   // % values, applied to both panel & camera
     *   "0%", "25%", "42%",
     *   // px values, arithmetic calculation with (+/-) is also allowed.
     *   "0px", "100px", "50% - 25px",
     *   // numbers, same to number + px ("0px", "100px")
     *   0, 100, 1000,
     *   // Setting a different value for panel & camera
     *   { panel: "10%", camera: "25%" }
     * ];
     *
     * possibleOptions.forEach(align => {
     *   new Flicking("#el", { align });
     * });
     * ```
     */
    get: function () {
      return this._align;
    },
    // Options Setter
    // UI / LAYOUT
    set: function (val) {
      this._align = val;
      this._renderer.align = val;
      this._camera.align = val;
      void this.resize();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "defaultIndex", {
    /**
     * Index of the panel to move when Flicking's {@link Flicking#init init()} is called. A zero-based integer
     * @ko Flicking의 {@link Flicking#init init()}이 호출될 때 이동할 디폴트 패널의 인덱스로, 0부터 시작하는 정수입니다
     * @type {number}
     * @default 0
     * @see {@link https://naver.github.io/egjs-flicking/Options#defaultindex defaultIndex ( Options )}
     */
    get: function () {
      return this._defaultIndex;
    },
    set: function (val) {
      this._defaultIndex = val;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "horizontal", {
    /**
     * Direction of panel movement (true: horizontal, false: vertical)
     * @ko 패널 이동 방향 (true: 가로방향, false: 세로방향)
     * @type {boolean}
     * @default true
     * @see {@link https://naver.github.io/egjs-flicking/Options#horizontal horizontal ( Options )}
     */
    get: function () {
      return this._horizontal;
    },
    set: function (val) {
      this._horizontal = val;
      this._control.controller.updateDirection();
      void this.resize();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "circular", {
    /**
     * Enables circular(continuous loop) mode, which connects first/last panel for continuous scrolling.
     * @ko 순환 모드를 활성화합니다. 순환 모드에서는 양 끝의 패널이 서로 연결되어 끊김없는 스크롤이 가능합니다.
     * @type {boolean}
     * @default false
     * @see {@link https://naver.github.io/egjs-flicking/Options#circular circular ( Options )}
     */
    get: function () {
      return this._circular;
    },
    set: function (val) {
      this._circular = val;
      void this.resize();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "circularFallback", {
    /**
     * Set panel control mode for the case when circular cannot be enabled.
     * "linear" will set the view's range from the top of the first panel to the top of the last panel.
     * "bound" will prevent the view from going out of the first/last panel, so it won't show empty spaces before/after the first/last panel.
     * @ko 순환 모드 사용 불가능시 사용할 패널 조작 범위 설정 방식을 변경합니다.
     * "linear" 사용시 시점이 첫번째 엘리먼트 위에서부터 마지막 엘리먼트 위까지 움직일 수 있도록 설정합니다.
     * "bound" 사용시 시점이 첫번째 엘리먼트와 마지막 엘리먼트의 끝과 끝 사이에서 움직일 수 있도록 설정합니다.
     * @see CIRCULAR_FALLBACK
     * @type {string}
     * @default "linear"
     * @see {@link https://naver.github.io/egjs-flicking/Options#circularfallback circularFallback ( Options )}
     */
    get: function () {
      return this._circularFallback;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "bound", {
    /**
     * Prevent the view(camera element) from going out of the first/last panel, so it won't show empty spaces before/after the first/last panel
     * Only can be enabled when `circular=false`
     * @ko 뷰(카메라 엘리먼트)가 첫번째와 마지막 패널 밖으로 넘어가지 못하게 하여, 첫번째/마지막 패널 전/후의 빈 공간을 보이지 않도록 하는 옵션입니다
     * `circular=false`인 경우에만 사용할 수 있습니다
     * @type {boolean}
     * @default false
     * @see {@link https://naver.github.io/egjs-flicking/Options#bound bound ( Options )}
     */
    get: function () {
      return this._bound;
    },
    set: function (val) {
      this._bound = val;
      void this.resize();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "adaptive", {
    /**
     * Update height of the viewport element after movement same to the height of the panel below. This can be only enabled when `horizontal=true`
     * @ko 이동한 후 뷰포트 엘리먼트의 크기를 현재 패널의 높이와 동일하게 설정합니다. `horizontal=true`인 경우에만 사용할 수 있습니다.
     * @type {boolean}
     * @default false
     * @see {@link https://naver.github.io/egjs-flicking/Options#adaptive adaptive ( Options )}
     */
    get: function () {
      return this._adaptive;
    },
    set: function (val) {
      this._adaptive = val;
      void this.resize();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "panelsPerView", {
    /**
     * A visible number of panels on viewport. Enabling this option will automatically resize panel size
     * @ko 한 화면에 보이는 패널의 개수. 이 옵션을 활성화할 경우 패널의 크기를 강제로 재조정합니다
     * @type {number}
     * @default -1
     * @see {@link https://naver.github.io/egjs-flicking/Options#panelsperview panelsPerView ( Options )}
     */
    get: function () {
      return this._panelsPerView;
    },
    set: function (val) {
      this._panelsPerView = val;
      void this.resize();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "noPanelStyleOverride", {
    /**
     * Enabling this option will not change `width/height` style of the panels if {@link Flicking#panelsPerView} is enabled.
     * This behavior can be useful in terms of performance when you're manually managing all panel sizes
     * @ko 이 옵션을 활성화할 경우, {@link Flicking#panelsPerView} 옵션이 활성화되었을 때 패널의 `width/height` 스타일을 변경하지 않도록 설정합니다.
     * 모든 패널들의 크기를 직접 관리하고 있을 경우, 이 옵션을 활성화하면 성능면에서 유리할 수 있습니다
     * @type {boolean}
     * @default false
     */
    get: function () {
      return this._noPanelStyleOverride;
    },
    set: function (val) {
      this._noPanelStyleOverride = val;
      void this.resize();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "resizeOnContentsReady", {
    /**
     * Enabling this option will automatically call {@link Flicking#resize} when all image/video inside panels are loaded.
     * This can be useful when you have contents inside Flicking that changes its size when it's loaded
     * @ko 이 옵션을 활성화할 경우, Flicking 패널 내부의 이미지/비디오들이 로드되었을 때 자동으로 {@link Flicking#resize}를 호출합니다.
     * 이 동작은 Flicking 내부에 로드 전/후로 크기가 변하는 콘텐츠를 포함하고 있을 때 유용하게 사용하실 수 있습니다.
     * @type {boolean}
     * @default false
     * @see {@link https://naver.github.io/egjs-flicking/Options#resizeOnContentsReady resizeOnContentsReady ( Options )}
     */
    get: function () {
      return this._resizeOnContentsReady;
    },
    set: function (val) {
      this._resizeOnContentsReady = val;
      if (val) {
        this._renderer.checkPanelContentsReady(this._renderer.panels);
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "nested", {
    /**
     * If you enable this option on child Flicking when the Flicking is placed inside the Flicking, the parent Flicking will move in the same direction after the child Flicking reaches the first/last panel.
     * If the parent Flicking and child Flicking have different horizontal option, you do not need to set this option.
     * @ko Flicking 내부에 Flicking이 배치될 때 하위 Flicking에서 이 옵션을 활성화하면 하위 Flicking이 첫/마지막 패널에 도달한 뒤부터 같은 방향으로 상위 Flicking이 움직입니다.
     * 만약 상위 Flicking과 하위 Flicking이 서로 다른 horizontal 옵션을 가지고 있다면 이 옵션을 설정할 필요가 없습니다.
     * @type {boolean}
     * @default false
     * @see {@link https://naver.github.io/egjs-flicking/Options#nested nested ( Options )}
     */
    get: function () {
      return this._nested;
    },
    set: function (val) {
      this._nested = val;
      var axes = this._control.controller.axes;
      if (axes) {
        axes.options.nested = val;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "needPanelThreshold", {
    // EVENTS
    /**
     * A Threshold from viewport edge before triggering `needPanel` event
     * @ko `needPanel`이벤트가 발생하기 위한 뷰포트 끝으로부터의 최대 거리
     * @type {number}
     * @default 0
     * @see {@link https://naver.github.io/egjs-flicking/Options#needpanelthreshold needPanelThreshold ( Options )}
     */
    get: function () {
      return this._needPanelThreshold;
    },
    // EVENTS
    set: function (val) {
      this._needPanelThreshold = val;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "preventEventsBeforeInit", {
    /**
     * When enabled, events are not triggered before `ready` when initializing
     * @ko 활성화할 경우 초기화시 `ready` 이벤트 이전의 이벤트가 발생하지 않습니다.
     * @type {boolean}
     * @default true
     * @see {@link https://naver.github.io/egjs-flicking/Options#preventeventsbeforeinit preventEventsBeforeInit ( Options )}
     */
    get: function () {
      return this._preventEventsBeforeInit;
    },
    set: function (val) {
      this._preventEventsBeforeInit = val;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "deceleration", {
    // ANIMATION
    /**
     * Deceleration value for panel movement animation which is triggered by user input. A higher value means a shorter animation time
     * @ko 사용자의 동작으로 가속도가 적용된 패널 이동 애니메이션의 감속도. 값이 높을수록 애니메이션 실행 시간이 짧아집니다
     * @type {number}
     * @default 0.0075
     * @see {@link https://naver.github.io/egjs-flicking/Options#deceleration deceleration ( Options )}
     */
    get: function () {
      return this._deceleration;
    },
    // ANIMATION
    set: function (val) {
      this._deceleration = val;
      var axes = this._control.controller.axes;
      if (axes) {
        axes.options.deceleration = val;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "easing", {
    /**
     * An easing function applied to the panel movement animation. Default value is `easeOutCubic`
     * @ko 패널 이동 애니메이션에 적용할 easing 함수. 기본값은 `easeOutCubic`이다
     * @type {function}
     * @default x => 1 - Math.pow(1 - x, 3)
     * @see Easing Functions Cheat Sheet {@link http://easings.net/} <ko>이징 함수 Cheat Sheet {@link http://easings.net/}</ko>
     * @see {@link https://naver.github.io/egjs-flicking/Options#easing Easing ( Options )}
     */
    get: function () {
      return this._easing;
    },
    set: function (val) {
      this._easing = val;
      var axes = this._control.controller.axes;
      if (axes) {
        axes.options.easing = val;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "duration", {
    /**
     * Default duration of the animation (ms)
     * @ko 디폴트 애니메이션 재생 시간 (ms)
     * @type {number}
     * @default 500
     * @see {@link https://naver.github.io/egjs-flicking/Options#duration duration ( Options )}
     */
    get: function () {
      return this._duration;
    },
    set: function (val) {
      this._duration = val;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "inputType", {
    // INPUT
    /**
     * Types of input devices to enable
     * @ko 활성화할 입력 장치 종류
     * @type {string[]}
     * @default ["touch", "mouse"]
     * @see {@link https://naver.github.io/egjs-axes/Options#paninput-options Possible values (PanInputOption#inputType)}
     * <ko>{@link https://naver.github.io/egjs-axes/Options#paninput-options 가능한 값들 (PanInputOption#inputType)}</ko>
     * @see {@link https://naver.github.io/egjs-flicking/Options#inputtype inputType ( Options )}
     */
    get: function () {
      return this._inputType;
    },
    // INPUT
    set: function (val) {
      this._inputType = val;
      var panInput = this._control.controller.panInput;
      if (panInput) {
        panInput.options.inputType = val;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "moveType", {
    /**
     * Movement style by user input. This will change instance type of {@link Flicking#control}
     * You can use the values of the constant {@link MOVE_TYPE}
     * @ko 사용자 입력에 의한 이동 방식. 이 값에 따라 {@link Flicking#control}의 인스턴스 타입이 결정됩니다
     * 상수 {@link MOVE_TYPE}에 정의된 값들을 이용할 수 있습니다
     * @type {MOVE_TYPE | Pair<string, object>}
     * @default "snap"
     * @see {@link https://naver.github.io/egjs-flicking/Options#movetype moveType ( Options )}
     * @example
     * |moveType|control|options|
     * |:---:|:---:|:---:|
     * |"snap"|{@link SnapControl}||
     * |"freeScroll"|{@link FreeControl}|{@link FreeControlOptions}|
     *
     * ```ts
     * import Flicking, { MOVE_TYPE } from "@egjs/flicking";
     *
     * const flicking = new Flicking({
     *   moveType: MOVE_TYPE.SNAP
     * });
     * ```
     *
     * ```ts
     * const flicking = new Flicking({
     *   // If you want more specific settings for the moveType
     *   // [moveType, options for that moveType]
     *   // In this case, it's ["freeScroll", FreeControlOptions]
     *   moveType: [MOVE_TYPE.FREE_SCROLL, { stopAtEdge: true }]
     * });
     * ```
     */
    get: function () {
      return this._moveType;
    },
    set: function (val) {
      this._moveType = val;
      var prevControl = this._control;
      var newControl = this._createControl();
      var activePanel = prevControl.activePanel;
      newControl.copy(prevControl);
      var prevProgressInPanel = activePanel ? this._camera.getProgressInPanel(activePanel) : 0;
      this._control = newControl;
      this._control.updatePosition(prevProgressInPanel);
      this._control.updateInput();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "threshold", {
    /**
     * Movement threshold to change panel (unit: px). It should be dragged above the threshold to change the current panel.
     * @ko 패널 변경을 위한 이동 임계값 (단위: px). 주어진 값 이상으로 스크롤해야만 패널 변경이 가능하다.
     * @type {number}
     * @default 40
     * @see {@link https://naver.github.io/egjs-flicking/Options#threshold Threshold ( Options )}
     */
    get: function () {
      return this._threshold;
    },
    set: function (val) {
      this._threshold = val;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "interruptable", {
    /**
     * Set animation to be interruptable by click/touch.
     * @ko 사용자의 클릭/터치로 인해 애니메이션을 도중에 멈출 수 있도록 설정합니다.
     * @type {boolean}
     * @default true
     * @see {@link https://naver.github.io/egjs-flicking/Options#interruptable Interruptable ( Options )}
     */
    get: function () {
      return this._interruptable;
    },
    set: function (val) {
      this._interruptable = val;
      var axes = this._control.controller.axes;
      if (axes) {
        axes.options.interruptable = val;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "bounce", {
    /**
     * The size value of the bounce area. Only can be enabled when `circular=false`.
     * You can set different bounce value for prev/next direction by using array.
     * `number` for px value, and `string` for px, and % value relative to viewport size.
     * You have to call {@link Control#updateInput} after changing this to take effect.
     * @ko Flicking이 최대 영역을 넘어서 갈 수 있는 최대 크기. `circular=false`인 경우에만 사용할 수 있습니다.
     * 배열을 통해 prev/next 방향에 대해 서로 다른 바운스 값을 지정할 수 있습니다.
     * `number`를 통해 px값을, `stirng`을 통해 px 혹은 뷰포트 크기 대비 %값을 사용할 수 있습니다.
     * 이 값을 변경시 {@link Control#updateInput}를 호출해야 합니다.
     * @type {string | number | Array<string | number>}
     * @default "20%"
     * @see {@link https://naver.github.io/egjs-flicking/Options#bounce bounce ( Options )}
     * @example
     * ```ts
     * const possibleOptions = [
     *   // % values, relative to viewport element(".flicking-viewport")'s size
     *   "0%", "25%", "42%",
     *   // px values, arithmetic calculation with (+/-) is also allowed.
     *   "0px", "100px", "50% - 25px",
     *   // numbers, same to number + px ("0px", "100px")
     *   0, 100, 1000
     * ];
     * ```
     *
     * @example
     * ```ts
     * const flicking = new Flicking("#el", { bounce: "20%" });
     *
     * flicking.bounce = "100%";
     * flicking.control.updateInput(); // Call this to update!
     * ```
     */
    get: function () {
      return this._bounce;
    },
    set: function (val) {
      this._bounce = val;
      this._control.updateInput();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "iOSEdgeSwipeThreshold", {
    /**
     * Size of the area from the right edge in iOS safari (in px) which enables swipe-back or swipe-forward
     * @ko iOS Safari에서 swipe를 통한 뒤로가기/앞으로가기를 활성화하는 오른쪽 끝으로부터의 영역의 크기 (px)
     * @type {number}
     * @default 30
     * @see {@link https://naver.github.io/egjs-flicking/Options#iosedgeswipethreshold iOSEdgeSwipeThreshold ( Options )}
     */
    get: function () {
      return this._iOSEdgeSwipeThreshold;
    },
    set: function (val) {
      this._iOSEdgeSwipeThreshold = val;
      var panInput = this._control.controller.panInput;
      if (panInput) {
        panInput.options.iOSEdgeSwipeThreshold = val;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "preventClickOnDrag", {
    /**
     * Automatically prevent `click` event if the user has dragged at least a single pixel on the viewport element
     * @ko 사용자가 뷰포트 영역을 1픽셀이라도 드래그했을 경우 자동으로 {@link https://developer.mozilla.org/ko/docs/Web/API/Element/click_event click} 이벤트를 취소합니다
     * @type {boolean}
     * @default true
     * @see {@link https://naver.github.io/egjs-flicking/Options#preventclickondrag preventClickOnDrag ( Options )}
     */
    get: function () {
      return this._preventClickOnDrag;
    },
    set: function (val) {
      var prevVal = this._preventClickOnDrag;
      if (val === prevVal) return;
      var controller = this._control.controller;
      if (val) {
        controller.addPreventClickHandler();
      } else {
        controller.removePreventClickHandler();
      }
      this._preventClickOnDrag = val;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "preventDefaultOnDrag", {
    /**
     * Whether to use the {@link https://developer.mozilla.org/ko/docs/Web/API/Event/preventDefault preventDefault} when the user starts dragging
     * @ko 사용자가 드래그를 시작할 때 {@link https://developer.mozilla.org/ko/docs/Web/API/Event/preventDefault preventDefault} 실행 여부
     * @type {boolean}
     * @default false
     * @see {@link https://naver.github.io/egjs-flicking/Options#preventDefaultOnDrag preventDefaultOnDrag ( Options )}
     */
    get: function () {
      return this._preventDefaultOnDrag;
    },
    set: function (val) {
      this._preventDefaultOnDrag = val;
      var panInput = this._control.controller.panInput;
      if (panInput) {
        panInput.options.preventDefaultOnDrag = val;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "disableOnInit", {
    /**
     * Automatically call {@link Flicking#disableInput disableInput()} on initialization
     * @ko Flicking init시에 {@link Flicking#disableInput disableInput()}을 바로 호출합니다
     * @type {boolean}
     * @default false
     * @see {@link https://naver.github.io/egjs-flicking/Options#disableoninit disableOnInit ( Options )}
     */
    get: function () {
      return this._disableOnInit;
    },
    set: function (val) {
      this._disableOnInit = val;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "changeOnHold", {
    /**
     * Change active panel index on mouse/touch hold while animating.
     * `index` of the `willChange`/`willRestore` event will be used as new index.
     * @ko 애니메이션 도중 마우스/터치 입력시 현재 활성화된 패널의 인덱스를 변경합니다.
     * `willChange`/`willRestore` 이벤트의 `index`값이 새로운 인덱스로 사용될 것입니다.
     * @type {boolean}
     * @default false
     * @see {@link https://naver.github.io/egjs-flicking/Options#changeonhold changeOnHold ( Options )}
     */
    get: function () {
      return this._changeOnHold;
    },
    set: function (val) {
      this._changeOnHold = val;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "renderOnlyVisible", {
    // PERFORMANCE
    /**
     * Whether to render visible panels only. This can dramatically increase performance when there're many panels
     * @ko 보이는 패널만 렌더링할지 여부를 설정합니다. 패널이 많을 경우에 퍼포먼스를 크게 향상시킬 수 있습니다
     * @type {boolean}
     * @default false
     * @see {@link https://naver.github.io/egjs-flicking/Options#renderonlyvisible renderOnlyVisible ( Options )}
     */
    get: function () {
      return this._renderOnlyVisible;
    },
    // PERFORMANCE
    set: function (val) {
      this._renderOnlyVisible = val;
      void this._renderer.render();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "virtual", {
    /**
     * By enabling this option, it will reduce memory consumption by restricting the number of DOM elements to `panelsPerView + 1`
     * Must be used with `panelsPerview`.
     * After Flicking's initialized, this property can be used to add/remove the panel count.
     * @ko 이 옵션을 활성화할 경우 패널 엘리먼트의 개수를 `panelsPerView + 1` 개로 고정함으로써, 메모리 사용량을 줄일 수 있습니다.
     * `panelsPerView` 옵션과 함께 사용되어야만 합니다.
     * Flicking 초기화 이후에, 이 프로퍼티는 렌더링하는 패널의 개수를 추가/제거하기 위해 사용될 수 있습니다.
     * @type {VirtualManager}
     * @property {function} renderPanel A rendering function for the panel element's innerHTML<ko>패널 엘리먼트의 innerHTML을 렌더링하는 함수</ko>
     * @property {number} initialPanelCount Initial panel count to render<ko>최초로 렌더링할 패널의 개수</ko>
     * @property {boolean} [cache=false] Whether to cache rendered panel's innerHTML<ko>렌더링된 패널의 innerHTML 정보를 캐시할지 여부</ko>
     * @property {string} [panelClass="flicking-panel"] The class name that will be applied to rendered panel elements<ko>렌더링되는 패널 엘리먼트에 적용될 클래스 이름</ko>
     * @see {@link https://naver.github.io/egjs-flicking/Options#virtual virtual ( Options )}
     * @example
     * ```ts
     * import Flicking, { VirtualPanel } from "@egjs/flicking";
     *
     * const flicking = new Flicking("#some_el", {
     *   panelsPerView: 3,
     *   virtual: {
     *     renderPanel: (panel: VirtualPanel, index: number) => `Panel ${index}`,
     *     initialPanelCount: 100
     *   }
     * });
     *
     * // Add 100 virtual panels (at the end)
     * flicking.virtual.append(100);
     *
     * // Remove 100 virtual panels from 0 to 100
     * flicking.virtual.remove(0, 100);
     * ```
     */
    get: function () {
      return this._virtualManager;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "autoInit", {
    // OTHERS
    /**
     * Call {@link Flicking#init init()} automatically when creating Flicking's instance
     * @ko Flicking 인스턴스를 생성할 때 자동으로 {@link Flicking#init init()}를 호출합니다
     * @type {boolean}
     * @default true
     * @see {@link https://naver.github.io/egjs-flicking/Options#autoinit autoInit ( Options )}
     * @readonly
     */
    get: function () {
      return this._autoInit;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "autoResize", {
    /**
     * Whether to automatically call {@link Flicking#resize resize()} when the viewport element(.flicking-viewport)'s size is changed
     * @ko 뷰포트 엘리먼트(.flicking-viewport)의 크기 변경시 {@link Flicking#resize resize()} 메소드를 자동으로 호출할지 여부를 설정합니다
     * @type {boolean}
     * @default true
     */
    get: function () {
      return this._autoResize;
    },
    // OTHERS
    set: function (val) {
      this._autoResize = val;
      if (val) {
        this._autoResizer.enable();
      } else {
        this._autoResizer.disable();
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "useResizeObserver", {
    /**
     * Whether to listen {@link https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver ResizeObserver}'s event instead of Window's {@link https://developer.mozilla.org/ko/docs/Web/API/Window/resize_event resize} event when using the `autoResize` option
     * @ko autoResize 옵션 사용시 {@link https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver ResizeObserver}의 이벤트를 Window객체의 {@link https://developer.mozilla.org/ko/docs/Web/API/Window/resize_event resize} 이벤트 대신 수신할지 여부를 설정합니다
     * @type {boolean}
     * @default true
     * @see {@link https://naver.github.io/egjs-flicking/Options#useresizeobserver useResizeObserver ( Options )}
     */
    get: function () {
      return this._useResizeObserver;
    },
    set: function (val) {
      this._useResizeObserver = val;
      if (this._autoResize) {
        this._autoResizer.enable();
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "resizeDebounce", {
    /**
     * Delays size recalculation from `autoResize` by the given time in milisecond.
     * If the size is changed again while being delayed, it cancels the previous one and delays from the beginning again.
     * This can increase performance by preventing `resize` being called too often.
     * @ko `autoResize` 설정시에 호출되는 크기 재계산을 주어진 시간(단위: ms)만큼 지연시킵니다.
     * 지연시키는 도중 크기가 다시 변경되었을 경우, 이전 것을 취소하고 주어진 시간만큼 다시 지연시킵니다.
     * 이를 통해 `resize`가 너무 많이 호출되는 것을 방지하여 성능을 향상시킬 수 있습니다.
     * @type {number}
     * @default 0
     * @see {@link https://naver.github.io/egjs-flicking/Options#resizedebounce resizeDebounce ( Options )}
     */
    get: function () {
      return this._resizeDebounce;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "maxResizeDebounce", {
    /**
     * The maximum time for size recalculation delay when using `resizeDebounce`, in milisecond.
     * This guarantees that size recalculation is performed at least once every (n)ms.
     * @ko `resizeDebounce` 사용시에 크기 재계산이 지연되는 최대 시간을 지정합니다. (단위: ms)
     * 이를 통해, 적어도 (n)ms에 한번은 크기 재계산을 수행하는 것을 보장할 수 있습니다.
     * @type {number}
     * @default 100
     * @see {@link https://naver.github.io/egjs-flicking/Options#maxresizedebounce maxResizeDebounce ( Options )}
     */
    get: function () {
      return this._maxResizeDebounce;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "useFractionalSize", {
    /**
     * By enabling this, Flicking will calculate all internal size with CSS width computed with getComputedStyle.
     * This can prevent 1px offset issue in some cases where panel size has the fractional part.
     * All sizes will have the original size before CSS {@link https://developer.mozilla.org/en-US/docs/Web/CSS/transform transform} is applied on the element.
     * @ko 이 옵션을 활성화할 경우, Flicking은 내부의 모든 크기를 {@link https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect getBoundingClientRect}를 이용하여 계산합니다.
     * 이를 통해, 패널 크기에 소수점을 포함할 경우에 발생할 수 있는 일부 1px 오프셋 이슈를 해결 가능합니다.
     * 모든 크기는 CSS {@link https://developer.mozilla.org/en-US/docs/Web/CSS/transform transform}이 엘리먼트에 적용되기 이전의 크기를 사용할 것입니다.
     * @type {boolean}
     * @default false
     * @see {@link https://naver.github.io/egjs-flicking/Options#usefractionalsize useFractionalSize ( Options )}
     */
    get: function () {
      return this._useFractionalSize;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "externalRenderer", {
    /**
     * This is an option for the frameworks(React, Vue, Angular, ...). Don't set it as it's automatically managed by Flicking.
     * @ko 프레임워크(React, Vue, Angular, ...)에서만 사용하는 옵션으로, 자동으로 설정되므로 따로 사용하실 필요 없습니다!
     * @default null
     * @internal
     * @readonly
     */
    get: function () {
      return this._externalRenderer;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "renderExternal", {
    /**
     * This is an option for the frameworks(React, Vue, Angular, ...). Don't set it as it's automatically managed by Flicking.
     * @ko 프레임워크(React, Vue, Angular, ...)에서만 사용하는 옵션으로, 자동으로 설정되므로 따로 사용하실 필요 없습니다!
     * @default null
     * @internal
     * @readonly
     * @deprecated
     */
    get: function () {
      return this._renderExternal;
    },
    enumerable: false,
    configurable: true
  });
  /**
   * Initialize Flicking and move to the default index
   * This is automatically called on Flicking's constructor when `autoInit` is true(default)
   * @ko Flicking을 초기화하고, 디폴트 인덱스로 이동합니다
   * 이 메소드는 `autoInit` 옵션이 true(default)일 경우 Flicking이 생성될 때 자동으로 호출됩니다
   * @fires Flicking#ready
   * @return {Promise<void>}
   */
  __proto.init = function () {
    var _this = this;
    if (this._initialized) return Promise.resolve();
    var camera = this._camera;
    var renderer = this._renderer;
    var control = this._control;
    var virtualManager = this._virtualManager;
    var originalTrigger = this.trigger;
    var preventEventsBeforeInit = this._preventEventsBeforeInit;
    camera.init();
    virtualManager.init();
    renderer.init(this);
    control.init(this);
    if (preventEventsBeforeInit) {
      this.trigger = function () {
        return _this;
      };
    }
    this._initialResize();
    // Look at initial panel
    this._moveToInitialPanel();
    if (this._autoResize) {
      this._autoResizer.enable();
    }
    if (this._preventClickOnDrag) {
      control.controller.addPreventClickHandler();
    }
    if (this._disableOnInit) {
      this.disableInput();
    }
    renderer.checkPanelContentsReady(renderer.panels);
    this._initialized = true;
    return renderer.render().then(function () {
      // Done initializing & emit ready event
      _this._plugins.forEach(function (plugin) {
        return plugin.init(_this);
      });
      if (preventEventsBeforeInit) {
        _this.trigger = originalTrigger;
      }
      _this.trigger(new ComponentEvent$1(EVENTS.READY));
    });
  };
  /**
   * Destroy Flicking and remove all event handlers
   * @ko Flicking과 하위 컴포넌트들을 초기 상태로 되돌리고, 부착된 모든 이벤트 핸들러를 제거합니다
   * @return {void}
   */
  __proto.destroy = function () {
    this.off();
    this._autoResizer.disable();
    this._control.destroy();
    this._camera.destroy();
    this._renderer.destroy();
    this._plugins.forEach(function (plugin) {
      return plugin.destroy();
    });
    this._initialized = false;
  };
  /**
   * Move to the previous panel (current index - 1)
   * @ko 이전 패널로 이동합니다 (현재 인덱스 - 1)
   * @param {number} [duration={@link Flicking#duration options.duration}] Duration of the panel movement animation (unit: ms)<ko>패널 이동 애니메이션 진행 시간 (단위: ms)</ko>
   * @async
   * @fires Flicking#moveStart
   * @fires Flicking#move
   * @fires Flicking#moveEnd
   * @fires Flicking#willChange
   * @fires Flicking#changed
   * @fires Flicking#willRestore
   * @fires Flicking#restored
   * @fires Flicking#needPanel
   * @fires Flicking#visibleChange
   * @fires Flicking#reachEdge
   * @throws {FlickingError}
   * |code|condition|
   * |---|---|
   * |{@link ERROR_CODE INDEX_OUT_OF_RANGE}|When the previous panel does not exist|
   * |{@link ERROR_CODE ANIMATION_ALREADY_PLAYING}|When the animation is already playing|
   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|When the animation is interrupted by user input|
   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|When the any of the event's `stop()` is called|
   * <ko>
   *
   * |code|condition|
   * |---|---|
   * |{@link ERROR_CODE INDEX_OUT_OF_RANGE}|이전 패널이 존재하지 않을 경우|
   * |{@link ERROR_CODE ANIMATION_ALREADY_PLAYING}|애니메이션이 이미 진행중인 경우|
   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|사용자 입력에 의해 애니메이션이 중단된 경우|
   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|발생된 이벤트들 중 하나라도 `stop()`이 호출된 경우|
   * </ko>
   * @return {Promise<void>} A Promise which will be resolved after reaching the previous panel<ko>이전 패널 도달시에 resolve되는 Promise</ko>
   */
  __proto.prev = function (duration) {
    var _a, _b, _c;
    if (duration === void 0) {
      duration = this._duration;
    }
    return this.moveTo((_c = (_b = (_a = this._control.activePanel) === null || _a === void 0 ? void 0 : _a.prev()) === null || _b === void 0 ? void 0 : _b.index) !== null && _c !== void 0 ? _c : -1, duration, DIRECTION.PREV);
  };
  /**
   * Move to the next panel (current index + 1)
   * @ko 다음 패널로 이동합니다 (현재 인덱스 + 1)
   * @param {number} [duration={@link Flicking#duration options.duration}] Duration of the panel movement animation (unit: ms).<ko>패널 이동 애니메이션 진행 시간 (단위: ms)</ko>
   * @async
   * @fires Flicking#moveStart
   * @fires Flicking#move
   * @fires Flicking#moveEnd
   * @fires Flicking#willChange
   * @fires Flicking#changed
   * @fires Flicking#willRestore
   * @fires Flicking#restored
   * @fires Flicking#needPanel
   * @fires Flicking#visibleChange
   * @fires Flicking#reachEdge
   * @throws {FlickingError}
   * |code|condition|
   * |---|---|
   * |{@link ERROR_CODE INDEX_OUT_OF_RANGE}|When the next panel does not exist|
   * |{@link ERROR_CODE ANIMATION_ALREADY_PLAYING}|When the animation is already playing|
   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|When the animation is interrupted by user input|
   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|When the any of the event's `stop()` is called|
   * <ko>
   *
   * |code|condition|
   * |---|---|
   * |{@link ERROR_CODE INDEX_OUT_OF_RANGE}|다음 패널이 존재하지 않을 경우|
   * |{@link ERROR_CODE ANIMATION_ALREADY_PLAYING}|애니메이션이 이미 진행중인 경우|
   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|사용자 입력에 의해 애니메이션이 중단된 경우|
   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|발생된 이벤트들 중 하나라도 `stop()`이 호출된 경우|
   *
   * </ko>
   * @return {Promise<void>} A Promise which will be resolved after reaching the next panel<ko>다음 패널 도달시에 resolve되는 Promise</ko>
   */
  __proto.next = function (duration) {
    var _a, _b, _c;
    if (duration === void 0) {
      duration = this._duration;
    }
    return this.moveTo((_c = (_b = (_a = this._control.activePanel) === null || _a === void 0 ? void 0 : _a.next()) === null || _b === void 0 ? void 0 : _b.index) !== null && _c !== void 0 ? _c : this._renderer.panelCount, duration, DIRECTION.NEXT);
  };
  /**
   * Move to the panel with given index
   * @ko 주어진 인덱스에 해당하는 패널로 이동합니다
   * @param {number} index The index of the panel to move<ko>이동할 패널의 인덱스</ko>
   * @param {number} [duration={@link Flicking#duration options.duration}] Duration of the animation (unit: ms)<ko>애니메이션 진행 시간 (단위: ms)</ko>
   * @param {DIRECTION} [direction=DIRECTION.NONE] Direction to move, only available in the {@link Flicking#circular circular} mode<ko>이동할 방향. {@link Flicking#circular circular} 옵션 활성화시에만 사용 가능합니다</ko>
   * @async
   * @fires Flicking#moveStart
   * @fires Flicking#move
   * @fires Flicking#moveEnd
   * @fires Flicking#willChange
   * @fires Flicking#changed
   * @fires Flicking#willRestore
   * @fires Flicking#restored
   * @fires Flicking#needPanel
   * @fires Flicking#visibleChange
   * @fires Flicking#reachEdge
   * @throws {FlickingError}
   * |code|condition|
   * |---|---|
   * |{@link ERROR_CODE INDEX_OUT_OF_RANGE}|When the root is not either string or HTMLElement|
   * |{@link ERROR_CODE ANIMATION_ALREADY_PLAYING}|When the animation is already playing|
   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|When the animation is interrupted by user input|
   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|When the any of the event's `stop()` is called|
   * <ko>
   *
   * |code|condition|
   * |---|---|
   * |{@link ERROR_CODE INDEX_OUT_OF_RANGE}|해당 인덱스를 가진 패널이 존재하지 않을 경우|
   * |{@link ERROR_CODE ANIMATION_ALREADY_PLAYING}|애니메이션이 이미 진행중인 경우|
   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|사용자 입력에 의해 애니메이션이 중단된 경우|
   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|발생된 이벤트들 중 하나라도 `stop()`이 호출된 경우|
   *
   * </ko>
   * @return {Promise<void>} A Promise which will be resolved after reaching the target panel<ko>해당 패널 도달시에 resolve되는 Promise</ko>
   */
  __proto.moveTo = function (index, duration, direction) {
    if (duration === void 0) {
      duration = this._duration;
    }
    if (direction === void 0) {
      direction = DIRECTION.NONE;
    }
    var renderer = this._renderer;
    var panelCount = renderer.panelCount;
    var panel = renderer.getPanel(index);
    if (!panel) {
      return Promise.reject(new FlickingError(MESSAGE.INDEX_OUT_OF_RANGE(index, 0, panelCount - 1), CODE.INDEX_OUT_OF_RANGE));
    }
    if (this._control.animating) {
      return Promise.reject(new FlickingError(MESSAGE.ANIMATION_ALREADY_PLAYING, CODE.ANIMATION_ALREADY_PLAYING));
    }
    if (this._control.holding) {
      this._control.controller.release();
    }
    return this._control.moveToPanel(panel, {
      duration: duration,
      direction: direction
    });
  };
  /**
   * Change the destination and duration of the animation currently playing
   * @ko 재생 중인 애니메이션의 목적지와 재생 시간을 변경합니다
   * @param {number} index The index of the panel to move<ko>이동할 패널의 인덱스</ko>
   * @param {number} duration Duration of the animation (unit: ms)<ko>애니메이션 진행 시간 (단위: ms)</ko>
   * @param {DIRECTION} direction Direction to move, only available in the {@link Flicking#circular circular} mode<ko>이동할 방향. {@link Flicking#circular circular} 옵션 활성화시에만 사용 가능합니다</ko>
   * @throws {FlickingError}
   * {@link ERROR_CODE INDEX_OUT_OF_RANGE} When the root is not either string or HTMLElement
   * <ko>{@link ERROR_CODE INDEX_OUT_OF_RANGE} 해당 인덱스를 가진 패널이 존재하지 않을 경우</ko>
   * @return {void}
   */
  __proto.updateAnimation = function (index, duration, direction) {
    if (!this._control.animating) {
      return;
    }
    var renderer = this._renderer;
    var panelCount = renderer.panelCount;
    var panel = renderer.getPanel(index);
    if (!panel) {
      throw new FlickingError(MESSAGE.INDEX_OUT_OF_RANGE(index, 0, panelCount - 1), CODE.INDEX_OUT_OF_RANGE);
    }
    this._control.updateAnimation(panel, duration, direction);
  };
  /**
   * Stops the animation currently playing
   * @ko 재생 중인 애니메이션을 중단시킵니다
   * @fires Flicking#moveEnd
   * @return {void}
   */
  __proto.stopAnimation = function () {
    if (!this._control.animating) {
      return;
    }
    this._control.stopAnimation();
  };
  /**
   * Return the {@link Panel} at the given index. `null` if it doesn't exists.
   * @ko 주어진 인덱스에 해당하는 {@link Panel}을 반환합니다. 주어진 인덱스에 해당하는 패널이 존재하지 않을 경우 `null`을 반환합니다.
   * @return {Panel | null} Panel at the given index<ko>주어진 인덱스에 해당하는 패널</ko>
   * @see Panel
   * @example
   * ```ts
   * const panel = flicking.getPanel(0);
   * // Which is a shorthand to...
   * const samePanel = flicking.panels[0];
   * ```
   */
  __proto.getPanel = function (index) {
    return this._renderer.getPanel(index);
  };
  /**
   * Enable input from the user (mouse/touch)
   * @ko 사용자의 입력(마우스/터치)를 활성화합니다
   * @return {this}
   */
  __proto.enableInput = function () {
    this._control.enable();
    return this;
  };
  /**
   * Disable input from the user (mouse/touch)
   * @ko 사용자의 입력(마우스/터치)를 막습니다
   * @return {this}
   */
  __proto.disableInput = function () {
    this._control.disable();
    return this;
  };
  /**
   * Get current flicking status. You can restore current state by giving returned value to {@link Flicking#setStatus setStatus()}
   * @ko 현재 상태를 반환합니다. 반환받은 값을 {@link Flicking#setStatus setStatus()} 메소드의 인자로 지정하면 현재 상태를 복원할 수 있습니다
   * @param {object} options Status retrieving options<ko>Status 반환 옵션</ko>
   * @param {boolean} [options.index=true] Include current panel index to the returning status. Camera will automatically move to the given index when the {@link Flicking#setStatus setStatus} is called<ko>현재 패널 인덱스를 반환값에 포함시킵니다. {@link Flicking#setStatus setStatus} 호출시 자동으로 해당 인덱스로 카메라를 움직입니다</ko>
   * @param {boolean} [options.position=true] Include camera position to the returning status. This works only when the {@link Flicking#moveType moveType} is `freeScroll`<ko>카메라의 현재 위치를 반환값에 포함시킵니다. 이 옵션은 {@link Flicking#moveType moveType}이 `freeScroll`일 경우에만 동작합니다</ko>
   * @param {boolean} [options.includePanelHTML=false] Include panel's `outerHTML` to the returning status<ko>패널의 `outerHTML`을 반환값에 포함시킵니다</ko>
   * @param {boolean} [options.visiblePanelsOnly=false] Include only {@link Flicking#visiblePanel visiblePanel}'s HTML. This option is available only when the `includePanelHTML` is true
   * <ko>현재 보이는 패널({@link Flicking#visiblePanel visiblePanel})의 HTML만 반환합니다. `includePanelHTML`이 `true`일 경우에만 동작합니다.</ko>
   * @return {Status} An object with current status value information<ko>현재 상태값 정보를 가진 객체.</ko>
   */
  __proto.getStatus = function (_a) {
    var _b, _c;
    var _d = _a === void 0 ? {} : _a,
      _e = _d.index,
      index = _e === void 0 ? true : _e,
      _f = _d.position,
      position = _f === void 0 ? true : _f,
      _g = _d.includePanelHTML,
      includePanelHTML = _g === void 0 ? false : _g,
      _h = _d.visiblePanelsOnly,
      visiblePanelsOnly = _h === void 0 ? false : _h;
    var camera = this._camera;
    var panels = visiblePanelsOnly ? this.visiblePanels : this.panels;
    var status = {
      panels: panels.map(function (panel) {
        var panelInfo = {
          index: panel.index
        };
        if (includePanelHTML) {
          panelInfo.html = panel.element.outerHTML;
        }
        return panelInfo;
      })
    };
    if (index) {
      status.index = this.index;
    }
    if (position) {
      var nearestAnchor = camera.findNearestAnchor(camera.position);
      if (nearestAnchor) {
        status.position = {
          panel: nearestAnchor.panel.index,
          progressInPanel: camera.getProgressInPanel(nearestAnchor.panel)
        };
      }
    }
    if (visiblePanelsOnly) {
      var visiblePanels = this.visiblePanels;
      status.visibleOffset = (_c = (_b = visiblePanels[0]) === null || _b === void 0 ? void 0 : _b.index) !== null && _c !== void 0 ? _c : 0;
    }
    return status;
  };
  /**
   * Restore to the state of the given {@link Status}
   * @ko 주어진 {@link Status}의 상태로 복원합니다
   * @param {Partial<Status>} status Status value to be restored. You should use the return value of the {@link Flicking#getStatus getStatus()} method<ko>복원할 상태 값. {@link Flicking#getStatus getStatus()} 메서드의 반환값을 지정하면 됩니다</ko>
   * @return {void}
   */
  __proto.setStatus = function (status) {
    var _a;
    if (!this._initialized) {
      throw new FlickingError(MESSAGE.NOT_INITIALIZED, CODE.NOT_INITIALIZED);
    }
    var index = status.index,
      position = status.position,
      visibleOffset = status.visibleOffset,
      panels = status.panels;
    var renderer = this._renderer;
    var control = this._control;
    // Can't add/remove panels on external rendering
    if (((_a = panels[0]) === null || _a === void 0 ? void 0 : _a.html) && !this._renderExternal) {
      renderer.batchRemove({
        index: 0,
        deleteCount: this.panels.length,
        hasDOMInElements: true
      });
      renderer.batchInsert({
        index: 0,
        elements: parseElement(panels.map(function (panel) {
          return panel.html;
        })),
        hasDOMInElements: true
      });
    }
    if (index != null) {
      var panelIndex = visibleOffset ? index - visibleOffset : index;
      void this.moveTo(panelIndex, 0).catch(function () {
        return void 0;
      });
    }
    if (position && this._moveType === MOVE_TYPE.FREE_SCROLL) {
      var panel = position.panel,
        progressInPanel = position.progressInPanel;
      var panelIndex = visibleOffset ? panel - visibleOffset : panel;
      var panelRange = renderer.panels[panelIndex].range;
      var newCameraPos = panelRange.min + (panelRange.max - panelRange.min) * progressInPanel;
      void control.moveToPosition(newCameraPos, 0).catch(function () {
        return void 0;
      });
    }
  };
  /**
   * Add plugins that can have different effects on Flicking
   * @ko 플리킹에 다양한 효과를 부여할 수 있는 플러그인을 추가합니다
   * @param {...Plugin} plugins The plugin(s) to add<ko>추가할 플러그인(들)</ko>
   * @return {this}
   * @see https://github.com/naver/egjs-flicking-plugins
   */
  __proto.addPlugins = function () {
    var _a;
    var _this = this;
    var plugins = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      plugins[_i] = arguments[_i];
    }
    if (this._initialized) {
      plugins.forEach(function (item) {
        return item.init(_this);
      });
    }
    (_a = this._plugins).push.apply(_a, __spread$1(plugins));
    return this;
  };
  /**
   * Remove plugins from Flicking.
   * @ko 플리킹으로부터 플러그인들을 제거합니다.
   * @param {...Plugin} plugin The plugin(s) to remove.<ko>제거 플러그인(들).</ko>
   * @return {this}
   * @see https://github.com/naver/egjs-flicking-plugins
   */
  __proto.removePlugins = function () {
    var _this = this;
    var plugins = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      plugins[_i] = arguments[_i];
    }
    plugins.forEach(function (item) {
      var foundIndex = findIndex(_this._plugins, function (val) {
        return val === item;
      });
      if (foundIndex >= 0) {
        item.destroy();
        _this._plugins.splice(foundIndex, 1);
      }
    });
    return this;
  };
  /**
   * Update viewport/panel sizes
   * @ko 패널 및 뷰포트의 크기를 갱신합니다
   * @method
   * @fires Flicking#beforeResize
   * @fires Flicking#afterResize
   * @return {this}
   */
  __proto.resize = function () {
    return __awaiter(this, void 0, void 0, function () {
      var viewport, renderer, camera, control, activePanel, prevWidth, prevHeight, prevProgressInPanel, newWidth, newHeight, sizeChanged;
      return __generator(this, function (_a) {
        switch (_a.label) {
          case 0:
            viewport = this._viewport;
            renderer = this._renderer;
            camera = this._camera;
            control = this._control;
            activePanel = control.activePanel;
            prevWidth = viewport.width;
            prevHeight = viewport.height;
            prevProgressInPanel = activePanel ? camera.getProgressInPanel(activePanel) : 0;
            this.trigger(new ComponentEvent$1(EVENTS.BEFORE_RESIZE, {
              width: prevWidth,
              height: prevHeight,
              element: viewport.element
            }));
            viewport.resize();
            return [4 /*yield*/, renderer.forceRenderAllPanels()];
          case 1:
            _a.sent(); // Render all panel elements, to update sizes
            if (!this._initialized) {
              return [2 /*return*/];
            }

            renderer.updatePanelSize();
            camera.updateAlignPos();
            camera.updateRange();
            camera.updateAnchors();
            camera.updateAdaptiveHeight();
            camera.updatePanelOrder();
            camera.updateOffset();
            return [4 /*yield*/, renderer.render()];
          case 2:
            _a.sent();
            if (!this._initialized) {
              return [2 /*return*/];
            }

            if (control.animating) ; else {
              control.updatePosition(prevProgressInPanel);
              control.updateInput();
            }
            newWidth = viewport.width;
            newHeight = viewport.height;
            sizeChanged = newWidth !== prevWidth || newHeight !== prevHeight;
            this.trigger(new ComponentEvent$1(EVENTS.AFTER_RESIZE, {
              width: viewport.width,
              height: viewport.height,
              prev: {
                width: prevWidth,
                height: prevHeight
              },
              sizeChanged: sizeChanged,
              element: viewport.element
            }));
            return [2 /*return*/];
        }
      });
    });
  };
  /**
   * Add new panels after the last panel
   * @ko 패널 목록의 제일 끝에 새로운 패널들을 추가합니다
   * @param {ElementLike | ElementLike[]} element A new HTMLElement, a outerHTML of element, or an array of both
   * <ko>새로운 HTMLElement, 혹은 엘리먼트의 outerHTML, 혹은 그것들의 배열</ko>
   * @return {Panel[]} An array of appended panels<ko>추가된 패널들의 배열</ko>
   * @see Panel
   * @see ElementLike
   * @throws {FlickingError} {@link ERROR_CODE ERROR_CODE.NOT_ALLOWED_IN_FRAMEWORK} if called on frameworks (React, Angular, Vue...)
   * @example
   * ```ts
   * const flicking = new Flicking("#flick");
   * // These are possible parameters
   * flicking.append(document.createElement("div"));
   * flicking.append("\<div\>Panel\</div\>");
   * flicking.append(["\<div\>Panel\</div\>", document.createElement("div")]);
   * // Even this is possible
   * flicking.append("\<div\>Panel 1\</div\>\<div\>Panel 2\</div\>");
   * ```
   */
  __proto.append = function (element) {
    return this.insert(this._renderer.panelCount, element);
  };
  /**
   * Add new panels before the first panel
   * This will increase index of panels after by the number of panels added
   * @ko 패널 목록의 제일 앞(index 0)에 새로운 패널들을 추가합니다
   * 추가한 패널의 개수만큼 기존 패널들의 인덱스가 증가합니다.
   * @param {ElementLike | ElementLike[]} element A new HTMLElement, a outerHTML of element, or an array of both
   * <ko>새로운 HTMLElement, 혹은 엘리먼트의 outerHTML, 혹은 그것들의 배열</ko>
   * @return {Panel[]} An array of prepended panels<ko>추가된 패널들의 배열</ko>
   * @see Panel
   * @see ElementLike
   * @throws {FlickingError} {@link ERROR_CODE ERROR_CODE.NOT_ALLOWED_IN_FRAMEWORK} if called on frameworks (React, Angular, Vue...)
   * @example
   * ```ts
   * const flicking = new eg.Flicking("#flick");
   * flicking.prepend(document.createElement("div"));
   * flicking.prepend("\<div\>Panel\</div\>");
   * flicking.prepend(["\<div\>Panel\</div\>", document.createElement("div")]);
   * // Even this is possible
   * flicking.prepend("\<div\>Panel 1\</div\>\<div\>Panel 2\</div\>");
   * ```
   */
  __proto.prepend = function (element) {
    return this.insert(0, element);
  };
  /**
   * Insert new panels at given index
   * This will increase index of panels after by the number of panels added
   * @ko 주어진 인덱스에 새로운 패널들을 추가합니다
   * 해당 인덱스보다 같거나 큰 인덱스를 가진 기존 패널들은 추가한 패널의 개수만큼 인덱스가 증가합니다.
   * @param {number} index Index to insert new panels at<ko>새로 패널들을 추가할 인덱스</ko>
   * @param {ElementLike | ElementLike[]} element A new HTMLElement, a outerHTML of element, or an array of both
   * <ko>새로운 HTMLElement, 혹은 엘리먼트의 outerHTML, 혹은 그것들의 배열</ko>
   * @return {Panel[]} An array of prepended panels<ko>추가된 패널들의 배열</ko>
   * @throws {FlickingError} {@link ERROR_CODE ERROR_CODE.NOT_ALLOWED_IN_FRAMEWORK} if called on frameworks (React, Angular, Vue...)
   * @example
   * ```ts
   * const flicking = new eg.Flicking("#flick");
   * flicking.insert(0, document.createElement("div"));
   * flicking.insert(2, "\<div\>Panel\</div\>");
   * flicking.insert(1, ["\<div\>Panel\</div\>", document.createElement("div")]);
   * // Even this is possible
   * flicking.insert(3, "\<div\>Panel 1\</div\>\<div\>Panel 2\</div\>");
   * ```
   */
  __proto.insert = function (index, element) {
    if (this._renderExternal) {
      throw new FlickingError(MESSAGE.NOT_ALLOWED_IN_FRAMEWORK, CODE.NOT_ALLOWED_IN_FRAMEWORK);
    }
    return this._renderer.batchInsert({
      index: index,
      elements: parseElement(element),
      hasDOMInElements: true
    });
  };
  /**
   * Remove the panel at the given index
   * This will decrease index of panels after by the number of panels removed
   * @ko 주어진 인덱스의 패널을 제거합니다
   * 해당 인덱스보다 큰 인덱스를 가진 기존 패널들은 제거한 패널의 개수만큼 인덱스가 감소합니다
   * @param {number} index Index of panel to remove<ko>제거할 패널의 인덱스</ko>
   * @param {number} [deleteCount=1] Number of panels to remove from index<ko>`index` 이후로 제거할 패널의 개수</ko>
   * @return {Panel[]} An array of removed panels<ko>제거된 패널들의 배열</ko>
   */
  __proto.remove = function (index, deleteCount) {
    if (deleteCount === void 0) {
      deleteCount = 1;
    }
    if (this._renderExternal) {
      throw new FlickingError(MESSAGE.NOT_ALLOWED_IN_FRAMEWORK, CODE.NOT_ALLOWED_IN_FRAMEWORK);
    }
    return this._renderer.batchRemove({
      index: index,
      deleteCount: deleteCount,
      hasDOMInElements: true
    });
  };
  __proto._createControl = function () {
    var _a;
    var moveType = this._moveType;
    var moveTypes = Object.keys(MOVE_TYPE).map(function (key) {
      return MOVE_TYPE[key];
    });
    var moveTypeStr = Array.isArray(moveType) ? moveType[0] : moveType;
    var moveTypeOptions = Array.isArray(moveType) ? (_a = moveType[1]) !== null && _a !== void 0 ? _a : {} : {};
    if (!includes(moveTypes, moveTypeStr)) {
      throw new FlickingError(MESSAGE.WRONG_OPTION("moveType", JSON.stringify(moveType)), CODE.WRONG_OPTION);
    }
    switch (moveTypeStr) {
      case MOVE_TYPE.SNAP:
        return new SnapControl(moveTypeOptions);
      case MOVE_TYPE.FREE_SCROLL:
        return new FreeControl(moveTypeOptions);
      case MOVE_TYPE.STRICT:
        return new StrictControl(moveTypeOptions);
    }
  };
  __proto._createCamera = function () {
    if (this._circular && this._bound) {
      // eslint-disable-next-line no-console
      console.warn("\"circular\" and \"bound\" option cannot be used together, ignoring bound.");
    }
    return new Camera(this, {
      align: this._align
    });
  };
  __proto._createRenderer = function () {
    var externalRenderer = this._externalRenderer;
    if (this._virtual && this._panelsPerView <= 0) {
      // eslint-disable-next-line no-console
      console.warn("\"virtual\" and \"panelsPerView\" option should be used together, ignoring virtual.");
    }
    return externalRenderer ? externalRenderer : this._renderExternal ? this._createExternalRenderer() : this._createVanillaRenderer();
  };
  __proto._createExternalRenderer = function () {
    var _a = this._renderExternal,
      renderer = _a.renderer,
      rendererOptions = _a.rendererOptions;
    return new renderer(__assign$2({
      align: this._align
    }, rendererOptions));
  };
  __proto._createVanillaRenderer = function () {
    var virtual = this.virtualEnabled;
    return new VanillaRenderer({
      align: this._align,
      strategy: virtual ? new VirtualRenderingStrategy() : new NormalRenderingStrategy({
        providerCtor: VanillaElementProvider
      })
    });
  };
  __proto._moveToInitialPanel = function () {
    var renderer = this._renderer;
    var control = this._control;
    var camera = this._camera;
    var defaultPanel = renderer.getPanel(this._defaultIndex) || renderer.getPanel(0);
    if (!defaultPanel) return;
    var nearestAnchor = camera.findNearestAnchor(defaultPanel.position);
    var initialPanel = nearestAnchor && defaultPanel.index !== nearestAnchor.panel.index ? nearestAnchor.panel : defaultPanel;
    control.setActive(initialPanel, null, false);
    if (!nearestAnchor) {
      throw new FlickingError(MESSAGE.POSITION_NOT_REACHABLE(initialPanel.position), CODE.POSITION_NOT_REACHABLE);
    }
    var position = initialPanel.position;
    if (!camera.canReach(initialPanel)) {
      position = nearestAnchor.position;
    }
    camera.lookAt(position);
    control.updateInput();
    camera.updateOffset();
  };
  __proto._initialResize = function () {
    var viewport = this._viewport;
    var renderer = this._renderer;
    var camera = this._camera;
    var control = this._control;
    this.trigger(new ComponentEvent$1(EVENTS.BEFORE_RESIZE, {
      width: 0,
      height: 0,
      element: viewport.element
    }));
    viewport.resize();
    renderer.updatePanelSize();
    camera.updateAlignPos();
    camera.updateRange();
    camera.updateAnchors();
    camera.updateOffset();
    control.updateInput();
    var newWidth = viewport.width;
    var newHeight = viewport.height;
    var sizeChanged = newWidth !== 0 || newHeight !== 0;
    this.trigger(new ComponentEvent$1(EVENTS.AFTER_RESIZE, {
      width: viewport.width,
      height: viewport.height,
      prev: {
        width: 0,
        height: 0
      },
      sizeChanged: sizeChanged,
      element: viewport.element
    }));
  };
  /**
   * Version info string
   * @ko 버전정보 문자열
   * @type {string}
   * @readonly
   * @example
   * ```ts
   * Flicking.VERSION;  // ex) 4.0.0
   * ```
   */
  Flicking.VERSION = "4.11.4";
  return Flicking;
}(Component);

/**
 * Decorator that makes the method of flicking available in the framework.
 * @ko 프레임워크에서 플리킹의 메소드를 사용할 수 있게 하는 데코레이터.
 * @memberof eg.Flicking
 * @private
 * @example
 * ```js
 * import Flicking, { withFlickingMethods } from "@egjs/flicking";
 *
 * class Flicking extends React.Component<Partial<FlickingProps & FlickingOptions>> {
 *   &#64;withFlickingMethods
 *   private flicking: Flicking;
 * }
 * ```
 */
var withFlickingMethods = function (prototype, flickingName) {
  [Component.prototype, Flicking.prototype].forEach(function (proto) {
    Object.getOwnPropertyNames(proto).filter(function (name) {
      return !prototype[name] && name.indexOf("_") !== 0 && name !== "constructor";
    }).forEach(function (name) {
      var descriptor = Object.getOwnPropertyDescriptor(proto, name);
      if (descriptor.value) {
        // Public Function
        Object.defineProperty(prototype, name, {
          value: function () {
            var _a;
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            return (_a = descriptor.value).call.apply(_a, __spread$1([this[flickingName]], args));
          }
        });
      } else {
        var getterDescriptor = {};
        if (descriptor.get) {
          getterDescriptor.get = function () {
            var _a;
            var flicking = this[flickingName];
            return flicking && ((_a = descriptor.get) === null || _a === void 0 ? void 0 : _a.call(flicking));
          };
        }
        if (descriptor.set) {
          getterDescriptor.set = function () {
            var _a;
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            return (_a = descriptor.set) === null || _a === void 0 ? void 0 : _a.call.apply(_a, __spread$1([this[flickingName]], args));
          };
        }
        Object.defineProperty(prototype, name, getterDescriptor);
      }
    });
  });
};

var sync = (function (flicking, diffResult, rendered) {
  var renderer = flicking.renderer;
  var panels = renderer.panels;
  var prevList = __spread$1(diffResult.prevList);
  var added = [];
  var removed = [];
  if (diffResult.removed.length > 0) {
    var endIdx_1 = -1;
    var prevIdx_1 = -1;
    diffResult.removed.forEach(function (removedIdx) {
      if (endIdx_1 < 0) {
        endIdx_1 = removedIdx;
      }
      if (prevIdx_1 >= 0 && removedIdx !== prevIdx_1 - 1) {
        removed.push.apply(removed, __spread$1(batchRemove(renderer, prevIdx_1, endIdx_1 + 1)));
        endIdx_1 = removedIdx;
        prevIdx_1 = removedIdx;
      } else {
        prevIdx_1 = removedIdx;
      }
      prevList.splice(removedIdx, 1);
    });
    removed.push.apply(removed, __spread$1(batchRemove(renderer, prevIdx_1, endIdx_1 + 1)));
  }
  diffResult.ordered.forEach(function (_a) {
    var _b = __read$1(_a, 2),
      from = _b[0],
      to = _b[1];
    var prevPanel = panels.splice(from, 1)[0];
    panels.splice(to, 0, prevPanel);
  });
  if (diffResult.ordered.length > 0) {
    panels.forEach(function (panel, idx) {
      var indexDiff = idx - panel.index;
      if (indexDiff > 0) {
        panel.increaseIndex(indexDiff);
      } else {
        panel.decreaseIndex(-indexDiff);
      }
    });
    panels.sort(function (panel1, panel2) {
      return panel1.index - panel2.index;
    });
    panels.forEach(function (panel) {
      panel.updatePosition();
    });
  }
  if (diffResult.added.length > 0) {
    var startIdx_1 = -1;
    var prevIdx_2 = -1;
    var addedElements_1 = rendered.slice(prevList.length);
    diffResult.added.forEach(function (addedIdx, idx) {
      if (startIdx_1 < 0) {
        startIdx_1 = idx;
      }
      if (prevIdx_2 >= 0 && addedIdx !== prevIdx_2 + 1) {
        added.push.apply(added, __spread$1(batchInsert(renderer, diffResult, addedElements_1, startIdx_1, idx + 1)));
        startIdx_1 = -1;
        prevIdx_2 = -1;
      } else {
        prevIdx_2 = addedIdx;
      }
    });
    if (startIdx_1 >= 0) {
      added.push.apply(added, __spread$1(batchInsert(renderer, diffResult, addedElements_1, startIdx_1)));
    }
  }
  if (diffResult.added.length > 0 || diffResult.removed.length > 0) {
    renderer.updateAfterPanelChange(added, removed);
  }
});
var batchInsert = function (renderer, diffResult, addedElements, startIdx, endIdx) {
  return renderer.batchInsertDefer.apply(renderer, __spread$1(diffResult.added.slice(startIdx, endIdx).map(function (index, elIdx) {
    return {
      index: index,
      elements: [addedElements[elIdx]],
      hasDOMInElements: false
    };
  })));
};
var batchRemove = function (renderer, startIdx, endIdx) {
  var removed = renderer.panels.slice(startIdx, endIdx);
  return renderer.batchRemoveDefer({
    index: startIdx,
    deleteCount: removed.length,
    hasDOMInElements: false
  });
};

var getRenderingPanels = (function (flicking, diffResult) {
  var removedPanels = diffResult.removed.reduce(function (map, idx) {
    map[idx] = true;
    return map;
  }, {});
  var maintainedMap = diffResult.maintained.reduce(function (map, _a) {
    var _b = __read$1(_a, 2),
      prev = _b[0],
      current = _b[1];
    map[prev] = current;
    return map;
  }, {});
  return __spread$1(flicking.panels.filter(function (panel) {
    return !removedPanels[panel.index];
  })
  // Sort panels by position
  .sort(function (panel1, panel2) {
    return panel1.position + panel1.offset - (panel2.position + panel2.offset);
  }).map(function (panel) {
    return diffResult.list[maintainedMap[panel.index]];
  }), diffResult.added.map(function (idx) {
    return diffResult.list[idx];
  }));
});

var getDefaultCameraTransform = (function (align, horizontal, firstPanelSize) {
  if (align === void 0) {
    align = ALIGN.CENTER;
  }
  if (horizontal === void 0) {
    horizontal = true;
  }
  var cameraAlign = getCameraAlign(align);
  var panelAlign = getPanelAlign(align);
  if (panelAlign == null) return "";
  var camPosition = "calc(" + cameraAlign + " - (" + (firstPanelSize || "0px") + " * " + panelAlign.percentage + ") - " + panelAlign.absolute + "px)";
  return horizontal ? "translate(" + camPosition + ")" : "translate(0, " + camPosition + ")";
});
var getCameraAlign = function (align) {
  var alignVal = typeof align === "object" ? align.camera : align;
  return parseAlign(alignVal);
};
var getPanelAlign = function (align) {
  var alignVal = typeof align === "object" ? align.panel : align;
  return parseArithmeticExpression(parseAlign(alignVal));
};
var parseAlign = function (alignVal) {
  if (typeof alignVal === "number") {
    return alignVal + "px";
  }
  switch (alignVal) {
    case ALIGN.CENTER:
      return "50%";
    case ALIGN.NEXT:
      return "100%";
    case ALIGN.PREV:
      return "0%";
    default:
      return alignVal;
  }
};

/*
Copyright (c) 2015-present NAVER Corp.
name: @egjs/react-flicking
license: MIT
author: NAVER Corp.
repository: https://github.com/naver/egjs-flicking/tree/master/packages/react-flicking
version: 4.11.4
*/

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics$4 = function (d, b) {
  extendStatics$4 = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
  };
  return extendStatics$4(d, b);
};
function __extends$4(d, b) {
  if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics$4(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign$3 = function () {
  __assign$3 = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign$3.apply(this, arguments);
};
function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
}
function __decorate$1(decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __awaiter$1(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator$1(thisArg, body) {
  var _ = {
      label: 0,
      sent: function () {
        if (t[0] & 1) throw t[1];
        return t[1];
      },
      trys: [],
      ops: []
    },
    f,
    y,
    t,
    g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;
  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return {
            value: op[1],
            done: false
          };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}

var DEFAULT_PROPS = {
  viewportTag: "div",
  cameraTag: "div",
  cameraClass: "",
  renderOnSameKey: false,
  plugins: [],
  useFindDOMNode: false,
  hideBeforeInit: false,
  onReady: function (e) {},
  onBeforeResize: function (e) {},
  onAfterResize: function (e) {},
  onHoldStart: function (e) {},
  onHoldEnd: function (e) {},
  onMoveStart: function (e) {},
  onMove: function (e) {},
  onMoveEnd: function (e) {},
  onWillChange: function (e) {},
  onChanged: function (e) {},
  onWillRestore: function (e) {},
  onRestored: function (e) {},
  onSelect: function (e) {},
  onNeedPanel: function (e) {},
  onVisibleChange: function (e) {},
  onReachEdge: function (e) {},
  onPanelChange: function (e) {}
};

var ReactRenderer = /*#__PURE__*/function (_super) {
  __extends$4(ReactRenderer, _super);
  function ReactRenderer(options) {
    var _this = _super.call(this, options) || this;
    _this._reactFlicking = options.reactFlicking;
    return _this;
  }
  // eslint-disable-next-line @typescript-eslint/require-await
  var __proto = ReactRenderer.prototype;
  __proto.render = function () {
    return __awaiter$1(this, void 0, void 0, function () {
      var flicking, reactFlicking, strategy;
      var _this = this;
      return __generator$1(this, function (_a) {
        flicking = getFlickingAttached(this._flicking);
        reactFlicking = this._reactFlicking;
        strategy = this._strategy;
        this._rendering = true;
        strategy.updateRenderingPanels(flicking);
        strategy.renderPanels(flicking);
        return [2 /*return*/, new Promise(function (resolve) {
          reactFlicking.renderEmitter.once("render", function () {
            _this._rendering = false;
            _this._afterRender();
            resolve();
          });
          reactFlicking.forceUpdate();
        })];
      });
    });
  };
  __proto.forceRenderAllPanels = function () {
    return __awaiter$1(this, void 0, void 0, function () {
      var reactFlicking;
      var _this = this;
      return __generator$1(this, function (_a) {
        switch (_a.label) {
          case 0:
            reactFlicking = this._reactFlicking;
            this._rendering = true;
            return [4 /*yield*/, _super.prototype.forceRenderAllPanels.call(this)];
          case 1:
            _a.sent();
            return [2 /*return*/, new Promise(function (resolve) {
              reactFlicking.renderEmitter.once("render", function () {
                _this._rendering = false;
                resolve();
              });
              reactFlicking.forceUpdate();
            })];
        }
      });
    });
  };
  __proto.destroy = function () {
    _super.prototype.destroy.call(this);
    this._reactFlicking.renderEmitter.off("render");
  };
  __proto._collectPanels = function () {
    var flicking = getFlickingAttached(this._flicking);
    var reactFlicking = this._reactFlicking;
    var reactPanels = reactFlicking.reactPanels;
    this._panels = this._strategy.collectPanels(flicking, reactPanels);
  };
  __proto._createPanel = function (externalComponent, options) {
    return this._strategy.createPanel(externalComponent, options);
  };
  return ReactRenderer;
}(ExternalRenderer);

var StrictPanel = /*#__PURE__*/function (_super) {
  __extends$4(StrictPanel, _super);
  function StrictPanel() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._hide = false;
    _this._elRef = (0,preact__WEBPACK_IMPORTED_MODULE_0__.createRef)();
    return _this;
  }
  var __proto = StrictPanel.prototype;
  Object.defineProperty(__proto, "nativeElement", {
    get: function () {
      return this._elRef.current;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "rendered", {
    get: function () {
      return !this._hide;
    },
    enumerable: false,
    configurable: true
  });
  __proto.render = function () {
    return this._hide ? (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(preact__WEBPACK_IMPORTED_MODULE_0__.Fragment, null) : this._getElement();
  };
  __proto.show = function () {
    this._hide = false;
  };
  __proto.hide = function () {
    this._hide = true;
  };
  __proto._getElement = function () {
    return rn(k$1.only(this.props.children), {
      ref: this._elRef
    });
  };
  return StrictPanel;
}(preact__WEBPACK_IMPORTED_MODULE_0__.Component);

var NonStrictPanel = /*#__PURE__*/function (_super) {
  __extends$4(NonStrictPanel, _super);
  function NonStrictPanel() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._hide = false;
    return _this;
  }
  var __proto = NonStrictPanel.prototype;
  Object.defineProperty(__proto, "nativeElement", {
    get: function () {
      return on(this);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "rendered", {
    get: function () {
      return !this._hide;
    },
    enumerable: false,
    configurable: true
  });
  __proto.render = function () {
    return this._hide ? (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(preact__WEBPACK_IMPORTED_MODULE_0__.Fragment, null) : this.props.children;
  };
  __proto.show = function () {
    this._hide = false;
  };
  __proto.hide = function () {
    this._hide = true;
  };
  return NonStrictPanel;
}(preact__WEBPACK_IMPORTED_MODULE_0__.Component);

/*
 * Copyright (c) 2015 NAVER Corp.
 * egjs projects are licensed under the MIT license
 */
var ViewportSlot = React__default.memo(function (props) {
  return React__default.createElement(React__default.Fragment, null, props.children);
});

var ReactElementProvider = /*#__PURE__*/function () {
  function ReactElementProvider(el) {
    this._el = el;
  }
  var __proto = ReactElementProvider.prototype;
  Object.defineProperty(__proto, "element", {
    get: function () {
      return this._el.nativeElement;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "rendered", {
    get: function () {
      return this._el.rendered;
    },
    enumerable: false,
    configurable: true
  });
  __proto.show = function () {
    this._el.show();
  };
  __proto.hide = function () {
    this._el.hide();
  };
  return ReactElementProvider;
}();

var Flicking$1 = /*#__PURE__*/function (_super) {
  __extends$4(Flicking$1, _super);
  function Flicking$1(props) {
    var _this = _super.call(this, props) || this;
    _this._panels = [];
    _this._renderEmitter = new Component();
    var children = _this._getChildren();
    _this._panels = _this._createPanelRefs(props, children);
    _this._prevChildren = children;
    return _this;
  }
  var __proto = Flicking$1.prototype;
  Object.defineProperty(__proto, "reactPanels", {
    get: function () {
      return this._panels.map(function (panel) {
        return panel.current;
      });
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "renderEmitter", {
    get: function () {
      return this._renderEmitter;
    },
    enumerable: false,
    configurable: true
  });
  __proto.componentDidMount = function () {
    var props = this.props;
    var rendererOptions = {
      reactFlicking: this,
      align: props.align,
      strategy: props.virtual && props.panelsPerView > 0 ? new VirtualRenderingStrategy() : new NormalRenderingStrategy({
        providerCtor: ReactElementProvider
      })
    };
    var flicking = new Flicking(this._viewportElement, __assign$3(__assign$3({}, props), {
      externalRenderer: new ReactRenderer(rendererOptions)
    }));
    this._vanillaFlicking = flicking;
    var children = this._getChildren();
    this._jsxDiffer = new ListDiffer(children, function (panel) {
      return panel.key;
    });
    this._pluginsDiffer = new ListDiffer();
    this._prevChildren = children;
    this._bindEvents();
    this._checkPlugins();
    if (props.status) {
      flicking.setStatus(props.status);
    }
  };
  __proto.componentWillUnmount = function () {
    var _a;
    (_a = this._vanillaFlicking) === null || _a === void 0 ? void 0 : _a.destroy();
  };
  __proto.shouldComponentUpdate = function (nextProps) {
    var vanillaFlicking = this._vanillaFlicking;
    var prevProps = this.props;
    if (!vanillaFlicking || !vanillaFlicking.initialized) return false;
    var children = nextProps.children,
      restProps = __rest(nextProps, ["children"]);
    for (var key in restProps) {
      if (prevProps[key] !== nextProps[key]) {
        return true;
      }
    }
    var prevChildren = this._prevChildren;
    var nextChildren = this._getChildren(children);
    if (nextProps.renderOnSameKey || !this._hasSameChildren(prevChildren, nextChildren)) return true;
    return false;
  };
  __proto.beforeRender = function () {
    var vanillaFlicking = this._vanillaFlicking;
    var props = this.props;
    var prevChildren = this._prevChildren;
    // Ignore updates before init, they will be updated after "ready" event's force update
    // Also, prevent updates when another update is already queued.
    // This usually happens when render() called twice without calling componentDidMount, like in the case of React.StrictMode.
    if (!vanillaFlicking || !vanillaFlicking.initialized || this._diffResult) return;
    var nextChildren = this._getChildren(props.children);
    if (props.renderOnSameKey || !this._hasSameChildren(prevChildren, nextChildren)) {
      this._panels = this._createPanelRefs(props, nextChildren);
      this._diffResult = this._jsxDiffer.update(nextChildren);
      this._prevChildren = nextChildren;
    }
  };
  __proto.componentDidUpdate = function () {
    var flicking = this._vanillaFlicking;
    var renderEmitter = this._renderEmitter;
    var diffResult = this._diffResult;
    this._checkPlugins();
    renderEmitter.trigger("render");
    flicking.camera.updateOffset();
    // Omit 'virtual', as it can't have any setter
    var _a = this.props;
      _a.virtual;
      var props = __rest(_a, ["virtual"]);
    for (var key in props) {
      if (key in flicking && flicking[key] !== props[key]) {
        flicking[key] = props[key];
      }
    }
    if (!diffResult || !flicking.initialized) return;
    sync(flicking, diffResult, this.reactPanels);
    this._diffResult = null;
  };
  __proto.render = function () {
    var _this = this;
    var _a, _b;
    var props = this.props;
    var Viewport = props.viewportTag;
    var Camera = props.cameraTag;
    var attributes = {};
    var flicking = this._vanillaFlicking;
    this.beforeRender();
    for (var name in props) {
      if (!(name in DEFAULT_PROPS) && !(name in Flicking.prototype)) {
        attributes[name] = props[name];
      }
    }
    var initialized = flicking && flicking.initialized;
    var viewportClasses = ["flicking-viewport"];
    var cameraClasses = ["flicking-camera"];
    var isHorizontal = flicking ? flicking.horizontal : (_a = props.horizontal) !== null && _a !== void 0 ? _a : true;
    if (!isHorizontal) {
      viewportClasses.push("vertical");
    }
    if (props.hideBeforeInit && !initialized) {
      viewportClasses.push("flicking-hidden");
    }
    if (attributes.className) {
      viewportClasses.push(attributes.className);
    }
    if (props.cameraClass) {
      cameraClasses.push(props.cameraClass);
    }
    var cameraProps = !initialized && props.firstPanelSize ? {
      style: {
        transform: getDefaultCameraTransform(this.props.align, this.props.horizontal, this.props.firstPanelSize)
      }
    } : {};
    var panels = !!props.virtual && ((_b = props.panelsPerView) !== null && _b !== void 0 ? _b : -1) > 0 ? this._getVirtualPanels() : this._getPanels();
    return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(Viewport, __assign$3({}, attributes, {
      className: viewportClasses.join(" "),
      ref: function (e) {
        e && (_this._viewportElement = e);
      }
    }), (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(Camera, __assign$3({
      className: cameraClasses.join(" ")
    }, cameraProps), panels), this._getViewportSlot());
  };
  __proto._createPanelRefs = function (props, children) {
    var _a;
    var panelsPerView = (_a = props.panelsPerView) !== null && _a !== void 0 ? _a : -1;
    return panelsPerView > 0 && !!props.virtual ? range(panelsPerView + 1).map(function () {
      return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createRef)();
    }) : children.map(function () {
      return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createRef)();
    });
  };
  __proto._bindEvents = function () {
    var _this = this;
    var flicking = this._vanillaFlicking;
    Object.keys(EVENTS).forEach(function (eventKey) {
      var eventName = EVENTS[eventKey];
      var propName = "on".concat(eventName.charAt(0).toUpperCase() + eventName.slice(1));
      flicking.on(eventName, function (e) {
        e.currentTarget = _this;
        var evtHandler = _this.props[propName];
        evtHandler(e);
      });
    });
    flicking.once(EVENTS.READY, function () {
      _this.forceUpdate();
    });
  };
  __proto._checkPlugins = function () {
    var flicking = this._vanillaFlicking;
    var _a = this._pluginsDiffer.update(this.props.plugins),
      list = _a.list,
      added = _a.added,
      removed = _a.removed,
      prevList = _a.prevList;
    flicking.addPlugins.apply(flicking, added.map(function (index) {
      return list[index];
    }));
    flicking.removePlugins.apply(flicking, removed.map(function (index) {
      return prevList[index];
    }));
  };
  __proto._hasSameChildren = function (prevChildren, nextChildren) {
    if (prevChildren.length !== nextChildren.length || prevChildren.length === 0) return false;
    var same = prevChildren.every(function (child, idx) {
      var nextChild = nextChildren[idx];
      if (child.key && nextChild.key) {
        return child.key === nextChild.key;
      } else {
        return child === nextChild;
      }
    });
    return same;
  };
  __proto._getChildren = function (children) {
    var _this = this;
    if (children === void 0) {
      children = this.props.children;
    }
    return k$1.toArray(children).filter(function (child) {
      return child.type !== ViewportSlot;
    }).reduce(function (all, child) {
      return __spreadArray(__spreadArray([], all, true), _this._unpackFragment(child), true);
    }, []);
  };
  __proto._getViewportSlot = function () {
    return k$1.toArray(this.props.children).filter(function (child) {
      return child.type === ViewportSlot;
    });
  };
  __proto._unpackFragment = function (child) {
    var _this = this;
    return this._isFragment(child) ? k$1.toArray(child.props.children).reduce(function (allChilds, fragChild) {
      return __spreadArray(__spreadArray([], allChilds, true), _this._unpackFragment(fragChild), true);
    }, []) : [child];
  };
  __proto._getVirtualPanels = function () {
    var _this = this;
    var _a = this.props.virtual.panelClass,
      panelClass = _a === void 0 ? "flicking-panel" : _a;
    var panelsPerView = this.props.panelsPerView;
    var flicking = this._vanillaFlicking;
    var initialized = flicking && flicking.initialized;
    var renderingIndexes = initialized ? flicking.renderer.strategy.getRenderingIndexesByOrder(flicking) : range(panelsPerView + 1);
    var firstPanel = flicking && flicking.panels[0];
    var size = firstPanel ? flicking.horizontal ? {
      width: firstPanel.size
    } : {
      height: firstPanel.size
    } : {};
    return renderingIndexes.map(function (idx) {
      return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)("div", {
        key: idx,
        "data-element-index": idx,
        ref: _this._panels[idx],
        className: panelClass,
        style: size
      });
    });
  };
  __proto._getPanels = function () {
    var _this = this;
    var origChildren = this._getChildren();
    var vanillaFlicking = this._vanillaFlicking;
    var diffResult = this._diffResult;
    var children = vanillaFlicking && vanillaFlicking.initialized ? diffResult ? getRenderingPanels(vanillaFlicking, diffResult) : getRenderingPanels(vanillaFlicking, diff(origChildren, origChildren)) : origChildren;
    return this.props.useFindDOMNode ? children.map(function (child, idx) {
      return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(NonStrictPanel, {
        key: child.key,
        ref: _this._panels[idx]
      }, child);
    }) : children.map(function (child, idx) {
      return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(StrictPanel, {
        key: child.key,
        ref: _this._panels[idx]
      }, child);
    });
  };
  __proto._isFragment = function (child) {
    if (child.type) {
      return child.type === preact__WEBPACK_IMPORTED_MODULE_0__.Fragment;
    }
    return child === preact__WEBPACK_IMPORTED_MODULE_0__.Fragment;
  };
  Flicking$1.defaultProps = DEFAULT_PROPS;
  __decorate$1([withFlickingMethods], Flicking$1.prototype, "_vanillaFlicking", void 0);
  return Flicking$1;
}(preact__WEBPACK_IMPORTED_MODULE_0__.Component);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Flicking$1);



/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js!./app/static/pages/globals.css":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js!./app/static/pages/globals.css ***!
  \**********************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../node_modules/css-loader/dist/runtime/getUrl.js */ "./node_modules/css-loader/dist/runtime/getUrl.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__);
// Imports



var ___CSS_LOADER_URL_IMPORT_0___ = new URL(/* asset import */ __webpack_require__(/*! ../assets/mobile/icon-hamburger.svg */ "./app/static/assets/mobile/icon-hamburger.svg"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_1___ = new URL(/* asset import */ __webpack_require__(/*! ../assets/mobile/icon-cross.svg */ "./app/static/assets/mobile/icon-cross.svg"), __webpack_require__.b);
var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
var ___CSS_LOADER_URL_REPLACEMENT_0___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_0___);
var ___CSS_LOADER_URL_REPLACEMENT_1___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_1___);
// Module
___CSS_LOADER_EXPORT___.push([module.id, `/*
! tailwindcss v3.4.7 | MIT License | https://tailwindcss.com
*//*
1. Prevent padding and border from affecting element width. (https://github.com/mozdevs/cssremedy/issues/4)
2. Allow adding a border to an element by just adding a border-width. (https://github.com/tailwindcss/tailwindcss/pull/116)
*/

*,
::before,
::after {
  box-sizing: border-box; /* 1 */
  border-width: 0; /* 2 */
  border-style: solid; /* 2 */
  border-color: #e5e7eb; /* 2 */
}

::before,
::after {
  --tw-content: '';
}

/*
1. Use a consistent sensible line-height in all browsers.
2. Prevent adjustments of font size after orientation changes in iOS.
3. Use a more readable tab size.
4. Use the user's configured \`sans\` font-family by default.
5. Use the user's configured \`sans\` font-feature-settings by default.
6. Use the user's configured \`sans\` font-variation-settings by default.
7. Disable tap highlights on iOS
*/

html,
:host {
  line-height: 1.5; /* 1 */
  -webkit-text-size-adjust: 100%; /* 2 */
  -moz-tab-size: 4; /* 3 */
  -o-tab-size: 4;
     tab-size: 4; /* 3 */
  font-family: ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji"; /* 4 */
  font-feature-settings: normal; /* 5 */
  font-variation-settings: normal; /* 6 */
  -webkit-tap-highlight-color: transparent; /* 7 */
}

/*
1. Remove the margin in all browsers.
2. Inherit line-height from \`html\` so users can set them as a class directly on the \`html\` element.
*/

body {
  margin: 0; /* 1 */
  line-height: inherit; /* 2 */
}

/*
1. Add the correct height in Firefox.
2. Correct the inheritance of border color in Firefox. (https://bugzilla.mozilla.org/show_bug.cgi?id=190655)
3. Ensure horizontal rules are visible by default.
*/

hr {
  height: 0; /* 1 */
  color: inherit; /* 2 */
  border-top-width: 1px; /* 3 */
}

/*
Add the correct text decoration in Chrome, Edge, and Safari.
*/

abbr:where([title]) {
  -webkit-text-decoration: underline dotted;
          text-decoration: underline dotted;
}

/*
Remove the default font size and weight for headings.
*/

h1,
h2,
h3,
h4,
h5,
h6 {
  font-size: inherit;
  font-weight: inherit;
}

/*
Reset links to optimize for opt-in styling instead of opt-out.
*/

a {
  color: inherit;
  text-decoration: inherit;
}

/*
Add the correct font weight in Edge and Safari.
*/

b,
strong {
  font-weight: bolder;
}

/*
1. Use the user's configured \`mono\` font-family by default.
2. Use the user's configured \`mono\` font-feature-settings by default.
3. Use the user's configured \`mono\` font-variation-settings by default.
4. Correct the odd \`em\` font sizing in all browsers.
*/

code,
kbd,
samp,
pre {
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; /* 1 */
  font-feature-settings: normal; /* 2 */
  font-variation-settings: normal; /* 3 */
  font-size: 1em; /* 4 */
}

/*
Add the correct font size in all browsers.
*/

small {
  font-size: 80%;
}

/*
Prevent \`sub\` and \`sup\` elements from affecting the line height in all browsers.
*/

sub,
sup {
  font-size: 75%;
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}

sub {
  bottom: -0.25em;
}

sup {
  top: -0.5em;
}

/*
1. Remove text indentation from table contents in Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=999088, https://bugs.webkit.org/show_bug.cgi?id=201297)
2. Correct table border color inheritance in all Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=935729, https://bugs.webkit.org/show_bug.cgi?id=195016)
3. Remove gaps between table borders by default.
*/

table {
  text-indent: 0; /* 1 */
  border-color: inherit; /* 2 */
  border-collapse: collapse; /* 3 */
}

/*
1. Change the font styles in all browsers.
2. Remove the margin in Firefox and Safari.
3. Remove default padding in all browsers.
*/

button,
input,
optgroup,
select,
textarea {
  font-family: inherit; /* 1 */
  font-feature-settings: inherit; /* 1 */
  font-variation-settings: inherit; /* 1 */
  font-size: 100%; /* 1 */
  font-weight: inherit; /* 1 */
  line-height: inherit; /* 1 */
  letter-spacing: inherit; /* 1 */
  color: inherit; /* 1 */
  margin: 0; /* 2 */
  padding: 0; /* 3 */
}

/*
Remove the inheritance of text transform in Edge and Firefox.
*/

button,
select {
  text-transform: none;
}

/*
1. Correct the inability to style clickable types in iOS and Safari.
2. Remove default button styles.
*/

button,
input:where([type='button']),
input:where([type='reset']),
input:where([type='submit']) {
  -webkit-appearance: button; /* 1 */
  background-color: transparent; /* 2 */
  background-image: none; /* 2 */
}

/*
Use the modern Firefox focus style for all focusable elements.
*/

:-moz-focusring {
  outline: auto;
}

/*
Remove the additional \`:invalid\` styles in Firefox. (https://github.com/mozilla/gecko-dev/blob/2f9eacd9d3d995c937b4251a5557d95d494c9be1/layout/style/res/forms.css#L728-L737)
*/

:-moz-ui-invalid {
  box-shadow: none;
}

/*
Add the correct vertical alignment in Chrome and Firefox.
*/

progress {
  vertical-align: baseline;
}

/*
Correct the cursor style of increment and decrement buttons in Safari.
*/

::-webkit-inner-spin-button,
::-webkit-outer-spin-button {
  height: auto;
}

/*
1. Correct the odd appearance in Chrome and Safari.
2. Correct the outline style in Safari.
*/

[type='search'] {
  -webkit-appearance: textfield; /* 1 */
  outline-offset: -2px; /* 2 */
}

/*
Remove the inner padding in Chrome and Safari on macOS.
*/

::-webkit-search-decoration {
  -webkit-appearance: none;
}

/*
1. Correct the inability to style clickable types in iOS and Safari.
2. Change font properties to \`inherit\` in Safari.
*/

::-webkit-file-upload-button {
  -webkit-appearance: button; /* 1 */
  font: inherit; /* 2 */
}

/*
Add the correct display in Chrome and Safari.
*/

summary {
  display: list-item;
}

/*
Removes the default spacing and border for appropriate elements.
*/

blockquote,
dl,
dd,
h1,
h2,
h3,
h4,
h5,
h6,
hr,
figure,
p,
pre {
  margin: 0;
}

fieldset {
  margin: 0;
  padding: 0;
}

legend {
  padding: 0;
}

ol,
ul,
menu {
  list-style: none;
  margin: 0;
  padding: 0;
}

/*
Reset default styling for dialogs.
*/
dialog {
  padding: 0;
}

/*
Prevent resizing textareas horizontally by default.
*/

textarea {
  resize: vertical;
}

/*
1. Reset the default placeholder opacity in Firefox. (https://github.com/tailwindlabs/tailwindcss/issues/3300)
2. Set the default placeholder color to the user's configured gray 400 color.
*/

input::-moz-placeholder, textarea::-moz-placeholder {
  opacity: 1; /* 1 */
  color: #9ca3af; /* 2 */
}

input::placeholder,
textarea::placeholder {
  opacity: 1; /* 1 */
  color: #9ca3af; /* 2 */
}

/*
Set the default cursor for buttons.
*/

button,
[role="button"] {
  cursor: pointer;
}

/*
Make sure disabled buttons don't get the pointer cursor.
*/
:disabled {
  cursor: default;
}

/*
1. Make replaced elements \`display: block\` by default. (https://github.com/mozdevs/cssremedy/issues/14)
2. Add \`vertical-align: middle\` to align replaced elements more sensibly by default. (https://github.com/jensimmons/cssremedy/issues/14#issuecomment-634934210)
   This can trigger a poorly considered lint error in some tools but is included by design.
*/

img,
svg,
video,
canvas,
audio,
iframe,
embed,
object {
  display: block; /* 1 */
  vertical-align: middle; /* 2 */
}

/*
Constrain images and videos to the parent width and preserve their intrinsic aspect ratio. (https://github.com/mozdevs/cssremedy/issues/14)
*/

img,
video {
  max-width: 100%;
  height: auto;
}

/* Make elements with the HTML hidden attribute stay hidden by default */
[hidden] {
  display: none;
}

*, ::before, ::after {
  --tw-border-spacing-x: 0;
  --tw-border-spacing-y: 0;
  --tw-translate-x: 0;
  --tw-translate-y: 0;
  --tw-rotate: 0;
  --tw-skew-x: 0;
  --tw-skew-y: 0;
  --tw-scale-x: 1;
  --tw-scale-y: 1;
  --tw-pan-x:  ;
  --tw-pan-y:  ;
  --tw-pinch-zoom:  ;
  --tw-scroll-snap-strictness: proximity;
  --tw-gradient-from-position:  ;
  --tw-gradient-via-position:  ;
  --tw-gradient-to-position:  ;
  --tw-ordinal:  ;
  --tw-slashed-zero:  ;
  --tw-numeric-figure:  ;
  --tw-numeric-spacing:  ;
  --tw-numeric-fraction:  ;
  --tw-ring-inset:  ;
  --tw-ring-offset-width: 0px;
  --tw-ring-offset-color: #fff;
  --tw-ring-color: rgb(59 130 246 / 0.5);
  --tw-ring-offset-shadow: 0 0 #0000;
  --tw-ring-shadow: 0 0 #0000;
  --tw-shadow: 0 0 #0000;
  --tw-shadow-colored: 0 0 #0000;
  --tw-blur:  ;
  --tw-brightness:  ;
  --tw-contrast:  ;
  --tw-grayscale:  ;
  --tw-hue-rotate:  ;
  --tw-invert:  ;
  --tw-saturate:  ;
  --tw-sepia:  ;
  --tw-drop-shadow:  ;
  --tw-backdrop-blur:  ;
  --tw-backdrop-brightness:  ;
  --tw-backdrop-contrast:  ;
  --tw-backdrop-grayscale:  ;
  --tw-backdrop-hue-rotate:  ;
  --tw-backdrop-invert:  ;
  --tw-backdrop-opacity:  ;
  --tw-backdrop-saturate:  ;
  --tw-backdrop-sepia:  ;
  --tw-contain-size:  ;
  --tw-contain-layout:  ;
  --tw-contain-paint:  ;
  --tw-contain-style:  ;
}

::backdrop {
  --tw-border-spacing-x: 0;
  --tw-border-spacing-y: 0;
  --tw-translate-x: 0;
  --tw-translate-y: 0;
  --tw-rotate: 0;
  --tw-skew-x: 0;
  --tw-skew-y: 0;
  --tw-scale-x: 1;
  --tw-scale-y: 1;
  --tw-pan-x:  ;
  --tw-pan-y:  ;
  --tw-pinch-zoom:  ;
  --tw-scroll-snap-strictness: proximity;
  --tw-gradient-from-position:  ;
  --tw-gradient-via-position:  ;
  --tw-gradient-to-position:  ;
  --tw-ordinal:  ;
  --tw-slashed-zero:  ;
  --tw-numeric-figure:  ;
  --tw-numeric-spacing:  ;
  --tw-numeric-fraction:  ;
  --tw-ring-inset:  ;
  --tw-ring-offset-width: 0px;
  --tw-ring-offset-color: #fff;
  --tw-ring-color: rgb(59 130 246 / 0.5);
  --tw-ring-offset-shadow: 0 0 #0000;
  --tw-ring-shadow: 0 0 #0000;
  --tw-shadow: 0 0 #0000;
  --tw-shadow-colored: 0 0 #0000;
  --tw-blur:  ;
  --tw-brightness:  ;
  --tw-contrast:  ;
  --tw-grayscale:  ;
  --tw-hue-rotate:  ;
  --tw-invert:  ;
  --tw-saturate:  ;
  --tw-sepia:  ;
  --tw-drop-shadow:  ;
  --tw-backdrop-blur:  ;
  --tw-backdrop-brightness:  ;
  --tw-backdrop-contrast:  ;
  --tw-backdrop-grayscale:  ;
  --tw-backdrop-hue-rotate:  ;
  --tw-backdrop-invert:  ;
  --tw-backdrop-opacity:  ;
  --tw-backdrop-saturate:  ;
  --tw-backdrop-sepia:  ;
  --tw-contain-size:  ;
  --tw-contain-layout:  ;
  --tw-contain-paint:  ;
  --tw-contain-style:  ;
}
.pointer-events-none {
  pointer-events: none;
}
.visible {
  visibility: visible;
}
.invisible {
  visibility: hidden;
}
.collapse {
  visibility: collapse;
}
.static {
  position: static;
}
.\\!fixed {
  position: fixed !important;
}
.fixed {
  position: fixed;
}
.absolute {
  position: absolute;
}
.relative {
  position: relative;
}
.bottom-0 {
  bottom: 0px;
}
.bottom-\\[45px\\] {
  bottom: 45px;
}
.left-0 {
  left: 0px;
}
.right-0 {
  right: 0px;
}
.right-\\[-31px\\] {
  right: -31px;
}
.right-\\[24px\\] {
  right: 24px;
}
.right-\\[26px\\] {
  right: 26px;
}
.right-\\[40px\\] {
  right: 40px;
}
.top-0 {
  top: 0px;
}
.top-\\[-15px\\] {
  top: -15px;
}
.top-\\[110px\\] {
  top: 110px;
}
.top-\\[126px\\] {
  top: 126px;
}
.-z-0 {
  z-index: 0;
}
.z-0 {
  z-index: 0;
}
.z-40 {
  z-index: 40;
}
.z-\\[1\\] {
  z-index: 1;
}
.z-\\[2\\] {
  z-index: 2;
}
.mx-auto {
  margin-left: auto;
  margin-right: auto;
}
.mb-0 {
  margin-bottom: 0px;
}
.mb-\\[101px\\] {
  margin-bottom: 101px;
}
.mb-\\[96px\\] {
  margin-bottom: 96px;
}
.mb-auto {
  margin-bottom: auto;
}
.ml-\\[59px\\] {
  margin-left: 59px;
}
.mt-0 {
  margin-top: 0px;
}
.mt-\\[44px\\] {
  margin-top: 44px;
}
.mt-\\[56px\\] {
  margin-top: 56px;
}
.mt-\\[70px\\] {
  margin-top: 70px;
}
.mt-\\[100px\\] {
  margin-top: 100px;
}
.block {
  display: block;
}
.flex {
  display: flex;
}
.table {
  display: table;
}
.grid {
  display: grid;
}
.contents {
  display: contents;
}
.hidden {
  display: none;
}
.size-\\[40px\\] {
  width: 40px;
  height: 40px;
}
.size-full {
  width: 100%;
  height: 100%;
}
.h-\\[110px\\] {
  height: 110px;
}
.h-\\[18px\\] {
  height: 18px;
}
.h-\\[200px\\] {
  height: 200px;
}
.h-\\[20px\\] {
  height: 20px;
}
.h-\\[233px\\] {
  height: 233px;
}
.h-\\[28px\\] {
  height: 28px;
}
.h-\\[292px\\] {
  height: 292px;
}
.h-\\[64px\\] {
  height: 64px;
}
.h-\\[72px\\] {
  height: 72px;
}
.h-fit {
  height: -moz-fit-content;
  height: fit-content;
}
.h-full {
  height: 100%;
}
.min-h-dvh {
  min-height: 100dvh;
}
.min-h-screen {
  min-height: 100vh;
}
.w-1 {
  width: 0.25rem;
}
.w-3 {
  width: 0.75rem;
}
.w-\\[177px\\] {
  width: 177px;
}
.w-\\[199px\\] {
  width: 199px;
}
.w-\\[20px\\] {
  width: 20px;
}
.w-\\[24px\\] {
  width: 24px;
}
.w-\\[390px\\] {
  width: 390px;
}
.w-\\[62px\\] {
  width: 62px;
}
.w-fit {
  width: -moz-fit-content;
  width: fit-content;
}
.w-full {
  width: 100%;
}
.min-w-\\[147px\\] {
  min-width: 147px;
}
.max-w-\\[1342px\\] {
  max-width: 1342px;
}
.max-w-\\[1440px\\] {
  max-width: 1440px;
}
.max-w-\\[190px\\] {
  max-width: 190px;
}
.max-w-\\[252px\\] {
  max-width: 252px;
}
.max-w-\\[281px\\] {
  max-width: 281px;
}
.max-w-\\[438px\\] {
  max-width: 438px;
}
.max-w-\\[730px\\] {
  max-width: 730px;
}
.max-w-\\[calc\\(1275px\\+39px\\)\\] {
  max-width: calc(1275px + 39px);
}
.max-w-full {
  max-width: 100%;
}
.flex-shrink {
  flex-shrink: 1;
}
.border-collapse {
  border-collapse: collapse;
}
.translate-x-\\[150\\%\\] {
  --tw-translate-x: 150%;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.translate-y-\\[0px\\] {
  --tw-translate-y: 0px;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.scale-105 {
  --tw-scale-x: 1.05;
  --tw-scale-y: 1.05;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.transform {
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.resize {
  resize: both;
}
.flex-row {
  flex-direction: row;
}
.flex-col {
  flex-direction: column;
}
.flex-col-reverse {
  flex-direction: column-reverse;
}
.items-start {
  align-items: flex-start;
}
.items-center {
  align-items: center;
}
.justify-start {
  justify-content: flex-start;
}
.justify-end {
  justify-content: flex-end;
}
.justify-center {
  justify-content: center;
}
.justify-between {
  justify-content: space-between;
}
.gap-\\[16px\\] {
  gap: 16px;
}
.gap-\\[20px\\] {
  gap: 20px;
}
.gap-\\[24px\\] {
  gap: 24px;
}
.gap-\\[28px\\] {
  gap: 28px;
}
.gap-\\[32px\\] {
  gap: 32px;
}
.gap-\\[40px\\] {
  gap: 40px;
}
.gap-\\[47px\\] {
  gap: 47px;
}
.gap-\\[48px\\] {
  gap: 48px;
}
.gap-\\[51px\\] {
  gap: 51px;
}
.self-auto {
  align-self: auto;
}
.self-start {
  align-self: flex-start;
}
.self-end {
  align-self: flex-end;
}
.overflow-hidden {
  overflow: hidden;
}
.overflow-x-clip {
  overflow-x: clip;
}
.rounded {
  border-radius: 0.25rem;
}
.border {
  border-width: 1px;
}
.bg-\\[\\#191921\\] {
  --tw-bg-opacity: 1;
  background-color: rgb(25 25 33 / var(--tw-bg-opacity));
}
.bg-\\[\\#F94F4F\\] {
  --tw-bg-opacity: 1;
  background-color: rgb(249 79 79 / var(--tw-bg-opacity));
}
.bg-black {
  --tw-bg-opacity: 1;
  background-color: rgb(0 0 0 / var(--tw-bg-opacity));
}
.stroke-\\[\\#F94F4F\\] {
  stroke: #F94F4F;
}
.stroke-\\[\\#FF9393\\] {
  stroke: #FF9393;
}
.object-contain {
  -o-object-fit: contain;
     object-fit: contain;
}
.object-cover {
  -o-object-fit: cover;
     object-fit: cover;
}
.object-fill {
  -o-object-fit: fill;
     object-fit: fill;
}
.object-scale-down {
  -o-object-fit: scale-down;
     object-fit: scale-down;
}
.object-bottom {
  -o-object-position: bottom;
     object-position: bottom;
}
.object-center {
  -o-object-position: center;
     object-position: center;
}
.object-right {
  -o-object-position: right;
     object-position: right;
}
.object-top {
  -o-object-position: top;
     object-position: top;
}
.px-0 {
  padding-left: 0px;
  padding-right: 0px;
}
.px-\\[24px\\] {
  padding-left: 24px;
  padding-right: 24px;
}
.px-\\[40px\\] {
  padding-left: 40px;
  padding-right: 40px;
}
.py-0 {
  padding-top: 0px;
  padding-bottom: 0px;
}
.py-\\[72px\\] {
  padding-top: 72px;
  padding-bottom: 72px;
}
.pl-0 {
  padding-left: 0px;
}
.pl-\\[33px\\] {
  padding-left: 33px;
}
.pl-\\[39px\\] {
  padding-left: 39px;
}
.pl-\\[40px\\] {
  padding-left: 40px;
}
.pr-0 {
  padding-right: 0px;
}
.pr-\\[40px\\] {
  padding-right: 40px;
}
.pt-\\[32px\\] {
  padding-top: 32px;
}
.text-center {
  text-align: center;
}
.text-start {
  text-align: start;
}
.text-end {
  text-align: end;
}
.font-commissioner {
  font-family: "Commissioner", sans-serif;
}
.text-\\[15px\\] {
  font-size: 15px;
}
.text-\\[16px\\] {
  font-size: 16px;
}
.text-\\[18px\\] {
  font-size: 18px;
}
.text-\\[32px\\] {
  font-size: 32px;
}
.text-\\[40px\\] {
  font-size: 40px;
}
.text-\\[80px\\] {
  font-size: 80px;
}
.font-extrabold {
  font-weight: 800;
}
.leading-\\[20px\\] {
  line-height: 20px;
}
.leading-\\[25px\\] {
  line-height: 25px;
}
.leading-\\[32px\\] {
  line-height: 32px;
}
.leading-\\[40px\\] {
  line-height: 40px;
}
.leading-\\[88px\\] {
  line-height: 88px;
}
.text-\\[\\#F94F4F\\] {
  --tw-text-opacity: 1;
  color: rgb(249 79 79 / var(--tw-text-opacity));
}
.text-white {
  --tw-text-opacity: 1;
  color: rgb(255 255 255 / var(--tw-text-opacity));
}
.text-white\\/25 {
  color: rgb(255 255 255 / 0.25);
}
.underline {
  text-decoration-line: underline;
}
.overline {
  text-decoration-line: overline;
}
.underline-offset-\\[12px\\] {
  text-underline-offset: 12px;
}
.opacity-0 {
  opacity: 0;
}
.outline {
  outline-style: solid;
}
.filter {
  filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow);
}
.transition {
  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, -webkit-backdrop-filter;
  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter;
  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter, -webkit-backdrop-filter;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 150ms;
}
.transition-all {
  transition-property: all;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 150ms;
}

h1 {
  font-size: 40px;
  font-weight: 800;
  line-height: 40px;
}

@media (min-width: 768px) {

  h1 {
    font-size: 56px;
    line-height: 56px;
  }
}

@media (min-width: 1280px) {

  h1 {
    font-size: 80px;
    line-height: 88px;
  }
}

h2 {
  font-size: 32px;
  font-weight: 800;
  line-height: 40px;
}

@media (min-width: 1280px) {

  h2 {
    font-size: 56px;
    line-height: 64px;
  }
}

h3 {
  font-size: 15px;
  font-weight: 800;
  line-height: 20px;
}

@media (min-width: 1280px) {

  h3 {
    font-size: 20px;
    line-height: 32px;
  }
}

p {
  font-size: 15px;
  line-height: 25px;
}

@media (min-width: 1280px) {

  p {
    font-size: 18px;
    line-height: 32px;
  }
}

a {
  font-size: 15px;
}

@media (min-width: 1280px) {

  a {
    font-size: 16px;
  }
}

.previous,
.next {
  stroke: #F94F4F;
  transition-property: all;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 150ms;
}
.previous:hover,
.next:hover {
  stroke: #FF9393;
}

.panel {
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 24px;
}

.image-container:hover {
  cursor: grab;
}

.image-container:active {
  cursor: grabbing;
}

.image-container {
  position: relative;
}

.carouselImage {
  pointer-events: none;
  width: 100%;
  -o-object-fit: cover;
     object-fit: cover;
  -o-object-position: right;
     object-position: right;
}

@media (min-width: 768px) {

  .carouselImage {
    height: 472px;
  }
}

@media (min-width: 1280px) {

  .carouselImage {
    height: 100%;
  }
}

.animationElement {
  transition-property: transform;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 150ms;
}

.animationElement.animateTransition {
  --tw-translate-y: 0px;
  --tw-scale-x: 1.05;
  --tw-scale-y: 1.05;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}

.animationElement {
  transition-duration: 500ms;
}

.image-container::after {
  height: 200px;
  width: 100%;
  content: '';
  position: absolute;
  bottom: 0;
  left: 0;
  background: linear-gradient(to bottom, rgba(0, 0, 0, 0) 0%, rgba(0, 0, 0, 0.5) 100%);
  pointer-events: none;
}

#mobileNav {
  height: 18px;
  width: 24px;
  background-image: url(${___CSS_LOADER_URL_REPLACEMENT_0___});
}

#mask {
  pointer-events: none;
}

#mobileNav.open {
  height: 20px;
  width: 20px;
  background-image: url(${___CSS_LOADER_URL_REPLACEMENT_1___});
}

body:has(#mobileNav.open) #mobileMenu {
  --tw-translate-x: 0px;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}

#mobileMenu {
  transition: all 0.5s ease 0s;
  display: flex;
  --tw-translate-x: 150%;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}

@media (min-width: 768px) {

  #mobileMenu {
    display: none;
  }
}

@media (max-width: 768px) {
  body:has(#mobileMenu.open) #mobileMenuList {
    pointer-events: auto;
  }

  body:has(#mobileNav.open) #mask {
    pointer-events: auto;
  }

  body:has(#mobileNav.open) {
    display: flex;
    min-height: 100vh;
    overflow: hidden;
  }
}

.hover\\:cursor-grab:hover {
  cursor: grab;
}

.hover\\:bg-\\[\\#434356\\]:hover {
  --tw-bg-opacity: 1;
  background-color: rgb(67 67 86 / var(--tw-bg-opacity));
}

.hover\\:bg-\\[\\#FF9393\\]:hover {
  --tw-bg-opacity: 1;
  background-color: rgb(255 147 147 / var(--tw-bg-opacity));
}

.hover\\:font-bold:hover {
  font-weight: 700;
}

.hover\\:text-\\[\\#FF9393\\]:hover {
  --tw-text-opacity: 1;
  color: rgb(255 147 147 / var(--tw-text-opacity));
}

@media (min-width: 768px) {

  .md\\:absolute {
    position: absolute;
  }

  .md\\:left-\\[-31px\\] {
    left: -31px;
  }

  .md\\:top-\\[220px\\] {
    top: 220px;
  }

  .md\\:mb-0 {
    margin-bottom: 0px;
  }

  .md\\:mt-\\[-120px\\] {
    margin-top: -120px;
  }

  .md\\:mt-\\[120px\\] {
    margin-top: 120px;
  }

  .md\\:mt-\\[77px\\] {
    margin-top: 77px;
  }

  .md\\:mt-\\[70px\\] {
    margin-top: 70px;
  }

  .md\\:block {
    display: block;
  }

  .md\\:flex {
    display: flex;
  }

  .md\\:hidden {
    display: none;
  }

  .md\\:h-\\[178px\\] {
    height: 178px;
  }

  .md\\:h-\\[200px\\] {
    height: 200px;
  }

  .md\\:h-\\[352px\\] {
    height: 352px;
  }

  .md\\:h-\\[472px\\] {
    height: 472px;
  }

  .md\\:h-\\[538px\\] {
    height: 538px;
  }

  .md\\:h-\\[606px\\] {
    height: 606px;
  }

  .md\\:h-\\[608px\\] {
    height: 608px;
  }

  .md\\:h-\\[648px\\] {
    height: 648px;
  }

  .md\\:h-\\[658px\\] {
    height: 658px;
  }

  .md\\:h-\\[797px\\] {
    height: 797px;
  }

  .md\\:min-h-\\[472px\\] {
    min-height: 472px;
  }

  .md\\:min-h-screen {
    min-height: 100vh;
  }

  .md\\:w-1\\/2 {
    width: 50%;
  }

  .md\\:w-3\\/5 {
    width: 60%;
  }

  .md\\:w-\\[1400px\\] {
    width: 1400px;
  }

  .md\\:w-\\[355px\\] {
    width: 355px;
  }

  .md\\:w-\\[390px\\] {
    width: 390px;
  }

  .md\\:w-\\[735px\\] {
    width: 735px;
  }

  .md\\:w-fit {
    width: -moz-fit-content;
    width: fit-content;
  }

  .md\\:w-full {
    width: 100%;
  }

  .md\\:max-w-\\[250px\\] {
    max-width: 250px;
  }

  .md\\:max-w-\\[281px\\] {
    max-width: 281px;
  }

  .md\\:max-w-\\[398px\\] {
    max-width: 398px;
  }

  .md\\:max-w-\\[735px\\] {
    max-width: 735px;
  }

  .md\\:flex-row {
    flex-direction: row;
  }

  .md\\:items-start {
    align-items: flex-start;
  }

  .md\\:items-center {
    align-items: center;
  }

  .md\\:justify-end {
    justify-content: flex-end;
  }

  .md\\:gap-\\[39px\\] {
    gap: 39px;
  }

  .md\\:gap-\\[48px\\] {
    gap: 48px;
  }

  .md\\:self-end {
    align-self: flex-end;
  }

  .md\\:object-\\[100\\%_0\\%\\] {
    -o-object-position: 100% 0%;
       object-position: 100% 0%;
  }

  .md\\:px-0 {
    padding-left: 0px;
    padding-right: 0px;
  }

  .md\\:py-0 {
    padding-top: 0px;
    padding-bottom: 0px;
  }

  .md\\:px-\\[40px\\] {
    padding-left: 40px;
    padding-right: 40px;
  }

  .md\\:pl-\\[39px\\] {
    padding-left: 39px;
  }

  .md\\:pl-\\[69px\\] {
    padding-left: 69px;
  }

  .md\\:pr-\\[40px\\] {
    padding-right: 40px;
  }

  .md\\:text-\\[56px\\] {
    font-size: 56px;
  }

  .md\\:leading-\\[56px\\] {
    line-height: 56px;
  }

  .md\\:opacity-0 {
    opacity: 0;
  }
}

@media (min-width: 1024px) {

  .lg\\:mt-0 {
    margin-top: 0px;
  }

  .lg\\:mt-\\[-200px\\] {
    margin-top: -200px;
  }

  .lg\\:h-\\[560px\\] {
    height: 560px;
  }

  .lg\\:h-\\[750px\\] {
    height: 750px;
  }

  .lg\\:w-\\[530px\\] {
    width: 530px;
  }

  .lg\\:max-w-\\[530px\\] {
    max-width: 530px;
  }

  .lg\\:max-w-full {
    max-width: 100%;
  }

  .lg\\:gap-\\[50px\\] {
    gap: 50px;
  }

  .lg\\:px-0 {
    padding-left: 0px;
    padding-right: 0px;
  }

  .lg\\:pl-\\[90px\\] {
    padding-left: 90px;
  }

  .lg\\:pr-\\[20px\\] {
    padding-right: 20px;
  }

  .lg\\:pr-\\[60px\\] {
    padding-right: 60px;
  }
}

@media (min-width: 1280px) {

  .xl\\:bottom-\\[68px\\] {
    bottom: 68px;
  }

  .xl\\:left-\\[-67px\\] {
    left: -67px;
  }

  .xl\\:right-\\[-67px\\] {
    right: -67px;
  }

  .xl\\:right-\\[154px\\] {
    right: 154px;
  }

  .xl\\:top-\\[186px\\] {
    top: 186px;
  }

  .xl\\:top-\\[234px\\] {
    top: 234px;
  }

  .xl\\:mb-\\[115px\\] {
    margin-bottom: 115px;
  }

  .xl\\:ml-\\[-67px\\] {
    margin-left: -67px;
  }

  .xl\\:ml-\\[98px\\] {
    margin-left: 98px;
  }

  .xl\\:mr-\\[-160px\\] {
    margin-right: -160px;
  }

  .xl\\:mt-\\[112px\\] {
    margin-top: 112px;
  }

  .xl\\:mt-\\[120px\\] {
    margin-top: 120px;
  }

  .xl\\:mt-\\[200px\\] {
    margin-top: 200px;
  }

  .xl\\:block {
    display: block;
  }

  .xl\\:h-\\[1100px\\] {
    height: 1100px;
  }

  .xl\\:h-\\[528px\\] {
    height: 528px;
  }

  .xl\\:h-\\[60px\\] {
    height: 60px;
  }

  .xl\\:h-\\[61px\\] {
    height: 61px;
  }

  .xl\\:h-\\[728px\\] {
    height: 728px;
  }

  .xl\\:h-\\[784px\\] {
    height: 784px;
  }

  .xl\\:h-\\[800px\\] {
    height: 800px;
  }

  .xl\\:h-\\[984px\\] {
    height: 984px;
  }

  .xl\\:min-h-\\[728px\\] {
    min-height: 728px;
  }

  .xl\\:w-\\[134px\\] {
    width: 134px;
  }

  .xl\\:w-\\[135px\\] {
    width: 135px;
  }

  .xl\\:w-\\[445px\\] {
    width: 445px;
  }

  .xl\\:w-\\[504px\\] {
    width: 504px;
  }

  .xl\\:w-\\[705px\\] {
    width: 705px;
  }

  .xl\\:w-\\[895px\\] {
    width: 895px;
  }

  .xl\\:w-fit {
    width: -moz-fit-content;
    width: fit-content;
  }

  .xl\\:min-w-\\[199px\\] {
    min-width: 199px;
  }

  .xl\\:max-w-\\[225px\\] {
    max-width: 225px;
  }

  .xl\\:max-w-\\[47vw\\] {
    max-width: 47vw;
  }

  .xl\\:max-w-\\[540px\\] {
    max-width: 540px;
  }

  .xl\\:max-w-\\[635px\\] {
    max-width: 635px;
  }

  .xl\\:max-w-\\[680px\\] {
    max-width: 680px;
  }

  .xl\\:max-w-full {
    max-width: 100%;
  }

  .xl\\:justify-end {
    justify-content: flex-end;
  }

  .xl\\:gap-\\[43px\\] {
    gap: 43px;
  }

  .xl\\:gap-\\[48px\\] {
    gap: 48px;
  }

  .xl\\:gap-\\[56px\\] {
    gap: 56px;
  }

  .xl\\:object-center {
    -o-object-position: center;
       object-position: center;
  }

  .xl\\:px-0 {
    padding-left: 0px;
    padding-right: 0px;
  }

  .xl\\:pl-0 {
    padding-left: 0px;
  }

  .xl\\:pl-\\[154px\\] {
    padding-left: 154px;
  }

  .xl\\:pl-\\[39px\\] {
    padding-left: 39px;
  }

  .xl\\:pl-\\[69px\\] {
    padding-left: 69px;
  }

  .xl\\:pr-0 {
    padding-right: 0px;
  }

  .xl\\:pr-\\[106px\\] {
    padding-right: 106px;
  }

  .xl\\:text-\\[16px\\] {
    font-size: 16px;
  }

  .xl\\:text-\\[18px\\] {
    font-size: 18px;
  }

  .xl\\:text-\\[20px\\] {
    font-size: 20px;
  }

  .xl\\:text-\\[56px\\] {
    font-size: 56px;
  }

  .xl\\:text-\\[80px\\] {
    font-size: 80px;
  }

  .xl\\:leading-\\[32px\\] {
    line-height: 32px;
  }

  .xl\\:leading-\\[64px\\] {
    line-height: 64px;
  }

  .xl\\:leading-\\[88px\\] {
    line-height: 88px;
  }
}

@media (min-width: 1500px) {

  .screen1500\\:max-w-\\[705px\\] {
    max-width: 705px;
  }
}
`, "",{"version":3,"sources":["webpack://./app/static/pages/globals.css"],"names":[],"mappings":"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AAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA,iBAAmB;EAAnB;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA,WAAmB;EAAnB;AAAmB;AAAnB;EAAA,WAAmB;EAAnB;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA,wBAAmB;EAAnB;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA,uBAAmB;EAAnB;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA,sBAAmB;EAAn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","sourcesContent":["@tailwind base;\r\n@tailwind components;\r\n@tailwind utilities;\r\n\r\nh1 {\r\n  @apply text-[40px] font-extrabold leading-[40px] md:text-[56px] md:leading-[56px] xl:text-[80px] xl:leading-[88px];\r\n}\r\n\r\nh2 {\r\n  @apply text-[32px] font-extrabold leading-[40px] xl:text-[56px] xl:leading-[64px];\r\n}\r\n\r\nh3 {\r\n  @apply text-[15px] font-extrabold leading-[20px] xl:text-[20px] xl:leading-[32px];\r\n}\r\n\r\np {\r\n  @apply text-[15px] leading-[25px] xl:text-[18px] xl:leading-[32px];\r\n}\r\n\r\na {\r\n  @apply text-[15px] xl:text-[16px];\r\n}\r\n\r\n.previous,\r\n.next {\r\n  @apply stroke-[#F94F4F] transition-all;\r\n}\r\n.previous:hover,\r\n.next:hover {\r\n  @apply stroke-[#FF9393];\r\n}\r\n\r\n.panel {\r\n  width: 100%;\r\n  height: 100%;\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n  font-size: 24px;\r\n}\r\n\r\n.image-container {\r\n  @apply hover:cursor-grab active:cursor-grabbing;\r\n  position: relative;\r\n}\r\n\r\n.carouselImage {\r\n  @apply pointer-events-none w-full object-cover object-right md:h-[472px] xl:h-full;\r\n}\r\n\r\n.animationElement {\r\n  @apply transition-transform;\r\n}\r\n\r\n.animationElement.animateTransition {\r\n  @apply translate-y-[0px] scale-105 transform;\r\n}\r\n\r\n.animationElement {\r\n  @apply duration-500;\r\n}\r\n\r\n.image-container::after {\r\n  @apply h-[200px] w-full;\r\n  content: '';\r\n  position: absolute;\r\n  bottom: 0;\r\n  left: 0;\r\n  background: linear-gradient(to bottom, rgba(0, 0, 0, 0) 0%, rgba(0, 0, 0, 0.5) 100%);\r\n  pointer-events: none;\r\n}\r\n\r\n#mobileNav {\r\n  @apply h-[18px] w-[24px];\r\n  background-image: url('../assets/mobile/icon-hamburger.svg');\r\n}\r\n\r\n#mask {\r\n  @apply pointer-events-none;\r\n}\r\n\r\n#mobileNav.open {\r\n  @apply h-[20px] w-[20px];\r\n  background-image: url('../assets/mobile/icon-cross.svg');\r\n}\r\n\r\nbody:has(#mobileNav.open) #mobileMenu {\r\n  @apply translate-x-0;\r\n}\r\n\r\n#mobileMenu {\r\n  transition: all 0.5s ease 0s;\r\n  @apply flex translate-x-[150%] md:hidden;\r\n}\r\n\r\n@media (max-width: 768px) {\r\n  body:has(#mobileMenu.open) #mobileMenuList {\r\n    @apply pointer-events-auto;\r\n  }\r\n\r\n  body:has(#mobileNav.open) #mask {\r\n    @apply pointer-events-auto;\r\n  }\r\n\r\n  body:has(#mobileNav.open) {\r\n    @apply flex min-h-screen overflow-hidden;\r\n  }\r\n}\r\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js!./node_modules/@egjs/preact-flicking/dist/flicking.css":
/*!**********************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js!./node_modules/@egjs/preact-flicking/dist/flicking.css ***!
  \**********************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `.flicking-viewport {
  position: relative;
  overflow: hidden;
}

.flicking-viewport.vertical {
  display: inline-flex;
}

.flicking-viewport.vertical > .flicking-camera {
  display: inline-flex;
  flex-direction: column;
}

.flicking-viewport.flicking-hidden > .flicking-camera > * {
  visibility: hidden;
}

.flicking-camera {
  width: 100%;
  height: 100%;
  display: flex;
  position: relative;
  flex-direction: row;
  z-index: 1;
  will-change: transform;
}

.flicking-camera > * {
  flex-shrink: 0;
}
`, "",{"version":3,"sources":["webpack://./node_modules/@egjs/preact-flicking/dist/flicking.css"],"names":[],"mappings":"AAAA;EACE,kBAAkB;EAClB,gBAAgB;AAClB;;AAEA;EAGE,oBAAoB;AACtB;;AAEA;EAGE,oBAAoB;EAIZ,sBAAsB;AAChC;;AAEA;EACE,kBAAkB;AACpB;;AAEA;EACE,WAAW;EACX,YAAY;EAGZ,aAAa;EACb,kBAAkB;EAIV,mBAAmB;EAC3B,UAAU;EACV,sBAAsB;AACxB;;AAEA;EAEM,cAAc;AACpB","sourcesContent":[".flicking-viewport {\n  position: relative;\n  overflow: hidden;\n}\n\n.flicking-viewport.vertical {\n  display: -webkit-inline-box;\n  display: -ms-inline-flexbox;\n  display: inline-flex;\n}\n\n.flicking-viewport.vertical > .flicking-camera {\n  display: -webkit-inline-box;\n  display: -ms-inline-flexbox;\n  display: inline-flex;\n  -webkit-box-orient: vertical;\n  -webkit-box-direction: normal;\n      -ms-flex-direction: column;\n          flex-direction: column;\n}\n\n.flicking-viewport.flicking-hidden > .flicking-camera > * {\n  visibility: hidden;\n}\n\n.flicking-camera {\n  width: 100%;\n  height: 100%;\n  display: -webkit-box;\n  display: -ms-flexbox;\n  display: flex;\n  position: relative;\n  -webkit-box-orient: horizontal;\n  -webkit-box-direction: normal;\n      -ms-flex-direction: row;\n          flex-direction: row;\n  z-index: 1;\n  will-change: transform;\n}\n\n.flicking-camera > * {\n  -ms-flex-negative: 0;\n      flex-shrink: 0;\n}\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {



/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
module.exports = function (cssWithMappingToString) {
  var list = [];

  // return the list of modules as css string
  list.toString = function toString() {
    return this.map(function (item) {
      var content = "";
      var needLayer = typeof item[5] !== "undefined";
      if (item[4]) {
        content += "@supports (".concat(item[4], ") {");
      }
      if (item[2]) {
        content += "@media ".concat(item[2], " {");
      }
      if (needLayer) {
        content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");
      }
      content += cssWithMappingToString(item);
      if (needLayer) {
        content += "}";
      }
      if (item[2]) {
        content += "}";
      }
      if (item[4]) {
        content += "}";
      }
      return content;
    }).join("");
  };

  // import a list of modules into the list
  list.i = function i(modules, media, dedupe, supports, layer) {
    if (typeof modules === "string") {
      modules = [[null, modules, undefined]];
    }
    var alreadyImportedModules = {};
    if (dedupe) {
      for (var k = 0; k < this.length; k++) {
        var id = this[k][0];
        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }
    for (var _k = 0; _k < modules.length; _k++) {
      var item = [].concat(modules[_k]);
      if (dedupe && alreadyImportedModules[item[0]]) {
        continue;
      }
      if (typeof layer !== "undefined") {
        if (typeof item[5] === "undefined") {
          item[5] = layer;
        } else {
          item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");
          item[5] = layer;
        }
      }
      if (media) {
        if (!item[2]) {
          item[2] = media;
        } else {
          item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");
          item[2] = media;
        }
      }
      if (supports) {
        if (!item[4]) {
          item[4] = "".concat(supports);
        } else {
          item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");
          item[4] = supports;
        }
      }
      list.push(item);
    }
  };
  return list;
};

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/getUrl.js":
/*!********************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/getUrl.js ***!
  \********************************************************/
/***/ ((module) => {



module.exports = function (url, options) {
  if (!options) {
    options = {};
  }
  if (!url) {
    return url;
  }
  url = String(url.__esModule ? url.default : url);

  // If url is already wrapped in quotes, remove them
  if (/^['"].*['"]$/.test(url)) {
    url = url.slice(1, -1);
  }
  if (options.hash) {
    url += options.hash;
  }

  // Should url be wrapped?
  // See https://drafts.csswg.org/css-values-3/#urls
  if (/["'() \t\n]|(%20)/.test(url) || options.needQuotes) {
    return "\"".concat(url.replace(/"/g, '\\"').replace(/\n/g, "\\n"), "\"");
  }
  return url;
};

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/sourceMaps.js":
/*!************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/sourceMaps.js ***!
  \************************************************************/
/***/ ((module) => {



module.exports = function (item) {
  var content = item[1];
  var cssMapping = item[3];
  if (!cssMapping) {
    return content;
  }
  if (typeof btoa === "function") {
    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));
    var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
    var sourceMapping = "/*# ".concat(data, " */");
    return [content].concat([sourceMapping]).join("\n");
  }
  return [content].join("\n");
};

/***/ }),

/***/ "./node_modules/preact/dist/preact.module.js":
/*!***************************************************!*\
  !*** ./node_modules/preact/dist/preact.module.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Component: () => (/* binding */ b),
/* harmony export */   Fragment: () => (/* binding */ k),
/* harmony export */   cloneElement: () => (/* binding */ E),
/* harmony export */   createContext: () => (/* binding */ G),
/* harmony export */   createElement: () => (/* binding */ _),
/* harmony export */   createRef: () => (/* binding */ m),
/* harmony export */   h: () => (/* binding */ _),
/* harmony export */   hydrate: () => (/* binding */ D),
/* harmony export */   isValidElement: () => (/* binding */ t),
/* harmony export */   options: () => (/* binding */ l),
/* harmony export */   render: () => (/* binding */ B),
/* harmony export */   toChildArray: () => (/* binding */ H)
/* harmony export */ });
var n,l,u,t,i,o,r,f,e,c,s,a,h={},p=[],v=/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i,y=Array.isArray;function d(n,l){for(var u in l)n[u]=l[u];return n}function w(n){var l=n.parentNode;l&&l.removeChild(n)}function _(l,u,t){var i,o,r,f={};for(r in u)"key"==r?i=u[r]:"ref"==r?o=u[r]:f[r]=u[r];if(arguments.length>2&&(f.children=arguments.length>3?n.call(arguments,2):t),"function"==typeof l&&null!=l.defaultProps)for(r in l.defaultProps)void 0===f[r]&&(f[r]=l.defaultProps[r]);return g(l,f,i,o,null)}function g(n,t,i,o,r){var f={type:n,props:t,key:i,ref:o,__k:null,__:null,__b:0,__e:null,__d:void 0,__c:null,constructor:void 0,__v:null==r?++u:r,__i:-1,__u:0};return null==r&&null!=l.vnode&&l.vnode(f),f}function m(){return{current:null}}function k(n){return n.children}function b(n,l){this.props=n,this.context=l}function x(n,l){if(null==l)return n.__?x(n.__,n.__i+1):null;for(var u;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e)return u.__e;return"function"==typeof n.type?x(n):null}function C(n){var l,u;if(null!=(n=n.__)&&null!=n.__c){for(n.__e=n.__c.base=null,l=0;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e){n.__e=n.__c.base=u.__e;break}return C(n)}}function M(n){(!n.__d&&(n.__d=!0)&&i.push(n)&&!P.__r++||o!==l.debounceRendering)&&((o=l.debounceRendering)||r)(P)}function P(){var n,u,t,o,r,e,c,s;for(i.sort(f);n=i.shift();)n.__d&&(u=i.length,o=void 0,e=(r=(t=n).__v).__e,c=[],s=[],t.__P&&((o=d({},r)).__v=r.__v+1,l.vnode&&l.vnode(o),O(t.__P,o,r,t.__n,t.__P.namespaceURI,32&r.__u?[e]:null,c,null==e?x(r):e,!!(32&r.__u),s),o.__v=r.__v,o.__.__k[o.__i]=o,j(c,o,s),o.__e!=e&&C(o)),i.length>u&&i.sort(f));P.__r=0}function S(n,l,u,t,i,o,r,f,e,c,s){var a,v,y,d,w,_=t&&t.__k||p,g=l.length;for(u.__d=e,$(u,l,_),e=u.__d,a=0;a<g;a++)null!=(y=u.__k[a])&&"boolean"!=typeof y&&"function"!=typeof y&&(v=-1===y.__i?h:_[y.__i]||h,y.__i=a,O(n,y,v,i,o,r,f,e,c,s),d=y.__e,y.ref&&v.ref!=y.ref&&(v.ref&&N(v.ref,null,y),s.push(y.ref,y.__c||d,y)),null==w&&null!=d&&(w=d),65536&y.__u||v.__k===y.__k?e=I(y,e,n):"function"==typeof y.type&&void 0!==y.__d?e=y.__d:d&&(e=d.nextSibling),y.__d=void 0,y.__u&=-196609);u.__d=e,u.__e=w}function $(n,l,u){var t,i,o,r,f,e=l.length,c=u.length,s=c,a=0;for(n.__k=[],t=0;t<e;t++)r=t+a,null!=(i=n.__k[t]=null==(i=l[t])||"boolean"==typeof i||"function"==typeof i?null:"string"==typeof i||"number"==typeof i||"bigint"==typeof i||i.constructor==String?g(null,i,null,null,null):y(i)?g(k,{children:i},null,null,null):void 0===i.constructor&&i.__b>0?g(i.type,i.props,i.key,i.ref?i.ref:null,i.__v):i)?(i.__=n,i.__b=n.__b+1,f=L(i,u,r,s),i.__i=f,o=null,-1!==f&&(s--,(o=u[f])&&(o.__u|=131072)),null==o||null===o.__v?(-1==f&&a--,"function"!=typeof i.type&&(i.__u|=65536)):f!==r&&(f==r-1?a=f-r:f==r+1?a++:f>r?s>e-r?a+=f-r:a--:f<r&&a++,f!==t+a&&(i.__u|=65536))):(o=u[r])&&null==o.key&&o.__e&&0==(131072&o.__u)&&(o.__e==n.__d&&(n.__d=x(o)),V(o,o,!1),u[r]=null,s--);if(s)for(t=0;t<c;t++)null!=(o=u[t])&&0==(131072&o.__u)&&(o.__e==n.__d&&(n.__d=x(o)),V(o,o))}function I(n,l,u){var t,i;if("function"==typeof n.type){for(t=n.__k,i=0;t&&i<t.length;i++)t[i]&&(t[i].__=n,l=I(t[i],l,u));return l}n.__e!=l&&(l&&n.type&&!u.contains(l)&&(l=x(n)),u.insertBefore(n.__e,l||null),l=n.__e);do{l=l&&l.nextSibling}while(null!=l&&8===l.nodeType);return l}function H(n,l){return l=l||[],null==n||"boolean"==typeof n||(y(n)?n.some(function(n){H(n,l)}):l.push(n)),l}function L(n,l,u,t){var i=n.key,o=n.type,r=u-1,f=u+1,e=l[u];if(null===e||e&&i==e.key&&o===e.type&&0==(131072&e.__u))return u;if(t>(null!=e&&0==(131072&e.__u)?1:0))for(;r>=0||f<l.length;){if(r>=0){if((e=l[r])&&0==(131072&e.__u)&&i==e.key&&o===e.type)return r;r--}if(f<l.length){if((e=l[f])&&0==(131072&e.__u)&&i==e.key&&o===e.type)return f;f++}}return-1}function T(n,l,u){"-"===l[0]?n.setProperty(l,null==u?"":u):n[l]=null==u?"":"number"!=typeof u||v.test(l)?u:u+"px"}function A(n,l,u,t,i){var o;n:if("style"===l)if("string"==typeof u)n.style.cssText=u;else{if("string"==typeof t&&(n.style.cssText=t=""),t)for(l in t)u&&l in u||T(n.style,l,"");if(u)for(l in u)t&&u[l]===t[l]||T(n.style,l,u[l])}else if("o"===l[0]&&"n"===l[1])o=l!==(l=l.replace(/(PointerCapture)$|Capture$/i,"$1")),l=l.toLowerCase()in n||"onFocusOut"===l||"onFocusIn"===l?l.toLowerCase().slice(2):l.slice(2),n.l||(n.l={}),n.l[l+o]=u,u?t?u.u=t.u:(u.u=e,n.addEventListener(l,o?s:c,o)):n.removeEventListener(l,o?s:c,o);else{if("http://www.w3.org/2000/svg"==i)l=l.replace(/xlink(H|:h)/,"h").replace(/sName$/,"s");else if("width"!=l&&"height"!=l&&"href"!=l&&"list"!=l&&"form"!=l&&"tabIndex"!=l&&"download"!=l&&"rowSpan"!=l&&"colSpan"!=l&&"role"!=l&&"popover"!=l&&l in n)try{n[l]=null==u?"":u;break n}catch(n){}"function"==typeof u||(null==u||!1===u&&"-"!==l[4]?n.removeAttribute(l):n.setAttribute(l,"popover"==l&&1==u?"":u))}}function F(n){return function(u){if(this.l){var t=this.l[u.type+n];if(null==u.t)u.t=e++;else if(u.t<t.u)return;return t(l.event?l.event(u):u)}}}function O(n,u,t,i,o,r,f,e,c,s){var a,h,p,v,w,_,g,m,x,C,M,P,$,I,H,L,T=u.type;if(void 0!==u.constructor)return null;128&t.__u&&(c=!!(32&t.__u),r=[e=u.__e=t.__e]),(a=l.__b)&&a(u);n:if("function"==typeof T)try{if(m=u.props,x="prototype"in T&&T.prototype.render,C=(a=T.contextType)&&i[a.__c],M=a?C?C.props.value:a.__:i,t.__c?g=(h=u.__c=t.__c).__=h.__E:(x?u.__c=h=new T(m,M):(u.__c=h=new b(m,M),h.constructor=T,h.render=q),C&&C.sub(h),h.props=m,h.state||(h.state={}),h.context=M,h.__n=i,p=h.__d=!0,h.__h=[],h._sb=[]),x&&null==h.__s&&(h.__s=h.state),x&&null!=T.getDerivedStateFromProps&&(h.__s==h.state&&(h.__s=d({},h.__s)),d(h.__s,T.getDerivedStateFromProps(m,h.__s))),v=h.props,w=h.state,h.__v=u,p)x&&null==T.getDerivedStateFromProps&&null!=h.componentWillMount&&h.componentWillMount(),x&&null!=h.componentDidMount&&h.__h.push(h.componentDidMount);else{if(x&&null==T.getDerivedStateFromProps&&m!==v&&null!=h.componentWillReceiveProps&&h.componentWillReceiveProps(m,M),!h.__e&&(null!=h.shouldComponentUpdate&&!1===h.shouldComponentUpdate(m,h.__s,M)||u.__v===t.__v)){for(u.__v!==t.__v&&(h.props=m,h.state=h.__s,h.__d=!1),u.__e=t.__e,u.__k=t.__k,u.__k.forEach(function(n){n&&(n.__=u)}),P=0;P<h._sb.length;P++)h.__h.push(h._sb[P]);h._sb=[],h.__h.length&&f.push(h);break n}null!=h.componentWillUpdate&&h.componentWillUpdate(m,h.__s,M),x&&null!=h.componentDidUpdate&&h.__h.push(function(){h.componentDidUpdate(v,w,_)})}if(h.context=M,h.props=m,h.__P=n,h.__e=!1,$=l.__r,I=0,x){for(h.state=h.__s,h.__d=!1,$&&$(u),a=h.render(h.props,h.state,h.context),H=0;H<h._sb.length;H++)h.__h.push(h._sb[H]);h._sb=[]}else do{h.__d=!1,$&&$(u),a=h.render(h.props,h.state,h.context),h.state=h.__s}while(h.__d&&++I<25);h.state=h.__s,null!=h.getChildContext&&(i=d(d({},i),h.getChildContext())),x&&!p&&null!=h.getSnapshotBeforeUpdate&&(_=h.getSnapshotBeforeUpdate(v,w)),S(n,y(L=null!=a&&a.type===k&&null==a.key?a.props.children:a)?L:[L],u,t,i,o,r,f,e,c,s),h.base=u.__e,u.__u&=-161,h.__h.length&&f.push(h),g&&(h.__E=h.__=null)}catch(n){if(u.__v=null,c||null!=r){for(u.__u|=c?160:32;e&&8===e.nodeType&&e.nextSibling;)e=e.nextSibling;r[r.indexOf(e)]=null,u.__e=e}else u.__e=t.__e,u.__k=t.__k;l.__e(n,u,t)}else null==r&&u.__v===t.__v?(u.__k=t.__k,u.__e=t.__e):u.__e=z(t.__e,u,t,i,o,r,f,c,s);(a=l.diffed)&&a(u)}function j(n,u,t){u.__d=void 0;for(var i=0;i<t.length;i++)N(t[i],t[++i],t[++i]);l.__c&&l.__c(u,n),n.some(function(u){try{n=u.__h,u.__h=[],n.some(function(n){n.call(u)})}catch(n){l.__e(n,u.__v)}})}function z(l,u,t,i,o,r,f,e,c){var s,a,p,v,d,_,g,m=t.props,k=u.props,b=u.type;if("svg"===b?o="http://www.w3.org/2000/svg":"math"===b?o="http://www.w3.org/1998/Math/MathML":o||(o="http://www.w3.org/1999/xhtml"),null!=r)for(s=0;s<r.length;s++)if((d=r[s])&&"setAttribute"in d==!!b&&(b?d.localName===b:3===d.nodeType)){l=d,r[s]=null;break}if(null==l){if(null===b)return document.createTextNode(k);l=document.createElementNS(o,b,k.is&&k),r=null,e=!1}if(null===b)m===k||e&&l.data===k||(l.data=k);else{if(r=r&&n.call(l.childNodes),m=t.props||h,!e&&null!=r)for(m={},s=0;s<l.attributes.length;s++)m[(d=l.attributes[s]).name]=d.value;for(s in m)if(d=m[s],"children"==s);else if("dangerouslySetInnerHTML"==s)p=d;else if("key"!==s&&!(s in k)){if("value"==s&&"defaultValue"in k||"checked"==s&&"defaultChecked"in k)continue;A(l,s,null,d,o)}for(s in k)d=k[s],"children"==s?v=d:"dangerouslySetInnerHTML"==s?a=d:"value"==s?_=d:"checked"==s?g=d:"key"===s||e&&"function"!=typeof d||m[s]===d||A(l,s,d,m[s],o);if(a)e||p&&(a.__html===p.__html||a.__html===l.innerHTML)||(l.innerHTML=a.__html),u.__k=[];else if(p&&(l.innerHTML=""),S(l,y(v)?v:[v],u,t,i,"foreignObject"===b?"http://www.w3.org/1999/xhtml":o,r,f,r?r[0]:t.__k&&x(t,0),e,c),null!=r)for(s=r.length;s--;)null!=r[s]&&w(r[s]);e||(s="value",void 0!==_&&(_!==l[s]||"progress"===b&&!_||"option"===b&&_!==m[s])&&A(l,s,_,m[s],o),s="checked",void 0!==g&&g!==l[s]&&A(l,s,g,m[s],o))}return l}function N(n,u,t){try{if("function"==typeof n){var i="function"==typeof n.__u;i&&n.__u(),i&&null==u||(n.__u=n(u))}else n.current=u}catch(n){l.__e(n,t)}}function V(n,u,t){var i,o;if(l.unmount&&l.unmount(n),(i=n.ref)&&(i.current&&i.current!==n.__e||N(i,null,u)),null!=(i=n.__c)){if(i.componentWillUnmount)try{i.componentWillUnmount()}catch(n){l.__e(n,u)}i.base=i.__P=null}if(i=n.__k)for(o=0;o<i.length;o++)i[o]&&V(i[o],u,t||"function"!=typeof n.type);t||null==n.__e||w(n.__e),n.__c=n.__=n.__e=n.__d=void 0}function q(n,l,u){return this.constructor(n,u)}function B(u,t,i){var o,r,f,e;l.__&&l.__(u,t),r=(o="function"==typeof i)?null:i&&i.__k||t.__k,f=[],e=[],O(t,u=(!o&&i||t).__k=_(k,null,[u]),r||h,h,t.namespaceURI,!o&&i?[i]:r?null:t.firstChild?n.call(t.childNodes):null,f,!o&&i?i:r?r.__e:t.firstChild,o,e),j(f,u,e)}function D(n,l){B(n,l,D)}function E(l,u,t){var i,o,r,f,e=d({},l.props);for(r in l.type&&l.type.defaultProps&&(f=l.type.defaultProps),u)"key"==r?i=u[r]:"ref"==r?o=u[r]:e[r]=void 0===u[r]&&void 0!==f?f[r]:u[r];return arguments.length>2&&(e.children=arguments.length>3?n.call(arguments,2):t),g(l.type,e,i||l.key,o||l.ref,null)}function G(n,l){var u={__c:l="__cC"+a++,__:n,Consumer:function(n,l){return n.children(l)},Provider:function(n){var u,t;return this.getChildContext||(u=[],(t={})[l]=this,this.getChildContext=function(){return t},this.componentWillUnmount=function(){u=null},this.shouldComponentUpdate=function(n){this.props.value!==n.value&&u.some(function(n){n.__e=!0,M(n)})},this.sub=function(n){u.push(n);var l=n.componentWillUnmount;n.componentWillUnmount=function(){u&&u.splice(u.indexOf(n),1),l&&l.call(n)}}),n.children}};return u.Provider.__=u.Consumer.contextType=u}n=p.slice,l={__e:function(n,l,u,t){for(var i,o,r;l=l.__;)if((i=l.__c)&&!i.__)try{if((o=i.constructor)&&null!=o.getDerivedStateFromError&&(i.setState(o.getDerivedStateFromError(n)),r=i.__d),null!=i.componentDidCatch&&(i.componentDidCatch(n,t||{}),r=i.__d),r)return i.__E=i}catch(l){n=l}throw n}},u=0,t=function(n){return null!=n&&null==n.constructor},b.prototype.setState=function(n,l){var u;u=null!=this.__s&&this.__s!==this.state?this.__s:this.__s=d({},this.state),"function"==typeof n&&(n=n(d({},u),this.props)),n&&d(u,n),null!=n&&this.__v&&(l&&this._sb.push(l),M(this))},b.prototype.forceUpdate=function(n){this.__v&&(this.__e=!0,n&&this.__h.push(n),M(this))},b.prototype.render=k,i=[],r="function"==typeof Promise?Promise.prototype.then.bind(Promise.resolve()):setTimeout,f=function(n,l){return n.__v.__b-l.__v.__b},P.__r=0,e=0,c=F(!1),s=F(!0),a=0;
//# sourceMappingURL=preact.module.js.map


/***/ }),

/***/ "./node_modules/preact/hooks/dist/hooks.module.js":
/*!********************************************************!*\
  !*** ./node_modules/preact/hooks/dist/hooks.module.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   useCallback: () => (/* binding */ q),
/* harmony export */   useContext: () => (/* binding */ x),
/* harmony export */   useDebugValue: () => (/* binding */ P),
/* harmony export */   useEffect: () => (/* binding */ y),
/* harmony export */   useErrorBoundary: () => (/* binding */ b),
/* harmony export */   useId: () => (/* binding */ g),
/* harmony export */   useImperativeHandle: () => (/* binding */ F),
/* harmony export */   useLayoutEffect: () => (/* binding */ _),
/* harmony export */   useMemo: () => (/* binding */ T),
/* harmony export */   useReducer: () => (/* binding */ p),
/* harmony export */   useRef: () => (/* binding */ A),
/* harmony export */   useState: () => (/* binding */ h)
/* harmony export */ });
/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.module.js");
var t,r,u,i,o=0,f=[],c=preact__WEBPACK_IMPORTED_MODULE_0__.options,e=c.__b,a=c.__r,v=c.diffed,l=c.__c,m=c.unmount,s=c.__;function d(n,t){c.__h&&c.__h(r,n,o||t),o=0;var u=r.__H||(r.__H={__:[],__h:[]});return n>=u.__.length&&u.__.push({}),u.__[n]}function h(n){return o=1,p(D,n)}function p(n,u,i){var o=d(t++,2);if(o.t=n,!o.__c&&(o.__=[i?i(u):D(void 0,u),function(n){var t=o.__N?o.__N[0]:o.__[0],r=o.t(t,n);t!==r&&(o.__N=[r,o.__[1]],o.__c.setState({}))}],o.__c=r,!r.u)){var f=function(n,t,r){if(!o.__c.__H)return!0;var u=o.__c.__H.__.filter(function(n){return!!n.__c});if(u.every(function(n){return!n.__N}))return!c||c.call(this,n,t,r);var i=!1;return u.forEach(function(n){if(n.__N){var t=n.__[0];n.__=n.__N,n.__N=void 0,t!==n.__[0]&&(i=!0)}}),!(!i&&o.__c.props===n)&&(!c||c.call(this,n,t,r))};r.u=!0;var c=r.shouldComponentUpdate,e=r.componentWillUpdate;r.componentWillUpdate=function(n,t,r){if(this.__e){var u=c;c=void 0,f(n,t,r),c=u}e&&e.call(this,n,t,r)},r.shouldComponentUpdate=f}return o.__N||o.__}function y(n,u){var i=d(t++,3);!c.__s&&C(i.__H,u)&&(i.__=n,i.i=u,r.__H.__h.push(i))}function _(n,u){var i=d(t++,4);!c.__s&&C(i.__H,u)&&(i.__=n,i.i=u,r.__h.push(i))}function A(n){return o=5,T(function(){return{current:n}},[])}function F(n,t,r){o=6,_(function(){return"function"==typeof n?(n(t()),function(){return n(null)}):n?(n.current=t(),function(){return n.current=null}):void 0},null==r?r:r.concat(n))}function T(n,r){var u=d(t++,7);return C(u.__H,r)&&(u.__=n(),u.__H=r,u.__h=n),u.__}function q(n,t){return o=8,T(function(){return n},t)}function x(n){var u=r.context[n.__c],i=d(t++,9);return i.c=n,u?(null==i.__&&(i.__=!0,u.sub(r)),u.props.value):n.__}function P(n,t){c.useDebugValue&&c.useDebugValue(t?t(n):n)}function b(n){var u=d(t++,10),i=h();return u.__=n,r.componentDidCatch||(r.componentDidCatch=function(n,t){u.__&&u.__(n,t),i[1](n)}),[i[0],function(){i[1](void 0)}]}function g(){var n=d(t++,11);if(!n.__){for(var u=r.__v;null!==u&&!u.__m&&null!==u.__;)u=u.__;var i=u.__m||(u.__m=[0,0]);n.__="P"+i[0]+"-"+i[1]++}return n.__}function j(){for(var n;n=f.shift();)if(n.__P&&n.__H)try{n.__H.__h.forEach(z),n.__H.__h.forEach(B),n.__H.__h=[]}catch(t){n.__H.__h=[],c.__e(t,n.__v)}}c.__b=function(n){r=null,e&&e(n)},c.__=function(n,t){n&&t.__k&&t.__k.__m&&(n.__m=t.__k.__m),s&&s(n,t)},c.__r=function(n){a&&a(n),t=0;var i=(r=n.__c).__H;i&&(u===r?(i.__h=[],r.__h=[],i.__.forEach(function(n){n.__N&&(n.__=n.__N),n.i=n.__N=void 0})):(i.__h.forEach(z),i.__h.forEach(B),i.__h=[],t=0)),u=r},c.diffed=function(n){v&&v(n);var t=n.__c;t&&t.__H&&(t.__H.__h.length&&(1!==f.push(t)&&i===c.requestAnimationFrame||((i=c.requestAnimationFrame)||w)(j)),t.__H.__.forEach(function(n){n.i&&(n.__H=n.i),n.i=void 0})),u=r=null},c.__c=function(n,t){t.some(function(n){try{n.__h.forEach(z),n.__h=n.__h.filter(function(n){return!n.__||B(n)})}catch(r){t.some(function(n){n.__h&&(n.__h=[])}),t=[],c.__e(r,n.__v)}}),l&&l(n,t)},c.unmount=function(n){m&&m(n);var t,r=n.__c;r&&r.__H&&(r.__H.__.forEach(function(n){try{z(n)}catch(n){t=n}}),r.__H=void 0,t&&c.__e(t,r.__v))};var k="function"==typeof requestAnimationFrame;function w(n){var t,r=function(){clearTimeout(u),k&&cancelAnimationFrame(t),setTimeout(n)},u=setTimeout(r,100);k&&(t=requestAnimationFrame(r))}function z(n){var t=r,u=n.__c;"function"==typeof u&&(n.__c=void 0,u()),r=t}function B(n){var t=r;n.__c=n.__(),r=t}function C(n,t){return!n||n.length!==t.length||t.some(function(t,r){return t!==n[r]})}function D(n,t){return"function"==typeof t?t(n):t}
//# sourceMappingURL=hooks.module.js.map


/***/ }),

/***/ "./node_modules/preact/jsx-runtime/dist/jsxRuntime.module.js":
/*!*******************************************************************!*\
  !*** ./node_modules/preact/jsx-runtime/dist/jsxRuntime.module.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Fragment: () => (/* reexport safe */ preact__WEBPACK_IMPORTED_MODULE_0__.Fragment),
/* harmony export */   jsx: () => (/* binding */ u),
/* harmony export */   jsxAttr: () => (/* binding */ l),
/* harmony export */   jsxDEV: () => (/* binding */ u),
/* harmony export */   jsxEscape: () => (/* binding */ _),
/* harmony export */   jsxTemplate: () => (/* binding */ a),
/* harmony export */   jsxs: () => (/* binding */ u)
/* harmony export */ });
/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.module.js");
var t=/["&<]/;function n(r){if(0===r.length||!1===t.test(r))return r;for(var e=0,n=0,o="",f="";n<r.length;n++){switch(r.charCodeAt(n)){case 34:f="&quot;";break;case 38:f="&amp;";break;case 60:f="&lt;";break;default:continue}n!==e&&(o+=r.slice(e,n)),o+=f,e=n+1}return n!==e&&(o+=r.slice(e,n)),o}var o=/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i,f=0,i=Array.isArray;function u(e,t,n,o,i,u){t||(t={});var a,c,p=t;if("ref"in p)for(c in p={},t)"ref"==c?a=t[c]:p[c]=t[c];var l={type:e,props:p,key:n,ref:a,__k:null,__:null,__b:0,__e:null,__d:void 0,__c:null,constructor:void 0,__v:--f,__i:-1,__u:0,__source:i,__self:u};if("function"==typeof e&&(a=e.defaultProps))for(c in a)void 0===p[c]&&(p[c]=a[c]);return preact__WEBPACK_IMPORTED_MODULE_0__.options.vnode&&preact__WEBPACK_IMPORTED_MODULE_0__.options.vnode(l),l}function a(r){var t=u(preact__WEBPACK_IMPORTED_MODULE_0__.Fragment,{tpl:r,exprs:[].slice.call(arguments,1)});return t.key=t.__v,t}var c={},p=/[A-Z]/g;function l(e,t){if(preact__WEBPACK_IMPORTED_MODULE_0__.options.attr){var f=preact__WEBPACK_IMPORTED_MODULE_0__.options.attr(e,t);if("string"==typeof f)return f}if("ref"===e||"key"===e)return"";if("style"===e&&"object"==typeof t){var i="";for(var u in t){var a=t[u];if(null!=a&&""!==a){var l="-"==u[0]?u:c[u]||(c[u]=u.replace(p,"-$&").toLowerCase()),_=";";"number"!=typeof a||l.startsWith("--")||o.test(l)||(_="px;"),i=i+l+":"+a+_}}return e+'="'+i+'"'}return null==t||!1===t||"function"==typeof t||"object"==typeof t?"":!0===t?e:e+'="'+n(t)+'"'}function _(r){if(null==r||"boolean"==typeof r||"function"==typeof r)return null;if("object"==typeof r){if(void 0===r.constructor)return r;if(i(r)){for(var e=0;e<r.length;e++)r[e]=_(r[e]);return r}}return n(""+r)}
//# sourceMappingURL=jsxRuntime.module.js.map


/***/ }),

/***/ "./app/static/pages/globals.css":
/*!**************************************!*\
  !*** ./app/static/pages/globals.css ***!
  \**************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_globals_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../../node_modules/css-loader/dist/cjs.js!../../../node_modules/postcss-loader/dist/cjs.js!./globals.css */ "./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js!./app/static/pages/globals.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());

      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
    
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_globals_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);


if (true) {
  if (!_node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_globals_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals || module.hot.invalidate) {
    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {
  if (!a && b || a && !b) {
    return false;
  }
  var p;
  for (p in a) {
    if (isNamedExport && p === "default") {
      // eslint-disable-next-line no-continue
      continue;
    }
    if (a[p] !== b[p]) {
      return false;
    }
  }
  for (p in b) {
    if (isNamedExport && p === "default") {
      // eslint-disable-next-line no-continue
      continue;
    }
    if (!a[p]) {
      return false;
    }
  }
  return true;
};
    var isNamedExport = !_node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_globals_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals;
    var oldLocals = isNamedExport ? _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_globals_css__WEBPACK_IMPORTED_MODULE_6__ : _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_globals_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals;

    module.hot.accept(
      /*! !!../../../node_modules/css-loader/dist/cjs.js!../../../node_modules/postcss-loader/dist/cjs.js!./globals.css */ "./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js!./app/static/pages/globals.css",
      __WEBPACK_OUTDATED_DEPENDENCIES__ => { /* harmony import */ _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_globals_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../../node_modules/css-loader/dist/cjs.js!../../../node_modules/postcss-loader/dist/cjs.js!./globals.css */ "./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js!./app/static/pages/globals.css");
(function () {
        if (!isEqualLocals(oldLocals, isNamedExport ? _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_globals_css__WEBPACK_IMPORTED_MODULE_6__ : _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_globals_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals, isNamedExport)) {
                module.hot.invalidate();

                return;
              }

              oldLocals = isNamedExport ? _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_globals_css__WEBPACK_IMPORTED_MODULE_6__ : _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_globals_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals;

              update(_node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_globals_css__WEBPACK_IMPORTED_MODULE_6__["default"]);
      })(__WEBPACK_OUTDATED_DEPENDENCIES__); }
    )
  }

  module.hot.dispose(function() {
    update();
  });
}



       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_globals_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_globals_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_globals_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./node_modules/@egjs/preact-flicking/dist/flicking.css":
/*!**************************************************************!*\
  !*** ./node_modules/@egjs/preact-flicking/dist/flicking.css ***!
  \**************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../../style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../../style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../../style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../../style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../../style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _css_loader_dist_cjs_js_postcss_loader_dist_cjs_js_flicking_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../../css-loader/dist/cjs.js!../../../postcss-loader/dist/cjs.js!./flicking.css */ "./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js!./node_modules/@egjs/preact-flicking/dist/flicking.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());

      options.insert = _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
    
options.domAPI = (_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_css_loader_dist_cjs_js_postcss_loader_dist_cjs_js_flicking_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);


if (true) {
  if (!_css_loader_dist_cjs_js_postcss_loader_dist_cjs_js_flicking_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals || module.hot.invalidate) {
    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {
  if (!a && b || a && !b) {
    return false;
  }
  var p;
  for (p in a) {
    if (isNamedExport && p === "default") {
      // eslint-disable-next-line no-continue
      continue;
    }
    if (a[p] !== b[p]) {
      return false;
    }
  }
  for (p in b) {
    if (isNamedExport && p === "default") {
      // eslint-disable-next-line no-continue
      continue;
    }
    if (!a[p]) {
      return false;
    }
  }
  return true;
};
    var isNamedExport = !_css_loader_dist_cjs_js_postcss_loader_dist_cjs_js_flicking_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals;
    var oldLocals = isNamedExport ? _css_loader_dist_cjs_js_postcss_loader_dist_cjs_js_flicking_css__WEBPACK_IMPORTED_MODULE_6__ : _css_loader_dist_cjs_js_postcss_loader_dist_cjs_js_flicking_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals;

    module.hot.accept(
      /*! !!../../../css-loader/dist/cjs.js!../../../postcss-loader/dist/cjs.js!./flicking.css */ "./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js!./node_modules/@egjs/preact-flicking/dist/flicking.css",
      __WEBPACK_OUTDATED_DEPENDENCIES__ => { /* harmony import */ _css_loader_dist_cjs_js_postcss_loader_dist_cjs_js_flicking_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../../css-loader/dist/cjs.js!../../../postcss-loader/dist/cjs.js!./flicking.css */ "./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js!./node_modules/@egjs/preact-flicking/dist/flicking.css");
(function () {
        if (!isEqualLocals(oldLocals, isNamedExport ? _css_loader_dist_cjs_js_postcss_loader_dist_cjs_js_flicking_css__WEBPACK_IMPORTED_MODULE_6__ : _css_loader_dist_cjs_js_postcss_loader_dist_cjs_js_flicking_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals, isNamedExport)) {
                module.hot.invalidate();

                return;
              }

              oldLocals = isNamedExport ? _css_loader_dist_cjs_js_postcss_loader_dist_cjs_js_flicking_css__WEBPACK_IMPORTED_MODULE_6__ : _css_loader_dist_cjs_js_postcss_loader_dist_cjs_js_flicking_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals;

              update(_css_loader_dist_cjs_js_postcss_loader_dist_cjs_js_flicking_css__WEBPACK_IMPORTED_MODULE_6__["default"]);
      })(__WEBPACK_OUTDATED_DEPENDENCIES__); }
    )
  }

  module.hot.dispose(function() {
    update();
  });
}



       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_css_loader_dist_cjs_js_postcss_loader_dist_cjs_js_flicking_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _css_loader_dist_cjs_js_postcss_loader_dist_cjs_js_flicking_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _css_loader_dist_cjs_js_postcss_loader_dist_cjs_js_flicking_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {



var stylesInDOM = [];
function getIndexByIdentifier(identifier) {
  var result = -1;
  for (var i = 0; i < stylesInDOM.length; i++) {
    if (stylesInDOM[i].identifier === identifier) {
      result = i;
      break;
    }
  }
  return result;
}
function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];
  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var indexByIdentifier = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3],
      supports: item[4],
      layer: item[5]
    };
    if (indexByIdentifier !== -1) {
      stylesInDOM[indexByIdentifier].references++;
      stylesInDOM[indexByIdentifier].updater(obj);
    } else {
      var updater = addElementStyle(obj, options);
      options.byIndex = i;
      stylesInDOM.splice(i, 0, {
        identifier: identifier,
        updater: updater,
        references: 1
      });
    }
    identifiers.push(identifier);
  }
  return identifiers;
}
function addElementStyle(obj, options) {
  var api = options.domAPI(options);
  api.update(obj);
  var updater = function updater(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {
        return;
      }
      api.update(obj = newObj);
    } else {
      api.remove();
    }
  };
  return updater;
}
module.exports = function (list, options) {
  options = options || {};
  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];
    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDOM[index].references--;
    }
    var newLastIdentifiers = modulesToDom(newList, options);
    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];
      var _index = getIndexByIdentifier(_identifier);
      if (stylesInDOM[_index].references === 0) {
        stylesInDOM[_index].updater();
        stylesInDOM.splice(_index, 1);
      }
    }
    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {



var memo = {};

/* istanbul ignore next  */
function getTarget(target) {
  if (typeof memo[target] === "undefined") {
    var styleTarget = document.querySelector(target);

    // Special case to return head of iframe instead of iframe itself
    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
      try {
        // This will throw an exception if access to iframe is blocked
        // due to cross-origin restrictions
        styleTarget = styleTarget.contentDocument.head;
      } catch (e) {
        // istanbul ignore next
        styleTarget = null;
      }
    }
    memo[target] = styleTarget;
  }
  return memo[target];
}

/* istanbul ignore next  */
function insertBySelector(insert, style) {
  var target = getTarget(insert);
  if (!target) {
    throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
  }
  target.appendChild(style);
}
module.exports = insertBySelector;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {



/* istanbul ignore next  */
function insertStyleElement(options) {
  var element = document.createElement("style");
  options.setAttributes(element, options.attributes);
  options.insert(element, options.options);
  return element;
}
module.exports = insertStyleElement;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



/* istanbul ignore next  */
function setAttributesWithoutAttributes(styleElement) {
  var nonce =  true ? __webpack_require__.nc : 0;
  if (nonce) {
    styleElement.setAttribute("nonce", nonce);
  }
}
module.exports = setAttributesWithoutAttributes;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {



/* istanbul ignore next  */
function apply(styleElement, options, obj) {
  var css = "";
  if (obj.supports) {
    css += "@supports (".concat(obj.supports, ") {");
  }
  if (obj.media) {
    css += "@media ".concat(obj.media, " {");
  }
  var needLayer = typeof obj.layer !== "undefined";
  if (needLayer) {
    css += "@layer".concat(obj.layer.length > 0 ? " ".concat(obj.layer) : "", " {");
  }
  css += obj.css;
  if (needLayer) {
    css += "}";
  }
  if (obj.media) {
    css += "}";
  }
  if (obj.supports) {
    css += "}";
  }
  var sourceMap = obj.sourceMap;
  if (sourceMap && typeof btoa !== "undefined") {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  }

  // For old IE
  /* istanbul ignore if  */
  options.styleTagTransform(css, styleElement, options.options);
}
function removeStyleElement(styleElement) {
  // istanbul ignore if
  if (styleElement.parentNode === null) {
    return false;
  }
  styleElement.parentNode.removeChild(styleElement);
}

/* istanbul ignore next  */
function domAPI(options) {
  if (typeof document === "undefined") {
    return {
      update: function update() {},
      remove: function remove() {}
    };
  }
  var styleElement = options.insertStyleElement(options);
  return {
    update: function update(obj) {
      apply(styleElement, options, obj);
    },
    remove: function remove() {
      removeStyleElement(styleElement);
    }
  };
}
module.exports = domAPI;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {



/* istanbul ignore next  */
function styleTagTransform(css, styleElement) {
  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css;
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild);
    }
    styleElement.appendChild(document.createTextNode(css));
  }
}
module.exports = styleTagTransform;

/***/ }),

/***/ "./app/static/pages/components/Block1.tsx":
/*!************************************************!*\
  !*** ./app/static/pages/components/Block1.tsx ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = Block1;
var jsx_runtime_1 = __webpack_require__(/*! preact/jsx-runtime */ "./node_modules/preact/jsx-runtime/dist/jsxRuntime.module.js");
var preact_router_1 = __webpack_require__(/*! preact-router */ "./node_modules/preact-router/dist/preact-router.mjs");
var image_hero_jpg_1 = __importDefault(__webpack_require__(/*! ../../assets/desktop/image-hero.jpg */ "./app/static/assets/desktop/image-hero.jpg"));
var image_hero_jpg_2 = __importDefault(__webpack_require__(/*! ../../assets/tablet/image-hero.jpg */ "./app/static/assets/tablet/image-hero.jpg"));
var image_hero_jpg_3 = __importDefault(__webpack_require__(/*! ../../assets/mobile/image-hero.jpg */ "./app/static/assets/mobile/image-hero.jpg"));
var items = {
    title: 'Branding & website design agency',
    description: 'We specialize in visual storytelling by creating cohesive brand and website design solutions for small businesses, giving lasting impressions to audiences in a digital world.',
    button: 'Learn More',
};
var linkItems = {
    title: 'Learn More',
    href: '#',
};
function Block1() {
    return ((0, jsx_runtime_1.jsxs)("div", { className: "relative mb-[96px] flex w-full max-w-[calc(1275px+39px)] flex-col-reverse items-center justify-between md:mb-0 md:h-[606px] md:flex-row md:items-start md:self-end md:pl-[39px] xl:h-[800px]", children: [(0, jsx_runtime_1.jsxs)("div", { className: "relative z-[1] mt-[56px] flex w-fit max-w-[730px] flex-col items-center gap-[40px] px-[24px] md:mt-[77px] md:w-full md:items-start md:gap-[48px] md:px-0 xl:mt-[112px]", children: [(0, jsx_runtime_1.jsxs)("section", { className: "flex flex-col gap-[20px] md:gap-[39px]", children: [(0, jsx_runtime_1.jsx)("h1", { className: "w-full md:max-w-[398px] xl:max-w-[680px]", children: items.title }), (0, jsx_runtime_1.jsx)("p", { className: "w-full md:max-w-[398px] xl:max-w-[540px]", children: items.description })] }), (0, jsx_runtime_1.jsx)(preact_router_1.Link, { className: "flex h-[72px] w-[177px] items-center justify-center self-start bg-[#F94F4F] text-[18px] font-extrabold text-white transition hover:bg-[#FF9393]", href: linkItems.href, children: linkItems.title })] }), (0, jsx_runtime_1.jsxs)("picture", { className: "right-0 w-full md:absolute md:h-[608px] md:w-fit xl:h-[800px]", children: [(0, jsx_runtime_1.jsx)("source", { media: "(max-width: 768px)", srcSet: image_hero_jpg_3.default }), (0, jsx_runtime_1.jsx)("source", { media: "(max-width: 1024px)", srcSet: image_hero_jpg_2.default }), (0, jsx_runtime_1.jsx)("img", { className: "md:object-fit size-full object-cover md:h-[606px] xl:h-[800px]", src: image_hero_jpg_1.default, alt: "men working on computers" })] })] }));
}


/***/ }),

/***/ "./app/static/pages/components/Block2.tsx":
/*!************************************************!*\
  !*** ./app/static/pages/components/Block2.tsx ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = Block2;
var jsx_runtime_1 = __webpack_require__(/*! preact/jsx-runtime */ "./node_modules/preact/jsx-runtime/dist/jsxRuntime.module.js");
var preact_router_1 = __webpack_require__(/*! preact-router */ "./node_modules/preact-router/dist/preact-router.mjs");
var image_strategic_jpg_1 = __importDefault(__webpack_require__(/*! ../../assets/desktop/image-strategic.jpg */ "./app/static/assets/desktop/image-strategic.jpg"));
var image_strategic_jpg_2 = __importDefault(__webpack_require__(/*! ../../assets/mobile/image-strategic.jpg */ "./app/static/assets/mobile/image-strategic.jpg"));
var bg_pattern_wave_red_svg_1 = __importDefault(__webpack_require__(/*! ../../assets/desktop/bg-pattern-wave-red.svg */ "./app/static/assets/desktop/bg-pattern-wave-red.svg"));
var items = {
    title: 'Design is strategic.',
    description: '“A well-crafted design strategy consistently produces desired outcomes and brand awareness. We are firm believers that success lies in creative collaboration with our clients.”',
    linkTitle: 'Schedule a Call',
};
function Block2() {
    return ((0, jsx_runtime_1.jsxs)("div", { className: "relative flex w-full flex-col md:h-[648px] md:flex-row  md:justify-end lg:h-[750px] xl:h-[984px]", children: [(0, jsx_runtime_1.jsxs)("picture", { children: [(0, jsx_runtime_1.jsx)("source", { media: "(max-width: 768px)", srcSet: image_strategic_jpg_2.default }), (0, jsx_runtime_1.jsx)("img", { className: "left-0 object-cover md:absolute md:h-[658px] md:w-[735px] md:object-[100%_0%] xl:h-[984px] xl:object-center", height: 984, width: 735, src: image_strategic_jpg_1.default, alt: "strategic" })] }), (0, jsx_runtime_1.jsx)("div", { className: "relative flex items-center bg-[#191921] py-[72px] md:h-[538px] md:w-[390px] md:py-0 md:pl-[69px] md:pr-[40px] lg:h-[560px] lg:w-[530px] lg:pl-[90px] lg:pr-[60px] xl:h-[784px] xl:w-[705px] xl:pl-[154px] xl:pr-[106px]", children: (0, jsx_runtime_1.jsxs)("div", { className: "flex flex-col gap-[48px] px-[24px] md:px-0", children: [(0, jsx_runtime_1.jsx)("img", { className: "absolute top-[-15px] h-[28px] w-[62px] md:left-[-31px] md:top-[220px] xl:left-[-67px] xl:top-[234px] xl:h-[61px] xl:w-[135px]", width: 135, height: 61, src: bg_pattern_wave_red_svg_1.default, alt: "pattern" }), (0, jsx_runtime_1.jsxs)("section", { className: "flex flex-col gap-[32px] md:max-w-[281px] lg:max-w-full xl:gap-[43px]", children: [(0, jsx_runtime_1.jsxs)("h2", { className: "text-white md:max-w-[250px] lg:max-w-full", children: [(0, jsx_runtime_1.jsx)("span", { className: "text-[#F94F4F]", children: items.title.split(' ')[0] }), " ".concat(items.title.split(' ').slice(1).join(' '))] }), (0, jsx_runtime_1.jsx)("p", { className: "text-white", children: items.description })] }), (0, jsx_runtime_1.jsx)(preact_router_1.Link, { className: "font-extrabold text-[#F94F4F] underline underline-offset-[12px] transition hover:text-[#FF9393]", href: "#", children: items.linkTitle })] }) })] }));
}


/***/ }),

/***/ "./app/static/pages/components/Block3.tsx":
/*!************************************************!*\
  !*** ./app/static/pages/components/Block3.tsx ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = Block3;
var jsx_runtime_1 = __webpack_require__(/*! preact/jsx-runtime */ "./node_modules/preact/jsx-runtime/dist/jsxRuntime.module.js");
var title = 'Our approach for creating a winning brand';
var items = [
    {
        title: 'Brand Strategy',
        description: 'Brand strategy is critical for long-term success. Outshining competitors and capturing the target audience are key.',
    },
    {
        title: 'Brand Design',
        description: 'Keeping the brand design unique and meaningful helps in communicating the brand’s timeless value effectively.',
    },
    {
        title: 'Web Design',
        description: 'A beautifully crafted website is the best tool for brand awareness, and ultimately results in increased revenues. ',
    },
];
function Block3() {
    return ((0, jsx_runtime_1.jsxs)("div", { className: "flex w-full flex-col justify-between md:flex-row xl:justify-end xl:pl-[39px]", children: [(0, jsx_runtime_1.jsx)("div", { className: "relative z-[2] flex w-full justify-center px-[24px] lg:px-0 xl:mr-[-160px] xl:w-fit", children: (0, jsx_runtime_1.jsx)("h2", { className: "z-[2] h-fit w-full max-w-[281px] md:mt-[120px] lg:mt-0 xl:mt-[200px] xl:max-w-[540px] xl:pl-0", children: title }) }), (0, jsx_runtime_1.jsx)("div", { className: "z-[1] flex items-center justify-center bg-[#F94F4F] md:mt-[-120px] md:h-[797px] md:w-[1400px] lg:mt-[-200px] xl:h-[1100px] xl:w-[895px] xl:justify-end xl:pr-[106px]", children: (0, jsx_runtime_1.jsx)("ul", { className: "flex flex-col gap-[40px] xl:gap-[56px]", children: items.map(function (item, index) { return ((0, jsx_runtime_1.jsxs)("li", { className: "flex flex-col gap-[24px] md:h-[200px] md:w-[355px] xl:w-[504px]", children: [(0, jsx_runtime_1.jsx)("span", { className: "absolute text-[80px] font-extrabold leading-[88px] text-white/25", children: (index + 1).toLocaleString('en-US', {
                                    minimumIntegerDigits: 2,
                                    useGrouping: false,
                                }) }), (0, jsx_runtime_1.jsxs)("section", { className: "ml-[59px] mt-[44px] flex flex-col gap-[24px]", children: [(0, jsx_runtime_1.jsx)("h3", { className: "text-white", children: item.title }), (0, jsx_runtime_1.jsx)("p", { className: "text-white", children: item.description })] })] }, item)); }) }) })] }));
}


/***/ }),

/***/ "./app/static/pages/components/Block4.tsx":
/*!************************************************!*\
  !*** ./app/static/pages/components/Block4.tsx ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = Block4;
var jsx_runtime_1 = __webpack_require__(/*! preact/jsx-runtime */ "./node_modules/preact/jsx-runtime/dist/jsxRuntime.module.js");
var image_slide_1_jpg_1 = __importDefault(__webpack_require__(/*! ../../assets/desktop/image-slide-1.jpg */ "./app/static/assets/desktop/image-slide-1.jpg"));
var image_slide_2_jpg_1 = __importDefault(__webpack_require__(/*! ../../assets/desktop/image-slide-2.jpg */ "./app/static/assets/desktop/image-slide-2.jpg"));
var image_slide_3_jpg_1 = __importDefault(__webpack_require__(/*! ../../assets/desktop/image-slide-3.jpg */ "./app/static/assets/desktop/image-slide-3.jpg"));
var bg_pattern_wavy_white_svg_1 = __importDefault(__webpack_require__(/*! ../../assets/desktop/bg-pattern-wavy-white.svg */ "./app/static/assets/desktop/bg-pattern-wavy-white.svg"));
var hooks_1 = __webpack_require__(/*! preact/hooks */ "./node_modules/preact/hooks/dist/hooks.module.js");
var preact_flicking_1 = __importDefault(__webpack_require__(/*! @egjs/preact-flicking */ "./node_modules/@egjs/preact-flicking/dist/flicking.esm.js"));
__webpack_require__(/*! @egjs/preact-flicking/dist/flicking.css */ "./node_modules/@egjs/preact-flicking/dist/flicking.css");
var TitleKey;
(function (TitleKey) {
    TitleKey[TitleKey["guidelines"] = 0] = "guidelines";
    TitleKey[TitleKey["merchandise"] = 1] = "merchandise";
    TitleKey[TitleKey["design"] = 2] = "design";
})(TitleKey || (TitleKey = {}));
var title = (_a = {},
    _a[TitleKey.guidelines] = {
        mainTitle: 'Brand naming & guidelines',
        title: 'Lean Product Roadmap',
        description: '2019 Project',
    },
    _a[TitleKey.merchandise] = {
        mainTitle: 'Brand identity & merchandise',
        title: 'New Majestic Hotel',
        description: '2018 Project',
    },
    _a[TitleKey.design] = {
        mainTitle: 'Brand identity & web design',
        title: 'Crypto Dashboard',
        description: '2016 Project',
    },
    _a);
var titlesButtons = {
    previous: 'previous slide',
    next: 'next slide',
};
function Block4() {
    var flicking = (0, hooks_1.useRef)();
    var mainTitleRef = (0, hooks_1.useRef)(null);
    var sectionRef = (0, hooks_1.useRef)(null);
    var _a = (0, hooks_1.useState)(TitleKey.guidelines), currentSlide = _a[0], setCurrentSlide = _a[1];
    var _b = (0, hooks_1.useState)(false), isPlaying = _b[0], setIsPlaying = _b[1];
    return ((0, jsx_runtime_1.jsxs)("div", { className: "relative flex w-full flex-col-reverse justify-start md:min-h-[472px] md:flex-row xl:min-h-[728px]", children: [(0, jsx_runtime_1.jsxs)("div", { className: "relative z-[1] flex items-center justify-center bg-[#191921] pl-[40px] md:h-[352px] md:w-1/2 md:max-w-[735px] xl:h-[528px]", children: [(0, jsx_runtime_1.jsx)("img", { alt: "pattern", className: "absolute right-[-31px] top-[126px] z-[2] hidden h-[28px] w-[62px] md:block xl:right-[-67px] xl:top-[186px] xl:h-[60px] xl:w-[134px]", src: bg_pattern_wavy_white_svg_1.default, width: 134, height: 60 }), (0, jsx_runtime_1.jsxs)("div", { className: "flex h-[233px] w-[390px] flex-col justify-center gap-[51px] xl:w-[445px]", children: [(0, jsx_runtime_1.jsx)("h2", { ref: mainTitleRef, className: "animationElement max-w-[281px] text-white xl:max-w-full", children: title[currentSlide].mainTitle }), (0, jsx_runtime_1.jsxs)("div", { className: "flex gap-[16px]", children: [(0, jsx_runtime_1.jsx)("button", { disabled: isPlaying, onClick: function () {
                                            var _a;
                                            void ((_a = flicking.current) === null || _a === void 0 ? void 0 : _a.prev());
                                        }, title: "previous slide", type: "button", className: "previous relative z-40 size-[40px]", children: (0, jsx_runtime_1.jsxs)("svg", { width: "40", height: "40", xmlns: "http://www.w3.org/2000/svg", children: [(0, jsx_runtime_1.jsx)("title", { children: titlesButtons.previous }), (0, jsx_runtime_1.jsxs)("g", { transform: "matrix(-1 0 0 1 40 0)", fill: "none", fillRule: "evenodd", children: [(0, jsx_runtime_1.jsx)("circle", { cx: "20", cy: "20", r: "19.5" }), (0, jsx_runtime_1.jsx)("path", { strokeWidth: "2", d: "M17.5 15l5 5-5 5" })] })] }) }), (0, jsx_runtime_1.jsx)("button", { disabled: isPlaying, onClick: function () {
                                            var _a;
                                            void ((_a = flicking.current) === null || _a === void 0 ? void 0 : _a.next());
                                        }, title: "next slide", type: "button", className: "previous relative z-40 size-[40px]", children: (0, jsx_runtime_1.jsxs)("svg", { width: "40", height: "40", xmlns: "http://www.w3.org/2000/svg", children: [(0, jsx_runtime_1.jsx)("title", { children: titlesButtons.next }), (0, jsx_runtime_1.jsxs)("g", { fill: "none", fillRule: "evenodd", children: [(0, jsx_runtime_1.jsx)("circle", { cx: "20", cy: "20", r: "19.5" }), (0, jsx_runtime_1.jsx)("path", { strokeWidth: "2", d: "M17.5 15l5 5-5 5" })] })] }) })] })] })] }), (0, jsx_runtime_1.jsxs)("div", { className: "relative right-0 z-0 md:absolute md:w-3/5 xl:h-[728px] xl:w-[895px] ", children: [(0, jsx_runtime_1.jsxs)(preact_flicking_1.default, { onMoveStart: function () {
                            var _a, _b;
                            setIsPlaying(true);
                            (_a = mainTitleRef.current) === null || _a === void 0 ? void 0 : _a.classList.add('animateTransition');
                            (_b = sectionRef.current) === null || _b === void 0 ? void 0 : _b.classList.add('animateTransition');
                        }, onMoveEnd: function () {
                            var _a, _b;
                            setIsPlaying(false);
                            (_a = mainTitleRef.current) === null || _a === void 0 ? void 0 : _a.classList.remove('animateTransition');
                            (_b = sectionRef.current) === null || _b === void 0 ? void 0 : _b.classList.remove('animateTransition');
                        }, ref: flicking, circular: true, onChanged: function (e) {
                            setCurrentSlide(e.index);
                        }, children: [(0, jsx_runtime_1.jsx)("div", { className: "panel image-container", children: (0, jsx_runtime_1.jsx)("img", { className: "carouselImage", src: image_slide_1_jpg_1.default, alt: "Slide 1" }) }, TitleKey.guidelines), (0, jsx_runtime_1.jsx)("div", { className: "panel image-container", children: (0, jsx_runtime_1.jsx)("img", { className: "carouselImage", src: image_slide_2_jpg_1.default, alt: "Slide 2" }) }, TitleKey.merchandise), (0, jsx_runtime_1.jsx)("div", { className: "panel image-container", children: (0, jsx_runtime_1.jsx)("img", { className: "carouselImage", src: image_slide_3_jpg_1.default, alt: "Slide 3" }) }, TitleKey.design)] }), (0, jsx_runtime_1.jsxs)("section", { ref: sectionRef, className: "animationElement absolute bottom-[45px] right-[40px] z-[1] flex flex-col text-end xl:bottom-[68px] xl:right-[154px]", children: [(0, jsx_runtime_1.jsx)("h3", { className: "text-white", children: title[currentSlide].title }), (0, jsx_runtime_1.jsx)("p", { className: "text-white", children: title[currentSlide].description })] })] })] }));
}


/***/ }),

/***/ "./app/static/pages/components/Footer.tsx":
/*!************************************************!*\
  !*** ./app/static/pages/components/Footer.tsx ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = Footer;
var jsx_runtime_1 = __webpack_require__(/*! preact/jsx-runtime */ "./node_modules/preact/jsx-runtime/dist/jsxRuntime.module.js");
var bg_pattern_wave_red_svg_1 = __importDefault(__webpack_require__(/*! ../../assets/desktop/bg-pattern-wave-red.svg */ "./app/static/assets/desktop/bg-pattern-wave-red.svg"));
var items = {
    title: 'Let’s build something great together.',
    buttonDescription: 'Schedule a Call',
};
function Footer() {
    return ((0, jsx_runtime_1.jsxs)("footer", { className: "mx-auto mb-[101px] mt-[100px] flex w-full max-w-[1342px] items-center overflow-hidden px-[24px] md:mt-[70px] md:px-[40px] xl:mb-[115px] xl:ml-[-67px] xl:mt-[120px] xl:px-0", children: [(0, jsx_runtime_1.jsx)("img", { className: "hidden xl:block", alt: "pattern", src: bg_pattern_wave_red_svg_1.default, width: 134, height: 60 }), (0, jsx_runtime_1.jsxs)("div", { className: "flex w-full flex-col justify-between gap-[47px] md:flex-row md:items-center xl:ml-[98px]", children: [(0, jsx_runtime_1.jsx)("h2", { className: "md:max-w-[398px] xl:max-w-[635px]", children: items.title }), (0, jsx_runtime_1.jsx)("button", { type: "button", className: "h-[64px] w-[199px] bg-[#F94F4F] text-[16px] font-extrabold text-white transition hover:bg-[#FF9393]", children: items.buttonDescription })] })] }));
}


/***/ }),

/***/ "./app/static/pages/components/Navbar.tsx":
/*!************************************************!*\
  !*** ./app/static/pages/components/Navbar.tsx ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = Navbar;
var jsx_runtime_1 = __webpack_require__(/*! preact/jsx-runtime */ "./node_modules/preact/jsx-runtime/dist/jsxRuntime.module.js");
var hooks_1 = __webpack_require__(/*! preact/hooks */ "./node_modules/preact/hooks/dist/hooks.module.js");
var logo_svg_1 = __importDefault(__webpack_require__(/*! ../../assets/desktop/logo.svg */ "./app/static/assets/desktop/logo.svg"));
var preact_router_1 = __webpack_require__(/*! preact-router */ "./node_modules/preact-router/dist/preact-router.mjs");
var items = [
    {
        title: 'About',
        href: '#',
    },
    {
        title: 'Service',
        href: '#',
    },
    {
        title: 'Projects',
        href: '#',
    },
];
var buttonTitle = 'Schedule a Call';
function Navbar() {
    var menuButtonRef = (0, hooks_1.useRef)(null);
    function handleOpen() {
        if (menuButtonRef.current) {
            menuButtonRef.current.classList.toggle('open');
        }
    }
    return ((0, jsx_runtime_1.jsxs)("nav", { className: "relative z-[2] flex h-[110px] w-full max-w-[calc(1275px+39px)] items-center justify-between self-end overflow-x-clip pl-[39px] md:h-[178px]", children: [(0, jsx_runtime_1.jsx)("div", { id: "mask", className: "fixed left-0 top-0 z-[1] flex size-full" }), (0, jsx_runtime_1.jsxs)("div", { id: "mobileMenu", className: "absolute right-[26px] top-[110px] z-40 flex h-[292px] w-full max-w-[252px] flex-col items-center gap-[24px] bg-black pt-[32px]", children: [(0, jsx_runtime_1.jsx)("ul", { className: " relative z-40 flex flex-col items-center gap-[24px]", children: items.map(function (item) { return ((0, jsx_runtime_1.jsx)("li", { className: "relative z-40", children: (0, jsx_runtime_1.jsx)(preact_router_1.Link, { className: " relative z-40 text-[18px] leading-[32px] text-white transition-all", href: item.href, children: item.title }) }, item.title)); }) }), (0, jsx_runtime_1.jsx)("button", { type: "button", className: "relative z-40 h-[64px] w-[199px] bg-[#F94F4F] text-[16px] font-extrabold text-white", children: buttonTitle })] }), (0, jsx_runtime_1.jsx)("img", { className: "relative -z-0 flex", src: logo_svg_1.default, alt: "logo" }), (0, jsx_runtime_1.jsxs)("div", { className: "hidden size-full max-w-[438px] items-center gap-[28px] bg-[#F94F4F] pl-[33px] pr-[40px] md:flex lg:max-w-[530px] lg:gap-[50px] lg:pr-[20px] xl:max-w-[47vw] xl:gap-[48px] xl:pl-[69px] xl:pr-0 screen1500:max-w-[705px]", children: [(0, jsx_runtime_1.jsx)("ul", { className: "flex w-full max-w-[190px] justify-between xl:max-w-[225px]", children: items.map(function (item) { return ((0, jsx_runtime_1.jsx)("li", { children: (0, jsx_runtime_1.jsx)(preact_router_1.Link, { className: " leading-[32px] text-white transition-all hover:font-bold", href: item.href, children: item.title }) }, item.title)); }) }), (0, jsx_runtime_1.jsx)("button", { type: "button", className: "h-[64px] min-w-[147px] bg-[#191921] text-[16px] font-extrabold text-white transition hover:bg-[#434356] xl:min-w-[199px]", children: buttonTitle })] }), (0, jsx_runtime_1.jsx)("button", { ref: menuButtonRef, onClick: function () {
                    handleOpen();
                }, id: "mobileNav", title: "mobile navigation", type: "button", className: "absolute right-[24px] z-[2] md:opacity-0" })] }));
}


/***/ }),

/***/ "./app/static/pages/layout.tsx":
/*!*************************************!*\
  !*** ./app/static/pages/layout.tsx ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var jsx_runtime_1 = __webpack_require__(/*! preact/jsx-runtime */ "./node_modules/preact/jsx-runtime/dist/jsxRuntime.module.js");
var preact_1 = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.module.js");
// import DataContext from './_lib/DataContext'; // placeholder
var Navbar_1 = __importDefault(__webpack_require__(/*! ./components/Navbar */ "./app/static/pages/components/Navbar.tsx"));
var page_1 = __importDefault(__webpack_require__(/*! ./page */ "./app/static/pages/page.tsx"));
var Footer_1 = __importDefault(__webpack_require__(/*! ./components/Footer */ "./app/static/pages/components/Footer.tsx"));
__webpack_require__(/*! ./globals.css */ "./app/static/pages/globals.css");
document.body.className =
    'min-h-dvh mx-auto md:min-h-screen max-w-[1440px]  flex flex-col items-center font-commissioner justify-space-between';
function App() {
    return ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsx)(Navbar_1.default, {}), (0, jsx_runtime_1.jsx)("main", { className: "mx-auto mb-auto flex  w-full flex-col items-center overflow-x-clip", children: (0, jsx_runtime_1.jsx)(page_1.default, {}) }), (0, jsx_runtime_1.jsx)(Footer_1.default, {})] }));
}
function Body() {
    return (0, jsx_runtime_1.jsx)(App, {});
}
(0, preact_1.render)((0, jsx_runtime_1.jsx)(Body, {}), document.body);


/***/ }),

/***/ "./app/static/pages/page.tsx":
/*!***********************************!*\
  !*** ./app/static/pages/page.tsx ***!
  \***********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var jsx_runtime_1 = __webpack_require__(/*! preact/jsx-runtime */ "./node_modules/preact/jsx-runtime/dist/jsxRuntime.module.js");
var Block1_1 = __importDefault(__webpack_require__(/*! ./components/Block1 */ "./app/static/pages/components/Block1.tsx"));
var Block2_1 = __importDefault(__webpack_require__(/*! ./components/Block2 */ "./app/static/pages/components/Block2.tsx"));
var Block3_1 = __importDefault(__webpack_require__(/*! ./components/Block3 */ "./app/static/pages/components/Block3.tsx"));
var Block4_1 = __importDefault(__webpack_require__(/*! ./components/Block4 */ "./app/static/pages/components/Block4.tsx"));
var Home = function () {
    return ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsx)(Block1_1.default, {}), (0, jsx_runtime_1.jsx)(Block2_1.default, {}), (0, jsx_runtime_1.jsx)(Block3_1.default, {}), (0, jsx_runtime_1.jsx)(Block4_1.default, {})] }));
};
exports["default"] = Home;


/***/ }),

/***/ "./app/static/assets/desktop/bg-pattern-wave-red.svg":
/*!***********************************************************!*\
  !*** ./app/static/assets/desktop/bg-pattern-wave-red.svg ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "images/8c3a13227cedc28ff49f.svg";

/***/ }),

/***/ "./app/static/assets/desktop/bg-pattern-wavy-white.svg":
/*!*************************************************************!*\
  !*** ./app/static/assets/desktop/bg-pattern-wavy-white.svg ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "images/549bc30aec22dc2bfd51.svg";

/***/ }),

/***/ "./app/static/assets/desktop/image-hero.jpg":
/*!**************************************************!*\
  !*** ./app/static/assets/desktop/image-hero.jpg ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "images/68589f1496e97e711702.jpg";

/***/ }),

/***/ "./app/static/assets/desktop/image-slide-1.jpg":
/*!*****************************************************!*\
  !*** ./app/static/assets/desktop/image-slide-1.jpg ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "images/61ea577f93a852703ca3.jpg";

/***/ }),

/***/ "./app/static/assets/desktop/image-slide-2.jpg":
/*!*****************************************************!*\
  !*** ./app/static/assets/desktop/image-slide-2.jpg ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "images/c02dc940dc3a5899ab81.jpg";

/***/ }),

/***/ "./app/static/assets/desktop/image-slide-3.jpg":
/*!*****************************************************!*\
  !*** ./app/static/assets/desktop/image-slide-3.jpg ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "images/e232c4ceebf129242018.jpg";

/***/ }),

/***/ "./app/static/assets/desktop/image-strategic.jpg":
/*!*******************************************************!*\
  !*** ./app/static/assets/desktop/image-strategic.jpg ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "images/1da0fbce3beeacea8ba8.jpg";

/***/ }),

/***/ "./app/static/assets/desktop/logo.svg":
/*!********************************************!*\
  !*** ./app/static/assets/desktop/logo.svg ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "images/bd6256eaed9209fe195a.svg";

/***/ }),

/***/ "./app/static/assets/mobile/icon-cross.svg":
/*!*************************************************!*\
  !*** ./app/static/assets/mobile/icon-cross.svg ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "images/7f0676df78e74b2858bc.svg";

/***/ }),

/***/ "./app/static/assets/mobile/icon-hamburger.svg":
/*!*****************************************************!*\
  !*** ./app/static/assets/mobile/icon-hamburger.svg ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "images/e7bdcc70ff60955e5c36.svg";

/***/ }),

/***/ "./app/static/assets/mobile/image-hero.jpg":
/*!*************************************************!*\
  !*** ./app/static/assets/mobile/image-hero.jpg ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "images/71252dd8e56f810bab8b.jpg";

/***/ }),

/***/ "./app/static/assets/mobile/image-strategic.jpg":
/*!******************************************************!*\
  !*** ./app/static/assets/mobile/image-strategic.jpg ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "images/56c30bc37cbe9047a5f6.jpg";

/***/ }),

/***/ "./app/static/assets/tablet/image-hero.jpg":
/*!*************************************************!*\
  !*** ./app/static/assets/tablet/image-hero.jpg ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "images/d854e8adff55c325467b.jpg";

/***/ }),

/***/ "./node_modules/preact-router/dist/preact-router.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/preact-router/dist/preact-router.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Link: () => (/* binding */ E),
/* harmony export */   Route: () => (/* binding */ L),
/* harmony export */   Router: () => (/* binding */ D),
/* harmony export */   "default": () => (/* binding */ D),
/* harmony export */   exec: () => (/* binding */ s),
/* harmony export */   getCurrentUrl: () => (/* binding */ R),
/* harmony export */   route: () => (/* binding */ $),
/* harmony export */   useRouter: () => (/* binding */ C)
/* harmony export */ });
/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.module.js");
/* harmony import */ var preact_hooks__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! preact/hooks */ "./node_modules/preact/hooks/dist/hooks.module.js");
var a={};function c(n,t){for(var r in t)n[r]=t[r];return n}function s(n,t,r){var i,o=/(?:\?([^#]*))?(#.*)?$/,e=n.match(o),u={};if(e&&e[1])for(var f=e[1].split("&"),c=0;c<f.length;c++){var s=f[c].split("=");u[decodeURIComponent(s[0])]=decodeURIComponent(s.slice(1).join("="))}n=d(n.replace(o,"")),t=d(t||"");for(var h=Math.max(n.length,t.length),v=0;v<h;v++)if(t[v]&&":"===t[v].charAt(0)){var l=t[v].replace(/(^:|[+*?]+$)/g,""),p=(t[v].match(/[+*?]+$/)||a)[0]||"",m=~p.indexOf("+"),y=~p.indexOf("*"),U=n[v]||"";if(!U&&!y&&(p.indexOf("?")<0||m)){i=!1;break}if(u[l]=decodeURIComponent(U),m||y){u[l]=n.slice(v).map(decodeURIComponent).join("/");break}}else if(t[v]!==n[v]){i=!1;break}return(!0===r.default||!1!==i)&&u}function h(n,t){return n.rank<t.rank?1:n.rank>t.rank?-1:n.index-t.index}function v(n,t){return n.index=t,n.rank=function(n){return n.props.default?0:d(n.props.path).map(l).join("")}(n),n.props}function d(n){return n.replace(/(^\/+|\/+$)/g,"").split("/")}function l(n){return":"==n.charAt(0)?1+"*+?".indexOf(n.charAt(n.length-1))||4:5}var p={},m=[],y=[],U=null,g={url:R()},k=(0,preact__WEBPACK_IMPORTED_MODULE_0__.createContext)(g);function C(){var n=(0,preact_hooks__WEBPACK_IMPORTED_MODULE_1__.useContext)(k);if(n===g){var t=(0,preact_hooks__WEBPACK_IMPORTED_MODULE_1__.useState)()[1];(0,preact_hooks__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function(){return y.push(t),function(){return y.splice(y.indexOf(t),1)}},[])}return[n,$]}function R(){var n;return""+((n=U&&U.location?U.location:U&&U.getCurrentLocation?U.getCurrentLocation():"undefined"!=typeof location?location:p).pathname||"")+(n.search||"")}function $(n,t){return void 0===t&&(t=!1),"string"!=typeof n&&n.url&&(t=n.replace,n=n.url),function(n){for(var t=m.length;t--;)if(m[t].canRoute(n))return!0;return!1}(n)&&function(n,t){void 0===t&&(t="push"),U&&U[t]?U[t](n):"undefined"!=typeof history&&history[t+"State"]&&history[t+"State"](null,null,n)}(n,t?"replace":"push"),I(n)}function I(n){for(var t=!1,r=0;r<m.length;r++)m[r].routeTo(n)&&(t=!0);return t}function M(n){if(n&&n.getAttribute){var t=n.getAttribute("href"),r=n.getAttribute("target");if(t&&t.match(/^\//g)&&(!r||r.match(/^_?self$/i)))return $(t)}}function b(n){return n.stopImmediatePropagation&&n.stopImmediatePropagation(),n.stopPropagation&&n.stopPropagation(),n.preventDefault(),!1}function W(n){if(!(n.ctrlKey||n.metaKey||n.altKey||n.shiftKey||n.button)){var t=n.target;do{if("a"===t.localName&&t.getAttribute("href")){if(t.hasAttribute("data-native")||t.hasAttribute("native"))return;if(M(t))return b(n)}}while(t=t.parentNode)}}var w=!1;function D(n){n.history&&(U=n.history),this.state={url:n.url||R()}}c(D.prototype=new preact__WEBPACK_IMPORTED_MODULE_0__.Component,{shouldComponentUpdate:function(n){return!0!==n.static||n.url!==this.props.url||n.onChange!==this.props.onChange},canRoute:function(n){var t=(0,preact__WEBPACK_IMPORTED_MODULE_0__.toChildArray)(this.props.children);return void 0!==this.g(t,n)},routeTo:function(n){this.setState({url:n});var t=this.canRoute(n);return this.p||this.forceUpdate(),t},componentWillMount:function(){this.p=!0},componentDidMount:function(){var n=this;w||(w=!0,U||addEventListener("popstate",function(){I(R())}),addEventListener("click",W)),m.push(this),U&&(this.u=U.listen(function(t){var r=t.location||t;n.routeTo(""+(r.pathname||"")+(r.search||""))})),this.p=!1},componentWillUnmount:function(){"function"==typeof this.u&&this.u(),m.splice(m.indexOf(this),1)},componentWillUpdate:function(){this.p=!0},componentDidUpdate:function(){this.p=!1},g:function(n,t){n=n.filter(v).sort(h);for(var r=0;r<n.length;r++){var i=n[r],o=s(t,i.props.path,i.props);if(o)return[i,o]}},render:function(n,t){var e,u,f=n.onChange,a=t.url,s=this.c,h=this.g((0,preact__WEBPACK_IMPORTED_MODULE_0__.toChildArray)(n.children),a);if(h&&(u=(0,preact__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(h[0],c(c({url:a,matches:e=h[1]},e),{key:void 0,ref:void 0}))),a!==(s&&s.url)){c(g,s=this.c={url:a,previous:s&&s.url,current:u,path:u?u.props.path:null,matches:e}),s.router=this,s.active=u?[u]:[];for(var v=y.length;v--;)y[v]({});"function"==typeof f&&f(s)}return (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(k.Provider,{value:s},u)}});var E=function(n){return (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)("a",c({onClick:W},n))},L=function(n){return (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(n.component,n)};
//# sourceMappingURL=preact-router.module.js.map


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			if (cachedModule.error !== undefined) throw cachedModule.error;
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		try {
/******/ 			var execOptions = { id: moduleId, module: module, factory: __webpack_modules__[moduleId], require: __webpack_require__ };
/******/ 			__webpack_require__.i.forEach(function(handler) { handler(execOptions); });
/******/ 			module = execOptions.module;
/******/ 			execOptions.factory.call(module.exports, module, module.exports, execOptions.require);
/******/ 		} catch(e) {
/******/ 			module.error = e;
/******/ 			throw e;
/******/ 		}
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = __webpack_module_cache__;
/******/ 	
/******/ 	// expose the module execution interceptor
/******/ 	__webpack_require__.i = [];
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript update chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference all chunks
/******/ 		__webpack_require__.hu = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + "." + __webpack_require__.h() + ".hot-update.js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get update manifest filename */
/******/ 	(() => {
/******/ 		__webpack_require__.hmrF = () => ("main." + __webpack_require__.h() + ".hot-update.json");
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/getFullHash */
/******/ 	(() => {
/******/ 		__webpack_require__.h = () => ("448099b17dd251d33de6")
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/load script */
/******/ 	(() => {
/******/ 		var inProgress = {};
/******/ 		var dataWebpackPrefix = "flask-preact-typescript-tailwind-template:";
/******/ 		// loadScript function to load a script via script tag
/******/ 		__webpack_require__.l = (url, done, key, chunkId) => {
/******/ 			if(inProgress[url]) { inProgress[url].push(done); return; }
/******/ 			var script, needAttach;
/******/ 			if(key !== undefined) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				for(var i = 0; i < scripts.length; i++) {
/******/ 					var s = scripts[i];
/******/ 					if(s.getAttribute("src") == url || s.getAttribute("data-webpack") == dataWebpackPrefix + key) { script = s; break; }
/******/ 				}
/******/ 			}
/******/ 			if(!script) {
/******/ 				needAttach = true;
/******/ 				script = document.createElement('script');
/******/ 		
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.setAttribute("data-webpack", dataWebpackPrefix + key);
/******/ 		
/******/ 				script.src = url;
/******/ 			}
/******/ 			inProgress[url] = [done];
/******/ 			var onScriptComplete = (prev, event) => {
/******/ 				// avoid mem leaks in IE.
/******/ 				script.onerror = script.onload = null;
/******/ 				clearTimeout(timeout);
/******/ 				var doneFns = inProgress[url];
/******/ 				delete inProgress[url];
/******/ 				script.parentNode && script.parentNode.removeChild(script);
/******/ 				doneFns && doneFns.forEach((fn) => (fn(event)));
/******/ 				if(prev) return prev(event);
/******/ 			}
/******/ 			var timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);
/******/ 			script.onerror = onScriptComplete.bind(null, script.onerror);
/******/ 			script.onload = onScriptComplete.bind(null, script.onload);
/******/ 			needAttach && document.head.appendChild(script);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hot module replacement */
/******/ 	(() => {
/******/ 		var currentModuleData = {};
/******/ 		var installedModules = __webpack_require__.c;
/******/ 		
/******/ 		// module and require creation
/******/ 		var currentChildModule;
/******/ 		var currentParents = [];
/******/ 		
/******/ 		// status
/******/ 		var registeredStatusHandlers = [];
/******/ 		var currentStatus = "idle";
/******/ 		
/******/ 		// while downloading
/******/ 		var blockingPromises = 0;
/******/ 		var blockingPromisesWaiting = [];
/******/ 		
/******/ 		// The update info
/******/ 		var currentUpdateApplyHandlers;
/******/ 		var queuedInvalidatedModules;
/******/ 		
/******/ 		__webpack_require__.hmrD = currentModuleData;
/******/ 		
/******/ 		__webpack_require__.i.push(function (options) {
/******/ 			var module = options.module;
/******/ 			var require = createRequire(options.require, options.id);
/******/ 			module.hot = createModuleHotObject(options.id, module);
/******/ 			module.parents = currentParents;
/******/ 			module.children = [];
/******/ 			currentParents = [];
/******/ 			options.require = require;
/******/ 		});
/******/ 		
/******/ 		__webpack_require__.hmrC = {};
/******/ 		__webpack_require__.hmrI = {};
/******/ 		
/******/ 		function createRequire(require, moduleId) {
/******/ 			var me = installedModules[moduleId];
/******/ 			if (!me) return require;
/******/ 			var fn = function (request) {
/******/ 				if (me.hot.active) {
/******/ 					if (installedModules[request]) {
/******/ 						var parents = installedModules[request].parents;
/******/ 						if (parents.indexOf(moduleId) === -1) {
/******/ 							parents.push(moduleId);
/******/ 						}
/******/ 					} else {
/******/ 						currentParents = [moduleId];
/******/ 						currentChildModule = request;
/******/ 					}
/******/ 					if (me.children.indexOf(request) === -1) {
/******/ 						me.children.push(request);
/******/ 					}
/******/ 				} else {
/******/ 					console.warn(
/******/ 						"[HMR] unexpected require(" +
/******/ 							request +
/******/ 							") from disposed module " +
/******/ 							moduleId
/******/ 					);
/******/ 					currentParents = [];
/******/ 				}
/******/ 				return require(request);
/******/ 			};
/******/ 			var createPropertyDescriptor = function (name) {
/******/ 				return {
/******/ 					configurable: true,
/******/ 					enumerable: true,
/******/ 					get: function () {
/******/ 						return require[name];
/******/ 					},
/******/ 					set: function (value) {
/******/ 						require[name] = value;
/******/ 					}
/******/ 				};
/******/ 			};
/******/ 			for (var name in require) {
/******/ 				if (Object.prototype.hasOwnProperty.call(require, name) && name !== "e") {
/******/ 					Object.defineProperty(fn, name, createPropertyDescriptor(name));
/******/ 				}
/******/ 			}
/******/ 			fn.e = function (chunkId, fetchPriority) {
/******/ 				return trackBlockingPromise(require.e(chunkId, fetchPriority));
/******/ 			};
/******/ 			return fn;
/******/ 		}
/******/ 		
/******/ 		function createModuleHotObject(moduleId, me) {
/******/ 			var _main = currentChildModule !== moduleId;
/******/ 			var hot = {
/******/ 				// private stuff
/******/ 				_acceptedDependencies: {},
/******/ 				_acceptedErrorHandlers: {},
/******/ 				_declinedDependencies: {},
/******/ 				_selfAccepted: false,
/******/ 				_selfDeclined: false,
/******/ 				_selfInvalidated: false,
/******/ 				_disposeHandlers: [],
/******/ 				_main: _main,
/******/ 				_requireSelf: function () {
/******/ 					currentParents = me.parents.slice();
/******/ 					currentChildModule = _main ? undefined : moduleId;
/******/ 					__webpack_require__(moduleId);
/******/ 				},
/******/ 		
/******/ 				// Module API
/******/ 				active: true,
/******/ 				accept: function (dep, callback, errorHandler) {
/******/ 					if (dep === undefined) hot._selfAccepted = true;
/******/ 					else if (typeof dep === "function") hot._selfAccepted = dep;
/******/ 					else if (typeof dep === "object" && dep !== null) {
/******/ 						for (var i = 0; i < dep.length; i++) {
/******/ 							hot._acceptedDependencies[dep[i]] = callback || function () {};
/******/ 							hot._acceptedErrorHandlers[dep[i]] = errorHandler;
/******/ 						}
/******/ 					} else {
/******/ 						hot._acceptedDependencies[dep] = callback || function () {};
/******/ 						hot._acceptedErrorHandlers[dep] = errorHandler;
/******/ 					}
/******/ 				},
/******/ 				decline: function (dep) {
/******/ 					if (dep === undefined) hot._selfDeclined = true;
/******/ 					else if (typeof dep === "object" && dep !== null)
/******/ 						for (var i = 0; i < dep.length; i++)
/******/ 							hot._declinedDependencies[dep[i]] = true;
/******/ 					else hot._declinedDependencies[dep] = true;
/******/ 				},
/******/ 				dispose: function (callback) {
/******/ 					hot._disposeHandlers.push(callback);
/******/ 				},
/******/ 				addDisposeHandler: function (callback) {
/******/ 					hot._disposeHandlers.push(callback);
/******/ 				},
/******/ 				removeDisposeHandler: function (callback) {
/******/ 					var idx = hot._disposeHandlers.indexOf(callback);
/******/ 					if (idx >= 0) hot._disposeHandlers.splice(idx, 1);
/******/ 				},
/******/ 				invalidate: function () {
/******/ 					this._selfInvalidated = true;
/******/ 					switch (currentStatus) {
/******/ 						case "idle":
/******/ 							currentUpdateApplyHandlers = [];
/******/ 							Object.keys(__webpack_require__.hmrI).forEach(function (key) {
/******/ 								__webpack_require__.hmrI[key](
/******/ 									moduleId,
/******/ 									currentUpdateApplyHandlers
/******/ 								);
/******/ 							});
/******/ 							setStatus("ready");
/******/ 							break;
/******/ 						case "ready":
/******/ 							Object.keys(__webpack_require__.hmrI).forEach(function (key) {
/******/ 								__webpack_require__.hmrI[key](
/******/ 									moduleId,
/******/ 									currentUpdateApplyHandlers
/******/ 								);
/******/ 							});
/******/ 							break;
/******/ 						case "prepare":
/******/ 						case "check":
/******/ 						case "dispose":
/******/ 						case "apply":
/******/ 							(queuedInvalidatedModules = queuedInvalidatedModules || []).push(
/******/ 								moduleId
/******/ 							);
/******/ 							break;
/******/ 						default:
/******/ 							// ignore requests in error states
/******/ 							break;
/******/ 					}
/******/ 				},
/******/ 		
/******/ 				// Management API
/******/ 				check: hotCheck,
/******/ 				apply: hotApply,
/******/ 				status: function (l) {
/******/ 					if (!l) return currentStatus;
/******/ 					registeredStatusHandlers.push(l);
/******/ 				},
/******/ 				addStatusHandler: function (l) {
/******/ 					registeredStatusHandlers.push(l);
/******/ 				},
/******/ 				removeStatusHandler: function (l) {
/******/ 					var idx = registeredStatusHandlers.indexOf(l);
/******/ 					if (idx >= 0) registeredStatusHandlers.splice(idx, 1);
/******/ 				},
/******/ 		
/******/ 				//inherit from previous dispose call
/******/ 				data: currentModuleData[moduleId]
/******/ 			};
/******/ 			currentChildModule = undefined;
/******/ 			return hot;
/******/ 		}
/******/ 		
/******/ 		function setStatus(newStatus) {
/******/ 			currentStatus = newStatus;
/******/ 			var results = [];
/******/ 		
/******/ 			for (var i = 0; i < registeredStatusHandlers.length; i++)
/******/ 				results[i] = registeredStatusHandlers[i].call(null, newStatus);
/******/ 		
/******/ 			return Promise.all(results).then(function () {});
/******/ 		}
/******/ 		
/******/ 		function unblock() {
/******/ 			if (--blockingPromises === 0) {
/******/ 				setStatus("ready").then(function () {
/******/ 					if (blockingPromises === 0) {
/******/ 						var list = blockingPromisesWaiting;
/******/ 						blockingPromisesWaiting = [];
/******/ 						for (var i = 0; i < list.length; i++) {
/******/ 							list[i]();
/******/ 						}
/******/ 					}
/******/ 				});
/******/ 			}
/******/ 		}
/******/ 		
/******/ 		function trackBlockingPromise(promise) {
/******/ 			switch (currentStatus) {
/******/ 				case "ready":
/******/ 					setStatus("prepare");
/******/ 				/* fallthrough */
/******/ 				case "prepare":
/******/ 					blockingPromises++;
/******/ 					promise.then(unblock, unblock);
/******/ 					return promise;
/******/ 				default:
/******/ 					return promise;
/******/ 			}
/******/ 		}
/******/ 		
/******/ 		function waitForBlockingPromises(fn) {
/******/ 			if (blockingPromises === 0) return fn();
/******/ 			return new Promise(function (resolve) {
/******/ 				blockingPromisesWaiting.push(function () {
/******/ 					resolve(fn());
/******/ 				});
/******/ 			});
/******/ 		}
/******/ 		
/******/ 		function hotCheck(applyOnUpdate) {
/******/ 			if (currentStatus !== "idle") {
/******/ 				throw new Error("check() is only allowed in idle status");
/******/ 			}
/******/ 			return setStatus("check")
/******/ 				.then(__webpack_require__.hmrM)
/******/ 				.then(function (update) {
/******/ 					if (!update) {
/******/ 						return setStatus(applyInvalidatedModules() ? "ready" : "idle").then(
/******/ 							function () {
/******/ 								return null;
/******/ 							}
/******/ 						);
/******/ 					}
/******/ 		
/******/ 					return setStatus("prepare").then(function () {
/******/ 						var updatedModules = [];
/******/ 						currentUpdateApplyHandlers = [];
/******/ 		
/******/ 						return Promise.all(
/******/ 							Object.keys(__webpack_require__.hmrC).reduce(function (
/******/ 								promises,
/******/ 								key
/******/ 							) {
/******/ 								__webpack_require__.hmrC[key](
/******/ 									update.c,
/******/ 									update.r,
/******/ 									update.m,
/******/ 									promises,
/******/ 									currentUpdateApplyHandlers,
/******/ 									updatedModules
/******/ 								);
/******/ 								return promises;
/******/ 							}, [])
/******/ 						).then(function () {
/******/ 							return waitForBlockingPromises(function () {
/******/ 								if (applyOnUpdate) {
/******/ 									return internalApply(applyOnUpdate);
/******/ 								} else {
/******/ 									return setStatus("ready").then(function () {
/******/ 										return updatedModules;
/******/ 									});
/******/ 								}
/******/ 							});
/******/ 						});
/******/ 					});
/******/ 				});
/******/ 		}
/******/ 		
/******/ 		function hotApply(options) {
/******/ 			if (currentStatus !== "ready") {
/******/ 				return Promise.resolve().then(function () {
/******/ 					throw new Error(
/******/ 						"apply() is only allowed in ready status (state: " +
/******/ 							currentStatus +
/******/ 							")"
/******/ 					);
/******/ 				});
/******/ 			}
/******/ 			return internalApply(options);
/******/ 		}
/******/ 		
/******/ 		function internalApply(options) {
/******/ 			options = options || {};
/******/ 		
/******/ 			applyInvalidatedModules();
/******/ 		
/******/ 			var results = currentUpdateApplyHandlers.map(function (handler) {
/******/ 				return handler(options);
/******/ 			});
/******/ 			currentUpdateApplyHandlers = undefined;
/******/ 		
/******/ 			var errors = results
/******/ 				.map(function (r) {
/******/ 					return r.error;
/******/ 				})
/******/ 				.filter(Boolean);
/******/ 		
/******/ 			if (errors.length > 0) {
/******/ 				return setStatus("abort").then(function () {
/******/ 					throw errors[0];
/******/ 				});
/******/ 			}
/******/ 		
/******/ 			// Now in "dispose" phase
/******/ 			var disposePromise = setStatus("dispose");
/******/ 		
/******/ 			results.forEach(function (result) {
/******/ 				if (result.dispose) result.dispose();
/******/ 			});
/******/ 		
/******/ 			// Now in "apply" phase
/******/ 			var applyPromise = setStatus("apply");
/******/ 		
/******/ 			var error;
/******/ 			var reportError = function (err) {
/******/ 				if (!error) error = err;
/******/ 			};
/******/ 		
/******/ 			var outdatedModules = [];
/******/ 			results.forEach(function (result) {
/******/ 				if (result.apply) {
/******/ 					var modules = result.apply(reportError);
/******/ 					if (modules) {
/******/ 						for (var i = 0; i < modules.length; i++) {
/******/ 							outdatedModules.push(modules[i]);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 			});
/******/ 		
/******/ 			return Promise.all([disposePromise, applyPromise]).then(function () {
/******/ 				// handle errors in accept handlers and self accepted module load
/******/ 				if (error) {
/******/ 					return setStatus("fail").then(function () {
/******/ 						throw error;
/******/ 					});
/******/ 				}
/******/ 		
/******/ 				if (queuedInvalidatedModules) {
/******/ 					return internalApply(options).then(function (list) {
/******/ 						outdatedModules.forEach(function (moduleId) {
/******/ 							if (list.indexOf(moduleId) < 0) list.push(moduleId);
/******/ 						});
/******/ 						return list;
/******/ 					});
/******/ 				}
/******/ 		
/******/ 				return setStatus("idle").then(function () {
/******/ 					return outdatedModules;
/******/ 				});
/******/ 			});
/******/ 		}
/******/ 		
/******/ 		function applyInvalidatedModules() {
/******/ 			if (queuedInvalidatedModules) {
/******/ 				if (!currentUpdateApplyHandlers) currentUpdateApplyHandlers = [];
/******/ 				Object.keys(__webpack_require__.hmrI).forEach(function (key) {
/******/ 					queuedInvalidatedModules.forEach(function (moduleId) {
/******/ 						__webpack_require__.hmrI[key](
/******/ 							moduleId,
/******/ 							currentUpdateApplyHandlers
/******/ 						);
/******/ 					});
/******/ 				});
/******/ 				queuedInvalidatedModules = undefined;
/******/ 				return true;
/******/ 			}
/******/ 		}
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src;
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) {
/******/ 					var i = scripts.length - 1;
/******/ 					while (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		__webpack_require__.b = document.baseURI || self.location.href;
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = __webpack_require__.hmrS_jsonp = __webpack_require__.hmrS_jsonp || {
/******/ 			"main": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		var currentUpdatedModulesList;
/******/ 		var waitingUpdateResolves = {};
/******/ 		function loadUpdateChunk(chunkId, updatedModulesList) {
/******/ 			currentUpdatedModulesList = updatedModulesList;
/******/ 			return new Promise((resolve, reject) => {
/******/ 				waitingUpdateResolves[chunkId] = resolve;
/******/ 				// start update chunk loading
/******/ 				var url = __webpack_require__.p + __webpack_require__.hu(chunkId);
/******/ 				// create error before stack unwound to get useful stacktrace later
/******/ 				var error = new Error();
/******/ 				var loadingEnded = (event) => {
/******/ 					if(waitingUpdateResolves[chunkId]) {
/******/ 						waitingUpdateResolves[chunkId] = undefined
/******/ 						var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 						var realSrc = event && event.target && event.target.src;
/******/ 						error.message = 'Loading hot update chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 						error.name = 'ChunkLoadError';
/******/ 						error.type = errorType;
/******/ 						error.request = realSrc;
/******/ 						reject(error);
/******/ 					}
/******/ 				};
/******/ 				__webpack_require__.l(url, loadingEnded);
/******/ 			});
/******/ 		}
/******/ 		
/******/ 		self["webpackHotUpdateflask_preact_typescript_tailwind_template"] = (chunkId, moreModules, runtime) => {
/******/ 			for(var moduleId in moreModules) {
/******/ 				if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 					currentUpdate[moduleId] = moreModules[moduleId];
/******/ 					if(currentUpdatedModulesList) currentUpdatedModulesList.push(moduleId);
/******/ 				}
/******/ 			}
/******/ 			if(runtime) currentUpdateRuntime.push(runtime);
/******/ 			if(waitingUpdateResolves[chunkId]) {
/******/ 				waitingUpdateResolves[chunkId]();
/******/ 				waitingUpdateResolves[chunkId] = undefined;
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		var currentUpdateChunks;
/******/ 		var currentUpdate;
/******/ 		var currentUpdateRemovedChunks;
/******/ 		var currentUpdateRuntime;
/******/ 		function applyHandler(options) {
/******/ 			if (__webpack_require__.f) delete __webpack_require__.f.jsonpHmr;
/******/ 			currentUpdateChunks = undefined;
/******/ 			function getAffectedModuleEffects(updateModuleId) {
/******/ 				var outdatedModules = [updateModuleId];
/******/ 				var outdatedDependencies = {};
/******/ 		
/******/ 				var queue = outdatedModules.map(function (id) {
/******/ 					return {
/******/ 						chain: [id],
/******/ 						id: id
/******/ 					};
/******/ 				});
/******/ 				while (queue.length > 0) {
/******/ 					var queueItem = queue.pop();
/******/ 					var moduleId = queueItem.id;
/******/ 					var chain = queueItem.chain;
/******/ 					var module = __webpack_require__.c[moduleId];
/******/ 					if (
/******/ 						!module ||
/******/ 						(module.hot._selfAccepted && !module.hot._selfInvalidated)
/******/ 					)
/******/ 						continue;
/******/ 					if (module.hot._selfDeclined) {
/******/ 						return {
/******/ 							type: "self-declined",
/******/ 							chain: chain,
/******/ 							moduleId: moduleId
/******/ 						};
/******/ 					}
/******/ 					if (module.hot._main) {
/******/ 						return {
/******/ 							type: "unaccepted",
/******/ 							chain: chain,
/******/ 							moduleId: moduleId
/******/ 						};
/******/ 					}
/******/ 					for (var i = 0; i < module.parents.length; i++) {
/******/ 						var parentId = module.parents[i];
/******/ 						var parent = __webpack_require__.c[parentId];
/******/ 						if (!parent) continue;
/******/ 						if (parent.hot._declinedDependencies[moduleId]) {
/******/ 							return {
/******/ 								type: "declined",
/******/ 								chain: chain.concat([parentId]),
/******/ 								moduleId: moduleId,
/******/ 								parentId: parentId
/******/ 							};
/******/ 						}
/******/ 						if (outdatedModules.indexOf(parentId) !== -1) continue;
/******/ 						if (parent.hot._acceptedDependencies[moduleId]) {
/******/ 							if (!outdatedDependencies[parentId])
/******/ 								outdatedDependencies[parentId] = [];
/******/ 							addAllToSet(outdatedDependencies[parentId], [moduleId]);
/******/ 							continue;
/******/ 						}
/******/ 						delete outdatedDependencies[parentId];
/******/ 						outdatedModules.push(parentId);
/******/ 						queue.push({
/******/ 							chain: chain.concat([parentId]),
/******/ 							id: parentId
/******/ 						});
/******/ 					}
/******/ 				}
/******/ 		
/******/ 				return {
/******/ 					type: "accepted",
/******/ 					moduleId: updateModuleId,
/******/ 					outdatedModules: outdatedModules,
/******/ 					outdatedDependencies: outdatedDependencies
/******/ 				};
/******/ 			}
/******/ 		
/******/ 			function addAllToSet(a, b) {
/******/ 				for (var i = 0; i < b.length; i++) {
/******/ 					var item = b[i];
/******/ 					if (a.indexOf(item) === -1) a.push(item);
/******/ 				}
/******/ 			}
/******/ 		
/******/ 			// at begin all updates modules are outdated
/******/ 			// the "outdated" status can propagate to parents if they don't accept the children
/******/ 			var outdatedDependencies = {};
/******/ 			var outdatedModules = [];
/******/ 			var appliedUpdate = {};
/******/ 		
/******/ 			var warnUnexpectedRequire = function warnUnexpectedRequire(module) {
/******/ 				console.warn(
/******/ 					"[HMR] unexpected require(" + module.id + ") to disposed module"
/******/ 				);
/******/ 			};
/******/ 		
/******/ 			for (var moduleId in currentUpdate) {
/******/ 				if (__webpack_require__.o(currentUpdate, moduleId)) {
/******/ 					var newModuleFactory = currentUpdate[moduleId];
/******/ 					/** @type {TODO} */
/******/ 					var result;
/******/ 					if (newModuleFactory) {
/******/ 						result = getAffectedModuleEffects(moduleId);
/******/ 					} else {
/******/ 						result = {
/******/ 							type: "disposed",
/******/ 							moduleId: moduleId
/******/ 						};
/******/ 					}
/******/ 					/** @type {Error|false} */
/******/ 					var abortError = false;
/******/ 					var doApply = false;
/******/ 					var doDispose = false;
/******/ 					var chainInfo = "";
/******/ 					if (result.chain) {
/******/ 						chainInfo = "\nUpdate propagation: " + result.chain.join(" -> ");
/******/ 					}
/******/ 					switch (result.type) {
/******/ 						case "self-declined":
/******/ 							if (options.onDeclined) options.onDeclined(result);
/******/ 							if (!options.ignoreDeclined)
/******/ 								abortError = new Error(
/******/ 									"Aborted because of self decline: " +
/******/ 										result.moduleId +
/******/ 										chainInfo
/******/ 								);
/******/ 							break;
/******/ 						case "declined":
/******/ 							if (options.onDeclined) options.onDeclined(result);
/******/ 							if (!options.ignoreDeclined)
/******/ 								abortError = new Error(
/******/ 									"Aborted because of declined dependency: " +
/******/ 										result.moduleId +
/******/ 										" in " +
/******/ 										result.parentId +
/******/ 										chainInfo
/******/ 								);
/******/ 							break;
/******/ 						case "unaccepted":
/******/ 							if (options.onUnaccepted) options.onUnaccepted(result);
/******/ 							if (!options.ignoreUnaccepted)
/******/ 								abortError = new Error(
/******/ 									"Aborted because " + moduleId + " is not accepted" + chainInfo
/******/ 								);
/******/ 							break;
/******/ 						case "accepted":
/******/ 							if (options.onAccepted) options.onAccepted(result);
/******/ 							doApply = true;
/******/ 							break;
/******/ 						case "disposed":
/******/ 							if (options.onDisposed) options.onDisposed(result);
/******/ 							doDispose = true;
/******/ 							break;
/******/ 						default:
/******/ 							throw new Error("Unexception type " + result.type);
/******/ 					}
/******/ 					if (abortError) {
/******/ 						return {
/******/ 							error: abortError
/******/ 						};
/******/ 					}
/******/ 					if (doApply) {
/******/ 						appliedUpdate[moduleId] = newModuleFactory;
/******/ 						addAllToSet(outdatedModules, result.outdatedModules);
/******/ 						for (moduleId in result.outdatedDependencies) {
/******/ 							if (__webpack_require__.o(result.outdatedDependencies, moduleId)) {
/******/ 								if (!outdatedDependencies[moduleId])
/******/ 									outdatedDependencies[moduleId] = [];
/******/ 								addAllToSet(
/******/ 									outdatedDependencies[moduleId],
/******/ 									result.outdatedDependencies[moduleId]
/******/ 								);
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 					if (doDispose) {
/******/ 						addAllToSet(outdatedModules, [result.moduleId]);
/******/ 						appliedUpdate[moduleId] = warnUnexpectedRequire;
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 			currentUpdate = undefined;
/******/ 		
/******/ 			// Store self accepted outdated modules to require them later by the module system
/******/ 			var outdatedSelfAcceptedModules = [];
/******/ 			for (var j = 0; j < outdatedModules.length; j++) {
/******/ 				var outdatedModuleId = outdatedModules[j];
/******/ 				var module = __webpack_require__.c[outdatedModuleId];
/******/ 				if (
/******/ 					module &&
/******/ 					(module.hot._selfAccepted || module.hot._main) &&
/******/ 					// removed self-accepted modules should not be required
/******/ 					appliedUpdate[outdatedModuleId] !== warnUnexpectedRequire &&
/******/ 					// when called invalidate self-accepting is not possible
/******/ 					!module.hot._selfInvalidated
/******/ 				) {
/******/ 					outdatedSelfAcceptedModules.push({
/******/ 						module: outdatedModuleId,
/******/ 						require: module.hot._requireSelf,
/******/ 						errorHandler: module.hot._selfAccepted
/******/ 					});
/******/ 				}
/******/ 			}
/******/ 		
/******/ 			var moduleOutdatedDependencies;
/******/ 		
/******/ 			return {
/******/ 				dispose: function () {
/******/ 					currentUpdateRemovedChunks.forEach(function (chunkId) {
/******/ 						delete installedChunks[chunkId];
/******/ 					});
/******/ 					currentUpdateRemovedChunks = undefined;
/******/ 		
/******/ 					var idx;
/******/ 					var queue = outdatedModules.slice();
/******/ 					while (queue.length > 0) {
/******/ 						var moduleId = queue.pop();
/******/ 						var module = __webpack_require__.c[moduleId];
/******/ 						if (!module) continue;
/******/ 		
/******/ 						var data = {};
/******/ 		
/******/ 						// Call dispose handlers
/******/ 						var disposeHandlers = module.hot._disposeHandlers;
/******/ 						for (j = 0; j < disposeHandlers.length; j++) {
/******/ 							disposeHandlers[j].call(null, data);
/******/ 						}
/******/ 						__webpack_require__.hmrD[moduleId] = data;
/******/ 		
/******/ 						// disable module (this disables requires from this module)
/******/ 						module.hot.active = false;
/******/ 		
/******/ 						// remove module from cache
/******/ 						delete __webpack_require__.c[moduleId];
/******/ 		
/******/ 						// when disposing there is no need to call dispose handler
/******/ 						delete outdatedDependencies[moduleId];
/******/ 		
/******/ 						// remove "parents" references from all children
/******/ 						for (j = 0; j < module.children.length; j++) {
/******/ 							var child = __webpack_require__.c[module.children[j]];
/******/ 							if (!child) continue;
/******/ 							idx = child.parents.indexOf(moduleId);
/******/ 							if (idx >= 0) {
/******/ 								child.parents.splice(idx, 1);
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					// remove outdated dependency from module children
/******/ 					var dependency;
/******/ 					for (var outdatedModuleId in outdatedDependencies) {
/******/ 						if (__webpack_require__.o(outdatedDependencies, outdatedModuleId)) {
/******/ 							module = __webpack_require__.c[outdatedModuleId];
/******/ 							if (module) {
/******/ 								moduleOutdatedDependencies =
/******/ 									outdatedDependencies[outdatedModuleId];
/******/ 								for (j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 									dependency = moduleOutdatedDependencies[j];
/******/ 									idx = module.children.indexOf(dependency);
/******/ 									if (idx >= 0) module.children.splice(idx, 1);
/******/ 								}
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 				},
/******/ 				apply: function (reportError) {
/******/ 					// insert new code
/******/ 					for (var updateModuleId in appliedUpdate) {
/******/ 						if (__webpack_require__.o(appliedUpdate, updateModuleId)) {
/******/ 							__webpack_require__.m[updateModuleId] = appliedUpdate[updateModuleId];
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					// run new runtime modules
/******/ 					for (var i = 0; i < currentUpdateRuntime.length; i++) {
/******/ 						currentUpdateRuntime[i](__webpack_require__);
/******/ 					}
/******/ 		
/******/ 					// call accept handlers
/******/ 					for (var outdatedModuleId in outdatedDependencies) {
/******/ 						if (__webpack_require__.o(outdatedDependencies, outdatedModuleId)) {
/******/ 							var module = __webpack_require__.c[outdatedModuleId];
/******/ 							if (module) {
/******/ 								moduleOutdatedDependencies =
/******/ 									outdatedDependencies[outdatedModuleId];
/******/ 								var callbacks = [];
/******/ 								var errorHandlers = [];
/******/ 								var dependenciesForCallbacks = [];
/******/ 								for (var j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 									var dependency = moduleOutdatedDependencies[j];
/******/ 									var acceptCallback =
/******/ 										module.hot._acceptedDependencies[dependency];
/******/ 									var errorHandler =
/******/ 										module.hot._acceptedErrorHandlers[dependency];
/******/ 									if (acceptCallback) {
/******/ 										if (callbacks.indexOf(acceptCallback) !== -1) continue;
/******/ 										callbacks.push(acceptCallback);
/******/ 										errorHandlers.push(errorHandler);
/******/ 										dependenciesForCallbacks.push(dependency);
/******/ 									}
/******/ 								}
/******/ 								for (var k = 0; k < callbacks.length; k++) {
/******/ 									try {
/******/ 										callbacks[k].call(null, moduleOutdatedDependencies);
/******/ 									} catch (err) {
/******/ 										if (typeof errorHandlers[k] === "function") {
/******/ 											try {
/******/ 												errorHandlers[k](err, {
/******/ 													moduleId: outdatedModuleId,
/******/ 													dependencyId: dependenciesForCallbacks[k]
/******/ 												});
/******/ 											} catch (err2) {
/******/ 												if (options.onErrored) {
/******/ 													options.onErrored({
/******/ 														type: "accept-error-handler-errored",
/******/ 														moduleId: outdatedModuleId,
/******/ 														dependencyId: dependenciesForCallbacks[k],
/******/ 														error: err2,
/******/ 														originalError: err
/******/ 													});
/******/ 												}
/******/ 												if (!options.ignoreErrored) {
/******/ 													reportError(err2);
/******/ 													reportError(err);
/******/ 												}
/******/ 											}
/******/ 										} else {
/******/ 											if (options.onErrored) {
/******/ 												options.onErrored({
/******/ 													type: "accept-errored",
/******/ 													moduleId: outdatedModuleId,
/******/ 													dependencyId: dependenciesForCallbacks[k],
/******/ 													error: err
/******/ 												});
/******/ 											}
/******/ 											if (!options.ignoreErrored) {
/******/ 												reportError(err);
/******/ 											}
/******/ 										}
/******/ 									}
/******/ 								}
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					// Load self accepted modules
/******/ 					for (var o = 0; o < outdatedSelfAcceptedModules.length; o++) {
/******/ 						var item = outdatedSelfAcceptedModules[o];
/******/ 						var moduleId = item.module;
/******/ 						try {
/******/ 							item.require(moduleId);
/******/ 						} catch (err) {
/******/ 							if (typeof item.errorHandler === "function") {
/******/ 								try {
/******/ 									item.errorHandler(err, {
/******/ 										moduleId: moduleId,
/******/ 										module: __webpack_require__.c[moduleId]
/******/ 									});
/******/ 								} catch (err2) {
/******/ 									if (options.onErrored) {
/******/ 										options.onErrored({
/******/ 											type: "self-accept-error-handler-errored",
/******/ 											moduleId: moduleId,
/******/ 											error: err2,
/******/ 											originalError: err
/******/ 										});
/******/ 									}
/******/ 									if (!options.ignoreErrored) {
/******/ 										reportError(err2);
/******/ 										reportError(err);
/******/ 									}
/******/ 								}
/******/ 							} else {
/******/ 								if (options.onErrored) {
/******/ 									options.onErrored({
/******/ 										type: "self-accept-errored",
/******/ 										moduleId: moduleId,
/******/ 										error: err
/******/ 									});
/******/ 								}
/******/ 								if (!options.ignoreErrored) {
/******/ 									reportError(err);
/******/ 								}
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					return outdatedModules;
/******/ 				}
/******/ 			};
/******/ 		}
/******/ 		__webpack_require__.hmrI.jsonp = function (moduleId, applyHandlers) {
/******/ 			if (!currentUpdate) {
/******/ 				currentUpdate = {};
/******/ 				currentUpdateRuntime = [];
/******/ 				currentUpdateRemovedChunks = [];
/******/ 				applyHandlers.push(applyHandler);
/******/ 			}
/******/ 			if (!__webpack_require__.o(currentUpdate, moduleId)) {
/******/ 				currentUpdate[moduleId] = __webpack_require__.m[moduleId];
/******/ 			}
/******/ 		};
/******/ 		__webpack_require__.hmrC.jsonp = function (
/******/ 			chunkIds,
/******/ 			removedChunks,
/******/ 			removedModules,
/******/ 			promises,
/******/ 			applyHandlers,
/******/ 			updatedModulesList
/******/ 		) {
/******/ 			applyHandlers.push(applyHandler);
/******/ 			currentUpdateChunks = {};
/******/ 			currentUpdateRemovedChunks = removedChunks;
/******/ 			currentUpdate = removedModules.reduce(function (obj, key) {
/******/ 				obj[key] = false;
/******/ 				return obj;
/******/ 			}, {});
/******/ 			currentUpdateRuntime = [];
/******/ 			chunkIds.forEach(function (chunkId) {
/******/ 				if (
/******/ 					__webpack_require__.o(installedChunks, chunkId) &&
/******/ 					installedChunks[chunkId] !== undefined
/******/ 				) {
/******/ 					promises.push(loadUpdateChunk(chunkId, updatedModulesList));
/******/ 					currentUpdateChunks[chunkId] = true;
/******/ 				} else {
/******/ 					currentUpdateChunks[chunkId] = false;
/******/ 				}
/******/ 			});
/******/ 			if (__webpack_require__.f) {
/******/ 				__webpack_require__.f.jsonpHmr = function (chunkId, promises) {
/******/ 					if (
/******/ 						currentUpdateChunks &&
/******/ 						__webpack_require__.o(currentUpdateChunks, chunkId) &&
/******/ 						!currentUpdateChunks[chunkId]
/******/ 					) {
/******/ 						promises.push(loadUpdateChunk(chunkId));
/******/ 						currentUpdateChunks[chunkId] = true;
/******/ 					}
/******/ 				};
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.hmrM = () => {
/******/ 			if (typeof fetch === "undefined") throw new Error("No browser support: need fetch API");
/******/ 			return fetch(__webpack_require__.p + __webpack_require__.hmrF()).then((response) => {
/******/ 				if(response.status === 404) return; // no update available
/******/ 				if(!response.ok) throw new Error("Failed to fetch update manifest " + response.statusText);
/******/ 				return response.json();
/******/ 			});
/******/ 		};
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// no jsonp function
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// module cache are used so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	var __webpack_exports__ = __webpack_require__("./app/static/pages/layout.tsx");
/******/ 	
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxHQUFHOztBQUVOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUNBQXlDOztBQUV6QywyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRyxHQUFHOztBQUVOO0FBQ0EscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUcsR0FBRzs7QUFFTjtBQUNBLDZDQUE2Qzs7QUFFN0M7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxHQUFHOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDLEdBQUc7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QscURBQXFEO0FBQ3JEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0NBQXNDOztBQUV0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHdCQUF3QjtBQUNoQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw2QkFBNkI7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQSxtQkFBbUIsdUJBQXVCO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDZCQUE2Qjs7QUFFdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxPQUFPO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpSUFBaUkseUNBQXlDLFFBQVE7QUFDbEw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFNBQVM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0MsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsSUFBSTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsT0FBTztBQUNwRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFFBQVE7O0FBRXhELHVDQUF1QyxRQUFRLHNEQUFzRCxRQUFROztBQUU3RztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7OztBQUdSOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsUUFBUTtBQUNSO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsK0NBQStDOzs7QUFHL0M7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkM7QUFDM0M7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw4QkFBOEI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHVCQUF1QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDJCQUEyQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxPQUFPO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNB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Q2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxrQkFBa0I7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSxrQ0FBa0MscURBQXFEO0FBQ3ZGLFFBQVEsb0RBQW9EO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDREQUE0RDtBQUN2RSxZQUFZLDJEQUEyRDtBQUN2RSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxXQUFXLG9FQUFvRTtBQUMvRSxZQUFZLG1FQUFtRTtBQUMvRSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7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cUNBQXFDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyx3Q0FBd0MsMEJBQTBCLDBCQUEwQjtBQUNuRyxPQUFPLDBDQUEwQyxFQUFFLHdCQUF3QjtBQUMzRSxPQUFPLHVDQUF1QztBQUM5QyxPQUFPLHFDQUFxQztBQUM1QztBQUNBO0FBQ0EsY0FBYyxlQUFlO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDRCQUE0QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSxNQUFNLGNBQWM7QUFDcEIsa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsNEJBQTRCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwwQkFBMEI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7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LEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssSUFBSTtBQUNUO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxJQUFJO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxJQUFJO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxJQUFJO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLFdBQVcscURBQWEsd0JBQXdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxHQUFHLHFEQUFhO0FBQ3JCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGlEQUFTO0FBQ3RCLEtBQUs7QUFDTCxhQUFhLGlEQUFTO0FBQ3RCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7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RUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixtQ0FBbUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG1DQUFtQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sZ0dBQWdHLFlBQVksTUFBTSxPQUFPLHFCQUFxQixvQkFBb0IscUJBQXFCLHFCQUFxQixNQUFNLE1BQU0sV0FBVyxNQUFNLFlBQVksTUFBTSxNQUFNLHFCQUFxQixxQkFBcUIscUJBQXFCLFVBQVUsb0JBQW9CLHFCQUFxQixxQkFBcUIscUJBQXFCLHFCQUFxQixNQUFNLE9BQU8sTUFBTSxLQUFLLG9CQUFvQixxQkFBcUIsTUFBTSxRQUFRLE1BQU0sS0FBSyxvQkFBb0Isb0JBQW9CLHFCQUFxQixNQUFNLE1BQU0sTUFBTSxLQUFLLFdBQVcsV0FBVyxNQUFNLE1BQU0sTUFBTSxVQUFVLFdBQVcsV0FBVyxNQUFNLE1BQU0sTUFBTSxLQUFLLFVBQVUsV0FBVyxNQUFNLE1BQU0sTUFBTSxNQUFNLFdBQVcsTUFBTSxTQUFTLE1BQU0sUUFBUSxxQkFBcUIscUJBQXFCLHFCQUFxQixvQkFBb0IsTUFBTSxNQUFNLE1BQU0sS0FBSyxVQUFVLE1BQU0sTUFBTSxNQUFNLE1BQU0sVUFBVSxVQUFVLFdBQVcsV0FBVyxNQUFNLEtBQUssVUFBVSxNQUFNLEtBQUssVUFBVSxNQUFNLFFBQVEsTUFBTSxLQUFLLG9CQUFvQixxQkFBcUIscUJBQXFCLE1BQU0sUUFBUSxNQUFNLFNBQVMscUJBQXFCLHFCQUFxQixxQkFBcUIsb0JBQW9CLHFCQUFxQixxQkFBcUIscUJBQXFCLG9CQUFvQixvQkFBb0Isb0JBQW9CLE1BQU0sTUFBTSxNQUFNLE1BQU0sV0FBVyxNQUFNLE9BQU8sTUFBTSxRQUFRLHFCQUFxQixxQkFBcUIscUJBQXFCLE1BQU0sTUFBTSxNQUFNLEtBQUssVUFBVSxNQUFNLE1BQU0sTUFBTSxLQUFLLFdBQVcsTUFBTSxNQUFNLE1BQU0sS0FBSyxXQUFXLE1BQU0sTUFBTSxNQUFNLE1BQU0sVUFBVSxNQUFNLE9BQU8sTUFBTSxLQUFLLHFCQUFxQixxQkFBcUIsTUFBTSxNQUFNLE1BQU0sS0FBSyxXQUFXLE1BQU0sT0FBTyxNQUFNLEtBQUsscUJBQXFCLG9CQUFvQixNQUFNLE1BQU0sTUFBTSxLQUFLLFdBQVcsTUFBTSxNQUFNLE1BQU0saUJBQWlCLFVBQVUsTUFBTSxLQUFLLFVBQVUsVUFBVSxNQUFNLEtBQUssVUFBVSxNQUFNLE9BQU8sV0FBVyxVQUFVLFVBQVUsTUFBTSxNQUFNLEtBQUssS0FBSyxVQUFVLE1BQU0sTUFBTSxNQUFNLEtBQUssV0FBVyxNQUFNLE9BQU8sTUFBTSxLQUFLLG9CQUFvQixvQkFBb0IsTUFBTSxNQUFNLG9CQUFvQixvQkFBb0IsTUFBTSxNQUFNLE1BQU0sTUFBTSxVQUFVLE1BQU0sTUFBTSxLQUFLLEtBQUssVUFBVSxNQUFNLFFBQVEsTUFBTSxZQUFZLG9CQUFvQixxQkFBcUIsTUFBTSxNQUFNLE1BQU0sTUFBTSxVQUFVLFVBQVUsTUFBTSxXQUFXLEtBQUssVUFBVSxNQUFNLEtBQUssV0FBVyxXQUFXLFdBQVcsV0FBVyxVQUFVLFVBQVUsVUFBVSxVQUFVLFVBQVUsVUFBVSxVQUFVLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxVQUFVLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFVBQVUsV0FBVyxXQUFXLFdBQVcsV0FBVyxVQUFVLFdBQVcsVUFBVSxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLEtBQUssTUFBTSxLQUFLLFdBQVcsV0FBVyxXQUFXLFdBQVcsVUFBVSxVQUFVLFVBQVUsVUFBVSxVQUFVLFVBQVUsVUFBVSxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsVUFBVSxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxVQUFVLFdBQVcsV0FBVyxXQUFXLFdBQVcsVUFBVSxXQUFXLFVBQVUsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxLQUFLLEtBQUssS0FBSyxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLFdBQVcsTUFBTSxNQUFNLE1BQU0sV0FBVyxNQUFNLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksYUFBYSxNQUFNLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxZQUFZLGFBQWEsYUFBYSxhQUFhLE1BQU0sTUFBTSxNQUFNLFlBQVksYUFBYSxNQUFNLE9BQU8sTUFBTSxXQUFXLGFBQWEsTUFBTSxPQUFPLE9BQU8sS0FBSyxXQUFXLE1BQU0sTUFBTSxNQUFNLE9BQU8sS0FBSyxXQUFXLE1BQU0sTUFBTSxNQUFNLE1BQU0sV0FBVyxhQUFhLE1BQU0sT0FBTyxPQUFPLEtBQUssV0FBVyxNQUFNLE1BQU0sTUFBTSxNQUFNLFdBQVcsYUFBYSxNQUFNLE9BQU8sT0FBTyxLQUFLLFdBQVcsTUFBTSxNQUFNLE1BQU0sTUFBTSxXQUFXLE1BQU0sT0FBTyxPQUFPLEtBQUssV0FBVyxNQUFNLE1BQU0sTUFBTSxNQUFNLEtBQUssT0FBTyxPQUFPLEtBQUssS0FBSyxNQUFNLE1BQU0sT0FBTyxXQUFXLGFBQWEsYUFBYSxNQUFNLE1BQU0sT0FBTyxLQUFLLE9BQU8sTUFBTSxVQUFVLFVBQVUsVUFBVSxZQUFZLGFBQWEsV0FBVyxPQUFPLEtBQUssS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sWUFBWSxPQUFPLEtBQUssWUFBWSxZQUFZLGFBQWEsYUFBYSxhQUFhLE1BQU0sT0FBTyxPQUFPLEtBQUssS0FBSyxNQUFNLE1BQU0sT0FBTyxLQUFLLEtBQUssTUFBTSxNQUFNLE1BQU0sWUFBWSxhQUFhLE1BQU0sT0FBTyxNQUFNLFlBQVksYUFBYSxhQUFhLE1BQU0sT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLFdBQVcsWUFBWSxXQUFXLFlBQVksV0FBVyxVQUFVLFlBQVksTUFBTSxPQUFPLE1BQU0sV0FBVyxZQUFZLE1BQU0sT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLFdBQVcsWUFBWSxNQUFNLE9BQU8sTUFBTSxZQUFZLE1BQU0sT0FBTyxNQUFNLFlBQVksWUFBWSxhQUFhLGFBQWEsT0FBTyxNQUFNLEtBQUssS0FBSyxNQUFNLE1BQU0sTUFBTSxLQUFLLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLFdBQVcsYUFBYSxNQUFNLE1BQU0sT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLFlBQVksTUFBTSxPQUFPLE1BQU0sWUFBWSxNQUFNLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxZQUFZLE1BQU0sT0FBTyxPQUFPLEtBQUssS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sWUFBWSxNQUFNLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxZQUFZLE1BQU0sT0FBTyxNQUFNLFlBQVksTUFBTSxPQUFPLE1BQU0sWUFBWSxNQUFNLE9BQU8sTUFBTSxZQUFZLE1BQU0sT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssTUFBTSxNQUFNLE9BQU8sS0FBSyxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxZQUFZLE1BQU0sT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssTUFBTSxNQUFNLE9BQU8sS0FBSyxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxZQUFZLE1BQU0sT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLFlBQVksTUFBTSxPQUFPLE1BQU0sWUFBWSxNQUFNLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxL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QUNBO1dBQ0E7V0FDQTs7V0FFQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsR0FBRztXQUNIO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLG1CQUFtQiwyQkFBMkI7V0FDOUM7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLEtBQUs7V0FDTDtXQUNBOztXQUVBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBOztXQUVBO1dBQ0Esa0JBQWtCLGNBQWM7V0FDaEM7V0FDQTtXQUNBO1dBQ0E7O1dBRUE7V0FDQTtXQUNBO1dBQ0E7V0FDQTs7V0FFQTtXQUNBO1dBQ0E7V0FDQTtXQUNBOztXQUVBO1dBQ0E7V0FDQTtXQUNBLGNBQWMsTUFBTTtXQUNwQjtXQUNBO1dBQ0E7V0FDQSxLQUFLO1dBQ0w7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLGNBQWMsYUFBYTtXQUMzQjtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7O1dBRUE7V0FDQTtXQUNBLGlCQUFpQiw0QkFBNEI7V0FDN0M7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLElBQUk7V0FDSjtXQUNBOztXQUVBOztXQUVBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsSUFBSTtXQUNKOztXQUVBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTs7V0FFQTs7V0FFQTtXQUNBO1dBQ0EsZ0JBQWdCLDRCQUE0QjtXQUM1QztXQUNBO1dBQ0E7O1dBRUE7V0FDQTs7V0FFQTtXQUNBOztXQUVBO1dBQ0E7O1dBRUE7V0FDQSxnQkFBZ0IsNEJBQTRCO1dBQzVDO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7O1dBRUE7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLGtCQUFrQix1Q0FBdUM7V0FDekQ7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxHQUFHO1dBQ0g7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7O1dBRUE7V0FDQSxtQkFBbUIsaUNBQWlDO1dBQ3BEO1dBQ0E7O1dBRUE7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxzQkFBc0IsdUNBQXVDO1dBQzdEO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLHNCQUFzQixzQkFBc0I7V0FDNUM7V0FDQTtXQUNBLFNBQVM7V0FDVDtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsV0FBVztXQUNYLFdBQVc7V0FDWDtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLFlBQVk7V0FDWjtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxVQUFVO1dBQ1Y7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsV0FBVztXQUNYO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBOztXQUVBO1dBQ0EsbUJBQW1CLHdDQUF3QztXQUMzRDtXQUNBO1dBQ0E7V0FDQTtXQUNBLE1BQU07V0FDTjtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsUUFBUTtXQUNSLFFBQVE7V0FDUjtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxTQUFTO1dBQ1Q7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsT0FBTztXQUNQO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxRQUFRO1dBQ1I7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7O1dBRUE7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLEVBQUUsSUFBSTtXQUNOO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxJQUFJO1dBQ0o7V0FDQTtXQUNBLEVBQUU7V0FDRjtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTs7V0FFQTtXQUNBO1dBQ0E7V0FDQSxzQ0FBc0M7V0FDdEM7V0FDQTtXQUNBLEVBQUU7V0FDRjs7V0FFQTs7V0FFQTs7Ozs7V0M5ZkE7Ozs7O1VFQUE7VUFDQTtVQUNBO1VBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mbGFzay1wcmVhY3QtdHlwZXNjcmlwdC10YWlsd2luZC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9AZWdqcy9wcmVhY3QtZmxpY2tpbmcvZGlzdC9mbGlja2luZy5lc20uanMiLCJ3ZWJwYWNrOi8vZmxhc2stcHJlYWN0LXR5cGVzY3JpcHQtdGFpbHdpbmQtdGVtcGxhdGUvLi9hcHAvc3RhdGljL3BhZ2VzL2dsb2JhbHMuY3NzIiwid2VicGFjazovL2ZsYXNrLXByZWFjdC10eXBlc2NyaXB0LXRhaWx3aW5kLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0BlZ2pzL3ByZWFjdC1mbGlja2luZy9kaXN0L2ZsaWNraW5nLmNzcyIsIndlYnBhY2s6Ly9mbGFzay1wcmVhY3QtdHlwZXNjcmlwdC10YWlsd2luZC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanMiLCJ3ZWJwYWNrOi8vZmxhc2stcHJlYWN0LXR5cGVzY3JpcHQtdGFpbHdpbmQtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvZ2V0VXJsLmpzIiwid2VicGFjazovL2ZsYXNrLXByZWFjdC10eXBlc2NyaXB0LXRhaWx3aW5kLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL3NvdXJjZU1hcHMuanMiLCJ3ZWJwYWNrOi8vZmxhc2stcHJlYWN0LXR5cGVzY3JpcHQtdGFpbHdpbmQtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvcHJlYWN0L2Rpc3QvcHJlYWN0Lm1vZHVsZS5qcyIsIndlYnBhY2s6Ly9mbGFzay1wcmVhY3QtdHlwZXNjcmlwdC10YWlsd2luZC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9wcmVhY3QvaG9va3MvZGlzdC9ob29rcy5tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vZmxhc2stcHJlYWN0LXR5cGVzY3JpcHQtdGFpbHdpbmQtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvcHJlYWN0L2pzeC1ydW50aW1lL2Rpc3QvanN4UnVudGltZS5tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vZmxhc2stcHJlYWN0LXR5cGVzY3JpcHQtdGFpbHdpbmQtdGVtcGxhdGUvLi9hcHAvc3RhdGljL3BhZ2VzL2dsb2JhbHMuY3NzPzU0MWYiLCJ3ZWJwYWNrOi8vZmxhc2stcHJlYWN0LXR5cGVzY3JpcHQtdGFpbHdpbmQtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQGVnanMvcHJlYWN0LWZsaWNraW5nL2Rpc3QvZmxpY2tpbmcuY3NzPzNmYzciLCJ3ZWJwYWNrOi8vZmxhc2stcHJlYWN0LXR5cGVzY3JpcHQtdGFpbHdpbmQtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanMiLCJ3ZWJwYWNrOi8vZmxhc2stcHJlYWN0LXR5cGVzY3JpcHQtdGFpbHdpbmQtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRCeVNlbGVjdG9yLmpzIiwid2VicGFjazovL2ZsYXNrLXByZWFjdC10eXBlc2NyaXB0LXRhaWx3aW5kLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5zZXJ0U3R5bGVFbGVtZW50LmpzIiwid2VicGFjazovL2ZsYXNrLXByZWFjdC10eXBlc2NyaXB0LXRhaWx3aW5kLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc2V0QXR0cmlidXRlc1dpdGhvdXRBdHRyaWJ1dGVzLmpzIiwid2VicGFjazovL2ZsYXNrLXByZWFjdC10eXBlc2NyaXB0LXRhaWx3aW5kLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc3R5bGVEb21BUEkuanMiLCJ3ZWJwYWNrOi8vZmxhc2stcHJlYWN0LXR5cGVzY3JpcHQtdGFpbHdpbmQtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZVRhZ1RyYW5zZm9ybS5qcyIsIndlYnBhY2s6Ly9mbGFzay1wcmVhY3QtdHlwZXNjcmlwdC10YWlsd2luZC10ZW1wbGF0ZS8uL2FwcC9zdGF0aWMvcGFnZXMvY29tcG9uZW50cy9CbG9jazEudHN4Iiwid2VicGFjazovL2ZsYXNrLXByZWFjdC10eXBlc2NyaXB0LXRhaWx3aW5kLXRlbXBsYXRlLy4vYXBwL3N0YXRpYy9wYWdlcy9jb21wb25lbnRzL0Jsb2NrMi50c3giLCJ3ZWJwYWNrOi8vZmxhc2stcHJlYWN0LXR5cGVzY3JpcHQtdGFpbHdpbmQtdGVtcGxhdGUvLi9hcHAvc3RhdGljL3BhZ2VzL2NvbXBvbmVudHMvQmxvY2szLnRzeCIsIndlYnBhY2s6Ly9mbGFzay1wcmVhY3QtdHlwZXNjcmlwdC10YWlsd2luZC10ZW1wbGF0ZS8uL2FwcC9zdGF0aWMvcGFnZXMvY29tcG9uZW50cy9CbG9jazQudHN4Iiwid2VicGFjazovL2ZsYXNrLXByZWFjdC10eXBlc2NyaXB0LXRhaWx3aW5kLXRlbXBsYXRlLy4vYXBwL3N0YXRpYy9wYWdlcy9jb21wb25lbnRzL0Zvb3Rlci50c3giLCJ3ZWJwYWNrOi8vZmxhc2stcHJlYWN0LXR5cGVzY3JpcHQtdGFpbHdpbmQtdGVtcGxhdGUvLi9hcHAvc3RhdGljL3BhZ2VzL2NvbXBvbmVudHMvTmF2YmFyLnRzeCIsIndlYnBhY2s6Ly9mbGFzay1wcmVhY3QtdHlwZXNjcmlwdC10YWlsd2luZC10ZW1wbGF0ZS8uL2FwcC9zdGF0aWMvcGFnZXMvbGF5b3V0LnRzeCIsIndlYnBhY2s6Ly9mbGFzay1wcmVhY3QtdHlwZXNjcmlwdC10YWlsd2luZC10ZW1wbGF0ZS8uL2FwcC9zdGF0aWMvcGFnZXMvcGFnZS50c3giLCJ3ZWJwYWNrOi8vZmxhc2stcHJlYWN0LXR5cGVzY3JpcHQtdGFpbHdpbmQtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvcHJlYWN0LXJvdXRlci9kaXN0L3ByZWFjdC1yb3V0ZXIubWpzIiwid2VicGFjazovL2ZsYXNrLXByZWFjdC10eXBlc2NyaXB0LXRhaWx3aW5kLXRlbXBsYXRlL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL2ZsYXNrLXByZWFjdC10eXBlc2NyaXB0LXRhaWx3aW5kLXRlbXBsYXRlL3dlYnBhY2svcnVudGltZS9jb21wYXQgZ2V0IGRlZmF1bHQgZXhwb3J0Iiwid2VicGFjazovL2ZsYXNrLXByZWFjdC10eXBlc2NyaXB0LXRhaWx3aW5kLXRlbXBsYXRlL3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly9mbGFzay1wcmVhY3QtdHlwZXNjcmlwdC10YWlsd2luZC10ZW1wbGF0ZS93ZWJwYWNrL3J1bnRpbWUvZ2V0IGphdmFzY3JpcHQgdXBkYXRlIGNodW5rIGZpbGVuYW1lIiwid2VicGFjazovL2ZsYXNrLXByZWFjdC10eXBlc2NyaXB0LXRhaWx3aW5kLXRlbXBsYXRlL3dlYnBhY2svcnVudGltZS9nZXQgdXBkYXRlIG1hbmlmZXN0IGZpbGVuYW1lIiwid2VicGFjazovL2ZsYXNrLXByZWFjdC10eXBlc2NyaXB0LXRhaWx3aW5kLXRlbXBsYXRlL3dlYnBhY2svcnVudGltZS9nZXRGdWxsSGFzaCIsIndlYnBhY2s6Ly9mbGFzay1wcmVhY3QtdHlwZXNjcmlwdC10YWlsd2luZC10ZW1wbGF0ZS93ZWJwYWNrL3J1bnRpbWUvZ2xvYmFsIiwid2VicGFjazovL2ZsYXNrLXByZWFjdC10eXBlc2NyaXB0LXRhaWx3aW5kLXRlbXBsYXRlL3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vZmxhc2stcHJlYWN0LXR5cGVzY3JpcHQtdGFpbHdpbmQtdGVtcGxhdGUvd2VicGFjay9ydW50aW1lL2xvYWQgc2NyaXB0Iiwid2VicGFjazovL2ZsYXNrLXByZWFjdC10eXBlc2NyaXB0LXRhaWx3aW5kLXRlbXBsYXRlL3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vZmxhc2stcHJlYWN0LXR5cGVzY3JpcHQtdGFpbHdpbmQtdGVtcGxhdGUvd2VicGFjay9ydW50aW1lL2hvdCBtb2R1bGUgcmVwbGFjZW1lbnQiLCJ3ZWJwYWNrOi8vZmxhc2stcHJlYWN0LXR5cGVzY3JpcHQtdGFpbHdpbmQtdGVtcGxhdGUvd2VicGFjay9ydW50aW1lL3B1YmxpY1BhdGgiLCJ3ZWJwYWNrOi8vZmxhc2stcHJlYWN0LXR5cGVzY3JpcHQtdGFpbHdpbmQtdGVtcGxhdGUvd2VicGFjay9ydW50aW1lL2pzb25wIGNodW5rIGxvYWRpbmciLCJ3ZWJwYWNrOi8vZmxhc2stcHJlYWN0LXR5cGVzY3JpcHQtdGFpbHdpbmQtdGVtcGxhdGUvd2VicGFjay9ydW50aW1lL25vbmNlIiwid2VicGFjazovL2ZsYXNrLXByZWFjdC10eXBlc2NyaXB0LXRhaWx3aW5kLXRlbXBsYXRlL3dlYnBhY2svYmVmb3JlLXN0YXJ0dXAiLCJ3ZWJwYWNrOi8vZmxhc2stcHJlYWN0LXR5cGVzY3JpcHQtdGFpbHdpbmQtdGVtcGxhdGUvd2VicGFjay9zdGFydHVwIiwid2VicGFjazovL2ZsYXNrLXByZWFjdC10eXBlc2NyaXB0LXRhaWx3aW5kLXRlbXBsYXRlL3dlYnBhY2svYWZ0ZXItc3RhcnR1cCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuQ29weXJpZ2h0IChjKSAyMDIxLXByZXNlbnQgTkFWRVIgQ29ycC5cbm5hbWU6IEBlZ2pzL3ByZWFjdC1mbGlja2luZ1xubGljZW5zZTogTUlUXG5hdXRob3I6IE5BVkVSIENvcnAuXG5yZXBvc2l0b3J5OiBodHRwczovL2dpdGh1Yi5jb20vbmF2ZXIvZWdqcy1mbGlja2luZy9ibG9iL21hc3Rlci9wYWNrYWdlcy9wcmVhY3QtZmxpY2tpbmdcbnZlcnNpb246IDQuMTEuNFxuKi9cbmltcG9ydCB7IG9wdGlvbnMsIENvbXBvbmVudCBhcyBDb21wb25lbnQkMSwgY3JlYXRlRWxlbWVudCwgRnJhZ21lbnQsIHRvQ2hpbGRBcnJheSwgY3JlYXRlQ29udGV4dCwgY3JlYXRlUmVmLCByZW5kZXIsIGh5ZHJhdGUsIGNsb25lRWxlbWVudCB9IGZyb20gJ3ByZWFjdCc7XG5cbnZhciB0LHUscixvPTAsaT1bXSxjPW9wdGlvbnMuX19iLGY9b3B0aW9ucy5fX3IsZT1vcHRpb25zLmRpZmZlZCxhPW9wdGlvbnMuX19jLHY9b3B0aW9ucy51bm1vdW50O2Z1bmN0aW9uIG0odCxyKXtvcHRpb25zLl9faCYmb3B0aW9ucy5fX2godSx0LG98fHIpLG89MDt2YXIgaT11Ll9fSHx8KHUuX19IPXtfXzpbXSxfX2g6W119KTtyZXR1cm4gdD49aS5fXy5sZW5ndGgmJmkuX18ucHVzaCh7fSksaS5fX1t0XX1mdW5jdGlvbiBsKG4pe3JldHVybiBvPTEscCh3LG4pfWZ1bmN0aW9uIHAobixyLG8pe3ZhciBpPW0odCsrLDIpO3JldHVybiBpLnQ9bixpLl9fY3x8KGkuX189W28/byhyKTp3KHZvaWQgMCxyKSxmdW5jdGlvbihuKXt2YXIgdD1pLnQoaS5fX1swXSxuKTtpLl9fWzBdIT09dCYmKGkuX189W3QsaS5fX1sxXV0saS5fX2Muc2V0U3RhdGUoe30pKTt9XSxpLl9fYz11KSxpLl9ffWZ1bmN0aW9uIHkocixvKXt2YXIgaT1tKHQrKywzKTshb3B0aW9ucy5fX3MmJmsoaS5fX0gsbykmJihpLl9fPXIsaS5fX0g9byx1Ll9fSC5fX2gucHVzaChpKSk7fWZ1bmN0aW9uIGgocixvKXt2YXIgaT1tKHQrKyw0KTshb3B0aW9ucy5fX3MmJmsoaS5fX0gsbykmJihpLl9fPXIsaS5fX0g9byx1Ll9faC5wdXNoKGkpKTt9ZnVuY3Rpb24gcyhuKXtyZXR1cm4gbz01LGQoZnVuY3Rpb24oKXtyZXR1cm4ge2N1cnJlbnQ6bn19LFtdKX1mdW5jdGlvbiBfKG4sdCx1KXtvPTYsaChmdW5jdGlvbigpe1wiZnVuY3Rpb25cIj09dHlwZW9mIG4/bih0KCkpOm4mJihuLmN1cnJlbnQ9dCgpKTt9LG51bGw9PXU/dTp1LmNvbmNhdChuKSk7fWZ1bmN0aW9uIGQobix1KXt2YXIgcj1tKHQrKyw3KTtyZXR1cm4gayhyLl9fSCx1KSYmKHIuX189bigpLHIuX19IPXUsci5fX2g9biksci5fX31mdW5jdGlvbiBBKG4sdCl7cmV0dXJuIG89OCxkKGZ1bmN0aW9uKCl7cmV0dXJuIG59LHQpfWZ1bmN0aW9uIEYobil7dmFyIHI9dS5jb250ZXh0W24uX19jXSxvPW0odCsrLDkpO3JldHVybiBvLmM9bixyPyhudWxsPT1vLl9fJiYoby5fXz0hMCxyLnN1Yih1KSksci5wcm9wcy52YWx1ZSk6bi5fX31mdW5jdGlvbiBUKHQsdSl7b3B0aW9ucy51c2VEZWJ1Z1ZhbHVlJiZvcHRpb25zLnVzZURlYnVnVmFsdWUodT91KHQpOnQpO31mdW5jdGlvbiB4KCl7dmFyIHQ7Zm9yKGkuc29ydChmdW5jdGlvbihuLHQpe3JldHVybiBuLl9fdi5fX2ItdC5fX3YuX19ifSk7dD1pLnBvcCgpOylpZih0Ll9fUCl0cnl7dC5fX0guX19oLmZvckVhY2goZyksdC5fX0guX19oLmZvckVhY2goaiksdC5fX0guX19oPVtdO31jYXRjaCh1KXt0Ll9fSC5fX2g9W10sb3B0aW9ucy5fX2UodSx0Ll9fdik7fX1vcHRpb25zLl9fYj1mdW5jdGlvbihuKXt1PW51bGwsYyYmYyhuKTt9LG9wdGlvbnMuX19yPWZ1bmN0aW9uKG4pe2YmJmYobiksdD0wO3ZhciByPSh1PW4uX19jKS5fX0g7ciYmKHIuX19oLmZvckVhY2goZyksci5fX2guZm9yRWFjaChqKSxyLl9faD1bXSk7fSxvcHRpb25zLmRpZmZlZD1mdW5jdGlvbih0KXtlJiZlKHQpO3ZhciBvPXQuX19jO28mJm8uX19IJiZvLl9fSC5fX2gubGVuZ3RoJiYoMSE9PWkucHVzaChvKSYmcj09PW9wdGlvbnMucmVxdWVzdEFuaW1hdGlvbkZyYW1lfHwoKHI9b3B0aW9ucy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpfHxmdW5jdGlvbihuKXt2YXIgdCx1PWZ1bmN0aW9uKCl7Y2xlYXJUaW1lb3V0KHIpLGImJmNhbmNlbEFuaW1hdGlvbkZyYW1lKHQpLHNldFRpbWVvdXQobik7fSxyPXNldFRpbWVvdXQodSwxMDApO2ImJih0PXJlcXVlc3RBbmltYXRpb25GcmFtZSh1KSk7fSkoeCkpLHU9bnVsbDt9LG9wdGlvbnMuX19jPWZ1bmN0aW9uKHQsdSl7dS5zb21lKGZ1bmN0aW9uKHQpe3RyeXt0Ll9faC5mb3JFYWNoKGcpLHQuX19oPXQuX19oLmZpbHRlcihmdW5jdGlvbihuKXtyZXR1cm4gIW4uX198fGoobil9KTt9Y2F0Y2gocil7dS5zb21lKGZ1bmN0aW9uKG4pe24uX19oJiYobi5fX2g9W10pO30pLHU9W10sb3B0aW9ucy5fX2Uocix0Ll9fdik7fX0pLGEmJmEodCx1KTt9LG9wdGlvbnMudW5tb3VudD1mdW5jdGlvbih0KXt2JiZ2KHQpO3ZhciB1LHI9dC5fX2M7ciYmci5fX0gmJihyLl9fSC5fXy5mb3JFYWNoKGZ1bmN0aW9uKG4pe3RyeXtnKG4pO31jYXRjaChuKXt1PW47fX0pLHUmJm9wdGlvbnMuX19lKHUsci5fX3YpKTt9O3ZhciBiPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVlc3RBbmltYXRpb25GcmFtZTtmdW5jdGlvbiBnKG4pe3ZhciB0PXUscj1uLl9fYztcImZ1bmN0aW9uXCI9PXR5cGVvZiByJiYobi5fX2M9dm9pZCAwLHIoKSksdT10O31mdW5jdGlvbiBqKG4pe3ZhciB0PXU7bi5fX2M9bi5fXygpLHU9dDt9ZnVuY3Rpb24gayhuLHQpe3JldHVybiAhbnx8bi5sZW5ndGghPT10Lmxlbmd0aHx8dC5zb21lKGZ1bmN0aW9uKHQsdSl7cmV0dXJuIHQhPT1uW3VdfSl9ZnVuY3Rpb24gdyhuLHQpe3JldHVybiBcImZ1bmN0aW9uXCI9PXR5cGVvZiB0P3Qobik6dH1cblxuZnVuY3Rpb24gUyhuLHQpe2Zvcih2YXIgZSBpbiB0KW5bZV09dFtlXTtyZXR1cm4gbn1mdW5jdGlvbiBDKG4sdCl7Zm9yKHZhciBlIGluIG4paWYoXCJfX3NvdXJjZVwiIT09ZSYmIShlIGluIHQpKXJldHVybiAhMDtmb3IodmFyIHIgaW4gdClpZihcIl9fc291cmNlXCIhPT1yJiZuW3JdIT09dFtyXSlyZXR1cm4gITA7cmV0dXJuICExfWZ1bmN0aW9uIEUobil7dGhpcy5wcm9wcz1uO31mdW5jdGlvbiBnJDEobix0KXtmdW5jdGlvbiBlKG4pe3ZhciBlPXRoaXMucHJvcHMucmVmLHI9ZT09bi5yZWY7cmV0dXJuICFyJiZlJiYoZS5jYWxsP2UobnVsbCk6ZS5jdXJyZW50PW51bGwpLHQ/IXQodGhpcy5wcm9wcyxuKXx8IXI6Qyh0aGlzLnByb3BzLG4pfWZ1bmN0aW9uIHIodCl7cmV0dXJuIHRoaXMuc2hvdWxkQ29tcG9uZW50VXBkYXRlPWUsY3JlYXRlRWxlbWVudChuLHQpfXJldHVybiByLmRpc3BsYXlOYW1lPVwiTWVtbyhcIisobi5kaXNwbGF5TmFtZXx8bi5uYW1lKStcIilcIixyLnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50PSEwLHIuX19mPSEwLHJ9KEUucHJvdG90eXBlPW5ldyBDb21wb25lbnQkMSkuaXNQdXJlUmVhY3RDb21wb25lbnQ9ITAsRS5wcm90b3R5cGUuc2hvdWxkQ29tcG9uZW50VXBkYXRlPWZ1bmN0aW9uKG4sdCl7cmV0dXJuIEModGhpcy5wcm9wcyxuKXx8Qyh0aGlzLnN0YXRlLHQpfTt2YXIgdyQxPW9wdGlvbnMuX19iO29wdGlvbnMuX19iPWZ1bmN0aW9uKG4pe24udHlwZSYmbi50eXBlLl9fZiYmbi5yZWYmJihuLnByb3BzLnJlZj1uLnJlZixuLnJlZj1udWxsKSx3JDEmJnckMShuKTt9O3ZhciBSPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBTeW1ib2wmJlN5bWJvbC5mb3ImJlN5bWJvbC5mb3IoXCJyZWFjdC5mb3J3YXJkX3JlZlwiKXx8MzkxMTtmdW5jdGlvbiB4JDEobil7ZnVuY3Rpb24gdCh0LGUpe3ZhciByPVMoe30sdCk7cmV0dXJuIGRlbGV0ZSByLnJlZixuKHIsKGU9dC5yZWZ8fGUpJiYoXCJvYmplY3RcIiE9dHlwZW9mIGV8fFwiY3VycmVudFwiaW4gZSk/ZTpudWxsKX1yZXR1cm4gdC4kJHR5cGVvZj1SLHQucmVuZGVyPXQsdC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudD10Ll9fZj0hMCx0LmRpc3BsYXlOYW1lPVwiRm9yd2FyZFJlZihcIisobi5kaXNwbGF5TmFtZXx8bi5uYW1lKStcIilcIix0fXZhciBOPWZ1bmN0aW9uKG4sdCl7cmV0dXJuIG51bGw9PW4/bnVsbDp0b0NoaWxkQXJyYXkodG9DaGlsZEFycmF5KG4pLm1hcCh0KSl9LGskMT17bWFwOk4sZm9yRWFjaDpOLGNvdW50OmZ1bmN0aW9uKG4pe3JldHVybiBuP3RvQ2hpbGRBcnJheShuKS5sZW5ndGg6MH0sb25seTpmdW5jdGlvbihuKXt2YXIgdD10b0NoaWxkQXJyYXkobik7aWYoMSE9PXQubGVuZ3RoKXRocm93IFwiQ2hpbGRyZW4ub25seVwiO3JldHVybiB0WzBdfSx0b0FycmF5OnRvQ2hpbGRBcnJheX0sQSQxPW9wdGlvbnMuX19lO29wdGlvbnMuX19lPWZ1bmN0aW9uKG4sdCxlKXtpZihuLnRoZW4pZm9yKHZhciByLHU9dDt1PXUuX187KWlmKChyPXUuX19jKSYmci5fX2MpcmV0dXJuIG51bGw9PXQuX19lJiYodC5fX2U9ZS5fX2UsdC5fX2s9ZS5fX2spLHIuX19jKG4sdCk7QSQxKG4sdCxlKTt9O3ZhciBPPW9wdGlvbnMudW5tb3VudDtmdW5jdGlvbiBMKCl7dGhpcy5fX3U9MCx0aGlzLnQ9bnVsbCx0aGlzLl9fYj1udWxsO31mdW5jdGlvbiBVKG4pe3ZhciB0PW4uX18uX19jO3JldHVybiB0JiZ0Ll9fZSYmdC5fX2Uobil9ZnVuY3Rpb24gRiQxKG4pe3ZhciB0LGUscjtmdW5jdGlvbiB1KHUpe2lmKHR8fCh0PW4oKSkudGhlbihmdW5jdGlvbihuKXtlPW4uZGVmYXVsdHx8bjt9LGZ1bmN0aW9uKG4pe3I9bjt9KSxyKXRocm93IHI7aWYoIWUpdGhyb3cgdDtyZXR1cm4gY3JlYXRlRWxlbWVudChlLHUpfXJldHVybiB1LmRpc3BsYXlOYW1lPVwiTGF6eVwiLHUuX19mPSEwLHV9ZnVuY3Rpb24gTSgpe3RoaXMudT1udWxsLHRoaXMubz1udWxsO31vcHRpb25zLnVubW91bnQ9ZnVuY3Rpb24obil7dmFyIHQ9bi5fX2M7dCYmdC5fX1ImJnQuX19SKCksdCYmITA9PT1uLl9faCYmKG4udHlwZT1udWxsKSxPJiZPKG4pO30sKEwucHJvdG90eXBlPW5ldyBDb21wb25lbnQkMSkuX19jPWZ1bmN0aW9uKG4sdCl7dmFyIGU9dC5fX2Mscj10aGlzO251bGw9PXIudCYmKHIudD1bXSksci50LnB1c2goZSk7dmFyIHU9VShyLl9fdiksbz0hMSxpPWZ1bmN0aW9uKCl7b3x8KG89ITAsZS5fX1I9bnVsbCx1P3UobCk6bCgpKTt9O2UuX19SPWk7dmFyIGw9ZnVuY3Rpb24oKXtpZighLS1yLl9fdSl7aWYoci5zdGF0ZS5fX2Upe3ZhciBuPXIuc3RhdGUuX19lO3IuX192Ll9fa1swXT1mdW5jdGlvbiBuKHQsZSxyKXtyZXR1cm4gdCYmKHQuX192PW51bGwsdC5fX2s9dC5fX2smJnQuX19rLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gbih0LGUscil9KSx0Ll9fYyYmdC5fX2MuX19QPT09ZSYmKHQuX19lJiZyLmluc2VydEJlZm9yZSh0Ll9fZSx0Ll9fZCksdC5fX2MuX19lPSEwLHQuX19jLl9fUD1yKSksdH0obixuLl9fYy5fX1Asbi5fX2MuX19PKTt9dmFyIHQ7Zm9yKHIuc2V0U3RhdGUoe19fZTpyLl9fYj1udWxsfSk7dD1yLnQucG9wKCk7KXQuZm9yY2VVcGRhdGUoKTt9fSxjPSEwPT09dC5fX2g7ci5fX3UrK3x8Y3x8ci5zZXRTdGF0ZSh7X19lOnIuX19iPXIuX192Ll9fa1swXX0pLG4udGhlbihpLGkpO30sTC5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQ9ZnVuY3Rpb24oKXt0aGlzLnQ9W107fSxMLnByb3RvdHlwZS5yZW5kZXI9ZnVuY3Rpb24obix0KXtpZih0aGlzLl9fYil7aWYodGhpcy5fX3YuX19rKXt2YXIgZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLHI9dGhpcy5fX3YuX19rWzBdLl9fYzt0aGlzLl9fdi5fX2tbMF09ZnVuY3Rpb24gbih0LGUscil7cmV0dXJuIHQmJih0Ll9fYyYmdC5fX2MuX19IJiYodC5fX2MuX19ILl9fLmZvckVhY2goZnVuY3Rpb24obil7XCJmdW5jdGlvblwiPT10eXBlb2Ygbi5fX2MmJm4uX19jKCk7fSksdC5fX2MuX19IPW51bGwpLG51bGwhPSh0PVMoe30sdCkpLl9fYyYmKHQuX19jLl9fUD09PXImJih0Ll9fYy5fX1A9ZSksdC5fX2M9bnVsbCksdC5fX2s9dC5fX2smJnQuX19rLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gbih0LGUscil9KSksdH0odGhpcy5fX2IsZSxyLl9fTz1yLl9fUCk7fXRoaXMuX19iPW51bGw7fXZhciB1PXQuX19lJiZjcmVhdGVFbGVtZW50KEZyYWdtZW50LG51bGwsbi5mYWxsYmFjayk7cmV0dXJuIHUmJih1Ll9faD1udWxsKSxbY3JlYXRlRWxlbWVudChGcmFnbWVudCxudWxsLHQuX19lP251bGw6bi5jaGlsZHJlbiksdV19O3ZhciBUJDE9ZnVuY3Rpb24obix0LGUpe2lmKCsrZVsxXT09PWVbMF0mJm4uby5kZWxldGUodCksbi5wcm9wcy5yZXZlYWxPcmRlciYmKFwidFwiIT09bi5wcm9wcy5yZXZlYWxPcmRlclswXXx8IW4uby5zaXplKSlmb3IoZT1uLnU7ZTspe2Zvcig7ZS5sZW5ndGg+MzspZS5wb3AoKSgpO2lmKGVbMV08ZVswXSlicmVhaztuLnU9ZT1lWzJdO319O2Z1bmN0aW9uIEQobil7cmV0dXJuIHRoaXMuZ2V0Q2hpbGRDb250ZXh0PWZ1bmN0aW9uKCl7cmV0dXJuIG4uY29udGV4dH0sbi5jaGlsZHJlbn1mdW5jdGlvbiBJKG4pe3ZhciB0PXRoaXMsZT1uLmk7dC5jb21wb25lbnRXaWxsVW5tb3VudD1mdW5jdGlvbigpe3JlbmRlcihudWxsLHQubCksdC5sPW51bGwsdC5pPW51bGw7fSx0LmkmJnQuaSE9PWUmJnQuY29tcG9uZW50V2lsbFVubW91bnQoKSxuLl9fdj8odC5sfHwodC5pPWUsdC5sPXtub2RlVHlwZToxLHBhcmVudE5vZGU6ZSxjaGlsZE5vZGVzOltdLGFwcGVuZENoaWxkOmZ1bmN0aW9uKG4pe3RoaXMuY2hpbGROb2Rlcy5wdXNoKG4pLHQuaS5hcHBlbmRDaGlsZChuKTt9LGluc2VydEJlZm9yZTpmdW5jdGlvbihuLGUpe3RoaXMuY2hpbGROb2Rlcy5wdXNoKG4pLHQuaS5hcHBlbmRDaGlsZChuKTt9LHJlbW92ZUNoaWxkOmZ1bmN0aW9uKG4pe3RoaXMuY2hpbGROb2Rlcy5zcGxpY2UodGhpcy5jaGlsZE5vZGVzLmluZGV4T2Yobik+Pj4xLDEpLHQuaS5yZW1vdmVDaGlsZChuKTt9fSkscmVuZGVyKGNyZWF0ZUVsZW1lbnQoRCx7Y29udGV4dDp0LmNvbnRleHR9LG4uX192KSx0LmwpKTp0LmwmJnQuY29tcG9uZW50V2lsbFVubW91bnQoKTt9ZnVuY3Rpb24gVyhuLHQpe3JldHVybiBjcmVhdGVFbGVtZW50KEkse19fdjpuLGk6dH0pfShNLnByb3RvdHlwZT1uZXcgQ29tcG9uZW50JDEpLl9fZT1mdW5jdGlvbihuKXt2YXIgdD10aGlzLGU9VSh0Ll9fdikscj10Lm8uZ2V0KG4pO3JldHVybiByWzBdKyssZnVuY3Rpb24odSl7dmFyIG89ZnVuY3Rpb24oKXt0LnByb3BzLnJldmVhbE9yZGVyPyhyLnB1c2godSksVCQxKHQsbixyKSk6dSgpO307ZT9lKG8pOm8oKTt9fSxNLnByb3RvdHlwZS5yZW5kZXI9ZnVuY3Rpb24obil7dGhpcy51PW51bGwsdGhpcy5vPW5ldyBNYXA7dmFyIHQ9dG9DaGlsZEFycmF5KG4uY2hpbGRyZW4pO24ucmV2ZWFsT3JkZXImJlwiYlwiPT09bi5yZXZlYWxPcmRlclswXSYmdC5yZXZlcnNlKCk7Zm9yKHZhciBlPXQubGVuZ3RoO2UtLTspdGhpcy5vLnNldCh0W2VdLHRoaXMudT1bMSwwLHRoaXMudV0pO3JldHVybiBuLmNoaWxkcmVufSxNLnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGU9TS5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQ9ZnVuY3Rpb24oKXt2YXIgbj10aGlzO3RoaXMuby5mb3JFYWNoKGZ1bmN0aW9uKHQsZSl7VCQxKG4sZSx0KTt9KTt9O3ZhciBqJDE9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmU3ltYm9sLmZvciYmU3ltYm9sLmZvcihcInJlYWN0LmVsZW1lbnRcIil8fDYwMTAzLFA9L14oPzphY2NlbnR8YWxpZ25tZW50fGFyYWJpY3xiYXNlbGluZXxjYXB8Y2xpcCg/IVBhdGhVKXxjb2xvcnxkb21pbmFudHxmaWxsfGZsb29kfGZvbnR8Z2x5cGgoPyFSKXxob3JpenxtYXJrZXIoPyFIfFd8VSl8b3ZlcmxpbmV8cGFpbnR8c3RvcHxzdHJpa2V0aHJvdWdofHN0cm9rZXx0ZXh0KD8hTCl8dW5kZXJsaW5lfHVuaWNvZGV8dW5pdHN8dnx2ZWN0b3J8dmVydHx3b3JkfHdyaXRpbmd8eCg/IUMpKVtBLVpdLyxWPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBkb2N1bWVudCx6PWZ1bmN0aW9uKG4pe3JldHVybiAoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbCgpPy9maWx8Y2hlfHJhZC9pOi9maWx8Y2hlfHJhL2kpLnRlc3Qobil9O2Z1bmN0aW9uIEIobix0LGUpe3JldHVybiBudWxsPT10Ll9fayYmKHQudGV4dENvbnRlbnQ9XCJcIikscmVuZGVyKG4sdCksXCJmdW5jdGlvblwiPT10eXBlb2YgZSYmZSgpLG4/bi5fX2M6bnVsbH1mdW5jdGlvbiAkKG4sdCxlKXtyZXR1cm4gaHlkcmF0ZShuLHQpLFwiZnVuY3Rpb25cIj09dHlwZW9mIGUmJmUoKSxuP24uX19jOm51bGx9Q29tcG9uZW50JDEucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQ9e30sW1wiY29tcG9uZW50V2lsbE1vdW50XCIsXCJjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzXCIsXCJjb21wb25lbnRXaWxsVXBkYXRlXCJdLmZvckVhY2goZnVuY3Rpb24obil7T2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBvbmVudCQxLnByb3RvdHlwZSxuLHtjb25maWd1cmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXNbXCJVTlNBRkVfXCIrbl19LHNldDpmdW5jdGlvbih0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcyxuLHtjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dH0pO319KTt9KTt2YXIgSD1vcHRpb25zLmV2ZW50O2Z1bmN0aW9uIFooKXt9ZnVuY3Rpb24gWSgpe3JldHVybiB0aGlzLmNhbmNlbEJ1YmJsZX1mdW5jdGlvbiBxKCl7cmV0dXJuIHRoaXMuZGVmYXVsdFByZXZlbnRlZH1vcHRpb25zLmV2ZW50PWZ1bmN0aW9uKG4pe3JldHVybiBIJiYobj1IKG4pKSxuLnBlcnNpc3Q9WixuLmlzUHJvcGFnYXRpb25TdG9wcGVkPVksbi5pc0RlZmF1bHRQcmV2ZW50ZWQ9cSxuLm5hdGl2ZUV2ZW50PW59O3ZhciBHLEo9e2NvbmZpZ3VyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jbGFzc319LEs9b3B0aW9ucy52bm9kZTtvcHRpb25zLnZub2RlPWZ1bmN0aW9uKG4pe3ZhciB0PW4udHlwZSxlPW4ucHJvcHMscj1lO2lmKFwic3RyaW5nXCI9PXR5cGVvZiB0KXt2YXIgdT0tMT09PXQuaW5kZXhPZihcIi1cIik7Zm9yKHZhciBvIGluIHI9e30sZSl7dmFyIGk9ZVtvXTtWJiZcImNoaWxkcmVuXCI9PT1vJiZcIm5vc2NyaXB0XCI9PT10fHxcInZhbHVlXCI9PT1vJiZcImRlZmF1bHRWYWx1ZVwiaW4gZSYmbnVsbD09aXx8KFwiZGVmYXVsdFZhbHVlXCI9PT1vJiZcInZhbHVlXCJpbiBlJiZudWxsPT1lLnZhbHVlP289XCJ2YWx1ZVwiOlwiZG93bmxvYWRcIj09PW8mJiEwPT09aT9pPVwiXCI6L29uZG91YmxlY2xpY2svaS50ZXN0KG8pP289XCJvbmRibGNsaWNrXCI6L15vbmNoYW5nZSh0ZXh0YXJlYXxpbnB1dCkvaS50ZXN0KG8rdCkmJiF6KGUudHlwZSk/bz1cIm9uaW5wdXRcIjovXm9uZm9jdXMkL2kudGVzdChvKT9vPVwib25mb2N1c2luXCI6L15vbmJsdXIkL2kudGVzdChvKT9vPVwib25mb2N1c291dFwiOi9eb24oQW5pfFRyYXxUb3V8QmVmb3JlSW5wKS8udGVzdChvKT9vPW8udG9Mb3dlckNhc2UoKTp1JiZQLnRlc3Qobyk/bz1vLnJlcGxhY2UoL1tBLVowLTldLyxcIi0kJlwiKS50b0xvd2VyQ2FzZSgpOm51bGw9PT1pJiYoaT12b2lkIDApLHJbb109aSk7fVwic2VsZWN0XCI9PXQmJnIubXVsdGlwbGUmJkFycmF5LmlzQXJyYXkoci52YWx1ZSkmJihyLnZhbHVlPXRvQ2hpbGRBcnJheShlLmNoaWxkcmVuKS5mb3JFYWNoKGZ1bmN0aW9uKG4pe24ucHJvcHMuc2VsZWN0ZWQ9LTEhPXIudmFsdWUuaW5kZXhPZihuLnByb3BzLnZhbHVlKTt9KSksXCJzZWxlY3RcIj09dCYmbnVsbCE9ci5kZWZhdWx0VmFsdWUmJihyLnZhbHVlPXRvQ2hpbGRBcnJheShlLmNoaWxkcmVuKS5mb3JFYWNoKGZ1bmN0aW9uKG4pe24ucHJvcHMuc2VsZWN0ZWQ9ci5tdWx0aXBsZT8tMSE9ci5kZWZhdWx0VmFsdWUuaW5kZXhPZihuLnByb3BzLnZhbHVlKTpyLmRlZmF1bHRWYWx1ZT09bi5wcm9wcy52YWx1ZTt9KSksbi5wcm9wcz1yLGUuY2xhc3MhPWUuY2xhc3NOYW1lJiYoSi5lbnVtZXJhYmxlPVwiY2xhc3NOYW1lXCJpbiBlLG51bGwhPWUuY2xhc3NOYW1lJiYoci5jbGFzcz1lLmNsYXNzTmFtZSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHIsXCJjbGFzc05hbWVcIixKKSk7fW4uJCR0eXBlb2Y9aiQxLEsmJksobik7fTt2YXIgUT1vcHRpb25zLl9fcjtvcHRpb25zLl9fcj1mdW5jdGlvbihuKXtRJiZRKG4pLEc9bi5fX2M7fTt2YXIgWD17UmVhY3RDdXJyZW50RGlzcGF0Y2hlcjp7Y3VycmVudDp7cmVhZENvbnRleHQ6ZnVuY3Rpb24obil7cmV0dXJuIEcuX19uW24uX19jXS5wcm9wcy52YWx1ZX19fX07ZnVuY3Rpb24gdG4obil7cmV0dXJuIGNyZWF0ZUVsZW1lbnQuYmluZChudWxsLG4pfWZ1bmN0aW9uIGVuKG4pe3JldHVybiAhIW4mJm4uJCR0eXBlb2Y9PT1qJDF9ZnVuY3Rpb24gcm4obil7cmV0dXJuIGVuKG4pP2Nsb25lRWxlbWVudC5hcHBseShudWxsLGFyZ3VtZW50cyk6bn1mdW5jdGlvbiB1bihuKXtyZXR1cm4gISFuLl9fayYmKHJlbmRlcihudWxsLG4pLCEwKX1mdW5jdGlvbiBvbihuKXtyZXR1cm4gbiYmKG4uYmFzZXx8MT09PW4ubm9kZVR5cGUmJm4pfHxudWxsfXZhciBsbj1mdW5jdGlvbihuLHQpe3JldHVybiBuKHQpfSxjbj1mdW5jdGlvbihuLHQpe3JldHVybiBuKHQpfTt2YXIgUmVhY3RfX2RlZmF1bHQgPSB7dXNlU3RhdGU6bCx1c2VSZWR1Y2VyOnAsdXNlRWZmZWN0OnksdXNlTGF5b3V0RWZmZWN0OmgsdXNlUmVmOnMsdXNlSW1wZXJhdGl2ZUhhbmRsZTpfLHVzZU1lbW86ZCx1c2VDYWxsYmFjazpBLHVzZUNvbnRleHQ6Rix1c2VEZWJ1Z1ZhbHVlOlQsdmVyc2lvbjpcIjE3LjAuMlwiLENoaWxkcmVuOmskMSxyZW5kZXI6QixoeWRyYXRlOiQsdW5tb3VudENvbXBvbmVudEF0Tm9kZTp1bixjcmVhdGVQb3J0YWw6VyxjcmVhdGVFbGVtZW50OmNyZWF0ZUVsZW1lbnQsY3JlYXRlQ29udGV4dDpjcmVhdGVDb250ZXh0LGNyZWF0ZUZhY3Rvcnk6dG4sY2xvbmVFbGVtZW50OnJuLGNyZWF0ZVJlZjpjcmVhdGVSZWYsRnJhZ21lbnQ6RnJhZ21lbnQsaXNWYWxpZEVsZW1lbnQ6ZW4sZmluZERPTU5vZGU6b24sQ29tcG9uZW50OkNvbXBvbmVudCQxLFB1cmVDb21wb25lbnQ6RSxtZW1vOmckMSxmb3J3YXJkUmVmOngkMSxmbHVzaFN5bmM6Y24sdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXM6bG4sU3RyaWN0TW9kZTpGcmFnbWVudCxTdXNwZW5zZTpMLFN1c3BlbnNlTGlzdDpNLGxhenk6RiQxLF9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEOlh9O1xuXG4vKlxuQ29weXJpZ2h0IChjKSBOQVZFUiBDb3JwLlxubmFtZTogQGVnanMvY29tcG9uZW50XG5saWNlbnNlOiBNSVRcbmF1dGhvcjogTkFWRVIgQ29ycC5cbnJlcG9zaXRvcnk6IGh0dHBzOi8vZ2l0aHViLmNvbS9uYXZlci9lZ2pzLWNvbXBvbmVudFxudmVyc2lvbjogMy4wLjRcbiovXG4vKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuZnVuY3Rpb24gX192YWx1ZXMobykge1xuICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsXG4gICAgbSA9IHMgJiYgb1tzXSxcbiAgICBpID0gMDtcbiAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XG4gIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcbiAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IG8gJiYgb1tpKytdLFxuICAgICAgICBkb25lOiAhb1xuICAgICAgfTtcbiAgICB9XG4gIH07XG4gIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn1cbmZ1bmN0aW9uIF9fcmVhZChvLCBuKSB7XG4gIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgaWYgKCFtKSByZXR1cm4gbztcbiAgdmFyIGkgPSBtLmNhbGwobyksXG4gICAgcixcbiAgICBhciA9IFtdLFxuICAgIGU7XG4gIHRyeSB7XG4gICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgZSA9IHtcbiAgICAgIGVycm9yOiBlcnJvclxuICAgIH07XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoZSkgdGhyb3cgZS5lcnJvcjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFyO1xufVxuZnVuY3Rpb24gX19zcHJlYWQoKSB7XG4gIGZvciAodmFyIGFyID0gW10sIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSBhciA9IGFyLmNvbmNhdChfX3JlYWQoYXJndW1lbnRzW2ldKSk7XG4gIHJldHVybiBhcjtcbn1cblxuLypcbiAqIENvcHlyaWdodCAoYykgMjAxNSBOQVZFUiBDb3JwLlxuICogZWdqcyBwcm9qZWN0cyBhcmUgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbnZhciBpc1VuZGVmaW5lZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiO1xufTtcblxuLy8gVGhpcyBjbGFzcyBuYW1lIGlzIG5vdCBtYXRjaGVkIHRvIGZpbGUgbmFtZSBpbnRlbnRpb25hbGx5XG4vKipcbiAqIEV2ZW50IGNsYXNzIHRvIHByb3ZpZGUgYWRkaXRpb25hbCBwcm9wZXJ0aWVzXG4gKiBAa28gQ29tcG9uZW507JeQ7IScIOy2lOqwgOyggeyduCDtlITroZztjbzti7Drpbwg7KCc6rO17ZWY64qUIOydtOuypO2KuCDtgbTrnpjsiqRcbiAqL1xudmFyIENvbXBvbmVudEV2ZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiBDb21wb25lbnRFdmVudC5cbiAgICogQGtvIENvbXBvbmVudEV2ZW507J2YIOyDiOuhnOyatCDsnbjsiqTthLTsiqTrpbwg7IOd7ISx7ZWc64ukLlxuICAgKiBAcGFyYW0gZXZlbnRUeXBlIFRoZSBuYW1lIG9mIHRoZSBldmVudC48a28+7J2067Kk7Yq4IOydtOumhC48L2tvPlxuICAgKiBAcGFyYW0gcHJvcHMgQW4gb2JqZWN0IHRoYXQgY29udGFpbnMgYWRkaXRpb25hbCBldmVudCBwcm9wZXJ0aWVzLjxrbz7stpTqsIDsoIHsnbgg7J2067Kk7Yq4IO2UhOuhnO2NvO2LsCDsmKTruIzsoJ3tirguPC9rbz5cbiAgICovXG4gIGZ1bmN0aW9uIENvbXBvbmVudEV2ZW50KGV2ZW50VHlwZSwgcHJvcHMpIHtcbiAgICB2YXIgZV8xLCBfYTtcbiAgICB0aGlzLl9jYW5jZWxlZCA9IGZhbHNlO1xuICAgIGlmIChwcm9wcykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyhPYmplY3Qua2V5cyhwcm9wcykpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgdmFyIGtleSA9IF9jLnZhbHVlO1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnRcbiAgICAgICAgICB0aGlzW2tleV0gPSBwcm9wc1trZXldO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlXzFfMSkge1xuICAgICAgICBlXzEgPSB7XG4gICAgICAgICAgZXJyb3I6IGVfMV8xXG4gICAgICAgIH07XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5ldmVudFR5cGUgPSBldmVudFR5cGU7XG4gIH1cbiAgLyoqXG4gICAqIFN0b3AgdGhlIGV2ZW50LiB7QGxpbmsgQ29tcG9uZW50RXZlbnQjaXNDYW5jZWxlZH0gd2lsbCByZXR1cm4gYHRydWVgIGFmdGVyLlxuICAgKiBAa28g7J2067Kk7Yq466W8IOykkeuLqO2VnOuLpC4g7J207ZuEIHtAbGluayBDb21wb25lbnRFdmVudCNpc0NhbmNlbGVkfeqwgCBgdHJ1ZWDrpbwg67CY7ZmY7ZWc64ukLlxuICAgKi9cbiAgdmFyIF9fcHJvdG8gPSBDb21wb25lbnRFdmVudC5wcm90b3R5cGU7XG4gIF9fcHJvdG8uc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9jYW5jZWxlZCA9IHRydWU7XG4gIH07XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgYm9vbGVhbiB2YWx1ZSB0aGF0IGluZGljYXRlcyB3aGV0aGVyIHtAbGluayBDb21wb25lbnRFdmVudCNzdG9wfSBpcyBjYWxsZWQgYmVmb3JlLlxuICAgKiBAa28ge0BsaW5rIENvbXBvbmVudEV2ZW50I3N0b3B97J20IO2YuOy2nOuQmOyXiOuKlOyngCDsl6zrtoDrpbwg67CY7ZmY7ZWc64ukLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBBIGJvb2xlYW4gdmFsdWUgdGhhdCBpbmRpY2F0ZXMgd2hldGhlciB7QGxpbmsgQ29tcG9uZW50RXZlbnQjc3RvcH0gaXMgY2FsbGVkIGJlZm9yZS48a28+7J207KCE7JeQIHtAbGluayBDb21wb25lbnRFdmVudCNzdG9wfeydtCDrtojroKTsoYzripTsp4Ag7Jes67aA66W8IOuwmO2ZmO2VnOuLpC48L2tvPlxuICAgKi9cbiAgX19wcm90by5pc0NhbmNlbGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9jYW5jZWxlZDtcbiAgfTtcbiAgcmV0dXJuIENvbXBvbmVudEV2ZW50O1xufSgpO1xuXG4vKipcbiAqIEEgY2xhc3MgdXNlZCB0byBtYW5hZ2UgZXZlbnRzIGluIGEgY29tcG9uZW50XG4gKiBAa28g7Lu07Y+s64SM7Yq47J2YIOydtOuypO2KuOydhCDqtIDrpqztlaAg7IiYIOyeiOqyjCDtlZjripQg7YG0656Y7IqkXG4gKi9cbnZhciBDb21wb25lbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHN1cHBvcnQge1wiaWVcIjogXCI3K1wiLCBcImNoXCIgOiBcImxhdGVzdFwiLCBcImZmXCIgOiBcImxhdGVzdFwiLCAgXCJzZlwiIDogXCJsYXRlc3RcIiwgXCJlZGdlXCIgOiBcImxhdGVzdFwiLCBcImlvc1wiIDogXCI3K1wiLCBcImFuXCIgOiBcIjIuMSsgKGV4Y2VwdCAzLngpXCJ9XG4gICAqL1xuICBmdW5jdGlvbiBDb21wb25lbnQoKSB7XG4gICAgdGhpcy5fZXZlbnRIYW5kbGVyID0ge307XG4gIH1cbiAgLyoqXG4gICAqIFRyaWdnZXIgYSBjdXN0b20gZXZlbnQuXG4gICAqIEBrbyDsu6TsiqTthYAg7J2067Kk7Yq466W8IOuwnOyDneyLnO2CqOuLpFxuICAgKiBAcGFyYW0ge3N0cmluZyB8IENvbXBvbmVudEV2ZW50fSBldmVudCBUaGUgbmFtZSBvZiB0aGUgY3VzdG9tIGV2ZW50IHRvIGJlIHRyaWdnZXJlZCBvciBhbiBpbnN0YW5jZSBvZiB0aGUgQ29tcG9uZW50RXZlbnQ8a28+67Cc7IOd7ZWgIOy7pOyKpO2FgCDsnbTrsqTtirjsnZgg7J2066aEIOuYkOuKlCBDb21wb25lbnRFdmVudOydmCDsnbjsiqTthLTsiqQ8L2tvPlxuICAgKiBAcGFyYW0ge2FueVtdfSBwYXJhbXMgRXZlbnQgZGF0YSB0byBiZSBzZW50IHdoZW4gdHJpZ2dlcmluZyBhIGN1c3RvbSBldmVudCA8a28+7Luk7Iqk7YWAIOydtOuypO2KuOqwgCDrsJzsg53tlaAg65WMIOyghOuLrO2VoCDrjbDsnbTthLA8L2tvPlxuICAgKiBAcmV0dXJuIEFuIGluc3RhbmNlIG9mIHRoZSBjb21wb25lbnQgaXRzZWxmPGtvPuy7tO2PrOuEjO2KuCDsnpDsi6DsnZgg7J247Iqk7YS07IqkPC9rbz5cbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHNcbiAgICogaW1wb3J0IENvbXBvbmVudCwgeyBDb21wb25lbnRFdmVudCB9IGZyb20gXCJAZWdqcy9jb21wb25lbnRcIjtcbiAgICpcbiAgICogY2xhc3MgU29tZSBleHRlbmRzIENvbXBvbmVudDx7XG4gICAqICAgYmVmb3JlSGk6IENvbXBvbmVudEV2ZW50PHsgZm9vOiBudW1iZXI7IGJhcjogc3RyaW5nIH0+O1xuICAgKiAgIGhpOiB7IGZvbzogeyBhOiBudW1iZXI7IGI6IGJvb2xlYW4gfSB9O1xuICAgKiAgIHNvbWVFdmVudDogKGZvbzogbnVtYmVyLCBiYXI6IHN0cmluZykgPT4gdm9pZDtcbiAgICogICBzb21lT3RoZXJFdmVudDogdm9pZDsgLy8gV2hlbiB0aGVyZSdzIG5vIGV2ZW50IGFyZ3VtZW50XG4gICAqIH0+IHtcbiAgICogICBzb21lKCl7XG4gICAqICAgICBpZih0aGlzLnRyaWdnZXIoXCJiZWZvcmVIaVwiKSl7IC8vIFdoZW4gZXZlbnQgY2FsbCB0byBzdG9wIHJldHVybiBmYWxzZS5cbiAgICogICAgICAgdGhpcy50cmlnZ2VyKFwiaGlcIik7Ly8gZmlyZSBoaSBldmVudC5cbiAgICogICAgIH1cbiAgICogICB9XG4gICAqIH1cbiAgICpcbiAgICogY29uc3Qgc29tZSA9IG5ldyBTb21lKCk7XG4gICAqIHNvbWUub24oXCJiZWZvcmVIaVwiLCBlID0+IHtcbiAgICogICBpZihjb25kaXRpb24pe1xuICAgKiAgICAgZS5zdG9wKCk7IC8vIFdoZW4gZXZlbnQgY2FsbCB0byBzdG9wLCBgaGlgIGV2ZW50IG5vdCBjYWxsLlxuICAgKiAgIH1cbiAgICogICAvLyBgY3VycmVudFRhcmdldGAgaXMgY29tcG9uZW50IGluc3RhbmNlLlxuICAgKiAgIGNvbnNvbGUubG9nKHNvbWUgPT09IGUuY3VycmVudFRhcmdldCk7IC8vIHRydWVcbiAgICpcbiAgICogICB0eXBlb2YgZS5mb287IC8vIG51bWJlclxuICAgKiAgIHR5cGVvZiBlLmJhcjsgLy8gc3RyaW5nXG4gICAqIH0pO1xuICAgKiBzb21lLm9uKFwiaGlcIiwgZSA9PiB7XG4gICAqICAgdHlwZW9mIGUuZm9vLmI7IC8vIGJvb2xlYW5cbiAgICogfSk7XG4gICAqIC8vIElmIHlvdSB3YW50IHRvIG1vcmUga25vdyBldmVudCBkZXNpZ24uIFlvdSBjYW4gc2VlIGFydGljbGUuXG4gICAqIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9uYXZlci9lZ2pzLWNvbXBvbmVudC93aWtpL0hvdy10by1tYWtlLUNvbXBvbmVudC1ldmVudC1kZXNpZ24lM0ZcbiAgICogYGBgXG4gICAqL1xuICB2YXIgX19wcm90byA9IENvbXBvbmVudC5wcm90b3R5cGU7XG4gIF9fcHJvdG8udHJpZ2dlciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciBwYXJhbXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgcGFyYW1zW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB2YXIgZXZlbnROYW1lID0gZXZlbnQgaW5zdGFuY2VvZiBDb21wb25lbnRFdmVudCA/IGV2ZW50LmV2ZW50VHlwZSA6IGV2ZW50O1xuICAgIHZhciBoYW5kbGVycyA9IF9fc3ByZWFkKHRoaXMuX2V2ZW50SGFuZGxlcltldmVudE5hbWVdIHx8IFtdKTtcbiAgICBpZiAoaGFuZGxlcnMubGVuZ3RoIDw9IDApIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZiAoZXZlbnQgaW5zdGFuY2VvZiBDb21wb25lbnRFdmVudCkge1xuICAgICAgZXZlbnQuY3VycmVudFRhcmdldCA9IHRoaXM7XG4gICAgICBoYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICAgIGhhbmRsZXIoZXZlbnQpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtY2FsbFxuICAgICAgICBoYW5kbGVyLmFwcGx5KHZvaWQgMCwgX19zcHJlYWQocGFyYW1zKSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxuICAgKiBFeGVjdXRlZCBldmVudCBqdXN0IG9uZSB0aW1lLlxuICAgKiBAa28g7J2067Kk7Yq46rCAIO2VnOuyiOunjCDsi6TtlonrkJzri6QuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIGJlIGF0dGFjaGVkIG9yIGFuIGV2ZW50IG5hbWUgLSBldmVudCBoYW5kbGVyIG1hcHBlZCBvYmplY3QuPGtvPuuTseuhne2VoCDsnbTrsqTtirjsnZgg7J2066aEIOuYkOuKlCDsnbTrsqTtirgg7J2066aELe2VuOuTpOufrCDsmKTruIzsoJ3tirg8L2tvPlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBoYW5kbGVyVG9BdHRhY2ggVGhlIGhhbmRsZXIgZnVuY3Rpb24gb2YgdGhlIGV2ZW50IHRvIGJlIGF0dGFjaGVkIDxrbz7rk7HroZ3tlaAg7J2067Kk7Yq47J2YIO2VuOuTpOufrCDtlajsiJg8L2tvPlxuICAgKiBAcmV0dXJuIEFuIGluc3RhbmNlIG9mIHRoZSBjb21wb25lbnQgaXRzZWxmPGtvPuy7tO2PrOuEjO2KuCDsnpDsi6DsnZgg7J247Iqk7YS07IqkPC9rbz5cbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHNcbiAgICogaW1wb3J0IENvbXBvbmVudCwgeyBDb21wb25lbnRFdmVudCB9IGZyb20gXCJAZWdqcy9jb21wb25lbnRcIjtcbiAgICpcbiAgICogY2xhc3MgU29tZSBleHRlbmRzIENvbXBvbmVudDx7XG4gICAqICAgaGk6IENvbXBvbmVudEV2ZW50O1xuICAgKiB9PiB7XG4gICAqICAgaGkoKSB7XG4gICAqICAgICBhbGVydChcImhpXCIpO1xuICAgKiAgIH1cbiAgICogICB0aGluZygpIHtcbiAgICogICAgIHRoaXMub25jZShcImhpXCIsIHRoaXMuaGkpO1xuICAgKiAgIH1cbiAgICogfVxuICAgKlxuICAgKiB2YXIgc29tZSA9IG5ldyBTb21lKCk7XG4gICAqIHNvbWUudGhpbmcoKTtcbiAgICogc29tZS50cmlnZ2VyKG5ldyBDb21wb25lbnRFdmVudChcImhpXCIpKTtcbiAgICogLy8gZmlyZSBhbGVydChcImhpXCIpO1xuICAgKiBzb21lLnRyaWdnZXIobmV3IENvbXBvbmVudEV2ZW50KFwiaGlcIikpO1xuICAgKiAvLyBOb3RoaW5nIGhhcHBlbnNcbiAgICogYGBgXG4gICAqL1xuICBfX3Byb3RvLm9uY2UgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBoYW5kbGVyVG9BdHRhY2gpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIGlmICh0eXBlb2YgZXZlbnROYW1lID09PSBcIm9iamVjdFwiICYmIGlzVW5kZWZpbmVkKGhhbmRsZXJUb0F0dGFjaCkpIHtcbiAgICAgIHZhciBldmVudEhhc2ggPSBldmVudE5hbWU7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gZXZlbnRIYXNoKSB7XG4gICAgICAgIHRoaXMub25jZShrZXksIGV2ZW50SGFzaFtrZXldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV2ZW50TmFtZSA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgaGFuZGxlclRvQXR0YWNoID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHZhciBsaXN0ZW5lcl8xID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1jYWxsXG4gICAgICAgIGhhbmRsZXJUb0F0dGFjaC5hcHBseSh2b2lkIDAsIF9fc3ByZWFkKGFyZ3MpKTtcbiAgICAgICAgX3RoaXMub2ZmKGV2ZW50TmFtZSwgbGlzdGVuZXJfMSk7XG4gICAgICB9O1xuICAgICAgdGhpcy5vbihldmVudE5hbWUsIGxpc3RlbmVyXzEpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIGFuIGV2ZW50IGhhcyBiZWVuIGF0dGFjaGVkIHRvIGEgY29tcG9uZW50LlxuICAgKiBAa28g7Lu07Y+s64SM7Yq47JeQIOydtOuypO2KuOqwgCDrk7HroZ3rkJDripTsp4Ag7ZmV7J247ZWc64ukLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBiZSBhdHRhY2hlZCA8a28+65Ox66GdIOyXrOu2gOulvCDtmZXsnbjtlaAg7J2067Kk7Yq47J2YIOydtOumhDwva28+XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IEluZGljYXRlcyB3aGV0aGVyIHRoZSBldmVudCBpcyBhdHRhY2hlZC4gPGtvPuydtOuypO2KuCDrk7HroZ0g7Jes67aAPC9rbz5cbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHNcbiAgICogaW1wb3J0IENvbXBvbmVudCBmcm9tIFwiQGVnanMvY29tcG9uZW50XCI7XG4gICAqXG4gICAqIGNsYXNzIFNvbWUgZXh0ZW5kcyBDb21wb25lbnQ8e1xuICAgKiAgIGhpOiB2b2lkO1xuICAgKiB9PiB7XG4gICAqICAgc29tZSgpIHtcbiAgICogICAgIHRoaXMuaGFzT24oXCJoaVwiKTsvLyBjaGVjayBoaSBldmVudC5cbiAgICogICB9XG4gICAqIH1cbiAgICogYGBgXG4gICAqL1xuICBfX3Byb3RvLmhhc09uID0gZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICAgIHJldHVybiAhIXRoaXMuX2V2ZW50SGFuZGxlcltldmVudE5hbWVdO1xuICB9O1xuICAvKipcbiAgICogQXR0YWNoZXMgYW4gZXZlbnQgdG8gYSBjb21wb25lbnQuXG4gICAqIEBrbyDsu7Ttj6zrhIztirjsl5Ag7J2067Kk7Yq466W8IOuTseuhne2VnOuLpC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gYmUgYXR0YWNoZWQgb3IgYW4gZXZlbnQgbmFtZSAtIGV2ZW50IGhhbmRsZXIgbWFwcGVkIG9iamVjdC48a28+65Ox66Gd7ZWgIOydtOuypO2KuOydmCDsnbTrpoQg65iQ64qUIOydtOuypO2KuCDsnbTrpoQt7ZW465Ok65+sIOyYpOu4jOygne2KuDwva28+XG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGhhbmRsZXJUb0F0dGFjaCBUaGUgaGFuZGxlciBmdW5jdGlvbiBvZiB0aGUgZXZlbnQgdG8gYmUgYXR0YWNoZWQgPGtvPuuTseuhne2VoCDsnbTrsqTtirjsnZgg7ZW465Ok65+sIO2VqOyImDwva28+XG4gICAqIEByZXR1cm4gQW4gaW5zdGFuY2Ugb2YgYSBjb21wb25lbnQgaXRzZWxmPGtvPuy7tO2PrOuEjO2KuCDsnpDsi6DsnZgg7J247Iqk7YS07IqkPC9rbz5cbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHNcbiAgICogaW1wb3J0IENvbXBvbmVudCwgeyBDb21wb25lbnRFdmVudCB9IGZyb20gXCJAZWdqcy9jb21wb25lbnRcIjtcbiAgICpcbiAgICogY2xhc3MgU29tZSBleHRlbmRzIENvbXBvbmVudDx7XG4gICAqICAgaGk6IHZvaWQ7XG4gICAqIH0+IHtcbiAgICogICBoaSgpIHtcbiAgICogICAgIGNvbnNvbGUubG9nKFwiaGlcIik7XG4gICAqICAgfVxuICAgKiAgIHNvbWUoKSB7XG4gICAqICAgICB0aGlzLm9uKFwiaGlcIix0aGlzLmhpKTsgLy9hdHRhY2ggZXZlbnRcbiAgICogICB9XG4gICAqIH1cbiAgICogYGBgXG4gICAqL1xuICBfX3Byb3RvLm9uID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgaGFuZGxlclRvQXR0YWNoKSB7XG4gICAgaWYgKHR5cGVvZiBldmVudE5hbWUgPT09IFwib2JqZWN0XCIgJiYgaXNVbmRlZmluZWQoaGFuZGxlclRvQXR0YWNoKSkge1xuICAgICAgdmFyIGV2ZW50SGFzaCA9IGV2ZW50TmFtZTtcbiAgICAgIGZvciAodmFyIG5hbWUgaW4gZXZlbnRIYXNoKSB7XG4gICAgICAgIHRoaXMub24obmFtZSwgZXZlbnRIYXNoW25hbWVdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV2ZW50TmFtZSA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgaGFuZGxlclRvQXR0YWNoID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHZhciBoYW5kbGVyTGlzdCA9IHRoaXMuX2V2ZW50SGFuZGxlcltldmVudE5hbWVdO1xuICAgICAgaWYgKGlzVW5kZWZpbmVkKGhhbmRsZXJMaXN0KSkge1xuICAgICAgICB0aGlzLl9ldmVudEhhbmRsZXJbZXZlbnROYW1lXSA9IFtdO1xuICAgICAgICBoYW5kbGVyTGlzdCA9IHRoaXMuX2V2ZW50SGFuZGxlcltldmVudE5hbWVdO1xuICAgICAgfVxuICAgICAgaGFuZGxlckxpc3QucHVzaChoYW5kbGVyVG9BdHRhY2gpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXG4gICAqIERldGFjaGVzIGFuIGV2ZW50IGZyb20gdGhlIGNvbXBvbmVudC48YnIvPklmIHRoZSBgZXZlbnROYW1lYCBpcyBub3QgZ2l2ZW4gdGhpcyB3aWxsIGRldGFjaCBhbGwgZXZlbnQgaGFuZGxlcnMgYXR0YWNoZWQuPGJyLz5JZiB0aGUgYGhhbmRsZXJUb0RldGFjaGAgaXMgbm90IGdpdmVuLCB0aGlzIHdpbGwgZGV0YWNoIGFsbCBldmVudCBoYW5kbGVycyBmb3IgYGV2ZW50TmFtZWAuXG4gICAqIEBrbyDsu7Ttj6zrhIztirjsl5Ag65Ox66Gd65CcIOydtOuypO2KuOulvCDtlbTsoJztlZzri6QuPGJyLz5gZXZlbnROYW1lYOydtCDso7zslrTsp4Dsp4Ag7JWK7JWY7J2EIOqyveyasCDrqqjrk6Ag7J2067Kk7Yq4IO2VuOuTpOufrOulvCDsoJzqsbDtlZzri6QuPGJyLz5gaGFuZGxlclRvQXR0YWNoYOqwgCDso7zslrTsp4Dsp4Ag7JWK7JWY7J2EIOqyveyasCBgZXZlbnROYW1lYOyXkCDtlbTri7ntlZjripQg66qo65OgIOydtOuypO2KuCDtlbjrk6Trn6zrpbwg7KCc6rGw7ZWc64ukLlxuICAgKiBAcGFyYW0ge3N0cmluZz99IGV2ZW50TmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gYmUgZGV0YWNoZWQgPGtvPu2VtOygnO2VoCDsnbTrsqTtirjsnZgg7J2066aEPC9rbz5cbiAgICogQHBhcmFtIHtmdW5jdGlvbj99IGhhbmRsZXJUb0RldGFjaCBUaGUgaGFuZGxlciBmdW5jdGlvbiBvZiB0aGUgZXZlbnQgdG8gYmUgZGV0YWNoZWQgPGtvPu2VtOygnO2VoCDsnbTrsqTtirjsnZgg7ZW465Ok65+sIO2VqOyImDwva28+XG4gICAqIEByZXR1cm4gQW4gaW5zdGFuY2Ugb2YgYSBjb21wb25lbnQgaXRzZWxmIDxrbz7su7Ttj6zrhIztirgg7J6Q7Iug7J2YIOyduOyKpO2EtOyKpDwva28+XG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzXG4gICAqIGltcG9ydCBDb21wb25lbnQsIHsgQ29tcG9uZW50RXZlbnQgfSBmcm9tIFwiQGVnanMvY29tcG9uZW50XCI7XG4gICAqXG4gICAqIGNsYXNzIFNvbWUgZXh0ZW5kcyBDb21wb25lbnQ8e1xuICAgKiAgIGhpOiB2b2lkO1xuICAgKiB9PiB7XG4gICAqICAgaGkoKSB7XG4gICAqICAgICBjb25zb2xlLmxvZyhcImhpXCIpO1xuICAgKiAgIH1cbiAgICogICBzb21lKCkge1xuICAgKiAgICAgdGhpcy5vZmYoXCJoaVwiLHRoaXMuaGkpOyAvL2RldGFjaCBldmVudFxuICAgKiAgIH1cbiAgICogfVxuICAgKiBgYGBcbiAgICovXG4gIF9fcHJvdG8ub2ZmID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgaGFuZGxlclRvRGV0YWNoKSB7XG4gICAgdmFyIGVfMSwgX2E7XG4gICAgLy8gRGV0YWNoIGFsbCBldmVudCBoYW5kbGVycy5cbiAgICBpZiAoaXNVbmRlZmluZWQoZXZlbnROYW1lKSkge1xuICAgICAgdGhpcy5fZXZlbnRIYW5kbGVyID0ge307XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gRGV0YWNoIGFsbCBoYW5kbGVycyBmb3IgZXZlbnRuYW1lIG9yIGRldGFjaCBldmVudCBoYW5kbGVycyBieSBvYmplY3QuXG4gICAgaWYgKGlzVW5kZWZpbmVkKGhhbmRsZXJUb0RldGFjaCkpIHtcbiAgICAgIGlmICh0eXBlb2YgZXZlbnROYW1lID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudEhhbmRsZXJbZXZlbnROYW1lXTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZXZlbnRIYXNoID0gZXZlbnROYW1lO1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIGV2ZW50SGFzaCkge1xuICAgICAgICAgIHRoaXMub2ZmKG5hbWUsIGV2ZW50SGFzaFtuYW1lXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIERldGFjaCBzaW5nbGUgZXZlbnQgaGFuZGxlclxuICAgIHZhciBoYW5kbGVyTGlzdCA9IHRoaXMuX2V2ZW50SGFuZGxlcltldmVudE5hbWVdO1xuICAgIGlmIChoYW5kbGVyTGlzdCkge1xuICAgICAgdmFyIGlkeCA9IDA7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBoYW5kbGVyTGlzdF8xID0gX192YWx1ZXMoaGFuZGxlckxpc3QpLCBoYW5kbGVyTGlzdF8xXzEgPSBoYW5kbGVyTGlzdF8xLm5leHQoKTsgIWhhbmRsZXJMaXN0XzFfMS5kb25lOyBoYW5kbGVyTGlzdF8xXzEgPSBoYW5kbGVyTGlzdF8xLm5leHQoKSkge1xuICAgICAgICAgIHZhciBoYW5kbGVyRnVuY3Rpb24gPSBoYW5kbGVyTGlzdF8xXzEudmFsdWU7XG4gICAgICAgICAgaWYgKGhhbmRsZXJGdW5jdGlvbiA9PT0gaGFuZGxlclRvRGV0YWNoKSB7XG4gICAgICAgICAgICBoYW5kbGVyTGlzdC5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICAgIGlmIChoYW5kbGVyTGlzdC5sZW5ndGggPD0gMCkge1xuICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fZXZlbnRIYW5kbGVyW2V2ZW50TmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWR4Kys7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVfMV8xKSB7XG4gICAgICAgIGVfMSA9IHtcbiAgICAgICAgICBlcnJvcjogZV8xXzFcbiAgICAgICAgfTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKGhhbmRsZXJMaXN0XzFfMSAmJiAhaGFuZGxlckxpc3RfMV8xLmRvbmUgJiYgKF9hID0gaGFuZGxlckxpc3RfMS5yZXR1cm4pKSBfYS5jYWxsKGhhbmRsZXJMaXN0XzEpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXG4gICAqIFZlcnNpb24gaW5mbyBzdHJpbmdcbiAgICogQGtvIOuyhOyghOygleuztCDrrLjsnpDsl7RcbiAgICogQG5hbWUgVkVSU0lPTlxuICAgKiBAc3RhdGljXG4gICAqIEBleGFtcGxlXG4gICAqIENvbXBvbmVudC5WRVJTSU9OOyAgLy8gZXgpIDMuMC4wXG4gICAqIEBtZW1iZXJvZiBDb21wb25lbnRcbiAgICovXG4gIENvbXBvbmVudC5WRVJTSU9OID0gXCIzLjAuNFwiO1xuICByZXR1cm4gQ29tcG9uZW50O1xufSgpO1xuXG4vKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IE5BVkVSIENvcnAuXG4gKiBlZ2pzIHByb2plY3RzIGFyZSBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvbiwgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50XG52YXIgQ29tcG9uZW50RXZlbnQkMSA9IENvbXBvbmVudEV2ZW50O1xuXG4vKlxuQ29weXJpZ2h0IChjKSAyMDE5LXByZXNlbnQgTkFWRVIgQ29ycC5cbm5hbWU6IEBlZ2pzL2xpc3QtZGlmZmVyXG5saWNlbnNlOiBNSVRcbmF1dGhvcjogTkFWRVIgQ29ycC5cbnJlcG9zaXRvcnk6IGh0dHBzOi8vZ2l0aHViLmNvbS9uYXZlci9lZ2pzLWxpc3QtZGlmZmVyXG52ZXJzaW9uOiAxLjAuMVxuKi9cbi8qXG5lZ2pzLWxpc3QtZGlmZmVyXG5Db3B5cmlnaHQgKGMpIDIwMTktcHJlc2VudCBOQVZFUiBDb3JwLlxuTUlUIGxpY2Vuc2VcbiovXG52YXIgUG9seU1hcCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFBvbHlNYXAoKSB7XG4gICAgdGhpcy5rZXlzID0gW107XG4gICAgdGhpcy52YWx1ZXMgPSBbXTtcbiAgfVxuXG4gIHZhciBfX3Byb3RvID0gUG9seU1hcC5wcm90b3R5cGU7XG5cbiAgX19wcm90by5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVzW3RoaXMua2V5cy5pbmRleE9mKGtleSldO1xuICB9O1xuXG4gIF9fcHJvdG8uc2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICB2YXIga2V5cyA9IHRoaXMua2V5cztcbiAgICB2YXIgdmFsdWVzID0gdGhpcy52YWx1ZXM7XG4gICAgdmFyIHByZXZJbmRleCA9IGtleXMuaW5kZXhPZihrZXkpO1xuICAgIHZhciBpbmRleCA9IHByZXZJbmRleCA9PT0gLTEgPyBrZXlzLmxlbmd0aCA6IHByZXZJbmRleDtcbiAgICBrZXlzW2luZGV4XSA9IGtleTtcbiAgICB2YWx1ZXNbaW5kZXhdID0gdmFsdWU7XG4gIH07XG5cbiAgcmV0dXJuIFBvbHlNYXA7XG59KCk7XG5cbi8qXG5lZ2pzLWxpc3QtZGlmZmVyXG5Db3B5cmlnaHQgKGMpIDIwMTktcHJlc2VudCBOQVZFUiBDb3JwLlxuTUlUIGxpY2Vuc2VcbiovXG52YXIgSGFzaE1hcCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEhhc2hNYXAoKSB7XG4gICAgdGhpcy5vYmplY3QgPSB7fTtcbiAgfVxuXG4gIHZhciBfX3Byb3RvID0gSGFzaE1hcC5wcm90b3R5cGU7XG5cbiAgX19wcm90by5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMub2JqZWN0W2tleV07XG4gIH07XG5cbiAgX19wcm90by5zZXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIHRoaXMub2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgfTtcblxuICByZXR1cm4gSGFzaE1hcDtcbn0oKTtcblxuLypcbmVnanMtbGlzdC1kaWZmZXJcbkNvcHlyaWdodCAoYykgMjAxOS1wcmVzZW50IE5BVkVSIENvcnAuXG5NSVQgbGljZW5zZVxuKi9cbnZhciBTVVBQT1JUX01BUCA9IHR5cGVvZiBNYXAgPT09IFwiZnVuY3Rpb25cIjtcblxuLypcbmVnanMtbGlzdC1kaWZmZXJcbkNvcHlyaWdodCAoYykgMjAxOS1wcmVzZW50IE5BVkVSIENvcnAuXG5NSVQgbGljZW5zZVxuKi9cbnZhciBMaW5rID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTGluaygpIHt9XG5cbiAgdmFyIF9fcHJvdG8gPSBMaW5rLnByb3RvdHlwZTtcblxuICBfX3Byb3RvLmNvbm5lY3QgPSBmdW5jdGlvbiAocHJldkxpbmssIG5leHRMaW5rKSB7XG4gICAgdGhpcy5wcmV2ID0gcHJldkxpbms7XG4gICAgdGhpcy5uZXh0ID0gbmV4dExpbms7XG4gICAgcHJldkxpbmsgJiYgKHByZXZMaW5rLm5leHQgPSB0aGlzKTtcbiAgICBuZXh0TGluayAmJiAobmV4dExpbmsucHJldiA9IHRoaXMpO1xuICB9O1xuXG4gIF9fcHJvdG8uZGlzY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBJbiBkb3VibGUgbGlua2VkIGxpc3QsIGRpY29ubmVjdCB0aGUgaW50ZXJjb25uZWN0ZWQgcmVsYXRpb25zaGlwLlxuICAgIHZhciBwcmV2TGluayA9IHRoaXMucHJldjtcbiAgICB2YXIgbmV4dExpbmsgPSB0aGlzLm5leHQ7XG4gICAgcHJldkxpbmsgJiYgKHByZXZMaW5rLm5leHQgPSBuZXh0TGluayk7XG4gICAgbmV4dExpbmsgJiYgKG5leHRMaW5rLnByZXYgPSBwcmV2TGluayk7XG4gIH07XG5cbiAgX19wcm90by5nZXRJbmRleCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbGluayA9IHRoaXM7XG4gICAgdmFyIGluZGV4ID0gLTE7XG5cbiAgICB3aGlsZSAobGluaykge1xuICAgICAgbGluayA9IGxpbmsucHJldjtcbiAgICAgICsraW5kZXg7XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZGV4O1xuICB9O1xuXG4gIHJldHVybiBMaW5rO1xufSgpO1xuXG4vKlxuZWdqcy1saXN0LWRpZmZlclxuQ29weXJpZ2h0IChjKSAyMDE5LXByZXNlbnQgTkFWRVIgQ29ycC5cbk1JVCBsaWNlbnNlXG4qL1xuXG5mdW5jdGlvbiBvcmRlckNoYW5nZWQoY2hhbmdlZCwgZml4ZWQpIHtcbiAgLy8gSXQgaXMgcm91Z2hseSBpbiB0aGUgb3JkZXIgb2YgdGhlc2UgZXhhbXBsZXMuXG4gIC8vIDQsIDYsIDAsIDIsIDEsIDMsIDUsIDdcbiAgdmFyIGZyb21MaW5rcyA9IFtdOyAvLyAwLCAxLCAyLCAzLCA0LCA1LCA2LCA3XG5cbiAgdmFyIHRvTGlua3MgPSBbXTtcbiAgY2hhbmdlZC5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBmcm9tID0gX2FbMF0sXG4gICAgICAgIHRvID0gX2FbMV07XG4gICAgdmFyIGxpbmsgPSBuZXcgTGluaygpO1xuICAgIGZyb21MaW5rc1tmcm9tXSA9IGxpbms7XG4gICAgdG9MaW5rc1t0b10gPSBsaW5rO1xuICB9KTsgLy8gYGZyb21MaW5rc2AgYXJlIGNvbm5lY3RlZCB0byBlYWNoIG90aGVyIGJ5IGRvdWJsZSBsaW5rZWQgbGlzdC5cblxuICBmcm9tTGlua3MuZm9yRWFjaChmdW5jdGlvbiAobGluaywgaSkge1xuICAgIGxpbmsuY29ubmVjdChmcm9tTGlua3NbaSAtIDFdKTtcbiAgfSk7XG4gIHJldHVybiBjaGFuZ2VkLmZpbHRlcihmdW5jdGlvbiAoXywgaSkge1xuICAgIHJldHVybiAhZml4ZWRbaV07XG4gIH0pLm1hcChmdW5jdGlvbiAoX2EsIGkpIHtcbiAgICB2YXIgZnJvbSA9IF9hWzBdLFxuICAgICAgICB0byA9IF9hWzFdO1xuXG4gICAgaWYgKGZyb20gPT09IHRvKSB7XG4gICAgICByZXR1cm4gWzAsIDBdO1xuICAgIH1cblxuICAgIHZhciBmcm9tTGluayA9IGZyb21MaW5rc1tmcm9tXTtcbiAgICB2YXIgdG9MaW5rID0gdG9MaW5rc1t0byAtIDFdO1xuICAgIHZhciBmcm9tSW5kZXggPSBmcm9tTGluay5nZXRJbmRleCgpOyAvLyBEaXNjb25uZWN0IHRoZSBsaW5rIGNvbm5lY3RlZCB0byBgZnJvbUxpbmtgLlxuXG4gICAgZnJvbUxpbmsuZGlzY29ubmVjdCgpOyAvLyBDb25uZWN0IGBmcm9tTGlua2AgdG8gdGhlIHJpZ2h0IG9mIGB0b0xpbmtgLlxuXG4gICAgaWYgKCF0b0xpbmspIHtcbiAgICAgIGZyb21MaW5rLmNvbm5lY3QodW5kZWZpbmVkLCBmcm9tTGlua3NbMF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBmcm9tTGluay5jb25uZWN0KHRvTGluaywgdG9MaW5rLm5leHQpO1xuICAgIH1cblxuICAgIHZhciB0b0luZGV4ID0gZnJvbUxpbmsuZ2V0SW5kZXgoKTtcbiAgICByZXR1cm4gW2Zyb21JbmRleCwgdG9JbmRleF07XG4gIH0pO1xufVxuXG52YXIgUmVzdWx0ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUmVzdWx0KHByZXZMaXN0LCBsaXN0LCBhZGRlZCwgcmVtb3ZlZCwgY2hhbmdlZCwgbWFpbnRhaW5lZCwgY2hhbmdlZEJlZm9yZUFkZGVkLCBmaXhlZCkge1xuICAgIHRoaXMucHJldkxpc3QgPSBwcmV2TGlzdDtcbiAgICB0aGlzLmxpc3QgPSBsaXN0O1xuICAgIHRoaXMuYWRkZWQgPSBhZGRlZDtcbiAgICB0aGlzLnJlbW92ZWQgPSByZW1vdmVkO1xuICAgIHRoaXMuY2hhbmdlZCA9IGNoYW5nZWQ7XG4gICAgdGhpcy5tYWludGFpbmVkID0gbWFpbnRhaW5lZDtcbiAgICB0aGlzLmNoYW5nZWRCZWZvcmVBZGRlZCA9IGNoYW5nZWRCZWZvcmVBZGRlZDtcbiAgICB0aGlzLmZpeGVkID0gZml4ZWQ7XG4gIH1cblxuICB2YXIgX19wcm90byA9IFJlc3VsdC5wcm90b3R5cGU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcIm9yZGVyZWRcIiwge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCF0aGlzLmNhY2hlT3JkZXJlZCkge1xuICAgICAgICB0aGlzLmNhY3VsYXRlT3JkZXJlZCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jYWNoZU9yZGVyZWQ7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwicHVyZUNoYW5nZWRcIiwge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCF0aGlzLmNhY2hlUHVyZUNoYW5nZWQpIHtcbiAgICAgICAgdGhpcy5jYWN1bGF0ZU9yZGVyZWQoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuY2FjaGVQdXJlQ2hhbmdlZDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuXG4gIF9fcHJvdG8uY2FjdWxhdGVPcmRlcmVkID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvcmRlcmVkID0gb3JkZXJDaGFuZ2VkKHRoaXMuY2hhbmdlZEJlZm9yZUFkZGVkLCB0aGlzLmZpeGVkKTtcbiAgICB2YXIgY2hhbmdlZCA9IHRoaXMuY2hhbmdlZDtcbiAgICB2YXIgcHVyZUNoYW5nZWQgPSBbXTtcbiAgICB0aGlzLmNhY2hlT3JkZXJlZCA9IG9yZGVyZWQuZmlsdGVyKGZ1bmN0aW9uIChfYSwgaSkge1xuICAgICAgdmFyIGZyb20gPSBfYVswXSxcbiAgICAgICAgICB0byA9IF9hWzFdO1xuICAgICAgdmFyIF9iID0gY2hhbmdlZFtpXSxcbiAgICAgICAgICBmcm9tQmVmb3JlID0gX2JbMF0sXG4gICAgICAgICAgdG9CZWZvcmUgPSBfYlsxXTtcblxuICAgICAgaWYgKGZyb20gIT09IHRvKSB7XG4gICAgICAgIHB1cmVDaGFuZ2VkLnB1c2goW2Zyb21CZWZvcmUsIHRvQmVmb3JlXSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuY2FjaGVQdXJlQ2hhbmdlZCA9IHB1cmVDaGFuZ2VkO1xuICB9O1xuXG4gIHJldHVybiBSZXN1bHQ7XG59KCk7XG5cbi8qKlxuICpcbiAqIEBtZW1iZXJvZiBlZy5MaXN0RGlmZmVyXG4gKiBAc3RhdGljXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSAtIFByZXZpb3VzIExpc3QgPGtvPiDsnbTsoIQg66qp66GdIDwva28+XG4gKiBAcGFyYW0gLSBMaXN0IHRvIFVwZGF0ZSA8a28+IOyXheuNsOydtO2KuCDtlaAg66qp66GdIDwva28+XG4gKiBAcGFyYW0gLSBUaGlzIGNhbGxiYWNrIGZ1bmN0aW9uIHJldHVybnMgdGhlIGtleSBvZiB0aGUgaXRlbS4gPGtvPiDslYTsnbTthZzsnZgg7YKk66W8IOuwmO2ZmO2VmOuKlCDsvZzrsLEg7ZWo7IiY7J6F64uI64ukLjwva28+XG4gKiBAcmV0dXJuIC0gUmV0dXJucyB0aGUgZGlmZiBiZXR3ZWVuIGBwcmV2TGlzdGAgYW5kIGBsaXN0YCA8a28+IGBwcmV2TGlzdGDsmYAgYGxpc3Rg7J2YIOuLpOuluCDsoJDsnYQg67CY7ZmY7ZWc64ukLjwva28+XG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgZGlmZiB9IGZyb20gXCJAZWdqcy9saXN0LWRpZmZlclwiO1xuICogLy8gc2NyaXB0ID0+IGVnLkxpc3REaWZmZXIuZGlmZlxuICogY29uc3QgcmVzdWx0ID0gZGlmZihbMCwgMSwgMiwgMywgNCwgNV0sIFs3LCA4LCAwLCA0LCAzLCA2LCAyLCAxXSwgZSA9PiBlKTtcbiAqIC8vIExpc3QgYmVmb3JlIHVwZGF0ZVxuICogLy8gWzEsIDIsIDMsIDQsIDVdXG4gKiBjb25zb2xlLmxvZyhyZXN1bHQucHJldkxpc3QpO1xuICogLy8gVXBkYXRlZCBsaXN0XG4gKiAvLyBbNCwgMywgNiwgMiwgMV1cbiAqIGNvbnNvbGUubG9nKHJlc3VsdC5saXN0KTtcbiAqIC8vIEluZGV4IGFycmF5IG9mIHZhbHVlcyBhZGRlZCB0byBgbGlzdGBcbiAqIC8vIFswLCAxLCA1XVxuICogY29uc29sZS5sb2cocmVzdWx0LmFkZGVkKTtcbiAqIC8vIEluZGV4IGFycmF5IG9mIHZhbHVlcyByZW1vdmVkIGluIGBwcmV2TGlzdGBcbiAqIC8vIFs1XVxuICogY29uc29sZS5sb2cocmVzdWx0LnJlbW92ZWQpO1xuICogLy8gQW4gYXJyYXkgb2YgaW5kZXggcGFpcnMgb2YgYHByZXZMaXN0YCBhbmQgYGxpc3RgIHdpdGggZGlmZmVyZW50IGluZGV4ZXMgZnJvbSBgcHJldkxpc3RgIGFuZCBgbGlzdGBcbiAqIC8vIFtbMCwgMl0sIFs0LCAzXSwgWzMsIDRdLCBbMiwgNl0sIFsxLCA3XV1cbiAqIGNvbnNvbGUubG9nKHJlc3VsdC5jaGFuZ2VkKTtcbiAqIC8vIFRoZSBzdWJzZXQgb2YgYGNoYW5nZWRgIGFuZCBhbiBhcnJheSBvZiBpbmRleCBwYWlycyB0aGF0IG1vdmVkIGRhdGEgZGlyZWN0bHkuIEluZGljYXRlIGFuIGFycmF5IG9mIGFic29sdXRlIGluZGV4IHBhaXJzIG9mIGBvcmRlcmVkYC4oRm9ybWF0dGVkIGJ5OiBBcnJheTxbaW5kZXggb2YgcHJldkxpc3QsIGluZGV4IG9mIGxpc3RdPilcbiAqIC8vIFtbNCwgM10sIFszLCA0XSwgWzIsIDZdXVxuICogY29uc29sZS5sb2cocmVzdWx0LnB1cmVDaGFuZ2VkKTtcbiAqIC8vIEFuIGFycmF5IG9mIGluZGV4IHBhaXJzIHRvIGJlIGBvcmRlcmVkYCB0aGF0IGNhbiBzeW5jaHJvbml6ZSBgbGlzdGAgYmVmb3JlIGFkZGluZyBkYXRhLiAoRm9ybWF0dGVkIGJ5OiBBcnJheTxbcHJldkluZGV4LCBuZXh0SW5kZXhdPilcbiAqIC8vIFtbNCwgMV0sIFs0LCAyXSwgWzQsIDNdXVxuICogY29uc29sZS5sb2cocmVzdWx0Lm9yZGVyZWQpO1xuICogLy8gQW4gYXJyYXkgb2YgaW5kZXggcGFpcnMgb2YgYHByZXZMaXN0YCBhbmQgYGxpc3RgIHRoYXQgaGF2ZSBub3QgYmVlbiBhZGRlZC9yZW1vdmVkIHNvIGRhdGEgaXMgcHJlc2VydmVkXG4gKiAvLyBbWzAsIDJdLCBbNCwgM10sIFszLCA0XSwgWzIsIDZdLCBbMSwgN11dXG4gKiBjb25zb2xlLmxvZyhyZXN1bHQubWFpbnRhaW5lZCk7XG4gKi9cblxuZnVuY3Rpb24gZGlmZihwcmV2TGlzdCwgbGlzdCwgZmluZEtleUNhbGxiYWNrKSB7XG4gIHZhciBtYXBDbGFzcyA9IFNVUFBPUlRfTUFQID8gTWFwIDogZmluZEtleUNhbGxiYWNrID8gSGFzaE1hcCA6IFBvbHlNYXA7XG5cbiAgdmFyIGNhbGxiYWNrID0gZmluZEtleUNhbGxiYWNrIHx8IGZ1bmN0aW9uIChlKSB7XG4gICAgcmV0dXJuIGU7XG4gIH07XG5cbiAgdmFyIGFkZGVkID0gW107XG4gIHZhciByZW1vdmVkID0gW107XG4gIHZhciBtYWludGFpbmVkID0gW107XG4gIHZhciBwcmV2S2V5cyA9IHByZXZMaXN0Lm1hcChjYWxsYmFjayk7XG4gIHZhciBrZXlzID0gbGlzdC5tYXAoY2FsbGJhY2spO1xuICB2YXIgcHJldktleU1hcCA9IG5ldyBtYXBDbGFzcygpO1xuICB2YXIga2V5TWFwID0gbmV3IG1hcENsYXNzKCk7XG4gIHZhciBjaGFuZ2VkQmVmb3JlQWRkZWQgPSBbXTtcbiAgdmFyIGZpeGVkID0gW107XG4gIHZhciByZW1vdmVkTWFwID0ge307XG4gIHZhciBjaGFuZ2VkID0gW107XG4gIHZhciBhZGRlZENvdW50ID0gMDtcbiAgdmFyIHJlbW92ZWRDb3VudCA9IDA7IC8vIEFkZCBwcmV2S2V5cyBhbmQga2V5cyB0byB0aGUgaGFzaG1hcC5cblxuICBwcmV2S2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXksIHByZXZMaXN0SW5kZXgpIHtcbiAgICBwcmV2S2V5TWFwLnNldChrZXksIHByZXZMaXN0SW5kZXgpO1xuICB9KTtcbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXksIGxpc3RJbmRleCkge1xuICAgIGtleU1hcC5zZXQoa2V5LCBsaXN0SW5kZXgpO1xuICB9KTsgLy8gQ29tcGFyZSBgcHJldktleXNgIGFuZCBga2V5c2AgYW5kIGFkZCB0aGVtIHRvIGByZW1vdmVkYCBpZiB0aGV5IGFyZSBub3QgaW4gYGtleXNgLlxuXG4gIHByZXZLZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSwgcHJldkxpc3RJbmRleCkge1xuICAgIHZhciBsaXN0SW5kZXggPSBrZXlNYXAuZ2V0KGtleSk7IC8vIEluIHByZXZMaXN0LCBidXQgbm90IGluIGxpc3QsIGl0IGlzIHJlbW92ZWQuXG5cbiAgICBpZiAodHlwZW9mIGxpc3RJbmRleCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgKytyZW1vdmVkQ291bnQ7XG4gICAgICByZW1vdmVkLnB1c2gocHJldkxpc3RJbmRleCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZWRNYXBbbGlzdEluZGV4XSA9IHJlbW92ZWRDb3VudDtcbiAgICB9XG4gIH0pOyAvLyBDb21wYXJlIGBwcmV2S2V5c2AgYW5kIGBrZXlzYCBhbmQgYWRkIHRoZW0gdG8gYGFkZGVkYCBpZiB0aGV5IGFyZSBub3QgaW4gYHByZXZLZXlzYC5cblxuICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSwgbGlzdEluZGV4KSB7XG4gICAgdmFyIHByZXZMaXN0SW5kZXggPSBwcmV2S2V5TWFwLmdldChrZXkpOyAvLyBJbiBsaXN0LCBidXQgbm90IGluIHByZXZMaXN0LCBpdCBpcyBhZGRlZC5cblxuICAgIGlmICh0eXBlb2YgcHJldkxpc3RJbmRleCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgYWRkZWQucHVzaChsaXN0SW5kZXgpO1xuICAgICAgKythZGRlZENvdW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBtYWludGFpbmVkLnB1c2goW3ByZXZMaXN0SW5kZXgsIGxpc3RJbmRleF0pO1xuICAgICAgcmVtb3ZlZENvdW50ID0gcmVtb3ZlZE1hcFtsaXN0SW5kZXhdIHx8IDA7XG4gICAgICBjaGFuZ2VkQmVmb3JlQWRkZWQucHVzaChbcHJldkxpc3RJbmRleCAtIHJlbW92ZWRDb3VudCwgbGlzdEluZGV4IC0gYWRkZWRDb3VudF0pO1xuICAgICAgZml4ZWQucHVzaChsaXN0SW5kZXggPT09IHByZXZMaXN0SW5kZXgpO1xuXG4gICAgICBpZiAocHJldkxpc3RJbmRleCAhPT0gbGlzdEluZGV4KSB7XG4gICAgICAgIGNoYW5nZWQucHVzaChbcHJldkxpc3RJbmRleCwgbGlzdEluZGV4XSk7XG4gICAgICB9XG4gICAgfVxuICB9KTsgLy8gU29ydCBieSBhc2NlbmRpbmcgb3JkZXIgb2YgJ3RvKGxpc3QncyBpbmRleCkuXG5cbiAgcmVtb3ZlZC5yZXZlcnNlKCk7XG4gIHJldHVybiBuZXcgUmVzdWx0KHByZXZMaXN0LCBsaXN0LCBhZGRlZCwgcmVtb3ZlZCwgY2hhbmdlZCwgbWFpbnRhaW5lZCwgY2hhbmdlZEJlZm9yZUFkZGVkLCBmaXhlZCk7XG59XG5cbi8qKlxuICogQSBtb2R1bGUgdGhhdCBjaGVja3MgZGlmZiB3aGVuIHZhbHVlcyBhcmUgYWRkZWQsIHJlbW92ZWQsIG9yIGNoYW5nZWQgaW4gYW4gYXJyYXkuXG4gKiBAa28g67Cw7Je0IOuYkOuKlCDsmKTruIzsoJ3tirjsl5DshJwg6rCS7J20IOy2lOqwgOuQmOqxsOuCmCDsgq3soJzrkJjqsbDrgpgg7Iic7ISc6rCAIOuzgOqyveyCrO2VreydhCDssrTtgaztlZjripQg66qo65OI7J6F64uI64ukLlxuICogQG1lbWJlcm9mIGVnXG4gKi9cblxudmFyIExpc3REaWZmZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIC0gSW5pdGlhbGl6aW5nIERhdGEgQXJyYXkuIDxrbz4g7LSI6riwIOyEpOygle2VoCDrjbDsnbTthLAg67Cw7Je0Ljwva28+XG4gICAqIEBwYXJhbSAtIFRoaXMgY2FsbGJhY2sgZnVuY3Rpb24gcmV0dXJucyB0aGUga2V5IG9mIHRoZSBpdGVtLiA8a28+IOyVhOydtO2FnOydmCDtgqTrpbwg67CY7ZmY7ZWY64qUIOy9nOuwsSDtlajsiJjsnoXri4jri6QuPC9rbz5cbiAgICogQGV4YW1wbGVcbiAgICogaW1wb3J0IExpc3REaWZmZXIgZnJvbSBcIkBlZ2pzL2xpc3QtZGlmZmVyXCI7XG4gICAqIC8vIHNjcmlwdCA9PiBlZy5MaXN0RGlmZmVyXG4gICAqIGNvbnN0IGRpZmZlciA9IG5ldyBMaXN0RGlmZmVyKFswLCAxLCAyLCAzLCA0LCA1XSwgZSA9PiBlKTtcbiAgICogY29uc3QgcmVzdWx0ID0gZGlmZmVyLnVwZGF0ZShbNywgOCwgMCwgNCwgMywgNiwgMiwgMV0pO1xuICAgKiAvLyBMaXN0IGJlZm9yZSB1cGRhdGVcbiAgICogLy8gWzEsIDIsIDMsIDQsIDVdXG4gICAqIGNvbnNvbGUubG9nKHJlc3VsdC5wcmV2TGlzdCk7XG4gICAqIC8vIFVwZGF0ZWQgbGlzdFxuICAgKiAvLyBbNCwgMywgNiwgMiwgMV1cbiAgICogY29uc29sZS5sb2cocmVzdWx0Lmxpc3QpO1xuICAgKiAvLyBJbmRleCBhcnJheSBvZiB2YWx1ZXMgYWRkZWQgdG8gYGxpc3RgLlxuICAgKiAvLyBbMCwgMSwgNV1cbiAgICogY29uc29sZS5sb2cocmVzdWx0LmFkZGVkKTtcbiAgICogLy8gSW5kZXggYXJyYXkgb2YgdmFsdWVzIHJlbW92ZWQgaW4gYHByZXZMaXN0YC5cbiAgICogLy8gWzVdXG4gICAqIGNvbnNvbGUubG9nKHJlc3VsdC5yZW1vdmVkKTtcbiAgICogLy8gQW4gYXJyYXkgb2YgaW5kZXggcGFpcnMgb2YgYHByZXZMaXN0YCBhbmQgYGxpc3RgIHdpdGggZGlmZmVyZW50IGluZGV4ZXMgZnJvbSBgcHJldkxpc3RgIGFuZCBgbGlzdGAuXG4gICAqIC8vIFtbMCwgMl0sIFs0LCAzXSwgWzMsIDRdLCBbMiwgNl0sIFsxLCA3XV1cbiAgICogY29uc29sZS5sb2cocmVzdWx0LmNoYW5nZWQpO1xuICAgKiAvLyBUaGUgc3Vic2V0IG9mIGBjaGFuZ2VkYCBhbmQgYW4gYXJyYXkgb2YgaW5kZXggcGFpcnMgdGhhdCBtb3ZlZCBkYXRhIGRpcmVjdGx5LiBJbmRpY2F0ZSBhbiBhcnJheSBvZiBhYnNvbHV0ZSBpbmRleCBwYWlycyBvZiBgb3JkZXJlZGAuKEZvcm1hdHRlZCBieTogQXJyYXk8W2luZGV4IG9mIHByZXZMaXN0LCBpbmRleCBvZiBsaXN0XT4pXG4gICAqIC8vIFtbNCwgM10sIFszLCA0XSwgWzIsIDZdXVxuICAgKiBjb25zb2xlLmxvZyhyZXN1bHQucHVyZUNoYW5nZWQpO1xuICAgKiAvLyBBbiBhcnJheSBvZiBpbmRleCBwYWlycyB0byBiZSBgb3JkZXJlZGAgdGhhdCBjYW4gc3luY2hyb25pemUgYGxpc3RgIGJlZm9yZSBhZGRpbmcgZGF0YS4gKEZvcm1hdHRlZCBieTogQXJyYXk8W3ByZXZJbmRleCwgbmV4dEluZGV4XT4pXG4gICAqIC8vIFtbNCwgMV0sIFs0LCAyXSwgWzQsIDNdXVxuICAgKiBjb25zb2xlLmxvZyhyZXN1bHQub3JkZXJlZCk7XG4gICAqIC8vIEFuIGFycmF5IG9mIGluZGV4IHBhaXJzIG9mIGBwcmV2TGlzdGAgYW5kIGBsaXN0YCB0aGF0IGhhdmUgbm90IGJlZW4gYWRkZWQvcmVtb3ZlZCBzbyBkYXRhIGlzIHByZXNlcnZlZC5cbiAgICogLy8gW1swLCAyXSwgWzQsIDNdLCBbMywgNF0sIFsyLCA2XSwgWzEsIDddXVxuICAgKiBjb25zb2xlLmxvZyhyZXN1bHQubWFpbnRhaW5lZCk7XG4gICAqL1xuICBmdW5jdGlvbiBMaXN0RGlmZmVyKGxpc3QsIGZpbmRLZXlDYWxsYmFjaykge1xuICAgIGlmIChsaXN0ID09PSB2b2lkIDApIHtcbiAgICAgIGxpc3QgPSBbXTtcbiAgICB9XG5cbiAgICB0aGlzLmZpbmRLZXlDYWxsYmFjayA9IGZpbmRLZXlDYWxsYmFjaztcbiAgICB0aGlzLmxpc3QgPSBbXS5zbGljZS5jYWxsKGxpc3QpO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGUgbGlzdC5cbiAgICogQGtvIOumrOyKpO2KuOulvCDsl4XrjbDsnbTtirjrpbwg7ZWp64uI64ukLlxuICAgKiBAcGFyYW0gLSBMaXN0IHRvIHVwZGF0ZSA8a28+IOyXheuNsOydtO2KuO2VoCDrpqzsiqTtirggPC9rbz5cbiAgICogQHJldHVybiAtIFJldHVybnMgdGhlIHJlc3VsdHMgb2YgYW4gdXBkYXRlIGZyb20gYHByZXZMaXN0YCB0byBgbGlzdGAuPGtvPiBgcHJldkxpc3Rg7JeQ7IScIGBsaXN0YOuhnCDsl4XrjbDsnbTtirjtlZwg6rKw6rO866W8IOuwmO2ZmO2VnOuLpC4gPC9rbz5cbiAgICovXG5cblxuICB2YXIgX19wcm90byA9IExpc3REaWZmZXIucHJvdG90eXBlO1xuXG4gIF9fcHJvdG8udXBkYXRlID0gZnVuY3Rpb24gKGxpc3QpIHtcbiAgICB2YXIgbmV3RGF0YSA9IFtdLnNsaWNlLmNhbGwobGlzdCk7XG4gICAgdmFyIHJlc3VsdCA9IGRpZmYodGhpcy5saXN0LCBuZXdEYXRhLCB0aGlzLmZpbmRLZXlDYWxsYmFjayk7XG4gICAgdGhpcy5saXN0ID0gbmV3RGF0YTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIHJldHVybiBMaXN0RGlmZmVyO1xufSgpO1xuXG4vKlxuQ29weXJpZ2h0IChjKSAyMDE1IE5BVkVSIENvcnAuXG5uYW1lOiBAZWdqcy9hZ2VudFxubGljZW5zZTogTUlUXG5hdXRob3I6IE5BVkVSIENvcnAuXG5yZXBvc2l0b3J5OiBnaXQraHR0cHM6Ly9naXRodWIuY29tL25hdmVyL2FnZW50LmdpdFxudmVyc2lvbjogMi40LjNcbiovXG5mdW5jdGlvbiBzb21lKGFyciwgY2FsbGJhY2spIHtcbiAgdmFyIGxlbmd0aCA9IGFyci5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmIChjYWxsYmFjayhhcnJbaV0sIGkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBmaW5kKGFyciwgY2FsbGJhY2spIHtcbiAgdmFyIGxlbmd0aCA9IGFyci5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmIChjYWxsYmFjayhhcnJbaV0sIGkpKSB7XG4gICAgICByZXR1cm4gYXJyW2ldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0VXNlckFnZW50U3RyaW5nKGFnZW50KSB7XG4gIHZhciB1c2VyQWdlbnQgPSBhZ2VudDtcblxuICBpZiAodHlwZW9mIHVzZXJBZ2VudCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yID09PSBcInVuZGVmaW5lZFwiIHx8ICFuYXZpZ2F0b3IpIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cblxuICAgIHVzZXJBZ2VudCA9IG5hdmlnYXRvci51c2VyQWdlbnQgfHwgXCJcIjtcbiAgfVxuXG4gIHJldHVybiB1c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcbn1cbmZ1bmN0aW9uIGV4ZWNSZWdFeHAocGF0dGVybiwgdGV4dCkge1xuICB0cnkge1xuICAgIHJldHVybiBuZXcgUmVnRXhwKHBhdHRlcm4sIFwiZ1wiKS5leGVjKHRleHQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIGhhc1VzZXJBZ2VudERhdGEoKSB7XG4gIGlmICh0eXBlb2YgbmF2aWdhdG9yID09PSBcInVuZGVmaW5lZFwiIHx8ICFuYXZpZ2F0b3IgfHwgIW5hdmlnYXRvci51c2VyQWdlbnREYXRhKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHVzZXJBZ2VudERhdGEgPSBuYXZpZ2F0b3IudXNlckFnZW50RGF0YTtcbiAgdmFyIGJyYW5kcyA9IHVzZXJBZ2VudERhdGEuYnJhbmRzIHx8IHVzZXJBZ2VudERhdGEudWFMaXN0O1xuICByZXR1cm4gISEoYnJhbmRzICYmIGJyYW5kcy5sZW5ndGgpO1xufVxuZnVuY3Rpb24gZmluZFZlcnNpb24odmVyc2lvblRlc3QsIHVzZXJBZ2VudCkge1xuICB2YXIgcmVzdWx0ID0gZXhlY1JlZ0V4cChcIihcIiArIHZlcnNpb25UZXN0ICsgXCIpKCg/OlxcXFwvfFxcXFxzfDopKFswLTl8XFxcXC58X10rKSlcIiwgdXNlckFnZW50KTtcbiAgcmV0dXJuIHJlc3VsdCA/IHJlc3VsdFszXSA6IFwiXCI7XG59XG5mdW5jdGlvbiBjb252ZXJ0VmVyc2lvbih0ZXh0KSB7XG4gIHJldHVybiB0ZXh0LnJlcGxhY2UoL18vZywgXCIuXCIpO1xufVxuZnVuY3Rpb24gZmluZFByZXNldChwcmVzZXRzLCB1c2VyQWdlbnQpIHtcbiAgdmFyIHVzZXJQcmVzZXQgPSBudWxsO1xuICB2YXIgdmVyc2lvbiA9IFwiLTFcIjtcbiAgc29tZShwcmVzZXRzLCBmdW5jdGlvbiAocHJlc2V0KSB7XG4gICAgdmFyIHJlc3VsdCA9IGV4ZWNSZWdFeHAoXCIoXCIgKyBwcmVzZXQudGVzdCArIFwiKSgoPzpcXFxcL3xcXFxcc3w6KShbMC05fFxcXFwufF9dKykpP1wiLCB1c2VyQWdlbnQpO1xuXG4gICAgaWYgKCFyZXN1bHQgfHwgcHJlc2V0LmJyYW5kKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdXNlclByZXNldCA9IHByZXNldDtcbiAgICB2ZXJzaW9uID0gcmVzdWx0WzNdIHx8IFwiLTFcIjtcblxuICAgIGlmIChwcmVzZXQudmVyc2lvbkFsaWFzKSB7XG4gICAgICB2ZXJzaW9uID0gcHJlc2V0LnZlcnNpb25BbGlhcztcbiAgICB9IGVsc2UgaWYgKHByZXNldC52ZXJzaW9uVGVzdCkge1xuICAgICAgdmVyc2lvbiA9IGZpbmRWZXJzaW9uKHByZXNldC52ZXJzaW9uVGVzdC50b0xvd2VyQ2FzZSgpLCB1c2VyQWdlbnQpIHx8IHZlcnNpb247XG4gICAgfVxuXG4gICAgdmVyc2lvbiA9IGNvbnZlcnRWZXJzaW9uKHZlcnNpb24pO1xuICAgIHJldHVybiB0cnVlO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBwcmVzZXQ6IHVzZXJQcmVzZXQsXG4gICAgdmVyc2lvbjogdmVyc2lvblxuICB9O1xufVxuZnVuY3Rpb24gZmluZFByZXNldEJyYW5kKHByZXNldHMsIGJyYW5kcykge1xuICB2YXIgYnJhbmRJbmZvID0ge1xuICAgIGJyYW5kOiBcIlwiLFxuICAgIHZlcnNpb246IFwiLTFcIlxuICB9O1xuICBzb21lKHByZXNldHMsIGZ1bmN0aW9uIChwcmVzZXQpIHtcbiAgICB2YXIgcmVzdWx0ID0gZmluZEJyYW5kKGJyYW5kcywgcHJlc2V0KTtcblxuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgYnJhbmRJbmZvLmJyYW5kID0gcHJlc2V0LmlkO1xuICAgIGJyYW5kSW5mby52ZXJzaW9uID0gcHJlc2V0LnZlcnNpb25BbGlhcyB8fCByZXN1bHQudmVyc2lvbjtcbiAgICByZXR1cm4gYnJhbmRJbmZvLnZlcnNpb24gIT09IFwiLTFcIjtcbiAgfSk7XG4gIHJldHVybiBicmFuZEluZm87XG59XG5mdW5jdGlvbiBmaW5kQnJhbmQoYnJhbmRzLCBwcmVzZXQpIHtcbiAgcmV0dXJuIGZpbmQoYnJhbmRzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgYnJhbmQgPSBfYS5icmFuZDtcbiAgICByZXR1cm4gZXhlY1JlZ0V4cChcIlwiICsgcHJlc2V0LnRlc3QsIGJyYW5kLnRvTG93ZXJDYXNlKCkpO1xuICB9KTtcbn1cblxudmFyIEJST1dTRVJfUFJFU0VUUyA9IFt7XG4gIHRlc3Q6IFwicGhhbnRvbWpzXCIsXG4gIGlkOiBcInBoYW50b21qc1wiXG59LCB7XG4gIHRlc3Q6IFwid2hhbGVcIixcbiAgaWQ6IFwid2hhbGVcIlxufSwge1xuICB0ZXN0OiBcImVkZ2lvc3xlZGdlfGVkZ1wiLFxuICBpZDogXCJlZGdlXCJcbn0sIHtcbiAgdGVzdDogXCJtc2llfHRyaWRlbnR8d2luZG93cyBwaG9uZVwiLFxuICBpZDogXCJpZVwiLFxuICB2ZXJzaW9uVGVzdDogXCJpZW1vYmlsZXxtc2llfHJ2XCJcbn0sIHtcbiAgdGVzdDogXCJtaXVpYnJvd3NlclwiLFxuICBpZDogXCJtaXVpIGJyb3dzZXJcIlxufSwge1xuICB0ZXN0OiBcInNhbXN1bmdicm93c2VyXCIsXG4gIGlkOiBcInNhbXN1bmcgaW50ZXJuZXRcIlxufSwge1xuICB0ZXN0OiBcInNhbXN1bmdcIixcbiAgaWQ6IFwic2Ftc3VuZyBpbnRlcm5ldFwiLFxuICB2ZXJzaW9uVGVzdDogXCJ2ZXJzaW9uXCJcbn0sIHtcbiAgdGVzdDogXCJjaHJvbWV8Y3Jpb3NcIixcbiAgaWQ6IFwiY2hyb21lXCJcbn0sIHtcbiAgdGVzdDogXCJmaXJlZm94fGZ4aW9zXCIsXG4gIGlkOiBcImZpcmVmb3hcIlxufSwge1xuICB0ZXN0OiBcImFuZHJvaWRcIixcbiAgaWQ6IFwiYW5kcm9pZCBicm93c2VyXCIsXG4gIHZlcnNpb25UZXN0OiBcInZlcnNpb25cIlxufSwge1xuICB0ZXN0OiBcInNhZmFyaXxpcGhvbmV8aXBhZHxpcG9kXCIsXG4gIGlkOiBcInNhZmFyaVwiLFxuICB2ZXJzaW9uVGVzdDogXCJ2ZXJzaW9uXCJcbn1dOyAvLyBjaHJvbWl1bSdzIGVuZ2luZShibGluaykgaXMgYmFzZWQgb24gYXBwbGV3ZWJraXQgNTM3LjM2LlxuXG52YXIgQ0hST01JVU1fUFJFU0VUUyA9IFt7XG4gIHRlc3Q6IFwiKD89LiphcHBsZXdlYmtpdC8oNTNbMC03XXw1WzAtMl18WzAtNF0pKSg/PS4qXFxcXHNjaHJvbWUpXCIsXG4gIGlkOiBcImNocm9tZVwiLFxuICB2ZXJzaW9uVGVzdDogXCJjaHJvbWVcIlxufSwge1xuICB0ZXN0OiBcImNocm9taXVtXCIsXG4gIGlkOiBcImNocm9tZVwiXG59LCB7XG4gIHRlc3Q6IFwid2hhbGVcIixcbiAgaWQ6IFwiY2hyb21lXCIsXG4gIHZlcnNpb25BbGlhczogXCItMVwiLFxuICBicmFuZDogdHJ1ZVxufV07XG52YXIgV0VCS0lUX1BSRVNFVFMgPSBbe1xuICB0ZXN0OiBcImFwcGxld2Via2l0XCIsXG4gIGlkOiBcIndlYmtpdFwiLFxuICB2ZXJzaW9uVGVzdDogXCJhcHBsZXdlYmtpdHxzYWZhcmlcIlxufV07XG52YXIgV0VCVklFV19QUkVTRVRTID0gW3tcbiAgdGVzdDogXCIoPz0oaXBob25lfGlwYWQpKSg/ISguKnZlcnNpb24pKVwiLFxuICBpZDogXCJ3ZWJ2aWV3XCJcbn0sIHtcbiAgdGVzdDogXCIoPz0oYW5kcm9pZHxpcGhvbmV8aXBhZCkpKD89LioobmF2ZXJ8ZGF1bXw7IHd2KSlcIixcbiAgaWQ6IFwid2Vidmlld1wiXG59LCB7XG4gIC8vIHRlc3Qgd2Vidmlld1xuICB0ZXN0OiBcIndlYnZpZXdcIixcbiAgaWQ6IFwid2Vidmlld1wiXG59XTtcbnZhciBPU19QUkVTRVRTID0gW3tcbiAgdGVzdDogXCJ3aW5kb3dzIHBob25lXCIsXG4gIGlkOiBcIndpbmRvd3MgcGhvbmVcIlxufSwge1xuICB0ZXN0OiBcIndpbmRvd3MgMjAwMFwiLFxuICBpZDogXCJ3aW5kb3dcIixcbiAgdmVyc2lvbkFsaWFzOiBcIjUuMFwiXG59LCB7XG4gIHRlc3Q6IFwid2luZG93cyBudFwiLFxuICBpZDogXCJ3aW5kb3dcIlxufSwge1xuICB0ZXN0OiBcIndpbjMyfHdpbmRvd3NcIixcbiAgaWQ6IFwid2luZG93XCJcbn0sIHtcbiAgdGVzdDogXCJpcGhvbmV8aXBhZHxpcG9kXCIsXG4gIGlkOiBcImlvc1wiLFxuICB2ZXJzaW9uVGVzdDogXCJpcGhvbmUgb3N8Y3B1IG9zXCJcbn0sIHtcbiAgdGVzdDogXCJtYWNvc3xtYWNpbnRlbHxtYWMgb3MgeFwiLFxuICBpZDogXCJtYWNcIlxufSwge1xuICB0ZXN0OiBcImFuZHJvaWR8bGludXggYXJtdjgxXCIsXG4gIGlkOiBcImFuZHJvaWRcIlxufSwge1xuICB0ZXN0OiBcInRpemVuXCIsXG4gIGlkOiBcInRpemVuXCJcbn0sIHtcbiAgdGVzdDogXCJ3ZWJvc3x3ZWIwc1wiLFxuICBpZDogXCJ3ZWJvc1wiXG59XTtcblxuZnVuY3Rpb24gaXNXZWJWaWV3KHVzZXJBZ2VudCkge1xuICByZXR1cm4gISFmaW5kUHJlc2V0KFdFQlZJRVdfUFJFU0VUUywgdXNlckFnZW50KS5wcmVzZXQ7XG59XG5mdW5jdGlvbiBnZXRMZWdhY3lBZ2VudCh1c2VyQWdlbnQpIHtcbiAgdmFyIG5leHRBZ2VudCA9IGdldFVzZXJBZ2VudFN0cmluZyh1c2VyQWdlbnQpO1xuICB2YXIgaXNNb2JpbGUgPSAhIS9tb2JpL2cuZXhlYyhuZXh0QWdlbnQpO1xuICB2YXIgYnJvd3NlciA9IHtcbiAgICBuYW1lOiBcInVua25vd25cIixcbiAgICB2ZXJzaW9uOiBcIi0xXCIsXG4gICAgbWFqb3JWZXJzaW9uOiAtMSxcbiAgICB3ZWJ2aWV3OiBpc1dlYlZpZXcobmV4dEFnZW50KSxcbiAgICBjaHJvbWl1bTogZmFsc2UsXG4gICAgY2hyb21pdW1WZXJzaW9uOiBcIi0xXCIsXG4gICAgd2Via2l0OiBmYWxzZSxcbiAgICB3ZWJraXRWZXJzaW9uOiBcIi0xXCJcbiAgfTtcbiAgdmFyIG9zID0ge1xuICAgIG5hbWU6IFwidW5rbm93blwiLFxuICAgIHZlcnNpb246IFwiLTFcIixcbiAgICBtYWpvclZlcnNpb246IC0xXG4gIH07XG5cbiAgdmFyIF9hID0gZmluZFByZXNldChCUk9XU0VSX1BSRVNFVFMsIG5leHRBZ2VudCksXG4gICAgICBicm93c2VyUHJlc2V0ID0gX2EucHJlc2V0LFxuICAgICAgYnJvd3NlclZlcnNpb24gPSBfYS52ZXJzaW9uO1xuXG4gIHZhciBfYiA9IGZpbmRQcmVzZXQoT1NfUFJFU0VUUywgbmV4dEFnZW50KSxcbiAgICAgIG9zUHJlc2V0ID0gX2IucHJlc2V0LFxuICAgICAgb3NWZXJzaW9uID0gX2IudmVyc2lvbjtcblxuICB2YXIgY2hyb21pdW1QcmVzZXQgPSBmaW5kUHJlc2V0KENIUk9NSVVNX1BSRVNFVFMsIG5leHRBZ2VudCk7XG4gIGJyb3dzZXIuY2hyb21pdW0gPSAhIWNocm9taXVtUHJlc2V0LnByZXNldDtcbiAgYnJvd3Nlci5jaHJvbWl1bVZlcnNpb24gPSBjaHJvbWl1bVByZXNldC52ZXJzaW9uO1xuXG4gIGlmICghYnJvd3Nlci5jaHJvbWl1bSkge1xuICAgIHZhciB3ZWJraXRQcmVzZXQgPSBmaW5kUHJlc2V0KFdFQktJVF9QUkVTRVRTLCBuZXh0QWdlbnQpO1xuICAgIGJyb3dzZXIud2Via2l0ID0gISF3ZWJraXRQcmVzZXQucHJlc2V0O1xuICAgIGJyb3dzZXIud2Via2l0VmVyc2lvbiA9IHdlYmtpdFByZXNldC52ZXJzaW9uO1xuICB9XG5cbiAgaWYgKG9zUHJlc2V0KSB7XG4gICAgb3MubmFtZSA9IG9zUHJlc2V0LmlkO1xuICAgIG9zLnZlcnNpb24gPSBvc1ZlcnNpb247XG4gICAgb3MubWFqb3JWZXJzaW9uID0gcGFyc2VJbnQob3NWZXJzaW9uLCAxMCk7XG4gIH1cblxuICBpZiAoYnJvd3NlclByZXNldCkge1xuICAgIGJyb3dzZXIubmFtZSA9IGJyb3dzZXJQcmVzZXQuaWQ7XG4gICAgYnJvd3Nlci52ZXJzaW9uID0gYnJvd3NlclZlcnNpb247IC8vIEVhcmx5IHdoYWxlIGJ1Z3NcblxuICAgIGlmIChicm93c2VyLndlYnZpZXcgJiYgb3MubmFtZSA9PT0gXCJpb3NcIiAmJiBicm93c2VyLm5hbWUgIT09IFwic2FmYXJpXCIpIHtcbiAgICAgIGJyb3dzZXIud2VidmlldyA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGJyb3dzZXIubWFqb3JWZXJzaW9uID0gcGFyc2VJbnQoYnJvd3Nlci52ZXJzaW9uLCAxMCk7XG4gIHJldHVybiB7XG4gICAgYnJvd3NlcjogYnJvd3NlcixcbiAgICBvczogb3MsXG4gICAgaXNNb2JpbGU6IGlzTW9iaWxlLFxuICAgIGlzSGludHM6IGZhbHNlXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldENsaWVudEhpbnRzQWdlbnQob3NEYXRhKSB7XG4gIHZhciB1c2VyQWdlbnREYXRhID0gbmF2aWdhdG9yLnVzZXJBZ2VudERhdGE7XG4gIHZhciBicmFuZHMgPSAodXNlckFnZW50RGF0YS51YUxpc3QgfHwgdXNlckFnZW50RGF0YS5icmFuZHMpLnNsaWNlKCk7XG4gIHZhciBmdWxsVmVyc2lvbkxpc3QgPSBvc0RhdGEgJiYgb3NEYXRhLmZ1bGxWZXJzaW9uTGlzdDtcbiAgdmFyIGlzTW9iaWxlID0gdXNlckFnZW50RGF0YS5tb2JpbGUgfHwgZmFsc2U7XG4gIHZhciBmaXJzdEJyYW5kID0gYnJhbmRzWzBdO1xuICB2YXIgcGxhdGZvcm0gPSAob3NEYXRhICYmIG9zRGF0YS5wbGF0Zm9ybSB8fCB1c2VyQWdlbnREYXRhLnBsYXRmb3JtIHx8IG5hdmlnYXRvci5wbGF0Zm9ybSkudG9Mb3dlckNhc2UoKTtcbiAgdmFyIGJyb3dzZXIgPSB7XG4gICAgbmFtZTogZmlyc3RCcmFuZC5icmFuZCxcbiAgICB2ZXJzaW9uOiBmaXJzdEJyYW5kLnZlcnNpb24sXG4gICAgbWFqb3JWZXJzaW9uOiAtMSxcbiAgICB3ZWJraXQ6IGZhbHNlLFxuICAgIHdlYmtpdFZlcnNpb246IFwiLTFcIixcbiAgICBjaHJvbWl1bTogZmFsc2UsXG4gICAgY2hyb21pdW1WZXJzaW9uOiBcIi0xXCIsXG4gICAgd2VidmlldzogISFmaW5kUHJlc2V0QnJhbmQoV0VCVklFV19QUkVTRVRTLCBicmFuZHMpLmJyYW5kIHx8IGlzV2ViVmlldyhnZXRVc2VyQWdlbnRTdHJpbmcoKSlcbiAgfTtcbiAgdmFyIG9zID0ge1xuICAgIG5hbWU6IFwidW5rbm93blwiLFxuICAgIHZlcnNpb246IFwiLTFcIixcbiAgICBtYWpvclZlcnNpb246IC0xXG4gIH07XG4gIGJyb3dzZXIud2Via2l0ID0gIWJyb3dzZXIuY2hyb21pdW0gJiYgc29tZShXRUJLSVRfUFJFU0VUUywgZnVuY3Rpb24gKHByZXNldCkge1xuICAgIHJldHVybiBmaW5kQnJhbmQoYnJhbmRzLCBwcmVzZXQpO1xuICB9KTtcbiAgdmFyIGNocm9taXVtQnJhbmQgPSBmaW5kUHJlc2V0QnJhbmQoQ0hST01JVU1fUFJFU0VUUywgYnJhbmRzKTtcbiAgYnJvd3Nlci5jaHJvbWl1bSA9ICEhY2hyb21pdW1CcmFuZC5icmFuZDtcbiAgYnJvd3Nlci5jaHJvbWl1bVZlcnNpb24gPSBjaHJvbWl1bUJyYW5kLnZlcnNpb247XG5cbiAgaWYgKCFicm93c2VyLmNocm9taXVtKSB7XG4gICAgdmFyIHdlYmtpdEJyYW5kID0gZmluZFByZXNldEJyYW5kKFdFQktJVF9QUkVTRVRTLCBicmFuZHMpO1xuICAgIGJyb3dzZXIud2Via2l0ID0gISF3ZWJraXRCcmFuZC5icmFuZDtcbiAgICBicm93c2VyLndlYmtpdFZlcnNpb24gPSB3ZWJraXRCcmFuZC52ZXJzaW9uO1xuICB9XG5cbiAgdmFyIHBsYXRmb21SZXN1bHQgPSBmaW5kKE9TX1BSRVNFVFMsIGZ1bmN0aW9uIChwcmVzZXQpIHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChcIlwiICsgcHJlc2V0LnRlc3QsIFwiZ1wiKS5leGVjKHBsYXRmb3JtKTtcbiAgfSk7XG4gIG9zLm5hbWUgPSBwbGF0Zm9tUmVzdWx0ID8gcGxhdGZvbVJlc3VsdC5pZCA6IFwiXCI7XG5cbiAgaWYgKG9zRGF0YSkge1xuICAgIG9zLnZlcnNpb24gPSBvc0RhdGEucGxhdGZvcm1WZXJzaW9uO1xuICB9XG5cbiAgaWYgKGZ1bGxWZXJzaW9uTGlzdCAmJiBmdWxsVmVyc2lvbkxpc3QubGVuZ3RoKSB7XG4gICAgdmFyIGJyb3dzZXJCcmFuZEJ5RnVsbFZlcnNpb25MaXN0ID0gZmluZFByZXNldEJyYW5kKEJST1dTRVJfUFJFU0VUUywgZnVsbFZlcnNpb25MaXN0KTtcbiAgICBicm93c2VyLm5hbWUgPSBicm93c2VyQnJhbmRCeUZ1bGxWZXJzaW9uTGlzdC5icmFuZCB8fCBicm93c2VyLm5hbWU7XG4gICAgYnJvd3Nlci52ZXJzaW9uID0gYnJvd3NlckJyYW5kQnlGdWxsVmVyc2lvbkxpc3QudmVyc2lvbiB8fCBicm93c2VyLnZlcnNpb247XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJyb3dzZXJCcmFuZCA9IGZpbmRQcmVzZXRCcmFuZChCUk9XU0VSX1BSRVNFVFMsIGJyYW5kcyk7XG4gICAgYnJvd3Nlci5uYW1lID0gYnJvd3NlckJyYW5kLmJyYW5kIHx8IGJyb3dzZXIubmFtZTtcbiAgICBicm93c2VyLnZlcnNpb24gPSBicm93c2VyQnJhbmQuYnJhbmQgJiYgb3NEYXRhID8gb3NEYXRhLnVhRnVsbFZlcnNpb24gOiBicm93c2VyQnJhbmQudmVyc2lvbjtcbiAgfVxuXG4gIGlmIChicm93c2VyLndlYmtpdCkge1xuICAgIG9zLm5hbWUgPSBpc01vYmlsZSA/IFwiaW9zXCIgOiBcIm1hY1wiO1xuICB9XG5cbiAgaWYgKG9zLm5hbWUgPT09IFwiaW9zXCIgJiYgYnJvd3Nlci53ZWJ2aWV3KSB7XG4gICAgYnJvd3Nlci52ZXJzaW9uID0gXCItMVwiO1xuICB9XG5cbiAgb3MudmVyc2lvbiA9IGNvbnZlcnRWZXJzaW9uKG9zLnZlcnNpb24pO1xuICBicm93c2VyLnZlcnNpb24gPSBjb252ZXJ0VmVyc2lvbihicm93c2VyLnZlcnNpb24pO1xuICBvcy5tYWpvclZlcnNpb24gPSBwYXJzZUludChvcy52ZXJzaW9uLCAxMCk7XG4gIGJyb3dzZXIubWFqb3JWZXJzaW9uID0gcGFyc2VJbnQoYnJvd3Nlci52ZXJzaW9uLCAxMCk7XG4gIHJldHVybiB7XG4gICAgYnJvd3NlcjogYnJvd3NlcixcbiAgICBvczogb3MsXG4gICAgaXNNb2JpbGU6IGlzTW9iaWxlLFxuICAgIGlzSGludHM6IHRydWVcbiAgfTtcbn1cbi8qKlxuICogRXh0cmFjdHMgYnJvd3NlciBhbmQgb3BlcmF0aW5nIHN5c3RlbSBpbmZvcm1hdGlvbiBmcm9tIHRoZSB1c2VyIGFnZW50IHN0cmluZy5cbiAqIEBrbyDsnKDsoIAg7JeQ7J207KCE7Yq4IOusuOyekOyXtOyXkOyEnCDruIzrnbzsmrDsoIDsmYAg7Jq07JiB7LK07KCcIOygleuztOulvCDstpTstpztlZzri6QuXG4gKiBAZnVuY3Rpb24gZWcuYWdlbnQjYWdlbnRcbiAqIEBwYXJhbSAtIHVzZXIgYWdlbnQgc3RyaW5nIHRvIHBhcnNlIDxrbz7tjIzsi7HtlaAg7Jyg7KCA7JeQ7J207KCE7Yq4IOusuOyekOyXtDwva28+XG4gKiBAcmV0dXJuIC0gYWdlbnQgSW5mbyA8a28+IOyXkOydtOyghO2KuCDsoJXrs7QgPC9rbz5cbiAqIEBleGFtcGxlXG5pbXBvcnQgYWdlbnQgZnJvbSBcIkBlZ2pzL2FnZW50XCI7XG4vLyBlZy5hZ2VudCgpO1xuY29uc3QgeyBvcywgYnJvd3NlciwgaXNNb2JpbGUgfSA9IGFnZW50KCk7XG4gKi9cblxuZnVuY3Rpb24gYWdlbnQodXNlckFnZW50KSB7XG4gIGlmICh0eXBlb2YgdXNlckFnZW50ID09PSBcInVuZGVmaW5lZFwiICYmIGhhc1VzZXJBZ2VudERhdGEoKSkge1xuICAgIHJldHVybiBnZXRDbGllbnRIaW50c0FnZW50KCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGdldExlZ2FjeUFnZW50KHVzZXJBZ2VudCk7XG4gIH1cbn1cblxuLypcbkNvcHlyaWdodCAoYykgMjAyMi1wcmVzZW50IE5BVkVSIENvcnAuXG5uYW1lOiBAY2Zjcy9jb3JlXG5saWNlbnNlOiBNSVRcbmF1dGhvcjogTkFWRVIgQ3JvcC5cbnJlcG9zaXRvcnk6IGh0dHBzOi8vZ2l0aHViLmNvbS9uYXZlci9jZmNzL3RyZWUvbWFpbi9wYWNrYWdlcy9jb3JlXG52ZXJzaW9uOiAwLjEuMFxuKi9cblxuLyoqXG4gKiBjZmNzXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjItcHJlc2VudCBOQVZFUiBDb3JwLlxuICogTUlUIGxpY2Vuc2VcbiAqL1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZnVuY3Rpb24ga2V5cyhvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaik7XG59XG5cbi8qKlxuICogY2Zjc1xuICogQ29weXJpZ2h0IChjKSAyMDIyLXByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIE1JVCBsaWNlbnNlXG4gKi9cbnZhciBPQlNFUlZFUlNfUEFUSCA9IFwiX19vYnNlcnZlcnNfX1wiO1xudmFyIENPTVBVVEVEX1BBVEggPSBcIl9fY29tcHV0ZWRfX1wiO1xudmFyIENGQ1NfREVURUNURURfREVQRU5ERU5DSUVTX1ZFUlNJT04gPSAxO1xudmFyIENGQ1NfREVURUNURURfREVQRU5ERU5DSUVTID0gXCJfX0NGQ1NfREVURUNURURfREVQRU5ERU5DSUVTX19cIjtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG5cbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXG52YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwge1xuICAgIF9fcHJvdG9fXzogW11cbiAgfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZC5fX3Byb3RvX18gPSBiO1xuICB9IHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTtcbiAgfTtcblxuICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbn07XG5cbmZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XG4gIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcblxuICBmdW5jdGlvbiBfXygpIHtcbiAgICB0aGlzLmNvbnN0cnVjdG9yID0gZDtcbiAgfVxuXG4gIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn1cblxuLyoqXG4gKiBjZmNzXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjItcHJlc2VudCBOQVZFUiBDb3JwLlxuICogTUlUIGxpY2Vuc2VcbiAqL1xuZnVuY3Rpb24gZ2V0RGV0ZWN0ZWRTdGFjaygpIHtcbiAgLy8gVmVyc2lvbiBpc3N1ZXMgZG8gbm90IG9jY3VyIHdoZW4geW91IGFjY2VzcyB0aGUgbmF0aXZlIG9iamVjdCBpbiB0aGUgZ2xvYmFsLlxuICBPYmplY3RbQ0ZDU19ERVRFQ1RFRF9ERVBFTkRFTkNJRVNdID0gT2JqZWN0W0NGQ1NfREVURUNURURfREVQRU5ERU5DSUVTXSB8fCB7fTtcbiAgdmFyIHZlcnNpb25MaXN0ID0gT2JqZWN0W0NGQ1NfREVURUNURURfREVQRU5ERU5DSUVTXTtcbiAgdmVyc2lvbkxpc3RbQ0ZDU19ERVRFQ1RFRF9ERVBFTkRFTkNJRVNfVkVSU0lPTl0gPSB2ZXJzaW9uTGlzdFtDRkNTX0RFVEVDVEVEX0RFUEVOREVOQ0lFU19WRVJTSU9OXSB8fCBbXTtcbiAgcmV0dXJuIHZlcnNpb25MaXN0W0NGQ1NfREVURUNURURfREVQRU5ERU5DSUVTX1ZFUlNJT05dO1xufVxuZnVuY3Rpb24gZ2V0Q3VycmVudERldGVjdGVkKCkge1xuICB2YXIgc3RhY2sgPSBnZXREZXRlY3RlZFN0YWNrKCk7XG4gIHJldHVybiBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbn1cbmZ1bmN0aW9uIGRldGVjdERlcGVuZGVuY2llcyhob3N0KSB7XG4gIHZhciBzdGFjayA9IGdldERldGVjdGVkU3RhY2soKTtcbiAgdmFyIG9ic2VydmVycyA9IFtdO1xuICB2YXIgZGV0ZWN0ZWQgPSB7XG4gICAgaG9zdDogaG9zdCxcbiAgICBvYnNlcnZlcnM6IG9ic2VydmVycyxcbiAgICBwdXNoOiBmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgIGlmIChob3N0ICE9PSBvYnNlcnZlciAmJiBvYnNlcnZlcnMuaW5kZXhPZihvYnNlcnZlcikgPT09IC0xKSB7XG4gICAgICAgIG9ic2VydmVycy5wdXNoKG9ic2VydmVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHN0YWNrLnB1c2goZGV0ZWN0ZWQpO1xuICByZXR1cm4gZGV0ZWN0ZWQ7XG59XG5mdW5jdGlvbiBlbmREZXRlY3REZXBlbmRlbmNpZXMoKSB7XG4gIHZhciBzdGFjayA9IGdldERldGVjdGVkU3RhY2soKTtcbiAgcmV0dXJuIHN0YWNrLnBvcCgpO1xufVxuXG4vKipcbiAqIGNmY3NcbiAqIENvcHlyaWdodCAoYykgMjAyMi1wcmVzZW50IE5BVkVSIENvcnAuXG4gKiBNSVQgbGljZW5zZVxuICovXG4vKipcbiAqIENyZWF0ZXMgYSBtdXRhYmxlIHJlZiBvYmplY3QuIFlvdSBjYW4gYWNjZXNzIHRoZSBgLmN1cnJlbnRgIHZhbHVlIGFuZCBkZXRlY3QgdGhlIHZhbHVlIGNoYW5nZSB0aHJvdWdoIGAuc3Vic2NyaWJlYC5cbiAqIEBjYXRlZ29yeSBSZWFjdGl2ZVxuICogQHNlZSBvYnNlcnZlXG4gKi9cblxudmFyIE9ic2VydmVyID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqXG4gICAqL1xuICBmdW5jdGlvbiBPYnNlcnZlcih2YWx1ZSkge1xuICAgIHRoaXMuX2VtaXR0ZXIgPSBuZXcgQ29tcG9uZW50KCk7XG4gICAgdGhpcy5fY3VycmVudCA9IHZhbHVlO1xuICB9XG5cbiAgdmFyIF9fcHJvdG8gPSBPYnNlcnZlci5wcm90b3R5cGU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcImN1cnJlbnRcIiwge1xuICAgIC8qKlxuICAgICAqIHJldHVybiB0aGUgY3VycmVudCB2YWx1ZS5cbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjdXJyZW50RGV0ZWN0ZWQgPSBnZXRDdXJyZW50RGV0ZWN0ZWQoKTtcbiAgICAgIGN1cnJlbnREZXRlY3RlZCA9PT0gbnVsbCB8fCBjdXJyZW50RGV0ZWN0ZWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN1cnJlbnREZXRlY3RlZC5wdXNoKHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnQ7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgdGhpcy5fc2V0Q3VycmVudCh2YWx1ZSk7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIC8qKlxuICAgKiBXaGVuIHRoZSBjdXJyZW50IHZhbHVlIGNoYW5nZXMsIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBpcyBjYWxsZWQuXG4gICAqL1xuXG4gIF9fcHJvdG8uc3Vic2NyaWJlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5jdXJyZW50O1xuXG4gICAgdGhpcy5fZW1pdHRlci5vbihcInVwZGF0ZVwiLCBjYWxsYmFjayk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXG4gICAqIENhbmNlbCB0aGUgcmVnaXN0ZXJlZCBzdWJzY3JpcHRpb24gdGhyb3VnaCBjYWxsYmFjay5cbiAgICovXG5cblxuICBfX3Byb3RvLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fZW1pdHRlci5vZmYoXCJ1cGRhdGVcIiwgY2FsbGJhY2spO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX19wcm90by5fc2V0Q3VycmVudCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhciBwcmV2VmFsdWUgPSB0aGlzLl9jdXJyZW50O1xuICAgIHZhciBpc1VwZGF0ZSA9IHZhbHVlICE9PSBwcmV2VmFsdWU7XG4gICAgdGhpcy5fY3VycmVudCA9IHZhbHVlO1xuXG4gICAgaWYgKGlzVXBkYXRlKSB7XG4gICAgICB0aGlzLl9lbWl0dGVyLnRyaWdnZXIoXCJ1cGRhdGVcIiwgdmFsdWUsIHByZXZWYWx1ZSk7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogQGhpZGRlblxuICAgKi9cblxuXG4gIF9fcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KHRoaXMuY3VycmVudCk7XG4gIH07XG4gIC8qKlxuICAgKiBAaGlkZGVuXG4gICAqL1xuXG5cbiAgX19wcm90by52YWx1ZU9mID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnQ7XG4gIH07XG5cbiAgcmV0dXJuIE9ic2VydmVyO1xufSgpO1xuXG4vKipcbiAqIEBjYXRlZ29yeSBSZWFjdGl2ZVxuICogQGhpZGRlblxuICovXG5cbnZhciBDb21wdXRlZE9ic2VydmVyID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKENvbXB1dGVkT2JzZXJ2ZXIsIF9zdXBlcik7XG4gIC8qKlxuICAgKiBAZGVzY3JpcHRpb24gQ3JlYXRlcyBhIG5ldyBjb21wdXRlZCBvYnNlcnZlciBmcm9tIHRoZSB2YWx1ZXMgb2Ygb3RoZXIgb2JzZXJ2ZXJzLlxuICAgKiBJdCBpcyByZWFkLW9ubHkgYW5kIGlmIHlvdSBjaGFuZ2UgdGhlIHZhbHVlIG9mIHRoZSBvYnNlcnZlciB1c2VkIGluc2lkZSB0aGUgY2FsbGJhY2ssIGl0cyB2YWx1ZSB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgdXBkYXRlZC5cbiAgICogQHBhcmFtIF9jb21wdXRlZENhbGxiYWNrIEEgZnVuY3Rpb24gZm9yIG9ic2VydmVycyB0byBiZSBjb21wdXRlZC5cbiAgICovXG5cblxuICBmdW5jdGlvbiBDb21wdXRlZE9ic2VydmVyKF9jb21wdXRlZENhbGxiYWNrKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcblxuICAgIF90aGlzLl9jb21wdXRlZENhbGxiYWNrID0gX2NvbXB1dGVkQ2FsbGJhY2s7XG4gICAgX3RoaXMuX3JlZ2lzdGVyZWQgPSBbXTtcblxuICAgIF90aGlzLl9vbkNoZWNrVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuX3NldEN1cnJlbnQoX3RoaXMuY3VycmVudCk7XG4gICAgfTtcblxuICAgIF90aGlzLl9jdXJyZW50ID0gX3RoaXMuY3VycmVudDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX19wcm90byA9IENvbXB1dGVkT2JzZXJ2ZXIucHJvdG90eXBlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJjdXJyZW50XCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIGRldGVjdERlcGVuZGVuY2llcyh0aGlzKTtcblxuICAgICAgdmFyIHZhbHVlID0gdGhpcy5fY29tcHV0ZWRDYWxsYmFjaygpO1xuXG4gICAgICB2YXIgcmVzdWx0cyA9IGVuZERldGVjdERlcGVuZGVuY2llcygpO1xuXG4gICAgICB0aGlzLl9yZWdpc3RlcmVkLmZvckVhY2goZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICAgIG9ic2VydmVyLnVuc3Vic2NyaWJlKF90aGlzLl9vbkNoZWNrVXBkYXRlKTtcbiAgICAgIH0pO1xuXG4gICAgICByZXN1bHRzLm9ic2VydmVycy5mb3JFYWNoKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICBvYnNlcnZlci5zdWJzY3JpYmUoX3RoaXMuX29uQ2hlY2tVcGRhdGUpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLl9yZWdpc3RlcmVkID0gcmVzdWx0cy5vYnNlcnZlcnM7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIHJldHVybiBDb21wdXRlZE9ic2VydmVyO1xufShPYnNlcnZlcik7XG5cbi8qKlxuICogY2Zjc1xuICogQ29weXJpZ2h0IChjKSAyMDIyLXByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIE1JVCBsaWNlbnNlXG4gKi9cblxuZnVuY3Rpb24gaW5qZWN0T2JzZXJ2ZShwcm90b3R5cGUsIG1lbWJlck5hbWUsIHB1YmxpY05hbWUpIHtcbiAgaWYgKHB1YmxpY05hbWUgPT09IHZvaWQgMCkge1xuICAgIHB1YmxpY05hbWUgPSBtZW1iZXJOYW1lO1xuICB9XG5cbiAgdmFyIG5leHRBdHRyaWJ1dGVzID0ge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBnZXRPYnNlcnZlcih0aGlzLCBwdWJsaWNOYW1lKS5jdXJyZW50O1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGdldE9ic2VydmVyKHRoaXMsIHB1YmxpY05hbWUsIHZhbHVlKS5jdXJyZW50ID0gdmFsdWU7XG4gICAgfVxuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG90eXBlLCBtZW1iZXJOYW1lLCBuZXh0QXR0cmlidXRlcyk7XG5cbiAgaWYgKHB1YmxpY05hbWUgIT09IG1lbWJlck5hbWUpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG90eXBlLCBwdWJsaWNOYW1lLCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGdldE9ic2VydmVyKHRoaXMsIHB1YmxpY05hbWUpLmN1cnJlbnQ7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbi8qKlxuICogQGRlc2NyaXB0aW9uIGBPYnNlcnZlYCBpcyBhIHByb3BlcnR5IGRlY29yYXRvciBhbmQgY29udmVydHMgdGhlIHByb3BlcnR5IGludG8gYSBgcmVhY3RpdmUgc3RhdGVgLiBZb3UgY2FuIGRldGVjdCBpdHMgc3RhdHVzIHRocm91Z2ggYC5zdWJzY3JpYmVgLlxuICogQGNhdGVnb3J5IFJlYWN0aXZlLURlY29yYXRvclxuICogQHNlZSBSZWFjdGl2ZVN1YnNjcmliZVxuICogQGV4YW1wbGVcbiogYGBgdHNcbmltcG9ydCB7IFJlYWN0aXZlU3Vic2NyaWJlLCBPYnNlcnZlIH0gZnJvbSBcIkBjZmNzL2NvcmVcIjtcblxuQFJlYWN0aXZlU3Vic2NyaWJlXG5jbGFzcyBDb21wb25lbnQge1xuICAvLyBUaGUgcHVibGljIG5hbWUgYW5kIHN0YXRlIG5hbWUgYXJlIHRoZSBzYW1lLlxuICBAT2JzZXJ2ZSB2YWx1ZTEgPSAxO1xuICAvLyBJZiB5b3Ugd2FudCB0byBzZXQgcHVibGljIG5hbWUgYW5kIHByaXZhdGUgcHJvcGVydGllcyBzZXBhcmF0ZWx5XG4gIEBPYnNlcnZlKFwidmFsdWUyXCIpIF92YWx1ZTIgPSAxO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICB0aGlzLnZhbHVlMSA9IDI7XG4gICAgfSk7XG4gIH1cbn1cbmludGVyZmFjZSBDXG5gYGBcbiAqL1xuXG5cbmZ1bmN0aW9uIE9ic2VydmUoKSB7XG4gIHZhciBhcmdzID0gW107XG5cbiAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gIH1cblxuICBpZiAoYXJncy5sZW5ndGggPiAxKSB7XG4gICAgcmV0dXJuIGluamVjdE9ic2VydmUoYXJnc1swXSwgYXJnc1sxXSk7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKHByb3RvdHlwZSwgbWVtYmVyTmFtZSkge1xuICAgIHJldHVybiBpbmplY3RPYnNlcnZlKHByb3RvdHlwZSwgbWVtYmVyTmFtZSwgYXJnc1swXSk7XG4gIH07XG59XG5cbi8qKlxuICogY2Zjc1xuICogQ29weXJpZ2h0IChjKSAyMDIyLXByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIE1JVCBsaWNlbnNlXG4gKi9cbi8qKlxuICogQGhpZGRlblxuICovXG5cbmZ1bmN0aW9uIGluamVjdFJlYWN0aXZlU3Vic2NyaWJlKG9iamVjdCkge1xuICBvYmplY3RbXCJzdWJzY3JpYmVcIl0gPSBmdW5jdGlvbiAobmFtZSwgY2FsbGJhY2spIHtcbiAgICB0aGlzW25hbWVdO1xuICAgIGdldE9ic2VydmVyKHRoaXMsIG5hbWUpLnN1YnNjcmliZShjYWxsYmFjayk7XG4gIH07XG5cbiAgb2JqZWN0W1widW5zdWJzY3JpYmVcIl0gPSBmdW5jdGlvbiAobmFtZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICBrZXlzKGdldE9ic2VydmVycyh0aGlzKSkuZm9yRWFjaChmdW5jdGlvbiAob2JzZXJ2ZXJOYW1lKSB7XG4gICAgICAgIF90aGlzLnVuc3Vic2NyaWJlKG9ic2VydmVyTmFtZSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIShuYW1lIGluIHRoaXMpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZ2V0T2JzZXJ2ZXIodGhpcywgbmFtZSkudW5zdWJzY3JpYmUoY2FsbGJhY2spO1xuICB9O1xufVxuLyoqXG4gKiBAZGVzY3JpcHRpb24gYFJlYWN0aXZlU3Vic2NyaWJlYCBpcyBhIGNsYXNzIGRlY29yYXRvciBhbmQgYWRkcyBgLnN1YnNjcmliZWAgYW5kIGAudW5zdWJzY3JpYmVgIG1ldGhvZHMuXG4gKiBAY2F0ZWdvcnkgUmVhY3RpdmUtRGVjb3JhdG9yXG4gKiBAc2VlIE9ic2VydmVcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuaW1wb3J0IHsgUmVhY3RpdmVTdWJzY3JpYmUsIE9ic2VydmUgfSBmcm9tIFwiQGNmY3MvY29yZVwiO1xuXG5AUmVhY3RpdmVTdWJzY3JpYmVcbmNsYXNzIENvbXBvbmVudCB7XG4gIEBPYnNlcnZlIHZhbHVlMSA9IDE7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIHRoaXMudmFsdWUxID0gMjtcbiAgICB9KTtcbiAgfVxufVxuXG5pbnRlcmZhY2UgQ29tcG9uZW50IGV4dGVuZHMgUmVhY3RpdmVTdWJzY3JpYmU8e1xuICB2YWx1ZTE6IG51bWJlcjtcbiAgdmFsdWUyOiBudW1iZXI7XG59PiB7fVxuXG5jb25zdCBjb21wb25lbnQgPSBuZXcgQ29tcG9uZW50KCk7XG5cbi8vIDFcbmNvbnNvbGUubG9nKGNvbXBvbmVudC52YWx1ZTEpO1xuXG5jb21wb25lbnQuc3Vic2NyaWJlKFwidmFsdWUxXCIsIG5leHRWYWx1ZSA9PiB7XG4gIC8vIFdoZW4gdGhlIGNoYW5nZSBldmVudCBvY2N1cnMgPT4gKDIsIDIpXG4gIGNvbnNvbGUubG9nKG5leHRWYWx1ZSwgY29tcG9uZW50LnZhbHVlMik7XG59KTtcbmBgYFxuICovXG5cbmZ1bmN0aW9uIFJlYWN0aXZlU3Vic2NyaWJlKENvbnN0cnVjdG9yKSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIGluamVjdFJlYWN0aXZlU3Vic2NyaWJlKHByb3RvdHlwZSk7XG59XG4vKipcbiAqIEBkZXNjcmlwdGlvbiBDcmVhdGVzIGEgbXV0YWJsZSByZWYgb2JqZWN0LiBZb3UgY2FuIGFjY2VzcyB0aGUgYC5jdXJyZW50YCB2YWx1ZSBhbmQgZGV0ZWN0IHRoZSB2YWx1ZSBjaGFuZ2UgdGhyb3VnaCBgLnN1YnNjcmliZWAuXG4gKiBAY2F0ZWdvcnkgUmVhY3RpdmVcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgb2JzZXJ2ZSB9IGZyb20gXCJAY2Zjcy9jb3JlXCI7XG4gKlxuICogY29uc3Qgb2IxID0gb2JzZXJ2ZSgxKTtcbiAqXG4gKiBvYjEuc3Vic2NyaWJlKG5leHRWYWx1ZSA9PiB7XG4gKiAgIGNvbnNvbGUubG9nKG5leHRWYWx1ZSk7XG4gKiB9KTtcbiAqXG4gKiBvYjEuY3VycmVudCA9IDI7XG4gKiBgYGBcbiAqL1xuXG5mdW5jdGlvbiBvYnNlcnZlKGRlZmF1bHRWYWx1ZSkge1xuICByZXR1cm4gbmV3IE9ic2VydmVyKGRlZmF1bHRWYWx1ZSk7XG59XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuXG5mdW5jdGlvbiBjb21wdXRlZChjb21wdXRlZENhbGxiYWNrKSB7XG4gIHJldHVybiBuZXcgQ29tcHV0ZWRPYnNlcnZlcihjb21wdXRlZENhbGxiYWNrKTtcbn1cbi8qKlxuICogQGhpZGRlblxuICovXG5cbmZ1bmN0aW9uIGRlZmluZU9ic2VydmVycyhpbnN0YW5jZSkge1xuICB2YXIgb2JzZXJ2ZXJzID0ge307XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpbnN0YW5jZSwgT0JTRVJWRVJTX1BBVEgsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBvYnNlcnZlcnM7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG9ic2VydmVycztcbn1cbi8qKlxuICogQGhpZGRlblxuICovXG5cbmZ1bmN0aW9uIGdldE9ic2VydmVycyhpbnN0YW5jZSwgaXNDb21wdXRlZCkge1xuICB2YXIgX2EsIF9iO1xuXG4gIGlmICghaW5zdGFuY2VbT0JTRVJWRVJTX1BBVEhdKSB7XG4gICAgZGVmaW5lT2JzZXJ2ZXJzKGluc3RhbmNlKTtcbiAgfVxuXG4gIHZhciBvYnNlcnZlcnMgPSBpbnN0YW5jZVtPQlNFUlZFUlNfUEFUSF07XG5cbiAgaWYgKCFpc0NvbXB1dGVkKSB7XG4gICAgdmFyIGNvbXB1dGVkTGlzdCA9IChfYiA9IChfYSA9IGluc3RhbmNlID09PSBudWxsIHx8IGluc3RhbmNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbnN0YW5jZS5jb25zdHJ1Y3RvcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnByb3RvdHlwZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW0NPTVBVVEVEX1BBVEhdO1xuXG4gICAgaWYgKGNvbXB1dGVkTGlzdCkge1xuICAgICAgY29tcHV0ZWRMaXN0LmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgaWYgKCEobmFtZSBpbiBvYnNlcnZlcnMpICYmIG5hbWUgaW4gaW5zdGFuY2UpIHtcbiAgICAgICAgICBpbnN0YW5jZVtuYW1lXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9ic2VydmVycztcbn1cbi8qKlxuICogQGhpZGRlblxuICovXG5cbmZ1bmN0aW9uIGdldE9ic2VydmVyKGluc3RhbmNlLCBuYW1lLCBkZWZhdWx0VmFsdWUpIHtcbiAgdmFyIG9ic2VydmVycyA9IGdldE9ic2VydmVycyhpbnN0YW5jZSk7XG5cbiAgaWYgKCFvYnNlcnZlcnNbbmFtZV0pIHtcbiAgICBvYnNlcnZlcnNbbmFtZV0gPSBvYnNlcnZlKGRlZmF1bHRWYWx1ZSk7XG4gIH1cblxuICByZXR1cm4gb2JzZXJ2ZXJzW25hbWVdO1xufVxuXG4vKipcbiAqIGNmY3NcbiAqIENvcHlyaWdodCAoYykgMjAyMi1wcmVzZW50IE5BVkVSIENvcnAuXG4gKiBNSVQgbGljZW5zZVxuICovXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBgQ29tcHV0ZWRgIGlzIGEgcHJvcGVydHkgZGVjb3JhdG9yLlxuICogQ2hhbmdlcyBpbiBjb21wdXRlZCBzdGF0ZSB2YWx1ZXMgYXJlIGFsc28gcmVjb2duaXplZCBhY2NvcmRpbmcgdG8gY2hhbmdlcyBpbiBvYnNlcnZlcnMgdXNlZCB3aXRoaW4gdGhlIGdldHRlciBmdW5jdGlvbi5cbiAqIFlvdSBjYW4gZGV0ZWN0IGl0cyBzdGF0dXMgdGhyb3VnaCBgLnN1YnNjcmliZWAuXG4gKiBAaGlkZGVuXG4gKiBAY2F0ZWdvcnkgUmVhY3RpdmUtRGVjb3JhdG9yXG4gKiBAc2VlIFJlYWN0aXZlU3Vic2NyaWJlXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbmNvbnN0IG9iMSA9IG9ic2VydmUoMCk7XG5jb25zdCBvYjIgPSBvYnNlcnZlKDEpO1xuXG4vLyBXaGVuXG5AUmVhY3RpdmVTdWJzY3JpYmVcbmNsYXNzIFRlc3RDb21wdXRlZCB7XG4gIEBDb21wdXRlZFxuICBnZXQgb2IzKCkge1xuICAgIHJldHVybiBvYjEuY3VycmVudCArIG9iMi5jdXJyZW50O1xuICB9XG59XG5jb25zdCBpbnN0ID0gbmV3IFRlc3RDb21wdXRlZCgpO1xuXG5pbnN0LnN1YnNjcmliZShcIm9iM1wiLCBvYjMgPT4ge1xuICBjb25zb2xlLmxvZyhvYjMpO1xufSk7XG5cbm9iMS5jdXJyZW50ID0gMTtcbmBgYFxuICovXG5cbmZ1bmN0aW9uIENvbXB1dGVkKHByb3RvdHlwZSwgbWVtYmVyTmFtZSwgYXR0cmlidXRlcykge1xuICB2YXIgZ2V0ID0gYXR0cmlidXRlcy5nZXQ7XG5cbiAgZnVuY3Rpb24gZ2V0Q29tcHV0ZWQoKSB7XG4gICAgdmFyIG9ic2VydmVycyA9IGdldE9ic2VydmVycyh0aGlzLCB0cnVlKTtcblxuICAgIGlmICghKG1lbWJlck5hbWUgaW4gb2JzZXJ2ZXJzKSkge1xuICAgICAgb2JzZXJ2ZXJzW21lbWJlck5hbWVdID0gY29tcHV0ZWQoZ2V0LmJpbmQodGhpcykpO1xuICAgIH1cblxuICAgIHJldHVybiBnZXRPYnNlcnZlcih0aGlzLCBtZW1iZXJOYW1lKS5jdXJyZW50O1xuICB9XG5cbiAgdmFyIG5leHRBdHRyaWJ1dGVzID0ge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGdldENvbXB1dGVkXG4gIH07XG4gIHByb3RvdHlwZVtDT01QVVRFRF9QQVRIXSB8fCAocHJvdG90eXBlW0NPTVBVVEVEX1BBVEhdID0gW10pO1xuICB2YXIgY29tcHV0ZWRMaXN0ID0gcHJvdG90eXBlW0NPTVBVVEVEX1BBVEhdO1xuXG4gIGlmIChjb21wdXRlZExpc3QuaW5kZXhPZihtZW1iZXJOYW1lKSA9PT0gLTEpIHtcbiAgICBjb21wdXRlZExpc3QucHVzaChtZW1iZXJOYW1lKTtcbiAgfVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90b3R5cGUsIG1lbWJlck5hbWUsIG5leHRBdHRyaWJ1dGVzKTtcbiAgcmV0dXJuIG5leHRBdHRyaWJ1dGVzO1xufVxuXG4vKlxuQ29weXJpZ2h0IChjKSBOQVZFUiBDb3JwLlxubmFtZTogQGVnanMvYXhlc1xubGljZW5zZTogTUlUXG5hdXRob3I6IE5BVkVSIENvcnAuXG5yZXBvc2l0b3J5OiBodHRwczovL2dpdGh1Yi5jb20vbmF2ZXIvZWdqcy1heGVzXG52ZXJzaW9uOiAzLjkuMVxuKi9cblxuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2VcclxudGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGVcclxuTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblRISVMgQ09ERSBJUyBQUk9WSURFRCBPTiBBTiAqQVMgSVMqIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuS0lORCwgRUlUSEVSIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIFdJVEhPVVQgTElNSVRBVElPTiBBTlkgSU1QTElFRFxyXG5XQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgVElUTEUsIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLFxyXG5NRVJDSEFOVEFCTElUWSBPUiBOT04tSU5GUklOR0VNRU5ULlxyXG5cclxuU2VlIHRoZSBBcGFjaGUgVmVyc2lvbiAyLjAgTGljZW5zZSBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zXHJcbmFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXG5cbnZhciBleHRlbmRTdGF0aWNzJDEgPSBmdW5jdGlvbiAoZCwgYikge1xuICBleHRlbmRTdGF0aWNzJDEgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwge1xuICAgIF9fcHJvdG9fXzogW11cbiAgfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZC5fX3Byb3RvX18gPSBiO1xuICB9IHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gIH07XG4gIHJldHVybiBleHRlbmRTdGF0aWNzJDEoZCwgYik7XG59O1xuZnVuY3Rpb24gX19leHRlbmRzJDEoZCwgYikge1xuICBleHRlbmRTdGF0aWNzJDEoZCwgYik7XG4gIGZ1bmN0aW9uIF9fKCkge1xuICAgIHRoaXMuY29uc3RydWN0b3IgPSBkO1xuICB9XG4gIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn1cbnZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uICgpIHtcbiAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcbiAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xuICAgIH1cbiAgICByZXR1cm4gdDtcbiAgfTtcbiAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuZnVuY3Rpb24gX19kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsXG4gICAgZDtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufVxuXG4vKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IE5BVkVSIENvcnAuXG4gKiBlZ2pzIHByb2plY3RzIGFyZSBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tbmV3LWZ1bmMsIG5vLW5lc3RlZC10ZXJuYXJ5ICovXG52YXIgd2luO1xuaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgLy8gd2luZG93IGlzIHVuZGVmaW5lZCBpbiBub2RlLmpzXG4gIHdpbiA9IHtcbiAgICBuYXZpZ2F0b3I6IHtcbiAgICAgIHVzZXJBZ2VudDogXCJcIlxuICAgIH1cbiAgfTtcbn0gZWxzZSB7XG4gIHdpbiA9IHdpbmRvdztcbn1cblxuLypcbiAqIENvcHlyaWdodCAoYykgMjAxNSBOQVZFUiBDb3JwLlxuICogZWdqcyBwcm9qZWN0cyBhcmUgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbnZhciBESVJFQ1RJT05fTk9ORSA9IDE7XG52YXIgRElSRUNUSU9OX0xFRlQgPSAyO1xudmFyIERJUkVDVElPTl9SSUdIVCA9IDQ7XG52YXIgRElSRUNUSU9OX0hPUklaT05UQUwgPSAyIHwgNDtcbnZhciBESVJFQ1RJT05fVVAgPSA4O1xudmFyIERJUkVDVElPTl9ET1dOID0gMTY7XG52YXIgRElSRUNUSU9OX1ZFUlRJQ0FMID0gOCB8IDE2O1xudmFyIERJUkVDVElPTl9BTEwgPSAyIHwgNCB8IDggfCAxNjtcbnZhciBNT1VTRV9MRUZUID0gXCJsZWZ0XCI7XG52YXIgTU9VU0VfUklHSFQgPSBcInJpZ2h0XCI7XG52YXIgTU9VU0VfTUlERExFID0gXCJtaWRkbGVcIjtcbnZhciBNT1VTRV9CVVRUT05fQ09ERV9NQVAgPSB7XG4gIDE6IE1PVVNFX0xFRlQsXG4gIDI6IE1PVVNFX01JRERMRSxcbiAgMzogTU9VU0VfUklHSFRcbn07XG52YXIgQU5ZID0gXCJhbnlcIjtcbnZhciBOT05FID0gXCJub25lXCI7XG52YXIgU0hJRlQgPSBcInNoaWZ0XCI7XG52YXIgQ1RSTCA9IFwiY3RybFwiO1xudmFyIEFMVCA9IFwiYWx0XCI7XG52YXIgTUVUQSA9IFwibWV0YVwiO1xudmFyIFZFTE9DSVRZX0lOVEVSVkFMID0gMTY7XG52YXIgSU9TX0VER0VfVEhSRVNIT0xEID0gMzA7XG52YXIgSVNfSU9TX1NBRkFSSSA9IFwib250b3VjaHN0YXJ0XCIgaW4gd2luICYmIGFnZW50KCkuYnJvd3Nlci5uYW1lID09PSBcInNhZmFyaVwiO1xudmFyIFRSQU5TRk9STSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG4gIHZhciBib2R5U3R5bGUgPSAoZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF0pLnN0eWxlO1xuICB2YXIgdGFyZ2V0ID0gW1widHJhbnNmb3JtXCIsIFwid2Via2l0VHJhbnNmb3JtXCIsIFwibXNUcmFuc2Zvcm1cIiwgXCJtb3pUcmFuc2Zvcm1cIl07XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0YXJnZXQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAodGFyZ2V0W2ldIGluIGJvZHlTdHlsZSkge1xuICAgICAgcmV0dXJuIHRhcmdldFtpXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFwiXCI7XG59KCk7XG52YXIgUFJFVkVOVF9EUkFHX0NTU1BST1BTID0ge1xuICBcIi13ZWJraXQtdXNlci1zZWxlY3RcIjogXCJub25lXCIsXG4gIFwiLW1zLXVzZXItc2VsZWN0XCI6IFwibm9uZVwiLFxuICBcIi1tb3otdXNlci1zZWxlY3RcIjogXCJub25lXCIsXG4gIFwidXNlci1zZWxlY3RcIjogXCJub25lXCIsXG4gIFwiLXdlYmtpdC11c2VyLWRyYWdcIjogXCJub25lXCJcbn07XG5cbnZhciB0b0FycmF5ID0gZnVuY3Rpb24gKG5vZGVzKSB7XG4gIC8vIGNvbnN0IGVsID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobm9kZXMpO1xuICAvLyBmb3IgSUU4XG4gIHZhciBlbCA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gbm9kZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBlbC5wdXNoKG5vZGVzW2ldKTtcbiAgfVxuICByZXR1cm4gZWw7XG59O1xudmFyICQkMSA9IGZ1bmN0aW9uIChwYXJhbSwgbXVsdGkpIHtcbiAgaWYgKG11bHRpID09PSB2b2lkIDApIHtcbiAgICBtdWx0aSA9IGZhbHNlO1xuICB9XG4gIHZhciBlbDtcbiAgaWYgKHR5cGVvZiBwYXJhbSA9PT0gXCJzdHJpbmdcIikge1xuICAgIC8vIFN0cmluZyAoSFRNTCwgU2VsZWN0b3IpXG4gICAgLy8gY2hlY2sgaWYgc3RyaW5nIGlzIEhUTUwgdGFnIGZvcm1hdFxuICAgIHZhciBtYXRjaCA9IHBhcmFtLm1hdGNoKC9ePChbYS16XSspXFxzKihbXj5dKik+Lyk7XG4gICAgLy8gY3JlYXRpbmcgZWxlbWVudFxuICAgIGlmIChtYXRjaCkge1xuICAgICAgLy8gSFRNTFxuICAgICAgdmFyIGR1bW15ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIGR1bW15LmlubmVySFRNTCA9IHBhcmFtO1xuICAgICAgZWwgPSB0b0FycmF5KGR1bW15LmNoaWxkTm9kZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTZWxlY3RvclxuICAgICAgZWwgPSB0b0FycmF5KGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwocGFyYW0pKTtcbiAgICB9XG4gICAgaWYgKCFtdWx0aSkge1xuICAgICAgZWwgPSBlbC5sZW5ndGggPj0gMSA/IGVsWzBdIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgfSBlbHNlIGlmIChwYXJhbSA9PT0gd2luKSB7XG4gICAgLy8gd2luZG93XG4gICAgZWwgPSBwYXJhbTtcbiAgfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gcGFyYW0gfHwgXCJjdXJyZW50XCIgaW4gcGFyYW0pIHtcbiAgICBlbCA9IHBhcmFtLnZhbHVlIHx8IHBhcmFtLmN1cnJlbnQ7XG4gIH0gZWxzZSBpZiAocGFyYW0ubm9kZU5hbWUgJiYgKHBhcmFtLm5vZGVUeXBlID09PSAxIHx8IHBhcmFtLm5vZGVUeXBlID09PSA5KSkge1xuICAgIC8vIEhUTUxFbGVtZW50LCBEb2N1bWVudFxuICAgIGVsID0gcGFyYW07XG4gIH0gZWxzZSBpZiAoXCJqUXVlcnlcIiBpbiB3aW4gJiYgcGFyYW0gaW5zdGFuY2VvZiBqUXVlcnkgfHwgcGFyYW0uY29uc3RydWN0b3IucHJvdG90eXBlLmpxdWVyeSkge1xuICAgIC8vIGpRdWVyeVxuICAgIGVsID0gbXVsdGkgPyBwYXJhbS50b0FycmF5KCkgOiBwYXJhbS5nZXQoMCk7XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShwYXJhbSkpIHtcbiAgICBlbCA9IHBhcmFtLm1hcChmdW5jdGlvbiAodikge1xuICAgICAgcmV0dXJuICQkMSh2KTtcbiAgICB9KTtcbiAgICBpZiAoIW11bHRpKSB7XG4gICAgICBlbCA9IGVsLmxlbmd0aCA+PSAxID8gZWxbMF0gOiB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBlbDtcbn07XG52YXIgcmFmID0gd2luLnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW4ud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xudmFyIGNhZiA9IHdpbi5jYW5jZWxBbmltYXRpb25GcmFtZSB8fCB3aW4ud2Via2l0Q2FuY2VsQW5pbWF0aW9uRnJhbWU7XG5pZiAocmFmICYmICFjYWYpIHtcbiAgdmFyIGtleUluZm9fMSA9IHt9O1xuICB2YXIgb2xkcmFmXzEgPSByYWY7XG4gIHJhZiA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIHZhciB3cmFwQ2FsbGJhY2sgPSBmdW5jdGlvbiAodGltZXN0YW1wKSB7XG4gICAgICBpZiAoa2V5SW5mb18xW2tleV0pIHtcbiAgICAgICAgY2FsbGJhY2sodGltZXN0YW1wKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBrZXkgPSBvbGRyYWZfMSh3cmFwQ2FsbGJhY2spO1xuICAgIGtleUluZm9fMVtrZXldID0gdHJ1ZTtcbiAgICByZXR1cm4ga2V5O1xuICB9O1xuICBjYWYgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgZGVsZXRlIGtleUluZm9fMVtrZXldO1xuICB9O1xufSBlbHNlIGlmICghKHJhZiAmJiBjYWYpKSB7XG4gIHJhZiA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIHJldHVybiB3aW4uc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBjYWxsYmFjayh3aW4ucGVyZm9ybWFuY2UgJiYgd2luLnBlcmZvcm1hbmNlLm5vdyAmJiB3aW4ucGVyZm9ybWFuY2Uubm93KCkgfHwgbmV3IERhdGUoKS5nZXRUaW1lKCkpO1xuICAgIH0sIDE2KTtcbiAgfTtcbiAgY2FmID0gd2luLmNsZWFyVGltZW91dDtcbn1cbi8qKlxuICogQSBwb2x5ZmlsbCBmb3IgdGhlIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKSBtZXRob2QuXG4gKiBAc2VlICBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvd2luZG93L3JlcXVlc3RBbmltYXRpb25GcmFtZVxuICogQHByaXZhdGVcbiAqL1xudmFyIHJlcXVlc3RBbmltYXRpb25GcmFtZSQxID0gZnVuY3Rpb24gKGZwKSB7XG4gIHJldHVybiByYWYoZnApO1xufTtcbi8qKlxuICogQSBwb2x5ZmlsbCBmb3IgdGhlIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSgpIG1ldGhvZC4gSXQgY2FuY2VscyBhbiBhbmltYXRpb24gZXhlY3V0ZWQgdGhyb3VnaCBhIGNhbGwgdG8gdGhlIHJlcXVlc3RBbmltYXRpb25GcmFtZSgpIG1ldGhvZC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBrZXkg4oiSICBUaGUgSUQgdmFsdWUgcmV0dXJuZWQgdGhyb3VnaCBhIGNhbGwgdG8gdGhlIHJlcXVlc3RBbmltYXRpb25GcmFtZSgpIG1ldGhvZC4gPGtvPnJlcXVlc3RBbmltYXRpb25GcmFtZSgpIOuplOyEnOuTnOqwgCDrsJjtmZjtlZwg7JWE7J2065SUIOqwkjwva28+XG4gKiBAc2VlICBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2luZG93L2NhbmNlbEFuaW1hdGlvbkZyYW1lXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgY2FuY2VsQW5pbWF0aW9uRnJhbWUkMSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgY2FmKGtleSk7XG59O1xudmFyIG1hcCA9IGZ1bmN0aW9uIChvYmosIGNhbGxiYWNrKSB7XG4gIHZhciB0cmFuZm9ybWVkID0ge307XG4gIGZvciAodmFyIGsgaW4gb2JqKSB7XG4gICAgaWYgKGspIHtcbiAgICAgIHRyYW5mb3JtZWRba10gPSBjYWxsYmFjayhvYmpba10sIGspO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJhbmZvcm1lZDtcbn07XG52YXIgZmlsdGVyID0gZnVuY3Rpb24gKG9iaiwgY2FsbGJhY2spIHtcbiAgdmFyIGZpbHRlcmVkID0ge307XG4gIGZvciAodmFyIGsgaW4gb2JqKSB7XG4gICAgaWYgKGsgJiYgY2FsbGJhY2sob2JqW2tdLCBrKSkge1xuICAgICAgZmlsdGVyZWRba10gPSBvYmpba107XG4gICAgfVxuICB9XG4gIHJldHVybiBmaWx0ZXJlZDtcbn07XG52YXIgZXZlcnkgPSBmdW5jdGlvbiAob2JqLCBjYWxsYmFjaykge1xuICBmb3IgKHZhciBrIGluIG9iaikge1xuICAgIGlmIChrICYmICFjYWxsYmFjayhvYmpba10sIGspKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufTtcbnZhciBlcXVhbCA9IGZ1bmN0aW9uICh0YXJnZXQsIGJhc2UpIHtcbiAgcmV0dXJuIGV2ZXJ5KHRhcmdldCwgZnVuY3Rpb24gKHYsIGspIHtcbiAgICByZXR1cm4gdiA9PT0gYmFzZVtrXTtcbiAgfSk7XG59O1xudmFyIHJvdW5kTnVtRnVuYyA9IHt9O1xudmFyIHJvdW5kTnVtYmVyID0gZnVuY3Rpb24gKG51bSwgcm91bmRVbml0KSB7XG4gIC8vIENhY2hlIGZvciBwZXJmb3JtYW5jZVxuICBpZiAoIXJvdW5kTnVtRnVuY1tyb3VuZFVuaXRdKSB7XG4gICAgcm91bmROdW1GdW5jW3JvdW5kVW5pdF0gPSBnZXRSb3VuZEZ1bmMocm91bmRVbml0KTtcbiAgfVxuICByZXR1cm4gcm91bmROdW1GdW5jW3JvdW5kVW5pdF0obnVtKTtcbn07XG52YXIgcm91bmROdW1iZXJzID0gZnVuY3Rpb24gKG51bSwgcm91bmRVbml0KSB7XG4gIGlmICghbnVtIHx8ICFyb3VuZFVuaXQpIHtcbiAgICByZXR1cm4gbnVtO1xuICB9XG4gIHJldHVybiBtYXAobnVtLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgIHJldHVybiByb3VuZE51bWJlcih2YWx1ZSwgdHlwZW9mIHJvdW5kVW5pdCA9PT0gXCJudW1iZXJcIiA/IHJvdW5kVW5pdCA6IHJvdW5kVW5pdFtrZXldKTtcbiAgfSk7XG59O1xudmFyIGdldERlY2ltYWxQbGFjZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgaWYgKCFpc0Zpbml0ZSh2YWwpKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgdmFyIHYgPSBcIlwiLmNvbmNhdCh2YWwpO1xuICBpZiAodi5pbmRleE9mKFwiZVwiKSA+PSAwKSB7XG4gICAgLy8gRXhwb25lbnRpYWwgRm9ybWF0XG4gICAgLy8gMWUtMTAsIDFlLTEyXG4gICAgdmFyIHAgPSAwO1xuICAgIHZhciBlID0gMTtcbiAgICB3aGlsZSAoTWF0aC5yb3VuZCh2YWwgKiBlKSAvIGUgIT09IHZhbCkge1xuICAgICAgZSAqPSAxMDtcbiAgICAgIHArKztcbiAgICB9XG4gICAgcmV0dXJuIHA7XG4gIH1cbiAgLy8gSW4gZ2VuZXJhbCwgZm9sbG93aW5nIGhhcyBwZXJmb3JtYW5jZSBiZW5lZml0LlxuICAvLyBodHRwczovL2pzcGVyZi5jb20vcHJlY2lzaW9uLWNhbGN1bGF0aW9uXG4gIHJldHVybiB2LmluZGV4T2YoXCIuXCIpID49IDAgPyB2Lmxlbmd0aCAtIHYuaW5kZXhPZihcIi5cIikgLSAxIDogMDtcbn07XG52YXIgaW52ZXJzZVBvdyA9IGZ1bmN0aW9uIChuKSB7XG4gIC8vIHJlcGxhY2UgTWF0aC5wb3coMTAsIC1uKSB0byBzb2x2ZSBmbG9hdGluZyBwb2ludCBpc3N1ZS5cbiAgLy8gZWcuIE1hdGgucG93KDEwLCAtNCkgPT4gMC4wMDAwOTk5OTk5OTk5OTk5OTk5OVxuICByZXR1cm4gMSAvIE1hdGgucG93KDEwLCBuKTtcbn07XG52YXIgZ2V0Um91bmRGdW5jID0gZnVuY3Rpb24gKHYpIHtcbiAgdmFyIHAgPSB2IDwgMSA/IE1hdGgucG93KDEwLCBnZXREZWNpbWFsUGxhY2UodikpIDogMTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChuKSB7XG4gICAgaWYgKHYgPT09IDApIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5yb3VuZChNYXRoLnJvdW5kKG4gLyB2KSAqIHYgKiBwKSAvIHA7XG4gIH07XG59O1xudmFyIGdldEFuZ2xlID0gZnVuY3Rpb24gKHBvc1gsIHBvc1kpIHtcbiAgcmV0dXJuIE1hdGguYXRhbjIocG9zWSwgcG9zWCkgKiAxODAgLyBNYXRoLlBJO1xufTtcbnZhciBpc0Nzc1Byb3BzRnJvbUF4ZXMgPSBmdW5jdGlvbiAob3JpZ2luYWxDc3NQcm9wcykge1xuICB2YXIgc2FtZSA9IHRydWU7XG4gIE9iamVjdC5rZXlzKFBSRVZFTlRfRFJBR19DU1NQUk9QUykuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgIGlmICghb3JpZ2luYWxDc3NQcm9wcyB8fCBvcmlnaW5hbENzc1Byb3BzW3Byb3BdICE9PSBQUkVWRU5UX0RSQUdfQ1NTUFJPUFNbcHJvcF0pIHtcbiAgICAgIHNhbWUgPSBmYWxzZTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gc2FtZTtcbn07XG52YXIgZ2V0RGlyZWN0aW9uID0gZnVuY3Rpb24gKHVzZUhvcml6b250YWwsIHVzZVZlcnRpY2FsKSB7XG4gIGlmICh1c2VIb3Jpem9udGFsICYmIHVzZVZlcnRpY2FsKSB7XG4gICAgcmV0dXJuIERJUkVDVElPTl9BTEw7XG4gIH0gZWxzZSBpZiAodXNlSG9yaXpvbnRhbCkge1xuICAgIHJldHVybiBESVJFQ1RJT05fSE9SSVpPTlRBTDtcbiAgfSBlbHNlIGlmICh1c2VWZXJ0aWNhbCkge1xuICAgIHJldHVybiBESVJFQ1RJT05fVkVSVElDQUw7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIERJUkVDVElPTl9OT05FO1xuICB9XG59O1xudmFyIHVzZURpcmVjdGlvbiA9IGZ1bmN0aW9uIChjaGVja1R5cGUsIGRpcmVjdGlvbiwgdXNlckRpcmVjdGlvbikge1xuICBpZiAodXNlckRpcmVjdGlvbikge1xuICAgIHJldHVybiAhIShkaXJlY3Rpb24gPT09IERJUkVDVElPTl9BTEwgfHwgZGlyZWN0aW9uICYgY2hlY2tUeXBlICYmIHVzZXJEaXJlY3Rpb24gJiBjaGVja1R5cGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAhIShkaXJlY3Rpb24gJiBjaGVja1R5cGUpO1xuICB9XG59O1xudmFyIHNldENzc1Byb3BzID0gZnVuY3Rpb24gKGVsZW1lbnQsIG9wdGlvbiwgZGlyZWN0aW9uKSB7XG4gIHZhciBfYTtcbiAgdmFyIHRvdWNoQWN0aW9uTWFwID0gKF9hID0ge30sIF9hW0RJUkVDVElPTl9OT05FXSA9IFwiYXV0b1wiLCBfYVtESVJFQ1RJT05fQUxMXSA9IFwibm9uZVwiLCBfYVtESVJFQ1RJT05fVkVSVElDQUxdID0gXCJwYW4teFwiLCBfYVtESVJFQ1RJT05fSE9SSVpPTlRBTF0gPSBcInBhbi15XCIsIF9hKTtcbiAgdmFyIG9sZENzc1Byb3BzID0ge307XG4gIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuc3R5bGUpIHtcbiAgICB2YXIgdG91Y2hBY3Rpb24gPSBvcHRpb24udG91Y2hBY3Rpb24gPyBvcHRpb24udG91Y2hBY3Rpb24gOiB0b3VjaEFjdGlvbk1hcFtkaXJlY3Rpb25dO1xuICAgIHZhciBuZXdDc3NQcm9wc18xID0gX19hc3NpZ24oX19hc3NpZ24oe30sIFBSRVZFTlRfRFJBR19DU1NQUk9QUyksIHtcbiAgICAgIFwidG91Y2gtYWN0aW9uXCI6IGVsZW1lbnQuc3R5bGVbXCJ0b3VjaC1hY3Rpb25cIl0gPT09IFwibm9uZVwiID8gXCJub25lXCIgOiB0b3VjaEFjdGlvblxuICAgIH0pO1xuICAgIE9iamVjdC5rZXlzKG5ld0Nzc1Byb3BzXzEpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgIG9sZENzc1Byb3BzW3Byb3BdID0gZWxlbWVudC5zdHlsZVtwcm9wXTtcbiAgICB9KTtcbiAgICAvLyBPbGQgc3R5bGUgcHJvcHMgbGlrZSB1c2VyLXNlbGVjdCBjYW4gYmUgY29ycnVwdGVkIGlmIHlvdSBjaGFuZ2UgdGhlIHN0eWxlIGRpcmVjdGx5IGluIHRoZSBsb2dpYyBhYm92ZS5cbiAgICBPYmplY3Qua2V5cyhuZXdDc3NQcm9wc18xKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICBlbGVtZW50LnN0eWxlW3Byb3BdID0gbmV3Q3NzUHJvcHNfMVtwcm9wXTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gb2xkQ3NzUHJvcHM7XG59O1xudmFyIHJldmVydENzc1Byb3BzID0gZnVuY3Rpb24gKGVsZW1lbnQsIG9yaWdpbmFsQ3NzUHJvcHMpIHtcbiAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5zdHlsZSAmJiBvcmlnaW5hbENzc1Byb3BzKSB7XG4gICAgT2JqZWN0LmtleXMob3JpZ2luYWxDc3NQcm9wcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgZWxlbWVudC5zdHlsZVtwcm9wXSA9IG9yaWdpbmFsQ3NzUHJvcHNbcHJvcF07XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuO1xufTtcblxudmFyIEV2ZW50TWFuYWdlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEV2ZW50TWFuYWdlcihfYXhlcykge1xuICAgIHRoaXMuX2F4ZXMgPSBfYXhlcztcbiAgICB0aGlzLmhvbGRpbmdDb3VudCA9IDA7XG4gIH1cbiAgLyoqXG4gICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiBhIHVzZXIgaG9sZHMgYW4gZWxlbWVudCBvbiB0aGUgc2NyZWVuIG9mIHRoZSBkZXZpY2UuXG4gICAqIEBrbyDsgqzsmqnsnpDqsIAg6riw6riw7J2YIO2ZlOuptOyXkCDshpDsnYQg64yA6rOgIOyeiOydhCDrlYwg67Cc7IOd7ZWY64qUIOydtOuypO2KuFxuICAgKiBAZXZlbnQgQXhlcyNob2xkXG4gICAqIEB0eXBlIHtvYmplY3R9XG4gICAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsIG51bWJlcj59IHBvcyBjb29yZGluYXRlIDxrbz7sooztkZwg7KCV67O0PC9rbz5cbiAgICogQHByb3BlcnR5IHtPYmplY3R9IGlucHV0IFRoZSBpbnN0YW5jZSBvZiBpbnB1dFR5cGUgd2hlcmUgdGhlIGV2ZW50IG9jY3VycmVkPGtvPuydtOuypO2KuOqwgCDrsJzsg53tlZwgaW5wdXRUeXBlIOyduOyKpO2EtOyKpDwva28+XG4gICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBpbnB1dEV2ZW50IFRoZSBldmVudCBvYmplY3QgcmVjZWl2ZWQgZnJvbSBpbnB1dFR5cGUgPGtvPmlucHV0VHlwZeycvOuhnCDrtoDthLAg67Cb7J2AIOydtOuypO2KuCDqsJ3ssrQ8L2tvPlxuICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGlzVHJ1c3RlZCBSZXR1cm5zIHRydWUgaWYgYW4gZXZlbnQgd2FzIGdlbmVyYXRlZCBieSB0aGUgdXNlciBhY3Rpb24sIG9yIGZhbHNlIGlmIGl0IHdhcyBjYXVzZWQgYnkgYSBzY3JpcHQgb3IgQVBJIGNhbGwgPGtvPuyCrOyaqeyekOydmCDslaHshZjsl5Ag7J2Y7ZW0IOydtOuypO2KuOqwgCDrsJzsg53tlZjsmIDsnLzrqbQgdHJ1ZSwg7Iqk7YGs66a97Yq464KYIEFQSe2YuOy2nOyXkCDsnZjtlbQg67Cc7IOd7ZWY7JiA7J2EIOqyveyasOyXkOuKlCBmYWxzZeulvCDrsJjtmZjtlZzri6QuPC9rbz5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogY29uc3QgYXhlcyA9IG5ldyBlZy5BeGVzKHtcbiAgICogICBcInhcIjoge1xuICAgKiAgICAgIHJhbmdlOiBbMCwgMTAwXVxuICAgKiAgIH0sXG4gICAqICAgXCJ6b29tXCI6IHtcbiAgICogICAgICByYW5nZTogWzUwLCAzMF1cbiAgICogICB9XG4gICAqIH0pLm9uKFwiaG9sZFwiLCBmdW5jdGlvbihldmVudCkge1xuICAgKiAgIC8vIGV2ZW50LnBvc1xuICAgKiAgIC8vIGV2ZW50LmlucHV0XG4gICAqICAgLy8gZXZlbnQuaW5wdXRFdmVudFxuICAgKiAgIC8vIGlzVHJ1c3RlZFxuICAgKiB9KTtcbiAgICogYGBgXG4gICAqL1xuICB2YXIgX19wcm90byA9IEV2ZW50TWFuYWdlci5wcm90b3R5cGU7XG4gIF9fcHJvdG8uaG9sZCA9IGZ1bmN0aW9uIChwb3MsIG9wdGlvbikge1xuICAgIHZhciByb3VuZFBvcyA9IHRoaXMuX2dldFJvdW5kUG9zKHBvcykucm91bmRQb3M7XG4gICAgdGhpcy5fYXhlcy50cmlnZ2VyKG5ldyBDb21wb25lbnRFdmVudCQxKFwiaG9sZFwiLCB7XG4gICAgICBwb3M6IHJvdW5kUG9zLFxuICAgICAgaW5wdXQ6IG9wdGlvbi5pbnB1dCB8fCBudWxsLFxuICAgICAgaW5wdXRFdmVudDogb3B0aW9uLmV2ZW50IHx8IG51bGwsXG4gICAgICBpc1RydXN0ZWQ6IHRydWVcbiAgICB9KSk7XG4gIH07XG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgdGhlIGNvb3JkaW5hdGVzIHRvIG1vdmUgYWZ0ZXIgdGhlICdjaGFuZ2UnIGV2ZW50LiBJdCB3b3JrcyB3aGVuIHRoZSBob2xkaW5nIHZhbHVlIG9mIHRoZSBjaGFuZ2UgZXZlbnQgaXMgdHJ1ZS5cbiAgICogQGtvICdjaGFuZ2UnIOydtOuypO2KuCDsnbTtm4Qg7J2064+Z7ZWgIOyijO2RnOulvCDsp4DsoJXtlZzri6QuIGNoYW5nZeydtOuypO2KuOydmCBob2xkaW5nIOqwkuydtCB0cnVl7J28IOqyveyasOyXkCDrj5nsnpHtlZzri6RcbiAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgbnVtYmVyPn0gcG9zIFRoZSBjb29yZGluYXRlIHRvIG1vdmUgdG8gPGtvPuydtOuPme2VoCDsooztkZw8L2tvPlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBjb25zdCBheGVzID0gbmV3IGVnLkF4ZXMoe1xuICAgKiAgIFwieFwiOiB7XG4gICAqICAgICAgcmFuZ2U6IFswLCAxMDBdXG4gICAqICAgfSxcbiAgICogICBcInpvb21cIjoge1xuICAgKiAgICAgIHJhbmdlOiBbNTAsIDMwXVxuICAgKiAgIH1cbiAgICogfSkub24oXCJjaGFuZ2VcIiwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICogICBldmVudC5ob2xkaW5nICYmIGV2ZW50LnNldCh7eDogMTB9KTtcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKi9cbiAgLyoqIFNwZWNpZmllcyB0aGUgYW5pbWF0aW9uIGNvb3JkaW5hdGVzIHRvIG1vdmUgYWZ0ZXIgdGhlICdyZWxlYXNlJyBvciAnYW5pbWF0aW9uU3RhcnQnIGV2ZW50cy5cbiAgICogQGtvICdyZWxlYXNlJyDrmJDripQgJ2FuaW1hdGlvblN0YXJ0JyDsnbTrsqTtirgg7J207ZuEIOydtOuPme2VoCDsooztkZzrpbwg7KeA7KCV7ZWc64ukLlxuICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCBudW1iZXI+fSBwb3MgVGhlIGNvb3JkaW5hdGUgdG8gbW92ZSB0byA8a28+7J2064+Z7ZWgIOyijO2RnDwva28+XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZHVyYXRpb249MF0gRHVyYXRpb24gb2YgdGhlIGFuaW1hdGlvbiAodW5pdDogbXMpIDxrbz7slaDri4jrqZTsnbTshZgg7KeE7ZaJIOyLnOqwhCjri6jsnIQ6IG1zKTwva28+XG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IGF4ZXMgPSBuZXcgZWcuQXhlcyh7XG4gICAqICAgXCJ4XCI6IHtcbiAgICogICAgICByYW5nZTogWzAsIDEwMF1cbiAgICogICB9LFxuICAgKiAgIFwiem9vbVwiOiB7XG4gICAqICAgICAgcmFuZ2U6IFs1MCwgMzBdXG4gICAqICAgfVxuICAgKiB9KS5vbihcImFuaW1hdGlvblN0YXJ0XCIsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAqICAgZXZlbnQuc2V0VG8oe3g6IDEwfSwgMjAwMCk7XG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICovXG4gIC8qKlxuICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gYSB1c2VyIHJlbGVhc2UgYW4gZWxlbWVudCBvbiB0aGUgc2NyZWVuIG9mIHRoZSBkZXZpY2UuXG4gICAqIEBrbyDsgqzsmqnsnpDqsIAg6riw6riw7J2YIO2ZlOuptOyXkOyEnCDshpDsnYQg65eQ7J2EIOuVjCDrsJzsg53tlZjripQg7J2067Kk7Yq4XG4gICAqIEBldmVudCBBeGVzI3JlbGVhc2VcbiAgICogQHR5cGUge29iamVjdH1cbiAgICogQHByb3BlcnR5IHtPYmplY3QuPHN0cmluZywgbnVtYmVyPn0gZGVwYVBvcyBUaGUgY29vcmRpbmF0ZXMgd2hlbiByZWxlYXNpbmcgYW4gZWxlbWVudDxrbz7shpDsnYQg65eQ7J2EIOuVjOydmCDsooztkZwgPC9rbz5cbiAgICogQHByb3BlcnR5IHtPYmplY3QuPHN0cmluZywgbnVtYmVyPn0gZGVzdFBvcyBUaGUgY29vcmRpbmF0ZXMgdG8gbW92ZSB0byBhZnRlciByZWxlYXNpbmcgYW4gZWxlbWVudDxrbz7shpDsnYQg65eAIOuSpOyXkCDsnbTrj5ntlaAg7KKM7ZGcPC9rbz5cbiAgICogQHByb3BlcnR5IHtPYmplY3QuPHN0cmluZywgbnVtYmVyPn0gZGVsdGEgIFRoZSBtb3ZlbWVudCB2YXJpYXRpb24gb2YgY29vcmRpbmF0ZSA8a28+7KKM7ZGc7J2YIOuzgO2ZlOufiTwva28+XG4gICAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsIG51bWJlcj59IGJvdW5jZVJhdGlvIElmIHRoZSBjb29yZGluYXRlcyBhdCB0aGUgdGltZSBvZiByZWxlYXNlIGFyZSBpbiB0aGUgYm91bmNlIGFyZWEsIHRoZSBjdXJyZW50IGJvdW5jZSB2YWx1ZSBkaXZpZGVkIGJ5IHRoZSBtYXhpbXVtIGJvdW5jZSB2YWx1ZSA8a28+7IaQ7J2EIOuXkOydhCDrlYzsnZgg7KKM7ZGc6rCAIGJvdW5jZSDsmIHsl63sl5Ag7J6I64qUIOqyveyasCDtmITsnqwgYm91bmNl65CcIOqwkuydhCDstZzrjIAgYm91bmNlIOqwkuycvOuhnCDrgpjriIgg7IiY7LmYLjwva28+XG4gICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBpbnB1dEV2ZW50IFRoZSBldmVudCBvYmplY3QgcmVjZWl2ZWQgZnJvbSBpbnB1dFR5cGUgPGtvPmlucHV0VHlwZeycvOuhnCDrtoDthLAg67Cb7J2AIOydtOuypO2KuCDqsJ3ssrQ8L2tvPlxuICAgKiBAcHJvcGVydHkge09iamVjdH0gaW5wdXQgVGhlIGluc3RhbmNlIG9mIGlucHV0VHlwZSB3aGVyZSB0aGUgZXZlbnQgb2NjdXJyZWQ8a28+7J2067Kk7Yq46rCAIOuwnOyDne2VnCBpbnB1dFR5cGUg7J247Iqk7YS07IqkPC9rbz5cbiAgICogQHByb3BlcnR5IHtzZXRUb30gc2V0VG8gU3BlY2lmaWVzIHRoZSBhbmltYXRpb24gY29vcmRpbmF0ZXMgdG8gbW92ZSBhZnRlciB0aGUgZXZlbnQgPGtvPuydtOuypO2KuCDsnbTtm4Qg7J2064+Z7ZWgIOyVoOuLiOuplOydtOyFmCDsooztkZzrpbwg7KeA7KCV7ZWc64ukPC9rbz5cbiAgICogQHByb3BlcnR5IHtCb29sZWFufSBpc1RydXN0ZWQgUmV0dXJucyB0cnVlIGlmIGFuIGV2ZW50IHdhcyBnZW5lcmF0ZWQgYnkgdGhlIHVzZXIgYWN0aW9uLCBvciBmYWxzZSBpZiBpdCB3YXMgY2F1c2VkIGJ5IGEgc2NyaXB0IG9yIEFQSSBjYWxsIDxrbz7sgqzsmqnsnpDsnZgg7JWh7IWY7JeQIOydmO2VtCDsnbTrsqTtirjqsIAg67Cc7IOd7ZWY7JiA7Jy866m0IHRydWUsIOyKpO2BrOumve2KuOuCmCBBUEntmLjstpzsl5Ag7J2Y7ZW0IOuwnOyDne2VmOyYgOydhCDqsr3smrDsl5DripQgZmFsc2Xrpbwg67CY7ZmY7ZWc64ukLjwva28+XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IGF4ZXMgPSBuZXcgZWcuQXhlcyh7XG4gICAqICAgXCJ4XCI6IHtcbiAgICogICAgICByYW5nZTogWzAsIDEwMF1cbiAgICogICB9LFxuICAgKiAgIFwiem9vbVwiOiB7XG4gICAqICAgICAgcmFuZ2U6IFs1MCwgMzBdXG4gICAqICAgfVxuICAgKiB9KS5vbihcInJlbGVhc2VcIiwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICogICAvLyBldmVudC5kZXBhUG9zXG4gICAqICAgLy8gZXZlbnQuZGVzdFBvc1xuICAgKiAgIC8vIGV2ZW50LmRlbHRhXG4gICAqICAgLy8gZXZlbnQuaW5wdXRcbiAgICogICAvLyBldmVudC5pbnB1dEV2ZW50XG4gICAqICAgLy8gZXZlbnQuc2V0VG9cbiAgICogICAvLyBldmVudC5pc1RydXN0ZWRcbiAgICpcbiAgICogICAvLyBpZiB5b3Ugd2FudCB0byBjaGFuZ2UgdGhlIGFuaW1hdGlvbiBjb29yZGluYXRlcyB0byBtb3ZlIGFmdGVyIHRoZSAncmVsZWFzZScgZXZlbnQuXG4gICAqICAgZXZlbnQuc2V0VG8oe3g6IDEwfSwgMjAwMCk7XG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICovXG4gIF9fcHJvdG8udHJpZ2dlclJlbGVhc2UgPSBmdW5jdGlvbiAocGFyYW0pIHtcbiAgICB2YXIgX2EgPSB0aGlzLl9nZXRSb3VuZFBvcyhwYXJhbS5kZXN0UG9zLCBwYXJhbS5kZXBhUG9zKSxcbiAgICAgIHJvdW5kUG9zID0gX2Eucm91bmRQb3MsXG4gICAgICByb3VuZERlcGEgPSBfYS5yb3VuZERlcGE7XG4gICAgcGFyYW0uZGVzdFBvcyA9IHJvdW5kUG9zO1xuICAgIHBhcmFtLmRlcGFQb3MgPSByb3VuZERlcGE7XG4gICAgcGFyYW0uc2V0VG8gPSB0aGlzLl9jcmVhdGVVc2VyQ29udHJvbGwocGFyYW0uZGVzdFBvcywgcGFyYW0uZHVyYXRpb24pO1xuICAgIHRoaXMuX2F4ZXMudHJpZ2dlcihuZXcgQ29tcG9uZW50RXZlbnQkMShcInJlbGVhc2VcIiwgX19hc3NpZ24oX19hc3NpZ24oe30sIHBhcmFtKSwge1xuICAgICAgYm91bmNlUmF0aW86IHRoaXMuX2dldEJvdW5jZVJhdGlvKHJvdW5kUG9zKVxuICAgIH0pKSk7XG4gIH07XG4gIC8qKlxuICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gY29vcmRpbmF0ZSBjaGFuZ2VzLlxuICAgKiBAa28g7KKM7ZGc6rCAIOuzgOqyveuQkOydhCDrlYwg67Cc7IOd7ZWY64qUIOydtOuypO2KuFxuICAgKiBAZXZlbnQgQXhlcyNjaGFuZ2VcbiAgICogQHR5cGUge29iamVjdH1cbiAgICogQHByb3BlcnR5IHtPYmplY3QuPHN0cmluZywgbnVtYmVyPn0gcG9zICBUaGUgY29vcmRpbmF0ZSA8a28+7KKM7ZGcPC9rbz5cbiAgICogQHByb3BlcnR5IHtPYmplY3QuPHN0cmluZywgbnVtYmVyPn0gZGVsdGEgIFRoZSBtb3ZlbWVudCB2YXJpYXRpb24gb2YgY29vcmRpbmF0ZSA8a28+7KKM7ZGc7J2YIOuzgO2ZlOufiTwva28+XG4gICAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsIG51bWJlcj59IGJvdW5jZVJhdGlvIElmIHRoZSBjdXJyZW50IGNvb3JkaW5hdGVzIGFyZSBpbiB0aGUgYm91bmNlIGFyZWEsIHRoZSBjdXJyZW50IGJvdW5jZSB2YWx1ZSBkaXZpZGVkIGJ5IHRoZSBtYXhpbXVtIGJvdW5jZSB2YWx1ZSA8a28+7ZiE7J6sIOyijO2RnOqwgCBib3VuY2Ug7JiB7Jet7JeQIOyeiOuKlCDqsr3smrAg7ZiE7J6sIGJvdW5jZeuQnCDqsJLsnYQg7LWc64yAIGJvdW5jZSDqsJLsnLzroZwg64KY64iIIOyImOy5mC48L2tvPlxuICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGhvbGRpbmcgSW5kaWNhdGVzIHdoZXRoZXIgYSB1c2VyIGhvbGRzIGFuIGVsZW1lbnQgb24gdGhlIHNjcmVlbiBvZiB0aGUgZGV2aWNlLjxrbz7sgqzsmqnsnpDqsIAg6riw6riw7J2YIO2ZlOuptOydhCDriITrpbTqs6Ag7J6I64qU7KeAIOyXrOu2gDwva28+XG4gICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBpbnB1dCBUaGUgaW5zdGFuY2Ugb2YgaW5wdXRUeXBlIHdoZXJlIHRoZSBldmVudCBvY2N1cnJlZC4gSWYgdGhlIHZhbHVlIGlzIGNoYW5nZWQgYnkgYW5pbWF0aW9uLCBpdCByZXR1cm5zICdudWxsJy48a28+7J2067Kk7Yq46rCAIOuwnOyDne2VnCBpbnB1dFR5cGUg7J247Iqk7YS07IqkLiDslaDri4jrqZTsnbTshZjsl5Ag7J2Y7ZW0IOqwkuydtCDrs4Dqsr3rkKAg6rK97Jqw7JeQ64qUICdudWxsJ+ydhCDrsJjtmZjtlZzri6QuPC9rbz5cbiAgICogQHByb3BlcnR5IHtPYmplY3R9IGlucHV0RXZlbnQgVGhlIGV2ZW50IG9iamVjdCByZWNlaXZlZCBmcm9tIGlucHV0VHlwZS4gSWYgdGhlIHZhbHVlIGlzIGNoYW5nZWQgYnkgYW5pbWF0aW9uLCBpdCByZXR1cm5zICdudWxsJy48a28+aW5wdXRUeXBl7Jy866GcIOu2gO2EsCDrsJvsnYAg7J2067Kk7Yq4IOqwneyytC4g7JWg64uI66mU7J207IWY7JeQIOydmO2VtCDqsJLsnbQg67OA6rK965CgIOqyveyasOyXkOuKlCAnbnVsbCfsnYQg67CY7ZmY7ZWc64ukLjwva28+XG4gICAqIEBwcm9wZXJ0eSB7c2V0fSBzZXQgU3BlY2lmaWVzIHRoZSBjb29yZGluYXRlcyB0byBtb3ZlIGFmdGVyIHRoZSBldmVudC4gSXQgd29ya3Mgd2hlbiB0aGUgaG9sZGluZyB2YWx1ZSBpcyB0cnVlIDxrbz7snbTrsqTtirgg7J207ZuEIOydtOuPme2VoCDsooztkZzrpbwg7KeA7KCV7ZWc64ukLiBob2xkaW5nIOqwkuydtCB0cnVl7J28IOqyveyasOyXkCDrj5nsnpHtlZzri6QuPC9rbz5cbiAgICogQHByb3BlcnR5IHtCb29sZWFufSBpc1RydXN0ZWQgUmV0dXJucyB0cnVlIGlmIGFuIGV2ZW50IHdhcyBnZW5lcmF0ZWQgYnkgdGhlIHVzZXIgYWN0aW9uLCBvciBmYWxzZSBpZiBpdCB3YXMgY2F1c2VkIGJ5IGEgc2NyaXB0IG9yIEFQSSBjYWxsIDxrbz7sgqzsmqnsnpDsnZgg7JWh7IWY7JeQIOydmO2VtCDsnbTrsqTtirjqsIAg67Cc7IOd7ZWY7JiA7Jy866m0IHRydWUsIOyKpO2BrOumve2KuOuCmCBBUEntmLjstpzsl5Ag7J2Y7ZW0IOuwnOyDne2VmOyYgOydhCDqsr3smrDsl5DripQgZmFsc2Xrpbwg67CY7ZmY7ZWc64ukLjwva28+XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IGF4ZXMgPSBuZXcgZWcuQXhlcyh7XG4gICAqICAgXCJ4XCI6IHtcbiAgICogICAgICByYW5nZTogWzAsIDEwMF1cbiAgICogICB9LFxuICAgKiAgIFwiem9vbVwiOiB7XG4gICAqICAgICAgcmFuZ2U6IFs1MCwgMzBdXG4gICAqICAgfVxuICAgKiB9KS5vbihcImNoYW5nZVwiLCBmdW5jdGlvbihldmVudCkge1xuICAgKiAgIC8vIGV2ZW50LnBvc1xuICAgKiAgIC8vIGV2ZW50LmRlbHRhXG4gICAqICAgLy8gZXZlbnQuaW5wdXRcbiAgICogICAvLyBldmVudC5pbnB1dEV2ZW50XG4gICAqICAgLy8gZXZlbnQuaG9sZGluZ1xuICAgKiAgIC8vIGV2ZW50LnNldFxuICAgKiAgIC8vIGV2ZW50LmlzVHJ1c3RlZFxuICAgKlxuICAgKiAgIC8vIGlmIHlvdSB3YW50IHRvIGNoYW5nZSB0aGUgY29vcmRpbmF0ZXMgdG8gbW92ZSBhZnRlciB0aGUgJ2NoYW5nZScgZXZlbnQuXG4gICAqICAgLy8gaXQgd29ya3Mgd2hlbiB0aGUgaG9sZGluZyB2YWx1ZSBvZiB0aGUgY2hhbmdlIGV2ZW50IGlzIHRydWUuXG4gICAqICAgZXZlbnQuaG9sZGluZyAmJiBldmVudC5zZXQoe3g6IDEwfSk7XG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICovXG4gIF9fcHJvdG8udHJpZ2dlckNoYW5nZSA9IGZ1bmN0aW9uIChwb3MsIGRlcGFQb3MsIG9wdGlvbiwgaG9sZGluZykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgaWYgKGhvbGRpbmcgPT09IHZvaWQgMCkge1xuICAgICAgaG9sZGluZyA9IGZhbHNlO1xuICAgIH1cbiAgICB2YXIgYW5pbWF0aW9uTWFuYWdlciA9IHRoaXMuYW5pbWF0aW9uTWFuYWdlcjtcbiAgICB2YXIgYXhpc01hbmFnZXIgPSBhbmltYXRpb25NYW5hZ2VyLmF4aXNNYW5hZ2VyO1xuICAgIHZhciBldmVudEluZm8gPSBhbmltYXRpb25NYW5hZ2VyLmdldEV2ZW50SW5mbygpO1xuICAgIHZhciBfYSA9IHRoaXMuX2dldFJvdW5kUG9zKHBvcywgZGVwYVBvcyksXG4gICAgICByb3VuZFBvcyA9IF9hLnJvdW5kUG9zLFxuICAgICAgcm91bmREZXBhID0gX2Eucm91bmREZXBhO1xuICAgIHZhciBtb3ZlVG8gPSBheGlzTWFuYWdlci5tb3ZlVG8ocm91bmRQb3MsIHJvdW5kRGVwYSk7XG4gICAgdmFyIGlucHV0RXZlbnQgPSAob3B0aW9uID09PSBudWxsIHx8IG9wdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9uLmV2ZW50KSB8fCAoZXZlbnRJbmZvID09PSBudWxsIHx8IGV2ZW50SW5mbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXZlbnRJbmZvLmV2ZW50KSB8fCBudWxsO1xuICAgIHZhciBwYXJhbSA9IHtcbiAgICAgIHBvczogbW92ZVRvLnBvcyxcbiAgICAgIGRlbHRhOiBtb3ZlVG8uZGVsdGEsXG4gICAgICBib3VuY2VSYXRpbzogdGhpcy5fZ2V0Qm91bmNlUmF0aW8obW92ZVRvLnBvcyksXG4gICAgICBob2xkaW5nOiBob2xkaW5nLFxuICAgICAgaW5wdXRFdmVudDogaW5wdXRFdmVudCxcbiAgICAgIGlzVHJ1c3RlZDogISFpbnB1dEV2ZW50LFxuICAgICAgaW5wdXQ6IChvcHRpb24gPT09IG51bGwgfHwgb3B0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb24uaW5wdXQpIHx8IChldmVudEluZm8gPT09IG51bGwgfHwgZXZlbnRJbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBldmVudEluZm8uaW5wdXQpIHx8IG51bGwsXG4gICAgICBzZXQ6IGlucHV0RXZlbnQgPyB0aGlzLl9jcmVhdGVVc2VyQ29udHJvbGwobW92ZVRvLnBvcykgOiBmdW5jdGlvbiAoKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1lbXB0eS1mdW5jdGlvblxuICAgIH07XG5cbiAgICB2YXIgZXZlbnQgPSBuZXcgQ29tcG9uZW50RXZlbnQkMShcImNoYW5nZVwiLCBwYXJhbSk7XG4gICAgdGhpcy5fYXhlcy50cmlnZ2VyKGV2ZW50KTtcbiAgICBPYmplY3Qua2V5cyhtb3ZlVG8ucG9zKS5mb3JFYWNoKGZ1bmN0aW9uIChheGlzKSB7XG4gICAgICB2YXIgcCA9IG1vdmVUby5wb3NbYXhpc107XG4gICAgICBnZXRPYnNlcnZlcihfdGhpcy5fYXhlcywgYXhpcywgcCkuY3VycmVudCA9IHA7XG4gICAgfSk7XG4gICAgaWYgKGlucHV0RXZlbnQpIHtcbiAgICAgIGF4aXNNYW5hZ2VyLnNldChwYXJhbS5zZXQoKS5kZXN0UG9zKTtcbiAgICB9XG4gICAgcmV0dXJuICFldmVudC5pc0NhbmNlbGVkKCk7XG4gIH07XG4gIC8qKlxuICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gYW5pbWF0aW9uIHN0YXJ0cy5cbiAgICogQGtvIOyXkOuLiOuplOydtOyFmOydtCDsi5zsnpHtlaAg65WMIOuwnOyDne2VnOuLpC5cbiAgICogQGV2ZW50IEF4ZXMjYW5pbWF0aW9uU3RhcnRcbiAgICogQHR5cGUge29iamVjdH1cbiAgICogQHByb3BlcnR5IHtPYmplY3QuPHN0cmluZywgbnVtYmVyPn0gZGVwYVBvcyBUaGUgY29vcmRpbmF0ZXMgd2hlbiBhbmltYXRpb24gc3RhcnRzPGtvPuyVoOuLiOuplOydtOyFmOydtCDsi5zsnpEg65CY7JeI7J2EIOuVjOydmCDsooztkZwgPC9rbz5cbiAgICogQHByb3BlcnR5IHtPYmplY3QuPHN0cmluZywgbnVtYmVyPn0gZGVzdFBvcyBUaGUgY29vcmRpbmF0ZXMgdG8gbW92ZSB0by4gSWYgeW91IGNoYW5nZSB0aGlzIHZhbHVlLCB5b3UgY2FuIHJ1biB0aGUgYW5pbWF0aW9uPGtvPuydtOuPme2VoCDsooztkZwuIOydtOqwkuydhCDrs4Dqsr3tlZjsl6wg7JWg64uI66mU7J207IWY7J2EIOuPmeyekeyLnO2CrOyImCDsnojri6Q8L2tvPlxuICAgKiBAcHJvcGVydHkge09iamVjdC48c3RyaW5nLCBudW1iZXI+fSBkZWx0YSAgVGhlIG1vdmVtZW50IHZhcmlhdGlvbiBvZiBjb29yZGluYXRlIDxrbz7sooztkZzsnZgg67OA7ZmU65+JPC9rbz5cbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGR1cmF0aW9uIER1cmF0aW9uIG9mIHRoZSBhbmltYXRpb24gKHVuaXQ6IG1zKS4gSWYgeW91IGNoYW5nZSB0aGlzIHZhbHVlLCB5b3UgY2FuIGNvbnRyb2wgdGhlIGFuaW1hdGlvbiBkdXJhdGlvbiB0aW1lLjxrbz7slaDri4jrqZTsnbTshZgg7KeE7ZaJIOyLnOqwhCjri6jsnIQ6IG1zKS4g7J206rCS7J2EIOuzgOqyve2VmOyXrCDslaDri4jrqZTsnbTshZjsnZgg7J2064+Z7Iuc6rCE7J2EIOyhsOygiO2VoCDsiJgg7J6I64ukLjwva28+XG4gICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBpbnB1dCBUaGUgaW5zdGFuY2Ugb2YgaW5wdXRUeXBlIHdoZXJlIHRoZSBldmVudCBvY2N1cnJlZC4gSWYgdGhlIHZhbHVlIGlzIGNoYW5nZWQgYnkgYW5pbWF0aW9uLCBpdCByZXR1cm5zICdudWxsJy48a28+7J2067Kk7Yq46rCAIOuwnOyDne2VnCBpbnB1dFR5cGUg7J247Iqk7YS07IqkLiDslaDri4jrqZTsnbTshZjsl5Ag7J2Y7ZW0IOqwkuydtCDrs4Dqsr3rkKAg6rK97Jqw7JeQ64qUICdudWxsJ+ydhCDrsJjtmZjtlZzri6QuPC9rbz5cbiAgICogQHByb3BlcnR5IHtPYmplY3R9IGlucHV0RXZlbnQgVGhlIGV2ZW50IG9iamVjdCByZWNlaXZlZCBmcm9tIGlucHV0VHlwZSA8a28+aW5wdXRUeXBl7Jy866GcIOu2gO2EsCDrsJvsnYAg7J2067Kk7Yq4IOqwneyytDwva28+XG4gICAqIEBwcm9wZXJ0eSB7c2V0VG99IHNldFRvIFNwZWNpZmllcyB0aGUgYW5pbWF0aW9uIGNvb3JkaW5hdGVzIHRvIG1vdmUgYWZ0ZXIgdGhlIGV2ZW50IDxrbz7snbTrsqTtirgg7J207ZuEIOydtOuPme2VoCDslaDri4jrqZTsnbTshZgg7KKM7ZGc66W8IOyngOygle2VnOuLpDwva28+XG4gICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gaXNUcnVzdGVkIFJldHVybnMgdHJ1ZSBpZiBhbiBldmVudCB3YXMgZ2VuZXJhdGVkIGJ5IHRoZSB1c2VyIGFjdGlvbiwgb3IgZmFsc2UgaWYgaXQgd2FzIGNhdXNlZCBieSBhIHNjcmlwdCBvciBBUEkgY2FsbCA8a28+7IKs7Jqp7J6Q7J2YIOyVoeyFmOyXkCDsnZjtlbQg7J2067Kk7Yq46rCAIOuwnOyDne2VmOyYgOycvOuptCB0cnVlLCDsiqTtgazrpr3tirjrgpggQVBJ7Zi47Lac7JeQIOydmO2VtCDrsJzsg53tlZjsmIDsnYQg6rK97Jqw7JeQ64qUIGZhbHNl66W8IOuwmO2ZmO2VnOuLpC48L2tvPlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBjb25zdCBheGVzID0gbmV3IGVnLkF4ZXMoe1xuICAgKiAgIFwieFwiOiB7XG4gICAqICAgICAgcmFuZ2U6IFswLCAxMDBdXG4gICAqICAgfSxcbiAgICogICBcInpvb21cIjoge1xuICAgKiAgICAgIHJhbmdlOiBbNTAsIDMwXVxuICAgKiAgIH1cbiAgICogfSkub24oXCJyZWxlYXNlXCIsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAqICAgLy8gZXZlbnQuZGVwYVBvc1xuICAgKiAgIC8vIGV2ZW50LmRlc3RQb3NcbiAgICogICAvLyBldmVudC5kZWx0YVxuICAgKiAgIC8vIGV2ZW50LmlucHV0XG4gICAqICAgLy8gZXZlbnQuaW5wdXRFdmVudFxuICAgKiAgIC8vIGV2ZW50LnNldFRvXG4gICAqICAgLy8gZXZlbnQuaXNUcnVzdGVkXG4gICAqXG4gICAqICAgLy8gaWYgeW91IHdhbnQgdG8gY2hhbmdlIHRoZSBhbmltYXRpb24gY29vcmRpbmF0ZXMgdG8gbW92ZSBhZnRlciB0aGUgJ2FuaW1hdGlvblN0YXJ0JyBldmVudC5cbiAgICogICBldmVudC5zZXRUbyh7eDogMTB9LCAyMDAwKTtcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKi9cbiAgX19wcm90by50cmlnZ2VyQW5pbWF0aW9uU3RhcnQgPSBmdW5jdGlvbiAocGFyYW0pIHtcbiAgICB2YXIgX2EgPSB0aGlzLl9nZXRSb3VuZFBvcyhwYXJhbS5kZXN0UG9zLCBwYXJhbS5kZXBhUG9zKSxcbiAgICAgIHJvdW5kUG9zID0gX2Eucm91bmRQb3MsXG4gICAgICByb3VuZERlcGEgPSBfYS5yb3VuZERlcGE7XG4gICAgcGFyYW0uZGVzdFBvcyA9IHJvdW5kUG9zO1xuICAgIHBhcmFtLmRlcGFQb3MgPSByb3VuZERlcGE7XG4gICAgcGFyYW0uc2V0VG8gPSB0aGlzLl9jcmVhdGVVc2VyQ29udHJvbGwocGFyYW0uZGVzdFBvcywgcGFyYW0uZHVyYXRpb24pO1xuICAgIHZhciBldmVudCA9IG5ldyBDb21wb25lbnRFdmVudCQxKFwiYW5pbWF0aW9uU3RhcnRcIiwgcGFyYW0pO1xuICAgIHRoaXMuX2F4ZXMudHJpZ2dlcihldmVudCk7XG4gICAgcmV0dXJuICFldmVudC5pc0NhbmNlbGVkKCk7XG4gIH07XG4gIC8qKlxuICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gYW5pbWF0aW9uIGVuZHMuXG4gICAqIEBrbyDsl5Dri4jrqZTsnbTshZjsnbQg64Gd64Ks7J2EIOuVjCDrsJzsg53tlZzri6QuXG4gICAqIEBldmVudCBBeGVzI2FuaW1hdGlvbkVuZFxuICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGlzVHJ1c3RlZCBSZXR1cm5zIHRydWUgaWYgYW4gZXZlbnQgd2FzIGdlbmVyYXRlZCBieSB0aGUgdXNlciBhY3Rpb24sIG9yIGZhbHNlIGlmIGl0IHdhcyBjYXVzZWQgYnkgYSBzY3JpcHQgb3IgQVBJIGNhbGwgPGtvPuyCrOyaqeyekOydmCDslaHshZjsl5Ag7J2Y7ZW0IOydtOuypO2KuOqwgCDrsJzsg53tlZjsmIDsnLzrqbQgdHJ1ZSwg7Iqk7YGs66a97Yq464KYIEFQSe2YuOy2nOyXkCDsnZjtlbQg67Cc7IOd7ZWY7JiA7J2EIOqyveyasOyXkOuKlCBmYWxzZeulvCDrsJjtmZjtlZzri6QuPC9rbz5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogY29uc3QgYXhlcyA9IG5ldyBlZy5BeGVzKHtcbiAgICogICBcInhcIjoge1xuICAgKiAgICAgIHJhbmdlOiBbMCwgMTAwXVxuICAgKiAgIH0sXG4gICAqICAgXCJ6b29tXCI6IHtcbiAgICogICAgICByYW5nZTogWzUwLCAzMF1cbiAgICogICB9XG4gICAqIH0pLm9uKFwiYW5pbWF0aW9uRW5kXCIsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAqICAgLy8gZXZlbnQuaXNUcnVzdGVkXG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICovXG4gIF9fcHJvdG8udHJpZ2dlckFuaW1hdGlvbkVuZCA9IGZ1bmN0aW9uIChpc1RydXN0ZWQpIHtcbiAgICBpZiAoaXNUcnVzdGVkID09PSB2b2lkIDApIHtcbiAgICAgIGlzVHJ1c3RlZCA9IGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLl9heGVzLnRyaWdnZXIobmV3IENvbXBvbmVudEV2ZW50JDEoXCJhbmltYXRpb25FbmRcIiwge1xuICAgICAgaXNUcnVzdGVkOiBpc1RydXN0ZWRcbiAgICB9KSk7XG4gIH07XG4gIC8qKlxuICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gYWxsIGFjdGlvbnMgaGF2ZSBiZWVuIGNvbXBsZXRlZC5cbiAgICogQGtvIOyXkOuLiOuplOydtOyFmOydtCDrgZ3rgqzsnYQg65WMIOuwnOyDne2VnOuLpC5cbiAgICogQGV2ZW50IEF4ZXMjZmluaXNoXG4gICAqIEB0eXBlIHtvYmplY3R9XG4gICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gaXNUcnVzdGVkIFJldHVybnMgdHJ1ZSBpZiBhbiBldmVudCB3YXMgZ2VuZXJhdGVkIGJ5IHRoZSB1c2VyIGFjdGlvbiwgb3IgZmFsc2UgaWYgaXQgd2FzIGNhdXNlZCBieSBhIHNjcmlwdCBvciBBUEkgY2FsbCA8a28+7IKs7Jqp7J6Q7J2YIOyVoeyFmOyXkCDsnZjtlbQg7J2067Kk7Yq46rCAIOuwnOyDne2VmOyYgOycvOuptCB0cnVlLCDsiqTtgazrpr3tirjrgpggQVBJ7Zi47Lac7JeQIOydmO2VtCDrsJzsg53tlZjsmIDsnYQg6rK97Jqw7JeQ64qUIGZhbHNl66W8IOuwmO2ZmO2VnOuLpC48L2tvPlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBjb25zdCBheGVzID0gbmV3IGVnLkF4ZXMoe1xuICAgKiAgIFwieFwiOiB7XG4gICAqICAgICAgcmFuZ2U6IFswLCAxMDBdXG4gICAqICAgfSxcbiAgICogICBcInpvb21cIjoge1xuICAgKiAgICAgIHJhbmdlOiBbNTAsIDMwXVxuICAgKiAgIH1cbiAgICogfSkub24oXCJmaW5pc2hcIiwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICogICAvLyBldmVudC5pc1RydXN0ZWRcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKi9cbiAgX19wcm90by50cmlnZ2VyRmluaXNoID0gZnVuY3Rpb24gKGlzVHJ1c3RlZCkge1xuICAgIGlmIChpc1RydXN0ZWQgPT09IHZvaWQgMCkge1xuICAgICAgaXNUcnVzdGVkID0gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuX2F4ZXMudHJpZ2dlcihuZXcgQ29tcG9uZW50RXZlbnQkMShcImZpbmlzaFwiLCB7XG4gICAgICBpc1RydXN0ZWQ6IGlzVHJ1c3RlZFxuICAgIH0pKTtcbiAgfTtcbiAgX19wcm90by5zZXRBbmltYXRpb25NYW5hZ2VyID0gZnVuY3Rpb24gKGFuaW1hdGlvbk1hbmFnZXIpIHtcbiAgICB0aGlzLmFuaW1hdGlvbk1hbmFnZXIgPSBhbmltYXRpb25NYW5hZ2VyO1xuICB9O1xuICBfX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fYXhlcy5vZmYoKTtcbiAgfTtcbiAgX19wcm90by5fY3JlYXRlVXNlckNvbnRyb2xsID0gZnVuY3Rpb24gKHBvcywgZHVyYXRpb24pIHtcbiAgICBpZiAoZHVyYXRpb24gPT09IHZvaWQgMCkge1xuICAgICAgZHVyYXRpb24gPSAwO1xuICAgIH1cbiAgICAvLyB0byBjb250cm9sbFxuICAgIHZhciB1c2VyQ29udHJvbCA9IHtcbiAgICAgIGRlc3RQb3M6IF9fYXNzaWduKHt9LCBwb3MpLFxuICAgICAgZHVyYXRpb246IGR1cmF0aW9uXG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRvUG9zLCB1c2VyRHVyYXRpb24pIHtcbiAgICAgIGlmICh0b1Bvcykge1xuICAgICAgICB1c2VyQ29udHJvbC5kZXN0UG9zID0gX19hc3NpZ24oe30sIHRvUG9zKTtcbiAgICAgIH1cbiAgICAgIGlmICh1c2VyRHVyYXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB1c2VyQ29udHJvbC5kdXJhdGlvbiA9IHVzZXJEdXJhdGlvbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB1c2VyQ29udHJvbDtcbiAgICB9O1xuICB9O1xuICBfX3Byb3RvLl9nZXRSb3VuZFBvcyA9IGZ1bmN0aW9uIChwb3MsIGRlcGFQb3MpIHtcbiAgICAvLyByb3VuZCB2YWx1ZSBpZiByb3VuZCBleGlzdFxuICAgIHZhciByb3VuZFVuaXQgPSB0aGlzLl9heGVzLm9wdGlvbnMucm91bmQ7XG4gICAgLy8gaWYgKHJvdW5kID09IG51bGwpIHtcbiAgICAvLyAgIHJldHVybiB7cG9zLCBkZXBhUG9zfTsgLy8gdW5kZWZpbmVkLCB1bmRlZmluZWRcbiAgICAvLyB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvdW5kUG9zOiByb3VuZE51bWJlcnMocG9zLCByb3VuZFVuaXQpLFxuICAgICAgcm91bmREZXBhOiByb3VuZE51bWJlcnMoZGVwYVBvcywgcm91bmRVbml0KVxuICAgIH07XG4gIH07XG4gIF9fcHJvdG8uX2dldEJvdW5jZVJhdGlvID0gZnVuY3Rpb24gKHBvcykge1xuICAgIHJldHVybiB0aGlzLl9heGVzLmF4aXNNYW5hZ2VyLm1hcChwb3MsIGZ1bmN0aW9uICh2LCBvcHQpIHtcbiAgICAgIGlmICh2IDwgb3B0LnJhbmdlWzBdICYmIG9wdC5ib3VuY2VbMF0gIT09IDApIHtcbiAgICAgICAgcmV0dXJuIChvcHQucmFuZ2VbMF0gLSB2KSAvIG9wdC5ib3VuY2VbMF07XG4gICAgICB9IGVsc2UgaWYgKHYgPiBvcHQucmFuZ2VbMV0gJiYgb3B0LmJvdW5jZVsxXSAhPT0gMCkge1xuICAgICAgICByZXR1cm4gKHYgLSBvcHQucmFuZ2VbMV0pIC8gb3B0LmJvdW5jZVsxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICBfX2RlY29yYXRlKFtPYnNlcnZlXSwgRXZlbnRNYW5hZ2VyLnByb3RvdHlwZSwgXCJob2xkaW5nQ291bnRcIiwgdm9pZCAwKTtcbiAgcmV0dXJuIEV2ZW50TWFuYWdlcjtcbn0oKTtcblxudmFyIEludGVycnVwdE1hbmFnZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBJbnRlcnJ1cHRNYW5hZ2VyKF9vcHRpb25zKSB7XG4gICAgdGhpcy5fb3B0aW9ucyA9IF9vcHRpb25zO1xuICAgIHRoaXMuX3ByZXZlbnRlZCA9IGZhbHNlOyAvLyAgY2hlY2sgd2hldGhlciB0aGUgYW5pbWF0aW9uIGV2ZW50IHdhcyBwcmV2ZW50ZWRcbiAgfVxuICB2YXIgX19wcm90byA9IEludGVycnVwdE1hbmFnZXIucHJvdG90eXBlO1xuICBfX3Byb3RvLmlzSW50ZXJydXB0aW5nID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIHdoZW4gaW50ZXJydXB0YWJsZSBpcyAndHJ1ZScsIHJldHVybiB2YWx1ZSBpcyBhbHdheXMgJ3RydWUnLlxuICAgIHJldHVybiB0aGlzLl9vcHRpb25zLmludGVycnVwdGFibGUgfHwgdGhpcy5fcHJldmVudGVkO1xuICB9O1xuICBfX3Byb3RvLmlzSW50ZXJydXB0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICF0aGlzLl9vcHRpb25zLmludGVycnVwdGFibGUgJiYgdGhpcy5fcHJldmVudGVkO1xuICB9O1xuICBfX3Byb3RvLnNldEludGVycnVwdCA9IGZ1bmN0aW9uIChwcmV2ZW50ZWQpIHtcbiAgICBpZiAoIXRoaXMuX29wdGlvbnMuaW50ZXJydXB0YWJsZSkge1xuICAgICAgdGhpcy5fcHJldmVudGVkID0gcHJldmVudGVkO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIEludGVycnVwdE1hbmFnZXI7XG59KCk7XG5cbi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgTkFWRVIgQ29ycC5cbiAqIGVnanMgcHJvamVjdHMgYXJlIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG52YXIgZ2V0SW5zaWRlUG9zaXRpb24gPSBmdW5jdGlvbiAoZGVzdFBvcywgcmFuZ2UsIGNpcmN1bGFyLCBib3VuY2UpIHtcbiAgdmFyIHRvRGVzdFBvcyA9IGRlc3RQb3M7XG4gIHZhciB0YXJnZXRSYW5nZSA9IFtjaXJjdWxhclswXSA/IHJhbmdlWzBdIDogYm91bmNlID8gcmFuZ2VbMF0gLSBib3VuY2VbMF0gOiByYW5nZVswXSwgY2lyY3VsYXJbMV0gPyByYW5nZVsxXSA6IGJvdW5jZSA/IHJhbmdlWzFdICsgYm91bmNlWzFdIDogcmFuZ2VbMV1dO1xuICB0b0Rlc3RQb3MgPSBNYXRoLm1heCh0YXJnZXRSYW5nZVswXSwgdG9EZXN0UG9zKTtcbiAgdG9EZXN0UG9zID0gTWF0aC5taW4odGFyZ2V0UmFuZ2VbMV0sIHRvRGVzdFBvcyk7XG4gIHJldHVybiB0b0Rlc3RQb3M7XG59O1xuLy8gZGV0ZXJtaW5lIG91dHNpZGVcbnZhciBpc091dHNpZGUgPSBmdW5jdGlvbiAocG9zLCByYW5nZSkge1xuICByZXR1cm4gcG9zIDwgcmFuZ2VbMF0gfHwgcG9zID4gcmFuZ2VbMV07XG59O1xuLy8gZGV0ZXJtaW5lIHdoZXRoZXIgcG9zaXRpb24gaGFzIHJlYWNoZWQgdGhlIG1heGltdW0gbW92ZWFibGUgYXJlYVxudmFyIGlzRW5kb2ZCb3VuY2UgPSBmdW5jdGlvbiAocG9zLCByYW5nZSwgYm91bmNlLCBjaXJjdWxhcikge1xuICByZXR1cm4gIWNpcmN1bGFyWzBdICYmIHBvcyA9PT0gcmFuZ2VbMF0gLSBib3VuY2VbMF0gfHwgIWNpcmN1bGFyWzFdICYmIHBvcyA9PT0gcmFuZ2VbMV0gKyBib3VuY2VbMV07XG59O1xudmFyIGdldER1cmF0aW9uID0gZnVuY3Rpb24gKGRpc3RhbmNlLCBkZWNlbGVyYXRpb24pIHtcbiAgdmFyIGR1cmF0aW9uID0gTWF0aC5zcXJ0KGRpc3RhbmNlIC8gZGVjZWxlcmF0aW9uICogMik7XG4gIC8vIHdoZW4gZHVyYXRpb24gaXMgdW5kZXIgMTAwLCB0aGVuIHZhbHVlIGlzIHplcm9cbiAgcmV0dXJuIGR1cmF0aW9uIDwgMTAwID8gMCA6IGR1cmF0aW9uO1xufTtcbnZhciBpc0NpcmN1bGFyYWJsZSA9IGZ1bmN0aW9uIChkZXN0UG9zLCByYW5nZSwgY2lyY3VsYXIpIHtcbiAgcmV0dXJuIGNpcmN1bGFyWzFdICYmIGRlc3RQb3MgPiByYW5nZVsxXSB8fCBjaXJjdWxhclswXSAmJiBkZXN0UG9zIDwgcmFuZ2VbMF07XG59O1xudmFyIGdldENpcmN1bGF0ZWRQb3MgPSBmdW5jdGlvbiAocG9zLCByYW5nZSwgY2lyY3VsYXIpIHtcbiAgdmFyIHRvUG9zID0gcG9zO1xuICB2YXIgbWluID0gcmFuZ2VbMF07XG4gIHZhciBtYXggPSByYW5nZVsxXTtcbiAgdmFyIGxlbmd0aCA9IG1heCAtIG1pbjtcbiAgaWYgKGNpcmN1bGFyWzFdICYmIHBvcyA+IG1heCkge1xuICAgIC8vIHJpZ2h0XG4gICAgdG9Qb3MgPSAodG9Qb3MgLSBtYXgpICUgbGVuZ3RoICsgbWluO1xuICB9XG4gIGlmIChjaXJjdWxhclswXSAmJiBwb3MgPCBtaW4pIHtcbiAgICAvLyBsZWZ0XG4gICAgdG9Qb3MgPSAodG9Qb3MgLSBtaW4pICUgbGVuZ3RoICsgbWF4O1xuICB9XG4gIHJldHVybiB0b1Bvcztcbn07XG5cbnZhciBBeGlzTWFuYWdlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEF4aXNNYW5hZ2VyKF9heGlzKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB0aGlzLl9heGlzID0gX2F4aXM7XG4gICAgdGhpcy5fY29tcGxlbWVudE9wdGlvbnMoKTtcbiAgICB0aGlzLl9wb3MgPSBPYmplY3Qua2V5cyh0aGlzLl9heGlzKS5yZWR1Y2UoZnVuY3Rpb24gKHBvcywgdikge1xuICAgICAgcG9zW3ZdID0gX3RoaXMuX2F4aXNbdl0uc3RhcnRQb3M7XG4gICAgICByZXR1cm4gcG9zO1xuICAgIH0sIHt9KTtcbiAgfVxuICB2YXIgX19wcm90byA9IEF4aXNNYW5hZ2VyLnByb3RvdHlwZTtcbiAgX19wcm90by5nZXREZWx0YSA9IGZ1bmN0aW9uIChkZXBhUG9zLCBkZXN0UG9zKSB7XG4gICAgdmFyIGZ1bGxEZXBhUG9zID0gdGhpcy5nZXQoZGVwYVBvcyk7XG4gICAgcmV0dXJuIG1hcCh0aGlzLmdldChkZXN0UG9zKSwgZnVuY3Rpb24gKHYsIGspIHtcbiAgICAgIHJldHVybiB2IC0gZnVsbERlcGFQb3Nba107XG4gICAgfSk7XG4gIH07XG4gIF9fcHJvdG8uZ2V0ID0gZnVuY3Rpb24gKGF4ZXMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIGlmIChheGVzICYmIEFycmF5LmlzQXJyYXkoYXhlcykpIHtcbiAgICAgIHJldHVybiBheGVzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCB2KSB7XG4gICAgICAgIGlmICh2ICYmIHYgaW4gX3RoaXMuX3Bvcykge1xuICAgICAgICAgIGFjY1t2XSA9IF90aGlzLl9wb3Nbdl07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH0sIHt9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCB0aGlzLl9wb3MpLCBheGVzIHx8IHt9KTtcbiAgICB9XG4gIH07XG4gIF9fcHJvdG8ubW92ZVRvID0gZnVuY3Rpb24gKHBvcywgZGVwYVBvcykge1xuICAgIGlmIChkZXBhUG9zID09PSB2b2lkIDApIHtcbiAgICAgIGRlcGFQb3MgPSB0aGlzLl9wb3M7XG4gICAgfVxuICAgIHZhciBkZWx0YSA9IG1hcCh0aGlzLl9wb3MsIGZ1bmN0aW9uICh2LCBrZXkpIHtcbiAgICAgIHJldHVybiBrZXkgaW4gcG9zICYmIGtleSBpbiBkZXBhUG9zID8gcG9zW2tleV0gLSBkZXBhUG9zW2tleV0gOiAwO1xuICAgIH0pO1xuICAgIHRoaXMuc2V0KHRoaXMubWFwKHBvcywgZnVuY3Rpb24gKHYsIG9wdCkge1xuICAgICAgcmV0dXJuIG9wdCA/IGdldENpcmN1bGF0ZWRQb3Modiwgb3B0LnJhbmdlLCBvcHQuY2lyY3VsYXIpIDogMDtcbiAgICB9KSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvczogX19hc3NpZ24oe30sIHRoaXMuX3BvcyksXG4gICAgICBkZWx0YTogZGVsdGFcbiAgICB9O1xuICB9O1xuICBfX3Byb3RvLnNldCA9IGZ1bmN0aW9uIChwb3MpIHtcbiAgICBmb3IgKHZhciBrIGluIHBvcykge1xuICAgICAgaWYgKGsgJiYgayBpbiB0aGlzLl9wb3MpIHtcbiAgICAgICAgdGhpcy5fcG9zW2tdID0gcG9zW2tdO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgX19wcm90by5ldmVyeSA9IGZ1bmN0aW9uIChwb3MsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGF4aXNPcHRpb25zID0gdGhpcy5fYXhpcztcbiAgICByZXR1cm4gZXZlcnkocG9zLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKHZhbHVlLCBheGlzT3B0aW9uc1trZXldLCBrZXkpO1xuICAgIH0pO1xuICB9O1xuICBfX3Byb3RvLmZpbHRlciA9IGZ1bmN0aW9uIChwb3MsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGF4aXNPcHRpb25zID0gdGhpcy5fYXhpcztcbiAgICByZXR1cm4gZmlsdGVyKHBvcywgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayh2YWx1ZSwgYXhpc09wdGlvbnNba2V5XSwga2V5KTtcbiAgICB9KTtcbiAgfTtcbiAgX19wcm90by5tYXAgPSBmdW5jdGlvbiAocG9zLCBjYWxsYmFjaykge1xuICAgIHZhciBheGlzT3B0aW9ucyA9IHRoaXMuX2F4aXM7XG4gICAgcmV0dXJuIG1hcChwb3MsIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2sodmFsdWUsIGF4aXNPcHRpb25zW2tleV0sIGtleSk7XG4gICAgfSk7XG4gIH07XG4gIF9fcHJvdG8uaXNPdXRzaWRlID0gZnVuY3Rpb24gKGF4ZXMpIHtcbiAgICByZXR1cm4gIXRoaXMuZXZlcnkoYXhlcyA/IHRoaXMuZ2V0KGF4ZXMpIDogdGhpcy5fcG9zLCBmdW5jdGlvbiAodiwgb3B0KSB7XG4gICAgICByZXR1cm4gIWlzT3V0c2lkZSh2LCBvcHQucmFuZ2UpO1xuICAgIH0pO1xuICB9O1xuICBfX3Byb3RvLmdldEF4aXNPcHRpb25zID0gZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiB0aGlzLl9heGlzW2tleV07XG4gIH07XG4gIF9fcHJvdG8uc2V0QXhpcyA9IGZ1bmN0aW9uIChheGlzKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBPYmplY3Qua2V5cyhheGlzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGlmICghX3RoaXMuX2F4aXNba2V5XSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBeGlzIFwiLmNvbmNhdChrZXksIFwiIGRvZXMgbm90IGV4aXN0IGluIEF4ZXMgaW5zdGFuY2VcIikpO1xuICAgICAgfVxuICAgICAgX3RoaXMuX2F4aXNba2V5XSA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBfdGhpcy5fYXhpc1trZXldKSwgYXhpc1trZXldKTtcbiAgICB9KTtcbiAgICB0aGlzLl9jb21wbGVtZW50T3B0aW9ucygpO1xuICB9O1xuICAvKipcbiAgICogc2V0IHVwICdjc3MnIGV4cHJlc3Npb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9fcHJvdG8uX2NvbXBsZW1lbnRPcHRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgT2JqZWN0LmtleXModGhpcy5fYXhpcykuZm9yRWFjaChmdW5jdGlvbiAoYXhpcykge1xuICAgICAgX3RoaXMuX2F4aXNbYXhpc10gPSBfX2Fzc2lnbih7XG4gICAgICAgIHJhbmdlOiBbMCwgMTAwXSxcbiAgICAgICAgc3RhcnRQb3M6IF90aGlzLl9heGlzW2F4aXNdLnJhbmdlWzBdLFxuICAgICAgICBib3VuY2U6IFswLCAwXSxcbiAgICAgICAgY2lyY3VsYXI6IFtmYWxzZSwgZmFsc2VdXG4gICAgICB9LCBfdGhpcy5fYXhpc1theGlzXSk7XG4gICAgICBbXCJib3VuY2VcIiwgXCJjaXJjdWxhclwiXS5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHZhciBheGlzT3B0aW9uID0gX3RoaXMuX2F4aXM7XG4gICAgICAgIHZhciBrZXkgPSBheGlzT3B0aW9uW2F4aXNdW3ZdO1xuICAgICAgICBpZiAoL3N0cmluZ3xudW1iZXJ8Ym9vbGVhbi8udGVzdCh0eXBlb2Yga2V5KSkge1xuICAgICAgICAgIGF4aXNPcHRpb25bYXhpc11bdl0gPSBba2V5LCBrZXldO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbiAgcmV0dXJuIEF4aXNNYW5hZ2VyO1xufSgpO1xuXG52YXIgU1VQUE9SVF9UT1VDSCA9IChcIm9udG91Y2hzdGFydFwiIGluIHdpbik7XG52YXIgU1VQUE9SVF9QT0lOVEVSID0gKFwiUG9pbnRlckV2ZW50XCIgaW4gd2luKTtcbnZhciBTVVBQT1JUX01TUE9JTlRFUiA9IChcIk1TUG9pbnRlckV2ZW50XCIgaW4gd2luKTtcbnZhciBTVVBQT1JUX1BPSU5URVJfRVZFTlRTID0gU1VQUE9SVF9QT0lOVEVSIHx8IFNVUFBPUlRfTVNQT0lOVEVSO1xudmFyIGlzVmFsaWRLZXkgPSBmdW5jdGlvbiAoZXZlbnQsIGlucHV0S2V5KSB7XG4gIGlmICghaW5wdXRLZXkgfHwgaW5wdXRLZXkuaW5kZXhPZihBTlkpID4gLTEgfHwgaW5wdXRLZXkuaW5kZXhPZihOT05FKSA+IC0xICYmICFldmVudC5zaGlmdEtleSAmJiAhZXZlbnQuY3RybEtleSAmJiAhZXZlbnQuYWx0S2V5ICYmICFldmVudC5tZXRhS2V5IHx8IGlucHV0S2V5LmluZGV4T2YoU0hJRlQpID4gLTEgJiYgZXZlbnQuc2hpZnRLZXkgfHwgaW5wdXRLZXkuaW5kZXhPZihDVFJMKSA+IC0xICYmIGV2ZW50LmN0cmxLZXkgfHwgaW5wdXRLZXkuaW5kZXhPZihBTFQpID4gLTEgJiYgZXZlbnQuYWx0S2V5IHx8IGlucHV0S2V5LmluZGV4T2YoTUVUQSkgPiAtMSAmJiBldmVudC5tZXRhS2V5KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcbnZhciBFdmVudElucHV0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRXZlbnRJbnB1dCgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHRoaXMuX3N0b3BDb250ZXh0TWVudSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHdpbi5yZW1vdmVFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgX3RoaXMuX3N0b3BDb250ZXh0TWVudSk7XG4gICAgfTtcbiAgfVxuICB2YXIgX19wcm90byA9IEV2ZW50SW5wdXQucHJvdG90eXBlO1xuICBfX3Byb3RvLmV4dGVuZEV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIF9hO1xuICAgIHZhciBwcmV2RXZlbnQgPSB0aGlzLnByZXZFdmVudDtcbiAgICB2YXIgY2VudGVyID0gdGhpcy5fZ2V0Q2VudGVyKGV2ZW50KTtcbiAgICB2YXIgbW92ZW1lbnQgPSBwcmV2RXZlbnQgPyB0aGlzLl9nZXRNb3ZlbWVudChldmVudCkgOiB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMFxuICAgIH07XG4gICAgdmFyIHNjYWxlID0gcHJldkV2ZW50ID8gdGhpcy5fZ2V0U2NhbGUoZXZlbnQpIDogMTtcbiAgICB2YXIgYW5nbGUgPSBwcmV2RXZlbnQgPyBnZXRBbmdsZShjZW50ZXIueCAtIHByZXZFdmVudC5jZW50ZXIueCwgY2VudGVyLnkgLSBwcmV2RXZlbnQuY2VudGVyLnkpIDogMDtcbiAgICB2YXIgZGVsdGFYID0gcHJldkV2ZW50ID8gcHJldkV2ZW50LmRlbHRhWCArIG1vdmVtZW50LnggOiBtb3ZlbWVudC54O1xuICAgIHZhciBkZWx0YVkgPSBwcmV2RXZlbnQgPyBwcmV2RXZlbnQuZGVsdGFZICsgbW92ZW1lbnQueSA6IG1vdmVtZW50Lnk7XG4gICAgdmFyIG9mZnNldFggPSBtb3ZlbWVudC54O1xuICAgIHZhciBvZmZzZXRZID0gbW92ZW1lbnQueTtcbiAgICB2YXIgbGF0ZXN0SW50ZXJ2YWwgPSB0aGlzLl9sYXRlc3RJbnRlcnZhbDtcbiAgICB2YXIgdGltZVN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICB2YXIgZGVsdGFUaW1lID0gbGF0ZXN0SW50ZXJ2YWwgPyB0aW1lU3RhbXAgLSBsYXRlc3RJbnRlcnZhbC50aW1lc3RhbXAgOiAwO1xuICAgIHZhciB2ZWxvY2l0eVggPSBwcmV2RXZlbnQgPyBwcmV2RXZlbnQudmVsb2NpdHlYIDogMDtcbiAgICB2YXIgdmVsb2NpdHlZID0gcHJldkV2ZW50ID8gcHJldkV2ZW50LnZlbG9jaXR5WSA6IDA7XG4gICAgaWYgKCFsYXRlc3RJbnRlcnZhbCB8fCBkZWx0YVRpbWUgPj0gVkVMT0NJVFlfSU5URVJWQUwpIHtcbiAgICAgIGlmIChsYXRlc3RJbnRlcnZhbCkge1xuICAgICAgICBfYSA9IFsoZGVsdGFYIC0gbGF0ZXN0SW50ZXJ2YWwuZGVsdGFYKSAvIGRlbHRhVGltZSwgKGRlbHRhWSAtIGxhdGVzdEludGVydmFsLmRlbHRhWSkgLyBkZWx0YVRpbWVdLCB2ZWxvY2l0eVggPSBfYVswXSwgdmVsb2NpdHlZID0gX2FbMV07XG4gICAgICB9XG4gICAgICB0aGlzLl9sYXRlc3RJbnRlcnZhbCA9IHtcbiAgICAgICAgdGltZXN0YW1wOiB0aW1lU3RhbXAsXG4gICAgICAgIGRlbHRhWDogZGVsdGFYLFxuICAgICAgICBkZWx0YVk6IGRlbHRhWVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHNyY0V2ZW50OiBldmVudCxcbiAgICAgIHNjYWxlOiBzY2FsZSxcbiAgICAgIGFuZ2xlOiBhbmdsZSxcbiAgICAgIGNlbnRlcjogY2VudGVyLFxuICAgICAgZGVsdGFYOiBkZWx0YVgsXG4gICAgICBkZWx0YVk6IGRlbHRhWSxcbiAgICAgIG9mZnNldFg6IG9mZnNldFgsXG4gICAgICBvZmZzZXRZOiBvZmZzZXRZLFxuICAgICAgdmVsb2NpdHlYOiB2ZWxvY2l0eVgsXG4gICAgICB2ZWxvY2l0eVk6IHZlbG9jaXR5WSxcbiAgICAgIHByZXZlbnRTeXN0ZW1FdmVudDogdHJ1ZVxuICAgIH07XG4gIH07XG4gIF9fcHJvdG8uX2dldERpc3RhbmNlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgeCA9IGVuZC5jbGllbnRYIC0gc3RhcnQuY2xpZW50WDtcbiAgICB2YXIgeSA9IGVuZC5jbGllbnRZIC0gc3RhcnQuY2xpZW50WTtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xuICB9O1xuICBfX3Byb3RvLl9nZXRCdXR0b24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgYnV0dG9uQ29kZU1hcCA9IHtcbiAgICAgIDE6IE1PVVNFX0xFRlQsXG4gICAgICAyOiBNT1VTRV9SSUdIVCxcbiAgICAgIDQ6IE1PVVNFX01JRERMRVxuICAgIH07XG4gICAgdmFyIGJ1dHRvbiA9IHRoaXMuX2lzVG91Y2hFdmVudChldmVudCkgPyBNT1VTRV9MRUZUIDogYnV0dG9uQ29kZU1hcFtldmVudC5idXR0b25zXTtcbiAgICByZXR1cm4gYnV0dG9uID8gYnV0dG9uIDogbnVsbDtcbiAgfTtcbiAgX19wcm90by5faXNUb3VjaEV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50LnR5cGUgJiYgZXZlbnQudHlwZS5pbmRleE9mKFwidG91Y2hcIikgPiAtMTtcbiAgfTtcbiAgX19wcm90by5faXNWYWxpZEJ1dHRvbiA9IGZ1bmN0aW9uIChidXR0b24sIGlucHV0QnV0dG9uKSB7XG4gICAgcmV0dXJuIGlucHV0QnV0dG9uLmluZGV4T2YoYnV0dG9uKSA+IC0xO1xuICB9O1xuICBfX3Byb3RvLl9pc1ZhbGlkRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQsIGlucHV0S2V5LCBpbnB1dEJ1dHRvbikge1xuICAgIHJldHVybiAoIWlucHV0S2V5IHx8IGlzVmFsaWRLZXkoZXZlbnQsIGlucHV0S2V5KSkgJiYgKCFpbnB1dEJ1dHRvbiB8fCB0aGlzLl9pc1ZhbGlkQnV0dG9uKHRoaXMuX2dldEJ1dHRvbihldmVudCksIGlucHV0QnV0dG9uKSk7XG4gIH07XG4gIF9fcHJvdG8uX3ByZXZlbnRNb3VzZUJ1dHRvbiA9IGZ1bmN0aW9uIChldmVudCwgYnV0dG9uKSB7XG4gICAgaWYgKGJ1dHRvbiA9PT0gTU9VU0VfUklHSFQpIHtcbiAgICAgIHdpbi5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgdGhpcy5fc3RvcENvbnRleHRNZW51KTtcbiAgICB9IGVsc2UgaWYgKGJ1dHRvbiA9PT0gTU9VU0VfTUlERExFKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIEV2ZW50SW5wdXQ7XG59KCk7XG5cbnZhciBNb3VzZUV2ZW50SW5wdXQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMkMShNb3VzZUV2ZW50SW5wdXQsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIE1vdXNlRXZlbnRJbnB1dCgpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICBfdGhpcy5zdGFydCA9IFtcIm1vdXNlZG93blwiXTtcbiAgICBfdGhpcy5tb3ZlID0gW1wibW91c2Vtb3ZlXCJdO1xuICAgIF90aGlzLmVuZCA9IFtcIm1vdXNldXBcIl07XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIHZhciBfX3Byb3RvID0gTW91c2VFdmVudElucHV0LnByb3RvdHlwZTtcbiAgX19wcm90by5vbkV2ZW50U3RhcnQgPSBmdW5jdGlvbiAoZXZlbnQsIGlucHV0S2V5LCBpbnB1dEJ1dHRvbikge1xuICAgIHZhciBidXR0b24gPSB0aGlzLl9nZXRCdXR0b24oZXZlbnQpO1xuICAgIGlmICghdGhpcy5faXNWYWxpZEV2ZW50KGV2ZW50LCBpbnB1dEtleSwgaW5wdXRCdXR0b24pKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5fcHJldmVudE1vdXNlQnV0dG9uKGV2ZW50LCBidXR0b24pO1xuICAgIHJldHVybiB0aGlzLmV4dGVuZEV2ZW50KGV2ZW50KTtcbiAgfTtcbiAgX19wcm90by5vbkV2ZW50TW92ZSA9IGZ1bmN0aW9uIChldmVudCwgaW5wdXRLZXksIGlucHV0QnV0dG9uKSB7XG4gICAgaWYgKCF0aGlzLl9pc1ZhbGlkRXZlbnQoZXZlbnQsIGlucHV0S2V5LCBpbnB1dEJ1dHRvbikpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5leHRlbmRFdmVudChldmVudCk7XG4gIH07XG4gIF9fcHJvdG8ub25FdmVudEVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm47XG4gIH07XG4gIF9fcHJvdG8ub25SZWxlYXNlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucHJldkV2ZW50ID0gbnVsbDtcbiAgICByZXR1cm47XG4gIH07XG4gIF9fcHJvdG8uZ2V0VG91Y2hlcyA9IGZ1bmN0aW9uIChldmVudCwgaW5wdXRCdXR0b24pIHtcbiAgICBpZiAoaW5wdXRCdXR0b24pIHtcbiAgICAgIHJldHVybiB0aGlzLl9pc1ZhbGlkQnV0dG9uKE1PVVNFX0JVVFRPTl9DT0RFX01BUFtldmVudC53aGljaF0sIGlucHV0QnV0dG9uKSAmJiB0aGlzLmVuZC5pbmRleE9mKGV2ZW50LnR5cGUpID09PSAtMSA/IDEgOiAwO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfTtcbiAgX19wcm90by5fZ2V0U2NhbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIDE7XG4gIH07XG4gIF9fcHJvdG8uX2dldENlbnRlciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiBldmVudC5jbGllbnRYLFxuICAgICAgeTogZXZlbnQuY2xpZW50WVxuICAgIH07XG4gIH07XG4gIF9fcHJvdG8uX2dldE1vdmVtZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIHByZXYgPSB0aGlzLnByZXZFdmVudC5zcmNFdmVudDtcbiAgICByZXR1cm4ge1xuICAgICAgeDogZXZlbnQuY2xpZW50WCAtIHByZXYuY2xpZW50WCxcbiAgICAgIHk6IGV2ZW50LmNsaWVudFkgLSBwcmV2LmNsaWVudFlcbiAgICB9O1xuICB9O1xuICByZXR1cm4gTW91c2VFdmVudElucHV0O1xufShFdmVudElucHV0KTtcblxudmFyIFRvdWNoRXZlbnRJbnB1dCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyQxKFRvdWNoRXZlbnRJbnB1dCwgX3N1cGVyKTtcbiAgZnVuY3Rpb24gVG91Y2hFdmVudElucHV0KCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIF90aGlzLnN0YXJ0ID0gW1widG91Y2hzdGFydFwiXTtcbiAgICBfdGhpcy5tb3ZlID0gW1widG91Y2htb3ZlXCJdO1xuICAgIF90aGlzLmVuZCA9IFtcInRvdWNoZW5kXCIsIFwidG91Y2hjYW5jZWxcIl07XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIHZhciBfX3Byb3RvID0gVG91Y2hFdmVudElucHV0LnByb3RvdHlwZTtcbiAgX19wcm90by5vbkV2ZW50U3RhcnQgPSBmdW5jdGlvbiAoZXZlbnQsIGlucHV0S2V5KSB7XG4gICAgdGhpcy5fYmFzZVRvdWNoZXMgPSBldmVudC50b3VjaGVzO1xuICAgIGlmICghdGhpcy5faXNWYWxpZEV2ZW50KGV2ZW50LCBpbnB1dEtleSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5leHRlbmRFdmVudChldmVudCk7XG4gIH07XG4gIF9fcHJvdG8ub25FdmVudE1vdmUgPSBmdW5jdGlvbiAoZXZlbnQsIGlucHV0S2V5KSB7XG4gICAgaWYgKCF0aGlzLl9pc1ZhbGlkRXZlbnQoZXZlbnQsIGlucHV0S2V5KSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmV4dGVuZEV2ZW50KGV2ZW50KTtcbiAgfTtcbiAgX19wcm90by5vbkV2ZW50RW5kID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdGhpcy5fYmFzZVRvdWNoZXMgPSBldmVudC50b3VjaGVzO1xuICAgIHJldHVybjtcbiAgfTtcbiAgX19wcm90by5vblJlbGVhc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5wcmV2RXZlbnQgPSBudWxsO1xuICAgIHRoaXMuX2Jhc2VUb3VjaGVzID0gbnVsbDtcbiAgICByZXR1cm47XG4gIH07XG4gIF9fcHJvdG8uZ2V0VG91Y2hlcyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiBldmVudC50b3VjaGVzLmxlbmd0aDtcbiAgfTtcbiAgX19wcm90by5fZ2V0U2NhbGUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQudG91Y2hlcy5sZW5ndGggIT09IDIgfHwgdGhpcy5fYmFzZVRvdWNoZXMubGVuZ3RoIDwgMikge1xuICAgICAgcmV0dXJuIG51bGw7IC8vIFRPRE86IGNvbnNpZGVyIGNhbGN1bGF0aW5nIG5vbi1waW5jaCBnZXN0dXJlIHNjYWxlXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2dldERpc3RhbmNlKGV2ZW50LnRvdWNoZXNbMF0sIGV2ZW50LnRvdWNoZXNbMV0pIC8gdGhpcy5fZ2V0RGlzdGFuY2UodGhpcy5fYmFzZVRvdWNoZXNbMF0sIHRoaXMuX2Jhc2VUb3VjaGVzWzFdKTtcbiAgfTtcbiAgX19wcm90by5fZ2V0Q2VudGVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGV2ZW50LnRvdWNoZXNbMF0uY2xpZW50WCxcbiAgICAgIHk6IGV2ZW50LnRvdWNoZXNbMF0uY2xpZW50WVxuICAgIH07XG4gIH07XG4gIF9fcHJvdG8uX2dldE1vdmVtZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIHByZXYgPSB0aGlzLnByZXZFdmVudC5zcmNFdmVudDtcbiAgICBpZiAoZXZlbnQudG91Y2hlc1swXS5pZGVudGlmaWVyICE9PSBwcmV2LnRvdWNoZXNbMF0uaWRlbnRpZmllcikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMFxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGV2ZW50LnRvdWNoZXNbMF0uY2xpZW50WCAtIHByZXYudG91Y2hlc1swXS5jbGllbnRYLFxuICAgICAgeTogZXZlbnQudG91Y2hlc1swXS5jbGllbnRZIC0gcHJldi50b3VjaGVzWzBdLmNsaWVudFlcbiAgICB9O1xuICB9O1xuICByZXR1cm4gVG91Y2hFdmVudElucHV0O1xufShFdmVudElucHV0KTtcblxudmFyIFBvaW50ZXJFdmVudElucHV0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzJDEoUG9pbnRlckV2ZW50SW5wdXQsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIFBvaW50ZXJFdmVudElucHV0KCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIF90aGlzLnN0YXJ0ID0gU1VQUE9SVF9QT0lOVEVSID8gW1wicG9pbnRlcmRvd25cIl0gOiBbXCJNU1BvaW50ZXJEb3duXCJdO1xuICAgIF90aGlzLm1vdmUgPSBTVVBQT1JUX1BPSU5URVIgPyBbXCJwb2ludGVybW92ZVwiXSA6IFtcIk1TUG9pbnRlck1vdmVcIl07XG4gICAgX3RoaXMuZW5kID0gU1VQUE9SVF9QT0lOVEVSID8gW1wicG9pbnRlcnVwXCIsIFwicG9pbnRlcmNhbmNlbFwiXSA6IFtcIk1TUG9pbnRlclVwXCIsIFwiTVNQb2ludGVyQ2FuY2VsXCJdO1xuICAgIC8vIHN0b3JlIGZpcnN0LCByZWNlbnQgaW5wdXRzIGZvciBlYWNoIGV2ZW50IGlkXG4gICAgX3RoaXMuX2ZpcnN0SW5wdXRzID0gW107XG4gICAgX3RoaXMuX3JlY2VudElucHV0cyA9IFtdO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICB2YXIgX19wcm90byA9IFBvaW50ZXJFdmVudElucHV0LnByb3RvdHlwZTtcbiAgX19wcm90by5vbkV2ZW50U3RhcnQgPSBmdW5jdGlvbiAoZXZlbnQsIGlucHV0S2V5LCBpbnB1dEJ1dHRvbikge1xuICAgIHZhciBidXR0b24gPSB0aGlzLl9nZXRCdXR0b24oZXZlbnQpO1xuICAgIGlmICghdGhpcy5faXNWYWxpZEV2ZW50KGV2ZW50LCBpbnB1dEtleSwgaW5wdXRCdXR0b24pKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5fcHJldmVudE1vdXNlQnV0dG9uKGV2ZW50LCBidXR0b24pO1xuICAgIHRoaXMuX3VwZGF0ZVBvaW50ZXJFdmVudChldmVudCk7XG4gICAgcmV0dXJuIHRoaXMuZXh0ZW5kRXZlbnQoZXZlbnQpO1xuICB9O1xuICBfX3Byb3RvLm9uRXZlbnRNb3ZlID0gZnVuY3Rpb24gKGV2ZW50LCBpbnB1dEtleSwgaW5wdXRCdXR0b24pIHtcbiAgICBpZiAoIXRoaXMuX2lzVmFsaWRFdmVudChldmVudCwgaW5wdXRLZXksIGlucHV0QnV0dG9uKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHRoaXMuX3VwZGF0ZVBvaW50ZXJFdmVudChldmVudCk7XG4gICAgcmV0dXJuIHRoaXMuZXh0ZW5kRXZlbnQoZXZlbnQpO1xuICB9O1xuICBfX3Byb3RvLm9uRXZlbnRFbmQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB0aGlzLl9yZW1vdmVQb2ludGVyRXZlbnQoZXZlbnQpO1xuICB9O1xuICBfX3Byb3RvLm9uUmVsZWFzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnByZXZFdmVudCA9IG51bGw7XG4gICAgdGhpcy5fZmlyc3RJbnB1dHMgPSBbXTtcbiAgICB0aGlzLl9yZWNlbnRJbnB1dHMgPSBbXTtcbiAgICByZXR1cm47XG4gIH07XG4gIF9fcHJvdG8uZ2V0VG91Y2hlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVjZW50SW5wdXRzLmxlbmd0aDtcbiAgfTtcbiAgX19wcm90by5fZ2V0U2NhbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3JlY2VudElucHV0cy5sZW5ndGggIT09IDIpIHtcbiAgICAgIHJldHVybiBudWxsOyAvLyBUT0RPOiBjb25zaWRlciBjYWxjdWxhdGluZyBub24tcGluY2ggZ2VzdHVyZSBzY2FsZVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9nZXREaXN0YW5jZSh0aGlzLl9yZWNlbnRJbnB1dHNbMF0sIHRoaXMuX3JlY2VudElucHV0c1sxXSkgLyB0aGlzLl9nZXREaXN0YW5jZSh0aGlzLl9maXJzdElucHV0c1swXSwgdGhpcy5fZmlyc3RJbnB1dHNbMV0pO1xuICB9O1xuICBfX3Byb3RvLl9nZXRDZW50ZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogZXZlbnQuY2xpZW50WCxcbiAgICAgIHk6IGV2ZW50LmNsaWVudFlcbiAgICB9O1xuICB9O1xuICBfX3Byb3RvLl9nZXRNb3ZlbWVudCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciBwcmV2ID0gdGhpcy5wcmV2RXZlbnQuc3JjRXZlbnQ7XG4gICAgaWYgKGV2ZW50LnBvaW50ZXJJZCAhPT0gcHJldi5wb2ludGVySWQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDBcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB4OiBldmVudC5jbGllbnRYIC0gcHJldi5jbGllbnRYLFxuICAgICAgeTogZXZlbnQuY2xpZW50WSAtIHByZXYuY2xpZW50WVxuICAgIH07XG4gIH07XG4gIF9fcHJvdG8uX3VwZGF0ZVBvaW50ZXJFdmVudCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIGFkZEZsYWcgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWNlbnRJbnB1dHMuZm9yRWFjaChmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgaWYgKGUucG9pbnRlcklkID09PSBldmVudC5wb2ludGVySWQpIHtcbiAgICAgICAgYWRkRmxhZyA9IHRydWU7XG4gICAgICAgIF90aGlzLl9yZWNlbnRJbnB1dHNbaV0gPSBldmVudDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIWFkZEZsYWcpIHtcbiAgICAgIHRoaXMuX2ZpcnN0SW5wdXRzLnB1c2goZXZlbnQpO1xuICAgICAgdGhpcy5fcmVjZW50SW5wdXRzLnB1c2goZXZlbnQpO1xuICAgIH1cbiAgfTtcbiAgX19wcm90by5fcmVtb3ZlUG9pbnRlckV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdGhpcy5fZmlyc3RJbnB1dHMgPSB0aGlzLl9maXJzdElucHV0cy5maWx0ZXIoZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiB4LnBvaW50ZXJJZCAhPT0gZXZlbnQucG9pbnRlcklkO1xuICAgIH0pO1xuICAgIHRoaXMuX3JlY2VudElucHV0cyA9IHRoaXMuX3JlY2VudElucHV0cy5maWx0ZXIoZnVuY3Rpb24gKHgpIHtcbiAgICAgIHJldHVybiB4LnBvaW50ZXJJZCAhPT0gZXZlbnQucG9pbnRlcklkO1xuICAgIH0pO1xuICB9O1xuICByZXR1cm4gUG9pbnRlckV2ZW50SW5wdXQ7XG59KEV2ZW50SW5wdXQpO1xuXG52YXIgVG91Y2hNb3VzZUV2ZW50SW5wdXQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMkMShUb3VjaE1vdXNlRXZlbnRJbnB1dCwgX3N1cGVyKTtcbiAgZnVuY3Rpb24gVG91Y2hNb3VzZUV2ZW50SW5wdXQoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgX3RoaXMuc3RhcnQgPSBbXCJtb3VzZWRvd25cIiwgXCJ0b3VjaHN0YXJ0XCJdO1xuICAgIF90aGlzLm1vdmUgPSBbXCJtb3VzZW1vdmVcIiwgXCJ0b3VjaG1vdmVcIl07XG4gICAgX3RoaXMuZW5kID0gW1wibW91c2V1cFwiLCBcInRvdWNoZW5kXCIsIFwidG91Y2hjYW5jZWxcIl07XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIHZhciBfX3Byb3RvID0gVG91Y2hNb3VzZUV2ZW50SW5wdXQucHJvdG90eXBlO1xuICBfX3Byb3RvLm9uRXZlbnRTdGFydCA9IGZ1bmN0aW9uIChldmVudCwgaW5wdXRLZXksIGlucHV0QnV0dG9uKSB7XG4gICAgdmFyIGJ1dHRvbiA9IHRoaXMuX2dldEJ1dHRvbihldmVudCk7XG4gICAgaWYgKHRoaXMuX2lzVG91Y2hFdmVudChldmVudCkpIHtcbiAgICAgIHRoaXMuX2Jhc2VUb3VjaGVzID0gZXZlbnQudG91Y2hlcztcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9pc1ZhbGlkRXZlbnQoZXZlbnQsIGlucHV0S2V5LCBpbnB1dEJ1dHRvbikpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB0aGlzLl9wcmV2ZW50TW91c2VCdXR0b24oZXZlbnQsIGJ1dHRvbik7XG4gICAgcmV0dXJuIHRoaXMuZXh0ZW5kRXZlbnQoZXZlbnQpO1xuICB9O1xuICBfX3Byb3RvLm9uRXZlbnRNb3ZlID0gZnVuY3Rpb24gKGV2ZW50LCBpbnB1dEtleSwgaW5wdXRCdXR0b24pIHtcbiAgICBpZiAoIXRoaXMuX2lzVmFsaWRFdmVudChldmVudCwgaW5wdXRLZXksIGlucHV0QnV0dG9uKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmV4dGVuZEV2ZW50KGV2ZW50KTtcbiAgfTtcbiAgX19wcm90by5vbkV2ZW50RW5kID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuX2lzVG91Y2hFdmVudChldmVudCkpIHtcbiAgICAgIHRoaXMuX2Jhc2VUb3VjaGVzID0gZXZlbnQudG91Y2hlcztcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9O1xuICBfX3Byb3RvLm9uUmVsZWFzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnByZXZFdmVudCA9IG51bGw7XG4gICAgdGhpcy5fYmFzZVRvdWNoZXMgPSBudWxsO1xuICAgIHJldHVybjtcbiAgfTtcbiAgX19wcm90by5nZXRUb3VjaGVzID0gZnVuY3Rpb24gKGV2ZW50LCBpbnB1dEJ1dHRvbikge1xuICAgIGlmICh0aGlzLl9pc1RvdWNoRXZlbnQoZXZlbnQpKSB7XG4gICAgICByZXR1cm4gZXZlbnQudG91Y2hlcy5sZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9pc1ZhbGlkQnV0dG9uKE1PVVNFX0JVVFRPTl9DT0RFX01BUFtldmVudC53aGljaF0sIGlucHV0QnV0dG9uKSAmJiB0aGlzLmVuZC5pbmRleE9mKGV2ZW50LnR5cGUpID09PSAtMSA/IDEgOiAwO1xuICAgIH1cbiAgfTtcbiAgX19wcm90by5fZ2V0U2NhbGUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAodGhpcy5faXNUb3VjaEV2ZW50KGV2ZW50KSkge1xuICAgICAgaWYgKGV2ZW50LnRvdWNoZXMubGVuZ3RoICE9PSAyIHx8IHRoaXMuX2Jhc2VUb3VjaGVzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIDE7IC8vIFRPRE86IGNvbnNpZGVyIGNhbGN1bGF0aW5nIG5vbi1waW5jaCBnZXN0dXJlIHNjYWxlXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9nZXREaXN0YW5jZShldmVudC50b3VjaGVzWzBdLCBldmVudC50b3VjaGVzWzFdKSAvIHRoaXMuX2dldERpc3RhbmNlKHRoaXMuX2Jhc2VUb3VjaGVzWzBdLCB0aGlzLl9iYXNlVG91Y2hlc1sxXSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnByZXZFdmVudC5zY2FsZTtcbiAgfTtcbiAgX19wcm90by5fZ2V0Q2VudGVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuX2lzVG91Y2hFdmVudChldmVudCkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IGV2ZW50LnRvdWNoZXNbMF0uY2xpZW50WCxcbiAgICAgICAgeTogZXZlbnQudG91Y2hlc1swXS5jbGllbnRZXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgeDogZXZlbnQuY2xpZW50WCxcbiAgICAgIHk6IGV2ZW50LmNsaWVudFlcbiAgICB9O1xuICB9O1xuICBfX3Byb3RvLl9nZXRNb3ZlbWVudCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIHByZXYgPSB0aGlzLnByZXZFdmVudC5zcmNFdmVudDtcbiAgICB2YXIgX2EgPSBbZXZlbnQsIHByZXZdLm1hcChmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoX3RoaXMuX2lzVG91Y2hFdmVudChlKSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpZDogZS50b3VjaGVzWzBdLmlkZW50aWZpZXIsXG4gICAgICAgICAgICB4OiBlLnRvdWNoZXNbMF0uY2xpZW50WCxcbiAgICAgICAgICAgIHk6IGUudG91Y2hlc1swXS5jbGllbnRZXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlkOiBudWxsLFxuICAgICAgICAgIHg6IGUuY2xpZW50WCxcbiAgICAgICAgICB5OiBlLmNsaWVudFlcbiAgICAgICAgfTtcbiAgICAgIH0pLFxuICAgICAgbmV4dFNwb3QgPSBfYVswXSxcbiAgICAgIHByZXZTcG90ID0gX2FbMV07XG4gICAgcmV0dXJuIG5leHRTcG90LmlkID09PSBwcmV2U3BvdC5pZCA/IHtcbiAgICAgIHg6IG5leHRTcG90LnggLSBwcmV2U3BvdC54LFxuICAgICAgeTogbmV4dFNwb3QueSAtIHByZXZTcG90LnlcbiAgICB9IDoge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDBcbiAgICB9O1xuICB9O1xuICByZXR1cm4gVG91Y2hNb3VzZUV2ZW50SW5wdXQ7XG59KEV2ZW50SW5wdXQpO1xuXG52YXIgdG9BeGlzID0gZnVuY3Rpb24gKHNvdXJjZSwgb2Zmc2V0KSB7XG4gIHJldHVybiBvZmZzZXQucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHYsIGkpIHtcbiAgICBpZiAoc291cmNlW2ldKSB7XG4gICAgICBhY2Nbc291cmNlW2ldXSA9IHY7XG4gICAgfVxuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbn07XG52YXIgY29udmVydElucHV0VHlwZSA9IGZ1bmN0aW9uIChpbnB1dFR5cGUpIHtcbiAgaWYgKGlucHV0VHlwZSA9PT0gdm9pZCAwKSB7XG4gICAgaW5wdXRUeXBlID0gW107XG4gIH1cbiAgdmFyIGhhc1RvdWNoID0gZmFsc2U7XG4gIHZhciBoYXNNb3VzZSA9IGZhbHNlO1xuICB2YXIgaGFzUG9pbnRlciA9IGZhbHNlO1xuICBpbnB1dFR5cGUuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgIHN3aXRjaCAodikge1xuICAgICAgY2FzZSBcIm1vdXNlXCI6XG4gICAgICAgIGhhc01vdXNlID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwidG91Y2hcIjpcbiAgICAgICAgaGFzVG91Y2ggPSBTVVBQT1JUX1RPVUNIO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJwb2ludGVyXCI6XG4gICAgICAgIGhhc1BvaW50ZXIgPSBTVVBQT1JUX1BPSU5URVJfRVZFTlRTO1xuICAgICAgLy8gbm8gZGVmYXVsdFxuICAgIH1cbiAgfSk7XG5cbiAgaWYgKGhhc1BvaW50ZXIpIHtcbiAgICByZXR1cm4gbmV3IFBvaW50ZXJFdmVudElucHV0KCk7XG4gIH0gZWxzZSBpZiAoaGFzVG91Y2ggJiYgaGFzTW91c2UpIHtcbiAgICByZXR1cm4gbmV3IFRvdWNoTW91c2VFdmVudElucHV0KCk7XG4gIH0gZWxzZSBpZiAoaGFzVG91Y2gpIHtcbiAgICByZXR1cm4gbmV3IFRvdWNoRXZlbnRJbnB1dCgpO1xuICB9IGVsc2UgaWYgKGhhc01vdXNlKSB7XG4gICAgcmV0dXJuIG5ldyBNb3VzZUV2ZW50SW5wdXQoKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5mdW5jdGlvbiBnZXRBZGRFdmVudE9wdGlvbnMoZXZlbnROYW1lKSB7XG4gIC8vIFRoZSBwYXNzaXZlIGRlZmF1bHQgdmFsdWUgb2YgdGhlIHRvdWNoIGV2ZW50IGlzIHRydWUuXG4gIC8vIElmIG5vdCBhIHRvdWNoIGV2ZW50LCByZXR1cm4gZmFsc2UgdG8gc3VwcG9ydCBpZTExXG4gIHJldHVybiBldmVudE5hbWUuaW5kZXhPZihcInRvdWNoXCIpID4gLTEgPyB7XG4gICAgcGFzc2l2ZTogZmFsc2VcbiAgfSA6IGZhbHNlO1xufVxuXG52YXIgSW5wdXRPYnNlcnZlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIElucHV0T2JzZXJ2ZXIoX2EpIHtcbiAgICB2YXIgb3B0aW9ucyA9IF9hLm9wdGlvbnMsXG4gICAgICBpbnRlcnJ1cHRNYW5hZ2VyID0gX2EuaW50ZXJydXB0TWFuYWdlcixcbiAgICAgIGV2ZW50TWFuYWdlciA9IF9hLmV2ZW50TWFuYWdlcixcbiAgICAgIGF4aXNNYW5hZ2VyID0gX2EuYXhpc01hbmFnZXIsXG4gICAgICBhbmltYXRpb25NYW5hZ2VyID0gX2EuYW5pbWF0aW9uTWFuYWdlcjtcbiAgICB0aGlzLl9pc091dHNpZGUgPSBmYWxzZTtcbiAgICB0aGlzLl9tb3ZlRGlzdGFuY2UgPSBudWxsO1xuICAgIHRoaXMuX2lzU3RvcHBlZCA9IGZhbHNlO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5faW50ZXJydXB0TWFuYWdlciA9IGludGVycnVwdE1hbmFnZXI7XG4gICAgdGhpcy5fZXZlbnRNYW5hZ2VyID0gZXZlbnRNYW5hZ2VyO1xuICAgIHRoaXMuX2F4aXNNYW5hZ2VyID0gYXhpc01hbmFnZXI7XG4gICAgdGhpcy5fYW5pbWF0aW9uTWFuYWdlciA9IGFuaW1hdGlvbk1hbmFnZXI7XG4gIH1cbiAgdmFyIF9fcHJvdG8gPSBJbnB1dE9ic2VydmVyLnByb3RvdHlwZTtcbiAgX19wcm90by5nZXQgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICByZXR1cm4gdGhpcy5fYXhpc01hbmFnZXIuZ2V0KGlucHV0LmF4ZXMpO1xuICB9O1xuICBfX3Byb3RvLmhvbGQgPSBmdW5jdGlvbiAoaW5wdXQsIGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuX2ludGVycnVwdE1hbmFnZXIuaXNJbnRlcnJ1cHRlZCgpIHx8ICFpbnB1dC5heGVzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgY2hhbmdlT3B0aW9uID0ge1xuICAgICAgaW5wdXQ6IGlucHV0LFxuICAgICAgZXZlbnQ6IGV2ZW50XG4gICAgfTtcbiAgICB0aGlzLl9pc1N0b3BwZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9pbnRlcnJ1cHRNYW5hZ2VyLnNldEludGVycnVwdCh0cnVlKTtcbiAgICB0aGlzLl9hbmltYXRpb25NYW5hZ2VyLnN0b3BBbmltYXRpb24oY2hhbmdlT3B0aW9uKTtcbiAgICArK3RoaXMuX2V2ZW50TWFuYWdlci5ob2xkaW5nQ291bnQ7XG4gICAgaWYgKCF0aGlzLl9tb3ZlRGlzdGFuY2UpIHtcbiAgICAgIHRoaXMuX2V2ZW50TWFuYWdlci5ob2xkKHRoaXMuX2F4aXNNYW5hZ2VyLmdldCgpLCBjaGFuZ2VPcHRpb24pO1xuICAgIH1cbiAgICB0aGlzLl9pc091dHNpZGUgPSB0aGlzLl9heGlzTWFuYWdlci5pc091dHNpZGUoaW5wdXQuYXhlcyk7XG4gICAgdGhpcy5fbW92ZURpc3RhbmNlID0gdGhpcy5fYXhpc01hbmFnZXIuZ2V0KGlucHV0LmF4ZXMpO1xuICB9O1xuICBfX3Byb3RvLmNoYW5nZSA9IGZ1bmN0aW9uIChpbnB1dCwgZXZlbnQsIG9mZnNldCwgdXNlQW5pbWF0aW9uKSB7XG4gICAgaWYgKHRoaXMuX2lzU3RvcHBlZCB8fCAhdGhpcy5faW50ZXJydXB0TWFuYWdlci5pc0ludGVycnVwdGluZygpIHx8IHRoaXMuX2F4aXNNYW5hZ2VyLmV2ZXJ5KG9mZnNldCwgZnVuY3Rpb24gKHYpIHtcbiAgICAgIHJldHVybiB2ID09PSAwO1xuICAgIH0pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBuYXRpdmVFdmVudCA9IGV2ZW50LnNyY0V2ZW50ID8gZXZlbnQuc3JjRXZlbnQgOiBldmVudDtcbiAgICBpZiAobmF0aXZlRXZlbnQuX19jaGlsZHJlbkF4ZXNBbHJlYWR5Q2hhbmdlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgZGVwYVBvcyA9IHRoaXMuX21vdmVEaXN0YW5jZSB8fCB0aGlzLl9heGlzTWFuYWdlci5nZXQoaW5wdXQuYXhlcyk7XG4gICAgdmFyIGRlc3RQb3M7XG4gICAgLy8gZm9yIG91dHNpZGUgbG9naWNcbiAgICBkZXN0UG9zID0gbWFwKGRlcGFQb3MsIGZ1bmN0aW9uICh2LCBrKSB7XG4gICAgICByZXR1cm4gdiArIChvZmZzZXRba10gfHwgMCk7XG4gICAgfSk7XG4gICAgaWYgKHRoaXMuX21vdmVEaXN0YW5jZSkge1xuICAgICAgdGhpcy5fbW92ZURpc3RhbmNlID0gdGhpcy5fYXhpc01hbmFnZXIubWFwKGRlc3RQb3MsIGZ1bmN0aW9uICh2LCBfYSkge1xuICAgICAgICB2YXIgY2lyY3VsYXIgPSBfYS5jaXJjdWxhcixcbiAgICAgICAgICByYW5nZSA9IF9hLnJhbmdlO1xuICAgICAgICByZXR1cm4gY2lyY3VsYXIgJiYgKGNpcmN1bGFyWzBdIHx8IGNpcmN1bGFyWzFdKSA/IGdldENpcmN1bGF0ZWRQb3ModiwgcmFuZ2UsIGNpcmN1bGFyKSA6IHY7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8gZnJvbSBvdXRzaWRlIHRvIGluc2lkZVxuICAgIGlmICh0aGlzLl9pc091dHNpZGUgJiYgdGhpcy5fYXhpc01hbmFnZXIuZXZlcnkoZGVwYVBvcywgZnVuY3Rpb24gKHYsIG9wdCkge1xuICAgICAgcmV0dXJuICFpc091dHNpZGUodiwgb3B0LnJhbmdlKTtcbiAgICB9KSkge1xuICAgICAgdGhpcy5faXNPdXRzaWRlID0gZmFsc2U7XG4gICAgfVxuICAgIGRlcGFQb3MgPSB0aGlzLl9hdE91dHNpZGUoZGVwYVBvcyk7XG4gICAgZGVzdFBvcyA9IHRoaXMuX2F0T3V0c2lkZShkZXN0UG9zKTtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5uZXN0ZWQgfHwgIXRoaXMuX2lzRW5kb2ZBeGlzKG9mZnNldCwgZGVwYVBvcywgZGVzdFBvcykpIHtcbiAgICAgIG5hdGl2ZUV2ZW50Ll9fY2hpbGRyZW5BeGVzQWxyZWFkeUNoYW5nZWQgPSB0cnVlO1xuICAgIH1cbiAgICB2YXIgY2hhbmdlT3B0aW9uID0ge1xuICAgICAgaW5wdXQ6IGlucHV0LFxuICAgICAgZXZlbnQ6IGV2ZW50XG4gICAgfTtcbiAgICBpZiAodXNlQW5pbWF0aW9uKSB7XG4gICAgICB2YXIgZHVyYXRpb24gPSB0aGlzLl9hbmltYXRpb25NYW5hZ2VyLmdldER1cmF0aW9uKGRlc3RQb3MsIGRlcGFQb3MpO1xuICAgICAgdGhpcy5fYW5pbWF0aW9uTWFuYWdlci5hbmltYXRlVG8oZGVzdFBvcywgZHVyYXRpb24sIGNoYW5nZU9wdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpc0NhbmNlbGVkID0gIXRoaXMuX2V2ZW50TWFuYWdlci50cmlnZ2VyQ2hhbmdlKGRlc3RQb3MsIGRlcGFQb3MsIGNoYW5nZU9wdGlvbiwgdHJ1ZSk7XG4gICAgICBpZiAoaXNDYW5jZWxlZCkge1xuICAgICAgICB0aGlzLl9pc1N0b3BwZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9tb3ZlRGlzdGFuY2UgPSBudWxsO1xuICAgICAgICB0aGlzLl9hbmltYXRpb25NYW5hZ2VyLmZpbmlzaChmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBfX3Byb3RvLnJlbGVhc2UgPSBmdW5jdGlvbiAoaW5wdXQsIGV2ZW50LCB2ZWxvY2l0eSwgaW5wdXREdXJhdGlvbikge1xuICAgIGlmICh0aGlzLl9pc1N0b3BwZWQgfHwgIXRoaXMuX2ludGVycnVwdE1hbmFnZXIuaXNJbnRlcnJ1cHRpbmcoKSB8fCAhdGhpcy5fbW92ZURpc3RhbmNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBuYXRpdmVFdmVudCA9IGV2ZW50LnNyY0V2ZW50ID8gZXZlbnQuc3JjRXZlbnQgOiBldmVudDtcbiAgICBpZiAobmF0aXZlRXZlbnQuX19jaGlsZHJlbkF4ZXNBbHJlYWR5UmVsZWFzZWQpIHtcbiAgICAgIHZlbG9jaXR5ID0gdmVsb2NpdHkubWFwKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9KTtcbiAgICB9XG4gICAgdmFyIHBvcyA9IHRoaXMuX2F4aXNNYW5hZ2VyLmdldChpbnB1dC5heGVzKTtcbiAgICB2YXIgZGVwYVBvcyA9IHRoaXMuX2F4aXNNYW5hZ2VyLmdldCgpO1xuICAgIHZhciBkaXNwbGFjZW1lbnQgPSB0aGlzLl9hbmltYXRpb25NYW5hZ2VyLmdldERpc3BsYWNlbWVudCh2ZWxvY2l0eSk7XG4gICAgdmFyIG9mZnNldCA9IHRvQXhpcyhpbnB1dC5heGVzLCBkaXNwbGFjZW1lbnQpO1xuICAgIHZhciBkZXN0UG9zID0gdGhpcy5fYXhpc01hbmFnZXIuZ2V0KHRoaXMuX2F4aXNNYW5hZ2VyLm1hcChvZmZzZXQsIGZ1bmN0aW9uICh2LCBvcHQsIGspIHtcbiAgICAgIGlmIChvcHQuY2lyY3VsYXIgJiYgKG9wdC5jaXJjdWxhclswXSB8fCBvcHQuY2lyY3VsYXJbMV0pKSB7XG4gICAgICAgIHJldHVybiBwb3Nba10gKyB2O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGdldEluc2lkZVBvc2l0aW9uKHBvc1trXSArIHYsIG9wdC5yYW5nZSwgb3B0LmNpcmN1bGFyLCBvcHQuYm91bmNlKTtcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgbmF0aXZlRXZlbnQuX19jaGlsZHJlbkF4ZXNBbHJlYWR5UmVsZWFzZWQgPSB0cnVlO1xuICAgIHZhciBkdXJhdGlvbiA9IHRoaXMuX2FuaW1hdGlvbk1hbmFnZXIuZ2V0RHVyYXRpb24oZGVzdFBvcywgcG9zLCBpbnB1dER1cmF0aW9uKTtcbiAgICBpZiAoZHVyYXRpb24gPT09IDApIHtcbiAgICAgIGRlc3RQb3MgPSBfX2Fzc2lnbih7fSwgZGVwYVBvcyk7XG4gICAgfVxuICAgIC8vIHByZXBhcmUgcGFyYW1zXG4gICAgdmFyIHBhcmFtID0ge1xuICAgICAgZGVwYVBvczogZGVwYVBvcyxcbiAgICAgIGRlc3RQb3M6IGRlc3RQb3MsXG4gICAgICBkdXJhdGlvbjogZHVyYXRpb24sXG4gICAgICBkZWx0YTogdGhpcy5fYXhpc01hbmFnZXIuZ2V0RGVsdGEoZGVwYVBvcywgZGVzdFBvcyksXG4gICAgICBpbnB1dEV2ZW50OiBldmVudCxcbiAgICAgIGlucHV0OiBpbnB1dCxcbiAgICAgIGlzVHJ1c3RlZDogdHJ1ZVxuICAgIH07XG4gICAgLS10aGlzLl9ldmVudE1hbmFnZXIuaG9sZGluZ0NvdW50O1xuICAgIHRoaXMuX2V2ZW50TWFuYWdlci50cmlnZ2VyUmVsZWFzZShwYXJhbSk7XG4gICAgaWYgKHRoaXMuX2V2ZW50TWFuYWdlci5ob2xkaW5nQ291bnQgPT09IDApIHtcbiAgICAgIHRoaXMuX21vdmVEaXN0YW5jZSA9IG51bGw7XG4gICAgfVxuICAgIC8vIHRvIGNvbnRvbFxuICAgIHZhciB1c2VyV2lzaCA9IHRoaXMuX2FuaW1hdGlvbk1hbmFnZXIuZ2V0VXNlckNvbnRyb2wocGFyYW0pO1xuICAgIHZhciBpc0VxdWFsID0gZXF1YWwodXNlcldpc2guZGVzdFBvcywgZGVwYVBvcyk7XG4gICAgdmFyIGNoYW5nZU9wdGlvbiA9IHtcbiAgICAgIGlucHV0OiBpbnB1dCxcbiAgICAgIGV2ZW50OiBldmVudFxuICAgIH07XG4gICAgaWYgKGlzRXF1YWwgfHwgdXNlcldpc2guZHVyYXRpb24gPT09IDApIHtcbiAgICAgIGlmICghaXNFcXVhbCkge1xuICAgICAgICB0aGlzLl9ldmVudE1hbmFnZXIudHJpZ2dlckNoYW5nZSh1c2VyV2lzaC5kZXN0UG9zLCBkZXBhUG9zLCBjaGFuZ2VPcHRpb24sIHRydWUpO1xuICAgICAgfVxuICAgICAgdGhpcy5faW50ZXJydXB0TWFuYWdlci5zZXRJbnRlcnJ1cHQoZmFsc2UpO1xuICAgICAgaWYgKHRoaXMuX2F4aXNNYW5hZ2VyLmlzT3V0c2lkZSgpKSB7XG4gICAgICAgIHRoaXMuX2FuaW1hdGlvbk1hbmFnZXIucmVzdG9yZShjaGFuZ2VPcHRpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZXZlbnRNYW5hZ2VyLnRyaWdnZXJGaW5pc2godHJ1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2FuaW1hdGlvbk1hbmFnZXIuYW5pbWF0ZVRvKHVzZXJXaXNoLmRlc3RQb3MsIHVzZXJXaXNoLmR1cmF0aW9uLCBjaGFuZ2VPcHRpb24pO1xuICAgIH1cbiAgfTtcbiAgLy8gd2hlbiBtb3ZlIHBvaW50ZXIgaXMgaGVsZCBpbiBvdXRzaWRlXG4gIF9fcHJvdG8uX2F0T3V0c2lkZSA9IGZ1bmN0aW9uIChwb3MpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIGlmICh0aGlzLl9pc091dHNpZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9heGlzTWFuYWdlci5tYXAocG9zLCBmdW5jdGlvbiAodiwgb3B0KSB7XG4gICAgICAgIHZhciB0biA9IG9wdC5yYW5nZVswXSAtIG9wdC5ib3VuY2VbMF07XG4gICAgICAgIHZhciB0eCA9IG9wdC5yYW5nZVsxXSArIG9wdC5ib3VuY2VbMV07XG4gICAgICAgIHJldHVybiB2ID4gdHggPyB0eCA6IHYgPCB0biA/IHRuIDogdjtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fYXhpc01hbmFnZXIubWFwKHBvcywgZnVuY3Rpb24gKHYsIG9wdCkge1xuICAgICAgICB2YXIgbWluID0gb3B0LnJhbmdlWzBdO1xuICAgICAgICB2YXIgbWF4ID0gb3B0LnJhbmdlWzFdO1xuICAgICAgICB2YXIgb3V0ID0gb3B0LmJvdW5jZTtcbiAgICAgICAgdmFyIGNpcmN1bGFyID0gb3B0LmNpcmN1bGFyO1xuICAgICAgICBpZiAoY2lyY3VsYXJbMF0gJiYgdiA8IG1pbiB8fCBjaXJjdWxhclsxXSAmJiB2ID4gbWF4KSB7XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIH0gZWxzZSBpZiAodiA8IG1pbikge1xuICAgICAgICAgIC8vIGxlZnRcbiAgICAgICAgICByZXR1cm4gbWluIC0gX3RoaXMuX2FuaW1hdGlvbk1hbmFnZXIuaW50ZXJwb2xhdGUobWluIC0gdiwgb3V0WzBdKTtcbiAgICAgICAgfSBlbHNlIGlmICh2ID4gbWF4KSB7XG4gICAgICAgICAgLy8gcmlnaHRcbiAgICAgICAgICByZXR1cm4gbWF4ICsgX3RoaXMuX2FuaW1hdGlvbk1hbmFnZXIuaW50ZXJwb2xhdGUodiAtIG1heCwgb3V0WzFdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdjtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgX19wcm90by5faXNFbmRvZkF4aXMgPSBmdW5jdGlvbiAob2Zmc2V0LCBkZXBhUG9zLCBkZXN0UG9zKSB7XG4gICAgcmV0dXJuIHRoaXMuX2F4aXNNYW5hZ2VyLmV2ZXJ5KGRlcGFQb3MsIGZ1bmN0aW9uICh2YWx1ZSwgb3B0aW9uLCBrZXkpIHtcbiAgICAgIHJldHVybiBvZmZzZXRba2V5XSA9PT0gMCB8fCBkZXBhUG9zW2tleV0gPT09IGRlc3RQb3Nba2V5XSAmJiBpc0VuZG9mQm91bmNlKHZhbHVlLCBvcHRpb24ucmFuZ2UsIG9wdGlvbi5ib3VuY2UsIG9wdGlvbi5jaXJjdWxhcik7XG4gICAgfSk7XG4gIH07XG4gIHJldHVybiBJbnB1dE9ic2VydmVyO1xufSgpO1xuXG52YXIgY2xhbXAgPSBmdW5jdGlvbiAodmFsdWUsIG1pbiwgbWF4KSB7XG4gIHJldHVybiBNYXRoLm1heChNYXRoLm1pbih2YWx1ZSwgbWF4KSwgbWluKTtcbn07XG52YXIgQW5pbWF0aW9uTWFuYWdlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEFuaW1hdGlvbk1hbmFnZXIoX2EpIHtcbiAgICB2YXIgb3B0aW9ucyA9IF9hLm9wdGlvbnMsXG4gICAgICBpbnRlcnJ1cHRNYW5hZ2VyID0gX2EuaW50ZXJydXB0TWFuYWdlcixcbiAgICAgIGV2ZW50TWFuYWdlciA9IF9hLmV2ZW50TWFuYWdlcixcbiAgICAgIGF4aXNNYW5hZ2VyID0gX2EuYXhpc01hbmFnZXI7XG4gICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5pbnRlcnJ1cHRNYW5hZ2VyID0gaW50ZXJydXB0TWFuYWdlcjtcbiAgICB0aGlzLmV2ZW50TWFuYWdlciA9IGV2ZW50TWFuYWdlcjtcbiAgICB0aGlzLmF4aXNNYW5hZ2VyID0gYXhpc01hbmFnZXI7XG4gICAgdGhpcy5hbmltYXRpb25FbmQgPSB0aGlzLmFuaW1hdGlvbkVuZC5iaW5kKHRoaXMpO1xuICB9XG4gIHZhciBfX3Byb3RvID0gQW5pbWF0aW9uTWFuYWdlci5wcm90b3R5cGU7XG4gIF9fcHJvdG8uZ2V0RHVyYXRpb24gPSBmdW5jdGlvbiAoZGVwYVBvcywgZGVzdFBvcywgd2lzaER1cmF0aW9uKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB2YXIgZHVyYXRpb247XG4gICAgaWYgKHR5cGVvZiB3aXNoRHVyYXRpb24gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGR1cmF0aW9uID0gd2lzaER1cmF0aW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZHVyYXRpb25zXzEgPSBtYXAoZGVzdFBvcywgZnVuY3Rpb24gKHYsIGspIHtcbiAgICAgICAgcmV0dXJuIGdldER1cmF0aW9uKE1hdGguYWJzKHYgLSBkZXBhUG9zW2tdKSwgX3RoaXMuX29wdGlvbnMuZGVjZWxlcmF0aW9uKTtcbiAgICAgIH0pO1xuICAgICAgZHVyYXRpb24gPSBPYmplY3Qua2V5cyhkdXJhdGlvbnNfMSkucmVkdWNlKGZ1bmN0aW9uIChtYXgsIHYpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KG1heCwgZHVyYXRpb25zXzFbdl0pO1xuICAgICAgfSwgLUluZmluaXR5KTtcbiAgICB9XG4gICAgcmV0dXJuIGNsYW1wKGR1cmF0aW9uLCB0aGlzLl9vcHRpb25zLm1pbmltdW1EdXJhdGlvbiwgdGhpcy5fb3B0aW9ucy5tYXhpbXVtRHVyYXRpb24pO1xuICB9O1xuICBfX3Byb3RvLmdldERpc3BsYWNlbWVudCA9IGZ1bmN0aW9uICh2ZWxvY2l0eSkge1xuICAgIHZhciB0b3RhbFZlbG9jaXR5ID0gTWF0aC5wb3codmVsb2NpdHkucmVkdWNlKGZ1bmN0aW9uICh0b3RhbCwgdikge1xuICAgICAgcmV0dXJuIHRvdGFsICsgdiAqIHY7XG4gICAgfSwgMCksIDEgLyB2ZWxvY2l0eS5sZW5ndGgpO1xuICAgIHZhciBkdXJhdGlvbiA9IE1hdGguYWJzKHRvdGFsVmVsb2NpdHkgLyAtdGhpcy5fb3B0aW9ucy5kZWNlbGVyYXRpb24pO1xuICAgIHJldHVybiB2ZWxvY2l0eS5tYXAoZnVuY3Rpb24gKHYpIHtcbiAgICAgIHJldHVybiB2IC8gMiAqIGR1cmF0aW9uO1xuICAgIH0pO1xuICB9O1xuICBfX3Byb3RvLnN0b3BBbmltYXRpb24gPSBmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgaWYgKHRoaXMuX2FuaW1hdGVQYXJhbSkge1xuICAgICAgdmFyIG9yZ1Bvc18xID0gdGhpcy5heGlzTWFuYWdlci5nZXQoKTtcbiAgICAgIHZhciBwb3MgPSB0aGlzLmF4aXNNYW5hZ2VyLm1hcChvcmdQb3NfMSwgZnVuY3Rpb24gKHYsIG9wdCkge1xuICAgICAgICByZXR1cm4gZ2V0Q2lyY3VsYXRlZFBvcyh2LCBvcHQucmFuZ2UsIG9wdC5jaXJjdWxhcik7XG4gICAgICB9KTtcbiAgICAgIGlmICghZXZlcnkocG9zLCBmdW5jdGlvbiAodiwgaykge1xuICAgICAgICByZXR1cm4gb3JnUG9zXzFba10gPT09IHY7XG4gICAgICB9KSkge1xuICAgICAgICB0aGlzLmV2ZW50TWFuYWdlci50cmlnZ2VyQ2hhbmdlKHBvcywgb3JnUG9zXzEsIG9wdGlvbiwgISFvcHRpb24pO1xuICAgICAgfVxuICAgICAgdGhpcy5fYW5pbWF0ZVBhcmFtID0gbnVsbDtcbiAgICAgIGlmICh0aGlzLl9yYWYpIHtcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUkMSh0aGlzLl9yYWYpO1xuICAgICAgfVxuICAgICAgdGhpcy5fcmFmID0gbnVsbDtcbiAgICAgIHRoaXMuZXZlbnRNYW5hZ2VyLnRyaWdnZXJBbmltYXRpb25FbmQoISEob3B0aW9uID09PSBudWxsIHx8IG9wdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9uLmV2ZW50KSk7XG4gICAgfVxuICB9O1xuICBfX3Byb3RvLmdldEV2ZW50SW5mbyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fYW5pbWF0ZVBhcmFtICYmIHRoaXMuX2FuaW1hdGVQYXJhbS5pbnB1dCAmJiB0aGlzLl9hbmltYXRlUGFyYW0uaW5wdXRFdmVudCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaW5wdXQ6IHRoaXMuX2FuaW1hdGVQYXJhbS5pbnB1dCxcbiAgICAgICAgZXZlbnQ6IHRoaXMuX2FuaW1hdGVQYXJhbS5pbnB1dEV2ZW50XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH07XG4gIF9fcHJvdG8ucmVzdG9yZSA9IGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICB2YXIgcG9zID0gdGhpcy5heGlzTWFuYWdlci5nZXQoKTtcbiAgICB2YXIgZGVzdFBvcyA9IHRoaXMuYXhpc01hbmFnZXIubWFwKHBvcywgZnVuY3Rpb24gKHYsIG9wdCkge1xuICAgICAgcmV0dXJuIE1hdGgubWluKG9wdC5yYW5nZVsxXSwgTWF0aC5tYXgob3B0LnJhbmdlWzBdLCB2KSk7XG4gICAgfSk7XG4gICAgdGhpcy5zdG9wQW5pbWF0aW9uKCk7XG4gICAgdGhpcy5hbmltYXRlVG8oZGVzdFBvcywgdGhpcy5nZXREdXJhdGlvbihwb3MsIGRlc3RQb3MpLCBvcHRpb24pO1xuICB9O1xuICBfX3Byb3RvLmFuaW1hdGlvbkVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYmVmb3JlUGFyYW0gPSB0aGlzLmdldEV2ZW50SW5mbygpO1xuICAgIHRoaXMuX2FuaW1hdGVQYXJhbSA9IG51bGw7XG4gICAgLy8gZm9yIENpcmN1bGFyXG4gICAgdmFyIGNpcmN1bGFyVGFyZ2V0cyA9IHRoaXMuYXhpc01hbmFnZXIuZmlsdGVyKHRoaXMuYXhpc01hbmFnZXIuZ2V0KCksIGZ1bmN0aW9uICh2LCBvcHQpIHtcbiAgICAgIHJldHVybiBpc0NpcmN1bGFyYWJsZSh2LCBvcHQucmFuZ2UsIG9wdC5jaXJjdWxhcik7XG4gICAgfSk7XG4gICAgaWYgKE9iamVjdC5rZXlzKGNpcmN1bGFyVGFyZ2V0cykubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5zZXRUbyh0aGlzLmF4aXNNYW5hZ2VyLm1hcChjaXJjdWxhclRhcmdldHMsIGZ1bmN0aW9uICh2LCBvcHQpIHtcbiAgICAgICAgcmV0dXJuIGdldENpcmN1bGF0ZWRQb3Modiwgb3B0LnJhbmdlLCBvcHQuY2lyY3VsYXIpO1xuICAgICAgfSkpO1xuICAgIH1cbiAgICB0aGlzLmludGVycnVwdE1hbmFnZXIuc2V0SW50ZXJydXB0KGZhbHNlKTtcbiAgICB0aGlzLmV2ZW50TWFuYWdlci50cmlnZ2VyQW5pbWF0aW9uRW5kKCEhYmVmb3JlUGFyYW0pO1xuICAgIGlmICh0aGlzLmF4aXNNYW5hZ2VyLmlzT3V0c2lkZSgpKSB7XG4gICAgICB0aGlzLnJlc3RvcmUoYmVmb3JlUGFyYW0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmZpbmlzaCghIWJlZm9yZVBhcmFtKTtcbiAgICB9XG4gIH07XG4gIF9fcHJvdG8uZmluaXNoID0gZnVuY3Rpb24gKGlzVHJ1c3RlZCkge1xuICAgIHRoaXMuX2FuaW1hdGVQYXJhbSA9IG51bGw7XG4gICAgdGhpcy5pbnRlcnJ1cHRNYW5hZ2VyLnNldEludGVycnVwdChmYWxzZSk7XG4gICAgdGhpcy5ldmVudE1hbmFnZXIudHJpZ2dlckZpbmlzaChpc1RydXN0ZWQpO1xuICB9O1xuICBfX3Byb3RvLmdldFVzZXJDb250cm9sID0gZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgdmFyIHVzZXJXaXNoID0gcGFyYW0uc2V0VG8oKTtcbiAgICB1c2VyV2lzaC5kZXN0UG9zID0gdGhpcy5heGlzTWFuYWdlci5nZXQodXNlcldpc2guZGVzdFBvcyk7XG4gICAgdXNlcldpc2guZHVyYXRpb24gPSBjbGFtcCh1c2VyV2lzaC5kdXJhdGlvbiwgdGhpcy5fb3B0aW9ucy5taW5pbXVtRHVyYXRpb24sIHRoaXMuX29wdGlvbnMubWF4aW11bUR1cmF0aW9uKTtcbiAgICByZXR1cm4gdXNlcldpc2g7XG4gIH07XG4gIF9fcHJvdG8uYW5pbWF0ZVRvID0gZnVuY3Rpb24gKGRlc3RQb3MsIGR1cmF0aW9uLCBvcHRpb24pIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHRoaXMuc3RvcEFuaW1hdGlvbigpO1xuICAgIHZhciBwYXJhbSA9IHRoaXMuX2NyZWF0ZUFuaW1hdGlvblBhcmFtKGRlc3RQb3MsIGR1cmF0aW9uLCBvcHRpb24pO1xuICAgIHZhciBkZXBhUG9zID0gX19hc3NpZ24oe30sIHBhcmFtLmRlcGFQb3MpO1xuICAgIHZhciByZXRUcmlnZ2VyID0gdGhpcy5ldmVudE1hbmFnZXIudHJpZ2dlckFuaW1hdGlvblN0YXJ0KHBhcmFtKTtcbiAgICAvLyB0byBjb250cm9sXG4gICAgdmFyIHVzZXJXaXNoID0gdGhpcy5nZXRVc2VyQ29udHJvbChwYXJhbSk7XG4gICAgLy8gWW91IGNhbid0IHN0b3AgdGhlICdhbmltYXRpb25TdGFydCcgZXZlbnQgd2hlbiAnY2lyY3VsYXInIGlzIHRydWUuXG4gICAgaWYgKCFyZXRUcmlnZ2VyICYmIHRoaXMuYXhpc01hbmFnZXIuZXZlcnkodXNlcldpc2guZGVzdFBvcywgZnVuY3Rpb24gKHYsIG9wdCkge1xuICAgICAgcmV0dXJuIGlzQ2lyY3VsYXJhYmxlKHYsIG9wdC5yYW5nZSwgb3B0LmNpcmN1bGFyKTtcbiAgICB9KSkge1xuICAgICAgY29uc29sZS53YXJuKFwiWW91IGNhbid0IHN0b3AgdGhlICdhbmltYXRpb24nIGV2ZW50IHdoZW4gJ2NpcmN1bGFyJyBpcyB0cnVlLlwiKTtcbiAgICB9XG4gICAgaWYgKHJldFRyaWdnZXIgJiYgIWVxdWFsKHVzZXJXaXNoLmRlc3RQb3MsIGRlcGFQb3MpKSB7XG4gICAgICB2YXIgaW5wdXRFdmVudCA9IChvcHRpb24gPT09IG51bGwgfHwgb3B0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb24uZXZlbnQpIHx8IG51bGw7XG4gICAgICB0aGlzLl9hbmltYXRlTG9vcCh7XG4gICAgICAgIGRlcGFQb3M6IGRlcGFQb3MsXG4gICAgICAgIGRlc3RQb3M6IHVzZXJXaXNoLmRlc3RQb3MsXG4gICAgICAgIGR1cmF0aW9uOiB1c2VyV2lzaC5kdXJhdGlvbixcbiAgICAgICAgZGVsdGE6IHRoaXMuYXhpc01hbmFnZXIuZ2V0RGVsdGEoZGVwYVBvcywgdXNlcldpc2guZGVzdFBvcyksXG4gICAgICAgIGlzVHJ1c3RlZDogISFpbnB1dEV2ZW50LFxuICAgICAgICBpbnB1dEV2ZW50OiBpbnB1dEV2ZW50LFxuICAgICAgICBpbnB1dDogKG9wdGlvbiA9PT0gbnVsbCB8fCBvcHRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbi5pbnB1dCkgfHwgbnVsbFxuICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMuYW5pbWF0aW9uRW5kKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIF9fcHJvdG8uc2V0VG8gPSBmdW5jdGlvbiAocG9zLCBkdXJhdGlvbikge1xuICAgIGlmIChkdXJhdGlvbiA9PT0gdm9pZCAwKSB7XG4gICAgICBkdXJhdGlvbiA9IDA7XG4gICAgfVxuICAgIHZhciBheGVzID0gT2JqZWN0LmtleXMocG9zKTtcbiAgICB2YXIgb3JnUG9zID0gdGhpcy5heGlzTWFuYWdlci5nZXQoYXhlcyk7XG4gICAgaWYgKGVxdWFsKHBvcywgb3JnUG9zKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRoaXMuaW50ZXJydXB0TWFuYWdlci5zZXRJbnRlcnJ1cHQodHJ1ZSk7XG4gICAgdmFyIG1vdmVkUG9zID0gZmlsdGVyKHBvcywgZnVuY3Rpb24gKHYsIGspIHtcbiAgICAgIHJldHVybiBvcmdQb3Nba10gIT09IHY7XG4gICAgfSk7XG4gICAgaWYgKCFPYmplY3Qua2V5cyhtb3ZlZFBvcykubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgbW92ZWRQb3MgPSB0aGlzLmF4aXNNYW5hZ2VyLm1hcChtb3ZlZFBvcywgZnVuY3Rpb24gKHYsIG9wdCkge1xuICAgICAgdmFyIHJhbmdlID0gb3B0LnJhbmdlLFxuICAgICAgICBjaXJjdWxhciA9IG9wdC5jaXJjdWxhcjtcbiAgICAgIGlmIChjaXJjdWxhciAmJiAoY2lyY3VsYXJbMF0gfHwgY2lyY3VsYXJbMV0pKSB7XG4gICAgICAgIHJldHVybiB2O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGdldEluc2lkZVBvc2l0aW9uKHYsIHJhbmdlLCBjaXJjdWxhcik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKGVxdWFsKG1vdmVkUG9zLCBvcmdQb3MpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKGR1cmF0aW9uID4gMCkge1xuICAgICAgdGhpcy5hbmltYXRlVG8obW92ZWRQb3MsIGR1cmF0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdG9wQW5pbWF0aW9uKCk7XG4gICAgICB0aGlzLmV2ZW50TWFuYWdlci50cmlnZ2VyQ2hhbmdlKG1vdmVkUG9zKTtcbiAgICAgIHRoaXMuZmluaXNoKGZhbHNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIF9fcHJvdG8uc2V0QnkgPSBmdW5jdGlvbiAocG9zLCBkdXJhdGlvbikge1xuICAgIGlmIChkdXJhdGlvbiA9PT0gdm9pZCAwKSB7XG4gICAgICBkdXJhdGlvbiA9IDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnNldFRvKG1hcCh0aGlzLmF4aXNNYW5hZ2VyLmdldChPYmplY3Qua2V5cyhwb3MpKSwgZnVuY3Rpb24gKHYsIGspIHtcbiAgICAgIHJldHVybiB2ICsgcG9zW2tdO1xuICAgIH0pLCBkdXJhdGlvbik7XG4gIH07XG4gIF9fcHJvdG8uc2V0T3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdGhpcy5fb3B0aW9ucyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCB0aGlzLl9vcHRpb25zKSwgb3B0aW9ucyk7XG4gIH07XG4gIF9fcHJvdG8uX2NyZWF0ZUFuaW1hdGlvblBhcmFtID0gZnVuY3Rpb24gKHBvcywgZHVyYXRpb24sIG9wdGlvbikge1xuICAgIHZhciBkZXBhUG9zID0gdGhpcy5heGlzTWFuYWdlci5nZXQoKTtcbiAgICB2YXIgZGVzdFBvcyA9IHBvcztcbiAgICB2YXIgaW5wdXRFdmVudCA9IChvcHRpb24gPT09IG51bGwgfHwgb3B0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb24uZXZlbnQpIHx8IG51bGw7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRlcGFQb3M6IGRlcGFQb3MsXG4gICAgICBkZXN0UG9zOiBkZXN0UG9zLFxuICAgICAgZHVyYXRpb246IGNsYW1wKGR1cmF0aW9uLCB0aGlzLl9vcHRpb25zLm1pbmltdW1EdXJhdGlvbiwgdGhpcy5fb3B0aW9ucy5tYXhpbXVtRHVyYXRpb24pLFxuICAgICAgZGVsdGE6IHRoaXMuYXhpc01hbmFnZXIuZ2V0RGVsdGEoZGVwYVBvcywgZGVzdFBvcyksXG4gICAgICBpbnB1dEV2ZW50OiBpbnB1dEV2ZW50LFxuICAgICAgaW5wdXQ6IChvcHRpb24gPT09IG51bGwgfHwgb3B0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb24uaW5wdXQpIHx8IG51bGwsXG4gICAgICBpc1RydXN0ZWQ6ICEhaW5wdXRFdmVudCxcbiAgICAgIGRvbmU6IHRoaXMuYW5pbWF0aW9uRW5kXG4gICAgfTtcbiAgfTtcbiAgX19wcm90by5fYW5pbWF0ZUxvb3AgPSBmdW5jdGlvbiAocGFyYW0sIGNvbXBsZXRlKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBpZiAocGFyYW0uZHVyYXRpb24pIHtcbiAgICAgIHRoaXMuX2FuaW1hdGVQYXJhbSA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBwYXJhbSksIHtcbiAgICAgICAgc3RhcnRUaW1lOiBuZXcgRGF0ZSgpLmdldFRpbWUoKVxuICAgICAgfSk7XG4gICAgICB2YXIgb3JpZ2luYWxJbnRlbmRlZFBvc18xID0gbWFwKHBhcmFtLmRlc3RQb3MsIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHJldHVybiB2O1xuICAgICAgfSk7XG4gICAgICB2YXIgc3RhdGVfMSA9IHRoaXMuX2luaXRTdGF0ZSh0aGlzLl9hbmltYXRlUGFyYW0pO1xuICAgICAgdmFyIGxvb3BfMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMuX3JhZiA9IG51bGw7XG4gICAgICAgIHZhciBhbmltYXRlUGFyYW0gPSBfdGhpcy5fYW5pbWF0ZVBhcmFtO1xuICAgICAgICB2YXIgbmV4dFN0YXRlID0gX3RoaXMuX2dldE5leHRTdGF0ZShzdGF0ZV8xKTtcbiAgICAgICAgdmFyIGlzQ2FuY2VsZWQgPSAhX3RoaXMuZXZlbnRNYW5hZ2VyLnRyaWdnZXJDaGFuZ2UobmV4dFN0YXRlLnBvcywgc3RhdGVfMS5wb3MpO1xuICAgICAgICBzdGF0ZV8xID0gbmV4dFN0YXRlO1xuICAgICAgICBpZiAobmV4dFN0YXRlLmZpbmlzaGVkKSB7XG4gICAgICAgICAgYW5pbWF0ZVBhcmFtLmRlc3RQb3MgPSBfdGhpcy5fZ2V0RmluYWxQb3MoYW5pbWF0ZVBhcmFtLmRlc3RQb3MsIG9yaWdpbmFsSW50ZW5kZWRQb3NfMSk7XG4gICAgICAgICAgaWYgKCFlcXVhbChhbmltYXRlUGFyYW0uZGVzdFBvcywgX3RoaXMuYXhpc01hbmFnZXIuZ2V0KE9iamVjdC5rZXlzKGFuaW1hdGVQYXJhbS5kZXN0UG9zKSkpKSB7XG4gICAgICAgICAgICBfdGhpcy5ldmVudE1hbmFnZXIudHJpZ2dlckNoYW5nZShhbmltYXRlUGFyYW0uZGVzdFBvcywgbmV4dFN0YXRlLnBvcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbXBsZXRlKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQ2FuY2VsZWQpIHtcbiAgICAgICAgICBfdGhpcy5maW5pc2goZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF90aGlzLl9yYWYgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUkMShsb29wXzEpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgbG9vcF8xKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZXZlbnRNYW5hZ2VyLnRyaWdnZXJDaGFuZ2UocGFyYW0uZGVzdFBvcyk7XG4gICAgICBjb21wbGV0ZSgpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIEdldCBlc3RpbWF0ZWQgZmluYWwgdmFsdWUuXG4gICAqXG4gICAqIElmIGRlc3RQb3MgaXMgd2l0aGluIHRoZSAnZXJyb3IgcmFuZ2UnIG9mIHRoZSBvcmlnaW5hbCBpbnRlbmRlZCBwb3NpdGlvbiwgdGhlIGluaXRpYWwgaW50ZW5kZWQgcG9zaXRpb24gaXMgcmV0dXJuZWQuXG4gICAqICAgLSBlZy4gb3JpZ2luYWwgaW50ZW5kZWQgcG9zOiAxMDAsIGRlc3RQb3M6IDEwMC4wMDAwMDAwMDA0ID09PiByZXR1cm4gMTAwO1xuICAgKiBJZiBkZXN0IFBvcyBpcyBvdXRzaWRlIHRoZSAncmFuZ2Ugb2YgZXJyb3InIGNvbXBhcmVkIHRvIHRoZSBvcmlnaW5hbGx5IGludGVuZGVkIHBvcywgaXQgaXMgcmV0dXJuZWQgcm91bmRlZCBiYXNlZCBvbiB0aGUgb3JpZ2luYWxseSBpbnRlbmRlZCBwb3MuXG4gICAqICAgLSBlZy4gb3JpZ2luYWwgaW50ZW5kZWQgcG9zOiAxMDAuMTIzIGRlc3RQb3M6IDUwLjEyMzQ1ID0+IHJldHVybiA1MC4xMjNcbiAgICogQHBhcmFtIG9yaWdpbmFsSW50ZW5kZWRQb3NcbiAgICogQHBhcmFtIGRlc3RQb3NcbiAgICovXG4gIF9fcHJvdG8uX2dldEZpbmFsUG9zID0gZnVuY3Rpb24gKGRlc3RQb3MsIG9yaWdpbmFsSW50ZW5kZWRQb3MpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIC8vIGNvbXBhcmUgZGVzdFBvcyBhbmQgb3JpZ2luYWxJbnRlbmRlZFBvc1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbiAgICB2YXIgRVJST1JfTElNSVQgPSAwLjAwMDAwMTtcbiAgICB2YXIgZmluYWxQb3MgPSBtYXAoZGVzdFBvcywgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgIGlmICh2YWx1ZSA+PSBvcmlnaW5hbEludGVuZGVkUG9zW2tleV0gLSBFUlJPUl9MSU1JVCAmJiB2YWx1ZSA8PSBvcmlnaW5hbEludGVuZGVkUG9zW2tleV0gKyBFUlJPUl9MSU1JVCkge1xuICAgICAgICAvLyBJbiBlcnJvciByYW5nZSwgcmV0dXJuIG9yaWdpbmFsIGludGVuZGVkXG4gICAgICAgIHJldHVybiBvcmlnaW5hbEludGVuZGVkUG9zW2tleV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBPdXQgb2YgZXJyb3IgcmFuZ2UsIHJldHVybiByb3VuZGVkIHBvcy5cbiAgICAgICAgdmFyIHJvdW5kVW5pdCA9IF90aGlzLl9nZXRSb3VuZFVuaXQodmFsdWUsIGtleSk7XG4gICAgICAgIHZhciByZXN1bHQgPSByb3VuZE51bWJlcih2YWx1ZSwgcm91bmRVbml0KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZmluYWxQb3M7XG4gIH07XG4gIF9fcHJvdG8uX2dldFJvdW5kVW5pdCA9IGZ1bmN0aW9uICh2YWwsIGtleSkge1xuICAgIHZhciByb3VuZFVuaXQgPSB0aGlzLl9vcHRpb25zLnJvdW5kOyAvLyBtYW51YWwgbW9kZVxuICAgIHZhciBtaW5Sb3VuZFVuaXQgPSBudWxsOyAvLyBhdXRvIG1vZGVcbiAgICAvLyBhdXRvIG1vZGVcbiAgICBpZiAoIXJvdW5kVW5pdCkge1xuICAgICAgLy8gR2V0IG1pbmltdW0gcm91bmQgdW5pdFxuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLmF4aXNNYW5hZ2VyLmdldEF4aXNPcHRpb25zKGtleSk7XG4gICAgICBtaW5Sb3VuZFVuaXQgPSBpbnZlcnNlUG93KE1hdGgubWF4KGdldERlY2ltYWxQbGFjZShvcHRpb25zLnJhbmdlWzBdKSwgZ2V0RGVjaW1hbFBsYWNlKG9wdGlvbnMucmFuZ2VbMV0pLCBnZXREZWNpbWFsUGxhY2UodmFsKSkpO1xuICAgIH1cbiAgICByZXR1cm4gbWluUm91bmRVbml0IHx8IHJvdW5kVW5pdDtcbiAgfTtcbiAgcmV0dXJuIEFuaW1hdGlvbk1hbmFnZXI7XG59KCk7XG5cbnZhciBFYXNpbmdNYW5hZ2VyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzJDEoRWFzaW5nTWFuYWdlciwgX3N1cGVyKTtcbiAgZnVuY3Rpb24gRWFzaW5nTWFuYWdlcigpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICBfdGhpcy5fdXNlRHVyYXRpb24gPSB0cnVlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICB2YXIgX19wcm90byA9IEVhc2luZ01hbmFnZXIucHJvdG90eXBlO1xuICBfX3Byb3RvLmludGVycG9sYXRlID0gZnVuY3Rpb24gKGRpc3BsYWNlbWVudCwgdGhyZXNob2xkKSB7XG4gICAgdmFyIGluaXRTbG9wZSA9IHRoaXMuX2Vhc2luZygwLjAwMDAxKSAvIDAuMDAwMDE7XG4gICAgcmV0dXJuIHRoaXMuX2Vhc2luZyhkaXNwbGFjZW1lbnQgLyAodGhyZXNob2xkICogaW5pdFNsb3BlKSkgKiB0aHJlc2hvbGQ7XG4gIH07XG4gIF9fcHJvdG8udXBkYXRlQW5pbWF0aW9uID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgX2E7XG4gICAgdmFyIGFuaW1hdGVQYXJhbSA9IHRoaXMuX2FuaW1hdGVQYXJhbTtcbiAgICBpZiAoIWFuaW1hdGVQYXJhbSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgZGlmZlRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIGFuaW1hdGVQYXJhbS5zdGFydFRpbWU7XG4gICAgdmFyIHBvcyA9IChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZGVzdFBvcykgfHwgYW5pbWF0ZVBhcmFtLmRlc3RQb3M7XG4gICAgdmFyIGR1cmF0aW9uID0gKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmR1cmF0aW9uKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBhbmltYXRlUGFyYW0uZHVyYXRpb247XG4gICAgaWYgKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucmVzdGFydCkgfHwgZHVyYXRpb24gPD0gZGlmZlRpbWUpIHtcbiAgICAgIHRoaXMuc2V0VG8ocG9zLCBkdXJhdGlvbiAtIGRpZmZUaW1lKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kZXN0UG9zKSB7XG4gICAgICB2YXIgY3VycmVudFBvcyA9IHRoaXMuYXhpc01hbmFnZXIuZ2V0KCk7XG4gICAgICAvLyBXaGVuIGRlc3RpbmF0aW9uIGlzIGNoYW5nZWQsIG5ldyBkZWx0YSBzaG91bGQgYmUgY2FsY3VsYXRlZCBhcyByZW1haW5pbmcgcGVyY2VudC5cbiAgICAgIC8vIEZvciBleGFtcGxlLCBtb3ZpbmcgeDowLCB5OjAgdG8geDoyMDAsIHk6MjAwIGFuZCBpdCBoYXMgY3VycmVudCBlYXNpbmcgcGVyY2VudCBvZiA5MiUuIGNvb3JkaW5hdGUgaXMgeDoxODQgYW5kIHk6MTg0XG4gICAgICAvLyBJZiBkZXN0aW5hdGlvbiBjaGFuZ2VzIHRvIHg6MzAwLCB5OjMwMC4geGRlbHRhOjIwMCwgeWRlbHRhOjIwMCBjaGFuZ2VzIHRvIHhkZWx0YToxMTYsIHlkZWx0YToxMTYgYW5kIHVzZSByZW1haW5pbmcgZWFzaW5nUGVyIGFzIDEwMCUsIG5vdCA4JSBhcyBwcmV2aW91cy5cbiAgICAgIC8vIFRoZXJlZm9yZSwgb3JpZ2luYWwgZWFzaW5nUGVyIGJ5IHRpbWUgaXMga2VwdC4gQW5kIGRpdmlkZWQgYnkgKDEgLSBzZWxmLl9pbml0aWFsRWFzaW5nUGVyKSB3aGljaCBtZWFucyBuZXcgdG90YWwgZWFzaW5nIHBlcmNlbnQuIExpa2UgY2FsY3VsYXRpbmcgOCUgYXMgMTAwJS5cbiAgICAgIHRoaXMuX2luaXRpYWxFYXNpbmdQZXIgPSB0aGlzLl9wcmV2RWFzaW5nUGVyO1xuICAgICAgYW5pbWF0ZVBhcmFtLmRlbHRhID0gdGhpcy5heGlzTWFuYWdlci5nZXREZWx0YShjdXJyZW50UG9zLCBwb3MpO1xuICAgICAgYW5pbWF0ZVBhcmFtLmRlc3RQb3MgPSBwb3M7XG4gICAgfVxuICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZHVyYXRpb24pIHtcbiAgICAgIHZhciByYXRpbyA9IChkaWZmVGltZSArIHRoaXMuX2R1cmF0aW9uT2Zmc2V0KSAvIGFuaW1hdGVQYXJhbS5kdXJhdGlvbjtcbiAgICAgIC8vIFVzZSBkdXJhdGlvbk9mZnNldCBmb3Iga2VlcGluZyBhbmltYXRpb24gcmF0aW8gYWZ0ZXIgZHVyYXRpb24gaXMgY2hhbmdlZC5cbiAgICAgIC8vIG5ld1JhdGlvID0gKGRpZmZUaW1lICsgbmV3RHVyYXRpb25PZmZzZXQpIC8gbmV3RHVyYXRpb24gPSBvbGRSYXRpb1xuICAgICAgLy8gbmV3RHVyYXRpb25PZmZzZXQgPSBvbGRSYXRpbyAqIG5ld0R1cmF0aW9uIC0gZGlmZlRpbWVcbiAgICAgIHRoaXMuX2R1cmF0aW9uT2Zmc2V0ID0gcmF0aW8gKiBkdXJhdGlvbiAtIGRpZmZUaW1lO1xuICAgICAgYW5pbWF0ZVBhcmFtLmR1cmF0aW9uID0gZHVyYXRpb247XG4gICAgfVxuICB9O1xuICBfX3Byb3RvLl9pbml0U3RhdGUgPSBmdW5jdGlvbiAoaW5mbykge1xuICAgIHRoaXMuX2luaXRpYWxFYXNpbmdQZXIgPSAwO1xuICAgIHRoaXMuX3ByZXZFYXNpbmdQZXIgPSAwO1xuICAgIHRoaXMuX2R1cmF0aW9uT2Zmc2V0ID0gMDtcbiAgICByZXR1cm4ge1xuICAgICAgcG9zOiBpbmZvLmRlcGFQb3MsXG4gICAgICBlYXNpbmdQZXI6IDAsXG4gICAgICBmaW5pc2hlZDogZmFsc2VcbiAgICB9O1xuICB9O1xuICBfX3Byb3RvLl9nZXROZXh0U3RhdGUgPSBmdW5jdGlvbiAocHJldlN0YXRlKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB2YXIgYW5pbWF0ZVBhcmFtID0gdGhpcy5fYW5pbWF0ZVBhcmFtO1xuICAgIHZhciBwcmV2UG9zID0gcHJldlN0YXRlLnBvcztcbiAgICB2YXIgZGVzdFBvcyA9IGFuaW1hdGVQYXJhbS5kZXN0UG9zO1xuICAgIHZhciBkaXJlY3Rpb25zID0gbWFwKHByZXZQb3MsIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICByZXR1cm4gdmFsdWUgPD0gZGVzdFBvc1trZXldID8gMSA6IC0xO1xuICAgIH0pO1xuICAgIHZhciBkaWZmVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gYW5pbWF0ZVBhcmFtLnN0YXJ0VGltZTtcbiAgICB2YXIgcmF0aW8gPSAoZGlmZlRpbWUgKyB0aGlzLl9kdXJhdGlvbk9mZnNldCkgLyBhbmltYXRlUGFyYW0uZHVyYXRpb247XG4gICAgdmFyIGVhc2luZ1BlciA9IHRoaXMuX2Vhc2luZyhyYXRpbyk7XG4gICAgdmFyIHRvUG9zID0gdGhpcy5heGlzTWFuYWdlci5tYXAocHJldlBvcywgZnVuY3Rpb24gKHBvcywgb3B0aW9ucywga2V5KSB7XG4gICAgICB2YXIgbmV4dFBvcyA9IHJhdGlvID49IDEgPyBkZXN0UG9zW2tleV0gOiBwb3MgKyBhbmltYXRlUGFyYW0uZGVsdGFba2V5XSAqIChlYXNpbmdQZXIgLSBfdGhpcy5fcHJldkVhc2luZ1BlcikgLyAoMSAtIF90aGlzLl9pbml0aWFsRWFzaW5nUGVyKTtcbiAgICAgIC8vIFN1YnRyYWN0IGRpc3RhbmNlIGZyb20gZGlzdGFuY2UgYWxyZWFkeSBtb3ZlZC5cbiAgICAgIC8vIFJlY2FsY3VsYXRlIHRoZSByZW1haW5pbmcgZGlzdGFuY2UuXG4gICAgICAvLyBGaXggdGhlIGJvdW5jaW5nIHBoZW5vbWVub24gYnkgY2hhbmdpbmcgdGhlIHJhbmdlLlxuICAgICAgdmFyIGNpcmN1bGF0ZWRQb3MgPSBnZXRDaXJjdWxhdGVkUG9zKG5leHRQb3MsIG9wdGlvbnMucmFuZ2UsIG9wdGlvbnMuY2lyY3VsYXIpO1xuICAgICAgaWYgKG5leHRQb3MgIT09IGNpcmN1bGF0ZWRQb3MpIHtcbiAgICAgICAgLy8gY2lyY3VsYXJcbiAgICAgICAgdmFyIHJhbmdlT2Zmc2V0ID0gZGlyZWN0aW9uc1trZXldICogKG9wdGlvbnMucmFuZ2VbMV0gLSBvcHRpb25zLnJhbmdlWzBdKTtcbiAgICAgICAgZGVzdFBvc1trZXldIC09IHJhbmdlT2Zmc2V0O1xuICAgICAgICBwcmV2UG9zW2tleV0gLT0gcmFuZ2VPZmZzZXQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2lyY3VsYXRlZFBvcztcbiAgICB9KTtcbiAgICB0aGlzLl9wcmV2RWFzaW5nUGVyID0gZWFzaW5nUGVyO1xuICAgIHJldHVybiB7XG4gICAgICBwb3M6IHRvUG9zLFxuICAgICAgZWFzaW5nUGVyOiBlYXNpbmdQZXIsXG4gICAgICBmaW5pc2hlZDogZWFzaW5nUGVyID49IDFcbiAgICB9O1xuICB9O1xuICBfX3Byb3RvLl9lYXNpbmcgPSBmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiBwID4gMSA/IDEgOiB0aGlzLl9vcHRpb25zLmVhc2luZyhwKTtcbiAgfTtcbiAgcmV0dXJuIEVhc2luZ01hbmFnZXI7XG59KEFuaW1hdGlvbk1hbmFnZXIpO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEF4aXNPcHRpb24gVGhlIEF4aXMgaW5mb3JtYXRpb24uIFRoZSBrZXkgb2YgdGhlIGF4aXMgc3BlY2lmaWVzIHRoZSBuYW1lIHRvIHVzZSBhcyB0aGUgbG9naWNhbCB2aXJ0dWFsIGNvb3JkaW5hdGUgc3lzdGVtLlxuICogQGtvIOy2lSDsoJXrs7QuIOy2leydmCDtgqTripQg64W866as7KCB7J24IOqwgOyDgSDsooztkZzqs4TroZwg7IKs7Jqp7ZWgIOydtOumhOydhCDsp4DsoJXtlZzri6QuXG4gKiBAcGFyYW0ge051bWJlcltdfSBbcmFuZ2VdIFRoZSByYW5nZSBvZiBjb29yZGluYXRlIDxrbz7sooztkZwg67KU7JyEPC9rbz5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbcmFuZ2VbMF09MF0gVGhlIGNvb3JkaW5hdGUgb2YgdGhlIG1pbmltdW0gPGtvPuy1nOyGjCDsooztkZw8L2tvPlxuICogQHBhcmFtIHtOdW1iZXJ9IFtyYW5nZVsxXT0wXSBUaGUgY29vcmRpbmF0ZSBvZiB0aGUgbWF4aW11bSA8a28+7LWc64yAIOyijO2RnDwva28+XG4gKiBAcGFyYW0ge051bWJlcn0gW3N0YXJ0UG9zPXJhbmdlWzBdXSBUaGUgY29vcmRpbmF0ZXMgdG8gYmUgbW92ZWQgd2hlbiBjcmVhdGluZyBhbiBpbnN0YW5jZSA8a28+7J247Iqk7YS07IqkIOyDneyEseyLnCDsnbTrj5ntlaAg7KKM7ZGcPC9rbz5cbiAqIEBwYXJhbSB7TnVtYmVyW119IFtib3VuY2VdIFRoZSBzaXplIG9mIGJvdW5jaW5nIGFyZWEuIFRoZSBjb29yZGluYXRlcyBjYW4gZXhjZWVkIHRoZSBjb29yZGluYXRlIGFyZWEgYXMgbXVjaCBhcyB0aGUgYm91bmNpbmcgYXJlYSBiYXNlZCBvbiB1c2VyIGFjdGlvbi4gSWYgdGhlIGNvb3JkaW5hdGVzIGRvZXMgbm90IGV4Y2VlZCB0aGUgYm91bmNpbmcgYXJlYSB3aGVuIGFuIGVsZW1lbnQgaXMgZHJhZ2dlZCwgdGhlIGNvb3JkaW5hdGVzIHdoZXJlIGJvdW5jaW5nIGVmZmVjdHMgYXJlIGFwcGxpZWQgYXJlIHJldHVuZWQgYmFjayBpbnRvIHRoZSBjb29yZGluYXRlIGFyZWE8a28+67CU7Jq07IqkIOyYgeyXreydmCDtgazquLAuIOyCrOyaqeyekOydmCDrj5nsnpHsl5Ag65Sw6528IOyijO2RnOqwgCDsooztkZwg7JiB7Jet7J2EIOuEmOyWtCDrsJTsmrTsiqQg7JiB7Jet7J2YIO2BrOq4sOunjO2BvCDrjZQg7J2064+Z7ZWgIOyImCDsnojri6QuIOyCrOyaqeyekOqwgCDrgYzslrTri6Qg64aT64qUIOuPmeyekeydhCDtlojsnYQg65WMIOyijO2RnOqwgCDrsJTsmrTsiqQg7JiB7Jet7JeQIOyeiOycvOuptCwg67CU7Jq07IqkIO2aqOqzvOqwgCDsoIHsmqnrkJwg7KKM7ZGc6rCAIOuLpOyLnCDsooztkZwg7JiB7JetIOyViOycvOuhnCDrk6TslrTsmKjri6Q8L2tvPlxuICogQHBhcmFtIHtOdW1iZXJ9IFtib3VuY2VbMF09MF0gVGhlIHNpemUgb2YgY29vcmRpbmF0ZSBvZiB0aGUgbWluaW11bSBhcmVhIDxrbz7stZzshowg7KKM7ZGcIOuwlOyatOyKpCDsmIHsl63snZgg7YGs6riwPC9rbz5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbYm91bmNlWzFdPTBdIFRoZSBzaXplIG9mIGNvb3JkaW5hdGUgb2YgdGhlIG1heGltdW0gYXJlYSA8a28+7LWc64yAIOyijO2RnCDrsJTsmrTsiqQg7JiB7Jet7J2YIO2BrOq4sDwva28+XG4gKiBAcGFyYW0ge0Jvb2xlYW5bXX0gW2NpcmN1bGFyXSBJbmRpY2F0ZXMgd2hldGhlciBhIGNpcmN1bGFyIGVsZW1lbnQgaXMgYXZhaWxhYmxlLiBJZiBpdCBpcyBzZXQgdG8gXCJ0cnVlXCIgYW5kIGFuIGVsZW1lbnQgaXMgZHJhZ2dlZCBvdXRzaWRlIHRoZSBjb29yZGluYXRlIGFyZWEsIHRoZSBlbGVtZW50IHdpbGwgYXBwZWFyIG9uIHRoZSBvdGhlciBzaWRlLjxrbz7siJztmZgg7Jes67aALiAndHJ1ZSfroZwg7ISk7KCV7ZWcIOuwqe2WpeydmCDsooztkZwg7JiB7JetIOuwluycvOuhnCDsl5jrpqzrqLztirjqsIAg7J2064+Z7ZWY66m0IOuwmOuMgCDrsKntlqXsl5DshJwg7JeY66as66i87Yq46rCAIOuCmO2DgOuCnOuLpDwva28+XG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtjaXJjdWxhclswXT1mYWxzZV0gSW5kaWNhdGVzIHdoZXRoZXIgdG8gY2lyY3VsYXRlIHRvIHRoZSBjb29yZGluYXRlIG9mIHRoZSBtaW5pbXVtIDxrbz7stZzshowg7KKM7ZGcIOuwqe2WpeydmCDsiJztmZgg7Jes67aAPC9rbz5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NpcmN1bGFyWzFdPWZhbHNlXSBJbmRpY2F0ZXMgd2hldGhlciB0byBjaXJjdWxhdGUgdG8gdGhlIGNvb3JkaW5hdGUgb2YgdGhlIG1heGltdW0gPGtvPuy1nOuMgCDsooztkZwg67Cp7Zal7J2YIOyInO2ZmCDsl6zrtoA8L2tvPlxuICoqL1xuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBBeGVzT3B0aW9uIFRoZSBvcHRpb24gb2JqZWN0IG9mIHRoZSBlZy5BeGVzIG1vZHVsZVxuICogQGtvIGVnLkF4ZXMg66qo65OI7J2YIOyYteyFmCDqsJ3ssrRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtlYXNpbmc9ZWFzaW5nLmVhc2VPdXRDdWJpY10gVGhlIGVhc2luZyBmdW5jdGlvbiB0byBhcHBseSB0byBhbiBhbmltYXRpb24gPGtvPuyVoOuLiOuplOydtOyFmOyXkCDsoIHsmqntlaAgZWFzaW5nIO2VqOyImDwva28+XG4gKiBAcGFyYW0ge051bWJlcn0gW21heGltdW1EdXJhdGlvbj1JbmZpbml0eV0gTWF4aW11bSBkdXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uIDxrbz7qsIDsho3rj4Tsl5Ag7J2Y7ZW0IOyVoOuLiOuplOydtOyFmOydtCDrj5nsnpHtlaAg65WM7J2YIOy1nOuMgCDsooztkZwg7J2064+ZIOyLnOqwhDwva28+XG4gKiBAcGFyYW0ge051bWJlcn0gW21pbmltdW1EdXJhdGlvbj0wXSBNaW5pbXVtIGR1cmF0aW9uIG9mIHRoZSBhbmltYXRpb24gPGtvPuqwgOyGjeuPhOyXkCDsnZjtlbQg7JWg64uI66mU7J207IWY7J20IOuPmeyeke2VoCDrlYzsnZgg7LWc7IaMIOyijO2RnCDsnbTrj5kg7Iuc6rCEPC9rbz5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbZGVjZWxlcmF0aW9uPTAuMDAwNl0gRGVjZWxlcmF0aW9uIG9mIHRoZSBhbmltYXRpb24gd2hlcmUgYWNjZWxlcmF0aW9uIGlzIG1hbnVhbGx5IGVuYWJsZWQgYnkgdXNlci4gQSBoaWdoZXIgdmFsdWUgaW5kaWNhdGVzIHNob3J0ZXIgcnVubmluZyB0aW1lLiA8a28+7IKs7Jqp7J6Q7J2YIOuPmeyekeycvOuhnCDqsIDsho3rj4TqsIAg7KCB7Jqp65CcIOyVoOuLiOuplOydtOyFmOydmCDqsJDsho3rj4QuIOqwkuydtCDrhpLsnYTsiJjroZ0g7JWg64uI66mU7J207IWYIOyLpO2WiSDsi5zqsITsnbQg7Ken7JWE7KeE64ukPC9rbz5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2ludGVycnVwdGFibGU9dHJ1ZV0gSW5kaWNhdGVzIHdoZXRoZXIgYW4gYW5pbWF0aW9uIGlzIGludGVycnVwdGlibGUuXG4gKiAtIHRydWU6IEl0IGNhbiBiZSBwYXVzZWQgb3Igc3RvcHBlZCBieSB1c2VyIGFjdGlvbiBvciB0aGUgQVBJLlxuICogLSBmYWxzZTogSXQgY2Fubm90IGJlIHBhdXNlZCBvciBzdG9wcGVkIGJ5IHVzZXIgYWN0aW9uIG9yIHRoZSBBUEkgd2hpbGUgaXQgaXMgcnVubmluZy5cbiAqIDxrbz7sp4Ttlokg7KSR7J24IOyVoOuLiOuplOydtOyFmCDspJHsp4Ag6rCA64qlIOyXrOu2gC5cbiAqIC0gdHJ1ZTog7IKs7Jqp7J6Q7J2YIOuPmeyekeydtOuCmCBBUEnroZwg7JWg64uI66mU7J207IWY7J2EIOykkeyngO2VoCDsiJgg7J6I64ukLlxuICogLSBmYWxzZTog7JWg64uI66mU7J207IWY7J20IOynhO2WiSDspJHsnbwg65WM64qUIOyCrOyaqeyekOydmCDrj5nsnpHsnbTrgpggQVBJ6rCAIOyggeyaqeuQmOyngCDslYrripTri6Q8L2tvPlxuICogQHBhcmFtIHtOdW1iZXJ9IFtyb3VuZD1udWxsXSBSb3VuZGluZyB1bml0LiBGb3IgZXhhbXBsZSwgMC4xIHJvdW5kcyB0byAwLjEgZGVjaW1hbCBwb2ludCg2LjEyMzQgPT4gNi4xKSwgNSByb3VuZHMgdG8gNSAoOTMgPT4gOTUpXG4gKiBbRGV0YWlsc10oaHR0cHM6Ly9naXRodWIuY29tL25hdmVyL2VnanMtYXhlcy93aWtpL3JvdW5kLW9wdGlvbik8a28+67CY7Jis66a8IOuLqOychC4g7JiI66W8IOuTpOyWtCAwLjEg7J2AIOyGjOyIq+ygkCAwLjEg6rmM7KeAIOuwmOyYrOumvCg2LjEyMzQgPT4gNi4xKSwgNSDripQgNSDri6jsnITroZwg67CY7Jis66a8KDkzID0+IDk1KS5cbiAqIFvsg4HshLjrgrTsmqldKGh0dHBzOi8vZ2l0aHViLmNvbS9uYXZlci9lZ2pzLWF4ZXMvd2lraS9yb3VuZC1vcHRpb24pPC9rbz5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW25lc3RlZD1mYWxzZV0gV2hldGhlciB0aGUgZXZlbnQgcHJvcGFnYXRlcyB0byBvdGhlciBpbnN0YW5jZXMgd2hlbiB0aGUgY29vcmRpbmF0ZXMgcmVhY2ggdGhlIGVuZCBvZiB0aGUgbW92YWJsZSBhcmVhIDxrbz7sooztkZzqsIAg7J2064+ZIOqwgOuKpe2VnCDsmIHsl63snZgg64Gd6rmM7KeAIOuPhOuLrO2WiOydhCDrlYwg64uk66W4IOyduOyKpO2EtOyKpOuTpOuhnOydmCDsnbTrsqTtirgg7KCE7YyMIOyXrOu2gDwva28+XG4gKiovXG4vKipcbiAqIEEgbW9kdWxlIHVzZWQgdG8gY2hhbmdlIHRoZSBpbmZvcm1hdGlvbiBvZiB1c2VyIGFjdGlvbiBlbnRlcmVkIGJ5IHZhcmlvdXMgaW5wdXQgZGV2aWNlcyBzdWNoIGFzIHRvdWNoIHNjcmVlbiBvciBtb3VzZSBpbnRvIHRoZSBsb2dpY2FsIHZpcnR1YWwgY29vcmRpbmF0ZXMuIFlvdSBjYW4gZWFzaWx5IGNyZWF0ZSBhIFVJIHRoYXQgcmVzcG9uZHMgdG8gdXNlciBhY3Rpb25zLlxuICogQGtvIO2EsOy5mCDsnoXroKUg7J6l7LmY64KYIOuniOyasOyKpOyZgCDqsJnsnYAg64uk7JaR7ZWcIOyeheugpSDsnqXsuZjrpbwg7Ya17ZW0IOyghOuLrCDrsJvsnYAg7IKs7Jqp7J6Q7J2YIOuPmeyekeydhCDrhbzrpqzsoIHsnbgg6rCA7IOBIOyijO2RnOuhnCDrs4Dqsr3tlZjripQg66qo65OI7J2064ukLiDsgqzsmqnsnpAg64+Z7J6R7JeQIOuwmOydke2VmOuKlCBVSeulvCDshpDsib3qsowg66eM65Ok7IiYIOyeiOuLpC5cbiAqIEBleHRlbmRzIGVnLkNvbXBvbmVudFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsIEF4aXNPcHRpb24+fSBheGlzIEF4aXMgaW5mb3JtYXRpb24gbWFuYWdlZCBieSBlZy5BeGVzLiBUaGUga2V5IG9mIHRoZSBheGlzIHNwZWNpZmllcyB0aGUgbmFtZSB0byB1c2UgYXMgdGhlIGxvZ2ljYWwgdmlydHVhbCBjb29yZGluYXRlIHN5c3RlbS4gIDxrbz5lZy5BeGVz6rCAIOq0gOumrO2VmOuKlCDstpUg7KCV67O0LiDstpXsnZgg7YKk64qUIOuFvOumrOyggeyduCDqsIDsg4Eg7KKM7ZGc6rOE66GcIOyCrOyaqe2VoCDsnbTrpoTsnYQg7KeA7KCV7ZWc64ukLjwva28+XG4gKiBAcGFyYW0ge0F4ZXNPcHRpb259IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9uIG9iamVjdCBvZiB0aGUgZWcuQXhlcyBtb2R1bGU8a28+ZWcuQXhlcyDrqqjrk4jsnZgg7Ji17IWYIOqwneyytDwva28+XG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCBudW1iZXI+fSBbc3RhcnRQb3M9e31dIFRoZSBjb29yZGluYXRlcyB0byBiZSBtb3ZlZCB3aGVuIGNyZWF0aW5nIGFuIGluc3RhbmNlLiBJdCBpcyBhcHBsaWVkIHdpdGggaGlnaGVyIHByaW9yaXR5IHRoYW4gc3RhcnRQb3Mgb2YgYXhpc09wdGlvbi48a28+7J247Iqk7YS07IqkIOyDneyEseyLnCDsnbTrj5ntlaAg7KKM7ZGcLCBheGlzT3B0aW9u7J2YIHN0YXJ0UG9z67O064ukIOuGkuydgCDsmrDshKDsiJzsnITroZwg7KCB7Jqp65Cc64ukLjwva28+XG4gKlxuICogQHN1cHBvcnQge1wiaWVcIjogXCIxMCtcIiwgXCJjaFwiIDogXCJsYXRlc3RcIiwgXCJmZlwiIDogXCJsYXRlc3RcIiwgIFwic2ZcIiA6IFwibGF0ZXN0XCIsIFwiZWRnZVwiIDogXCJsYXRlc3RcIiwgXCJpb3NcIiA6IFwiNytcIiwgXCJhblwiIDogXCIyLjMrIChleGNlcHQgMy54KVwifVxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiAvLyAxLiBJbml0aWFsaXplIGVnLkF4ZXNcbiAqIGNvbnN0IGF4ZXMgPSBuZXcgZWcuQXhlcyh7XG4gKiAgc29tZXRoaW5nMToge1xuICogICAgcmFuZ2U6IFswLCAxNTBdLFxuICogICAgYm91bmNlOiA1MFxuICogIH0sXG4gKiAgc29tZXRoaW5nMjoge1xuICogICAgcmFuZ2U6IFswLCAyMDBdLFxuICogICAgYm91bmNlOiAxMDBcbiAqICB9LFxuICogIHNvbWV0aGluZ046IHtcbiAqICAgIHJhbmdlOiBbMSwgMTBdLFxuICogIH1cbiAqIH0sIHtcbiAqICBkZWNlbGVyYXRpb24gOiAwLjAwMjRcbiAqIH0pO1xuICpcbiAqIC8vIDIuIGF0dGFjaCBldmVudCBoYW5kbGVyXG4gKiBheGVzLm9uKHtcbiAqICBcImhvbGRcIiA6IGZ1bmN0aW9uKGV2dCkge1xuICogIH0sXG4gKiAgXCJyZWxlYXNlXCIgOiBmdW5jdGlvbihldnQpIHtcbiAqICB9LFxuICogIFwiYW5pbWF0aW9uU3RhcnRcIiA6IGZ1bmN0aW9uKGV2dCkge1xuICogIH0sXG4gKiAgXCJhbmltYXRpb25FbmRcIiA6IGZ1bmN0aW9uKGV2dCkge1xuICogIH0sXG4gKiAgXCJjaGFuZ2VcIiA6IGZ1bmN0aW9uKGV2dCkge1xuICogIH1cbiAqIH0pO1xuICpcbiAqIC8vIDMuIEluaXRpYWxpemUgaW5wdXRUeXBlc1xuICogY29uc3QgcGFuSW5wdXRBcmVhID0gbmV3IGVnLkF4ZXMuUGFuSW5wdXQoXCIjYXJlYVwiLCB7XG4gKiAgc2NhbGU6IFswLjUsIDFdXG4gKiB9KTtcbiAqIGNvbnN0IHBhbklucHV0SG1vdmUgPSBuZXcgZWcuQXhlcy5QYW5JbnB1dChcIiNobW92ZVwiKTtcbiAqIGNvbnN0IHBhbklucHV0Vm1vdmUgPSBuZXcgZWcuQXhlcy5QYW5JbnB1dChcIiN2bW92ZVwiKTtcbiAqIGNvbnN0IHBpbmNoSW5wdXRBcmVhID0gbmV3IGVnLkF4ZXMuUGluY2hJbnB1dChcIiNhcmVhXCIsIHtcbiAqICBzY2FsZTogMS41XG4gKiB9KTtcbiAqXG4gKiAvLyA0LiBDb25uZWN0IGVnLkF4ZXMgYW5kIElucHV0VHlwZXNcbiAqIC8vIFtQYW5JbnB1dF0gV2hlbiB0aGUgbW91c2Ugb3IgdG91Y2hzY3JlZW4gaXMgZG93biBhbmQgbW92ZWQuXG4gKiAvLyBDb25uZWN0IHRoZSAnc29tZXRoaW5nMicgYXhpcyB0byB0aGUgbW91c2Ugb3IgdG91Y2hzY3JlZW4geCBwb3NpdGlvbiBhbmRcbiAqIC8vIGNvbm5lY3QgdGhlICdzb21ldGhpbmdOJyBheGlzIHRvIHRoZSBtb3VzZSBvciB0b3VjaHNjcmVlbiB5IHBvc2l0aW9uLlxuICogYXhlcy5jb25uZWN0KFtcInNvbWV0aGluZzJcIiwgXCJzb21ldGhpbmdOXCJdLCBwYW5JbnB1dEFyZWEpOyAvLyBvciBheGVzLmNvbm5lY3QoXCJzb21ldGhpbmcyIHNvbWV0aGluZ05cIiwgcGFuSW5wdXRBcmVhKTtcbiAqXG4gKiAvLyBDb25uZWN0IG9ubHkgb25lICdzb21ldGhpbmcxJyBheGlzIHRvIHRoZSBtb3VzZSBvciB0b3VjaHNjcmVlbiB4IHBvc2l0aW9uLlxuICogYXhlcy5jb25uZWN0KFtcInNvbWV0aGluZzFcIl0sIHBhbklucHV0SG1vdmUpOyAvLyBvciBheGVzLmNvbm5lY3QoXCJzb21ldGhpbmcxXCIsIHBhbklucHV0SG1vdmUpO1xuICpcbiAqIC8vIENvbm5lY3Qgb25seSBvbmUgJ3NvbWV0aGluZzInIGF4aXMgdG8gdGhlIG1vdXNlIG9yIHRvdWNoc2NyZWVuIHkgcG9zaXRpb24uXG4gKiBheGVzLmNvbm5lY3QoW1wiXCIsIFwic29tZXRoaW5nMlwiXSwgcGFuSW5wdXRWbW92ZSk7IC8vIG9yIGF4ZXMuY29ubmVjdChcIiBzb21ldGhpbmcyXCIsIHBhbklucHV0Vm1vdmUpO1xuICpcbiAqIC8vIFtQaW5jaElucHV0XSBDb25uZWN0ICdzb21ldGhpbmcyJyBheGlzIHdoZW4gdHdvIHBvaW50ZXJzIGFyZSBtb3ZpbmcgdG93YXJkICh6b29tLWluKSBvciBhd2F5IGZyb20gZWFjaCBvdGhlciAoem9vbS1vdXQpLlxuICogYXhlcy5jb25uZWN0KFwic29tZXRoaW5nMlwiLCBwaW5jaElucHV0QXJlYSk7XG4gKiBgYGBcbiAqL1xudmFyIEF4ZXMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMkMShBeGVzLCBfc3VwZXIpO1xuICAvKipcbiAgICpcbiAgICovXG4gIGZ1bmN0aW9uIEF4ZXMoYXhpcywgb3B0aW9ucywgc3RhcnRQb3MpIHtcbiAgICBpZiAoYXhpcyA9PT0gdm9pZCAwKSB7XG4gICAgICBheGlzID0ge307XG4gICAgfVxuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgaWYgKHN0YXJ0UG9zID09PSB2b2lkIDApIHtcbiAgICAgIHN0YXJ0UG9zID0ge307XG4gICAgfVxuICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgX3RoaXMuYXhpcyA9IGF4aXM7XG4gICAgX3RoaXMuX2lucHV0cyA9IFtdO1xuICAgIF90aGlzLm9wdGlvbnMgPSBfX2Fzc2lnbih7XG4gICAgICBlYXNpbmc6IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiAxIC0gTWF0aC5wb3coMSAtIHgsIDMpO1xuICAgICAgfSxcbiAgICAgIGludGVycnVwdGFibGU6IHRydWUsXG4gICAgICBtYXhpbXVtRHVyYXRpb246IEluZmluaXR5LFxuICAgICAgbWluaW11bUR1cmF0aW9uOiAwLFxuICAgICAgZGVjZWxlcmF0aW9uOiAwLjAwMDYsXG4gICAgICByb3VuZDogbnVsbCxcbiAgICAgIG5lc3RlZDogZmFsc2VcbiAgICB9LCBvcHRpb25zKTtcbiAgICBPYmplY3Qua2V5cyhzdGFydFBvcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBfdGhpcy5heGlzW2tleV0uc3RhcnRQb3MgPSBzdGFydFBvc1trZXldO1xuICAgIH0pO1xuICAgIF90aGlzLmludGVycnVwdE1hbmFnZXIgPSBuZXcgSW50ZXJydXB0TWFuYWdlcihfdGhpcy5vcHRpb25zKTtcbiAgICBfdGhpcy5heGlzTWFuYWdlciA9IG5ldyBBeGlzTWFuYWdlcihfdGhpcy5heGlzKTtcbiAgICBfdGhpcy5ldmVudE1hbmFnZXIgPSBuZXcgRXZlbnRNYW5hZ2VyKF90aGlzKTtcbiAgICBfdGhpcy5hbmltYXRpb25NYW5hZ2VyID0gbmV3IEVhc2luZ01hbmFnZXIoX3RoaXMpO1xuICAgIF90aGlzLmlucHV0T2JzZXJ2ZXIgPSBuZXcgSW5wdXRPYnNlcnZlcihfdGhpcyk7XG4gICAgX3RoaXMuZXZlbnRNYW5hZ2VyLnNldEFuaW1hdGlvbk1hbmFnZXIoX3RoaXMuYW5pbWF0aW9uTWFuYWdlcik7XG4gICAgX3RoaXMuZXZlbnRNYW5hZ2VyLnRyaWdnZXJDaGFuZ2UoX3RoaXMuYXhpc01hbmFnZXIuZ2V0KCkpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICB2YXIgX19wcm90byA9IEF4ZXMucHJvdG90eXBlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJob2xkaW5nXCIsIHtcbiAgICAvKipcbiAgICAgKiBAbmFtZSBBeGVzI2hvbGRpbmdcbiAgICAgKiBAZGVzYyBSZXR1cm5zIHRydWUgaWYgYXQgbGVhc3Qgb25lIGlucHV0IGlzIGluIHByb2dyZXNzLlxuICAgICAqIEBrbyDsnoXroKXsnbQg7ZWY64KYIOydtOyDgSDsp4Ttlokg7KSR7J247KeAIOyXrOu2gOulvCDrsJjtmZjtlZzri6QuXG4gICAgICpcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICogY29uc3QgYXhlcyA9IG5ldyBlZy5BeGVzKHtcbiAgICAgKiAgeDoge1xuICAgICAqICAgIHJhbmdlOiBbMCwgMTAwXSxcbiAgICAgKiAgfSxcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIGF4ZXMuaG9sZGluZ1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZXZlbnRNYW5hZ2VyLmhvbGRpbmdDb3VudCA+IDA7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIC8qKlxuICAgKiBDb25uZWN0IHRoZSBheGlzIG9mIGVnLkF4ZXMgdG8gdGhlIGlucHV0VHlwZS5cbiAgICogQGtvIGVnLkF4ZXPsnZgg7LaV6rO8IGlucHV0VHlwZeydhCDsl7DqsrDtlZzri6RcbiAgICogQHBhcmFtIHsoU3RyaW5nW118U3RyaW5nKX0gYXhlcyBUaGUgbmFtZSBvZiB0aGUgYXhpcyB0byBhc3NvY2lhdGUgd2l0aCBpbnB1dFR5cGUgPGtvPmlucHV0VHlwZeqzvCDsl7DqsrDtlaAg7LaV7J2YIOydtOumhDwva28+XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFR5cGUgVGhlIGlucHV0VHlwZSBpbnN0YW5jZSB0byBhc3NvY2lhdGUgd2l0aCB0aGUgYXhpcyBvZiBlZy5BeGVzIDxrbz5lZy5BeGVz7J2YIOy2leqzvCDsl7DqsrDtlaAgaW5wdXRUeXBlIOyduOyKpO2EtOyKpDwva28+XG4gICAqIEByZXR1cm4ge2VnLkF4ZXN9IEFuIGluc3RhbmNlIG9mIGEgbW9kdWxlIGl0c2VsZiA8a28+66qo65OIIOyekOyLoOydmCDsnbjsiqTthLTsiqQ8L2tvPlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBjb25zdCBheGVzID0gbmV3IGVnLkF4ZXMoe1xuICAgKiAgIFwieFwiOiB7XG4gICAqICAgICAgcmFuZ2U6IFswLCAxMDBdXG4gICAqICAgfSxcbiAgICogICBcInhPdGhlclwiOiB7XG4gICAqICAgICAgcmFuZ2U6IFstMTAwLCAxMDBdXG4gICAqICAgfVxuICAgKiB9KTtcbiAgICpcbiAgICogYXhlcy5jb25uZWN0KFwieFwiLCBuZXcgZWcuQXhlcy5QYW5JbnB1dChcIiNhcmVhMVwiKSlcbiAgICogICAgLmNvbm5lY3QoXCJ4IHhPdGhlclwiLCBuZXcgZWcuQXhlcy5QYW5JbnB1dChcIiNhcmVhMlwiKSlcbiAgICogICAgLmNvbm5lY3QoXCIgeE90aGVyXCIsIG5ldyBlZy5BeGVzLlBhbklucHV0KFwiI2FyZWEzXCIpKVxuICAgKiAgICAuY29ubmVjdChbXCJ4XCJdLCBuZXcgZWcuQXhlcy5QYW5JbnB1dChcIiNhcmVhNFwiKSlcbiAgICogICAgLmNvbm5lY3QoW1wieE90aGVyXCIsIFwieFwiXSwgbmV3IGVnLkF4ZXMuUGFuSW5wdXQoXCIjYXJlYTVcIikpXG4gICAqICAgIC5jb25uZWN0KFtcIlwiLCBcInhPdGhlclwiXSwgbmV3IGVnLkF4ZXMuUGFuSW5wdXQoXCIjYXJlYTZcIikpO1xuICAgKiBgYGBcbiAgICovXG4gIF9fcHJvdG8uY29ubmVjdCA9IGZ1bmN0aW9uIChheGVzLCBpbnB1dFR5cGUpIHtcbiAgICB2YXIgbWFwcGVkO1xuICAgIGlmICh0eXBlb2YgYXhlcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgbWFwcGVkID0gYXhlcy5zcGxpdChcIiBcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1hcHBlZCA9IGF4ZXMuY29uY2F0KCk7XG4gICAgfVxuICAgIC8vIGNoZWNrIHNhbWUgaW5zdGFuY2VcbiAgICBpZiAofnRoaXMuX2lucHV0cy5pbmRleE9mKGlucHV0VHlwZSkpIHtcbiAgICAgIHRoaXMuZGlzY29ubmVjdChpbnB1dFR5cGUpO1xuICAgIH1cbiAgICBpbnB1dFR5cGUubWFwQXhlcyhtYXBwZWQpO1xuICAgIGlucHV0VHlwZS5jb25uZWN0KHRoaXMuaW5wdXRPYnNlcnZlcik7XG4gICAgdGhpcy5faW5wdXRzLnB1c2goaW5wdXRUeXBlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXG4gICAqIERpc2Nvbm5lY3QgdGhlIGF4aXMgb2YgZWcuQXhlcyBmcm9tIHRoZSBpbnB1dFR5cGUuXG4gICAqIEBrbyBlZy5BeGVz7J2YIOy2leqzvCBpbnB1dFR5cGXsnZgg7Jew6rKw7J2EIOuBiuuKlOuLpC5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtpbnB1dFR5cGVdIEFuIGlucHV0VHlwZSBpbnN0YW5jZSBhc3NvY2lhdGVkIHdpdGggdGhlIGF4aXMgb2YgZWcuQXhlcyA8a28+ZWcuQXhlc+ydmCDstpXqs7wg7Jew6rKw7ZWcIGlucHV0VHlwZSDsnbjsiqTthLTsiqQ8L2tvPlxuICAgKiBAcmV0dXJuIHtlZy5BeGVzfSBBbiBpbnN0YW5jZSBvZiBhIG1vZHVsZSBpdHNlbGYgPGtvPuuqqOuTiCDsnpDsi6DsnZgg7J247Iqk7YS07IqkPC9rbz5cbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogY29uc3QgYXhlcyA9IG5ldyBlZy5BeGVzKHtcbiAgICogICBcInhcIjoge1xuICAgKiAgICAgIHJhbmdlOiBbMCwgMTAwXVxuICAgKiAgIH0sXG4gICAqICAgXCJ4T3RoZXJcIjoge1xuICAgKiAgICAgIHJhbmdlOiBbLTEwMCwgMTAwXVxuICAgKiAgIH1cbiAgICogfSk7XG4gICAqXG4gICAqIGNvbnN0IGlucHV0MSA9IG5ldyBlZy5BeGVzLlBhbklucHV0KFwiI2FyZWExXCIpO1xuICAgKiBjb25zdCBpbnB1dDIgPSBuZXcgZWcuQXhlcy5QYW5JbnB1dChcIiNhcmVhMlwiKTtcbiAgICogY29uc3QgaW5wdXQzID0gbmV3IGVnLkF4ZXMuUGFuSW5wdXQoXCIjYXJlYTNcIik7XG4gICAqXG4gICAqIGF4ZXMuY29ubmVjdChcInhcIiwgaW5wdXQxKTtcbiAgICogICAgLmNvbm5lY3QoXCJ4IHhPdGhlclwiLCBpbnB1dDIpXG4gICAqICAgIC5jb25uZWN0KFtcInhPdGhlclwiLCBcInhcIl0sIGlucHV0Myk7XG4gICAqXG4gICAqIGF4ZXMuZGlzY29ubmVjdChpbnB1dDEpOyAvLyBkaXNjb25uZWN0cyBpbnB1dDFcbiAgICogYXhlcy5kaXNjb25uZWN0KCk7IC8vIGRpc2Nvbm5lY3RzIGFsbCBvZiB0aGVtXG4gICAqIGBgYFxuICAgKi9cbiAgX19wcm90by5kaXNjb25uZWN0ID0gZnVuY3Rpb24gKGlucHV0VHlwZSkge1xuICAgIGlmIChpbnB1dFR5cGUpIHtcbiAgICAgIHZhciBpbmRleCA9IHRoaXMuX2lucHV0cy5pbmRleE9mKGlucHV0VHlwZSk7XG4gICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICB0aGlzLl9pbnB1dHNbaW5kZXhdLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgdGhpcy5faW5wdXRzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2lucHV0cy5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHJldHVybiB2LmRpc2Nvbm5lY3QoKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5faW5wdXRzID0gW107XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBwb3NpdGlvbiBvZiB0aGUgY29vcmRpbmF0ZXMuXG4gICAqIEBrbyDsooztkZzsnZgg7ZiE7J6sIOychOy5mOulvCDrsJjtmZjtlZzri6RcbiAgICogQHBhcmFtIHtPYmplY3R9IFtheGVzXSBUaGUgbmFtZXMgb2YgdGhlIGF4aXMgPGtvPuy2lSDsnbTrpoTrk6Q8L2tvPlxuICAgKiBAcmV0dXJuIHtPYmplY3QuPHN0cmluZywgbnVtYmVyPn0gQXhpcyBjb29yZGluYXRlIGluZm9ybWF0aW9uIDxrbz7stpUg7KKM7ZGcIOygleuztDwva28+XG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IGF4ZXMgPSBuZXcgZWcuQXhlcyh7XG4gICAqICAgXCJ4XCI6IHtcbiAgICogICAgICByYW5nZTogWzAsIDEwMF1cbiAgICogICB9LFxuICAgKiAgIFwieE90aGVyXCI6IHtcbiAgICogICAgICByYW5nZTogWy0xMDAsIDEwMF1cbiAgICogICB9LFxuICAgKiAgICBcInpvb21cIjoge1xuICAgKiAgICAgIHJhbmdlOiBbNTAsIDMwXVxuICAgKiAgIH1cbiAgICogfSk7XG4gICAqXG4gICAqIGF4ZXMuZ2V0KCk7IC8vIHtcInhcIjogMCwgXCJ4T3RoZXJcIjogLTEwMCwgXCJ6b29tXCI6IDUwfVxuICAgKiBheGVzLmdldChbXCJ4XCIsIFwiem9vbVwiXSk7IC8vIHtcInhcIjogMCwgXCJ6b29tXCI6IDUwfVxuICAgKiBgYGBcbiAgICovXG4gIF9fcHJvdG8uZ2V0ID0gZnVuY3Rpb24gKGF4ZXMpIHtcbiAgICByZXR1cm4gdGhpcy5heGlzTWFuYWdlci5nZXQoYXhlcyk7XG4gIH07XG4gIC8qKlxuICAgKiBNb3ZlcyBhbiBheGlzIHRvIHNwZWNpZmljIGNvb3JkaW5hdGVzLlxuICAgKiBAa28g7KKM7ZGc66W8IOydtOuPme2VnOuLpC5cbiAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgbnVtYmVyPn0gcG9zIFRoZSBjb29yZGluYXRlIHRvIG1vdmUgdG8gPGtvPuydtOuPme2VoCDsooztkZw8L2tvPlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2R1cmF0aW9uPTBdIER1cmF0aW9uIG9mIHRoZSBhbmltYXRpb24gKHVuaXQ6IG1zKSA8a28+7JWg64uI66mU7J207IWYIOynhO2WiSDsi5zqsIQo64uo7JyEOiBtcyk8L2tvPlxuICAgKiBAcmV0dXJuIHtlZy5BeGVzfSBBbiBpbnN0YW5jZSBvZiBhIG1vZHVsZSBpdHNlbGYgPGtvPuuqqOuTiCDsnpDsi6DsnZgg7J247Iqk7YS07IqkPC9rbz5cbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogY29uc3QgYXhlcyA9IG5ldyBlZy5BeGVzKHtcbiAgICogICBcInhcIjoge1xuICAgKiAgICAgIHJhbmdlOiBbMCwgMTAwXVxuICAgKiAgIH0sXG4gICAqICAgXCJ4T3RoZXJcIjoge1xuICAgKiAgICAgIHJhbmdlOiBbLTEwMCwgMTAwXVxuICAgKiAgIH0sXG4gICAqICAgIFwiem9vbVwiOiB7XG4gICAqICAgICAgcmFuZ2U6IFs1MCwgMzBdXG4gICAqICAgfVxuICAgKiB9KTtcbiAgICpcbiAgICogYXhlcy5zZXRUbyh7XCJ4XCI6IDMwLCBcInpvb21cIjogNjB9KTtcbiAgICogYXhlcy5nZXQoKTsgLy8ge1wieFwiOiAzMCwgXCJ4T3RoZXJcIjogLTEwMCwgXCJ6b29tXCI6IDYwfVxuICAgKlxuICAgKiBheGVzLnNldFRvKHtcInhcIjogMTAwLCBcInhPdGhlclwiOiA2MH0sIDEwMDApOyAvLyBhbmltYXRhdGlvblxuICAgKlxuICAgKiAvLyBhZnRlciAxMDAwIG1zXG4gICAqIGF4ZXMuZ2V0KCk7IC8vIHtcInhcIjogMTAwLCBcInhPdGhlclwiOiA2MCwgXCJ6b29tXCI6IDYwfVxuICAgKiBgYGBcbiAgICovXG4gIF9fcHJvdG8uc2V0VG8gPSBmdW5jdGlvbiAocG9zLCBkdXJhdGlvbikge1xuICAgIGlmIChkdXJhdGlvbiA9PT0gdm9pZCAwKSB7XG4gICAgICBkdXJhdGlvbiA9IDA7XG4gICAgfVxuICAgIHRoaXMuYW5pbWF0aW9uTWFuYWdlci5zZXRUbyhwb3MsIGR1cmF0aW9uKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXG4gICAqIE1vdmVzIGFuIGF4aXMgZnJvbSB0aGUgY3VycmVudCBjb29yZGluYXRlcyB0byBzcGVjaWZpYyBjb29yZGluYXRlcy5cbiAgICogQGtvIO2YhOyerCDsooztkZzrpbwg6riw7KSA7Jy866GcIOyijO2RnOulvCDsnbTrj5ntlZzri6QuXG4gICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsIG51bWJlcj59IHBvcyBUaGUgY29vcmRpbmF0ZSB0byBtb3ZlIHRvIDxrbz7snbTrj5ntlaAg7KKM7ZGcPC9rbz5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtkdXJhdGlvbj0wXSBEdXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uICh1bml0OiBtcykgPGtvPuyVoOuLiOuplOydtOyFmCDsp4Ttlokg7Iuc6rCEKOuLqOychDogbXMpPC9rbz5cbiAgICogQHJldHVybiB7ZWcuQXhlc30gQW4gaW5zdGFuY2Ugb2YgYSBtb2R1bGUgaXRzZWxmIDxrbz7rqqjrk4gg7J6Q7Iug7J2YIOyduOyKpO2EtOyKpDwva28+XG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IGF4ZXMgPSBuZXcgZWcuQXhlcyh7XG4gICAqICAgXCJ4XCI6IHtcbiAgICogICAgICByYW5nZTogWzAsIDEwMF1cbiAgICogICB9LFxuICAgKiAgIFwieE90aGVyXCI6IHtcbiAgICogICAgICByYW5nZTogWy0xMDAsIDEwMF1cbiAgICogICB9LFxuICAgKiAgICBcInpvb21cIjoge1xuICAgKiAgICAgIHJhbmdlOiBbNTAsIDMwXVxuICAgKiAgIH1cbiAgICogfSk7XG4gICAqXG4gICAqIGF4ZXMuc2V0Qnkoe1wieFwiOiAzMCwgXCJ6b29tXCI6IDEwfSk7XG4gICAqIGF4ZXMuZ2V0KCk7IC8vIHtcInhcIjogMzAsIFwieE90aGVyXCI6IC0xMDAsIFwiem9vbVwiOiA2MH1cbiAgICpcbiAgICogYXhlcy5zZXRCeSh7XCJ4XCI6IDcwLCBcInhPdGhlclwiOiA2MH0sIDEwMDApOyAvLyBhbmltYXRhdGlvblxuICAgKlxuICAgKiAvLyBhZnRlciAxMDAwIG1zXG4gICAqIGF4ZXMuZ2V0KCk7IC8vIHtcInhcIjogMTAwLCBcInhPdGhlclwiOiAtNDAsIFwiem9vbVwiOiA2MH1cbiAgICogYGBgXG4gICAqL1xuICBfX3Byb3RvLnNldEJ5ID0gZnVuY3Rpb24gKHBvcywgZHVyYXRpb24pIHtcbiAgICBpZiAoZHVyYXRpb24gPT09IHZvaWQgMCkge1xuICAgICAgZHVyYXRpb24gPSAwO1xuICAgIH1cbiAgICB0aGlzLmFuaW1hdGlvbk1hbmFnZXIuc2V0QnkocG9zLCBkdXJhdGlvbik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxuICAgKiBDaGFuZ2UgdGhlIG9wdGlvbnMgb2YgQXhlcyBpbnN0YW5jZS5cbiAgICogQGtvIOyduOyKpO2EtOyKpOydmCDsmLXshZjsnYQg67OA6rK97ZWc64ukLlxuICAgKiBAcGFyYW0ge0F4ZXNPcHRpb259IG9wdGlvbnMgQXhlcyBvcHRpb25zIHRvIGNoYW5nZSA8a28+67OA6rK97ZWgIOyYteyFmCDrqqnroZ08L2tvPlxuICAgKiBAcmV0dXJuIHtlZy5BeGVzfSBBbiBpbnN0YW5jZSBvZiBhIG1vZHVsZSBpdHNlbGYgPGtvPuuqqOuTiCDsnpDsi6DsnZgg7J247Iqk7YS07IqkPC9rbz5cbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogY29uc3QgYXhlcyA9IG5ldyBlZy5BeGVzKHtcbiAgICogICBcInhcIjoge1xuICAgKiAgICAgIHJhbmdlOiBbMCwgMTAwXVxuICAgKiAgIH0sXG4gICAqIH0sIHtcbiAgICogICByb3VuZDogMTAsXG4gICAqIH0pO1xuICAgKlxuICAgKiBheGVzLnNldFRvKHtcInhcIjogNDh9KTtcbiAgICogYXhlcy5nZXQoKTsgLy8ge1wieFwiOiA1MH1cbiAgICpcbiAgICogYXhlcy5zZXRPcHRpb25zKHtcbiAgICogICByb3VuZDogMSxcbiAgICogfSk7XG4gICAqXG4gICAqIGF4ZXMuc2V0VG8oe1wieFwiOiA0OH0pO1xuICAgKiBheGVzLmdldCgpOyAvLyB7XCJ4XCI6IDQ4fVxuICAgKiBgYGBcbiAgICovXG4gIF9fcHJvdG8uc2V0T3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gX19hc3NpZ24oX19hc3NpZ24oe30sIHRoaXMub3B0aW9ucyksIG9wdGlvbnMpO1xuICAgIHRoaXMuYW5pbWF0aW9uTWFuYWdlci5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogQ2hhbmdlIHRoZSBpbmZvcm1hdGlvbiBvZiBhbiBleGlzdGluZyBheGlzLlxuICAgKiBAa28g7KG07J6s7ZWY64qUIOy2leydmCDsoJXrs7Trpbwg67OA6rK97ZWc64ukLlxuICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCBBeGlzT3B0aW9uPn0gYXhpcyBBeGlzIG9wdGlvbnMgdG8gY2hhbmdlIDxrbz7rs4Dqsr3tlaAg7LaV7J2YIOygleuztDwva28+XG4gICAqIEByZXR1cm4ge2VnLkF4ZXN9IEFuIGluc3RhbmNlIG9mIGEgbW9kdWxlIGl0c2VsZiA8a28+66qo65OIIOyekOyLoOydmCDsnbjsiqTthLTsiqQ8L2tvPlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBjb25zdCBheGVzID0gbmV3IGVnLkF4ZXMoe1xuICAgKiAgIFwieFwiOiB7XG4gICAqICAgICAgcmFuZ2U6IFswLCAxMDBdXG4gICAqICAgfSxcbiAgICogfSk7XG4gICAqXG4gICAqIGF4ZXMuc2V0VG8oe1wieFwiOiAxNTB9KTtcbiAgICogYXhlcy5nZXQoKTsgLy8ge1wieFwiOiAxMDB9XG4gICAqXG4gICAqIGF4ZXMuc2V0QXhpcyh7XG4gICAqICAgXCJ4XCI6IHtcbiAgICogICAgICByYW5nZTogWzAsIDIwMF1cbiAgICogICB9LFxuICAgKiB9KTtcbiAgICpcbiAgICogYXhlcy5zZXRUbyh7XCJ4XCI6IDE1MH0pO1xuICAgKiBheGVzLmdldCgpOyAvLyB7XCJ4XCI6IDE1MH1cbiAgICogYGBgXG4gICAqL1xuICBfX3Byb3RvLnNldEF4aXMgPSBmdW5jdGlvbiAoYXhpcykge1xuICAgIHRoaXMuYXhpc01hbmFnZXIuc2V0QXhpcyhheGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXG4gICAqIFN0b3AgYW4gYW5pbWF0aW9uIGluIHByb2dyZXNzLlxuICAgKiBAa28g7J6s7IOdIOykkeyduCDslaDri4jrqZTsnbTshZjsnYQg7KCV7KeA7ZWc64ukLlxuICAgKiBAcmV0dXJuIHtlZy5BeGVzfSBBbiBpbnN0YW5jZSBvZiBhIG1vZHVsZSBpdHNlbGYgPGtvPuuqqOuTiCDsnpDsi6DsnZgg7J247Iqk7YS07IqkPC9rbz5cbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogY29uc3QgYXhlcyA9IG5ldyBlZy5BeGVzKHtcbiAgICogICBcInhcIjoge1xuICAgKiAgICAgIHJhbmdlOiBbMCwgMTAwXVxuICAgKiAgIH0sXG4gICAqIH0pO1xuICAgKlxuICAgKiBheGVzLnNldFRvKHtcInhcIjogMTB9LCAxMDAwKTsgLy8gc3RhcnQgYW5pbWF0YXRpb25cbiAgICpcbiAgICogLy8gYWZ0ZXIgNTAwIG1zXG4gICAqIGF4ZXMuc3RvcEFuaW1hdGlvbigpOyAvLyBzdG9wIGFuaW1hdGlvbiBkdXJpbmcgbW92ZW1lbnQuXG4gICAqIGBgYFxuICAgKi9cbiAgX19wcm90by5zdG9wQW5pbWF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYW5pbWF0aW9uTWFuYWdlci5zdG9wQW5pbWF0aW9uKCk7XG4gICAgdGhpcy5hbmltYXRpb25NYW5hZ2VyLmZpbmlzaChmYWxzZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxuICAgKiBDaGFuZ2UgdGhlIGRlc3RpbmF0aW9uIG9mIGFuIGFuaW1hdGlvbiBpbiBwcm9ncmVzcy5cbiAgICogQGtvIOyerOyDnSDspJHsnbgg7JWg64uI66mU7J207IWY7J2YIOuqqeyggeyngOyZgCDsp4Ttlokg7Iuc6rCE7J2EIOuzgOqyve2VnOuLpC5cbiAgICogQHBhcmFtIHtVcGRhdGVBbmltYXRpb25PcHRpb259IHBvcyBUaGUgY29vcmRpbmF0ZSB0byBtb3ZlIHRvIDxrbz7snbTrj5ntlaAg7KKM7ZGcPC9rbz5cbiAgICogQHJldHVybiB7ZWcuQXhlc30gQW4gaW5zdGFuY2Ugb2YgYSBtb2R1bGUgaXRzZWxmIDxrbz7rqqjrk4gg7J6Q7Iug7J2YIOyduOyKpO2EtOyKpDwva28+XG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IGF4ZXMgPSBuZXcgZWcuQXhlcyh7XG4gICAqICAgXCJ4XCI6IHtcbiAgICogICAgICByYW5nZTogWzAsIDIwMF1cbiAgICogICB9LFxuICAgKiAgIFwieVwiOiB7XG4gICAqICAgICAgcmFuZ2U6IFswLCAyMDBdXG4gICAqICAgfVxuICAgKiB9KTtcbiAgICpcbiAgICogYXhlcy5zZXRUbyh7XCJ4XCI6IDUwLCBcInlcIjogNTB9LCAxMDAwKTsgLy8gdHJpZ2dlciBhbmltYXRpb24gYnkgc2V0VG9cbiAgICpcbiAgICogLy8gYWZ0ZXIgNTAwIG1zXG4gICAqIGF4ZXMudXBkYXRlQW5pbWF0aW9uKHtkZXN0UG9zOiB7XCJ4XCI6IDEwMCwgXCJ5XCI6IDEwMH19KTsgLy8gYW5pbWF0aW9uIHdpbGwgZW5kIGFmdGVyIDUwMCBtcywgYXQge1wieFwiOiAxMDAsIFwieVwiOiAxMDB9XG4gICAqXG4gICAqIC8vIGFmdGVyIDUwMCBtc1xuICAgKiBheGVzLnNldFRvKHtcInhcIjogNTAsIFwieVwiOiA1MH0sIDEwMDApOyAvLyB0cmlnZ2VyIGFuaW1hdGlvbiBieSBzZXRUb1xuICAgKlxuICAgKiAvLyBhZnRlciA3MDAgbXNcbiAgICogYXhlcy51cGRhdGVBbmltYXRpb24oe2Rlc3RQb3M6IHtcInhcIjogMTAwLCBcInlcIjogMTAwfSwgZHVyYXRpb246IDE1MDAsIHJlc3RhcnQ6IHRydWV9KTsgLy8gdGhpcyB3b3JrcyBzYW1lIGFzIGF4ZXMuc2V0VG8oe1wieFwiOiAxMDAsIFwieVwiOiAxMDB9LCA4MDApIHNpbmNlIHJlc3RhcnQgaXMgdHJ1ZS5cbiAgICogYGBgXG4gICAqL1xuICBfX3Byb3RvLnVwZGF0ZUFuaW1hdGlvbiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdGhpcy5hbmltYXRpb25NYW5hZ2VyLnVwZGF0ZUFuaW1hdGlvbihvcHRpb25zKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGVyZSBpcyBhIGNvb3JkaW5hdGUgaW4gdGhlIGJvdW5jZSBhcmVhIG9mIOKAi+KAi3RoZSB0YXJnZXQgYXhpcy5cbiAgICogQGtvIOuMgOyDgSDstpUg7KSRIGJvdW5jZeyYgeyXreyXkCDsooztkZzqsIAg7KG07J6s7ZWY64qU7KeA66W8IOuwmO2ZmO2VnOuLpFxuICAgKiBAcGFyYW0ge09iamVjdH0gW2F4ZXNdIFRoZSBuYW1lcyBvZiB0aGUgYXhpcyA8a28+7LaVIOydtOumhOuTpDwva28+XG4gICAqIEByZXR1cm4ge0Jvb2xlbn0gV2hldGhlciB0aGUgYm91bmNlIGFyZWEgZXhpc3RzLiA8a28+Ym91bmNlIOyYgeyXrSDsobTsnqwg7Jes67aAPC9rbz5cbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogY29uc3QgYXhlcyA9IG5ldyBlZy5BeGVzKHtcbiAgICogICBcInhcIjoge1xuICAgKiAgICAgIHJhbmdlOiBbMCwgMTAwXVxuICAgKiAgIH0sXG4gICAqICAgXCJ4T3RoZXJcIjoge1xuICAgKiAgICAgIHJhbmdlOiBbLTEwMCwgMTAwXVxuICAgKiAgIH0sXG4gICAqICAgIFwiem9vbVwiOiB7XG4gICAqICAgICAgcmFuZ2U6IFs1MCwgMzBdXG4gICAqICAgfVxuICAgKiB9KTtcbiAgICpcbiAgICogYXhlcy5pc0JvdW5jZUFyZWEoW1wieFwiXSk7XG4gICAqIGF4ZXMuaXNCb3VuY2VBcmVhKFtcInhcIiwgXCJ6b29tXCJdKTtcbiAgICogYXhlcy5pc0JvdW5jZUFyZWEoKTtcbiAgICogYGBgXG4gICAqL1xuICBfX3Byb3RvLmlzQm91bmNlQXJlYSA9IGZ1bmN0aW9uIChheGVzKSB7XG4gICAgcmV0dXJuIHRoaXMuYXhpc01hbmFnZXIuaXNPdXRzaWRlKGF4ZXMpO1xuICB9O1xuICAvKipcbiAgICogRGVzdHJveXMgcHJvcGVydGllcywgYW5kIGV2ZW50cyB1c2VkIGluIGEgbW9kdWxlIGFuZCBkaXNjb25uZWN0IGFsbCBjb25uZWN0aW9ucyB0byBpbnB1dFR5cGVzLlxuICAgKiBAa28g66qo65OI7JeQIOyCrOyaqe2VnCDsho3shLEsIOydtOuypO2KuOulvCDtlbTsoJztlZzri6QuIOuqqOuToCBpbnB1dFR5cGXqs7zsnZgg7Jew6rKw7J2EIOuBiuuKlOuLpC5cbiAgICovXG4gIF9fcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICB0aGlzLmV2ZW50TWFuYWdlci5kZXN0cm95KCk7XG4gIH07XG4gIC8qKlxuICAgKiBAbmFtZSBWRVJTSU9OXG4gICAqIEBkZXNjIFZlcnNpb24gaW5mbyBzdHJpbmdcbiAgICogQGtvIOuyhOyghOygleuztCDrrLjsnpDsl7RcbiAgICpcbiAgICogQGNvbnN0YW50XG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGVnLkF4ZXMuVkVSU0lPTjsgIC8vIGV4KSAzLjMuM1xuICAgKiBgYGBcbiAgICovXG4gIEF4ZXMuVkVSU0lPTiA9IFwiMy45LjFcIjtcbiAgLyogZXNsaW50LWVuYWJsZSAqL1xuICAvKipcbiAgICogQG5hbWUgVFJBTlNGT1JNXG4gICAqIEBkZXNjIFJldHVybnMgdGhlIHRyYW5zZm9ybSBhdHRyaWJ1dGUgd2l0aCBDU1MgdmVuZG9yIHByZWZpeGVzLlxuICAgKiBAa28gQ1NTIHZlbmRvciBwcmVmaXhlc+ulvCDrtpnsnbggdHJhbnNmb3JtIOyGjeyEseydhCDrsJjtmZjtlZzri6QuXG4gICAqXG4gICAqIEBjb25zdGFudFxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBlZy5BeGVzLlRSQU5TRk9STTsgLy8gXCJ0cmFuc2Zvcm1cIiBvciBcIndlYmtpdFRyYW5zZm9ybVwiXG4gICAqIGBgYFxuICAgKi9cbiAgQXhlcy5UUkFOU0ZPUk0gPSBUUkFOU0ZPUk07XG4gIC8qKlxuICAgKiBAbmFtZSBESVJFQ1RJT05fTk9ORVxuICAgKiBAY29uc3RhbnRcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIEF4ZXMuRElSRUNUSU9OX05PTkUgPSBESVJFQ1RJT05fTk9ORTtcbiAgLyoqXG4gICAqIEBuYW1lIERJUkVDVElPTl9MRUZUXG4gICAqIEBjb25zdGFudFxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgQXhlcy5ESVJFQ1RJT05fTEVGVCA9IERJUkVDVElPTl9MRUZUO1xuICAvKipcbiAgICogQG5hbWUgRElSRUNUSU9OX1JJR0hUXG4gICAqIEBjb25zdGFudFxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgQXhlcy5ESVJFQ1RJT05fUklHSFQgPSBESVJFQ1RJT05fUklHSFQ7XG4gIC8qKlxuICAgKiBAbmFtZSBESVJFQ1RJT05fVVBcbiAgICogQGNvbnN0YW50XG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBBeGVzLkRJUkVDVElPTl9VUCA9IERJUkVDVElPTl9VUDtcbiAgLyoqXG4gICAqIEBuYW1lIERJUkVDVElPTl9ET1dOXG4gICAqIEBjb25zdGFudFxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgQXhlcy5ESVJFQ1RJT05fRE9XTiA9IERJUkVDVElPTl9ET1dOO1xuICAvKipcbiAgICogQG5hbWUgRElSRUNUSU9OX0hPUklaT05UQUxcbiAgICogQGNvbnN0YW50XG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBBeGVzLkRJUkVDVElPTl9IT1JJWk9OVEFMID0gRElSRUNUSU9OX0hPUklaT05UQUw7XG4gIC8qKlxuICAgKiBAbmFtZSBESVJFQ1RJT05fVkVSVElDQUxcbiAgICogQGNvbnN0YW50XG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBBeGVzLkRJUkVDVElPTl9WRVJUSUNBTCA9IERJUkVDVElPTl9WRVJUSUNBTDtcbiAgLyoqXG4gICAqIEBuYW1lIERJUkVDVElPTl9BTExcbiAgICogQGNvbnN0YW50XG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBBeGVzLkRJUkVDVElPTl9BTEwgPSBESVJFQ1RJT05fQUxMO1xuICBfX2RlY29yYXRlKFtDb21wdXRlZF0sIEF4ZXMucHJvdG90eXBlLCBcImhvbGRpbmdcIiwgbnVsbCk7XG4gIEF4ZXMgPSBfX2RlY29yYXRlKFtSZWFjdGl2ZVN1YnNjcmliZV0sIEF4ZXMpO1xuICByZXR1cm4gQXhlcztcbn0oQ29tcG9uZW50KTtcblxuLypcbiAqIENvcHlyaWdodCAoYykgMjAxNSBOQVZFUiBDb3JwLlxuICogZWdqcyBwcm9qZWN0cyBhcmUgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbi8vIGdldCB1c2VyJ3MgZGlyZWN0aW9uXG52YXIgZ2V0RGlyZWN0aW9uQnlBbmdsZSA9IGZ1bmN0aW9uIChhbmdsZSwgdGhyZXNob2xkQW5nbGUpIHtcbiAgaWYgKHRocmVzaG9sZEFuZ2xlIDwgMCB8fCB0aHJlc2hvbGRBbmdsZSA+IDkwKSB7XG4gICAgcmV0dXJuIERJUkVDVElPTl9OT05FO1xuICB9XG4gIHZhciB0b0FuZ2xlID0gTWF0aC5hYnMoYW5nbGUpO1xuICByZXR1cm4gdG9BbmdsZSA+IHRocmVzaG9sZEFuZ2xlICYmIHRvQW5nbGUgPCAxODAgLSB0aHJlc2hvbGRBbmdsZSA/IERJUkVDVElPTl9WRVJUSUNBTCA6IERJUkVDVElPTl9IT1JJWk9OVEFMO1xufTtcbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gUGFuSW5wdXRPcHRpb24gVGhlIG9wdGlvbiBvYmplY3Qgb2YgdGhlIGVnLkF4ZXMuUGFuSW5wdXQgbW9kdWxlLlxuICogQGtvIGVnLkF4ZXMuUGFuSW5wdXQg66qo65OI7J2YIOyYteyFmCDqsJ3ssrRcbiAqIEBwYXJhbSB7U3RyaW5nW119IFtpbnB1dFR5cGU9W1widG91Y2hcIiwgXCJtb3VzZVwiLCBcInBvaW50ZXJcIl1dIFR5cGVzIG9mIGlucHV0IGRldmljZXNcbiAqIC0gdG91Y2g6IFRvdWNoIHNjcmVlblxuICogLSBtb3VzZTogTW91c2VcbiAqIC0gcG9pbnRlcjogTW91c2UgYW5kIHRvdWNoIDxrbz7snoXroKUg7J6l7LmYIOyiheulmFxuICogLSB0b3VjaDog7YSw7LmYIOyeheugpSDsnqXsuZhcbiAqIC0gbW91c2U6IOuniOyasOyKpFxuICogLSBwb2ludGVyOiDrp4jsmrDsiqQg67CPIO2EsOy5mDwva28+XG4gKiBAcGFyYW0ge1N0cmluZ1tdfSBbaW5wdXRLZXk9W1wiYW55XCJdXSBMaXN0IG9mIGtleSBjb21iaW5hdGlvbnMgdG8gYWxsb3cgaW5wdXRcbiAqIC0gYW55OiBhbnkga2V5XG4gKiAtIHNoaWZ0OiBzaGlmdCBrZXlcbiAqIC0gY3RybDogY3RybCBrZXkgYW5kIHBpbmNoIGdlc3R1cmUgb24gdGhlIHRyYWNrcGFkXG4gKiAtIGFsdDogYWx0IGtleVxuICogLSBtZXRhOiBtZXRhIGtleVxuICogLSBub25lOiBub25lIG9mIHRoZXNlIGtleXMgYXJlIHByZXNzZWQgPGtvPuyeheugpeydhCDtl4jsmqntlaAg7YKkIOyhsO2VqSDrqqnroZ1cbiAqIC0gYW55OiDslYTrrLQg7YKkXG4gKiAtIHNoaWZ0OiBzaGlmdCDtgqRcbiAqIC0gY3RybDogY3RybCDtgqQg67CPIO2KuOueme2MqOuTnOydmCBwaW5jaCDsoJzsiqTss5BcbiAqIC0gYWx0OiBhbHQg7YKkXG4gKiAtIG1ldGE6IG1ldGEg7YKkXG4gKiAtIG5vbmU6IOyVhOustCDtgqTrj4Qg64iM66as7KeAIOyViuydgCDsg4Htg5wgPC9rbz5cbiAqIEBwYXJhbSB7U3RyaW5nW119IFtpbnB1dEJ1dHRvbj1bXCJsZWZ0XCJdXSBMaXN0IG9mIGJ1dHRvbnMgdG8gYWxsb3cgaW5wdXRcbiAqIC0gbGVmdDogTGVmdCBtb3VzZSBidXR0b24gYW5kIG5vcm1hbCB0b3VjaFxuICogLSBtaWRkbGU6IE1vdXNlIHdoZWVsIHByZXNzXG4gKiAtIHJpZ2h0OiBSaWdodCBtb3VzZSBidXR0b24gPGtvPuyeheugpeydhCDtl4jsmqntlaAg67KE7Yq8IOuqqeuhnVxuICogLSBsZWZ0OiDrp4jsmrDsiqQg7Jm87Kq9IOuyhO2KvFxuICogLSBtaWRkbGU6IOuniOyasOyKpCDtnKAg64iM66a8XG4gKiAtIHJpZ2h0OiDrp4jsmrDsiqQg7Jik66W47Kq9IOuyhO2KvCA8L2tvPlxuICogQHBhcmFtIHtOdW1iZXJbXX0gW3NjYWxlXSBDb29yZGluYXRlIHNjYWxlIHRoYXQgYSB1c2VyIGNhbiBtb3ZlPGtvPuyCrOyaqeyekOydmCDrj5nsnpHsnLzroZwg7J2064+Z7ZWY64qUIOyijO2RnOydmCDrsLDsnKg8L2tvPlxuICogQHBhcmFtIHtOdW1iZXJ9IFtzY2FsZVswXT0xXSBob3Jpem9udGFsIGF4aXMgc2NhbGUgPGtvPuyImO2Piey2lSDrsLDsnKg8L2tvPlxuICogQHBhcmFtIHtOdW1iZXJ9IFtzY2FsZVsxXT0xXSB2ZXJ0aWNhbCBheGlzIHNjYWxlIDxrbz7siJjsp4HstpUg67Cw7JyoPC9rbz5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbdGhyZXNob2xkQW5nbGU9NDVdIFRoZSB0aHJlc2hvbGQgdmFsdWUgdGhhdCBkZXRlcm1pbmVzIHdoZXRoZXIgdXNlciBhY3Rpb24gaXMgaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbCAoMH45MCkgPGtvPuyCrOyaqeyekOydmCDrj5nsnpHsnbQg6rCA66GcIOuwqe2WpeyduOyngCDshLjroZwg67Cp7Zal7J247KeAIO2MkOuLqO2VmOuKlCDquLDspIAg6rCB64+EKDB+OTApPC9rbz5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbdGhyZXNob2xkPTBdIE1pbmltYWwgcGFuIGRpc3RhbmNlIHJlcXVpcmVkIGJlZm9yZSByZWNvZ25pemluZyA8a28+7IKs7Jqp7J6Q7J2YIFBhbiDrj5nsnpHsnYQg7J247Iud7ZWY6riwIOychO2VtOyCsCDstZzshoztlZzsnZgg6rGw66asPC9rbz5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3ByZXZlbnRDbGlja09uRHJhZz1mYWxzZV0gV2hldGhlciB0byBjYW5jZWwgdGhlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvRWxlbWVudC9jbGlja19ldmVudCBjbGlja30gZXZlbnQgd2hlbiB0aGUgdXNlciBmaW5pc2hlcyBkcmFnZ2luZyBtb3JlIHRoYW4gMSBwaXhlbCA8a28+7IKs7Jqp7J6Q6rCAIDHtlL3shYAg7J207IOBIOuTnOuemOq3uOulvCDrp4jss6TsnYQg65WMIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9rby9kb2NzL1dlYi9BUEkvRWxlbWVudC9jbGlja19ldmVudCBjbGlja30g7J2067Kk7Yq4IOy3qOyGjCDsl6zrtoA8L2tvPlxuICogQHBhcmFtIHtCb29sZWFufSBbcHJldmVudERlZmF1bHRPbkRyYWc9ZmFsc2VdIFdoZXRoZXIgdG8gdXNlIHRoZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcva28vZG9jcy9XZWIvQVBJL0V2ZW50L3ByZXZlbnREZWZhdWx0IHByZXZlbnREZWZhdWx0fSB3aGVuIHRoZSB1c2VyIHN0YXJ0cyBkcmFnZ2luZyA8a28+7IKs7Jqp7J6Q6rCAIOuTnOuemOq3uOulvCDsi5zsnpHtlaAg65WMIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9rby9kb2NzL1dlYi9BUEkvRXZlbnQvcHJldmVudERlZmF1bHQgcHJldmVudERlZmF1bHR9IOyLpO2WiSDsl6zrtoA8L2tvPlxuICogQHBhcmFtIHtOdW1iZXJ9IFtpT1NFZGdlU3dpcGVUaHJlc2hvbGQ9MzBdIEFyZWEgKHB4KSB0aGF0IGNhbiBnbyB0byB0aGUgbmV4dCBwYWdlIHdoZW4gc3dpcGluZyB0aGUgcmlnaHQgZWRnZSBpbiBpT1Mgc2FmYXJpIDxrbz5pT1MgU2FmYXJp7JeQ7IScIOyYpOuluOyqvSDsl6Psp4Drpbwg7Iqk7JmA7J207ZSEIO2VmOuKlCDqsr3smrAg64uk7J2MIO2OmOydtOyngOuhnCDrhJjslrTqsIgg7IiYIOyeiOuKlCDsmIHsl60ocHgpPC9rbz5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbdG91Y2hBY3Rpb249bnVsbF0gVmFsdWUgdGhhdCBvdmVycmlkZXMgdGhlIGVsZW1lbnQncyBcInRvdWNoLWFjdGlvblwiIGNzcyBwcm9wZXJ0eS4gSWYgc2V0IHRvIG51bGwsIGl0IGlzIGF1dG9tYXRpY2FsbHkgc2V0IHRvIHByZXZlbnQgc2Nyb2xsaW5nIGluIHRoZSBkaXJlY3Rpb24gb2YgdGhlIGNvbm5lY3RlZCBheGlzLiA8a28+7JeY66as66i87Yq47J2YIFwidG91Y2gtYWN0aW9uXCIgQ1NTIOyGjeyEseydhCDrja7slrTsk7DripQg6rCSLiDrp4zslb0gbnVsbOuhnCDshKTsoJXrkJwg6rK97JqwLCDsl7DqsrDrkJwg7LaVIOuwqe2WpeycvOuhnOydmCDsiqTtgazroaTsnYQg67Cp7KeA7ZWY6rKM64GUIOyekOuPmeycvOuhnCDshKTsoJXrkJzri6QuPC9rbz5cbiAqKi9cbi8qKlxuICogQSBtb2R1bGUgdGhhdCBwYXNzZXMgdGhlIGFtb3VudCBvZiBjaGFuZ2UgdG8gZWcuQXhlcyB3aGVuIHRoZSBtb3VzZSBvciB0b3VjaHNjcmVlbiBpcyBkb3duIGFuZCBtb3ZlZC4gdXNlIGxlc3MgdGhhbiB0d28gYXhlcy5cbiAqIEBrbyDrp4jsmrDsiqTrgpgg7YSw7LmYIOyKpO2BrOumsOydhCDriITrpbTqs6Ag7JuA7KeB7J2865WM7J2YIOuzgO2ZlOufieydhCBlZy5BeGVz7JeQIOyghOuLrO2VmOuKlCDrqqjrk4guIOuRkOqwnCDsnbTtlZjsnZgg7LaV7J2EIOyCrOyaqe2VnOuLpC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIGNvbnN0IHBhbiA9IG5ldyBlZy5BeGVzLlBhbklucHV0KFwiI2FyZWFcIiwge1xuICogICAgIGlucHV0VHlwZTogW1widG91Y2hcIl0sXG4gKiAgICAgc2NhbGU6IFsxLCAxLjNdLFxuICogfSk7XG4gKlxuICogLy8gQ29ubmVjdCB0aGUgJ3NvbWV0aGluZzInIGF4aXMgdG8gdGhlIG1vdXNlIG9yIHRvdWNoc2NyZWVuIHggcG9zaXRpb24gd2hlbiB0aGUgbW91c2Ugb3IgdG91Y2hzY3JlZW4gaXMgZG93biBhbmQgbW92ZWQuXG4gKiAvLyBDb25uZWN0IHRoZSAnc29tZXRoaW5nTicgYXhpcyB0byB0aGUgbW91c2Ugb3IgdG91Y2hzY3JlZW4geSBwb3NpdGlvbiB3aGVuIHRoZSBtb3VzZSBvciB0b3VjaHNjcmVlbiBpcyBkb3duIGFuZCBtb3ZlZC5cbiAqIGF4ZXMuY29ubmVjdChbXCJzb21ldGhpbmcyXCIsIFwic29tZXRoaW5nTlwiXSwgcGFuKTsgLy8gb3IgYXhlcy5jb25uZWN0KFwic29tZXRoaW5nMiBzb21ldGhpbmdOXCIsIHBhbik7XG4gKlxuICogLy8gQ29ubmVjdCBvbmx5IG9uZSAnc29tZXRoaW5nMScgYXhpcyB0byB0aGUgbW91c2Ugb3IgdG91Y2hzY3JlZW4geCBwb3NpdGlvbiB3aGVuIHRoZSBtb3VzZSBvciB0b3VjaHNjcmVlbiBpcyBkb3duIGFuZCBtb3ZlZC5cbiAqIGF4ZXMuY29ubmVjdChbXCJzb21ldGhpbmcxXCJdLCBwYW4pOyAvLyBvciBheGVzLmNvbm5lY3QoXCJzb21ldGhpbmcxXCIsIHBhbik7XG4gKlxuICogLy8gQ29ubmVjdCBvbmx5IG9uZSAnc29tZXRoaW5nMicgYXhpcyB0byB0aGUgbW91c2Ugb3IgdG91Y2hzY3JlZW4geSBwb3NpdGlvbiB3aGVuIHRoZSBtb3VzZSBvciB0b3VjaHNjcmVlbiBpcyBkb3duIGFuZCBtb3ZlZC5cbiAqIGF4ZXMuY29ubmVjdChbXCJcIiwgXCJzb21ldGhpbmcyXCJdLCBwYW4pOyAvLyBvciBheGVzLmNvbm5lY3QoXCIgc29tZXRoaW5nMlwiLCBwYW4pO1xuICogYGBgXG4gKiBAcGFyYW0ge1N0cmluZ3xIVE1MRWxlbWVudHxSZWY8SFRNTEVsZW1lbnQ+fGpRdWVyeX0gZWxlbWVudCBBbiBlbGVtZW50IHRvIHVzZSB0aGUgZWcuQXhlcy5QYW5JbnB1dCBtb2R1bGUgPGtvPmVnLkF4ZXMuUGFuSW5wdXQg66qo65OI7J2EIOyCrOyaqe2VoCDsl5jrpqzrqLztirg8L2tvPlxuICogQHBhcmFtIHtQYW5JbnB1dE9wdGlvbn0gW29wdGlvbnM9e31dIFRoZSBvcHRpb24gb2JqZWN0IG9mIHRoZSBlZy5BeGVzLlBhbklucHV0IG1vZHVsZTxrbz5lZy5BeGVzLlBhbklucHV0IOuqqOuTiOydmCDsmLXshZgg6rCd7LK0PC9rbz5cbiAqL1xudmFyIFBhbklucHV0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqXG4gICAqL1xuICBmdW5jdGlvbiBQYW5JbnB1dChlbCwgb3B0aW9ucykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdGhpcy5heGVzID0gW107XG4gICAgdGhpcy5lbGVtZW50ID0gbnVsbDtcbiAgICB0aGlzLl9lbmFibGVkID0gZmFsc2U7XG4gICAgdGhpcy5fYWN0aXZlRXZlbnQgPSBudWxsO1xuICAgIHRoaXMuX2F0UmlnaHRFZGdlID0gZmFsc2U7XG4gICAgdGhpcy5fcmlnaHRFZGdlVGltZXIgPSAwO1xuICAgIHRoaXMuX2RyYWdnZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9pc092ZXJUaHJlc2hvbGQgPSBmYWxzZTtcbiAgICB0aGlzLl9wcmV2ZW50Q2xpY2tXaGVuRHJhZ2dlZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoX3RoaXMuX2RyYWdnZWQpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgfVxuICAgICAgX3RoaXMuX2RyYWdnZWQgPSBmYWxzZTtcbiAgICB9O1xuICAgIHRoaXMuX3ZvaWRGdW5jdGlvbiA9IGZ1bmN0aW9uICgpIHt9O1xuICAgIHRoaXMuZWxlbWVudCA9ICQkMShlbCk7XG4gICAgdGhpcy5vcHRpb25zID0gX19hc3NpZ24oe1xuICAgICAgaW5wdXRUeXBlOiBbXCJ0b3VjaFwiLCBcIm1vdXNlXCIsIFwicG9pbnRlclwiXSxcbiAgICAgIGlucHV0S2V5OiBbQU5ZXSxcbiAgICAgIGlucHV0QnV0dG9uOiBbTU9VU0VfTEVGVF0sXG4gICAgICBzY2FsZTogWzEsIDFdLFxuICAgICAgdGhyZXNob2xkQW5nbGU6IDQ1LFxuICAgICAgdGhyZXNob2xkOiAwLFxuICAgICAgcHJldmVudENsaWNrT25EcmFnOiBmYWxzZSxcbiAgICAgIHByZXZlbnREZWZhdWx0T25EcmFnOiBmYWxzZSxcbiAgICAgIGlPU0VkZ2VTd2lwZVRocmVzaG9sZDogSU9TX0VER0VfVEhSRVNIT0xELFxuICAgICAgcmVsZWFzZU9uU2Nyb2xsOiBmYWxzZSxcbiAgICAgIHRvdWNoQWN0aW9uOiBudWxsXG4gICAgfSwgb3B0aW9ucyk7XG4gICAgdGhpcy5fb25QYW5zdGFydCA9IHRoaXMuX29uUGFuc3RhcnQuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vblBhbm1vdmUgPSB0aGlzLl9vblBhbm1vdmUuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vblBhbmVuZCA9IHRoaXMuX29uUGFuZW5kLmJpbmQodGhpcyk7XG4gIH1cbiAgdmFyIF9fcHJvdG8gPSBQYW5JbnB1dC5wcm90b3R5cGU7XG4gIF9fcHJvdG8ubWFwQXhlcyA9IGZ1bmN0aW9uIChheGVzKSB7XG4gICAgdGhpcy5fZGlyZWN0aW9uID0gZ2V0RGlyZWN0aW9uKCEhYXhlc1swXSwgISFheGVzWzFdKTtcbiAgICB0aGlzLmF4ZXMgPSBheGVzO1xuICB9O1xuICBfX3Byb3RvLmNvbm5lY3QgPSBmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICBpZiAodGhpcy5fYWN0aXZlRXZlbnQpIHtcbiAgICAgIHRoaXMuX2RldGFjaEVsZW1lbnRFdmVudCgpO1xuICAgICAgdGhpcy5fZGV0YWNoV2luZG93RXZlbnQodGhpcy5fYWN0aXZlRXZlbnQpO1xuICAgIH1cbiAgICB0aGlzLl9hdHRhY2hFbGVtZW50RXZlbnQob2JzZXJ2ZXIpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBfX3Byb3RvLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fZGV0YWNoRWxlbWVudEV2ZW50KCk7XG4gICAgdGhpcy5fZGV0YWNoV2luZG93RXZlbnQodGhpcy5fYWN0aXZlRXZlbnQpO1xuICAgIHRoaXMuX2RpcmVjdGlvbiA9IERJUkVDVElPTl9OT05FO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogRGVzdHJveXMgZWxlbWVudHMsIHByb3BlcnRpZXMsIGFuZCBldmVudHMgdXNlZCBpbiBhIG1vZHVsZS5cbiAgICogQGtvIOuqqOuTiOyXkCDsgqzsmqntlZwg7JeY66as66i87Yq47JmAIOyGjeyEsSwg7J2067Kk7Yq466W8IO2VtOygnO2VnOuLpC5cbiAgICovXG4gIF9fcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICB0aGlzLmVsZW1lbnQgPSBudWxsO1xuICB9O1xuICAvKipcbiAgICogRW5hYmxlcyBpbnB1dCBkZXZpY2VzXG4gICAqIEBrbyDsnoXroKUg7J6l7LmY66W8IOyCrOyaqe2VoCDsiJgg7J6I6rKMIO2VnOuLpFxuICAgKiBAcmV0dXJuIHtQYW5JbnB1dH0gQW4gaW5zdGFuY2Ugb2YgYSBtb2R1bGUgaXRzZWxmIDxrbz7rqqjrk4gg7J6Q7Iug7J2YIOyduOyKpO2EtOyKpDwva28+XG4gICAqL1xuICBfX3Byb3RvLmVuYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuX2VuYWJsZWQpIHtcbiAgICAgIHRoaXMuX2VuYWJsZWQgPSB0cnVlO1xuICAgICAgdGhpcy5fb3JpZ2luYWxDc3NQcm9wcyA9IHNldENzc1Byb3BzKHRoaXMuZWxlbWVudCwgdGhpcy5vcHRpb25zLCB0aGlzLl9kaXJlY3Rpb24pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXG4gICAqIERpc2FibGVzIGlucHV0IGRldmljZXNcbiAgICogQGtvIOyeheugpSDsnqXsuZjrpbwg7IKs7Jqp7ZWgIOyImCDsl4bqsowg7ZWc64ukLlxuICAgKiBAcmV0dXJuIHtQYW5JbnB1dH0gQW4gaW5zdGFuY2Ugb2YgYSBtb2R1bGUgaXRzZWxmIDxrbz7rqqjrk4gg7J6Q7Iug7J2YIOyduOyKpO2EtOyKpDwva28+XG4gICAqL1xuICBfX3Byb3RvLmRpc2FibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX2VuYWJsZWQpIHtcbiAgICAgIHRoaXMuX2VuYWJsZWQgPSBmYWxzZTtcbiAgICAgIGlmICghaXNDc3NQcm9wc0Zyb21BeGVzKHRoaXMuX29yaWdpbmFsQ3NzUHJvcHMpKSB7XG4gICAgICAgIHJldmVydENzc1Byb3BzKHRoaXMuZWxlbWVudCwgdGhpcy5fb3JpZ2luYWxDc3NQcm9wcyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRvIHVzZSBhbiBpbnB1dCBkZXZpY2VcbiAgICogQGtvIOyeheugpSDsnqXsuZgg7IKs7JqpIOyXrOu2gOulvCDrsJjtmZjtlZzri6QuXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IFdoZXRoZXIgdG8gdXNlIGFuIGlucHV0IGRldmljZSA8a28+7J6F66Cl7J6l7LmYIOyCrOyaqeyXrOu2gDwva28+XG4gICAqL1xuICBfX3Byb3RvLmlzRW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fZW5hYmxlZDtcbiAgfTtcbiAgLyoqXG4gICAqIFJlbGVhc2VzIGN1cnJlbnQgdXNlciBpbnB1dC5cbiAgICogQGtvIOyCrOyaqeyekOydmCDsnoXroKXsnYQg6rCV7KCc66GcIOykkeuLqOyLnO2CqOuLpC5cbiAgICogQHJldHVybiB7UGFuSW5wdXR9IEFuIGluc3RhbmNlIG9mIGEgbW9kdWxlIGl0c2VsZiA8a28+66qo65OIIOyekOyLoOydmCDsnbjsiqTthLTsiqQ8L2tvPlxuICAgKi9cbiAgX19wcm90by5yZWxlYXNlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhY3RpdmVFdmVudCA9IHRoaXMuX2FjdGl2ZUV2ZW50O1xuICAgIHZhciBwcmV2RXZlbnQgPSBhY3RpdmVFdmVudC5wcmV2RXZlbnQ7XG4gICAgYWN0aXZlRXZlbnQub25SZWxlYXNlKCk7XG4gICAgdGhpcy5fb2JzZXJ2ZXIucmVsZWFzZSh0aGlzLCBwcmV2RXZlbnQsIFswLCAwXSk7XG4gICAgdGhpcy5fZGV0YWNoV2luZG93RXZlbnQoYWN0aXZlRXZlbnQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBfX3Byb3RvLl9vblBhbnN0YXJ0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIF9hID0gdGhpcy5vcHRpb25zLFxuICAgICAgaW5wdXRLZXkgPSBfYS5pbnB1dEtleSxcbiAgICAgIGlucHV0QnV0dG9uID0gX2EuaW5wdXRCdXR0b24sXG4gICAgICBwcmV2ZW50RGVmYXVsdE9uRHJhZyA9IF9hLnByZXZlbnREZWZhdWx0T25EcmFnO1xuICAgIHZhciBhY3RpdmVFdmVudCA9IHRoaXMuX2FjdGl2ZUV2ZW50O1xuICAgIHZhciBwYW5FdmVudCA9IGFjdGl2ZUV2ZW50Lm9uRXZlbnRTdGFydChldmVudCwgaW5wdXRLZXksIGlucHV0QnV0dG9uKTtcbiAgICBpZiAoIXBhbkV2ZW50IHx8ICF0aGlzLl9lbmFibGVkIHx8IGFjdGl2ZUV2ZW50LmdldFRvdWNoZXMoZXZlbnQsIGlucHV0QnV0dG9uKSA+IDEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHBhbkV2ZW50LnNyY0V2ZW50LmNhbmNlbGFibGUgIT09IGZhbHNlKSB7XG4gICAgICB2YXIgZWRnZVRocmVzaG9sZCA9IHRoaXMub3B0aW9ucy5pT1NFZGdlU3dpcGVUaHJlc2hvbGQ7XG4gICAgICB0aGlzLl9kcmFnZ2VkID0gZmFsc2U7XG4gICAgICB0aGlzLl9pc092ZXJUaHJlc2hvbGQgPSBmYWxzZTtcbiAgICAgIHRoaXMuX29ic2VydmVyLmhvbGQodGhpcywgcGFuRXZlbnQpO1xuICAgICAgdGhpcy5fYXRSaWdodEVkZ2UgPSBJU19JT1NfU0FGQVJJICYmIHBhbkV2ZW50LmNlbnRlci54ID4gd2luZG93LmlubmVyV2lkdGggLSBlZGdlVGhyZXNob2xkO1xuICAgICAgdGhpcy5fYXR0YWNoV2luZG93RXZlbnQoYWN0aXZlRXZlbnQpO1xuICAgICAgcHJldmVudERlZmF1bHRPbkRyYWcgJiYgcGFuRXZlbnQuc3JjRXZlbnQudHlwZSAhPT0gXCJ0b3VjaHN0YXJ0XCIgJiYgcGFuRXZlbnQuc3JjRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGFjdGl2ZUV2ZW50LnByZXZFdmVudCA9IHBhbkV2ZW50O1xuICAgIH1cbiAgfTtcbiAgX19wcm90by5fb25QYW5tb3ZlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB2YXIgX2EgPSB0aGlzLm9wdGlvbnMsXG4gICAgICBpT1NFZGdlU3dpcGVUaHJlc2hvbGQgPSBfYS5pT1NFZGdlU3dpcGVUaHJlc2hvbGQsXG4gICAgICBwcmV2ZW50Q2xpY2tPbkRyYWcgPSBfYS5wcmV2ZW50Q2xpY2tPbkRyYWcsXG4gICAgICByZWxlYXNlT25TY3JvbGwgPSBfYS5yZWxlYXNlT25TY3JvbGwsXG4gICAgICBpbnB1dEtleSA9IF9hLmlucHV0S2V5LFxuICAgICAgaW5wdXRCdXR0b24gPSBfYS5pbnB1dEJ1dHRvbixcbiAgICAgIHRocmVzaG9sZCA9IF9hLnRocmVzaG9sZCxcbiAgICAgIHRocmVzaG9sZEFuZ2xlID0gX2EudGhyZXNob2xkQW5nbGU7XG4gICAgdmFyIGFjdGl2ZUV2ZW50ID0gdGhpcy5fYWN0aXZlRXZlbnQ7XG4gICAgdmFyIHBhbkV2ZW50ID0gYWN0aXZlRXZlbnQub25FdmVudE1vdmUoZXZlbnQsIGlucHV0S2V5LCBpbnB1dEJ1dHRvbik7XG4gICAgdmFyIHRvdWNoZXMgPSBhY3RpdmVFdmVudC5nZXRUb3VjaGVzKGV2ZW50LCBpbnB1dEJ1dHRvbik7XG4gICAgaWYgKHRvdWNoZXMgPT09IDAgfHwgcmVsZWFzZU9uU2Nyb2xsICYmIHBhbkV2ZW50ICYmICFwYW5FdmVudC5zcmNFdmVudC5jYW5jZWxhYmxlKSB7XG4gICAgICB0aGlzLl9vblBhbmVuZChldmVudCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghcGFuRXZlbnQgfHwgIXRoaXMuX2VuYWJsZWQgfHwgdG91Y2hlcyA+IDEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHVzZXJEaXJlY3Rpb24gPSBnZXREaXJlY3Rpb25CeUFuZ2xlKHBhbkV2ZW50LmFuZ2xlLCB0aHJlc2hvbGRBbmdsZSk7XG4gICAgdmFyIHVzZUhvcml6b250YWwgPSB1c2VEaXJlY3Rpb24oRElSRUNUSU9OX0hPUklaT05UQUwsIHRoaXMuX2RpcmVjdGlvbiwgdXNlckRpcmVjdGlvbik7XG4gICAgdmFyIHVzZVZlcnRpY2FsID0gdXNlRGlyZWN0aW9uKERJUkVDVElPTl9WRVJUSUNBTCwgdGhpcy5fZGlyZWN0aW9uLCB1c2VyRGlyZWN0aW9uKTtcbiAgICBpZiAoYWN0aXZlRXZlbnQucHJldkV2ZW50ICYmIElTX0lPU19TQUZBUkkpIHtcbiAgICAgIHZhciBzd2lwZUxlZnRUb1JpZ2h0ID0gcGFuRXZlbnQuY2VudGVyLnggPCAwO1xuICAgICAgaWYgKHN3aXBlTGVmdFRvUmlnaHQpIHtcbiAgICAgICAgLy8gaU9TIHN3aXBlIGxlZnQgPT4gcmlnaHRcbiAgICAgICAgdGhpcy5yZWxlYXNlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fYXRSaWdodEVkZ2UpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3JpZ2h0RWRnZVRpbWVyKTtcbiAgICAgICAgLy8gLSBpcyByaWdodCB0byBsZWZ0XG4gICAgICAgIHZhciBzd2lwZVJpZ2h0VG9MZWZ0ID0gcGFuRXZlbnQuZGVsdGFYIDwgLWlPU0VkZ2VTd2lwZVRocmVzaG9sZDtcbiAgICAgICAgaWYgKHN3aXBlUmlnaHRUb0xlZnQpIHtcbiAgICAgICAgICB0aGlzLl9hdFJpZ2h0RWRnZSA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGlPUyBzd2lwZSByaWdodCA9PiBsZWZ0XG4gICAgICAgICAgdGhpcy5fcmlnaHRFZGdlVGltZXIgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMucmVsZWFzZSgpO1xuICAgICAgICAgIH0sIDEwMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGRpc3RhbmNlID0gdGhpcy5fZ2V0RGlzdGFuY2UoW3BhbkV2ZW50LmRlbHRhWCwgcGFuRXZlbnQuZGVsdGFZXSwgW3VzZUhvcml6b250YWwsIHVzZVZlcnRpY2FsXSk7XG4gICAgdmFyIG9mZnNldCA9IHRoaXMuX2dldE9mZnNldChbcGFuRXZlbnQub2Zmc2V0WCwgcGFuRXZlbnQub2Zmc2V0WV0sIFt1c2VIb3Jpem9udGFsLCB1c2VWZXJ0aWNhbF0pO1xuICAgIHZhciBwcmV2ZW50ID0gb2Zmc2V0LnNvbWUoZnVuY3Rpb24gKHYpIHtcbiAgICAgIHJldHVybiB2ICE9PSAwO1xuICAgIH0pO1xuICAgIGlmIChwcmV2ZW50KSB7XG4gICAgICBpZiAocGFuRXZlbnQuc3JjRXZlbnQuY2FuY2VsYWJsZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgcGFuRXZlbnQuc3JjRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICAgIHBhbkV2ZW50LnNyY0V2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH1cbiAgICBwYW5FdmVudC5wcmV2ZW50U3lzdGVtRXZlbnQgPSBwcmV2ZW50O1xuICAgIGlmIChwcmV2ZW50ICYmICh0aGlzLl9pc092ZXJUaHJlc2hvbGQgfHwgZGlzdGFuY2UgPj0gdGhyZXNob2xkKSkge1xuICAgICAgdGhpcy5fZHJhZ2dlZCA9IHByZXZlbnRDbGlja09uRHJhZztcbiAgICAgIHRoaXMuX2lzT3ZlclRocmVzaG9sZCA9IHRydWU7XG4gICAgICB0aGlzLl9vYnNlcnZlci5jaGFuZ2UodGhpcywgcGFuRXZlbnQsIHRvQXhpcyh0aGlzLmF4ZXMsIG9mZnNldCkpO1xuICAgIH1cbiAgICBhY3RpdmVFdmVudC5wcmV2RXZlbnQgPSBwYW5FdmVudDtcbiAgfTtcbiAgX19wcm90by5fb25QYW5lbmQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgaW5wdXRCdXR0b24gPSB0aGlzLm9wdGlvbnMuaW5wdXRCdXR0b247XG4gICAgdmFyIGFjdGl2ZUV2ZW50ID0gdGhpcy5fYWN0aXZlRXZlbnQ7XG4gICAgYWN0aXZlRXZlbnQub25FdmVudEVuZChldmVudCk7XG4gICAgaWYgKCF0aGlzLl9lbmFibGVkIHx8IGFjdGl2ZUV2ZW50LmdldFRvdWNoZXMoZXZlbnQsIGlucHV0QnV0dG9uKSAhPT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9kZXRhY2hXaW5kb3dFdmVudChhY3RpdmVFdmVudCk7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX3JpZ2h0RWRnZVRpbWVyKTtcbiAgICB2YXIgcHJldkV2ZW50ID0gYWN0aXZlRXZlbnQucHJldkV2ZW50O1xuICAgIHZhciB2ZWxvY2l0eSA9IHRoaXMuX2lzT3ZlclRocmVzaG9sZCA/IHRoaXMuX2dldE9mZnNldChbTWF0aC5hYnMocHJldkV2ZW50LnZlbG9jaXR5WCkgKiAocHJldkV2ZW50Lm9mZnNldFggPCAwID8gLTEgOiAxKSwgTWF0aC5hYnMocHJldkV2ZW50LnZlbG9jaXR5WSkgKiAocHJldkV2ZW50Lm9mZnNldFkgPCAwID8gLTEgOiAxKV0sIFt1c2VEaXJlY3Rpb24oRElSRUNUSU9OX0hPUklaT05UQUwsIHRoaXMuX2RpcmVjdGlvbiksIHVzZURpcmVjdGlvbihESVJFQ1RJT05fVkVSVElDQUwsIHRoaXMuX2RpcmVjdGlvbildKSA6IFswLCAwXTtcbiAgICBhY3RpdmVFdmVudC5vblJlbGVhc2UoKTtcbiAgICB0aGlzLl9vYnNlcnZlci5yZWxlYXNlKHRoaXMsIHByZXZFdmVudCwgdmVsb2NpdHkpO1xuICB9O1xuICBfX3Byb3RvLl9hdHRhY2hXaW5kb3dFdmVudCA9IGZ1bmN0aW9uIChhY3RpdmVFdmVudCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgYWN0aXZlRXZlbnQgPT09IG51bGwgfHwgYWN0aXZlRXZlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFjdGl2ZUV2ZW50Lm1vdmUuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBfdGhpcy5fb25QYW5tb3ZlLCBnZXRBZGRFdmVudE9wdGlvbnMoZXZlbnQpKTtcbiAgICB9KTtcbiAgICBhY3RpdmVFdmVudCA9PT0gbnVsbCB8fCBhY3RpdmVFdmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWN0aXZlRXZlbnQuZW5kLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgX3RoaXMuX29uUGFuZW5kLCBnZXRBZGRFdmVudE9wdGlvbnMoZXZlbnQpKTtcbiAgICB9KTtcbiAgfTtcbiAgX19wcm90by5fZGV0YWNoV2luZG93RXZlbnQgPSBmdW5jdGlvbiAoYWN0aXZlRXZlbnQpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIGFjdGl2ZUV2ZW50ID09PSBudWxsIHx8IGFjdGl2ZUV2ZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhY3RpdmVFdmVudC5tb3ZlLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgX3RoaXMuX29uUGFubW92ZSk7XG4gICAgfSk7XG4gICAgYWN0aXZlRXZlbnQgPT09IG51bGwgfHwgYWN0aXZlRXZlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFjdGl2ZUV2ZW50LmVuZC5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIF90aGlzLl9vblBhbmVuZCk7XG4gICAgfSk7XG4gIH07XG4gIF9fcHJvdG8uX2dldE9mZnNldCA9IGZ1bmN0aW9uIChwcm9wZXJ0aWVzLCBkaXJlY3Rpb24pIHtcbiAgICB2YXIgc2NhbGUgPSB0aGlzLm9wdGlvbnMuc2NhbGU7XG4gICAgcmV0dXJuIFtkaXJlY3Rpb25bMF0gPyBwcm9wZXJ0aWVzWzBdICogc2NhbGVbMF0gOiAwLCBkaXJlY3Rpb25bMV0gPyBwcm9wZXJ0aWVzWzFdICogc2NhbGVbMV0gOiAwXTtcbiAgfTtcbiAgX19wcm90by5fZ2V0RGlzdGFuY2UgPSBmdW5jdGlvbiAoZGVsdGEsIGRpcmVjdGlvbikge1xuICAgIHJldHVybiBNYXRoLnNxcnQoTnVtYmVyKGRpcmVjdGlvblswXSkgKiBNYXRoLnBvdyhkZWx0YVswXSwgMikgKyBOdW1iZXIoZGlyZWN0aW9uWzFdKSAqIE1hdGgucG93KGRlbHRhWzFdLCAyKSk7XG4gIH07XG4gIF9fcHJvdG8uX2F0dGFjaEVsZW1lbnRFdmVudCA9IGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIGFjdGl2ZUV2ZW50ID0gY29udmVydElucHV0VHlwZSh0aGlzLm9wdGlvbnMuaW5wdXRUeXBlKTtcbiAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcbiAgICBpZiAoIWFjdGl2ZUV2ZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRWxlbWVudCB0byBjb25uZWN0IGlucHV0IGRvZXMgbm90IGV4aXN0LlwiKTtcbiAgICB9XG4gICAgdGhpcy5fb2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICB0aGlzLmVuYWJsZSgpO1xuICAgIHRoaXMuX2FjdGl2ZUV2ZW50ID0gYWN0aXZlRXZlbnQ7XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fcHJldmVudENsaWNrV2hlbkRyYWdnZWQsIHRydWUpO1xuICAgIGFjdGl2ZUV2ZW50LnN0YXJ0LmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIF90aGlzLl9vblBhbnN0YXJ0KTtcbiAgICB9KTtcbiAgICAvLyBhZGRpbmcgZXZlbnQgbGlzdGVuZXIgdG8gZWxlbWVudCBwcmV2ZW50cyBpbnZhbGlkIGJlaGF2aW9yIGluIGlPUyBTYWZhcmlcbiAgICBhY3RpdmVFdmVudC5tb3ZlLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIF90aGlzLl92b2lkRnVuY3Rpb24pO1xuICAgIH0pO1xuICB9O1xuICBfX3Byb3RvLl9kZXRhY2hFbGVtZW50RXZlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB2YXIgYWN0aXZlRXZlbnQgPSB0aGlzLl9hY3RpdmVFdmVudDtcbiAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fcHJldmVudENsaWNrV2hlbkRyYWdnZWQsIHRydWUpO1xuICAgICAgYWN0aXZlRXZlbnQgPT09IG51bGwgfHwgYWN0aXZlRXZlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFjdGl2ZUV2ZW50LnN0YXJ0LmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgX3RoaXMuX29uUGFuc3RhcnQpO1xuICAgICAgfSk7XG4gICAgICBhY3RpdmVFdmVudCA9PT0gbnVsbCB8fCBhY3RpdmVFdmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWN0aXZlRXZlbnQubW92ZS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIF90aGlzLl92b2lkRnVuY3Rpb24pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuZGlzYWJsZSgpO1xuICAgIHRoaXMuX29ic2VydmVyID0gbnVsbDtcbiAgfTtcbiAgcmV0dXJuIFBhbklucHV0O1xufSgpO1xuXG4vKlxuQ29weXJpZ2h0IChjKSAyMDIwLXByZXNlbnQgTkFWRVIgQ29ycC5cbm5hbWU6IEBlZ2pzL2ltcmVhZHlcbmxpY2Vuc2U6IE1JVFxuYXV0aG9yOiBOQVZFUiBDb3JwLlxucmVwb3NpdG9yeTogaHR0cHM6Ly9naXRodWIuY29tL25hdmVyL2VnanMtaW1yZWFkeVxudmVyc2lvbjogMS4zLjFcbiovXG5cbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG5cbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXG52YXIgZXh0ZW5kU3RhdGljcyQyID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgZXh0ZW5kU3RhdGljcyQyID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IHtcbiAgICBfX3Byb3RvX186IFtdXG4gIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikge1xuICAgIGQuX19wcm90b19fID0gYjtcbiAgfSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07XG4gIH07XG5cbiAgcmV0dXJuIGV4dGVuZFN0YXRpY3MkMihkLCBiKTtcbn07XG5cbmZ1bmN0aW9uIF9fZXh0ZW5kcyQyKGQsIGIpIHtcbiAgZXh0ZW5kU3RhdGljcyQyKGQsIGIpO1xuXG4gIGZ1bmN0aW9uIF9fKCkge1xuICAgIHRoaXMuY29uc3RydWN0b3IgPSBkO1xuICB9XG5cbiAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufVxudmFyIF9fYXNzaWduJDEgPSBmdW5jdGlvbiAoKSB7XG4gIF9fYXNzaWduJDEgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcbiAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgIHMgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XG4gICAgfVxuXG4gICAgcmV0dXJuIHQ7XG4gIH07XG5cbiAgcmV0dXJuIF9fYXNzaWduJDEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5mdW5jdGlvbiBfX3NwcmVhZEFycmF5cygpIHtcbiAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XG5cbiAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKSBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKykgcltrXSA9IGFbal07XG5cbiAgcmV0dXJuIHI7XG59XG5cbi8qXG5lZ2pzLWltcmVhZHlcbkNvcHlyaWdodCAoYykgMjAyMC1wcmVzZW50IE5BVkVSIENvcnAuXG5NSVQgbGljZW5zZVxuKi9cbnZhciBpc1dpbmRvdyA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCI7XG52YXIgdWEgPSBpc1dpbmRvdyA/IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50IDogXCJcIjtcbnZhciBTVVBQT1JUX0NPTVBVVEVEU1RZTEUgPSBpc1dpbmRvdyA/ICEhKFwiZ2V0Q29tcHV0ZWRTdHlsZVwiIGluIHdpbmRvdykgOiBmYWxzZTtcbnZhciBJU19JRSA9IC9NU0lFfFRyaWRlbnR8V2luZG93cyBQaG9uZXxFZGdlLy50ZXN0KHVhKTtcbnZhciBTVVBQT1JUX0FEREVWRU5UTElTVEVORVIgPSBpc1dpbmRvdyA/ICEhKFwiYWRkRXZlbnRMaXN0ZW5lclwiIGluIGRvY3VtZW50KSA6IGZhbHNlO1xudmFyIFdJRFRIID0gXCJ3aWR0aFwiO1xudmFyIEhFSUdIVCA9IFwiaGVpZ2h0XCI7XG5cbmZ1bmN0aW9uIGdldEF0dHJpYnV0ZShlbCwgbmFtZSkge1xuICByZXR1cm4gZWwuZ2V0QXR0cmlidXRlKG5hbWUpIHx8IFwiXCI7XG59XG5mdW5jdGlvbiB0b0FycmF5JDEoYXJyKSB7XG4gIHJldHVybiBbXS5zbGljZS5jYWxsKGFycik7XG59XG5mdW5jdGlvbiBoYXNTaXplQXR0cmlidXRlKHRhcmdldCwgcHJlZml4KSB7XG4gIGlmIChwcmVmaXggPT09IHZvaWQgMCkge1xuICAgIHByZWZpeCA9IFwiZGF0YS1cIjtcbiAgfVxuXG4gIHJldHVybiAhIXRhcmdldC5nZXRBdHRyaWJ1dGUocHJlZml4ICsgXCJ3aWR0aFwiKTtcbn1cbmZ1bmN0aW9uIGhhc0xvYWRpbmdBdHRyaWJ1dGUodGFyZ2V0LCBwcmVmaXgpIHtcbiAgaWYgKHByZWZpeCA9PT0gdm9pZCAwKSB7XG4gICAgcHJlZml4ID0gXCJkYXRhLVwiO1xuICB9XG5cbiAgcmV0dXJuIFwibG9hZGluZ1wiIGluIHRhcmdldCAmJiB0YXJnZXQuZ2V0QXR0cmlidXRlKFwibG9hZGluZ1wiKSA9PT0gXCJsYXp5XCIgfHwgISF0YXJnZXQuZ2V0QXR0cmlidXRlKHByZWZpeCArIFwibGF6eVwiKTtcbn1cbmZ1bmN0aW9uIGhhc1NraXBBdHRyaWJ1dGUodGFyZ2V0LCBwcmVmaXgpIHtcbiAgaWYgKHByZWZpeCA9PT0gdm9pZCAwKSB7XG4gICAgcHJlZml4ID0gXCJkYXRhLVwiO1xuICB9XG5cbiAgcmV0dXJuICEhdGFyZ2V0LmdldEF0dHJpYnV0ZShwcmVmaXggKyBcInNraXBcIik7XG59XG5mdW5jdGlvbiBhZGRFdmVudChlbGVtZW50LCB0eXBlLCBoYW5kbGVyKSB7XG4gIGlmIChTVVBQT1JUX0FEREVWRU5UTElTVEVORVIpIHtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgZmFsc2UpO1xuICB9IGVsc2UgaWYgKGVsZW1lbnQuYXR0YWNoRXZlbnQpIHtcbiAgICBlbGVtZW50LmF0dGFjaEV2ZW50KFwib25cIiArIHR5cGUsIGhhbmRsZXIpO1xuICB9IGVsc2Uge1xuICAgIGVsZW1lbnRbXCJvblwiICsgdHlwZV0gPSBoYW5kbGVyO1xuICB9XG59XG5mdW5jdGlvbiByZW1vdmVFdmVudChlbGVtZW50LCB0eXBlLCBoYW5kbGVyKSB7XG4gIGlmIChlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcbiAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgZmFsc2UpO1xuICB9IGVsc2UgaWYgKGVsZW1lbnQuZGV0YWNoRXZlbnQpIHtcbiAgICBlbGVtZW50LmRldGFjaEV2ZW50KFwib25cIiArIHR5cGUsIGhhbmRsZXIpO1xuICB9IGVsc2Uge1xuICAgIGVsZW1lbnRbXCJvblwiICsgdHlwZV0gPSBudWxsO1xuICB9XG59XG5mdW5jdGlvbiBpbm5lcldpZHRoKGVsKSB7XG4gIHJldHVybiBnZXRTaXplKGVsLCBcIldpZHRoXCIpO1xufVxuZnVuY3Rpb24gaW5uZXJIZWlnaHQoZWwpIHtcbiAgcmV0dXJuIGdldFNpemUoZWwsIFwiSGVpZ2h0XCIpO1xufVxuZnVuY3Rpb24gZ2V0U3R5bGVzKGVsKSB7XG4gIHJldHVybiAoU1VQUE9SVF9DT01QVVRFRFNUWUxFID8gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpIDogZWwuY3VycmVudFN0eWxlKSB8fCB7fTtcbn1cblxuZnVuY3Rpb24gZ2V0U2l6ZShlbCwgbmFtZSkge1xuICB2YXIgc2l6ZSA9IGVsW1wiY2xpZW50XCIgKyBuYW1lXSB8fCBlbFtcIm9mZnNldFwiICsgbmFtZV07XG4gIHJldHVybiBwYXJzZUZsb2F0KHNpemUgfHwgZ2V0U3R5bGVzKGVsKVtuYW1lLnRvTG93ZXJDYXNlKCldKSB8fCAwO1xufVxuXG5mdW5jdGlvbiBnZXRDb250ZW50RWxlbWVudHMoZWxlbWVudCwgdGFncywgcHJlZml4KSB7XG4gIHZhciBza2lwRWxlbWVudHMgPSB0b0FycmF5JDEoZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKF9fc3ByZWFkQXJyYXlzKFtcIltcIiArIHByZWZpeCArIFwic2tpcF0gW1wiICsgcHJlZml4ICsgXCJ3aWR0aF1cIl0sIHRhZ3MubWFwKGZ1bmN0aW9uICh0YWcpIHtcbiAgICByZXR1cm4gW1wiW1wiICsgcHJlZml4ICsgXCJza2lwXSBcIiArIHRhZywgdGFnICsgXCJbXCIgKyBwcmVmaXggKyBcInNraXBdXCIsIFwiW1wiICsgcHJlZml4ICsgXCJ3aWR0aF0gXCIgKyB0YWddLmpvaW4oXCIsIFwiKTtcbiAgfSkpLmpvaW4oXCIsIFwiKSkpO1xuICByZXR1cm4gdG9BcnJheSQxKGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChcIltcIiArIHByZWZpeCArIFwid2lkdGhdLCBcIiArIHRhZ3Muam9pbihcIiwgXCIpKSkuZmlsdGVyKGZ1bmN0aW9uIChlbCkge1xuICAgIHJldHVybiBza2lwRWxlbWVudHMuaW5kZXhPZihlbCkgPT09IC0xO1xuICB9KTtcbn1cblxuLypcbmVnanMtaW1yZWFkeVxuQ29weXJpZ2h0IChjKSAyMDIwLXByZXNlbnQgTkFWRVIgQ29ycC5cbk1JVCBsaWNlbnNlXG4qL1xudmFyIGVsZW1lbnRzID0gW107XG5mdW5jdGlvbiBhZGRBdXRvU2l6ZXIoZWxlbWVudCwgcHJlZml4KSB7XG4gICFlbGVtZW50cy5sZW5ndGggJiYgYWRkRXZlbnQod2luZG93LCBcInJlc2l6ZVwiLCByZXNpemVBbGxBdXRvU2l6ZXJzKTtcbiAgZWxlbWVudC5fX1BSRUZJWF9fID0gcHJlZml4O1xuICBlbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuICByZXNpemUoZWxlbWVudCk7XG59XG5mdW5jdGlvbiByZW1vdmVBdXRvU2l6ZXIoZWxlbWVudCwgcHJlZml4KSB7XG4gIHZhciBpbmRleCA9IGVsZW1lbnRzLmluZGV4T2YoZWxlbWVudCk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBmaXhlZCA9IGdldEF0dHJpYnV0ZShlbGVtZW50LCBwcmVmaXggKyBcImZpeGVkXCIpO1xuICBkZWxldGUgZWxlbWVudC5fX1BSRUZJWF9fO1xuICBlbGVtZW50LnN0eWxlW2ZpeGVkID09PSBIRUlHSFQgPyBXSURUSCA6IEhFSUdIVF0gPSBcIlwiO1xuICBlbGVtZW50cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAhZWxlbWVudHMubGVuZ3RoICYmIHJlbW92ZUV2ZW50KHdpbmRvdywgXCJyZXNpemVcIiwgcmVzaXplQWxsQXV0b1NpemVycyk7XG59XG5cbmZ1bmN0aW9uIHJlc2l6ZShlbGVtZW50LCBwcmVmaXgpIHtcbiAgaWYgKHByZWZpeCA9PT0gdm9pZCAwKSB7XG4gICAgcHJlZml4ID0gXCJkYXRhLVwiO1xuICB9XG5cbiAgdmFyIGVsZW1lbnRQcmVmaXggPSBlbGVtZW50Ll9fUFJFRklYX18gfHwgcHJlZml4O1xuICB2YXIgZGF0YVdpZHRoID0gcGFyc2VJbnQoZ2V0QXR0cmlidXRlKGVsZW1lbnQsIFwiXCIgKyBlbGVtZW50UHJlZml4ICsgV0lEVEgpLCAxMCkgfHwgMDtcbiAgdmFyIGRhdGFIZWlnaHQgPSBwYXJzZUludChnZXRBdHRyaWJ1dGUoZWxlbWVudCwgXCJcIiArIGVsZW1lbnRQcmVmaXggKyBIRUlHSFQpLCAxMCkgfHwgMDtcbiAgdmFyIGZpeGVkID0gZ2V0QXR0cmlidXRlKGVsZW1lbnQsIGVsZW1lbnRQcmVmaXggKyBcImZpeGVkXCIpO1xuXG4gIGlmIChmaXhlZCA9PT0gSEVJR0hUKSB7XG4gICAgdmFyIHNpemUgPSBpbm5lckhlaWdodChlbGVtZW50KSB8fCBkYXRhSGVpZ2h0O1xuICAgIGVsZW1lbnQuc3R5bGVbV0lEVEhdID0gZGF0YVdpZHRoIC8gZGF0YUhlaWdodCAqIHNpemUgKyBcInB4XCI7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHNpemUgPSBpbm5lcldpZHRoKGVsZW1lbnQpIHx8IGRhdGFXaWR0aDtcbiAgICBlbGVtZW50LnN0eWxlW0hFSUdIVF0gPSBkYXRhSGVpZ2h0IC8gZGF0YVdpZHRoICogc2l6ZSArIFwicHhcIjtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNpemVBbGxBdXRvU2l6ZXJzKCkge1xuICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgcmVzaXplKGVsZW1lbnQpO1xuICB9KTtcbn1cblxudmFyIExvYWRlciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyQyKExvYWRlciwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBMb2FkZXIoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMuaXNSZWFkeSA9IGZhbHNlO1xuICAgIF90aGlzLmlzUHJlUmVhZHkgPSBmYWxzZTtcbiAgICBfdGhpcy5oYXNEYXRhU2l6ZSA9IGZhbHNlO1xuICAgIF90aGlzLmhhc0xvYWRpbmcgPSBmYWxzZTtcbiAgICBfdGhpcy5pc1NraXAgPSBmYWxzZTtcblxuICAgIF90aGlzLm9uQ2hlY2sgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgX3RoaXMuY2xlYXIoKTtcblxuICAgICAgaWYgKGUgJiYgZS50eXBlID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgX3RoaXMub25FcnJvcihfdGhpcy5lbGVtZW50KTtcbiAgICAgIH1cblxuICAgICAgaWYgKF90aGlzLmhhc0xvYWRpbmcgJiYgX3RoaXMuY2hlY2tFbGVtZW50KCkpIHtcbiAgICAgICAgLy8gSSdtIG5vdCByZWFkeVxuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIEknbSBwcmUtcmVhZHkgYW5kIHJlYWR5IVxuXG5cbiAgICAgIHZhciB3aXRoUHJlUmVhZHkgPSAhX3RoaXMuaGFzRGF0YVNpemUgJiYgIV90aGlzLmhhc0xvYWRpbmc7XG5cbiAgICAgIF90aGlzLm9uUmVhZHkod2l0aFByZVJlYWR5KTtcbiAgICB9O1xuXG4gICAgX3RoaXMub3B0aW9ucyA9IF9fYXNzaWduJDEoe1xuICAgICAgcHJlZml4OiBcImRhdGEtXCJcbiAgICB9LCBvcHRpb25zKTtcbiAgICBfdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICB2YXIgcHJlZml4ID0gX3RoaXMub3B0aW9ucy5wcmVmaXg7XG4gICAgX3RoaXMuaGFzRGF0YVNpemUgPSBoYXNTaXplQXR0cmlidXRlKGVsZW1lbnQsIHByZWZpeCk7XG4gICAgX3RoaXMuaXNTa2lwID0gaGFzU2tpcEF0dHJpYnV0ZShlbGVtZW50LCBwcmVmaXgpO1xuICAgIF90aGlzLmhhc0xvYWRpbmcgPSBoYXNMb2FkaW5nQXR0cmlidXRlKGVsZW1lbnQsIHByZWZpeCk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9fcHJvdG8gPSBMb2FkZXIucHJvdG90eXBlO1xuXG4gIF9fcHJvdG8uY2hlY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuaXNTa2lwIHx8ICF0aGlzLmNoZWNrRWxlbWVudCgpKSB7XG4gICAgICAvLyBJJ20gUmVhZHlcbiAgICAgIHRoaXMub25BbHJlYWR5UmVhZHkodHJ1ZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaGFzRGF0YVNpemUpIHtcbiAgICAgIGFkZEF1dG9TaXplcih0aGlzLmVsZW1lbnQsIHRoaXMub3B0aW9ucy5wcmVmaXgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmhhc0RhdGFTaXplIHx8IHRoaXMuaGFzTG9hZGluZykge1xuICAgICAgLy8gSSdtIFByZSBSZWFkeVxuICAgICAgdGhpcy5vbkFscmVhZHlQcmVSZWFkeSgpO1xuICAgIH0gLy8gV2F0aSBQcmUgUmVhZHksIFJlYWR5XG5cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIF9fcHJvdG8uYWRkRXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcbiAgICB0aGlzLmNvbnN0cnVjdG9yLkVWRU5UUy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBhZGRFdmVudChlbGVtZW50LCBuYW1lLCBfdGhpcy5vbkNoZWNrKTtcbiAgICB9KTtcbiAgfTtcblxuICBfX3Byb3RvLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcbiAgICB0aGlzLmNvbnN0cnVjdG9yLkVWRU5UUy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICByZW1vdmVFdmVudChlbGVtZW50LCBuYW1lLCBfdGhpcy5vbkNoZWNrKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlbW92ZUF1dG9TaXplcigpO1xuICB9O1xuXG4gIF9fcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNsZWFyKCk7XG4gICAgdGhpcy5vZmYoKTtcbiAgfTtcblxuICBfX3Byb3RvLnJlbW92ZUF1dG9TaXplciA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5oYXNEYXRhU2l6ZSkge1xuICAgICAgLy8gSSdtIGFscmVhZHkgcmVhZHkuXG4gICAgICB2YXIgcHJlZml4ID0gdGhpcy5vcHRpb25zLnByZWZpeDtcbiAgICAgIHJlbW92ZUF1dG9TaXplcih0aGlzLmVsZW1lbnQsIHByZWZpeCk7XG4gICAgfVxuICB9O1xuXG4gIF9fcHJvdG8ub25FcnJvciA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICB0aGlzLnRyaWdnZXIoXCJlcnJvclwiLCB7XG4gICAgICBlbGVtZW50OiB0aGlzLmVsZW1lbnQsXG4gICAgICB0YXJnZXQ6IHRhcmdldFxuICAgIH0pO1xuICB9O1xuXG4gIF9fcHJvdG8ub25QcmVSZWFkeSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5pc1ByZVJlYWR5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5pc1ByZVJlYWR5ID0gdHJ1ZTtcbiAgICB0aGlzLnRyaWdnZXIoXCJwcmVSZWFkeVwiLCB7XG4gICAgICBlbGVtZW50OiB0aGlzLmVsZW1lbnQsXG4gICAgICBoYXNMb2FkaW5nOiB0aGlzLmhhc0xvYWRpbmcsXG4gICAgICBpc1NraXA6IHRoaXMuaXNTa2lwXG4gICAgfSk7XG4gIH07XG5cbiAgX19wcm90by5vblJlYWR5ID0gZnVuY3Rpb24gKHdpdGhQcmVSZWFkeSkge1xuICAgIGlmICh0aGlzLmlzUmVhZHkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3aXRoUHJlUmVhZHkgPSAhdGhpcy5pc1ByZVJlYWR5ICYmIHdpdGhQcmVSZWFkeTtcblxuICAgIGlmICh3aXRoUHJlUmVhZHkpIHtcbiAgICAgIHRoaXMuaXNQcmVSZWFkeSA9IHRydWU7XG4gICAgfVxuXG4gICAgdGhpcy5yZW1vdmVBdXRvU2l6ZXIoKTtcbiAgICB0aGlzLmlzUmVhZHkgPSB0cnVlO1xuICAgIHRoaXMudHJpZ2dlcihcInJlYWR5XCIsIHtcbiAgICAgIGVsZW1lbnQ6IHRoaXMuZWxlbWVudCxcbiAgICAgIHdpdGhQcmVSZWFkeTogd2l0aFByZVJlYWR5LFxuICAgICAgaGFzTG9hZGluZzogdGhpcy5oYXNMb2FkaW5nLFxuICAgICAgaXNTa2lwOiB0aGlzLmlzU2tpcFxuICAgIH0pO1xuICB9O1xuXG4gIF9fcHJvdG8ub25BbHJlYWR5RXJyb3IgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMub25FcnJvcih0YXJnZXQpO1xuICAgIH0pO1xuICB9O1xuXG4gIF9fcHJvdG8ub25BbHJlYWR5UHJlUmVhZHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMub25QcmVSZWFkeSgpO1xuICAgIH0pO1xuICB9O1xuXG4gIF9fcHJvdG8ub25BbHJlYWR5UmVhZHkgPSBmdW5jdGlvbiAod2l0aFByZVJlYWR5KSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMub25SZWFkeSh3aXRoUHJlUmVhZHkpO1xuICAgIH0pO1xuICB9O1xuXG4gIExvYWRlci5FVkVOVFMgPSBbXTtcbiAgcmV0dXJuIExvYWRlcjtcbn0oQ29tcG9uZW50KTtcblxudmFyIEVsZW1lbnRMb2FkZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMkMihFbGVtZW50TG9hZGVyLCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIEVsZW1lbnRMb2FkZXIoKSB7XG4gICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9fcHJvdG8gPSBFbGVtZW50TG9hZGVyLnByb3RvdHlwZTtcblxuICBfX3Byb3RvLnNldEhhc0xvYWRpbmcgPSBmdW5jdGlvbiAoaGFzTG9hZGluZykge1xuICAgIHRoaXMuaGFzTG9hZGluZyA9IGhhc0xvYWRpbmc7XG4gIH07XG5cbiAgX19wcm90by5jaGVjayA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5pc1NraXApIHtcbiAgICAgIC8vIEknbSBSZWFkeVxuICAgICAgdGhpcy5vbkFscmVhZHlSZWFkeSh0cnVlKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5oYXNEYXRhU2l6ZSkge1xuICAgICAgYWRkQXV0b1NpemVyKHRoaXMuZWxlbWVudCwgdGhpcy5vcHRpb25zLnByZWZpeCk7XG4gICAgICB0aGlzLm9uQWxyZWFkeVByZVJlYWR5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGhhcyBub3QgZGF0YSBzaXplXG4gICAgICB0aGlzLnRyaWdnZXIoXCJyZXF1ZXN0Q2hpbGRyZW5cIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgX19wcm90by5jaGVja0VsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgX19wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuY2xlYXIoKTtcbiAgICB0aGlzLnRyaWdnZXIoXCJyZXF1ZXN0RGVzdHJveVwiKTtcbiAgICB0aGlzLm9mZigpO1xuICB9O1xuXG4gIF9fcHJvdG8ub25BbHJlYWR5UHJlUmVhZHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gaGFzIGRhdGEgc2l6ZVxuICAgIF9zdXBlci5wcm90b3R5cGUub25BbHJlYWR5UHJlUmVhZHkuY2FsbCh0aGlzKTtcblxuICAgIHRoaXMudHJpZ2dlcihcInJlcWV1c3RSZWFkeUNoaWxkcmVuXCIpO1xuICB9O1xuXG4gIEVsZW1lbnRMb2FkZXIuRVZFTlRTID0gW107XG4gIHJldHVybiBFbGVtZW50TG9hZGVyO1xufShMb2FkZXIpO1xuXG4vKipcbiAqIEBhbGlhcyBlZy5JbVJlYWR5XG4gKiBAZXh0ZW5kcyBlZy5Db21wb25lbnRcbiAqL1xuXG52YXIgSW1SZWFkeU1hbmFnZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMkMihJbVJlYWR5TWFuYWdlciwgX3N1cGVyKTtcbiAgLyoqXG4gICAqIEBwYXJhbSAtIEltUmVhZHkncyBvcHRpb25zXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gSW1SZWFkeU1hbmFnZXIob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMucmVhZHlDb3VudCA9IDA7XG4gICAgX3RoaXMucHJlUmVhZHlDb3VudCA9IDA7XG4gICAgX3RoaXMudG90YWxDb3VudCA9IDA7XG4gICAgX3RoaXMudG90YWxFcnJvckNvdW50ID0gMDtcbiAgICBfdGhpcy5pc1ByZVJlYWR5T3ZlciA9IHRydWU7XG4gICAgX3RoaXMuZWxlbWVudEluZm9zID0gW107XG4gICAgX3RoaXMub3B0aW9ucyA9IF9fYXNzaWduJDEoe1xuICAgICAgbG9hZGVyczoge30sXG4gICAgICBwcmVmaXg6IFwiZGF0YS1cIlxuICAgIH0sIG9wdGlvbnMpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgZWxlbWVudHMgYXJlIGluIHRoZSByZWFkeSBzdGF0ZS5cbiAgICogQGtvIOyXmOumrOuovO2KuOqwgCDspIDruYQg7IOB7YOc7J247KeAIOyytO2BrO2VnOuLpC5cbiAgICogQGVsZW1lbnRzIC0gRWxlbWVudHMgdG8gY2hlY2sgcmVhZHkgc3RhdHVzLiA8a28+IOykgOu5hCDsg4Htg5zrpbwg7LK07YGs7ZWgIOyXmOumrOuovO2KuOuTpC48L2tvPlxuICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2PlxuICAgICAqICAgIDxpbWcgc3JjPVwiLi8xLmpwZ1wiIGRhdGEtd2lkdGg9XCIxMjgwXCIgZGF0YS1oZWlnaHQ9XCI4NTNcIiBzdHlsZT1cIndpZHRoOjEwMCVcIi8+XG4gICAgICogICAgPGltZyBzcmM9XCIuLzIuanBnXCIgZGF0YS13aWR0aD1cIjEyODBcIiBkYXRhLWhlaWdodD1cIjg1M1wiLz5cbiAgICAgKiAgICA8aW1nIHNyYz1cIkVSUlwiIGRhdGEtd2lkdGg9XCIxMjgwXCIgZGF0YS1oZWlnaHQ9XCI4NTNcIi8+XG4gICAgICogPC9kaXY+XG4gICAgICogYGBgXG4gICAgICogIyMgSmF2YXNjcmlwdFxuICAgICAqIGBgYGpzXG4gICAgICogaW1wb3J0IEltUmVhZHkgZnJvbSBcIkBlZ2pzL2ltcmVhZHlcIjtcbiAgICAgKlxuICAgICAqIGNvbnN0IGltID0gbmV3IEltUmVhZHkoKTsgLy8gdW1kOiBlZy5JbVJlYWR5XG4gICAgICogaW0uY2hlY2soZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcImltZ1wiKSkub24oe1xuICAgICAqICAgcHJlUmVhZHlFbGVtZW50OiBlID0+IHtcbiAgICAgKiAgICAgLy8gMSwgM1xuICAgICAqICAgICAvLyAyLCAzXG4gICAgICogICAgIC8vIDMsIDNcbiAgICAgKiAgICAgY29uc29sZS5sb2coZS5wcmVSZWFkeUNvdW50LCBlLnRvdGFsQ291bnQpLFxuICAgICAqICAgfSxcbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICovXG5cblxuICB2YXIgX19wcm90byA9IEltUmVhZHlNYW5hZ2VyLnByb3RvdHlwZTtcblxuICBfX3Byb3RvLmNoZWNrID0gZnVuY3Rpb24gKGVsZW1lbnRzKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBwcmVmaXggPSB0aGlzLm9wdGlvbnMucHJlZml4O1xuICAgIHRoaXMuY2xlYXIoKTtcbiAgICB0aGlzLmVsZW1lbnRJbmZvcyA9IHRvQXJyYXkkMShlbGVtZW50cykubWFwKGZ1bmN0aW9uIChlbGVtZW50LCBpbmRleCkge1xuICAgICAgdmFyIGxvYWRlciA9IF90aGlzLmdldExvYWRlcihlbGVtZW50LCB7XG4gICAgICAgIHByZWZpeDogcHJlZml4XG4gICAgICB9KTtcblxuICAgICAgbG9hZGVyLmNoZWNrKCk7XG4gICAgICBsb2FkZXIub24oXCJlcnJvclwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBfdGhpcy5vbkVycm9yKGluZGV4LCBlLnRhcmdldCk7XG4gICAgICB9KS5vbihcInByZVJlYWR5XCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBpbmZvID0gX3RoaXMuZWxlbWVudEluZm9zW2luZGV4XTtcbiAgICAgICAgaW5mby5oYXNMb2FkaW5nID0gZS5oYXNMb2FkaW5nO1xuICAgICAgICBpbmZvLmlzU2tpcCA9IGUuaXNTa2lwO1xuXG4gICAgICAgIHZhciBpc1ByZVJlYWR5ID0gX3RoaXMuY2hlY2tQcmVSZWFkeShpbmRleCk7XG5cbiAgICAgICAgX3RoaXMub25QcmVSZWFkeUVsZW1lbnQoaW5kZXgpO1xuXG4gICAgICAgIGlzUHJlUmVhZHkgJiYgX3RoaXMub25QcmVSZWFkeSgpO1xuICAgICAgfSkub24oXCJyZWFkeVwiLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIHdpdGhQcmVSZWFkeSA9IF9hLndpdGhQcmVSZWFkeSxcbiAgICAgICAgICAgIGhhc0xvYWRpbmcgPSBfYS5oYXNMb2FkaW5nLFxuICAgICAgICAgICAgaXNTa2lwID0gX2EuaXNTa2lwO1xuICAgICAgICB2YXIgaW5mbyA9IF90aGlzLmVsZW1lbnRJbmZvc1tpbmRleF07XG4gICAgICAgIGluZm8uaGFzTG9hZGluZyA9IGhhc0xvYWRpbmc7XG4gICAgICAgIGluZm8uaXNTa2lwID0gaXNTa2lwO1xuXG4gICAgICAgIHZhciBpc1ByZVJlYWR5ID0gd2l0aFByZVJlYWR5ICYmIF90aGlzLmNoZWNrUHJlUmVhZHkoaW5kZXgpO1xuXG4gICAgICAgIHZhciBpc1JlYWR5ID0gX3RoaXMuY2hlY2tSZWFkeShpbmRleCk7IC8vIFByZS1yZWFkeSBhbmQgcmVhZHkgb2NjdXIgc2ltdWx0YW5lb3VzbHlcblxuXG4gICAgICAgIHdpdGhQcmVSZWFkeSAmJiBfdGhpcy5vblByZVJlYWR5RWxlbWVudChpbmRleCk7XG5cbiAgICAgICAgX3RoaXMub25SZWFkeUVsZW1lbnQoaW5kZXgpO1xuXG4gICAgICAgIGlzUHJlUmVhZHkgJiYgX3RoaXMub25QcmVSZWFkeSgpO1xuICAgICAgICBpc1JlYWR5ICYmIF90aGlzLm9uUmVhZHkoKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbG9hZGVyOiBsb2FkZXIsXG4gICAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgICAgIGhhc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICBoYXNFcnJvcjogZmFsc2UsXG4gICAgICAgIGlzUHJlUmVhZHk6IGZhbHNlLFxuICAgICAgICBpc1JlYWR5OiBmYWxzZSxcbiAgICAgICAgaXNTa2lwOiBmYWxzZVxuICAgICAgfTtcbiAgICB9KTtcbiAgICB2YXIgbGVuZ3RoID0gdGhpcy5lbGVtZW50SW5mb3MubGVuZ3RoO1xuICAgIHRoaXMudG90YWxDb3VudCA9IGxlbmd0aDtcblxuICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMub25QcmVSZWFkeSgpO1xuXG4gICAgICAgIF90aGlzLm9uUmVhZHkoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogR2V0cyB0aGUgdG90YWwgY291bnQgb2YgZWxlbWVudHMgdG8gYmUgY2hlY2tlZC5cbiAgICogQGtvIOyytO2BrO2VmOuKlCBlbGVtZW507J2YIOy0nSDqsJzsiJjrpbwg6rCA7KC47Jio64ukLlxuICAgKi9cblxuXG4gIF9fcHJvdG8uZ2V0VG90YWxDb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy50b3RhbENvdW50O1xuICB9O1xuICAvKipcbiAgICogV2hldGhlciB0aGUgZWxlbWVudHMgYXJlIGFsbCBwcmUtcmVhZHkuIChhbGwgc2l6ZXMgYXJlIGtub3duKVxuICAgKiBAa28g7JeY66as66i87Yq465Ok7J20IOuqqOuRkCDsgqzsoIQg7KSA67mE6rCAIOuQkOuKlOyngCAo7IKs7J207KaI66W8IOyghOu2gCDslYwg7IiYIOyeiOuKlOyngCkg7Jes67aALlxuICAgKi9cblxuXG4gIF9fcHJvdG8uaXNQcmVSZWFkeSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50SW5mb3MuZXZlcnkoZnVuY3Rpb24gKGluZm8pIHtcbiAgICAgIHJldHVybiBpbmZvLmlzUHJlUmVhZHk7XG4gICAgfSk7XG4gIH07XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBlbGVtZW50cyBhcmUgYWxsIHJlYWR5LlxuICAgKiBAa28g7JeY66as66i87Yq465Ok7J20IOuqqOuRkCDspIDruYTqsIAg65CQ64qU7KeAIOyXrOu2gC5cbiAgICovXG5cblxuICBfX3Byb3RvLmlzUmVhZHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudEluZm9zLmV2ZXJ5KGZ1bmN0aW9uIChpbmZvKSB7XG4gICAgICByZXR1cm4gaW5mby5pc1JlYWR5O1xuICAgIH0pO1xuICB9O1xuICAvKipcbiAgICogV2hldGhlciBhbiBlcnJvciBoYXMgb2NjdXJyZWQgaW4gdGhlIGVsZW1lbnRzIGluIHRoZSBjdXJyZW50IHN0YXRlLlxuICAgKiBAa28g7ZiE7J6sIOyDge2DnOyXkOyEnCDsl5jrpqzrqLztirjrk6TsnbQg7JeQ65+s6rCAIOuwnOyDne2WiOuKlOyngCDsl6zrtoAuXG4gICAqL1xuXG5cbiAgX19wcm90by5oYXNFcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy50b3RhbEVycm9yQ291bnQgPiAwO1xuICB9O1xuICAvKipcbiAgICogQ2xlYXJzIGV2ZW50cyBvZiBlbGVtZW50cyBiZWluZyBjaGVja2VkLlxuICAgKiBAa28g7LK07YGsIOykkeyduCDsl5jrpqzrqLztirjrk6TsnZgg7J2067Kk7Yq466W8IO2VtOygnCDtlZzri6QuXG4gICAqL1xuXG5cbiAgX19wcm90by5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmlzUHJlUmVhZHlPdmVyID0gZmFsc2U7XG4gICAgdGhpcy50b3RhbENvdW50ID0gMDtcbiAgICB0aGlzLnByZVJlYWR5Q291bnQgPSAwO1xuICAgIHRoaXMucmVhZHlDb3VudCA9IDA7XG4gICAgdGhpcy50b3RhbEVycm9yQ291bnQgPSAwO1xuICAgIHRoaXMuZWxlbWVudEluZm9zLmZvckVhY2goZnVuY3Rpb24gKGluZm8pIHtcbiAgICAgIGlmIChpbmZvLmxvYWRlcikge1xuICAgICAgICBpbmZvLmxvYWRlci5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5lbGVtZW50SW5mb3MgPSBbXTtcbiAgfTtcbiAgLyoqXG4gICAqIERlc3RvcnkgYWxsIGV2ZW50cy5cbiAgICogQGtvIOuqqOuToCDsnbTrsqTtirjrpbwg7ZW07KCcIO2VnOuLpC5cbiAgICovXG5cblxuICBfX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jbGVhcigpO1xuICAgIHRoaXMub2ZmKCk7XG4gIH07XG5cbiAgX19wcm90by5nZXRMb2FkZXIgPSBmdW5jdGlvbiAoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgdGFnTmFtZSA9IGVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciBsb2FkZXJzID0gdGhpcy5vcHRpb25zLmxvYWRlcnM7XG4gICAgdmFyIHByZWZpeCA9IG9wdGlvbnMucHJlZml4O1xuICAgIHZhciB0YWdzID0gT2JqZWN0LmtleXMobG9hZGVycyk7XG5cbiAgICBpZiAobG9hZGVyc1t0YWdOYW1lXSkge1xuICAgICAgcmV0dXJuIG5ldyBsb2FkZXJzW3RhZ05hbWVdKGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHZhciBsb2FkZXIgPSBuZXcgRWxlbWVudExvYWRlcihlbGVtZW50LCBvcHRpb25zKTtcbiAgICB2YXIgY2hpbGRyZW4gPSB0b0FycmF5JDEoZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKHRhZ3Muam9pbihcIiwgXCIpKSk7XG4gICAgbG9hZGVyLnNldEhhc0xvYWRpbmcoY2hpbGRyZW4uc29tZShmdW5jdGlvbiAoZWwpIHtcbiAgICAgIHJldHVybiBoYXNMb2FkaW5nQXR0cmlidXRlKGVsLCBwcmVmaXgpO1xuICAgIH0pKTtcbiAgICB2YXIgd2l0aFByZVJlYWR5ID0gZmFsc2U7XG4gICAgdmFyIGNoaWxkcmVuSW1SZWFkeSA9IHRoaXMuY2xvbmUoKS5vbihcImVycm9yXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBsb2FkZXIub25FcnJvcihlLnRhcmdldCk7XG4gICAgfSkub24oXCJyZWFkeVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBsb2FkZXIub25SZWFkeSh3aXRoUHJlUmVhZHkpO1xuICAgIH0pO1xuICAgIGxvYWRlci5vbihcInJlcXVlc3RDaGlsZHJlblwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBoYXMgbm90IGRhdGEgc2l6ZVxuICAgICAgdmFyIGNvbnRlbnRFbGVtZW50cyA9IGdldENvbnRlbnRFbGVtZW50cyhlbGVtZW50LCB0YWdzLCBfdGhpcy5vcHRpb25zLnByZWZpeCk7XG4gICAgICBjaGlsZHJlbkltUmVhZHkuY2hlY2soY29udGVudEVsZW1lbnRzKS5vbihcInByZVJlYWR5XCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHdpdGhQcmVSZWFkeSA9IGUuaXNSZWFkeTtcblxuICAgICAgICBpZiAoIXdpdGhQcmVSZWFkeSkge1xuICAgICAgICAgIGxvYWRlci5vblByZVJlYWR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pLm9uKFwicmVxZXVzdFJlYWR5Q2hpbGRyZW5cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgLy8gaGFzIGRhdGEgc2l6ZVxuICAgICAgLy8gbG9hZGVyIGNhbGwgcHJlUmVhZHlcbiAgICAgIC8vIGNoZWNrIG9ubHkgdmlkZW8sIGltYWdlIGVsZW1lbnRzXG4gICAgICBjaGlsZHJlbkltUmVhZHkuY2hlY2soY2hpbGRyZW4pO1xuICAgIH0pLm9uKFwicmVxdWVzdERlc3Ryb3lcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgY2hpbGRyZW5JbVJlYWR5LmRlc3Ryb3koKTtcbiAgICB9KTtcbiAgICByZXR1cm4gbG9hZGVyO1xuICB9O1xuXG4gIF9fcHJvdG8uY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBJbVJlYWR5TWFuYWdlcihfX2Fzc2lnbiQxKHt9LCB0aGlzLm9wdGlvbnMpKTtcbiAgfTtcblxuICBfX3Byb3RvLmNoZWNrUHJlUmVhZHkgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICB0aGlzLmVsZW1lbnRJbmZvc1tpbmRleF0uaXNQcmVSZWFkeSA9IHRydWU7XG4gICAgKyt0aGlzLnByZVJlYWR5Q291bnQ7XG5cbiAgICBpZiAodGhpcy5wcmVSZWFkeUNvdW50IDwgdGhpcy50b3RhbENvdW50KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgX19wcm90by5jaGVja1JlYWR5ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgdGhpcy5lbGVtZW50SW5mb3NbaW5kZXhdLmlzUmVhZHkgPSB0cnVlO1xuICAgICsrdGhpcy5yZWFkeUNvdW50O1xuXG4gICAgaWYgKHRoaXMucmVhZHlDb3VudCA8IHRoaXMudG90YWxDb3VudCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIF9fcHJvdG8ub25FcnJvciA9IGZ1bmN0aW9uIChpbmRleCwgdGFyZ2V0KSB7XG4gICAgdmFyIGluZm8gPSB0aGlzLmVsZW1lbnRJbmZvc1tpbmRleF07XG4gICAgaW5mby5oYXNFcnJvciA9IHRydWU7XG4gICAgLyoqXG4gICAgICogQW4gZXZlbnQgb2NjdXJzIGlmIHRoZSBpbWFnZSwgdmlkZW8gZmFpbHMgdG8gbG9hZC5cbiAgICAgKiBAa28g7J2066+47KeALCDruYTrlJTsmKTqsIAg66Gc65Sp7JeQIOyLpO2MqO2VmOuptCDsnbTrsqTtirjqsIAg67Cc7IOd7ZWc64ukLlxuICAgICAqIEBldmVudCBlZy5JbVJlYWR5I2Vycm9yXG4gICAgICogQHBhcmFtIHtlZy5JbVJlYWR5Lk9uRXJyb3J9IGUgLSBUaGUgb2JqZWN0IG9mIGRhdGEgdG8gYmUgc2VudCB0byBhbiBldmVudCA8a28+7J2067Kk7Yq47JeQIOyghOuLrOuQmOuKlCDrjbDsnbTthLAg6rCd7LK0PC9rbz5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2PlxuICAgICAqICAgIDxpbWcgc3JjPVwiLi8xLmpwZ1wiIGRhdGEtd2lkdGg9XCIxMjgwXCIgZGF0YS1oZWlnaHQ9XCI4NTNcIiBzdHlsZT1cIndpZHRoOjEwMCVcIi8+XG4gICAgICogICAgPGltZyBzcmM9XCIuLzIuanBnXCIvPlxuICAgICAqICAgIDxpbWcgc3JjPVwiRVJSXCIvPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqICMjIEphdmFzY3JpcHRcbiAgICAgKiBgYGBqc1xuICAgICAqIGltcG9ydCBJbVJlYWR5IGZyb20gXCJAZWdqcy9pbXJlYWR5XCI7XG4gICAgICpcbiAgICAgKiBjb25zdCBpbSA9IG5ldyBJbVJlYWR5KCk7IC8vIHVtZDogZWcuSW1SZWFkeVxuICAgICAqIGltLmNoZWNrKFtkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiZGl2XCIpXSkub24oe1xuICAgICAqICAgZXJyb3I6IGUgPT4ge1xuICAgICAqICAgICAvLyA8ZGl2Pi4uLjwvZGl2PiwgMCwgPGltZyBzcmM9XCJFUlJcIi8+XG4gICAgICogICAgIGNvbnNvbGUubG9nKGUuZWxlbWVudCwgZS5pbmRleCwgZS50YXJnZXQpLFxuICAgICAqICAgfSxcbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cblxuICAgIHRoaXMudHJpZ2dlcihuZXcgQ29tcG9uZW50RXZlbnQkMShcImVycm9yXCIsIHtcbiAgICAgIGVsZW1lbnQ6IGluZm8uZWxlbWVudCxcbiAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgZXJyb3JDb3VudDogdGhpcy5nZXRFcnJvckNvdW50KCksXG4gICAgICB0b3RhbEVycm9yQ291bnQ6ICsrdGhpcy50b3RhbEVycm9yQ291bnRcbiAgICB9KSk7XG4gIH07XG5cbiAgX19wcm90by5vblByZVJlYWR5RWxlbWVudCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgIHZhciBpbmZvID0gdGhpcy5lbGVtZW50SW5mb3NbaW5kZXhdO1xuICAgIC8qKlxuICAgICAqIEFuIGV2ZW50IG9jY3VycyB3aGVuIHRoZSBlbGVtZW50IGlzIHByZS1yZWFkeSAod2hlbiB0aGUgbG9hZGluZyBhdHRyaWJ1dGUgaXMgYXBwbGllZCBvciB0aGUgc2l6ZSBpcyBrbm93bilcbiAgICAgKiBAa28g7ZW064u5IOyXmOumrOuovO2KuOqwgCDsgqzsoIQg7KSA67mE65CY7JeI7J2EIOuVjChsb2FkaW5nIOyGjeyEseydtCDsoIHsmqnrkJjsl4jqsbDrgpgg7IKs7J207KaI66W8IOyVjCDsiJgg7J6I7J2EIOuVjCkg7J2067Kk7Yq46rCAIOuwnOyDne2VnOuLpC5cbiAgICAgKiBAZXZlbnQgZWcuSW1SZWFkeSNwcmVSZWFkeUVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge2VnLkltUmVhZHkuT25QcmVSZWFkeUVsZW1lbnR9IGUgLSBUaGUgb2JqZWN0IG9mIGRhdGEgdG8gYmUgc2VudCB0byBhbiBldmVudCA8a28+7J2067Kk7Yq47JeQIOyghOuLrOuQmOuKlCDrjbDsnbTthLAg6rCd7LK0PC9rbz5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2PlxuICAgICAqICAgIDxpbWcgc3JjPVwiLi8xLmpwZ1wiIGRhdGEtd2lkdGg9XCIxMjgwXCIgZGF0YS1oZWlnaHQ9XCI4NTNcIiBzdHlsZT1cIndpZHRoOjEwMCVcIi8+XG4gICAgICogICAgPGltZyBzcmM9XCIuLzIuanBnXCIgZGF0YS13aWR0aD1cIjEyODBcIiBkYXRhLWhlaWdodD1cIjg1M1wiLz5cbiAgICAgKiAgICA8aW1nIHNyYz1cIkVSUlwiIGRhdGEtd2lkdGg9XCIxMjgwXCIgZGF0YS1oZWlnaHQ9XCI4NTNcIi8+XG4gICAgICogPC9kaXY+XG4gICAgICogYGBgXG4gICAgICogIyMgSmF2YXNjcmlwdFxuICAgICAqIGBgYGpzXG4gICAgICogaW1wb3J0IEltUmVhZHkgZnJvbSBcIkBlZ2pzL2ltcmVhZHlcIjtcbiAgICAgKlxuICAgICAqIGNvbnN0IGltID0gbmV3IEltUmVhZHkoKTsgLy8gdW1kOiBlZy5JbVJlYWR5XG4gICAgICogaW0uY2hlY2soZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcImltZ1wiKSkub24oe1xuICAgICAqICAgcHJlUmVhZHlFbGVtZW50OiBlID0+IHtcbiAgICAgKiAgICAgLy8gMSwgM1xuICAgICAqICAgICAvLyAyLCAzXG4gICAgICogICAgIC8vIDMsIDNcbiAgICAgKiAgICAgY29uc29sZS5sb2coZS5wcmVSZWFkeUNvdW50LCBlLnRvdGFsQ291bnQpLFxuICAgICAqICAgfSxcbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cblxuICAgIHRoaXMudHJpZ2dlcihuZXcgQ29tcG9uZW50RXZlbnQkMShcInByZVJlYWR5RWxlbWVudFwiLCB7XG4gICAgICBlbGVtZW50OiBpbmZvLmVsZW1lbnQsXG4gICAgICBpbmRleDogaW5kZXgsXG4gICAgICBwcmVSZWFkeUNvdW50OiB0aGlzLnByZVJlYWR5Q291bnQsXG4gICAgICByZWFkeUNvdW50OiB0aGlzLnJlYWR5Q291bnQsXG4gICAgICB0b3RhbENvdW50OiB0aGlzLnRvdGFsQ291bnQsXG4gICAgICBpc1ByZVJlYWR5OiB0aGlzLmlzUHJlUmVhZHkoKSxcbiAgICAgIGlzUmVhZHk6IHRoaXMuaXNSZWFkeSgpLFxuICAgICAgaGFzTG9hZGluZzogaW5mby5oYXNMb2FkaW5nLFxuICAgICAgaXNTa2lwOiBpbmZvLmlzU2tpcFxuICAgIH0pKTtcbiAgfTtcblxuICBfX3Byb3RvLm9uUHJlUmVhZHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5pc1ByZVJlYWR5T3ZlciA9IHRydWU7XG4gICAgLyoqXG4gICAgICogQW4gZXZlbnQgb2NjdXJzIHdoZW4gYWxsIGVsZW1lbnQgYXJlIHByZS1yZWFkeSAoV2hlbiBhbGwgZWxlbWVudHMgaGF2ZSB0aGUgbG9hZGluZyBhdHRyaWJ1dGUgYXBwbGllZCBvciB0aGUgc2l6ZSBpcyBrbm93bilcbiAgICAgKiBAa28g66qo65OgIOyXmOumrOuovO2KuOuTpOydtCDsgqzsoIQg7KSA67mE65CcIOqyveyasCAo66qo65OgIOyXmOumrOuovO2KuOuTpOydtCBsb2FkaW5nIOyGjeyEseydtCDsoIHsmqnrkJjsl4jqsbDrgpgg7IKs7J207KaI66W8IOyVjCDsiJgg7J6I64qUIOqyveyasCkg7J2067Kk7Yq46rCAIOuwnOyDne2VnOuLpC5cbiAgICAgKiBAZXZlbnQgZWcuSW1SZWFkeSNwcmVSZWFkeVxuICAgICAqIEBwYXJhbSB7ZWcuSW1SZWFkeS5PblByZVJlYWR5fSBlIC0gVGhlIG9iamVjdCBvZiBkYXRhIHRvIGJlIHNlbnQgdG8gYW4gZXZlbnQgPGtvPuydtOuypO2KuOyXkCDsoITri6zrkJjripQg642w7J207YSwIOqwneyytDwva28+XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdj5cbiAgICAgKiAgICA8aW1nIHNyYz1cIi4vMS5qcGdcIiBkYXRhLXdpZHRoPVwiMTI4MFwiIGRhdGEtaGVpZ2h0PVwiODUzXCIgc3R5bGU9XCJ3aWR0aDoxMDAlXCIvPlxuICAgICAqICAgIDxpbWcgc3JjPVwiLi8yLmpwZ1wiIGRhdGEtd2lkdGg9XCIxMjgwXCIgZGF0YS1oZWlnaHQ9XCI4NTNcIi8+XG4gICAgICogICAgPGltZyBzcmM9XCJFUlJcIiBkYXRhLXdpZHRoPVwiMTI4MFwiIGRhdGEtaGVpZ2h0PVwiODUzXCIvPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqICMjIEphdmFzY3JpcHRcbiAgICAgKiBgYGBqc1xuICAgICAqIGltcG9ydCBJbVJlYWR5IGZyb20gXCJAZWdqcy9pbXJlYWR5XCI7XG4gICAgICpcbiAgICAgKiBjb25zdCBpbSA9IG5ldyBJbVJlYWR5KCk7IC8vIHVtZDogZWcuSW1SZWFkeVxuICAgICAqIGltLmNoZWNrKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJpbWdcIikpLm9uKHtcbiAgICAgKiAgIHByZVJlYWR5OiBlID0+IHtcbiAgICAgKiAgICAgLy8gMCwgM1xuICAgICAqICAgICBjb25zb2xlLmxvZyhlLnJlYWR5Q291bnQsIGUudG90YWxDb3VudCksXG4gICAgICogICB9LFxuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqL1xuXG4gICAgdGhpcy50cmlnZ2VyKG5ldyBDb21wb25lbnRFdmVudCQxKFwicHJlUmVhZHlcIiwge1xuICAgICAgcmVhZHlDb3VudDogdGhpcy5yZWFkeUNvdW50LFxuICAgICAgdG90YWxDb3VudDogdGhpcy50b3RhbENvdW50LFxuICAgICAgaXNSZWFkeTogdGhpcy5pc1JlYWR5KCksXG4gICAgICBoYXNMb2FkaW5nOiB0aGlzLmhhc0xvYWRpbmcoKVxuICAgIH0pKTtcbiAgfTtcblxuICBfX3Byb3RvLm9uUmVhZHlFbGVtZW50ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgdmFyIGluZm8gPSB0aGlzLmVsZW1lbnRJbmZvc1tpbmRleF07XG4gICAgLyoqXG4gICAgICogQW4gZXZlbnQgb2NjdXJzIHdoZW4gdGhlIGVsZW1lbnQgaXMgcmVhZHlcbiAgICAgKiBAa28g7ZW064u5IOyXmOumrOuovO2KuOqwgCDspIDruYTqsIAg65CY7JeI7J2EIOuVjCDsnbTrsqTtirjqsIAg67Cc7IOd7ZWc64ukLlxuICAgICAqIEBldmVudCBlZy5JbVJlYWR5I3JlYWR5RWxlbWVudFxuICAgICAqIEBwYXJhbSB7ZWcuSW1SZWFkeS5PblJlYWR5RWxlbWVudH0gZSAtIFRoZSBvYmplY3Qgb2YgZGF0YSB0byBiZSBzZW50IHRvIGFuIGV2ZW50IDxrbz7snbTrsqTtirjsl5Ag7KCE64us65CY64qUIOuNsOydtO2EsCDqsJ3ssrQ8L2tvPlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXY+XG4gICAgICogICAgPGltZyBzcmM9XCIuLzEuanBnXCIgZGF0YS13aWR0aD1cIjEyODBcIiBkYXRhLWhlaWdodD1cIjg1M1wiIHN0eWxlPVwid2lkdGg6MTAwJVwiLz5cbiAgICAgKiAgICA8aW1nIHNyYz1cIi4vMi5qcGdcIiBkYXRhLXdpZHRoPVwiMTI4MFwiIGRhdGEtaGVpZ2h0PVwiODUzXCIvPlxuICAgICAqICAgIDxpbWcgc3JjPVwiRVJSXCIgZGF0YS13aWR0aD1cIjEyODBcIiBkYXRhLWhlaWdodD1cIjg1M1wiLz5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKiAjIyBKYXZhc2NyaXB0XG4gICAgICogYGBganNcbiAgICAgKiBpbXBvcnQgSW1SZWFkeSBmcm9tIFwiQGVnanMvaW1yZWFkeVwiO1xuICAgICAqXG4gICAgICogY29uc3QgaW0gPSBuZXcgSW1SZWFkeSgpOyAvLyB1bWQ6IGVnLkltUmVhZHlcbiAgICAgKiBpbS5jaGVjayhkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiaW1nXCIpKS5vbih7XG4gICAgICogICByZWFkeUVsZW1lbnQ6IGUgPT4ge1xuICAgICAqICAgICAvLyAxLCAwLCBmYWxzZSwgM1xuICAgICAqICAgICAvLyAyLCAxLCBmYWxzZSwgM1xuICAgICAqICAgICAvLyAzLCAyLCB0cnVlLCAzXG4gICAgICogICAgIGNvbnNvbGUubG9nKGUucmVhZHlDb3VudCwgZS5pbmRleCwgZS5oYXNFcnJvciwgZS50b3RhbENvdW50KSxcbiAgICAgKiAgIH0sXG4gICAgICogfSk7XG4gICAgICogYGBgXG4gICAgICovXG5cbiAgICB0aGlzLnRyaWdnZXIobmV3IENvbXBvbmVudEV2ZW50JDEoXCJyZWFkeUVsZW1lbnRcIiwge1xuICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgZWxlbWVudDogaW5mby5lbGVtZW50LFxuICAgICAgaGFzRXJyb3I6IGluZm8uaGFzRXJyb3IsXG4gICAgICBlcnJvckNvdW50OiB0aGlzLmdldEVycm9yQ291bnQoKSxcbiAgICAgIHRvdGFsRXJyb3JDb3VudDogdGhpcy50b3RhbEVycm9yQ291bnQsXG4gICAgICBwcmVSZWFkeUNvdW50OiB0aGlzLnByZVJlYWR5Q291bnQsXG4gICAgICByZWFkeUNvdW50OiB0aGlzLnJlYWR5Q291bnQsXG4gICAgICB0b3RhbENvdW50OiB0aGlzLnRvdGFsQ291bnQsXG4gICAgICBpc1ByZVJlYWR5OiB0aGlzLmlzUHJlUmVhZHkoKSxcbiAgICAgIGlzUmVhZHk6IHRoaXMuaXNSZWFkeSgpLFxuICAgICAgaGFzTG9hZGluZzogaW5mby5oYXNMb2FkaW5nLFxuICAgICAgaXNQcmVSZWFkeU92ZXI6IHRoaXMuaXNQcmVSZWFkeU92ZXIsXG4gICAgICBpc1NraXA6IGluZm8uaXNTa2lwXG4gICAgfSkpO1xuICB9O1xuXG4gIF9fcHJvdG8ub25SZWFkeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBBbiBldmVudCBvY2N1cnMgd2hlbiBhbGwgZWxlbWVudCBhcmUgcmVhZHlcbiAgICAgKiBAa28g66qo65OgIOyXmOumrOuovO2KuOuTpOydtCDspIDruYTrkJwg6rK97JqwIOydtOuypO2KuOqwgCDrsJzsg53tlZzri6QuXG4gICAgICogQGV2ZW50IGVnLkltUmVhZHkjcmVhZHlcbiAgICAgKiBAcGFyYW0ge2VnLkltUmVhZHkuT25SZWFkeX0gZSAtIFRoZSBvYmplY3Qgb2YgZGF0YSB0byBiZSBzZW50IHRvIGFuIGV2ZW50IDxrbz7snbTrsqTtirjsl5Ag7KCE64us65CY64qUIOuNsOydtO2EsCDqsJ3ssrQ8L2tvPlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXY+XG4gICAgICogICAgPGltZyBzcmM9XCIuLzEuanBnXCIgZGF0YS13aWR0aD1cIjEyODBcIiBkYXRhLWhlaWdodD1cIjg1M1wiIHN0eWxlPVwid2lkdGg6MTAwJVwiLz5cbiAgICAgKiAgICA8aW1nIHNyYz1cIi4vMi5qcGdcIiBkYXRhLXdpZHRoPVwiMTI4MFwiIGRhdGEtaGVpZ2h0PVwiODUzXCIvPlxuICAgICAqICAgIDxpbWcgc3JjPVwiRVJSXCIgZGF0YS13aWR0aD1cIjEyODBcIiBkYXRhLWhlaWdodD1cIjg1M1wiLz5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKiAjIyBKYXZhc2NyaXB0XG4gICAgICogYGBganNcbiAgICAgKiBpbXBvcnQgSW1SZWFkeSBmcm9tIFwiQGVnanMvaW1yZWFkeVwiO1xuICAgICAqXG4gICAgICogY29uc3QgaW0gPSBuZXcgSW1SZWFkeSgpOyAvLyB1bWQ6IGVnLkltUmVhZHlcbiAgICAgKiBpbS5jaGVjayhkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiaW1nXCIpKS5vbih7XG4gICAgICogICBwcmVSZWFkeTogZSA9PiB7XG4gICAgICogICAgIC8vIDAsIDNcbiAgICAgKiAgICAgY29uc29sZS5sb2coZS5yZWFkeUNvdW50LCBlLnRvdGFsQ291bnQpLFxuICAgICAqICAgfSxcbiAgICAgKiAgIHJlYWR5OiBlID0+IHtcbiAgICAgKiAgICAgLy8gMSwgM1xuICAgICAqICAgICBjb25zb2xlLmxvZyhlLmVycm9yQ291bnQsIGUudG90YWxDb3VudCksXG4gICAgICogICB9LFxuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHRoaXMudHJpZ2dlcihuZXcgQ29tcG9uZW50RXZlbnQkMShcInJlYWR5XCIsIHtcbiAgICAgIGVycm9yQ291bnQ6IHRoaXMuZ2V0RXJyb3JDb3VudCgpLFxuICAgICAgdG90YWxFcnJvckNvdW50OiB0aGlzLnRvdGFsRXJyb3JDb3VudCxcbiAgICAgIHRvdGFsQ291bnQ6IHRoaXMudG90YWxDb3VudFxuICAgIH0pKTtcbiAgfTtcblxuICBfX3Byb3RvLmdldEVycm9yQ291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudEluZm9zLmZpbHRlcihmdW5jdGlvbiAoaW5mbykge1xuICAgICAgcmV0dXJuIGluZm8uaGFzRXJyb3I7XG4gICAgfSkubGVuZ3RoO1xuICB9O1xuXG4gIF9fcHJvdG8uaGFzTG9hZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50SW5mb3Muc29tZShmdW5jdGlvbiAoaW5mbykge1xuICAgICAgcmV0dXJuIGluZm8uaGFzTG9hZGluZztcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gSW1SZWFkeU1hbmFnZXI7XG59KENvbXBvbmVudCk7XG5cbnZhciBJbWFnZUxvYWRlciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyQyKEltYWdlTG9hZGVyLCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIEltYWdlTG9hZGVyKCkge1xuICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfX3Byb3RvID0gSW1hZ2VMb2FkZXIucHJvdG90eXBlO1xuXG4gIF9fcHJvdG8uY2hlY2tFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuICAgIHZhciBzcmMgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShcInNyY1wiKTtcblxuICAgIGlmIChlbGVtZW50LmNvbXBsZXRlKSB7XG4gICAgICBpZiAoc3JjKSB7XG4gICAgICAgIC8vIGNvbXBsZXRlXG4gICAgICAgIGlmICghZWxlbWVudC5uYXR1cmFsV2lkdGgpIHtcbiAgICAgICAgICB0aGlzLm9uQWxyZWFkeUVycm9yKGVsZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVXNpbmcgYW4gZXh0ZXJuYWwgbGF6eSBsb2FkaW5nIG1vZHVsZVxuICAgICAgICB0aGlzLm9uQWxyZWFkeVByZVJlYWR5KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5hZGRFdmVudHMoKTtcbiAgICBJU19JRSAmJiBlbGVtZW50LnNldEF0dHJpYnV0ZShcInNyY1wiLCBzcmMpO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIEltYWdlTG9hZGVyLkVWRU5UUyA9IFtcImxvYWRcIiwgXCJlcnJvclwiXTtcbiAgcmV0dXJuIEltYWdlTG9hZGVyO1xufShMb2FkZXIpO1xuXG52YXIgVmlkZW9Mb2FkZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMkMihWaWRlb0xvYWRlciwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBWaWRlb0xvYWRlcigpIHtcbiAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX19wcm90byA9IFZpZGVvTG9hZGVyLnByb3RvdHlwZTtcblxuICBfX3Byb3RvLmNoZWNrRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudDsgLy8gSEFWRV9OT1RISU5HOiAwLCBubyBpbmZvcm1hdGlvbiB3aGV0aGVyIG9yIG5vdCB0aGUgYXVkaW8vdmlkZW8gaXMgcmVhZHlcbiAgICAvLyBIQVZFX01FVEFEQVRBOiAxLCBIQVZFX01FVEFEQVRBIC0gbWV0YWRhdGEgZm9yIHRoZSBhdWRpby92aWRlbyBpcyByZWFkeVxuICAgIC8vIEhBVkVfQ1VSUkVOVF9EQVRBOiAyLCBkYXRhIGZvciB0aGUgY3VycmVudCBwbGF5YmFjayBwb3NpdGlvbiBpcyBhdmFpbGFibGUsIGJ1dCBub3QgZW5vdWdoIGRhdGEgdG8gcGxheSBuZXh0IGZyYW1lL21pbGxpc2Vjb25kXG4gICAgLy8gSEFWRV9GVVRVUkVfREFUQTogMywgZGF0YSBmb3IgdGhlIGN1cnJlbnQgYW5kIGF0IGxlYXN0IHRoZSBuZXh0IGZyYW1lIGlzIGF2YWlsYWJsZVxuICAgIC8vIEhBVkVfRU5PVUdIX0RBVEE6IDQsIGVub3VnaCBkYXRhIGF2YWlsYWJsZSB0byBzdGFydCBwbGF5aW5nXG5cbiAgICBpZiAoZWxlbWVudC5yZWFkeVN0YXRlID49IDEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoZWxlbWVudC5lcnJvcikge1xuICAgICAgdGhpcy5vbkFscmVhZHlFcnJvcihlbGVtZW50KTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLmFkZEV2ZW50cygpO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIFZpZGVvTG9hZGVyLkVWRU5UUyA9IFtcImxvYWRlZG1ldGFkYXRhXCIsIFwiZXJyb3JcIl07XG4gIHJldHVybiBWaWRlb0xvYWRlcjtcbn0oTG9hZGVyKTtcblxudmFyIEltUmVhZHkgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMkMihJbVJlYWR5LCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIEltUmVhZHkob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgX19hc3NpZ24kMSh7XG4gICAgICBsb2FkZXJzOiB7XG4gICAgICAgIGltZzogSW1hZ2VMb2FkZXIsXG4gICAgICAgIHZpZGVvOiBWaWRlb0xvYWRlclxuICAgICAgfVxuICAgIH0sIG9wdGlvbnMpKSB8fCB0aGlzO1xuICB9XG5cbiAgcmV0dXJuIEltUmVhZHk7XG59KEltUmVhZHlNYW5hZ2VyKTtcblxuLypcbkNvcHlyaWdodCAoYykgMjAxNS1wcmVzZW50IE5BVkVSIENvcnAuXG5uYW1lOiBAZWdqcy9mbGlja2luZ1xubGljZW5zZTogTUlUXG5hdXRob3I6IE5BVkVSIENvcnAuXG5yZXBvc2l0b3J5OiBodHRwczovL2dpdGh1Yi5jb20vbmF2ZXIvZWdqcy1mbGlja2luZ1xudmVyc2lvbjogNC4xMS40XG4qL1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlLCBTdXBwcmVzc2VkRXJyb3IsIFN5bWJvbCAqL1xuXG52YXIgZXh0ZW5kU3RhdGljcyQzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgZXh0ZW5kU3RhdGljcyQzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IHtcbiAgICBfX3Byb3RvX186IFtdXG4gIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikge1xuICAgIGQuX19wcm90b19fID0gYjtcbiAgfSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07XG4gIH07XG4gIHJldHVybiBleHRlbmRTdGF0aWNzJDMoZCwgYik7XG59O1xuZnVuY3Rpb24gX19leHRlbmRzJDMoZCwgYikge1xuICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gIGV4dGVuZFN0YXRpY3MkMyhkLCBiKTtcbiAgZnVuY3Rpb24gX18oKSB7XG4gICAgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7XG4gIH1cbiAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufVxudmFyIF9fYXNzaWduJDIgPSBmdW5jdGlvbiAoKSB7XG4gIF9fYXNzaWduJDIgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcbiAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xuICAgIH1cbiAgICByZXR1cm4gdDtcbiAgfTtcbiAgcmV0dXJuIF9fYXNzaWduJDIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5mdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHtcbiAgICAgIHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpO1xuICAgIH1cbiAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gX19nZW5lcmF0b3IodGhpc0FyZywgYm9keSkge1xuICB2YXIgXyA9IHtcbiAgICAgIGxhYmVsOiAwLFxuICAgICAgc2VudDogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodFswXSAmIDEpIHRocm93IHRbMV07XG4gICAgICAgIHJldHVybiB0WzFdO1xuICAgICAgfSxcbiAgICAgIHRyeXM6IFtdLFxuICAgICAgb3BzOiBbXVxuICAgIH0sXG4gICAgZixcbiAgICB5LFxuICAgIHQsXG4gICAgZztcbiAgcmV0dXJuIGcgPSB7XG4gICAgbmV4dDogdmVyYigwKSxcbiAgICBcInRocm93XCI6IHZlcmIoMSksXG4gICAgXCJyZXR1cm5cIjogdmVyYigyKVxuICB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSksIGc7XG4gIGZ1bmN0aW9uIHZlcmIobikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodikge1xuICAgICAgcmV0dXJuIHN0ZXAoW24sIHZdKTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgd2hpbGUgKGcgJiYgKGcgPSAwLCBvcFswXSAmJiAoXyA9IDApKSwgXykgdHJ5IHtcbiAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgdCA9IG9wO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgXy5sYWJlbCsrO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogb3BbMV0sXG4gICAgICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICBfLmxhYmVsKys7XG4gICAgICAgICAgeSA9IG9wWzFdO1xuICAgICAgICAgIG9wID0gWzBdO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgb3AgPSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICBfLnRyeXMucG9wKCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHtcbiAgICAgICAgICAgIF8gPSAwO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgb3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpIHtcbiAgICAgICAgICAgIF8ubGFiZWwgPSBvcFsxXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHtcbiAgICAgICAgICAgIF8ubGFiZWwgPSB0WzFdO1xuICAgICAgICAgICAgdCA9IG9wO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7XG4gICAgICAgICAgICBfLmxhYmVsID0gdFsyXTtcbiAgICAgICAgICAgIF8ub3BzLnB1c2gob3ApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICBfLnRyeXMucG9wKCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBvcCA9IFs2LCBlXTtcbiAgICAgIHkgPSAwO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBmID0gdCA9IDA7XG4gICAgfVxuICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdO1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCxcbiAgICAgIGRvbmU6IHRydWVcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBfX3ZhbHVlcyQxKG8pIHtcbiAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLFxuICAgIG0gPSBzICYmIG9bc10sXG4gICAgaSA9IDA7XG4gIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xuICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XG4gICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiBvICYmIG9baSsrXSxcbiAgICAgICAgZG9uZTogIW9cbiAgICAgIH07XG4gICAgfVxuICB9O1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG59XG5mdW5jdGlvbiBfX3JlYWQkMShvLCBuKSB7XG4gIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgaWYgKCFtKSByZXR1cm4gbztcbiAgdmFyIGkgPSBtLmNhbGwobyksXG4gICAgcixcbiAgICBhciA9IFtdLFxuICAgIGU7XG4gIHRyeSB7XG4gICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgZSA9IHtcbiAgICAgIGVycm9yOiBlcnJvclxuICAgIH07XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoZSkgdGhyb3cgZS5lcnJvcjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFyO1xufVxuXG4vKiogQGRlcHJlY2F0ZWQgKi9cbmZ1bmN0aW9uIF9fc3ByZWFkJDEoKSB7XG4gIGZvciAodmFyIGFyID0gW10sIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSBhciA9IGFyLmNvbmNhdChfX3JlYWQkMShhcmd1bWVudHNbaV0pKTtcbiAgcmV0dXJuIGFyO1xufVxudHlwZW9mIFN1cHByZXNzZWRFcnJvciA9PT0gXCJmdW5jdGlvblwiID8gU3VwcHJlc3NlZEVycm9yIDogZnVuY3Rpb24gKGVycm9yLCBzdXBwcmVzc2VkLCBtZXNzYWdlKSB7XG4gIHZhciBlID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICByZXR1cm4gZS5uYW1lID0gXCJTdXBwcmVzc2VkRXJyb3JcIiwgZS5lcnJvciA9IGVycm9yLCBlLnN1cHByZXNzZWQgPSBzdXBwcmVzc2VkLCBlO1xufTtcblxuLypcclxuICogQ29weXJpZ2h0IChjKSAyMDE1IE5BVkVSIENvcnAuXHJcbiAqIGVnanMgcHJvamVjdHMgYXJlIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9yZXN0cmljdC10ZW1wbGF0ZS1leHByZXNzaW9ucyAqL1xuLyoqXHJcbiAqIEVycm9yIGNvZGVzIG9mIHtAbGluayBGbGlja2luZ0Vycm9yfS4gQmVsb3cgYXJlIHRoZSBjb25kaXRpb25zIHdoZXJlIGVhY2ggZXJyb3IgY29kZSBvY2N1cnMuXHJcbiAqIEBrbyB7QGxpbmsgRmxpY2tpbmdFcnJvcn3snZgg7JeQ65+sIOy9lOuTnC4g7JWE656Y64qUIOqwgeqwgeydmCDsl5Drn6wg7L2U65Oc6rCAIOuwnOyDne2VmOuKlCDsobDqsbTsnoXri4jri6QuXHJcbiAqIEBuYW1lIEVSUk9SX0NPREVcclxuICogQGNvbnN0YW50XHJcbiAqIEB0eXBlIG9iamVjdFxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gV1JPTkdfVFlQRSBQYXJhbWV0ZXIgdHlwZSBpcyB3cm9uZzxrbz7tjKjrn6zrr7jthLDsnZgg7YOA7J6F7J20IOyemOuqu+uQmOyXiOydhCDqsr3smrA8L2tvPlxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gRUxFTUVOVF9OT1RfRk9VTkQgRWxlbWVudCBpcyBub3QgZm91bmQgaW5zaWRlIHBhZ2Ugd2l0aCB0aGUgZ2l2ZW4gQ1NTIHNlbGVjdG9yPGtvPuyjvOyWtOynhCBDU1Mgc2VsZWN0b3LroZwg7Y6Y7J207KeAIOuCtOyXkOyEnCDtlbTri7kg7JeY66as66i87Yq466W8IOywvuyngCDrqrvtlojsnYQg6rK97JqwPC9rbz5cclxuICogQHByb3BlcnR5IHtudW1iZXJ9IFZBTF9NVVNUX05PVF9OVUxMIEV4cGVjdGVkIG5vbi1udWxsIHZhbHVlLCBidXQgZ2l2ZW4gYG51bGxgIG9yIGB1bmRlZmluZWRgPGtvPuqwkuydhCDquLDrjIDtlojsnLzrgpgsIGBudWxsYOydtOuCmCBgdW5kZWZpbmVkYOulvCDrsJvsnYAg6rK97JqwPC9rbz5cclxuICogQHByb3BlcnR5IHtudW1iZXJ9IE5PVF9BVFRBQ0hFRF9UT19GTElDS0lORyBXaGVuIEZsaWNraW5nJ3MgY29tcG9uZW50IGlzIG5vdCBpbml0aWFsaXplZCAoaS5lLiB7QGxpbmsgRmxpY2tpbmcjaW5pdH0gaXMgbm90IGNhbGxlZCk8a28+RmxpY2tpbmcg64K067aAIOy7tO2PrOuEjO2KuOqwgCDstIjquLDtmZTrkJjsp4Ag7JWK7J2AIOqyveyasCAoe0BsaW5rIEZsaWNraW5nI2luaXR97J20IO2YuOy2nOuQmOyngCDslYrsnYAg6rK97JqwKTwva28+XHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBXUk9OR19PUFRJT04gT25lIG9mIHRoZSBvcHRpb25zIGlzIHdyb25nPGtvPuyYteyFmOuTpCDspJEg7J6Y66q765CcIOqwkuydtCDsnojsnYQg65WMPC9rbz5cclxuICogQHByb3BlcnR5IHtudW1iZXJ9IElOREVYX09VVF9PRl9SQU5HRSBXaGVuIHRoZSBnaXZlbiBpbmRleCBpcyBvdXQgb2YgcG9zc2libGUgcmFuZ2U8a28+7J24642x7Iqk6rCAIOyjvOyWtOynhCDrspTsnITrpbwg67KX7Ja064KcIOqyveyasDwva28+XHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBQT1NJVElPTl9OT1RfUkVBQ0hBQkxFIFdoZW4ge0BsaW5rIENvbnRyb2wjbW92ZVRvUG9zaXRpb259J3MgcG9zaXRpb24gcGFyYW1ldGVyIGlzIG91dCBvZiBwb3NzaWJsZSByYW5nZS48a28+e0BsaW5rIENvbnRyb2wjbW92ZVRvUG9zaXRpb2597J2YIGBwb3NpdGlvbmAg7Yyo65+s66+47YSw6rCAIOuPhOuLrCDqsIDriqXtlZwg67KU7JyE66W8IOuyl+yWtOuCnCDqsr3smrA8L2tvPlxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gVFJBTlNGT1JNX05PVF9TVVBQT1JURUQgQ1NTIGB0cmFuc2Zvcm1gIHByb3BlcnR5IGlzIG5vdCBhdmFpbGFibGUoPD1JRTgpIDxrbz5DU1MgYHRyYW5zZm9ybWAg7IaN7ISx7J2EIOyCrOyaqe2VoCDsiJgg7JeG64qUIOqyveyasCg8PUlFOCk8L2tvPlxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gU1RPUF9DQUxMRURfQllfVVNFUiBXaGVuIHRoZSBldmVudCdzIGBzdG9wKClgIGlzIGNhbGxlZCBieSB1c2VyLjxrbz7sgqzsmqnsnpDsl5Ag7J2Y7ZW0IOydtOuypO2KuOydmCBgc3RvcCgpYOydtCDtmLjstpzrkJwg6rK97JqwPC9rbz5cclxuICogQHByb3BlcnR5IHtudW1iZXJ9IEFOSU1BVElPTl9JTlRFUlJVUFRFRCBXaGVuIHRoZSBhbmltYXRpb24gaXMgaW50ZXJydXB0ZWQgYnkgdXNlci48a28+7IKs7Jqp7J6Q7JeQIOydmO2VtCDslaDri4jrqZTsnbTshZjsnbQg7KSR64uo65CcIOqyveyasDwva28+XHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBBTklNQVRJT05fQUxSRUFEWV9QTEFZSU5HIFdoZW4gdGhlIGFuaW1hdGlvbiBpcyBhbHJlYWR5IHBsYXlpbmcuPGtvPu2YhOyerCDslaDri4jrqZTsnbTshZjsnbQg7J2066+4IOynhO2WieykkeyduCDqsr3smrA8L2tvPlxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gTk9UX0FMTE9XRURfSU5fRlJBTUVXT1JLIFdoZW4gdGhlIG5vbi1hbGxvd2VkIG1ldGhvZCBpcyBjYWxsZWQgZnJvbSBmcmFtZXdvcmtzIChSZWFjdCwgQW5ndWxhciwgVnVlLi4uKVxyXG4gKiA8a28+7ZSE66CI7J6E7JuM7YGsKFJlYWN0LCBBbmd1bGFyLCBWdWUgLi4uKeyXkOyEnCDsgqzsmqkg67aI6rCA64ql7ZWcIOuplOyGjOuTnOulvCDtmLjstpztlojsnYQg6rK97JqwPC9rbz5cclxuICogQHByb3BlcnR5IHtudW1iZXJ9IE5PVF9JTklUSUFMSVpFRCBXaGVuIHRoZSB7QGxpbmsgRmxpY2tpbmcjaW5pdH0gaXMgbm90IGNhbGxlZCBiZWZvcmUgYnV0IGlzIG5lZWRlZDxrbz57QGxpbmsgRmxpY2tpbmcjaW5pdH3snZgg7Zi47Lac7J20IO2VhOyalO2VmOuCmCwg7JWE7KeBIO2YuOy2nOuQmOyngCDslYrslZjsnYQg6rK97JqwPC9rbz5cclxuICogQHByb3BlcnR5IHtudW1iZXJ9IE5PX0FDVElWRSBXaGVuIHRoZXJlJ3JlIG5vIGFjdGl2ZSBwYW5lbCB0aGF0IGZsaWNraW5nIGhhcyBzZWxlY3RlZC4gVGhpcyBtYXkgYmUgZHVlIHRvIHRoZSBhYnNlbmNlIG9mIGFueSBwYW5lbHM8a28+7ZiE7J6sIEZsaWNraW5n7J20IOyEoO2Dne2VnCDtjKjrhJDsnbQg7JeG7J2EIOqyveyasC4g7J2867CY7KCB7Jy866GcIO2MqOuEkOydtCDtlZjrgpjrj4Qg7JeG64qUIOqyveyasOyXkCDrsJzsg53tlaAg7IiYIOyeiOyKteuLiOuLpDwva28+XHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBOT1RfQUxMT1dFRF9JTl9WSVJUVUFMIFdoZW4gdGhlIG5vbi1hbGxvd2VkIG1ldGhvZCBpcyBjYWxsZWQgd2hpbGUgdGhlIHZpcnR1YWwgb3B0aW9uIGlzIGVuYWJsZWQ8a28+dmlydHVhbCDsmLXshZjsnbQg7Zmc7ISx7ZmU65CcIOyDge2DnOyXkOyEnCDsgqzsmqkg67aI6rCA64ql7ZWcIOuplOyGjOuTnOqwgCDtmLjstpzrkJjsl4jsnYQg6rK97JqwPC9rbz5cclxuICovXG52YXIgQ09ERSA9IHtcbiAgV1JPTkdfVFlQRTogMCxcbiAgRUxFTUVOVF9OT1RfRk9VTkQ6IDEsXG4gIFZBTF9NVVNUX05PVF9OVUxMOiAyLFxuICBOT1RfQVRUQUNIRURfVE9fRkxJQ0tJTkc6IDMsXG4gIFdST05HX09QVElPTjogNCxcbiAgSU5ERVhfT1VUX09GX1JBTkdFOiA1LFxuICBQT1NJVElPTl9OT1RfUkVBQ0hBQkxFOiA2LFxuICBUUkFOU0ZPUk1fTk9UX1NVUFBPUlRFRDogNyxcbiAgU1RPUF9DQUxMRURfQllfVVNFUjogOCxcbiAgQU5JTUFUSU9OX0lOVEVSUlVQVEVEOiA5LFxuICBBTklNQVRJT05fQUxSRUFEWV9QTEFZSU5HOiAxMCxcbiAgTk9UX0FMTE9XRURfSU5fRlJBTUVXT1JLOiAxMSxcbiAgTk9UX0lOSVRJQUxJWkVEOiAxMixcbiAgTk9fQUNUSVZFOiAxMyxcbiAgTk9UX0FMTE9XRURfSU5fVklSVFVBTDogMTRcbn07XG52YXIgTUVTU0FHRSA9IHtcbiAgV1JPTkdfVFlQRTogZnVuY3Rpb24gKHdyb25nVmFsLCBjb3JyZWN0VHlwZXMpIHtcbiAgICByZXR1cm4gd3JvbmdWYWwgKyBcIihcIiArIHR5cGVvZiB3cm9uZ1ZhbCArIFwiKSBpcyBub3QgYSBcIiArIGNvcnJlY3RUeXBlcy5tYXAoZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIHJldHVybiBcIlxcXCJcIiArIHR5cGUgKyBcIlxcXCJcIjtcbiAgICB9KS5qb2luKFwiIG9yIFwiKSArIFwiLlwiO1xuICB9LFxuICBFTEVNRU5UX05PVF9GT1VORDogZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIFwiRWxlbWVudCB3aXRoIHNlbGVjdG9yIFxcXCJcIiArIHNlbGVjdG9yICsgXCJcXFwiIG5vdCBmb3VuZC5cIjtcbiAgfSxcbiAgVkFMX01VU1RfTk9UX05VTEw6IGZ1bmN0aW9uICh2YWwsIG5hbWUpIHtcbiAgICByZXR1cm4gbmFtZSArIFwiIHNob3VsZCBiZSBwcm92aWRlZC4gR2l2ZW46IFwiICsgdmFsO1xuICB9LFxuICBOT1RfQVRUQUNIRURfVE9fRkxJQ0tJTkc6IFwiVGhpcyBtb2R1bGUgaXMgbm90IGF0dGFjaGVkIHRvIHRoZSBGbGlja2luZyBpbnN0YW5jZS4gXFxcImluaXQoKVxcXCIgc2hvdWxkIGJlIGNhbGxlZCBmaXJzdC5cIixcbiAgV1JPTkdfT1BUSU9OOiBmdW5jdGlvbiAob3B0aW9uTmFtZSwgdmFsKSB7XG4gICAgcmV0dXJuIFwiT3B0aW9uIFxcXCJcIiArIG9wdGlvbk5hbWUgKyBcIlxcXCIgaXMgbm90IGluIGNvcnJlY3QgZm9ybWF0LCBnaXZlbjogXCIgKyB2YWw7XG4gIH0sXG4gIElOREVYX09VVF9PRl9SQU5HRTogZnVuY3Rpb24gKHZhbCwgbWluLCBtYXgpIHtcbiAgICByZXR1cm4gXCJJbmRleCBcXFwiXCIgKyB2YWwgKyBcIlxcXCIgaXMgb3V0IG9mIHJhbmdlOiBzaG91bGQgYmUgYmV0d2VlbiBcIiArIG1pbiArIFwiIGFuZCBcIiArIG1heCArIFwiLlwiO1xuICB9LFxuICBQT1NJVElPTl9OT1RfUkVBQ0hBQkxFOiBmdW5jdGlvbiAocG9zaXRpb24pIHtcbiAgICByZXR1cm4gXCJQb3NpdGlvbiBcXFwiXCIgKyBwb3NpdGlvbiArIFwiXFxcIiBpcyBub3QgcmVhY2hhYmxlLlwiO1xuICB9LFxuICBUUkFOU0ZPUk1fTk9UX1NVUFBPUlRFRDogXCJCcm93c2VyIGRvZXMgbm90IHN1cHBvcnQgQ1NTIHRyYW5zZm9ybS5cIixcbiAgU1RPUF9DQUxMRURfQllfVVNFUjogXCJFdmVudCBzdG9wKCkgaXMgY2FsbGVkIGJ5IHVzZXIuXCIsXG4gIEFOSU1BVElPTl9JTlRFUlJVUFRFRDogXCJBbmltYXRpb24gaXMgaW50ZXJydXB0ZWQgYnkgdXNlciBpbnB1dC5cIixcbiAgQU5JTUFUSU9OX0FMUkVBRFlfUExBWUlORzogXCJBbmltYXRpb24gaXMgYWxyZWFkeSBwbGF5aW5nLlwiLFxuICBOT1RfQUxMT1dFRF9JTl9GUkFNRVdPUks6IFwiVGhpcyBiZWhhdmlvciBpcyBub3QgYWxsb3dlZCBpbiB0aGUgZnJhbWV3b3JrcyBsaWtlIFJlYWN0LCBWdWUsIG9yIEFuZ3VsYXIuXCIsXG4gIE5PVF9JTklUSUFMSVpFRDogXCJGbGlja2luZyBpcyBub3QgaW5pdGlhbGl6ZWQgeWV0LCBjYWxsIGluaXQoKSBmaXJzdC5cIixcbiAgTk9fQUNUSVZFOiBcIlRoZXJlJ3Mgbm8gYWN0aXZlIHBhbmVsIHRoYXQgRmxpY2tpbmcgaGFzIHNlbGVjdGVkLiBUaGlzIG1heSBiZSBkdWUgdG8gdGhlIGFic2VuY2Ugb2YgYW55IHBhbmVscy5cIixcbiAgTk9UX0FMTE9XRURfSU5fVklSVFVBTDogXCJUaGlzIGJlaGF2aW9yIGlzIG5vdCBhbGxvd2VkIHdoZW4gdGhlIHZpcnR1YWwgb3B0aW9uIGlzIGVuYWJsZWRcIlxufTtcblxuLypcclxuICogQ29weXJpZ2h0IChjKSAyMDE1IE5BVkVSIENvcnAuXHJcbiAqIGVnanMgcHJvamVjdHMgYXJlIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cbi8qKlxyXG4gKiBFdmVudCB0eXBlIG9iamVjdCB3aXRoIGV2ZW50IG5hbWUgc3RyaW5ncyBvZiB7QGxpbmsgRmxpY2tpbmd9XHJcbiAqIEBrbyB7QGxpbmsgRmxpY2tpbmd97J2YIOydtOuypO2KuCDsnbTrpoQg66y47J6Q7Je065Ok7J2EIOuLtOydgCDqsJ3ssrRcclxuICogQHR5cGUge29iamVjdH1cclxuICogQHByb3BlcnR5IHtcImhvbGRTdGFydFwifSBIT0xEX1NUQVJUIGhvbGRTdGFydCBldmVudDxrbz5ob2xkU3RhcnQg7J2067Kk7Yq4PC9rbz5cclxuICogQHByb3BlcnR5IHtcImhvbGRFbmRcIn0gSE9MRF9FTkQgaG9sZEVuZCBldmVudDxrbz5ob2xkRW5kIOydtOuypO2KuDwva28+XHJcbiAqIEBwcm9wZXJ0eSB7XCJtb3ZlU3RhcnRcIn0gTU9WRV9TVEFSVCBtb3ZlU3RhcnQgZXZlbnQ8a28+bW92ZVN0YXJ0IOydtOuypO2KuDwva28+XHJcbiAqIEBwcm9wZXJ0eSB7XCJtb3ZlXCJ9IE1PVkUgbW92ZSBldmVudDxrbz5tb3ZlIOydtOuypO2KuDwva28+XHJcbiAqIEBwcm9wZXJ0eSB7XCJtb3ZlRW5kXCJ9IE1PVkVfRU5EIG1vdmVFbmQgZXZlbnQ8a28+bW92ZUVuZCDsnbTrsqTtirg8L2tvPlxyXG4gKiBAcHJvcGVydHkge1wid2lsbENoYW5nZVwifSBXSUxMX0NIQU5HRSB3aWxsQ2hhbmdlIGV2ZW50PGtvPndpbGxDaGFuZ2Ug7J2067Kk7Yq4PC9rbz5cclxuICogQHByb3BlcnR5IHtcImNoYW5nZWRcIn0gQ0hBTkdFRCBjaGFuZ2VkIGV2ZW50PGtvPmNoYW5nZWQg7J2067Kk7Yq4PC9rbz5cclxuICogQHByb3BlcnR5IHtcIndpbGxSZXN0b3JlXCJ9IFdJTExfUkVTVE9SRSB3aWxsUmVzdG9yZSBldmVudDxrbz53aWxsUmVzdG9yZSDsnbTrsqTtirg8L2tvPlxyXG4gKiBAcHJvcGVydHkge1wicmVzdG9yZWRcIn0gUkVTVE9SRUQgcmVzdG9yZWQgZXZlbnQ8a28+cmVzdG9yZWQg7J2067Kk7Yq4PC9rbz5cclxuICogQHByb3BlcnR5IHtcInNlbGVjdFwifSBTRUxFQ1Qgc2VsZWN0IGV2ZW50PGtvPnNlbGVjdCDsnbTrsqTtirg8L2tvPlxyXG4gKiBAcHJvcGVydHkge1wibmVlZFBhbmVsXCJ9IE5FRURfUEFORUwgbmVlZFBhbmVsIGV2ZW50PGtvPm5lZWRQYW5lbCDsnbTrsqTtirg8L2tvPlxyXG4gKiBAcHJvcGVydHkge1wicGFuZWxDaGFuZ2VcIn0gUEFORUxfQ0hBTkdFIHBhbmVsQ2hhbmdlIGV2ZW50PGtvPnBhbmVsQ2hhbmdlIOydtOuypO2KuDwva28+XHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYHRzXHJcbiAqIGltcG9ydCB7IEVWRU5UUyB9IGZyb20gXCJAZWdqcy9mbGlja2luZ1wiO1xyXG4gKiBFVkVOVFMuTU9WRV9TVEFSVDsgLy8gXCJtb3ZlU3RhcnRcIlxyXG4gKiBgYGBcclxuICovXG52YXIgRVZFTlRTID0ge1xuICBSRUFEWTogXCJyZWFkeVwiLFxuICBCRUZPUkVfUkVTSVpFOiBcImJlZm9yZVJlc2l6ZVwiLFxuICBBRlRFUl9SRVNJWkU6IFwiYWZ0ZXJSZXNpemVcIixcbiAgSE9MRF9TVEFSVDogXCJob2xkU3RhcnRcIixcbiAgSE9MRF9FTkQ6IFwiaG9sZEVuZFwiLFxuICBNT1ZFX1NUQVJUOiBcIm1vdmVTdGFydFwiLFxuICBNT1ZFOiBcIm1vdmVcIixcbiAgTU9WRV9FTkQ6IFwibW92ZUVuZFwiLFxuICBXSUxMX0NIQU5HRTogXCJ3aWxsQ2hhbmdlXCIsXG4gIENIQU5HRUQ6IFwiY2hhbmdlZFwiLFxuICBXSUxMX1JFU1RPUkU6IFwid2lsbFJlc3RvcmVcIixcbiAgUkVTVE9SRUQ6IFwicmVzdG9yZWRcIixcbiAgU0VMRUNUOiBcInNlbGVjdFwiLFxuICBORUVEX1BBTkVMOiBcIm5lZWRQYW5lbFwiLFxuICBWSVNJQkxFX0NIQU5HRTogXCJ2aXNpYmxlQ2hhbmdlXCIsXG4gIFJFQUNIX0VER0U6IFwicmVhY2hFZGdlXCIsXG4gIFBBTkVMX0NIQU5HRTogXCJwYW5lbENoYW5nZVwiXG59O1xuLyoqXHJcbiAqIEFuIG9iamVjdCB3aXRoIGFsbCBwb3NzaWJsZSBwcmVkZWZpbmVkIGxpdGVyYWwgc3RyaW5nIGZvciB0aGUge0BsaW5rIEZsaWNraW5nI2FsaWduIGFsaWdufSBvcHRpb25cclxuICogQGtvIHtAbGluayBGbGlja2luZyNhbGlnbiBhbGlnbn0g7Ji17IWY7JeQIOyCrOyaqeuQmOuKlCDrr7jrpqwg7KCV7J2Y65CcIOumrO2EsOuftCDsg4HsiJjrk6TsnYQg64u06rOgIOyeiOuKlCDqsJ3ssrRcclxuICogQHR5cGUge29iamVjdH1cclxuICogQHByb3BlcnR5IHtcInByZXZcIn0gUFJFViBsZWZ0L3RvcCBhbGlnbjxrbz7soowv7IOBIOygleugrDwva28+XHJcbiAqIEBwcm9wZXJ0eSB7XCJjZW50ZXJcIn0gQ0VOVEVSIGNlbnRlciBhbGlnbjxrbz7spJHslZkg7KCV66CsPC9rbz5cclxuICogQHByb3BlcnR5IHtcIm5leHRcIn0gTkVYVCByaWdodC9ib3R0b20gYWxpZ248a28+7JqwL+2VmCDsoJXroKw8L2tvPlxyXG4gKi9cbnZhciBBTElHTiA9IHtcbiAgUFJFVjogXCJwcmV2XCIsXG4gIENFTlRFUjogXCJjZW50ZXJcIixcbiAgTkVYVDogXCJuZXh0XCJcbn07XG4vKipcclxuICogQW4gb2JqZWN0IG9mIGRpcmVjdGlvbnNcclxuICogQGtvIOuwqe2WpeydhCDrgpjtg4DrgrTripQg6rCS65Ok7J2EIOuLtOqzoCDsnojripQg6rCd7LK0XHJcbiAqIEB0eXBlIHtvYmplY3R9XHJcbiAqIEBwcm9wZXJ0eSB7XCJQUkVWXCJ9IFBSRVYgXCJsZWZ0XCIgd2hlbiB7QGxpbmsgRmxpY2tpbmcjaG9yaXpvbnRhbCBob3Jpem9udGFsfSBpcyB0cnVlLCBhbmQgXCJ0b3BcIiB3aGVuIHtAbGluayBGbGlja2luZyNob3Jpem9udGFsIGhvcml6b250YWx9IGlzIGZhbHNlXHJcbiAqIDxrbz57QGxpbmsgRmxpY2tpbmcjaG9yaXpvbnRhbCBob3Jpem9udGFsfeqwgCBgdHJ1ZWDsnbwg6rK97JqwIOyZvOyqvSwge0BsaW5rIEZsaWNraW5nI2hvcml6b250YWwgaG9yaXpvbnRhbH3qsIAgYGZhbHNlYOydvCDqsr3smrAg7JyE7Kq97J2EIOydmOuvuO2VqeuLiOuLpDwva28+XHJcbiAqIEBwcm9wZXJ0eSB7XCJORVhUXCJ9IE5FWFQgXCJyaWdodFwiIHdoZW4ge0BsaW5rIEZsaWNraW5nI2hvcml6b250YWwgaG9yaXpvbnRhbH0gaXMgdHJ1ZSwgYW5kIFwiYm90dG9tXCIgd2hlbiB7QGxpbmsgRmxpY2tpbmcjaG9yaXpvbnRhbCBob3Jpem9udGFsfSBpcyBmYWxzZVxyXG4gKiA8a28+e0BsaW5rIEZsaWNraW5nI2hvcml6b250YWwgaG9yaXpvbnRhbH3qsIAgYHRydWVg7J28IOqyveyasCDsmKTrpbjsqr0sIHtAbGluayBGbGlja2luZyNob3Jpem9udGFsIGhvcml6b250YWx96rCAIGBmYWxzZWDsnbwg6rK97JqwIOyVhOuemOyqveydhCDsnZjrr7jtlanri4jri6Q8L2tvPlxyXG4gKiBAcHJvcGVydHkge251bGx9IE5PTkUgVGhpcyB2YWx1ZSB1c3VhbGx5IG1lYW5zIGl0J3MgdGhlIHNhbWUgcG9zaXRpb248a28+7KO866GcIOygnOyekOumrOyduCDqsr3smrDrpbwg7J2Y66+47ZWp64uI64ukPC9rbz5cclxuICovXG52YXIgRElSRUNUSU9OID0ge1xuICBQUkVWOiBcIlBSRVZcIixcbiAgTkVYVDogXCJORVhUXCIsXG4gIE5PTkU6IG51bGxcbn07XG4vKipcclxuICogQW4gb2JqZWN0IHdpdGggYWxsIHBvc3NpYmxlIHtAbGluayBGbGlja2luZyNtb3ZlVHlwZSBtb3ZlVHlwZX1zXHJcbiAqIEBrbyBGbGlja2luZ+ydtCDsoJzqs7XtlZjripQge0BsaW5rIEZsaWNraW5nI21vdmVUeXBlIG1vdmVUeXBlfeuTpOydhCDri7Tqs6Ag7J6I64qUIOqwneyytFxyXG4gKiBAdHlwZSB7b2JqZWN0fVxyXG4gKiBAcHJvcGVydHkge1wic25hcFwifSBTTkFQIEZsaWNraW5nJ3Mge0BsaW5rIEZsaWNraW5nI21vdmVUeXBlIG1vdmVUeXBlfSB0aGF0IGVuYWJsZXMge0BsaW5rIFNuYXBDb250cm9sfSBhcyBhIEZsaWNraW5nJ3Mge0BsaW5rIEZsaWNraW5nI2NvbnRyb2wgY29udHJvbH1cclxuICogPGtvPkZsaWNraW5n7J2YIHtAbGluayBGbGlja2luZyNjb250cm9sIGNvbnRyb2x97J2EIHtAbGluayBTbmFwQ29udHJvbH3roZwg7ISk7KCV7ZWY6rKMIO2VmOuKlCB7QGxpbmsgRmxpY2tpbmcjbW92ZVR5cGUgbW92ZVR5cGV9PC9rbz5cclxuICogQHByb3BlcnR5IHtcImZyZWVTY3JvbGxcIn0gRlJFRV9TQ1JPTEwgRmxpY2tpbmcncyB7QGxpbmsgRmxpY2tpbmcjbW92ZVR5cGUgbW92ZVR5cGV9IHRoYXQgZW5hYmxlcyB7QGxpbmsgRnJlZUNvbnRyb2x9IGFzIGEgRmxpY2tpbmcncyB7QGxpbmsgRmxpY2tpbmcjY29udHJvbCBjb250cm9sfVxyXG4gKiA8a28+RmxpY2tpbmfsnZgge0BsaW5rIEZsaWNraW5nI2NvbnRyb2wgY29udHJvbH3snYQge0BsaW5rIEZyZWVDb250cm9sfeuhnCDshKTsoJXtlZjqsowg7ZWY64qUIHtAbGluayBGbGlja2luZyNtb3ZlVHlwZSBtb3ZlVHlwZX08L2tvPlxyXG4gKiBAcHJvcGVydHkge1wic3RyaWN0XCJ9IFNUUklDVCBGbGlja2luZydzIHtAbGluayBGbGlja2luZyNtb3ZlVHlwZSBtb3ZlVHlwZX0gdGhhdCBlbmFibGVzIHtAbGluayBTdHJpY3RDb250cm9sfSBhcyBhIEZsaWNraW5nJ3Mge0BsaW5rIEZsaWNraW5nI2NvbnRyb2wgY29udHJvbH1cclxuICogPGtvPkZsaWNraW5n7J2YIHtAbGluayBGbGlja2luZyNjb250cm9sIGNvbnRyb2x97J2EIHtAbGluayBTdHJpY3RDb250cm9sfeuhnCDshKTsoJXtlZjqsowg7ZWY64qUIHtAbGluayBGbGlja2luZyNtb3ZlVHlwZSBtb3ZlVHlwZX08L2tvPlxyXG4gKi9cbnZhciBNT1ZFX1RZUEUgPSB7XG4gIFNOQVA6IFwic25hcFwiLFxuICBGUkVFX1NDUk9MTDogXCJmcmVlU2Nyb2xsXCIsXG4gIFNUUklDVDogXCJzdHJpY3RcIlxufTtcbnZhciBDTEFTUyA9IHtcbiAgVkVSVElDQUw6IFwidmVydGljYWxcIixcbiAgSElEREVOOiBcImZsaWNraW5nLWhpZGRlblwiLFxuICBERUZBVUxUX1ZJUlRVQUw6IFwiZmxpY2tpbmctcGFuZWxcIlxufTtcbi8qKlxyXG4gKiBBbiBvYmplY3Qgd2l0aCBhbGwgcG9zc2libGUge0BsaW5rIEZsaWNraW5nI2NpcmN1bGFyRmFsbGJhY2sgY2lyY3VsYXJGYWxsYmFja31zXHJcbiAqIEBrbyBGbGlja2luZ+ydmCB7QGxpbmsgRmxpY2tpbmcjY2lyY3VsYXJGYWxsYmFjayBjaXJjdWxhckZhbGxiYWNrfeyXkCDshKTsoJUg6rCA64ql7ZWcIOqwkuuTpOydhCDri7Tqs6Ag7J6I64qUIOqwneyytFxyXG4gKiBAdHlwZSB7b2JqZWN0fVxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gTElORUFSIFwibGluZWFyXCJcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IEJPVU5EIFwiYm91bmRcIlxyXG4gKi9cbnZhciBDSVJDVUxBUl9GQUxMQkFDSyA9IHtcbiAgTElORUFSOiBcImxpbmVhclwiLFxuICBCT1VORDogXCJib3VuZFwiXG59O1xuLyoqXHJcbiAqIEFuIG9iamVjdCBmb3IgaWRlbnRpZnlpbmcge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9kaXJlY3Rpb24gZGlyZWN0aW9ufSBDU1MgcHJvcGVydHkgYXBwbGllZCB0byB0aGUgY2FtZXJhIGVsZW1lbnQoYC5mbGlja2luZy1jYW1lcmFgKVxyXG4gKiBAa28g7Lm066mU6528IOyXmOumrOuovO2KuChgLmZsaWNraW5nLWNhbWVyYWAp7JeQIOyggeyaqeuQnCB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL2RpcmVjdGlvbiBkaXJlY3Rpb259IENTUyDsho3shLHsnYQg6rWs67aE7ZWY6riwIOychO2VnCDqsJ3ssrRcclxuICogQHR5cGUge29iamVjdH1cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IExUUiBcImx0clwiXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBSVEwgXCJydGxcIlxyXG4gKi9cbnZhciBPUkRFUiA9IHtcbiAgTFRSOiBcImx0clwiLFxuICBSVEw6IFwicnRsXCJcbn07XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXR5cGVzXG52YXIgbWVyZ2UgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gIHZhciBzb3VyY2VzID0gW107XG4gIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgc291cmNlc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgfVxuICBzb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgIE9iamVjdC5rZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIHRhcmdldDtcbn07XG52YXIgZ2V0RWxlbWVudCA9IGZ1bmN0aW9uIChlbCwgcGFyZW50KSB7XG4gIHZhciB0YXJnZXRFbCA9IG51bGw7XG4gIGlmIChpc1N0cmluZyhlbCkpIHtcbiAgICB2YXIgcGFyZW50RWwgPSBwYXJlbnQgPyBwYXJlbnQgOiBkb2N1bWVudDtcbiAgICB2YXIgcXVlcnlSZXN1bHQgPSBwYXJlbnRFbC5xdWVyeVNlbGVjdG9yKGVsKTtcbiAgICBpZiAoIXF1ZXJ5UmVzdWx0KSB7XG4gICAgICB0aHJvdyBuZXcgRmxpY2tpbmdFcnJvcihNRVNTQUdFLkVMRU1FTlRfTk9UX0ZPVU5EKGVsKSwgQ09ERS5FTEVNRU5UX05PVF9GT1VORCk7XG4gICAgfVxuICAgIHRhcmdldEVsID0gcXVlcnlSZXN1bHQ7XG4gIH0gZWxzZSBpZiAoZWwgJiYgZWwubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgdGFyZ2V0RWwgPSBlbDtcbiAgfVxuICBpZiAoIXRhcmdldEVsKSB7XG4gICAgdGhyb3cgbmV3IEZsaWNraW5nRXJyb3IoTUVTU0FHRS5XUk9OR19UWVBFKGVsLCBbXCJIVE1MRWxlbWVudFwiLCBcInN0cmluZ1wiXSksIENPREUuV1JPTkdfVFlQRSk7XG4gIH1cbiAgcmV0dXJuIHRhcmdldEVsO1xufTtcbnZhciBjaGVja0V4aXN0ZW5jZSA9IGZ1bmN0aW9uICh2YWx1ZSwgbmFtZU9uRXJyTXNnKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEZsaWNraW5nRXJyb3IoTUVTU0FHRS5WQUxfTVVTVF9OT1RfTlVMTCh2YWx1ZSwgbmFtZU9uRXJyTXNnKSwgQ09ERS5WQUxfTVVTVF9OT1RfTlVMTCk7XG4gIH1cbn07XG52YXIgY2xhbXAkMSA9IGZ1bmN0aW9uICh4LCBtaW4sIG1heCkge1xuICByZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4oeCwgbWF4KSwgbWluKTtcbn07XG52YXIgZ2V0RmxpY2tpbmdBdHRhY2hlZCA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgaWYgKCF2YWwpIHtcbiAgICB0aHJvdyBuZXcgRmxpY2tpbmdFcnJvcihNRVNTQUdFLk5PVF9BVFRBQ0hFRF9UT19GTElDS0lORywgQ09ERS5OT1RfQVRUQUNIRURfVE9fRkxJQ0tJTkcpO1xuICB9XG4gIHJldHVybiB2YWw7XG59O1xudmFyIHRvQXJyYXkkMiA9IGZ1bmN0aW9uIChpdGVyYWJsZSkge1xuICByZXR1cm4gW10uc2xpY2UuY2FsbChpdGVyYWJsZSk7XG59O1xudmFyIHBhcnNlQWxpZ24kMSA9IGZ1bmN0aW9uIChhbGlnbiwgc2l6ZSkge1xuICB2YXIgYWxpZ25Qb2ludDtcbiAgaWYgKGlzU3RyaW5nKGFsaWduKSkge1xuICAgIHN3aXRjaCAoYWxpZ24pIHtcbiAgICAgIGNhc2UgQUxJR04uUFJFVjpcbiAgICAgICAgYWxpZ25Qb2ludCA9IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBBTElHTi5DRU5URVI6XG4gICAgICAgIGFsaWduUG9pbnQgPSAwLjUgKiBzaXplO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQUxJR04uTkVYVDpcbiAgICAgICAgYWxpZ25Qb2ludCA9IHNpemU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYWxpZ25Qb2ludCA9IHBhcnNlQXJpdGhtZXRpY1NpemUoYWxpZ24sIHNpemUpO1xuICAgICAgICBpZiAoYWxpZ25Qb2ludCA9PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZsaWNraW5nRXJyb3IoTUVTU0FHRS5XUk9OR19PUFRJT04oXCJhbGlnblwiLCBhbGlnbiksIENPREUuV1JPTkdfT1BUSU9OKTtcbiAgICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBhbGlnblBvaW50ID0gYWxpZ247XG4gIH1cbiAgcmV0dXJuIGFsaWduUG9pbnQ7XG59O1xudmFyIHBhcnNlQm91bmNlID0gZnVuY3Rpb24gKGJvdW5jZSwgc2l6ZSkge1xuICB2YXIgcGFyc2VkQm91bmNlO1xuICBpZiAoQXJyYXkuaXNBcnJheShib3VuY2UpKSB7XG4gICAgcGFyc2VkQm91bmNlID0gYm91bmNlLm1hcChmdW5jdGlvbiAodmFsKSB7XG4gICAgICByZXR1cm4gcGFyc2VBcml0aG1ldGljU2l6ZSh2YWwsIHNpemUpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHZhciBwYXJzZWRWYWwgPSBwYXJzZUFyaXRobWV0aWNTaXplKGJvdW5jZSwgc2l6ZSk7XG4gICAgcGFyc2VkQm91bmNlID0gW3BhcnNlZFZhbCwgcGFyc2VkVmFsXTtcbiAgfVxuICByZXR1cm4gcGFyc2VkQm91bmNlLm1hcChmdW5jdGlvbiAodmFsKSB7XG4gICAgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRmxpY2tpbmdFcnJvcihNRVNTQUdFLldST05HX09QVElPTihcImJvdW5jZVwiLCBib3VuY2UpLCBDT0RFLldST05HX09QVElPTik7XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG4gIH0pO1xufTtcbnZhciBwYXJzZUFyaXRobWV0aWNTaXplID0gZnVuY3Rpb24gKGNzc1ZhbHVlLCBiYXNlKSB7XG4gIHZhciBwYXJzZWQgPSBwYXJzZUFyaXRobWV0aWNFeHByZXNzaW9uKGNzc1ZhbHVlKTtcbiAgaWYgKHBhcnNlZCA9PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgcmV0dXJuIHBhcnNlZC5wZXJjZW50YWdlICogYmFzZSArIHBhcnNlZC5hYnNvbHV0ZTtcbn07XG52YXIgcGFyc2VBcml0aG1ldGljRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChjc3NWYWx1ZSkge1xuICB2YXIgY3NzUmVnZXggPSAvKD86KFxcK3xcXC0pXFxzKik/KFxcZCsoPzpcXC5cXGQrKT8oJXxweCk/KS9nO1xuICBpZiAodHlwZW9mIGNzc1ZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBlcmNlbnRhZ2U6IDAsXG4gICAgICBhYnNvbHV0ZTogY3NzVmFsdWVcbiAgICB9O1xuICB9XG4gIHZhciBwYXJzZWQgPSB7XG4gICAgcGVyY2VudGFnZTogMCxcbiAgICBhYnNvbHV0ZTogMFxuICB9O1xuICB2YXIgaWR4ID0gMDtcbiAgdmFyIG1hdGNoUmVzdWx0ID0gY3NzUmVnZXguZXhlYyhjc3NWYWx1ZSk7XG4gIHdoaWxlIChtYXRjaFJlc3VsdCAhPSBudWxsKSB7XG4gICAgdmFyIHNpZ24gPSBtYXRjaFJlc3VsdFsxXTtcbiAgICB2YXIgdmFsdWUgPSBtYXRjaFJlc3VsdFsyXTtcbiAgICB2YXIgdW5pdCA9IG1hdGNoUmVzdWx0WzNdO1xuICAgIHZhciBwYXJzZWRWYWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICAgIGlmIChpZHggPD0gMCkge1xuICAgICAgc2lnbiA9IHNpZ24gfHwgXCIrXCI7XG4gICAgfVxuICAgIC8vIFJldHVybiBkZWZhdWx0IHZhbHVlIGZvciB2YWx1ZXMgbm90IGluIGdvb2QgZm9ybVxuICAgIGlmICghc2lnbikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBzaWduTXVsdGlwbGllciA9IHNpZ24gPT09IFwiK1wiID8gMSA6IC0xO1xuICAgIGlmICh1bml0ID09PSBcIiVcIikge1xuICAgICAgcGFyc2VkLnBlcmNlbnRhZ2UgKz0gc2lnbk11bHRpcGxpZXIgKiAocGFyc2VkVmFsdWUgLyAxMDApO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJzZWQuYWJzb2x1dGUgKz0gc2lnbk11bHRpcGxpZXIgKiBwYXJzZWRWYWx1ZTtcbiAgICB9XG4gICAgLy8gTWF0Y2ggbmV4dCBvY2N1cnJlbmNlXG4gICAgKytpZHg7XG4gICAgbWF0Y2hSZXN1bHQgPSBjc3NSZWdleC5leGVjKGNzc1ZhbHVlKTtcbiAgfVxuICAvLyBOb25lLW1hdGNoZWRcbiAgaWYgKGlkeCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBwYXJzZWQ7XG59O1xudmFyIHBhcnNlQ1NTU2l6ZVZhbHVlID0gZnVuY3Rpb24gKHZhbCkge1xuICByZXR1cm4gaXNTdHJpbmcodmFsKSA/IHZhbCA6IHZhbCArIFwicHhcIjtcbn07XG52YXIgcGFyc2VQYW5lbEFsaWduID0gZnVuY3Rpb24gKGFsaWduKSB7XG4gIHJldHVybiB0eXBlb2YgYWxpZ24gPT09IFwib2JqZWN0XCIgPyBhbGlnbi5wYW5lbCA6IGFsaWduO1xufTtcbnZhciBnZXREaXJlY3Rpb24kMSA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gZW5kKSByZXR1cm4gRElSRUNUSU9OLk5PTkU7XG4gIHJldHVybiBzdGFydCA8IGVuZCA/IERJUkVDVElPTi5ORVhUIDogRElSRUNUSU9OLlBSRVY7XG59O1xudmFyIHBhcnNlRWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShlbGVtZW50KSkge1xuICAgIGVsZW1lbnQgPSBbZWxlbWVudF07XG4gIH1cbiAgdmFyIGVsZW1lbnRzID0gW107XG4gIGVsZW1lbnQuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICBpZiAoaXNTdHJpbmcoZWwpKSB7XG4gICAgICB2YXIgdGVtcERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICB0ZW1wRGl2LmlubmVySFRNTCA9IGVsO1xuICAgICAgZWxlbWVudHMucHVzaC5hcHBseShlbGVtZW50cywgX19zcHJlYWQkMSh0b0FycmF5JDIodGVtcERpdi5jaGlsZHJlbikpKTtcbiAgICAgIHdoaWxlICh0ZW1wRGl2LmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgdGVtcERpdi5yZW1vdmVDaGlsZCh0ZW1wRGl2LmZpcnN0Q2hpbGQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZWwgJiYgZWwubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICBlbGVtZW50cy5wdXNoKGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEZsaWNraW5nRXJyb3IoTUVTU0FHRS5XUk9OR19UWVBFKGVsLCBbXCJIVE1MRWxlbWVudFwiLCBcInN0cmluZ1wiXSksIENPREUuV1JPTkdfVFlQRSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGVsZW1lbnRzO1xufTtcbnZhciBnZXRNaW51c0NvbXBlbnNhdGVkSW5kZXggPSBmdW5jdGlvbiAoaWR4LCBtYXgpIHtcbiAgcmV0dXJuIGlkeCA8IDAgPyBjbGFtcCQxKGlkeCArIG1heCwgMCwgbWF4KSA6IGNsYW1wJDEoaWR4LCAwLCBtYXgpO1xufTtcbnZhciBpbmNsdWRlcyA9IGZ1bmN0aW9uIChhcnJheSwgdGFyZ2V0KSB7XG4gIHZhciBlXzEsIF9hO1xuICB0cnkge1xuICAgIGZvciAodmFyIGFycmF5XzEgPSBfX3ZhbHVlcyQxKGFycmF5KSwgYXJyYXlfMV8xID0gYXJyYXlfMS5uZXh0KCk7ICFhcnJheV8xXzEuZG9uZTsgYXJyYXlfMV8xID0gYXJyYXlfMS5uZXh0KCkpIHtcbiAgICAgIHZhciB2YWwgPSBhcnJheV8xXzEudmFsdWU7XG4gICAgICBpZiAodmFsID09PSB0YXJnZXQpIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSBjYXRjaCAoZV8xXzEpIHtcbiAgICBlXzEgPSB7XG4gICAgICBlcnJvcjogZV8xXzFcbiAgICB9O1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoYXJyYXlfMV8xICYmICFhcnJheV8xXzEuZG9uZSAmJiAoX2EgPSBhcnJheV8xLnJldHVybikpIF9hLmNhbGwoYXJyYXlfMSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcbnZhciBpc1N0cmluZyA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09IFwic3RyaW5nXCI7XG59O1xudmFyIGNpcmN1bGF0ZVBvc2l0aW9uID0gZnVuY3Rpb24gKHBvcywgbWluLCBtYXgpIHtcbiAgdmFyIHNpemUgPSBtYXggLSBtaW47XG4gIGlmIChwb3MgPCBtaW4pIHtcbiAgICB2YXIgb2Zmc2V0ID0gKG1pbiAtIHBvcykgJSBzaXplO1xuICAgIHBvcyA9IG1heCAtIG9mZnNldDtcbiAgfSBlbHNlIGlmIChwb3MgPiBtYXgpIHtcbiAgICB2YXIgb2Zmc2V0ID0gKHBvcyAtIG1heCkgJSBzaXplO1xuICAgIHBvcyA9IG1pbiArIG9mZnNldDtcbiAgfVxuICByZXR1cm4gcG9zO1xufTtcbnZhciBmaW5kJDEgPSBmdW5jdGlvbiAoYXJyYXksIGNoZWNrZXIpIHtcbiAgdmFyIGVfMiwgX2E7XG4gIHRyeSB7XG4gICAgZm9yICh2YXIgYXJyYXlfMiA9IF9fdmFsdWVzJDEoYXJyYXkpLCBhcnJheV8yXzEgPSBhcnJheV8yLm5leHQoKTsgIWFycmF5XzJfMS5kb25lOyBhcnJheV8yXzEgPSBhcnJheV8yLm5leHQoKSkge1xuICAgICAgdmFyIHZhbCA9IGFycmF5XzJfMS52YWx1ZTtcbiAgICAgIGlmIChjaGVja2VyKHZhbCkpIHtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGVfMl8xKSB7XG4gICAgZV8yID0ge1xuICAgICAgZXJyb3I6IGVfMl8xXG4gICAgfTtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKGFycmF5XzJfMSAmJiAhYXJyYXlfMl8xLmRvbmUgJiYgKF9hID0gYXJyYXlfMi5yZXR1cm4pKSBfYS5jYWxsKGFycmF5XzIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufTtcbnZhciBmaW5kUmlnaHQgPSBmdW5jdGlvbiAoYXJyYXksIGNoZWNrZXIpIHtcbiAgZm9yICh2YXIgaWR4ID0gYXJyYXkubGVuZ3RoIC0gMTsgaWR4ID49IDA7IGlkeC0tKSB7XG4gICAgdmFyIHZhbCA9IGFycmF5W2lkeF07XG4gICAgaWYgKGNoZWNrZXIodmFsKSkge1xuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xudmFyIGZpbmRJbmRleCA9IGZ1bmN0aW9uIChhcnJheSwgY2hlY2tlcikge1xuICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBhcnJheS5sZW5ndGg7IGlkeCsrKSB7XG4gICAgaWYgKGNoZWNrZXIoYXJyYXlbaWR4XSkpIHtcbiAgICAgIHJldHVybiBpZHg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn07XG52YXIgZ2V0UHJvZ3Jlc3MgPSBmdW5jdGlvbiAocG9zLCBwcmV2LCBuZXh0KSB7XG4gIHJldHVybiAocG9zIC0gcHJldikgLyAobmV4dCAtIHByZXYpO1xufTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3NcbnZhciBnZXRTdHlsZSA9IGZ1bmN0aW9uIChlbCkge1xuICByZXR1cm4gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpIHx8IGVsLmN1cnJlbnRTdHlsZTtcbn07XG52YXIgc2V0U2l6ZSA9IGZ1bmN0aW9uIChlbCwgX2EpIHtcbiAgdmFyIHdpZHRoID0gX2Eud2lkdGgsXG4gICAgaGVpZ2h0ID0gX2EuaGVpZ2h0O1xuICBpZiAod2lkdGggIT0gbnVsbCkge1xuICAgIGlmIChpc1N0cmluZyh3aWR0aCkpIHtcbiAgICAgIGVsLnN0eWxlLndpZHRoID0gd2lkdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlLndpZHRoID0gd2lkdGggKyBcInB4XCI7XG4gICAgfVxuICB9XG4gIGlmIChoZWlnaHQgIT0gbnVsbCkge1xuICAgIGlmIChpc1N0cmluZyhoZWlnaHQpKSB7XG4gICAgICBlbC5zdHlsZS5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlLmhlaWdodCA9IGhlaWdodCArIFwicHhcIjtcbiAgICB9XG4gIH1cbn07XG52YXIgaXNCZXR3ZWVuID0gZnVuY3Rpb24gKHZhbCwgbWluLCBtYXgpIHtcbiAgcmV0dXJuIHZhbCA+PSBtaW4gJiYgdmFsIDw9IG1heDtcbn07XG52YXIgY2lyY3VsYXRlSW5kZXggPSBmdW5jdGlvbiAoaW5kZXgsIG1heCkge1xuICBpZiAoaW5kZXggPj0gbWF4KSB7XG4gICAgcmV0dXJuIGluZGV4ICUgbWF4O1xuICB9IGVsc2UgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiBnZXRNaW51c0NvbXBlbnNhdGVkSW5kZXgoKGluZGV4ICsgMSkgJSBtYXggLSAxLCBtYXgpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBpbmRleDtcbiAgfVxufTtcbnZhciByYW5nZSA9IGZ1bmN0aW9uIChlbmQpIHtcbiAgdmFyIGFyciA9IG5ldyBBcnJheShlbmQpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgYXJyW2ldID0gaTtcbiAgfVxuICByZXR1cm4gYXJyO1xufTtcbnZhciBnZXRFbGVtZW50U2l6ZSA9IGZ1bmN0aW9uIChfYSkge1xuICB2YXIgZWwgPSBfYS5lbCxcbiAgICBob3Jpem9udGFsID0gX2EuaG9yaXpvbnRhbCxcbiAgICB1c2VGcmFjdGlvbmFsU2l6ZSA9IF9hLnVzZUZyYWN0aW9uYWxTaXplLFxuICAgIHVzZU9mZnNldCA9IF9hLnVzZU9mZnNldCxcbiAgICBzdHlsZSA9IF9hLnN0eWxlO1xuICB2YXIgc2l6ZSA9IDA7XG4gIGlmICh1c2VGcmFjdGlvbmFsU2l6ZSkge1xuICAgIHZhciBiYXNlU2l6ZSA9IHBhcnNlRmxvYXQoaG9yaXpvbnRhbCA/IHN0eWxlLndpZHRoIDogc3R5bGUuaGVpZ2h0KSB8fCAwO1xuICAgIHZhciBpc0JvcmRlckJveFNpemluZyA9IHN0eWxlLmJveFNpemluZyA9PT0gXCJib3JkZXItYm94XCI7XG4gICAgdmFyIGJvcmRlciA9IGhvcml6b250YWwgPyBwYXJzZUZsb2F0KHN0eWxlLmJvcmRlckxlZnRXaWR0aCB8fCBcIjBcIikgKyBwYXJzZUZsb2F0KHN0eWxlLmJvcmRlclJpZ2h0V2lkdGggfHwgXCIwXCIpIDogcGFyc2VGbG9hdChzdHlsZS5ib3JkZXJUb3BXaWR0aCB8fCBcIjBcIikgKyBwYXJzZUZsb2F0KHN0eWxlLmJvcmRlckJvdHRvbVdpZHRoIHx8IFwiMFwiKTtcbiAgICBpZiAoaXNCb3JkZXJCb3hTaXppbmcpIHtcbiAgICAgIHNpemUgPSB1c2VPZmZzZXQgPyBiYXNlU2l6ZSA6IGJhc2VTaXplIC0gYm9yZGVyO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcGFkZGluZyA9IGhvcml6b250YWwgPyBwYXJzZUZsb2F0KHN0eWxlLnBhZGRpbmdMZWZ0IHx8IFwiMFwiKSArIHBhcnNlRmxvYXQoc3R5bGUucGFkZGluZ1JpZ2h0IHx8IFwiMFwiKSA6IHBhcnNlRmxvYXQoc3R5bGUucGFkZGluZ1RvcCB8fCBcIjBcIikgKyBwYXJzZUZsb2F0KHN0eWxlLnBhZGRpbmdCb3R0b20gfHwgXCIwXCIpO1xuICAgICAgc2l6ZSA9IHVzZU9mZnNldCA/IGJhc2VTaXplICsgcGFkZGluZyArIGJvcmRlciA6IGJhc2VTaXplICsgcGFkZGluZztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIHNpemVTdHIgPSBob3Jpem9udGFsID8gXCJXaWR0aFwiIDogXCJIZWlnaHRcIjtcbiAgICBzaXplID0gdXNlT2Zmc2V0ID8gZWxbXCJvZmZzZXRcIiArIHNpemVTdHJdIDogZWxbXCJjbGllbnRcIiArIHNpemVTdHJdO1xuICB9XG4gIHJldHVybiBNYXRoLm1heChzaXplLCAwKTtcbn07XG52YXIgc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gKG9iaiwgcHJvdG8pIHtcbiAgb2JqLl9fcHJvdG9fXyA9IHByb3RvO1xuICByZXR1cm4gb2JqO1xufTtcblxuLypcclxuICogQ29weXJpZ2h0IChjKSAyMDE1IE5BVkVSIENvcnAuXHJcbiAqIGVnanMgcHJvamVjdHMgYXJlIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cbi8qKlxyXG4gKiBTcGVjaWFsIHR5cGUgb2Yga25vd24gZXJyb3IgdGhhdCB7QGxpbmsgRmxpY2tpbmd9IHRocm93cy5cclxuICogQGtvIEZsaWNraW5nIOuCtOu2gOyXkOyEnCDslYzroKTsp4Qg7Jik66WYIOuwnOyDneyLnCB0aHJvd+uQmOuKlCDsl5Drn6xcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IGNvZGUgRXJyb3IgY29kZTxrbz7sl5Drn6wg7L2U65OcPC9rbz5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IG1lc3NhZ2UgRXJyb3IgbWVzc2FnZTxrbz7sl5Drn6wg66mU7Iuc7KeAPC9rbz5cclxuICogQHNlZSB7QGxpbmsgRVJST1JfQ09ERSBFUlJPUl9DT0RFfVxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGB0c1xyXG4gKiBpbXBvcnQgRmxpY2tpbmcsIHsgRmxpY2tpbmdFcnJvciwgRVJST1JfQ09ERVMgfSBmcm9tIFwiQGVnanMvZmxpY2tpbmdcIjtcclxuICogdHJ5IHtcclxuICogICBjb25zdCBmbGlja2luZyA9IG5ldyBGbGlja2luZyhcIi5mbGlja2luZy12aWV3cG9ydFwiKVxyXG4gKiB9IGNhdGNoIChlKSB7XHJcbiAqICAgaWYgKGUgaW5zdGFuY2VvZiBGbGlja2luZ0Vycm9yICYmIGUuY29kZSA9PT0gRVJST1JfQ09ERVMuRUxFTUVOVF9OT1RfRk9VTkQpIHtcclxuICogICAgIGNvbnNvbGUuZXJyb3IoXCJFbGVtZW50IG5vdCBmb3VuZFwiKVxyXG4gKiAgIH1cclxuICogfVxyXG4gKiBgYGBcclxuICovXG52YXIgRmxpY2tpbmdFcnJvciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyQzKEZsaWNraW5nRXJyb3IsIF9zdXBlcik7XG4gIC8qKlxyXG4gICAqIEBwYXJhbSBtZXNzYWdlIEVycm9yIG1lc3NhZ2U8a28+7JeQ65+sIOuplOyLnOyngDwva28+XHJcbiAgICogQHBhcmFtIGNvZGUgRXJyb3IgY29kZTxrbz7sl5Drn6wg7L2U65OcPC9rbz5cclxuICAgKi9cbiAgZnVuY3Rpb24gRmxpY2tpbmdFcnJvcihtZXNzYWdlLCBjb2RlKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbWVzc2FnZSkgfHwgdGhpcztcbiAgICBzZXRQcm90b3R5cGVPZihfdGhpcywgRmxpY2tpbmdFcnJvci5wcm90b3R5cGUpO1xuICAgIF90aGlzLm5hbWUgPSBcIkZsaWNraW5nRXJyb3JcIjtcbiAgICBfdGhpcy5jb2RlID0gY29kZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgcmV0dXJuIEZsaWNraW5nRXJyb3I7XG59KEVycm9yKTtcblxuLyoqXHJcbiAqIEEgY29tcG9uZW50IHRoYXQgbWFuYWdlcyB2aWV3cG9ydCBzaXplXHJcbiAqIEBrbyDrt7Dtj6ztirgg7YGs6riwIOygleuztOulvCDri7Tri7ntlZjripQg7Lu07Y+s64SM7Yq4XHJcbiAqL1xudmFyIFZpZXdwb3J0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXHJcbiAgICogQHBhcmFtIGVsIEEgdmlld3BvcnQgZWxlbWVudDxrbz7rt7Dtj6ztirgg7JeY66as66i87Yq4PC9rbz5cclxuICAgKi9cbiAgZnVuY3Rpb24gVmlld3BvcnQoZmxpY2tpbmcsIGVsKSB7XG4gICAgdGhpcy5fZmxpY2tpbmcgPSBmbGlja2luZztcbiAgICB0aGlzLl9lbCA9IGVsO1xuICAgIHRoaXMuX3dpZHRoID0gMDtcbiAgICB0aGlzLl9oZWlnaHQgPSAwO1xuICAgIHRoaXMuX3BhZGRpbmcgPSB7XG4gICAgICBsZWZ0OiAwLFxuICAgICAgcmlnaHQ6IDAsXG4gICAgICB0b3A6IDAsXG4gICAgICBib3R0b206IDBcbiAgICB9O1xuICAgIHRoaXMuX2lzQm9yZGVyQm94U2l6aW5nID0gZmFsc2U7XG4gIH1cbiAgdmFyIF9fcHJvdG8gPSBWaWV3cG9ydC5wcm90b3R5cGU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcImVsZW1lbnRcIiwge1xuICAgIC8qKlxyXG4gICAgICogQSB2aWV3cG9ydChyb290KSBlbGVtZW50XHJcbiAgICAgKiBAa28g67ew7Y+s7Yq4KHJvb3QpIOyXmOumrOuovO2KuFxyXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9lbDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwid2lkdGhcIiwge1xuICAgIC8qKlxyXG4gICAgICogVmlld3BvcnQgd2lkdGgsIHdpdGhvdXQgcGFkZGluZ3NcclxuICAgICAqIEBrbyDrt7Dtj6ztirgg64SI67mEXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl93aWR0aCAtIHRoaXMuX3BhZGRpbmcubGVmdCAtIHRoaXMuX3BhZGRpbmcucmlnaHQ7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcImhlaWdodFwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBWaWV3cG9ydCBoZWlnaHQsIHdpdGhvdXQgcGFkZGluZ3NcclxuICAgICAqIEBrbyDrt7Dtj6ztirgg64aS7J20XHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9oZWlnaHQgLSB0aGlzLl9wYWRkaW5nLnRvcCAtIHRoaXMuX3BhZGRpbmcuYm90dG9tO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJwYWRkaW5nXCIsIHtcbiAgICAvKipcclxuICAgICAqIFZpZXdwb3J0IHBhZGRpbmdzXHJcbiAgICAgKiBAa28g67ew7Y+s7Yq4IENTUyBwYWRkaW5nIOqwklxyXG4gICAgICogQHR5cGUge29iamVjdH1cclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsZWZ0IENTUyBgcGFkZGluZy1sZWZ0YFxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHJpZ2h0IENTUyBgcGFkZGluZy1yaWdodGBcclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0b3AgQ1NTIGBwYWRkaW5nLXRvcGBcclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBib3R0b20gQ1NTIGBwYWRkaW5nLWJvdHRvbWBcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcGFkZGluZztcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgLyoqXHJcbiAgICogQ2hhbmdlIHZpZXdwb3J0J3Mgc2l6ZS5cclxuICAgKiBUaGlzIHdpbGwgY2hhbmdlIHRoZSBhY3R1YWwgc2l6ZSBvZiBgLmZsaWNraW5nLXZpZXdwb3J0YCBlbGVtZW50IGJ5IGNoYW5naW5nIGl0cyBDU1Mgd2lkdGgvaGVpZ2h0IHByb3BlcnR5XHJcbiAgICogQGtvIOu3sO2PrO2KuCDtgazquLDrpbwg67OA6rK97ZWp64uI64ukLlxyXG4gICAqIGAuZmxpY2tpbmctdmlld3BvcnRgIOyXmOumrOuovO2KuOyXkCDtlbTri7kg7YGs6riw7J2YIENTUyB3aWR0aC9oZWlnaHTrpbwg7KCB7Jqp7ZWp64uI64ukXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IFtzaXplXSBOZXcgdmlld3BvcnQgc2l6ZTxrbz7sg4gg67ew7Y+s7Yq4IO2BrOq4sDwva28+XHJcbiAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbc2l6ZS53aWR0aF0gQ1NTIHN0cmluZyBvciBudW1iZXIoaW4gcHgpPGtvPkNTUyDrrLjsnpDsl7Qg65iQ64qUIOyIq+yekChweCk8L2tvPlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW3NpemUuaGVpZ2h0XSBDU1Mgc3RyaW5nIG9yIG51bWJlcihpbiBweCk8a28+Q1NTIOusuOyekOyXtCDrmJDripQg7Iir7J6QKHB4KTwva28+XHJcbiAgICovXG4gIF9fcHJvdG8uc2V0U2l6ZSA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciB3aWR0aCA9IF9hLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gX2EuaGVpZ2h0O1xuICAgIHZhciBlbCA9IHRoaXMuX2VsO1xuICAgIHZhciBwYWRkaW5nID0gdGhpcy5fcGFkZGluZztcbiAgICB2YXIgaXNCb3JkZXJCb3hTaXppbmcgPSB0aGlzLl9pc0JvcmRlckJveFNpemluZztcbiAgICBpZiAod2lkdGggIT0gbnVsbCkge1xuICAgICAgaWYgKGlzU3RyaW5nKHdpZHRoKSkge1xuICAgICAgICBlbC5zdHlsZS53aWR0aCA9IHdpZHRoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG5ld1dpZHRoID0gaXNCb3JkZXJCb3hTaXppbmcgPyB3aWR0aCArIHBhZGRpbmcubGVmdCArIHBhZGRpbmcucmlnaHQgOiB3aWR0aDtcbiAgICAgICAgZWwuc3R5bGUud2lkdGggPSBuZXdXaWR0aCArIFwicHhcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGhlaWdodCAhPSBudWxsKSB7XG4gICAgICBpZiAoaXNTdHJpbmcoaGVpZ2h0KSkge1xuICAgICAgICBlbC5zdHlsZS5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbmV3SGVpZ2h0ID0gaXNCb3JkZXJCb3hTaXppbmcgPyBoZWlnaHQgKyBwYWRkaW5nLnRvcCArIHBhZGRpbmcuYm90dG9tIDogaGVpZ2h0O1xuICAgICAgICBlbC5zdHlsZS5oZWlnaHQgPSBuZXdIZWlnaHQgKyBcInB4XCI7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMucmVzaXplKCk7XG4gIH07XG4gIC8qKlxyXG4gICAqIFVwZGF0ZSB3aWR0aC9oZWlnaHQgdG8gdGhlIGN1cnJlbnQgdmlld3BvcnQgZWxlbWVudCdzIHNpemVcclxuICAgKiBAa28g7ZiE7J6sIOu3sO2PrO2KuCDsl5jrpqzrqLztirjsnZgg7YGs6riw66GcIOuEiOu5hC/rhpLsnbTrpbwg7JeF642w7J207Yq47ZWp64uI64ukXHJcbiAgICovXG4gIF9fcHJvdG8ucmVzaXplID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbCA9IHRoaXMuX2VsO1xuICAgIHZhciBlbFN0eWxlID0gZ2V0U3R5bGUoZWwpO1xuICAgIHZhciB1c2VGcmFjdGlvbmFsU2l6ZSA9IHRoaXMuX2ZsaWNraW5nLnVzZUZyYWN0aW9uYWxTaXplO1xuICAgIHRoaXMuX3dpZHRoID0gZ2V0RWxlbWVudFNpemUoe1xuICAgICAgZWw6IGVsLFxuICAgICAgaG9yaXpvbnRhbDogdHJ1ZSxcbiAgICAgIHVzZUZyYWN0aW9uYWxTaXplOiB1c2VGcmFjdGlvbmFsU2l6ZSxcbiAgICAgIHVzZU9mZnNldDogZmFsc2UsXG4gICAgICBzdHlsZTogZWxTdHlsZVxuICAgIH0pO1xuICAgIHRoaXMuX2hlaWdodCA9IGdldEVsZW1lbnRTaXplKHtcbiAgICAgIGVsOiBlbCxcbiAgICAgIGhvcml6b250YWw6IGZhbHNlLFxuICAgICAgdXNlRnJhY3Rpb25hbFNpemU6IHVzZUZyYWN0aW9uYWxTaXplLFxuICAgICAgdXNlT2Zmc2V0OiBmYWxzZSxcbiAgICAgIHN0eWxlOiBlbFN0eWxlXG4gICAgfSk7XG4gICAgdGhpcy5fcGFkZGluZyA9IHtcbiAgICAgIGxlZnQ6IGVsU3R5bGUucGFkZGluZ0xlZnQgPyBwYXJzZUZsb2F0KGVsU3R5bGUucGFkZGluZ0xlZnQpIDogMCxcbiAgICAgIHJpZ2h0OiBlbFN0eWxlLnBhZGRpbmdSaWdodCA/IHBhcnNlRmxvYXQoZWxTdHlsZS5wYWRkaW5nUmlnaHQpIDogMCxcbiAgICAgIHRvcDogZWxTdHlsZS5wYWRkaW5nVG9wID8gcGFyc2VGbG9hdChlbFN0eWxlLnBhZGRpbmdUb3ApIDogMCxcbiAgICAgIGJvdHRvbTogZWxTdHlsZS5wYWRkaW5nQm90dG9tID8gcGFyc2VGbG9hdChlbFN0eWxlLnBhZGRpbmdCb3R0b20pIDogMFxuICAgIH07XG4gICAgdGhpcy5faXNCb3JkZXJCb3hTaXppbmcgPSBlbFN0eWxlLmJveFNpemluZyA9PT0gXCJib3JkZXItYm94XCI7XG4gIH07XG4gIHJldHVybiBWaWV3cG9ydDtcbn0oKTtcblxudmFyIEF1dG9SZXNpemVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQXV0b1Jlc2l6ZXIoZmxpY2tpbmcpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHRoaXMuX29uUmVzaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGZsaWNraW5nID0gX3RoaXMuX2ZsaWNraW5nO1xuICAgICAgdmFyIHJlc2l6ZURlYm91bmNlID0gZmxpY2tpbmcucmVzaXplRGVib3VuY2U7XG4gICAgICB2YXIgbWF4UmVzaXplRGVib3VuY2UgPSBmbGlja2luZy5tYXhSZXNpemVEZWJvdW5jZTtcbiAgICAgIGlmIChyZXNpemVEZWJvdW5jZSA8PSAwKSB7XG4gICAgICAgIHZvaWQgZmxpY2tpbmcucmVzaXplKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoX3RoaXMuX21heFJlc2l6ZURlYm91bmNlVGltZXIgPD0gMCkge1xuICAgICAgICAgIGlmIChtYXhSZXNpemVEZWJvdW5jZSA+IDAgJiYgbWF4UmVzaXplRGVib3VuY2UgPj0gcmVzaXplRGVib3VuY2UpIHtcbiAgICAgICAgICAgIF90aGlzLl9tYXhSZXNpemVEZWJvdW5jZVRpbWVyID0gd2luZG93LnNldFRpbWVvdXQoX3RoaXMuX2RvU2NoZWR1bGVkUmVzaXplLCBtYXhSZXNpemVEZWJvdW5jZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChfdGhpcy5fcmVzaXplVGltZXIgPiAwKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLl9yZXNpemVUaW1lcik7XG4gICAgICAgICAgX3RoaXMuX3Jlc2l6ZVRpbWVyID0gMDtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5fcmVzaXplVGltZXIgPSB3aW5kb3cuc2V0VGltZW91dChfdGhpcy5fZG9TY2hlZHVsZWRSZXNpemUsIHJlc2l6ZURlYm91bmNlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuX2RvU2NoZWR1bGVkUmVzaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLl9yZXNpemVUaW1lcik7XG4gICAgICBjbGVhclRpbWVvdXQoX3RoaXMuX21heFJlc2l6ZURlYm91bmNlVGltZXIpO1xuICAgICAgX3RoaXMuX21heFJlc2l6ZURlYm91bmNlVGltZXIgPSAtMTtcbiAgICAgIF90aGlzLl9yZXNpemVUaW1lciA9IC0xO1xuICAgICAgdm9pZCBfdGhpcy5fZmxpY2tpbmcucmVzaXplKCk7XG4gICAgfTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L21lbWJlci1vcmRlcmluZ1xuICAgIHRoaXMuX3NraXBGaXJzdFJlc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBpc0ZpcnN0UmVzaXplID0gdHJ1ZTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpc0ZpcnN0UmVzaXplKSB7XG4gICAgICAgICAgaXNGaXJzdFJlc2l6ZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5fb25SZXNpemUoKTtcbiAgICAgIH07XG4gICAgfSgpO1xuICAgIHRoaXMuX2ZsaWNraW5nID0gZmxpY2tpbmc7XG4gICAgdGhpcy5fZW5hYmxlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3Jlc2l6ZU9ic2VydmVyID0gbnVsbDtcbiAgICB0aGlzLl9yZXNpemVUaW1lciA9IC0xO1xuICAgIHRoaXMuX21heFJlc2l6ZURlYm91bmNlVGltZXIgPSAtMTtcbiAgfVxuICB2YXIgX19wcm90byA9IEF1dG9SZXNpemVyLnByb3RvdHlwZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwiZW5hYmxlZFwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZW5hYmxlZDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgX19wcm90by5lbmFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZsaWNraW5nID0gdGhpcy5fZmxpY2tpbmc7XG4gICAgdmFyIHZpZXdwb3J0ID0gZmxpY2tpbmcudmlld3BvcnQ7XG4gICAgaWYgKHRoaXMuX2VuYWJsZWQpIHtcbiAgICAgIHRoaXMuZGlzYWJsZSgpO1xuICAgIH1cbiAgICBpZiAoZmxpY2tpbmcudXNlUmVzaXplT2JzZXJ2ZXIgJiYgISF3aW5kb3cuUmVzaXplT2JzZXJ2ZXIpIHtcbiAgICAgIHZhciB2aWV3cG9ydFNpemVOb3QwID0gdmlld3BvcnQud2lkdGggIT09IDAgfHwgdmlld3BvcnQuaGVpZ2h0ICE9PSAwO1xuICAgICAgdmFyIHJlc2l6ZU9ic2VydmVyID0gdmlld3BvcnRTaXplTm90MCA/IG5ldyBSZXNpemVPYnNlcnZlcih0aGlzLl9za2lwRmlyc3RSZXNpemUpIDogbmV3IFJlc2l6ZU9ic2VydmVyKHRoaXMuX29uUmVzaXplKTtcbiAgICAgIHJlc2l6ZU9ic2VydmVyLm9ic2VydmUoZmxpY2tpbmcudmlld3BvcnQuZWxlbWVudCk7XG4gICAgICB0aGlzLl9yZXNpemVPYnNlcnZlciA9IHJlc2l6ZU9ic2VydmVyO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLl9vblJlc2l6ZSk7XG4gICAgfVxuICAgIHRoaXMuX2VuYWJsZWQgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBfX3Byb3RvLmRpc2FibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLl9lbmFibGVkKSByZXR1cm4gdGhpcztcbiAgICB2YXIgcmVzaXplT2JzZXJ2ZXIgPSB0aGlzLl9yZXNpemVPYnNlcnZlcjtcbiAgICBpZiAocmVzaXplT2JzZXJ2ZXIpIHtcbiAgICAgIHJlc2l6ZU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgIHRoaXMuX3Jlc2l6ZU9ic2VydmVyID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5fb25SZXNpemUpO1xuICAgIH1cbiAgICB0aGlzLl9lbmFibGVkID0gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIHJldHVybiBBdXRvUmVzaXplcjtcbn0oKTtcblxuLyoqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cbnZhciBWYW5pbGxhRWxlbWVudFByb3ZpZGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVmFuaWxsYUVsZW1lbnRQcm92aWRlcihlbGVtZW50KSB7XG4gICAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdGhpcy5fcmVuZGVyZWQgPSB0cnVlO1xuICB9XG4gIHZhciBfX3Byb3RvID0gVmFuaWxsYUVsZW1lbnRQcm92aWRlci5wcm90b3R5cGU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcImVsZW1lbnRcIiwge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQ7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcInJlbmRlcmVkXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJlZDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgX19wcm90by5zaG93ID0gZnVuY3Rpb24gKGZsaWNraW5nKSB7XG4gICAgdmFyIGVsID0gdGhpcy5lbGVtZW50O1xuICAgIHZhciBjYW1lcmFFbCA9IGZsaWNraW5nLmNhbWVyYS5lbGVtZW50O1xuICAgIGlmIChlbC5wYXJlbnRFbGVtZW50ICE9PSBjYW1lcmFFbCkge1xuICAgICAgY2FtZXJhRWwuYXBwZW5kQ2hpbGQoZWwpO1xuICAgICAgdGhpcy5fcmVuZGVyZWQgPSB0cnVlO1xuICAgIH1cbiAgfTtcbiAgX19wcm90by5oaWRlID0gZnVuY3Rpb24gKGZsaWNraW5nKSB7XG4gICAgdmFyIGVsID0gdGhpcy5lbGVtZW50O1xuICAgIHZhciBjYW1lcmFFbCA9IGZsaWNraW5nLmNhbWVyYS5lbGVtZW50O1xuICAgIGlmIChlbC5wYXJlbnRFbGVtZW50ID09PSBjYW1lcmFFbCkge1xuICAgICAgY2FtZXJhRWwucmVtb3ZlQ2hpbGQoZWwpO1xuICAgICAgdGhpcy5fcmVuZGVyZWQgPSBmYWxzZTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBWYW5pbGxhRWxlbWVudFByb3ZpZGVyO1xufSgpO1xuXG4vKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgTkFWRVIgQ29ycC5cclxuICogZWdqcyBwcm9qZWN0cyBhcmUgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xuLyoqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cbnZhciBWaXJ0dWFsRWxlbWVudFByb3ZpZGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVmlydHVhbEVsZW1lbnRQcm92aWRlcihmbGlja2luZykge1xuICAgIHRoaXMuX2ZsaWNraW5nID0gZmxpY2tpbmc7XG4gIH1cbiAgdmFyIF9fcHJvdG8gPSBWaXJ0dWFsRWxlbWVudFByb3ZpZGVyLnByb3RvdHlwZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwiZWxlbWVudFwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdmlydHVhbEVsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwicmVuZGVyZWRcIiwge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3ZpcnR1YWxFbGVtZW50LnZpc2libGU7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcIl92aXJ0dWFsRWxlbWVudFwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZmxpY2tpbmcgPSB0aGlzLl9mbGlja2luZztcbiAgICAgIHZhciBlbEluZGV4ID0gdGhpcy5fcGFuZWwuZWxlbWVudEluZGV4O1xuICAgICAgdmFyIHZpcnR1YWxFbGVtZW50cyA9IGZsaWNraW5nLnZpcnR1YWwuZWxlbWVudHM7XG4gICAgICByZXR1cm4gdmlydHVhbEVsZW1lbnRzW2VsSW5kZXhdO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBfX3Byb3RvLmluaXQgPSBmdW5jdGlvbiAocGFuZWwpIHtcbiAgICB0aGlzLl9wYW5lbCA9IHBhbmVsO1xuICB9O1xuICBfX3Byb3RvLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gRE9fTk9USElOR1xuICAgIC8vIEFjdHVhbCBlbGVtZW50IHZpc2liaWxpdHkgaXMgY29udHJvbGxlZCBieSBWaXJ0dWFsTWFuYWdlclxuICB9O1xuICBfX3Byb3RvLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gRE9fTk9USElOR1xuICAgIC8vIEFjdHVhbCBlbGVtZW50IHZpc2liaWxpdHkgaXMgY29udHJvbGxlZCBieSBWaXJ0dWFsTWFuYWdlclxuICB9O1xuICByZXR1cm4gVmlydHVhbEVsZW1lbnRQcm92aWRlcjtcbn0oKTtcblxuLyoqXHJcbiAqIEEgbWFuYWdlciBjbGFzcyB0byBhZGQgLyByZW1vdmUgdmlydHVhbCBwYW5lbHNcclxuICovXG52YXIgVmlydHVhbE1hbmFnZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBWaXJ0dWFsTWFuYWdlcihmbGlja2luZywgb3B0aW9ucykge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICB0aGlzLl9mbGlja2luZyA9IGZsaWNraW5nO1xuICAgIHRoaXMuX3JlbmRlclBhbmVsID0gKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnJlbmRlclBhbmVsKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9O1xuICAgIHRoaXMuX2luaXRpYWxQYW5lbENvdW50ID0gKF9iID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmluaXRpYWxQYW5lbENvdW50KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAtMTtcbiAgICB0aGlzLl9jYWNoZSA9IChfYyA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jYWNoZSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogZmFsc2U7XG4gICAgdGhpcy5fcGFuZWxDbGFzcyA9IChfZCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wYW5lbENsYXNzKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBDTEFTUy5ERUZBVUxUX1ZJUlRVQUw7XG4gICAgdGhpcy5fZWxlbWVudHMgPSBbXTtcbiAgfVxuICB2YXIgX19wcm90byA9IFZpcnR1YWxNYW5hZ2VyLnByb3RvdHlwZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwiZWxlbWVudHNcIiwge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2VsZW1lbnRzO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJyZW5kZXJQYW5lbFwiLCB7XG4gICAgLy8gT3B0aW9uc1xuICAgIC8qKlxyXG4gICAgICogQSByZW5kZXJpbmcgZnVuY3Rpb24gZm9yIHRoZSBwYW5lbCBlbGVtZW50J3MgaW5uZXJIVE1MXHJcbiAgICAgKiBAa28g7Yyo64SQIOyXmOumrOuovO2KuOydmCBpbm5lckhUTUzsnYQg66CM642U66eB7ZWY64qUIO2VqOyImFxyXG4gICAgICogQHR5cGUge2Z1bmN0aW9ufVxyXG4gICAgICogQHBhcmFtIHtWaXJ0dWFsUGFuZWx9IHBhbmVsIEluc3RhbmNlIG9mIHRoZSBwYW5lbDxrbz7tjKjrhJAg7J247Iqk7YS07IqkPC9rbz5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCBvZiB0aGUgcGFuZWw8a28+7Yyo64SQIOyduOuNseyKpDwva28+XHJcbiAgICAgKiBAZGVmYXVsdCBcIigpID0+IHt9XCJcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlclBhbmVsO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICB0aGlzLl9yZW5kZXJQYW5lbCA9IHZhbDtcbiAgICAgIHRoaXMuX2ZsaWNraW5nLnJlbmRlcmVyLnBhbmVscy5mb3JFYWNoKGZ1bmN0aW9uIChwYW5lbCkge1xuICAgICAgICByZXR1cm4gcGFuZWwudW5jYWNoZVJlbmRlclJlc3VsdCgpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcImluaXRpYWxQYW5lbENvdW50XCIsIHtcbiAgICAvKipcclxuICAgICAqIEluaXRpYWwgcGFuZWwgY291bnQgdG8gcmVuZGVyXHJcbiAgICAgKiBAa28g7LWc7LSI66GcIOugjOuNlOunge2VoCDtjKjrhJDsnZgg6rCc7IiYXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCAtMVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5faW5pdGlhbFBhbmVsQ291bnQ7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcImNhY2hlXCIsIHtcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgdG8gY2FjaGUgcmVuZGVyZWQgcGFuZWwncyBpbm5lckhUTUxcclxuICAgICAqIEBrbyDroIzrjZTrp4HrkJwg7Yyo64SQ7J2YIGlubmVySFRNTCDsoJXrs7Trpbwg7LqQ7Iuc7ZWg7KeAIOyXrOu2gFxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2FjaGU7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHRoaXMuX2NhY2hlID0gdmFsO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJwYW5lbENsYXNzXCIsIHtcbiAgICAvKipcclxuICAgICAqIFRoZSBjbGFzcyBuYW1lIHRoYXQgd2lsbCBiZSBhcHBsaWVkIHRvIHJlbmRlcmVkIHBhbmVsIGVsZW1lbnRzXHJcbiAgICAgKiBAa28g66CM642U66eB65CY64qUIO2MqOuEkCDsl5jrpqzrqLztirjsl5Ag7KCB7Jqp65CgIO2BtOuemOyKpCDsnbTrpoRcclxuICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgKiBAZGVmYXVsdCBcImZsaWNraW5nLXBhbmVsXCJcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3BhbmVsQ2xhc3M7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHRoaXMuX3BhbmVsQ2xhc3MgPSB2YWw7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIF9fcHJvdG8uaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZmxpY2tpbmcgPSB0aGlzLl9mbGlja2luZztcbiAgICBpZiAoIWZsaWNraW5nLnZpcnR1YWxFbmFibGVkKSByZXR1cm47XG4gICAgaWYgKCFmbGlja2luZy5leHRlcm5hbFJlbmRlcmVyICYmICFmbGlja2luZy5yZW5kZXJFeHRlcm5hbCkge1xuICAgICAgdGhpcy5faW5pdFZpcnR1YWxFbGVtZW50cygpO1xuICAgIH1cbiAgICB2YXIgdmlydHVhbEVsZW1lbnRzID0gZmxpY2tpbmcuY2FtZXJhLmNoaWxkcmVuO1xuICAgIHRoaXMuX2VsZW1lbnRzID0gdmlydHVhbEVsZW1lbnRzLm1hcChmdW5jdGlvbiAoZWwpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hdGl2ZUVsZW1lbnQ6IGVsLFxuICAgICAgICB2aXNpYmxlOiB0cnVlXG4gICAgICB9O1xuICAgIH0pO1xuICB9O1xuICBfX3Byb3RvLnNob3cgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICB2YXIgZWwgPSB0aGlzLl9lbGVtZW50c1tpbmRleF07XG4gICAgdmFyIG5hdGl2ZUVsID0gZWwubmF0aXZlRWxlbWVudDtcbiAgICBlbC52aXNpYmxlID0gdHJ1ZTtcbiAgICBpZiAobmF0aXZlRWwuc3R5bGUuZGlzcGxheSkge1xuICAgICAgbmF0aXZlRWwuc3R5bGUuZGlzcGxheSA9IFwiXCI7XG4gICAgfVxuICB9O1xuICBfX3Byb3RvLmhpZGUgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICB2YXIgZWwgPSB0aGlzLl9lbGVtZW50c1tpbmRleF07XG4gICAgdmFyIG5hdGl2ZUVsID0gZWwubmF0aXZlRWxlbWVudDtcbiAgICBlbC52aXNpYmxlID0gZmFsc2U7XG4gICAgbmF0aXZlRWwuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICB9O1xuICAvKipcclxuICAgKiBBZGQgbmV3IHZpcnR1YWwgcGFuZWxzIGF0IHRoZSBlbmQgb2YgdGhlIGxpc3RcclxuICAgKiBAa28g7IOI66Gc7Jq0IOqwgOyDgSDtjKjrhJDrk6TsnYQg66as7Iqk7Yq47J2YIOuBneyXkCDstpTqsIDtlanri4jri6RcclxuICAgKiBAcGFyYW0ge251bWJlcn0gY291bnQgVGhlIG51bWJlciBvZiBwYW5lbHMgdG8gYWRkPGtvPuy2lOqwgO2VoCDtjKjrhJDsnZgg6rCc7IiYPC9rbz5cclxuICAgKiBAcmV0dXJucyB7QXJyYXk8VmlydHVhbFBhbmVsPn0gVGhlIG5ldyBwYW5lbHMgYWRkZWQ8a28+7IOI66Gt6rKMIOy2lOqwgOuQnCDtjKjrhJDrk6Q8L2tvPlxyXG4gICAqL1xuICBfX3Byb3RvLmFwcGVuZCA9IGZ1bmN0aW9uIChjb3VudCkge1xuICAgIGlmIChjb3VudCA9PT0gdm9pZCAwKSB7XG4gICAgICBjb3VudCA9IDE7XG4gICAgfVxuICAgIHZhciBmbGlja2luZyA9IHRoaXMuX2ZsaWNraW5nO1xuICAgIHJldHVybiB0aGlzLmluc2VydChmbGlja2luZy5wYW5lbHMubGVuZ3RoLCBjb3VudCk7XG4gIH07XG4gIC8qKlxyXG4gICAqIEFkZCBuZXcgdmlydHVhbCBwYW5lbHMgYXQgdGhlIHN0YXJ0IG9mIHRoZSBsaXN0XHJcbiAgICogQGtvIOyDiOuhnOyatCDqsIDsg4Eg7Yyo64SQ65Ok7J2EIOumrOyKpO2KuOydmCDsi5zsnpHsl5Ag7LaU6rCA7ZWp64uI64ukXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNvdW50IFRoZSBudW1iZXIgb2YgcGFuZWxzIHRvIGFkZDxrbz7stpTqsIDtlaAg7Yyo64SQ7J2YIOqwnOyImDwva28+XHJcbiAgICogQHJldHVybnMge0FycmF5PFZpcnR1YWxQYW5lbD59IFRoZSBuZXcgcGFuZWxzIGFkZGVkPGtvPuyDiOuhreqyjCDstpTqsIDrkJwg7Yyo64SQ65OkPC9rbz5cclxuICAgKi9cbiAgX19wcm90by5wcmVwZW5kID0gZnVuY3Rpb24gKGNvdW50KSB7XG4gICAgaWYgKGNvdW50ID09PSB2b2lkIDApIHtcbiAgICAgIGNvdW50ID0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuaW5zZXJ0KDAsIGNvdW50KTtcbiAgfTtcbiAgLyoqXHJcbiAgICogQWRkIG5ldyB2aXJ0dWFsIHBhbmVscyBhdCB0aGUgZ2l2ZW4gaW5kZXhcclxuICAgKiBAa28g7IOI66Gc7Jq0IOqwgOyDgSDtjKjrhJDrk6TsnYQg7KO87Ja07KeEIOyduOuNseyKpOyXkCDstpTqsIDtlanri4jri6RcclxuICAgKiBAcGFyYW0ge251bWJlcn0gY291bnQgVGhlIG51bWJlciBvZiBwYW5lbHMgdG8gYWRkPGtvPuy2lOqwgO2VoCDtjKjrhJDsnZgg6rCc7IiYPC9rbz5cclxuICAgKiBAcmV0dXJucyB7QXJyYXk8VmlydHVhbFBhbmVsPn0gVGhlIG5ldyBwYW5lbHMgYWRkZWQ8a28+7IOI66Gt6rKMIOy2lOqwgOuQnCDtjKjrhJDrk6Q8L2tvPlxyXG4gICAqL1xuICBfX3Byb3RvLmluc2VydCA9IGZ1bmN0aW9uIChpbmRleCwgY291bnQpIHtcbiAgICBpZiAoY291bnQgPT09IHZvaWQgMCkge1xuICAgICAgY291bnQgPSAxO1xuICAgIH1cbiAgICBpZiAoY291bnQgPD0gMCkgcmV0dXJuIFtdO1xuICAgIHZhciBmbGlja2luZyA9IHRoaXMuX2ZsaWNraW5nO1xuICAgIHJldHVybiBmbGlja2luZy5yZW5kZXJlci5iYXRjaEluc2VydCh7XG4gICAgICBpbmRleDogaW5kZXgsXG4gICAgICBlbGVtZW50czogcmFuZ2UoY291bnQpLFxuICAgICAgaGFzRE9NSW5FbGVtZW50czogZmFsc2VcbiAgICB9KTtcbiAgfTtcbiAgLyoqXHJcbiAgICogUmVtb3ZlIHBhbmVscyBhdCB0aGUgZ2l2ZW4gaW5kZXhcclxuICAgKiBAa28g7KO87Ja07KeEIOyduOuNseyKpOyXkOyEnCDtjKjrhJDrk6TsnYQg7IKt7KCc7ZWp64uI64ukXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNvdW50IFRoZSBudW1iZXIgb2YgcGFuZWxzIHRvIHJlbW92ZTxrbz7sgq3soJztlaAg7Yyo64SQ7J2YIOqwnOyImDwva28+XHJcbiAgICogQHJldHVybnMge0FycmF5PFZpcnR1YWxQYW5lbD59IFRoZSBwYW5lbHMgcmVtb3ZlZDxrbz7sgq3soJzrkJwg7Yyo64SQ65OkPC9rbz5cclxuICAgKi9cbiAgX19wcm90by5yZW1vdmUgPSBmdW5jdGlvbiAoaW5kZXgsIGNvdW50KSB7XG4gICAgaWYgKGNvdW50IDw9IDApIHJldHVybiBbXTtcbiAgICB2YXIgZmxpY2tpbmcgPSB0aGlzLl9mbGlja2luZztcbiAgICByZXR1cm4gZmxpY2tpbmcucmVuZGVyZXIuYmF0Y2hSZW1vdmUoe1xuICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgZGVsZXRlQ291bnQ6IGNvdW50LFxuICAgICAgaGFzRE9NSW5FbGVtZW50czogZmFsc2VcbiAgICB9KTtcbiAgfTtcbiAgX19wcm90by5faW5pdFZpcnR1YWxFbGVtZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHZhciBmbGlja2luZyA9IHRoaXMuX2ZsaWNraW5nO1xuICAgIHZhciBjYW1lcmFFbGVtZW50ID0gZmxpY2tpbmcuY2FtZXJhLmVsZW1lbnQ7XG4gICAgdmFyIHBhbmVsc1BlclZpZXcgPSBmbGlja2luZy5wYW5lbHNQZXJWaWV3O1xuICAgIHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICB2YXIgbmV3RWxlbWVudHMgPSByYW5nZShwYW5lbHNQZXJWaWV3ICsgMSkubWFwKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgIHZhciBwYW5lbEVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIHBhbmVsRWwuY2xhc3NOYW1lID0gX3RoaXMuX3BhbmVsQ2xhc3M7XG4gICAgICBwYW5lbEVsLmRhdGFzZXQuZWxlbWVudEluZGV4ID0gaWR4LnRvU3RyaW5nKCk7XG4gICAgICByZXR1cm4gcGFuZWxFbDtcbiAgICB9KTtcbiAgICBuZXdFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoZWwpO1xuICAgIH0pO1xuICAgIGNhbWVyYUVsZW1lbnQuYXBwZW5kQ2hpbGQoZnJhZ21lbnQpO1xuICB9O1xuICByZXR1cm4gVmlydHVhbE1hbmFnZXI7XG59KCk7XG5cbi8qKlxyXG4gKiBBbGwgcG9zc2libGUgQGVnanMvYXhlcyBldmVudCBrZXlzXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cbnZhciBFVkVOVCA9IHtcbiAgSE9MRDogXCJob2xkXCIsXG4gIENIQU5HRTogXCJjaGFuZ2VcIixcbiAgUkVMRUFTRTogXCJyZWxlYXNlXCIsXG4gIEFOSU1BVElPTl9FTkQ6IFwiYW5pbWF0aW9uRW5kXCIsXG4gIEZJTklTSDogXCJmaW5pc2hcIlxufTtcbi8qKlxyXG4gKiBBbiBBeGlzIGtleSB0aGF0IEZsaWNraW5nIHVzZXNcclxuICogQGludGVybmFsXHJcbiAqL1xudmFyIFBPU0lUSU9OX0tFWSA9IFwiZmxpY2tcIjtcblxudmFyIFNUQVRFX1RZUEU7XG4oZnVuY3Rpb24gKFNUQVRFX1RZUEUpIHtcbiAgU1RBVEVfVFlQRVtTVEFURV9UWVBFW1wiSURMRVwiXSA9IDBdID0gXCJJRExFXCI7XG4gIFNUQVRFX1RZUEVbU1RBVEVfVFlQRVtcIkhPTERJTkdcIl0gPSAxXSA9IFwiSE9MRElOR1wiO1xuICBTVEFURV9UWVBFW1NUQVRFX1RZUEVbXCJEUkFHR0lOR1wiXSA9IDJdID0gXCJEUkFHR0lOR1wiO1xuICBTVEFURV9UWVBFW1NUQVRFX1RZUEVbXCJBTklNQVRJTkdcIl0gPSAzXSA9IFwiQU5JTUFUSU5HXCI7XG4gIFNUQVRFX1RZUEVbU1RBVEVfVFlQRVtcIkRJU0FCTEVEXCJdID0gNF0gPSBcIkRJU0FCTEVEXCI7XG59KShTVEFURV9UWVBFIHx8IChTVEFURV9UWVBFID0ge30pKTtcbi8qKlxyXG4gKiBBIGNvbXBvbmVudCB0aGF0IHNob3dzIHRoZSBjdXJyZW50IHN0YXR1cyBvZiB0aGUgdXNlciBpbnB1dCBvciB0aGUgYW5pbWF0aW9uXHJcbiAqIEBrbyDtmITsnqwg7IKs7Jqp7J6QIOyeheugpSDrmJDripQg7JWg64uI66mU7J207IWYIOyDge2DnOulvCDrgpjtg4DrgrTripQg7Lu07Y+s64SM7Yq4XHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cbnZhciBTdGF0ZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFN0YXRlKCkge1xuICAgIHRoaXMuX2RlbHRhID0gMDtcbiAgICB0aGlzLl90YXJnZXRQYW5lbCA9IG51bGw7XG4gIH1cbiAgdmFyIF9fcHJvdG8gPSBTdGF0ZS5wcm90b3R5cGU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcImRlbHRhXCIsIHtcbiAgICAvKipcclxuICAgICAqIEEgc3VtIG9mIGRlbHRhIHZhbHVlcyBvZiBjaGFuZ2UgZXZlbnRzIGZyb20gdGhlIGxhc3QgaG9sZCBldmVudCBvZiBBeGVzXHJcbiAgICAgKiBAa28g7J207KCEIGhvbGTsnbTrsqTtirjrtoDthLAgY2hhbmdl7JeQIOydmO2VtCDrsJzsg53tlZwg7J2064+ZIGRlbHRh6rCS7J2YIO2VqeyCsFxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGVsdGE7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcInRhcmdldFBhbmVsXCIsIHtcbiAgICAvKipcclxuICAgICAqIEEgcGFuZWwgdG8gc2V0IGFzIHtAbGluayBDb250cm9sI2FjdGl2ZVBhbmVsfSBhZnRlciB0aGUgYW5pbWF0aW9uIGlzIGZpbmlzaGVkXHJcbiAgICAgKiBAa28g7JWg64uI66mU7J207IWYIOyiheujjOyLnCB7QGxpbmsgQ29udHJvbCNhY3RpdmVQYW5lbH3roZwg7ISk7KCV7ZWgIO2MqOuEkFxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdGFyZ2V0UGFuZWw7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHRoaXMuX3RhcmdldFBhbmVsID0gdmFsO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICAvKipcclxuICAgKiBBbiBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiBzdGF0ZSBoYXMgY2hhbmdlZCB0byB0aGlzIHN0YXRlXHJcbiAgICogQGtvIO2YhOyerCDsg4Htg5zroZwg64+M7J6F7ZaI7J2E65WMIO2YuOy2nOuQmOuKlCDsvZzrsLEg7ZWo7IiYXHJcbiAgICogQHBhcmFtIHtTdGF0ZX0gcHJldlN0YXRlIEFuIHByZXZpb3VzIHN0YXRlPGtvPuydtOyghCDsg4Htg5zqsJI8L2tvPlxyXG4gICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICovXG4gIF9fcHJvdG8ub25FbnRlciA9IGZ1bmN0aW9uIChwcmV2U3RhdGUpIHtcbiAgICB0aGlzLl9kZWx0YSA9IHByZXZTdGF0ZS5fZGVsdGE7XG4gICAgdGhpcy5fdGFyZ2V0UGFuZWwgPSBwcmV2U3RhdGUuX3RhcmdldFBhbmVsO1xuICB9O1xuICAvKipcclxuICAgKiBBbiBldmVudCBoYW5kbGVyIGZvciBBeGVzJ3Mge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtYXhlcy9yZWxlYXNlL2xhdGVzdC9kb2MvZWcuQXhlcy5odG1sI2V2ZW50OmhvbGQgaG9sZH0gZXZlbnRcclxuICAgKiBAa28gQXhlc+ydmCB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1heGVzL3JlbGVhc2UvbGF0ZXN0L2RvYy9lZy5BeGVzLmh0bWwjZXZlbnQ6aG9sZCBob2xkfSDsnbTrsqTtirgg7ZW465Ok65+sXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IFtjdHhdIEV2ZW50IGNvbnRleHQ8a28+7J2067Kk7Yq4IOy9mO2FjeyKpO2KuDwva28+XHJcbiAgICogQHBhcmFtIHtGbGlja2luZ30gW2N0eC5mbGlja2luZ10gQW4gaW5zdGFuY2Ugb2YgRmxpY2tpbmc8a28+RmxpY2tpbmcg7J247Iqk7YS07IqkPC9rbz5cclxuICAgKiBAcGFyYW0ge29iamVjdH0gW2N0eC5heGVzRXZlbnRdIEEge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtYXhlcy9yZWxlYXNlL2xhdGVzdC9kb2MvZWcuQXhlcy5odG1sI2V2ZW50OmhvbGQgaG9sZH0gZXZlbnQgb2YgQXhlc1xyXG4gICAqIDxrbz5BeGVz7J2YIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWF4ZXMvcmVsZWFzZS9sYXRlc3QvZG9jL2VnLkF4ZXMuaHRtbCNldmVudDpob2xkIGhvbGR9IOydtOuypO2KuDwva28+XHJcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2N0eC50cmFuc2l0VG9dIEEgZnVuY3Rpb24gZm9yIGNoYW5naW5nIGN1cnJlbnQgc3RhdGUgdG8gb3RoZXIgc3RhdGU8a28+64uk66W4IOyDge2DnOuhnCDrs4Dqsr3tlZjquLAg7JyE7ZWcIO2VqOyImDwva28+XHJcbiAgICogQHJldHVybiB7dm9pZH1cclxuICAgKi9cbiAgX19wcm90by5vbkhvbGQgPSBmdW5jdGlvbiAoY3R4KSB7XG4gICAgLy8gRE8gTk9USElOR1xuICB9O1xuICAvKipcclxuICAgKiBBbiBldmVudCBoYW5kbGVyIGZvciBBeGVzJ3Mge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtYXhlcy9yZWxlYXNlL2xhdGVzdC9kb2MvZWcuQXhlcy5odG1sI2V2ZW50OmNoYW5nZSBjaGFuZ2V9IGV2ZW50XHJcbiAgICogQGtvIEF4ZXPsnZgge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtYXhlcy9yZWxlYXNlL2xhdGVzdC9kb2MvZWcuQXhlcy5odG1sI2V2ZW50OmNoYW5nZSBjaGFuZ2V9IOydtOuypO2KuCDtlbjrk6Trn6xcclxuICAgKiBAcGFyYW0ge29iamVjdH0gW2N0eF0gRXZlbnQgY29udGV4dDxrbz7snbTrsqTtirgg7L2Y7YWN7Iqk7Yq4PC9rbz5cclxuICAgKiBAcGFyYW0ge0ZsaWNraW5nfSBbY3R4LmZsaWNraW5nXSBBbiBpbnN0YW5jZSBvZiBGbGlja2luZzxrbz5GbGlja2luZyDsnbjsiqTthLTsiqQ8L2tvPlxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbY3R4LmF4ZXNFdmVudF0gQSB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1heGVzL3JlbGVhc2UvbGF0ZXN0L2RvYy9lZy5BeGVzLmh0bWwjZXZlbnQ6Y2hhbmdlIGNoYW5nZX0gZXZlbnQgb2YgQXhlc1xyXG4gICAqIDxrbz5BeGVz7J2YIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWF4ZXMvcmVsZWFzZS9sYXRlc3QvZG9jL2VnLkF4ZXMuaHRtbCNldmVudDpjaGFuZ2UgY2hhbmdlfSDsnbTrsqTtirg8L2tvPlxyXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjdHgudHJhbnNpdFRvXSBBIGZ1bmN0aW9uIGZvciBjaGFuZ2luZyBjdXJyZW50IHN0YXRlIHRvIG90aGVyIHN0YXRlPGtvPuuLpOuluCDsg4Htg5zroZwg67OA6rK97ZWY6riwIOychO2VnCDtlajsiJg8L2tvPlxyXG4gICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICovXG4gIF9fcHJvdG8ub25DaGFuZ2UgPSBmdW5jdGlvbiAoY3R4KSB7XG4gICAgLy8gRE8gTk9USElOR1xuICB9O1xuICAvKipcclxuICAgKiBBbiBldmVudCBoYW5kbGVyIGZvciBBeGVzJ3Mge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtYXhlcy9yZWxlYXNlL2xhdGVzdC9kb2MvZWcuQXhlcy5odG1sI2V2ZW50OnJlbGVhc2UgcmVsZWFzZX0gZXZlbnRcclxuICAgKiBAa28gQXhlc+ydmCB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1heGVzL3JlbGVhc2UvbGF0ZXN0L2RvYy9lZy5BeGVzLmh0bWwjZXZlbnQ6cmVsZWFzZSByZWxlYXNlfSDsnbTrsqTtirgg7ZW465Ok65+sXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IFtjdHhdIEV2ZW50IGNvbnRleHQ8a28+7J2067Kk7Yq4IOy9mO2FjeyKpO2KuDwva28+XHJcbiAgICogQHBhcmFtIHtGbGlja2luZ30gW2N0eC5mbGlja2luZ10gQW4gaW5zdGFuY2Ugb2YgRmxpY2tpbmc8a28+RmxpY2tpbmcg7J247Iqk7YS07IqkPC9rbz5cclxuICAgKiBAcGFyYW0ge29iamVjdH0gW2N0eC5heGVzRXZlbnRdIEEge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtYXhlcy9yZWxlYXNlL2xhdGVzdC9kb2MvZWcuQXhlcy5odG1sI2V2ZW50OnJlbGVhc2UgcmVsZWFzZX0gZXZlbnQgb2YgQXhlc1xyXG4gICAqIDxrbz5BeGVz7J2YIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWF4ZXMvcmVsZWFzZS9sYXRlc3QvZG9jL2VnLkF4ZXMuaHRtbCNldmVudDpyZWxlYXNlIHJlbGVhc2V9IOydtOuypO2KuDwva28+XHJcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2N0eC50cmFuc2l0VG9dIEEgZnVuY3Rpb24gZm9yIGNoYW5naW5nIGN1cnJlbnQgc3RhdGUgdG8gb3RoZXIgc3RhdGU8a28+64uk66W4IOyDge2DnOuhnCDrs4Dqsr3tlZjquLAg7JyE7ZWcIO2VqOyImDwva28+XHJcbiAgICogQHJldHVybiB7dm9pZH1cclxuICAgKi9cbiAgX19wcm90by5vblJlbGVhc2UgPSBmdW5jdGlvbiAoY3R4KSB7XG4gICAgLy8gRE8gTk9USElOR1xuICB9O1xuICAvKipcclxuICAgKiBBbiBldmVudCBoYW5kbGVyIGZvciBBeGVzJ3Mge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtYXhlcy9yZWxlYXNlL2xhdGVzdC9kb2MvZWcuQXhlcy5odG1sI2V2ZW50OmFuaW1hdGlvbkVuZCBhbmltYXRpb25FbmR9IGV2ZW50XHJcbiAgICogQGtvIEF4ZXPsnZgge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtYXhlcy9yZWxlYXNlL2xhdGVzdC9kb2MvZWcuQXhlcy5odG1sI2V2ZW50OmFuaW1hdGlvbkVuZCBhbmltYXRpb25FbmR9IOydtOuypO2KuCDtlbjrk6Trn6xcclxuICAgKiBAcGFyYW0ge29iamVjdH0gW2N0eF0gRXZlbnQgY29udGV4dDxrbz7snbTrsqTtirgg7L2Y7YWN7Iqk7Yq4PC9rbz5cclxuICAgKiBAcGFyYW0ge0ZsaWNraW5nfSBbY3R4LmZsaWNraW5nXSBBbiBpbnN0YW5jZSBvZiBGbGlja2luZzxrbz5GbGlja2luZyDsnbjsiqTthLTsiqQ8L2tvPlxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbY3R4LmF4ZXNFdmVudF0gQSB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1heGVzL3JlbGVhc2UvbGF0ZXN0L2RvYy9lZy5BeGVzLmh0bWwjZXZlbnQ6YW5pbWF0aW9uRW5kIGFuaW1hdGlvbkVuZH0gZXZlbnQgb2YgQXhlc1xyXG4gICAqIDxrbz5BeGVz7J2YIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWF4ZXMvcmVsZWFzZS9sYXRlc3QvZG9jL2VnLkF4ZXMuaHRtbCNldmVudDphbmltYXRpb25FbmQgYW5pbWF0aW9uRW5kfSDsnbTrsqTtirg8L2tvPlxyXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjdHgudHJhbnNpdFRvXSBBIGZ1bmN0aW9uIGZvciBjaGFuZ2luZyBjdXJyZW50IHN0YXRlIHRvIG90aGVyIHN0YXRlPGtvPuuLpOuluCDsg4Htg5zroZwg67OA6rK97ZWY6riwIOychO2VnCDtlajsiJg8L2tvPlxyXG4gICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICovXG4gIF9fcHJvdG8ub25BbmltYXRpb25FbmQgPSBmdW5jdGlvbiAoY3R4KSB7XG4gICAgLy8gRE8gTk9USElOR1xuICB9O1xuICAvKipcclxuICAgKiBBbiBldmVudCBoYW5kbGVyIGZvciBBeGVzJ3Mge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtYXhlcy9yZWxlYXNlL2xhdGVzdC9kb2MvZWcuQXhlcy5odG1sI2V2ZW50OmZpbmlzaCBmaW5pc2h9IGV2ZW50XHJcbiAgICogQGtvIEF4ZXPsnZgge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtYXhlcy9yZWxlYXNlL2xhdGVzdC9kb2MvZWcuQXhlcy5odG1sI2V2ZW50OmZpbmlzaCBmaW5pc2h9IOydtOuypO2KuCDtlbjrk6Trn6xcclxuICAgKiBAcGFyYW0ge29iamVjdH0gW2N0eF0gRXZlbnQgY29udGV4dDxrbz7snbTrsqTtirgg7L2Y7YWN7Iqk7Yq4PC9rbz5cclxuICAgKiBAcGFyYW0ge0ZsaWNraW5nfSBbY3R4LmZsaWNraW5nXSBBbiBpbnN0YW5jZSBvZiBGbGlja2luZzxrbz5GbGlja2luZyDsnbjsiqTthLTsiqQ8L2tvPlxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbY3R4LmF4ZXNFdmVudF0gQSB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1heGVzL3JlbGVhc2UvbGF0ZXN0L2RvYy9lZy5BeGVzLmh0bWwjZXZlbnQ6ZmluaXNoIGZpbmlzaH0gZXZlbnQgb2YgQXhlczxrbz5BeGVz7J2YIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWF4ZXMvcmVsZWFzZS9sYXRlc3QvZG9jL2VnLkF4ZXMuaHRtbCNldmVudDpmaW5pc2ggZmluaXNofSDsnbTrsqTtirg8L2tvPlxyXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjdHgudHJhbnNpdFRvXSBBIGZ1bmN0aW9uIGZvciBjaGFuZ2luZyBjdXJyZW50IHN0YXRlIHRvIG90aGVyIHN0YXRlPGtvPuuLpOuluCDsg4Htg5zroZwg67OA6rK97ZWY6riwIOychO2VnCDtlajsiJg8L2tvPlxyXG4gICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICovXG4gIF9fcHJvdG8ub25GaW5pc2ggPSBmdW5jdGlvbiAoY3R4KSB7XG4gICAgLy8gRE8gTk9USElOR1xuICB9O1xuICBfX3Byb3RvLl9tb3ZlVG9DaGFuZ2VkUG9zaXRpb24gPSBmdW5jdGlvbiAoY3R4KSB7XG4gICAgdmFyIGZsaWNraW5nID0gY3R4LmZsaWNraW5nLFxuICAgICAgYXhlc0V2ZW50ID0gY3R4LmF4ZXNFdmVudCxcbiAgICAgIHRyYW5zaXRUbyA9IGN0eC50cmFuc2l0VG87XG4gICAgdmFyIGRlbHRhID0gYXhlc0V2ZW50LmRlbHRhW1BPU0lUSU9OX0tFWV07XG4gICAgaWYgKCFkZWx0YSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9kZWx0YSArPSBkZWx0YTtcbiAgICB2YXIgY2FtZXJhID0gZmxpY2tpbmcuY2FtZXJhO1xuICAgIHZhciBwcmV2UG9zaXRpb24gPSBjYW1lcmEucG9zaXRpb247XG4gICAgdmFyIHBvc2l0aW9uID0gYXhlc0V2ZW50LnBvc1tQT1NJVElPTl9LRVldO1xuICAgIHZhciBuZXdQb3NpdGlvbiA9IGZsaWNraW5nLmNpcmN1bGFyRW5hYmxlZCA/IGNpcmN1bGF0ZVBvc2l0aW9uKHBvc2l0aW9uLCBjYW1lcmEucmFuZ2UubWluLCBjYW1lcmEucmFuZ2UubWF4KSA6IHBvc2l0aW9uO1xuICAgIGNhbWVyYS5sb29rQXQobmV3UG9zaXRpb24pO1xuICAgIHZhciBtb3ZlRXZlbnQgPSBuZXcgQ29tcG9uZW50RXZlbnQkMShFVkVOVFMuTU9WRSwge1xuICAgICAgaXNUcnVzdGVkOiBheGVzRXZlbnQuaXNUcnVzdGVkLFxuICAgICAgaG9sZGluZzogdGhpcy5ob2xkaW5nLFxuICAgICAgZGlyZWN0aW9uOiBnZXREaXJlY3Rpb24kMSgwLCBheGVzRXZlbnQuZGVsdGFbUE9TSVRJT05fS0VZXSksXG4gICAgICBheGVzRXZlbnQ6IGF4ZXNFdmVudFxuICAgIH0pO1xuICAgIGZsaWNraW5nLnRyaWdnZXIobW92ZUV2ZW50KTtcbiAgICBpZiAobW92ZUV2ZW50LmlzQ2FuY2VsZWQoKSkge1xuICAgICAgLy8gUmV0dXJuIHRvIHByZXZpb3VzIHBvc2l0aW9uXG4gICAgICBjYW1lcmEubG9va0F0KHByZXZQb3NpdGlvbik7XG4gICAgICB0cmFuc2l0VG8oU1RBVEVfVFlQRS5ESVNBQkxFRCk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gU3RhdGU7XG59KCk7XG5cbi8qKlxyXG4gKiBBIGRlZmF1bHQgc3RhdGUgd2hlbiB0aGVyZSdzIG5vIHVzZXIgaW5wdXQgYW5kIG5vIGFuaW1hdGlvbidzIHBsYXlpbmdcclxuICogQGtvIOyCrOyaqeyekOydmCDsnoXroKXsnbQg7JeG6rOgLCDslaDri4jrqZTsnbTshZjsnbQg64+Z7J6R7ZWY6rOg7J6I7KeAIOyViuydgCDquLDrs7gg7IOB7YOcXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cbnZhciBJZGxlU3RhdGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMkMyhJZGxlU3RhdGUsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIElkbGVTdGF0ZSgpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgdXNlciBpcyBjbGlja2luZyBvciB0b3VjaGluZ1xyXG4gICAgICogQGtvIO2YhOyerCDsgqzsmqnsnpDqsIAg7YG066atL+2EsOy5mOykkeyduOyngCDsl6zrtoBcclxuICAgICAqIEB0eXBlIHtmYWxzZX1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgX3RoaXMuaG9sZGluZyA9IGZhbHNlO1xuICAgIC8qKlxyXG4gICAgICogV2hldGhlciBGbGlja2luZydzIGFuaW1hdGluZ1xyXG4gICAgICogQGtvIO2YhOyerCDslaDri4jrqZTsnbTshZgg64+Z7J6RIOyXrOu2gFxyXG4gICAgICogQHR5cGUge2ZhbHNlfVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBfdGhpcy5hbmltYXRpbmcgPSBmYWxzZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgdmFyIF9fcHJvdG8gPSBJZGxlU3RhdGUucHJvdG90eXBlO1xuICBfX3Byb3RvLm9uRW50ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fZGVsdGEgPSAwO1xuICAgIHRoaXMuX3RhcmdldFBhbmVsID0gbnVsbDtcbiAgfTtcbiAgX19wcm90by5vbkhvbGQgPSBmdW5jdGlvbiAoY3R4KSB7XG4gICAgLy8gU2hvdWxkbid0IGRvIGFueSBhY3Rpb24gdW50aWwgYW55IHBhbmVscyBvbiBmbGlja2luZyBhcmVhXG4gICAgdmFyIGZsaWNraW5nID0gY3R4LmZsaWNraW5nLFxuICAgICAgYXhlc0V2ZW50ID0gY3R4LmF4ZXNFdmVudCxcbiAgICAgIHRyYW5zaXRUbyA9IGN0eC50cmFuc2l0VG87XG4gICAgaWYgKGZsaWNraW5nLnJlbmRlcmVyLnBhbmVsQ291bnQgPD0gMCkge1xuICAgICAgdHJhbnNpdFRvKFNUQVRFX1RZUEUuRElTQUJMRUQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgaG9sZFN0YXJ0RXZlbnQgPSBuZXcgQ29tcG9uZW50RXZlbnQkMShFVkVOVFMuSE9MRF9TVEFSVCwge1xuICAgICAgYXhlc0V2ZW50OiBheGVzRXZlbnRcbiAgICB9KTtcbiAgICBmbGlja2luZy50cmlnZ2VyKGhvbGRTdGFydEV2ZW50KTtcbiAgICBpZiAoaG9sZFN0YXJ0RXZlbnQuaXNDYW5jZWxlZCgpKSB7XG4gICAgICB0cmFuc2l0VG8oU1RBVEVfVFlQRS5ESVNBQkxFRCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyYW5zaXRUbyhTVEFURV9UWVBFLkhPTERJTkcpO1xuICAgIH1cbiAgfTtcbiAgLy8gQnkgbWV0aG9kcyBjYWxsXG4gIF9fcHJvdG8ub25DaGFuZ2UgPSBmdW5jdGlvbiAoY3R4KSB7XG4gICAgdmFyIGZsaWNraW5nID0gY3R4LmZsaWNraW5nLFxuICAgICAgYXhlc0V2ZW50ID0gY3R4LmF4ZXNFdmVudCxcbiAgICAgIHRyYW5zaXRUbyA9IGN0eC50cmFuc2l0VG87XG4gICAgdmFyIGNvbnRyb2xsZXIgPSBmbGlja2luZy5jb250cm9sLmNvbnRyb2xsZXI7XG4gICAgdmFyIGFuaW1hdGluZ0NvbnRleHQgPSBjb250cm9sbGVyLmFuaW1hdGluZ0NvbnRleHQ7XG4gICAgdmFyIG1vdmVTdGFydEV2ZW50ID0gbmV3IENvbXBvbmVudEV2ZW50JDEoRVZFTlRTLk1PVkVfU1RBUlQsIHtcbiAgICAgIGlzVHJ1c3RlZDogYXhlc0V2ZW50LmlzVHJ1c3RlZCxcbiAgICAgIGhvbGRpbmc6IHRoaXMuaG9sZGluZyxcbiAgICAgIGRpcmVjdGlvbjogZ2V0RGlyZWN0aW9uJDEoYW5pbWF0aW5nQ29udGV4dC5zdGFydCwgYW5pbWF0aW5nQ29udGV4dC5lbmQpLFxuICAgICAgYXhlc0V2ZW50OiBheGVzRXZlbnRcbiAgICB9KTtcbiAgICBmbGlja2luZy50cmlnZ2VyKG1vdmVTdGFydEV2ZW50KTtcbiAgICBpZiAobW92ZVN0YXJ0RXZlbnQuaXNDYW5jZWxlZCgpKSB7XG4gICAgICB0cmFuc2l0VG8oU1RBVEVfVFlQRS5ESVNBQkxFRCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRyaWdnZXIgQW5pbWF0aW5nU3RhdGUncyBvbkNoYW5nZSwgdG8gdHJpZ2dlciBcIm1vdmVcIiBldmVudCBpbW1lZGlhdGVseVxuICAgICAgdHJhbnNpdFRvKFNUQVRFX1RZUEUuQU5JTUFUSU5HKS5vbkNoYW5nZShjdHgpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIElkbGVTdGF0ZTtcbn0oU3RhdGUpO1xuXG4vKipcclxuICogQSBzdGF0ZSB0aGF0IGFjdGl2YXRlcyB3aGVuIHVzZXIncyBob2xkaW5nIHRoZSBGbGlja2luZyBhcmVhLCBidXQgbm90IG1vdmVkIGEgc2luZ2xlIHBpeGVsIHlldFxyXG4gKiBAa28g7IKs7Jqp7J6Q7J2YIOyeheugpeydtCDsi5zsnpHrkJjsl4jsnLzrgpgsIOyVhOyngSDsm4Dsp4HsnbTsp4DripQg7JWK7J2AIOyDge2DnFxyXG4gKiBAaW50ZXJuYWxcclxuICovXG52YXIgSG9sZGluZ1N0YXRlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzJDMoSG9sZGluZ1N0YXRlLCBfc3VwZXIpO1xuICBmdW5jdGlvbiBIb2xkaW5nU3RhdGUoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHVzZXIgaXMgY2xpY2tpbmcgb3IgdG91Y2hpbmdcclxuICAgICAqIEBrbyDtmITsnqwg7IKs7Jqp7J6Q6rCAIO2BtOumrS/thLDsuZjspJHsnbjsp4Ag7Jes67aAXHJcbiAgICAgKiBAdHlwZSB7dHJ1ZX1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgX3RoaXMuaG9sZGluZyA9IHRydWU7XG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIEZsaWNraW5nJ3MgYW5pbWF0aW5nXHJcbiAgICAgKiBAa28g7ZiE7J6sIOyVoOuLiOuplOydtOyFmCDrj5nsnpEg7Jes67aAXHJcbiAgICAgKiBAdHlwZSB7ZmFsc2V9XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIF90aGlzLmFuaW1hdGluZyA9IGZhbHNlO1xuICAgIF90aGlzLl9yZWxlYXNlRXZlbnQgPSBudWxsO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICB2YXIgX19wcm90byA9IEhvbGRpbmdTdGF0ZS5wcm90b3R5cGU7XG4gIF9fcHJvdG8ub25DaGFuZ2UgPSBmdW5jdGlvbiAoY3R4KSB7XG4gICAgdmFyIGZsaWNraW5nID0gY3R4LmZsaWNraW5nLFxuICAgICAgYXhlc0V2ZW50ID0gY3R4LmF4ZXNFdmVudCxcbiAgICAgIHRyYW5zaXRUbyA9IGN0eC50cmFuc2l0VG87XG4gICAgdmFyIGlucHV0RXZlbnQgPSBheGVzRXZlbnQuaW5wdXRFdmVudDtcbiAgICB2YXIgb2Zmc2V0ID0gZmxpY2tpbmcuaG9yaXpvbnRhbCA/IGlucHV0RXZlbnQub2Zmc2V0WCA6IGlucHV0RXZlbnQub2Zmc2V0WTtcbiAgICB2YXIgbW92ZVN0YXJ0RXZlbnQgPSBuZXcgQ29tcG9uZW50RXZlbnQkMShFVkVOVFMuTU9WRV9TVEFSVCwge1xuICAgICAgaXNUcnVzdGVkOiBheGVzRXZlbnQuaXNUcnVzdGVkLFxuICAgICAgaG9sZGluZzogdGhpcy5ob2xkaW5nLFxuICAgICAgZGlyZWN0aW9uOiBnZXREaXJlY3Rpb24kMSgwLCAtb2Zmc2V0KSxcbiAgICAgIGF4ZXNFdmVudDogYXhlc0V2ZW50XG4gICAgfSk7XG4gICAgZmxpY2tpbmcudHJpZ2dlcihtb3ZlU3RhcnRFdmVudCk7XG4gICAgaWYgKG1vdmVTdGFydEV2ZW50LmlzQ2FuY2VsZWQoKSkge1xuICAgICAgdHJhbnNpdFRvKFNUQVRFX1RZUEUuRElTQUJMRUQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUcmlnZ2VyIERyYWdnaW5nU3RhdGUncyBvbkNoYW5nZSwgdG8gdHJpZ2dlciBcIm1vdmVcIiBldmVudCBpbW1lZGlhdGVseVxuICAgICAgdHJhbnNpdFRvKFNUQVRFX1RZUEUuRFJBR0dJTkcpLm9uQ2hhbmdlKGN0eCk7XG4gICAgfVxuICB9O1xuICBfX3Byb3RvLm9uUmVsZWFzZSA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICB2YXIgZmxpY2tpbmcgPSBjdHguZmxpY2tpbmcsXG4gICAgICBheGVzRXZlbnQgPSBjdHguYXhlc0V2ZW50LFxuICAgICAgdHJhbnNpdFRvID0gY3R4LnRyYW5zaXRUbztcbiAgICBmbGlja2luZy50cmlnZ2VyKG5ldyBDb21wb25lbnRFdmVudCQxKEVWRU5UUy5IT0xEX0VORCwge1xuICAgICAgYXhlc0V2ZW50OiBheGVzRXZlbnRcbiAgICB9KSk7XG4gICAgaWYgKGF4ZXNFdmVudC5kZWx0YS5mbGljayAhPT0gMCkge1xuICAgICAgLy8gU29tZXRpbWVzIFwicmVsZWFzZVwiIGV2ZW50IG9uIGF4ZXMgdHJpZ2dlcmVkIGJlZm9yZSBcImNoYW5nZVwiIGV2ZW50XG4gICAgICAvLyBFc3BlY2lhbGx5IGlmIHVzZXIgZmxpY2tlZCBwYW5lbCBmYXN0IGluIHJlYWxseSBzaG9ydCBhbW91bnQgb2YgdGltZVxuICAgICAgLy8gaWYgZGVsdGEgaXMgbm90IHplcm8sIHRoYXQgbWVhbnMgYWJvdmUgY2FzZSBoYXBwZW5lZC5cbiAgICAgIC8vIEV2ZW50IGZsb3cgc2hvdWxkIGJlIEhPTERfU1RBUlQgLT4gTU9WRV9TVEFSVCAtPiBNT1ZFIC0+IEhPTERfRU5EXG4gICAgICAvLyBBdCBsZWFzdCBvbmUgbW92ZSBldmVudCBzaG91bGQgYmUgaW5jbHVkZWQgYmV0d2VlbiBob2xkU3RhcnQgYW5kIGhvbGRFbmRcbiAgICAgIGF4ZXNFdmVudC5zZXRUbyh7XG4gICAgICAgIGZsaWNrOiBmbGlja2luZy5jYW1lcmEucG9zaXRpb25cbiAgICAgIH0sIDApO1xuICAgICAgdHJhbnNpdFRvKFNUQVRFX1RZUEUuSURMRSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIENhbid0IGhhbmRsZSBzZWxlY3QgZXZlbnQgaGVyZSxcbiAgICAvLyBBcyBcImZpbmlzaFwiIGF4ZXMgZXZlbnQgaGFwcGVuc1xuICAgIHRoaXMuX3JlbGVhc2VFdmVudCA9IGF4ZXNFdmVudDtcbiAgfTtcbiAgX19wcm90by5vbkZpbmlzaCA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICB2YXIgZV8xLCBfYTtcbiAgICB2YXIgZmxpY2tpbmcgPSBjdHguZmxpY2tpbmcsXG4gICAgICB0cmFuc2l0VG8gPSBjdHgudHJhbnNpdFRvO1xuICAgIC8vIFNob3VsZCB0cmFuc2l0ZSB0byBJRExFIHN0YXRlIGJlZm9yZSBzZWxlY3QgZXZlbnRcbiAgICAvLyBBcyB1c2VyIGV4cGVjdHMgaG9sZCBpcyBhbHJlYWR5IGZpbmlzaGVkXG4gICAgdHJhbnNpdFRvKFNUQVRFX1RZUEUuSURMRSk7XG4gICAgaWYgKCF0aGlzLl9yZWxlYXNlRXZlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gSGFuZGxlIHJlbGVhc2UgZXZlbnQgaGVyZVxuICAgIC8vIFRvIHByZXZlbnQgZmluaXNoIGV2ZW50IGNhbGxlZCB0d2ljZVxuICAgIHZhciByZWxlYXNlRXZlbnQgPSB0aGlzLl9yZWxlYXNlRXZlbnQ7XG4gICAgLy8gU3RhdGljIGNsaWNrXG4gICAgLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50LCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3MgKi9cbiAgICB2YXIgc3JjRXZlbnQgPSByZWxlYXNlRXZlbnQuaW5wdXRFdmVudC5zcmNFdmVudDtcbiAgICB2YXIgY2xpY2tlZEVsZW1lbnQ7XG4gICAgaWYgKHNyY0V2ZW50LnR5cGUgPT09IFwidG91Y2hlbmRcIikge1xuICAgICAgdmFyIHRvdWNoRXZlbnQgPSBzcmNFdmVudDtcbiAgICAgIHZhciB0b3VjaCA9IHRvdWNoRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgICBjbGlja2VkRWxlbWVudCA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQodG91Y2guY2xpZW50WCwgdG91Y2guY2xpZW50WSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNsaWNrZWRFbGVtZW50ID0gc3JjRXZlbnQudGFyZ2V0O1xuICAgIH1cbiAgICAvKiBlc2xpbnQtZW5hYmxlICovXG4gICAgdmFyIHBhbmVscyA9IGZsaWNraW5nLnJlbmRlcmVyLnBhbmVscztcbiAgICB2YXIgY2xpY2tlZFBhbmVsID0gbnVsbDtcbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgcGFuZWxzXzEgPSBfX3ZhbHVlcyQxKHBhbmVscyksIHBhbmVsc18xXzEgPSBwYW5lbHNfMS5uZXh0KCk7ICFwYW5lbHNfMV8xLmRvbmU7IHBhbmVsc18xXzEgPSBwYW5lbHNfMS5uZXh0KCkpIHtcbiAgICAgICAgdmFyIHBhbmVsID0gcGFuZWxzXzFfMS52YWx1ZTtcbiAgICAgICAgaWYgKHBhbmVsLmNvbnRhaW5zKGNsaWNrZWRFbGVtZW50KSkge1xuICAgICAgICAgIGNsaWNrZWRQYW5lbCA9IHBhbmVsO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZV8xXzEpIHtcbiAgICAgIGVfMSA9IHtcbiAgICAgICAgZXJyb3I6IGVfMV8xXG4gICAgICB9O1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAocGFuZWxzXzFfMSAmJiAhcGFuZWxzXzFfMS5kb25lICYmIChfYSA9IHBhbmVsc18xLnJldHVybikpIF9hLmNhbGwocGFuZWxzXzEpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY2xpY2tlZFBhbmVsKSB7XG4gICAgICB2YXIgY2FtZXJhUG9zaXRpb24gPSBmbGlja2luZy5jYW1lcmEucG9zaXRpb247XG4gICAgICB2YXIgY2xpY2tlZFBhbmVsUG9zaXRpb24gPSBjbGlja2VkUGFuZWwucG9zaXRpb247XG4gICAgICBmbGlja2luZy50cmlnZ2VyKG5ldyBDb21wb25lbnRFdmVudCQxKEVWRU5UUy5TRUxFQ1QsIHtcbiAgICAgICAgaW5kZXg6IGNsaWNrZWRQYW5lbC5pbmRleCxcbiAgICAgICAgcGFuZWw6IGNsaWNrZWRQYW5lbCxcbiAgICAgICAgLy8gRGlyZWN0aW9uIHRvIHRoZSBjbGlja2VkIHBhbmVsXG4gICAgICAgIGRpcmVjdGlvbjogZ2V0RGlyZWN0aW9uJDEoY2FtZXJhUG9zaXRpb24sIGNsaWNrZWRQYW5lbFBvc2l0aW9uKVxuICAgICAgfSkpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIEhvbGRpbmdTdGF0ZTtcbn0oU3RhdGUpO1xuXG4vKipcclxuICogQSBzdGF0ZSB0aGF0IGFjdGl2YXRlcyB3aGVuIHVzZXIncyBkcmFnZ2luZyB0aGUgRmxpY2tpbmcgYXJlYVxyXG4gKiBAa28g7IKs7Jqp7J6Q6rCAIOuTnOuemOq5heykkeyduCDsg4Htg5xcclxuICogQGludGVybmFsXHJcbiAqL1xudmFyIERyYWdnaW5nU3RhdGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMkMyhEcmFnZ2luZ1N0YXRlLCBfc3VwZXIpO1xuICBmdW5jdGlvbiBEcmFnZ2luZ1N0YXRlKCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIC8qKlxyXG4gICAgICogV2hldGhlciB1c2VyIGlzIGNsaWNraW5nIG9yIHRvdWNoaW5nXHJcbiAgICAgKiBAa28g7ZiE7J6sIOyCrOyaqeyekOqwgCDtgbTrpq0v7YSw7LmY7KSR7J247KeAIOyXrOu2gFxyXG4gICAgICogQHR5cGUge3RydWV9XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIF90aGlzLmhvbGRpbmcgPSB0cnVlO1xuICAgIC8qKlxyXG4gICAgICogV2hldGhlciBGbGlja2luZydzIGFuaW1hdGluZ1xyXG4gICAgICogQGtvIO2YhOyerCDslaDri4jrqZTsnbTshZgg64+Z7J6RIOyXrOu2gFxyXG4gICAgICogQHR5cGUge3RydWV9XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIF90aGlzLmFuaW1hdGluZyA9IHRydWU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIHZhciBfX3Byb3RvID0gRHJhZ2dpbmdTdGF0ZS5wcm90b3R5cGU7XG4gIF9fcHJvdG8ub25DaGFuZ2UgPSBmdW5jdGlvbiAoY3R4KSB7XG4gICAgdGhpcy5fbW92ZVRvQ2hhbmdlZFBvc2l0aW9uKGN0eCk7XG4gIH07XG4gIF9fcHJvdG8ub25SZWxlYXNlID0gZnVuY3Rpb24gKGN0eCkge1xuICAgIHZhciBfYTtcbiAgICB2YXIgZmxpY2tpbmcgPSBjdHguZmxpY2tpbmcsXG4gICAgICBheGVzRXZlbnQgPSBjdHguYXhlc0V2ZW50LFxuICAgICAgdHJhbnNpdFRvID0gY3R4LnRyYW5zaXRUbztcbiAgICAvLyBVcGRhdGUgbGFzdCBwb3NpdGlvbiB0byBjb3BlIHdpdGggQXhlcydzIGFuaW1hdGluZyBiZWhhdmlvclxuICAgIC8vIEF4ZXMgdXNlcyBzdGFydCBwb3NpdGlvbiB3aGVuIGFuaW1hdGlvbiBzdGFydFxuICAgIGZsaWNraW5nLnRyaWdnZXIobmV3IENvbXBvbmVudEV2ZW50JDEoRVZFTlRTLkhPTERfRU5ELCB7XG4gICAgICBheGVzRXZlbnQ6IGF4ZXNFdmVudFxuICAgIH0pKTtcbiAgICBpZiAoZmxpY2tpbmcucmVuZGVyZXIucGFuZWxDb3VudCA8PSAwKSB7XG4gICAgICAvLyBUaGVyZSdyZSBubyBwYW5lbHNcbiAgICAgIHRyYW5zaXRUbyhTVEFURV9UWVBFLklETEUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0cmFuc2l0VG8oU1RBVEVfVFlQRS5BTklNQVRJTkcpO1xuICAgIHZhciBjb250cm9sID0gZmxpY2tpbmcuY29udHJvbDtcbiAgICB2YXIgcG9zaXRpb24gPSBheGVzRXZlbnQuZGVzdFBvc1tQT1NJVElPTl9LRVldO1xuICAgIHZhciBkdXJhdGlvbiA9IE1hdGgubWF4KGF4ZXNFdmVudC5kdXJhdGlvbiwgZmxpY2tpbmcuZHVyYXRpb24pO1xuICAgIHRyeSB7XG4gICAgICB2b2lkIGNvbnRyb2wubW92ZVRvUG9zaXRpb24ocG9zaXRpb24sIGR1cmF0aW9uLCBheGVzRXZlbnQpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdHJhbnNpdFRvKFNUQVRFX1RZUEUuSURMRSk7XG4gICAgICBheGVzRXZlbnQuc2V0VG8oKF9hID0ge30sIF9hW1BPU0lUSU9OX0tFWV0gPSBmbGlja2luZy5jYW1lcmEucG9zaXRpb24sIF9hKSwgMCk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gRHJhZ2dpbmdTdGF0ZTtcbn0oU3RhdGUpO1xuXG4vKipcclxuICogQSBzdGF0ZSB0aGF0IGFjdGl2YXRlcyB3aGVuIEZsaWNraW5nJ3MgYW5pbWF0aW5nIGJ5IHVzZXIgaW5wdXQgb3IgbWV0aG9kIGNhbGxcclxuICogQGtvIOyCrOyaqeyekCDsnoXroKXsnbTrgpgg66mU7IaM65OcIO2YuOy2nOyXkCDsnZjtlbQgRmxpY2tpbmfsnZgg7JWg64uI66mU7J207IWY7J20IOuPmeyekeykkeyduCDsg4Htg5xcclxuICogQGludGVybmFsXHJcbiAqL1xudmFyIEFuaW1hdGluZ1N0YXRlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzJDMoQW5pbWF0aW5nU3RhdGUsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIEFuaW1hdGluZ1N0YXRlKCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIC8qKlxyXG4gICAgICogV2hldGhlciB1c2VyIGlzIGNsaWNraW5nIG9yIHRvdWNoaW5nXHJcbiAgICAgKiBAa28g7ZiE7J6sIOyCrOyaqeyekOqwgCDtgbTrpq0v7YSw7LmY7KSR7J247KeAIOyXrOu2gFxyXG4gICAgICogQHR5cGUge2ZhbHNlfVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBfdGhpcy5ob2xkaW5nID0gZmFsc2U7XG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIEZsaWNraW5nJ3MgYW5pbWF0aW5nXHJcbiAgICAgKiBAa28g7ZiE7J6sIOyVoOuLiOuplOydtOyFmCDrj5nsnpEg7Jes67aAXHJcbiAgICAgKiBAdHlwZSB7dHJ1ZX1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgX3RoaXMuYW5pbWF0aW5nID0gdHJ1ZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgdmFyIF9fcHJvdG8gPSBBbmltYXRpbmdTdGF0ZS5wcm90b3R5cGU7XG4gIF9fcHJvdG8ub25Ib2xkID0gZnVuY3Rpb24gKGN0eCkge1xuICAgIHZhciBmbGlja2luZyA9IGN0eC5mbGlja2luZyxcbiAgICAgIGF4ZXNFdmVudCA9IGN0eC5heGVzRXZlbnQsXG4gICAgICB0cmFuc2l0VG8gPSBjdHgudHJhbnNpdFRvO1xuICAgIHZhciB0YXJnZXRQYW5lbCA9IHRoaXMuX3RhcmdldFBhbmVsO1xuICAgIHZhciBjb250cm9sID0gZmxpY2tpbmcuY29udHJvbDtcbiAgICB0aGlzLl9kZWx0YSA9IDA7XG4gICAgZmxpY2tpbmcuY29udHJvbC51cGRhdGVJbnB1dCgpO1xuICAgIGlmIChmbGlja2luZy5jaGFuZ2VPbkhvbGQgJiYgdGFyZ2V0UGFuZWwpIHtcbiAgICAgIGNvbnRyb2wuc2V0QWN0aXZlKHRhcmdldFBhbmVsLCBjb250cm9sLmFjdGl2ZVBhbmVsLCBheGVzRXZlbnQuaXNUcnVzdGVkKTtcbiAgICB9XG4gICAgdmFyIGhvbGRTdGFydEV2ZW50ID0gbmV3IENvbXBvbmVudEV2ZW50JDEoRVZFTlRTLkhPTERfU1RBUlQsIHtcbiAgICAgIGF4ZXNFdmVudDogYXhlc0V2ZW50XG4gICAgfSk7XG4gICAgZmxpY2tpbmcudHJpZ2dlcihob2xkU3RhcnRFdmVudCk7XG4gICAgaWYgKGhvbGRTdGFydEV2ZW50LmlzQ2FuY2VsZWQoKSkge1xuICAgICAgdHJhbnNpdFRvKFNUQVRFX1RZUEUuRElTQUJMRUQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmFuc2l0VG8oU1RBVEVfVFlQRS5EUkFHR0lORyk7XG4gICAgfVxuICB9O1xuICBfX3Byb3RvLm9uQ2hhbmdlID0gZnVuY3Rpb24gKGN0eCkge1xuICAgIHRoaXMuX21vdmVUb0NoYW5nZWRQb3NpdGlvbihjdHgpO1xuICB9O1xuICBfX3Byb3RvLm9uRmluaXNoID0gZnVuY3Rpb24gKGN0eCkge1xuICAgIHZhciBmbGlja2luZyA9IGN0eC5mbGlja2luZyxcbiAgICAgIGF4ZXNFdmVudCA9IGN0eC5heGVzRXZlbnQsXG4gICAgICB0cmFuc2l0VG8gPSBjdHgudHJhbnNpdFRvO1xuICAgIHZhciBjb250cm9sID0gZmxpY2tpbmcuY29udHJvbDtcbiAgICB2YXIgY29udHJvbGxlciA9IGNvbnRyb2wuY29udHJvbGxlcjtcbiAgICB2YXIgYW5pbWF0aW5nQ29udGV4dCA9IGNvbnRyb2xsZXIuYW5pbWF0aW5nQ29udGV4dDtcbiAgICB0cmFuc2l0VG8oU1RBVEVfVFlQRS5JRExFKTtcbiAgICBmbGlja2luZy50cmlnZ2VyKG5ldyBDb21wb25lbnRFdmVudCQxKEVWRU5UUy5NT1ZFX0VORCwge1xuICAgICAgaXNUcnVzdGVkOiBheGVzRXZlbnQuaXNUcnVzdGVkLFxuICAgICAgZGlyZWN0aW9uOiBnZXREaXJlY3Rpb24kMShhbmltYXRpbmdDb250ZXh0LnN0YXJ0LCBhbmltYXRpbmdDb250ZXh0LmVuZCksXG4gICAgICBheGVzRXZlbnQ6IGF4ZXNFdmVudFxuICAgIH0pKTtcbiAgICB2YXIgdGFyZ2V0UGFuZWwgPSB0aGlzLl90YXJnZXRQYW5lbDtcbiAgICBpZiAodGFyZ2V0UGFuZWwpIHtcbiAgICAgIGNvbnRyb2wuc2V0QWN0aXZlKHRhcmdldFBhbmVsLCBjb250cm9sLmFjdGl2ZVBhbmVsLCBheGVzRXZlbnQuaXNUcnVzdGVkKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBBbmltYXRpbmdTdGF0ZTtcbn0oU3RhdGUpO1xuXG4vKipcclxuICogQSBzdGF0ZSB0aGF0IGFjdGl2YXRlcyB3aGVuIEZsaWNraW5nIGlzIHN0b3BwZWQgYnkgZXZlbnQncyBgc3RvcGAgbWV0aG9kXHJcbiAqIEBrbyDsnbTrsqTtirjsnZggYHN0b3Bg7Zi47Lac7JeQIOydmO2VtCBGbGlja2luZ+ydtCDsoJXsp4DrkJwg7IOB7YOcXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cbnZhciBEaXNhYmxlZFN0YXRlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzJDMoRGlzYWJsZWRTdGF0ZSwgX3N1cGVyKTtcbiAgZnVuY3Rpb24gRGlzYWJsZWRTdGF0ZSgpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgdXNlciBpcyBjbGlja2luZyBvciB0b3VjaGluZ1xyXG4gICAgICogQGtvIO2YhOyerCDsgqzsmqnsnpDqsIAg7YG066atL+2EsOy5mOykkeyduOyngCDsl6zrtoBcclxuICAgICAqIEB0eXBlIHtmYWxzZX1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgX3RoaXMuaG9sZGluZyA9IGZhbHNlO1xuICAgIC8qKlxyXG4gICAgICogV2hldGhlciBGbGlja2luZydzIGFuaW1hdGluZ1xyXG4gICAgICogQGtvIO2YhOyerCDslaDri4jrqZTsnbTshZgg64+Z7J6RIOyXrOu2gFxyXG4gICAgICogQHR5cGUge3RydWV9XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIF90aGlzLmFuaW1hdGluZyA9IHRydWU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIHZhciBfX3Byb3RvID0gRGlzYWJsZWRTdGF0ZS5wcm90b3R5cGU7XG4gIF9fcHJvdG8ub25BbmltYXRpb25FbmQgPSBmdW5jdGlvbiAoY3R4KSB7XG4gICAgdmFyIHRyYW5zaXRUbyA9IGN0eC50cmFuc2l0VG87XG4gICAgdHJhbnNpdFRvKFNUQVRFX1RZUEUuSURMRSk7XG4gIH07XG4gIF9fcHJvdG8ub25DaGFuZ2UgPSBmdW5jdGlvbiAoY3R4KSB7XG4gICAgdmFyIGF4ZXNFdmVudCA9IGN0eC5heGVzRXZlbnQsXG4gICAgICB0cmFuc2l0VG8gPSBjdHgudHJhbnNpdFRvO1xuICAgIC8vIENhbiBzdG9wIEF4ZXMncyBjaGFuZ2UgZXZlbnRcbiAgICBheGVzRXZlbnQuc3RvcCgpO1xuICAgIHRyYW5zaXRUbyhTVEFURV9UWVBFLklETEUpO1xuICB9O1xuICBfX3Byb3RvLm9uUmVsZWFzZSA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICB2YXIgYXhlc0V2ZW50ID0gY3R4LmF4ZXNFdmVudCxcbiAgICAgIHRyYW5zaXRUbyA9IGN0eC50cmFuc2l0VG87XG4gICAgLy8gVGhpcyBpcyBuZWVkZWQgd2hlbiBzdG9wcGVkIGhvbGQgc3RhcnQgZXZlbnRcbiAgICBpZiAoYXhlc0V2ZW50LmRlbHRhLmZsaWNrID09PSAwKSB7XG4gICAgICB0cmFuc2l0VG8oU1RBVEVfVFlQRS5JRExFKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBEaXNhYmxlZFN0YXRlO1xufShTdGF0ZSk7XG5cbi8qKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXG52YXIgU3RhdGVNYWNoaW5lID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU3RhdGVNYWNoaW5lKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdGhpcy50cmFuc2l0VG8gPSBmdW5jdGlvbiAobmV4dFN0YXRlVHlwZSkge1xuICAgICAgdmFyIG5leHRTdGF0ZTtcbiAgICAgIHN3aXRjaCAobmV4dFN0YXRlVHlwZSkge1xuICAgICAgICBjYXNlIFNUQVRFX1RZUEUuSURMRTpcbiAgICAgICAgICBuZXh0U3RhdGUgPSBuZXcgSWRsZVN0YXRlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgU1RBVEVfVFlQRS5IT0xESU5HOlxuICAgICAgICAgIG5leHRTdGF0ZSA9IG5ldyBIb2xkaW5nU3RhdGUoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBTVEFURV9UWVBFLkRSQUdHSU5HOlxuICAgICAgICAgIG5leHRTdGF0ZSA9IG5ldyBEcmFnZ2luZ1N0YXRlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgU1RBVEVfVFlQRS5BTklNQVRJTkc6XG4gICAgICAgICAgbmV4dFN0YXRlID0gbmV3IEFuaW1hdGluZ1N0YXRlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgU1RBVEVfVFlQRS5ESVNBQkxFRDpcbiAgICAgICAgICBuZXh0U3RhdGUgPSBuZXcgRGlzYWJsZWRTdGF0ZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbmV4dFN0YXRlLm9uRW50ZXIoX3RoaXMuX3N0YXRlKTtcbiAgICAgIF90aGlzLl9zdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICAgIHJldHVybiBfdGhpcy5fc3RhdGU7XG4gICAgfTtcbiAgICB0aGlzLl9zdGF0ZSA9IG5ldyBJZGxlU3RhdGUoKTtcbiAgfVxuICB2YXIgX19wcm90byA9IFN0YXRlTWFjaGluZS5wcm90b3R5cGU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcInN0YXRlXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgX19wcm90by5maXJlID0gZnVuY3Rpb24gKGV2ZW50VHlwZSwgZXh0ZXJuYWxDdHgpIHtcbiAgICB2YXIgY3VycmVudFN0YXRlID0gdGhpcy5fc3RhdGU7XG4gICAgdmFyIGN0eCA9IF9fYXNzaWduJDIoX19hc3NpZ24kMih7fSwgZXh0ZXJuYWxDdHgpLCB7XG4gICAgICB0cmFuc2l0VG86IHRoaXMudHJhbnNpdFRvXG4gICAgfSk7XG4gICAgc3dpdGNoIChldmVudFR5cGUpIHtcbiAgICAgIGNhc2UgRVZFTlQuSE9MRDpcbiAgICAgICAgY3VycmVudFN0YXRlLm9uSG9sZChjdHgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRVZFTlQuQ0hBTkdFOlxuICAgICAgICBjdXJyZW50U3RhdGUub25DaGFuZ2UoY3R4KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEVWRU5ULlJFTEVBU0U6XG4gICAgICAgIGN1cnJlbnRTdGF0ZS5vblJlbGVhc2UoY3R4KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEVWRU5ULkFOSU1BVElPTl9FTkQ6XG4gICAgICAgIGN1cnJlbnRTdGF0ZS5vbkFuaW1hdGlvbkVuZChjdHgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRVZFTlQuRklOSVNIOlxuICAgICAgICBjdXJyZW50U3RhdGUub25GaW5pc2goY3R4KTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9O1xuICByZXR1cm4gU3RhdGVNYWNoaW5lO1xufSgpO1xuXG4vKipcclxuICogQSBjb250cm9sbGVyIHRoYXQgaGFuZGxlcyB0aGUge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtYXhlcy8gQGVnanMvYXhlc30gZXZlbnRzXHJcbiAqIEBrbyB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1heGVzLyBAZWdqcy9heGVzfeydmCDsnbTrsqTtirjrpbwg7LKY66as7ZWY64qUIOy7qO2KuOuhpOufrCDsu7Ttj6zrhIztirhcclxuICogQGludGVybmFsXHJcbiAqL1xudmFyIEF4ZXNDb250cm9sbGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqICovXG4gIGZ1bmN0aW9uIEF4ZXNDb250cm9sbGVyKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdGhpcy5fb25BeGVzSG9sZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLl9kcmFnZ2VkID0gZmFsc2U7XG4gICAgfTtcbiAgICB0aGlzLl9vbkF4ZXNDaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICBfdGhpcy5fZHJhZ2dlZCA9ICEhKChfYSA9IF90aGlzLl9wYW5JbnB1dCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzRW5hYmxlZCgpKTtcbiAgICB9O1xuICAgIHRoaXMuX3ByZXZlbnRDbGlja1doZW5EcmFnZ2VkID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChfdGhpcy5fZHJhZ2dlZCkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB9XG4gICAgICBfdGhpcy5fZHJhZ2dlZCA9IGZhbHNlO1xuICAgIH07XG4gICAgdGhpcy5fcmVzZXRJbnRlcm5hbFZhbHVlcygpO1xuICAgIHRoaXMuX3N0YXRlTWFjaGluZSA9IG5ldyBTdGF0ZU1hY2hpbmUoKTtcbiAgfVxuICB2YXIgX19wcm90byA9IEF4ZXNDb250cm9sbGVyLnByb3RvdHlwZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwiYXhlc1wiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBBbiB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1heGVzL2RvY3MvYXBpL0F4ZXMgQXhlc30gaW5zdGFuY2VcclxuICAgICAqIEBrbyB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1heGVzL2RvY3MvYXBpL0F4ZXMgQXhlc33snZgg7J247Iqk7YS07IqkXHJcbiAgICAgKiBAdHlwZSB7QXhlcyB8IG51bGx9XHJcbiAgICAgKiBAc2VlIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtYXhlcy9kb2NzL2FwaS9BeGVzXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2F4ZXM7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcInBhbklucHV0XCIsIHtcbiAgICAvKipcclxuICAgICAqIEFuIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWF4ZXMvZG9jcy9hcGkvUGFuSW5wdXQgUGFuSW5wdXR9IGluc3RhbmNlXHJcbiAgICAgKiBAa28ge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtYXhlcy9kb2NzL2FwaS9QYW5JbnB1dCBQYW5JbnB1dH3snZgg7J247Iqk7YS07IqkXHJcbiAgICAgKiBAdHlwZSB7UGFuSW5wdXQgfCBudWxsfVxyXG4gICAgICogQHNlZSBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWF4ZXMvZG9jcy9hcGkvUGFuSW5wdXRcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcGFuSW5wdXQ7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcInN0YXRlTWFjaGluZVwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlTWFjaGluZTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwic3RhdGVcIiwge1xuICAgIC8qKlxyXG4gICAgICogQSBhY3RpdmF0ZWQge0BsaW5rIFN0YXRlfSB0aGF0IHNob3dzIHRoZSBjdXJyZW50IHN0YXR1cyBvZiB0aGUgdXNlciBpbnB1dCBvciB0aGUgYW5pbWF0aW9uXHJcbiAgICAgKiBAa28g7ZiE7J6sIO2ZnOyEse2ZlOuQnCB7QGxpbmsgU3RhdGV9IOyduOyKpO2EtOyKpOuhnCDsgqzsmqnsnpAg7J6F66ClIOuYkOuKlCDslaDri4jrqZTsnbTshZgg7IOB7YOc66W8IOuCmO2DgOuDheuLiOuLpFxyXG4gICAgICogQHR5cGUge1N0YXRlfVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3RhdGVNYWNoaW5lLnN0YXRlO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJhbmltYXRpbmdDb250ZXh0XCIsIHtcbiAgICAvKipcclxuICAgICAqIEEgY29udGV4dCBvZiB0aGUgY3VycmVudCBhbmltYXRpb24gcGxheWluZ1xyXG4gICAgICogQGtvIO2YhOyerCDsnqzsg53spJHsnbgg7JWg64uI66mU7J207IWYIOygleuztFxyXG4gICAgICogQHR5cGUge29iamVjdH1cclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzdGFydCBBIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSBhbmltYXRpb248a28+7JWg64uI66mU7J207IWYIOyLnOyekSDsp4DsoJA8L2tvPlxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGVuZCBBIGVuZCBwb3NpdGlvbiBvZiB0aGUgYW5pbWF0aW9uPGtvPuyVoOuLiOuplOydtOyFmCDrgZ0g7KeA7KCQPC9rbz5cclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBvZmZzZXQgY2FtZXJhIG9mZnNldDxrbz7subTrqZTrnbwg7Jik7ZSE7IWLPC9rbz5cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYW5pbWF0aW5nQ29udGV4dDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwiY29udHJvbFBhcmFtc1wiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBBIGN1cnJlbnQgY29udHJvbCBwYXJhbWV0ZXJzIG9mIHRoZSBBeGVzIGluc3RhbmNlXHJcbiAgICAgKiBAa28g7Zmc7ISx7ZmU65CcIO2YhOyerCBBeGVzIO2MqOufrOuvuO2EsOuTpFxyXG4gICAgICogQHR5cGUge0NvbnRyb2xQYXJhbXN9XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBheGVzID0gdGhpcy5fYXhlcztcbiAgICAgIGlmICghYXhlcykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJhbmdlOiB7XG4gICAgICAgICAgICBtaW46IDAsXG4gICAgICAgICAgICBtYXg6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIHBvc2l0aW9uOiAwLFxuICAgICAgICAgIGNpcmN1bGFyOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdmFyIGF4aXMgPSBheGVzLmF4aXNbUE9TSVRJT05fS0VZXTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJhbmdlOiB7XG4gICAgICAgICAgbWluOiBheGlzLnJhbmdlWzBdLFxuICAgICAgICAgIG1heDogYXhpcy5yYW5nZVsxXVxuICAgICAgICB9LFxuICAgICAgICBjaXJjdWxhcjogYXhpcy5jaXJjdWxhclswXSxcbiAgICAgICAgcG9zaXRpb246IHRoaXMucG9zaXRpb25cbiAgICAgIH07XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcImVuYWJsZWRcIiwge1xuICAgIC8qKlxyXG4gICAgICogQSBCb29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgdXNlciBpbnB1dCBpcyBlbmFibGVkXHJcbiAgICAgKiBAa28g7ZiE7J6sIOyCrOyaqeyekCDsnoXroKXsnbQg7Zmc7ISx7ZmU65CY7JeI64qU7KeA66W8IOuCmO2DgOuCtOuKlCDqsJJcclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfYSwgX2I7XG4gICAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5fcGFuSW5wdXQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pc0VuYWJsZWQoKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZmFsc2U7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcInBvc2l0aW9uXCIsIHtcbiAgICAvKipcclxuICAgICAqIEN1cnJlbnQgcG9zaXRpb24gdmFsdWUgaW4ge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtYXhlcy9yZWxlYXNlL2xhdGVzdC9kb2MvZWcuQXhlcy5odG1sIEF4ZXN9IGluc3RhbmNlXHJcbiAgICAgKiBAa28ge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtYXhlcy9yZWxlYXNlL2xhdGVzdC9kb2MvZWcuQXhlcy5odG1sIEF4ZXN9IOyduOyKpO2EtOyKpCDrgrTrtoDsnZgg7ZiE7J6sIOyijO2RnCDqsJJcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLl9heGVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0KFtQT1NJVElPTl9LRVldKVtQT1NJVElPTl9LRVldKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJyYW5nZVwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBDdXJyZW50IHJhbmdlIHZhbHVlIGluIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWF4ZXMvcmVsZWFzZS9sYXRlc3QvZG9jL2VnLkF4ZXMuaHRtbCBBeGVzfSBpbnN0YW5jZVxyXG4gICAgICogQGtvIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWF4ZXMvcmVsZWFzZS9sYXRlc3QvZG9jL2VnLkF4ZXMuaHRtbCBBeGVzfSDsnbjsiqTthLTsiqQg64K067aA7J2YIO2YhOyerCDsnbTrj5kg67KU7JyEIOqwklxyXG4gICAgICogQHR5cGUge251bWJlcltdfVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfYSwgX2I7XG4gICAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5fYXhlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmF4aXNbUE9TSVRJT05fS0VZXS5yYW5nZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogWzAsIDBdO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJib3VuY2VcIiwge1xuICAgIC8qKlxyXG4gICAgICogQWN0dWFsIGJvdW5jZSBzaXplKHB4KVxyXG4gICAgICogQGtvIOyggeyaqeuQnCBib3VuY2Ug7YGs6riwKHB4IOuLqOychClcclxuICAgICAqIEB0eXBlIHtudW1iZXJbXX1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICByZXR1cm4gKF9hID0gdGhpcy5fYXhlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmF4aXNbUE9TSVRJT05fS0VZXS5ib3VuY2U7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIC8qKlxyXG4gICAqIEluaXRpYWxpemUgQXhlc0NvbnRyb2xsZXJcclxuICAgKiBAa28gQXhlc0NvbnRyb2xsZXLrpbwg7LSI6riw7ZmU7ZWp64uI64ukXHJcbiAgICogQHBhcmFtIHtGbGlja2luZ30gZmxpY2tpbmcgQW4gaW5zdGFuY2Ugb2YgRmxpY2tpbmdcclxuICAgKiBAY2hhaW5hYmxlXHJcbiAgICogQHJldHVybiB7dGhpc31cclxuICAgKi9cbiAgX19wcm90by5pbml0ID0gZnVuY3Rpb24gKGZsaWNraW5nKSB7XG4gICAgdmFyIF9hO1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdGhpcy5fZmxpY2tpbmcgPSBmbGlja2luZztcbiAgICB0aGlzLl9heGVzID0gbmV3IEF4ZXMoKF9hID0ge30sIF9hW1BPU0lUSU9OX0tFWV0gPSB7XG4gICAgICByYW5nZTogWzAsIDBdLFxuICAgICAgY2lyY3VsYXI6IGZhbHNlLFxuICAgICAgYm91bmNlOiBbMCwgMF1cbiAgICB9LCBfYSksIHtcbiAgICAgIGRlY2VsZXJhdGlvbjogZmxpY2tpbmcuZGVjZWxlcmF0aW9uLFxuICAgICAgaW50ZXJydXB0YWJsZTogZmxpY2tpbmcuaW50ZXJydXB0YWJsZSxcbiAgICAgIG5lc3RlZDogZmxpY2tpbmcubmVzdGVkLFxuICAgICAgZWFzaW5nOiBmbGlja2luZy5lYXNpbmdcbiAgICB9KTtcbiAgICB0aGlzLl9wYW5JbnB1dCA9IG5ldyBQYW5JbnB1dChmbGlja2luZy52aWV3cG9ydC5lbGVtZW50LCB7XG4gICAgICBpbnB1dFR5cGU6IGZsaWNraW5nLmlucHV0VHlwZSxcbiAgICAgIHRocmVzaG9sZDogMSxcbiAgICAgIGlPU0VkZ2VTd2lwZVRocmVzaG9sZDogZmxpY2tpbmcuaU9TRWRnZVN3aXBlVGhyZXNob2xkLFxuICAgICAgcHJldmVudERlZmF1bHRPbkRyYWc6IGZsaWNraW5nLnByZXZlbnREZWZhdWx0T25EcmFnLFxuICAgICAgc2NhbGU6IGZsaWNraW5nLmhvcml6b250YWwgPyBbZmxpY2tpbmcuY2FtZXJhLnBhbmVsT3JkZXIgPT09IE9SREVSLlJUTCA/IDEgOiAtMSwgMF0gOiBbMCwgLTFdLFxuICAgICAgcmVsZWFzZU9uU2Nyb2xsOiB0cnVlXG4gICAgfSk7XG4gICAgdmFyIGF4ZXMgPSB0aGlzLl9heGVzO1xuICAgIGF4ZXMuY29ubmVjdChmbGlja2luZy5ob3Jpem9udGFsID8gW1BPU0lUSU9OX0tFWSwgXCJcIl0gOiBbXCJcIiwgUE9TSVRJT05fS0VZXSwgdGhpcy5fcGFuSW5wdXQpO1xuICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgdmFyIGV2ZW50VHlwZSA9IEVWRU5UW2tleV07XG4gICAgICBheGVzLm9uKGV2ZW50VHlwZSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgX3RoaXMuX3N0YXRlTWFjaGluZS5maXJlKGV2ZW50VHlwZSwge1xuICAgICAgICAgIGZsaWNraW5nOiBmbGlja2luZyxcbiAgICAgICAgICBheGVzRXZlbnQ6IGVcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGZvciAodmFyIGtleSBpbiBFVkVOVCkge1xuICAgICAgX2xvb3BfMShrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXHJcbiAgICogRGVzdHJveSBBeGVzQ29udHJvbGxlciBhbmQgcmV0dXJuIHRvIGluaXRpYWwgc3RhdGVcclxuICAgKiBAa28gQXhlc0NvbnRyb2xsZXLrpbwg7LSI6riwIOyDge2DnOuhnCDrkJjrj4zrpr3ri4jri6RcclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xuICBfX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICh0aGlzLl9heGVzKSB7XG4gICAgICB0aGlzLnJlbW92ZVByZXZlbnRDbGlja0hhbmRsZXIoKTtcbiAgICAgIHRoaXMuX2F4ZXMuZGVzdHJveSgpO1xuICAgIH1cbiAgICAoX2EgPSB0aGlzLl9wYW5JbnB1dCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRlc3Ryb3koKTtcbiAgICB0aGlzLl9yZXNldEludGVybmFsVmFsdWVzKCk7XG4gIH07XG4gIC8qKlxyXG4gICAqIEVuYWJsZSBpbnB1dCBmcm9tIHRoZSB1c2VyIChtb3VzZS90b3VjaClcclxuICAgKiBAa28g7IKs7Jqp7J6Q7J2YIOyeheugpSjrp4jsmrDsiqQv7YSw7LmYKeulvCDtmZzshLHtmZTtlanri4jri6RcclxuICAgKiBAY2hhaW5hYmxlXHJcbiAgICogQHJldHVybiB7dGhpc31cclxuICAgKi9cbiAgX19wcm90by5lbmFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9hO1xuICAgIChfYSA9IHRoaXMuX3BhbklucHV0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZW5hYmxlKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxyXG4gICAqIERpc2FibGUgaW5wdXQgZnJvbSB0aGUgdXNlciAobW91c2UvdG91Y2gpXHJcbiAgICogQGtvIOyCrOyaqeyekOydmCDsnoXroKUo66eI7Jqw7IqkL+2EsOy5mCnrpbwg66eJ7Iq164uI64ukXHJcbiAgICogQGNoYWluYWJsZVxyXG4gICAqIEByZXR1cm4ge3RoaXN9XHJcbiAgICovXG4gIF9fcHJvdG8uZGlzYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX2E7XG4gICAgKF9hID0gdGhpcy5fcGFuSW5wdXQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kaXNhYmxlKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxyXG4gICAqIFJlbGVhc2VzIG9uZ29pbmcgdXNlciBpbnB1dCAobW91c2UvdG91Y2gpXHJcbiAgICogQGtvIOyCrOyaqeyekOydmCDtmITsnqwg7J6F66ClKOuniOyasOyKpC/thLDsuZgp66W8IOykkeuLqOyLnO2CteuLiOuLpFxyXG4gICAqIEBjaGFpbmFibGVcclxuICAgKiBAcmV0dXJuIHt0aGlzfVxyXG4gICAqL1xuICBfX3Byb3RvLnJlbGVhc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9hO1xuICAgIChfYSA9IHRoaXMuX3BhbklucHV0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVsZWFzZSgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcclxuICAgKiBDaGFuZ2UgdGhlIGRlc3RpbmF0aW9uIGFuZCBkdXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uIGN1cnJlbnRseSBwbGF5aW5nXHJcbiAgICogQGtvIOyerOyDnSDspJHsnbgg7JWg64uI66mU7J207IWY7J2YIOuqqeyggeyngOyZgCDsnqzsg50g7Iuc6rCE7J2EIOuzgOqyve2VqeuLiOuLpFxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwb3NpdGlvbiBBIHBvc2l0aW9uIHRvIG1vdmU8a28+7J2064+Z7ZWgIOyijO2RnDwva28+XHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGR1cmF0aW9uIER1cmF0aW9uIG9mIHRoZSBhbmltYXRpb24gKHVuaXQ6IG1zKTxrbz7slaDri4jrqZTsnbTshZgg7KeE7ZaJIOyLnOqwhCAo64uo7JyEOiBtcyk8L2tvPlxyXG4gICAqIEBjaGFpbmFibGVcclxuICAgKiBAcmV0dXJuIHt0aGlzfVxyXG4gICAqL1xuICBfX3Byb3RvLnVwZGF0ZUFuaW1hdGlvbiA9IGZ1bmN0aW9uIChwb3NpdGlvbiwgZHVyYXRpb24pIHtcbiAgICB2YXIgX2E7XG4gICAgdmFyIF9iO1xuICAgIHRoaXMuX2FuaW1hdGluZ0NvbnRleHQgPSBfX2Fzc2lnbiQyKF9fYXNzaWduJDIoe30sIHRoaXMuX2FuaW1hdGluZ0NvbnRleHQpLCB7XG4gICAgICBlbmQ6IHBvc2l0aW9uXG4gICAgfSk7XG4gICAgKF9iID0gdGhpcy5fYXhlcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnVwZGF0ZUFuaW1hdGlvbih7XG4gICAgICBkZXN0UG9zOiAoX2EgPSB7fSwgX2FbUE9TSVRJT05fS0VZXSA9IHBvc2l0aW9uLCBfYSksXG4gICAgICBkdXJhdGlvbjogZHVyYXRpb25cbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXHJcbiAgICogU3RvcHMgdGhlIGFuaW1hdGlvbiBjdXJyZW50bHkgcGxheWluZ1xyXG4gICAqIEBrbyDsnqzsg50g7KSR7J24IOyVoOuLiOuplOydtOyFmOydhCDspJHri6jsi5ztgrXri4jri6RcclxuICAgKiBAY2hhaW5hYmxlXHJcbiAgICogQHJldHVybiB7dGhpc31cclxuICAgKi9cbiAgX19wcm90by5zdG9wQW5pbWF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfYTtcbiAgICAoX2EgPSB0aGlzLl9heGVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3RvcEFuaW1hdGlvbigpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcclxuICAgKiBVcGRhdGUge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtYXhlcy8gQGVnanMvYXhlc30ncyBzdGF0ZVxyXG4gICAqIEBrbyB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1heGVzLyBAZWdqcy9heGVzfeydmCDsg4Htg5zrpbwg6rCx7Iug7ZWp64uI64ukXHJcbiAgICogQGNoYWluYWJsZVxyXG4gICAqIEB0aHJvd3Mge0ZsaWNraW5nRXJyb3J9XHJcbiAgICoge0BsaW5rIEVSUk9SX0NPREUgTk9UX0FUVEFDSEVEX1RPX0ZMSUNLSU5HfSBXaGVuIHtAbGluayBBeGVzQ29udHJvbGxlciNpbml0IGluaXR9IGlzIG5vdCBjYWxsZWQgYmVmb3JlXHJcbiAgICogPGtvPntAbGluayBBeGVzQ29udHJvbGxlciNpbml0IGluaXR97J20IOydtOyghOyXkCDtmLjstpzrkJjsp4Ag7JWK7J2AIOqyveyasDwva28+XHJcbiAgICogQHJldHVybiB7dGhpc31cclxuICAgKi9cbiAgX19wcm90by51cGRhdGUgPSBmdW5jdGlvbiAoY29udHJvbFBhcmFtcykge1xuICAgIHZhciBfYTtcbiAgICB2YXIgZmxpY2tpbmcgPSBnZXRGbGlja2luZ0F0dGFjaGVkKHRoaXMuX2ZsaWNraW5nKTtcbiAgICB2YXIgY2FtZXJhID0gZmxpY2tpbmcuY2FtZXJhO1xuICAgIHZhciBheGVzID0gdGhpcy5fYXhlcztcbiAgICB2YXIgYXhpcyA9IGF4ZXMuYXhpc1tQT1NJVElPTl9LRVldO1xuICAgIGF4aXMuY2lyY3VsYXIgPSBbY29udHJvbFBhcmFtcy5jaXJjdWxhciwgY29udHJvbFBhcmFtcy5jaXJjdWxhcl07XG4gICAgYXhpcy5yYW5nZSA9IFtjb250cm9sUGFyYW1zLnJhbmdlLm1pbiwgY29udHJvbFBhcmFtcy5yYW5nZS5tYXhdO1xuICAgIGF4aXMuYm91bmNlID0gcGFyc2VCb3VuY2UoZmxpY2tpbmcuYm91bmNlLCBjYW1lcmEuc2l6ZSk7XG4gICAgYXhlcy5heGlzTWFuYWdlci5zZXQoKF9hID0ge30sIF9hW1BPU0lUSU9OX0tFWV0gPSBjb250cm9sUGFyYW1zLnBvc2l0aW9uLCBfYSkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcclxuICAgKiBBdHRhY2ggYSBoYW5kbGVyIHRvIHRoZSBjYW1lcmEgZWxlbWVudCB0byBwcmV2ZW50IGNsaWNrIGV2ZW50cyBkdXJpbmcgYW5pbWF0aW9uXHJcbiAgICogQGtvIOy5tOuplOudvCDsl5jrpqzrqLztirjsl5Ag7JWg64uI66mU7J207IWYIOuPhOykkeyXkCDtgbTrpq0g7J2067Kk7Yq466W8IOuwqeyngO2VmOuKlCDtlbjrk6Trn6zrpbwg67aA7LCp7ZWp64uI64ukXHJcbiAgICogQHJldHVybiB7dGhpc31cclxuICAgKi9cbiAgX19wcm90by5hZGRQcmV2ZW50Q2xpY2tIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBmbGlja2luZyA9IGdldEZsaWNraW5nQXR0YWNoZWQodGhpcy5fZmxpY2tpbmcpO1xuICAgIHZhciBheGVzID0gdGhpcy5fYXhlcztcbiAgICB2YXIgY2FtZXJhRWwgPSBmbGlja2luZy5jYW1lcmEuZWxlbWVudDtcbiAgICBheGVzLm9uKEVWRU5ULkhPTEQsIHRoaXMuX29uQXhlc0hvbGQpO1xuICAgIGF4ZXMub24oRVZFTlQuQ0hBTkdFLCB0aGlzLl9vbkF4ZXNDaGFuZ2UpO1xuICAgIGNhbWVyYUVsLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl9wcmV2ZW50Q2xpY2tXaGVuRHJhZ2dlZCwgdHJ1ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxyXG4gICAqIERldGFjaCBhIGhhbmRsZXIgdG8gdGhlIGNhbWVyYSBlbGVtZW50IHRvIHByZXZlbnQgY2xpY2sgZXZlbnRzIGR1cmluZyBhbmltYXRpb25cclxuICAgKiBAa28g7Lm066mU6528IOyXmOumrOuovO2KuOyXkCDslaDri4jrqZTsnbTshZgg64+E7KSR7JeQIO2BtOumrSDsnbTrsqTtirjrpbwg67Cp7KeA7ZWY64qUIO2VuOuTpOufrOulvCDtg4jssKntlanri4jri6RcclxuICAgKiBAcmV0dXJuIHt0aGlzfVxyXG4gICAqL1xuICBfX3Byb3RvLnJlbW92ZVByZXZlbnRDbGlja0hhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZsaWNraW5nID0gZ2V0RmxpY2tpbmdBdHRhY2hlZCh0aGlzLl9mbGlja2luZyk7XG4gICAgdmFyIGF4ZXMgPSB0aGlzLl9heGVzO1xuICAgIHZhciBjYW1lcmFFbCA9IGZsaWNraW5nLmNhbWVyYS5lbGVtZW50O1xuICAgIGF4ZXMub2ZmKEVWRU5ULkhPTEQsIHRoaXMuX29uQXhlc0hvbGQpO1xuICAgIGF4ZXMub2ZmKEVWRU5ULkNIQU5HRSwgdGhpcy5fb25BeGVzQ2hhbmdlKTtcbiAgICBjYW1lcmFFbC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fcHJldmVudENsaWNrV2hlbkRyYWdnZWQsIHRydWUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcclxuICAgKiBSdW4gQXhlcydzIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWF4ZXMvcmVsZWFzZS9sYXRlc3QvZG9jL2VnLkF4ZXMuaHRtbCNzZXRUbyBzZXRUb30gdXNpbmcgdGhlIGdpdmVuIHBvc2l0aW9uXHJcbiAgICogQGtvIEF4ZXPsnZgge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtYXhlcy9yZWxlYXNlL2xhdGVzdC9kb2MvZWcuQXhlcy5odG1sI3NldFRvIHNldFRvfSDrqZTshozrk5zrpbwg7KO87Ja07KeEIOyijO2RnOulvCDsnbTsmqntlZjsl6wg7IiY7ZaJ7ZWp64uI64ukXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHBvc2l0aW9uIEEgcG9zaXRpb24gdG8gbW92ZTxrbz7snbTrj5ntlaAg7KKM7ZGcPC9rbz5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gZHVyYXRpb24gRHVyYXRpb24gb2YgdGhlIGFuaW1hdGlvbiAodW5pdDogbXMpPGtvPuyVoOuLiOuplOydtOyFmCDsp4Ttlokg7Iuc6rCEICjri6jsnIQ6IG1zKTwva28+XHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtheGVzRXZlbnRdIElmIHByb3ZpZGVkLCBpdCdsbCB1c2UgaXRzIHtAbGluayBodHRwczovL25hdmVyI2dpdGh1YiNpby9lZ2pzLWF4ZXMvcmVsZWFzZS9sYXRlc3QvZG9jL2VnI0F4ZXMjaHRtbCNzZXRUbyBzZXRUb30gbWV0aG9kIGluc3RlYWQ8a28+7J20IOqwkuydtCDso7zslrTsoYzsnYQg6rK97JqwLCDtlbTri7kg7J2067Kk7Yq47J2YIHtAbGluayBodHRwczovL25hdmVyI2dpdGh1YiNpby9lZ2pzLWF4ZXMvcmVsZWFzZS9sYXRlc3QvZG9jL2VnI0F4ZXMjaHRtbCNzZXRUbyBzZXRUb30g66mU7IaM65Oc66W8IOuMgOyLoO2VtOyEnCDsgqzsmqntlanri4jri6QuPC9rbz5cclxuICAgKiBAdGhyb3dzIHtGbGlja2luZ0Vycm9yfVxyXG4gICAqIHxjb2RlfGNvbmRpdGlvbnxcclxuICAgKiB8LS0tfC0tLXxcclxuICAgKiB8e0BsaW5rIEVSUk9SX0NPREUgTk9UX0FUVEFDSEVEX1RPX0ZMSUNLSU5HfXxXaGVuIHtAbGluayBDb250cm9sI2luaXQgaW5pdH0gaXMgbm90IGNhbGxlZCBiZWZvcmV8XHJcbiAgICogfHtAbGluayBFUlJPUl9DT0RFIEFOSU1BVElPTl9JTlRFUlJVUFRFRH18V2hlbiB0aGUgYW5pbWF0aW9uIGlzIGludGVycnVwdGVkIGJ5IHVzZXIgaW5wdXR8XHJcbiAgICogPGtvPlxyXG4gICAqXHJcbiAgICogfGNvZGV8Y29uZGl0aW9ufFxyXG4gICAqIHwtLS18LS0tfFxyXG4gICAqIHx7QGxpbmsgRVJST1JfQ09ERSBOT1RfQVRUQUNIRURfVE9fRkxJQ0tJTkd9fHtAbGluayBDb250cm9sI2luaXQgaW5pdH3snbQg7J207KCE7JeQIO2YuOy2nOuQmOyngCDslYrsnYAg6rK97JqwfFxyXG4gICAqIHx7QGxpbmsgRVJST1JfQ09ERSBBTklNQVRJT05fSU5URVJSVVBURUR9fOyCrOyaqeyekCDsnoXroKXsl5Ag7J2Y7ZW0IOyVoOuLiOuplOydtOyFmOydtCDspJHri6jrkJwg6rK97JqwfFxyXG4gICAqXHJcbiAgICogPC9rbz5cclxuICAgKiBAcmV0dXJuIHtQcm9taXNlPHZvaWQ+fSBBIFByb21pc2Ugd2hpY2ggd2lsbCBiZSByZXNvbHZlZCBhZnRlciByZWFjaGluZyB0aGUgdGFyZ2V0IHBvc2l0aW9uPGtvPu2VtOuLuSDsooztkZwg64+E64us7Iuc7JeQIHJlc29sdmXrkJjripQgUHJvbWlzZTwva28+XHJcbiAgICovXG4gIF9fcHJvdG8uYW5pbWF0ZVRvID0gZnVuY3Rpb24gKHBvc2l0aW9uLCBkdXJhdGlvbiwgYXhlc0V2ZW50KSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB2YXIgX2E7XG4gICAgdmFyIGF4ZXMgPSB0aGlzLl9heGVzO1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuX3N0YXRlTWFjaGluZS5zdGF0ZTtcbiAgICBpZiAoIWF4ZXMpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRmxpY2tpbmdFcnJvcihNRVNTQUdFLk5PVF9BVFRBQ0hFRF9UT19GTElDS0lORywgQ09ERS5OT1RfQVRUQUNIRURfVE9fRkxJQ0tJTkcpKTtcbiAgICB9XG4gICAgdmFyIHN0YXJ0UG9zID0gYXhlcy5nZXQoW1BPU0lUSU9OX0tFWV0pW1BPU0lUSU9OX0tFWV07XG4gICAgaWYgKHN0YXJ0UG9zID09PSBwb3NpdGlvbikge1xuICAgICAgdmFyIGZsaWNraW5nID0gZ2V0RmxpY2tpbmdBdHRhY2hlZCh0aGlzLl9mbGlja2luZyk7XG4gICAgICBmbGlja2luZy5jYW1lcmEubG9va0F0KHBvc2l0aW9uKTtcbiAgICAgIGlmIChzdGF0ZS50YXJnZXRQYW5lbCkge1xuICAgICAgICBmbGlja2luZy5jb250cm9sLnNldEFjdGl2ZShzdGF0ZS50YXJnZXRQYW5lbCwgZmxpY2tpbmcuY29udHJvbC5hY3RpdmVQYW5lbCwgKF9hID0gYXhlc0V2ZW50ID09PSBudWxsIHx8IGF4ZXNFdmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogYXhlc0V2ZW50LmlzVHJ1c3RlZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICB0aGlzLl9hbmltYXRpbmdDb250ZXh0ID0ge1xuICAgICAgc3RhcnQ6IHN0YXJ0UG9zLFxuICAgICAgZW5kOiBwb3NpdGlvbixcbiAgICAgIG9mZnNldDogMFxuICAgIH07XG4gICAgdmFyIGFuaW1hdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgdmFyIHJlc2V0Q29udGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMuX2FuaW1hdGluZ0NvbnRleHQgPSB7XG4gICAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgICAgZW5kOiAwLFxuICAgICAgICAgIG9mZnNldDogMFxuICAgICAgICB9O1xuICAgICAgfTtcbiAgICAgIGF4ZXMub25jZShFVkVOVC5GSU5JU0gsIHJlc2V0Q29udGV4dCk7XG4gICAgICBpZiAoYXhlc0V2ZW50KSB7XG4gICAgICAgIGF4ZXNFdmVudC5zZXRUbygoX2EgPSB7fSwgX2FbUE9TSVRJT05fS0VZXSA9IHBvc2l0aW9uLCBfYSksIGR1cmF0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF4ZXMuc2V0VG8oKF9iID0ge30sIF9iW1BPU0lUSU9OX0tFWV0gPSBwb3NpdGlvbiwgX2IpLCBkdXJhdGlvbik7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIGFuaW1hdGlvbkZpbmlzaEhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGF4ZXMub2ZmKEVWRU5ULkhPTEQsIGludGVycnVwdGlvbkhhbmRsZXIpO1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9O1xuICAgICAgdmFyIGludGVycnVwdGlvbkhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGF4ZXMub2ZmKEVWRU5ULkZJTklTSCwgYW5pbWF0aW9uRmluaXNoSGFuZGxlcik7XG4gICAgICAgIHJlamVjdChuZXcgRmxpY2tpbmdFcnJvcihNRVNTQUdFLkFOSU1BVElPTl9JTlRFUlJVUFRFRCwgQ09ERS5BTklNQVRJT05fSU5URVJSVVBURUQpKTtcbiAgICAgIH07XG4gICAgICBheGVzLm9uY2UoRVZFTlQuRklOSVNILCBhbmltYXRpb25GaW5pc2hIYW5kbGVyKTtcbiAgICAgIGF4ZXMub25jZShFVkVOVC5IT0xELCBpbnRlcnJ1cHRpb25IYW5kbGVyKTtcbiAgICAgIGFuaW1hdGUoKTtcbiAgICB9KTtcbiAgfTtcbiAgX19wcm90by51cGRhdGVEaXJlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZsaWNraW5nID0gZ2V0RmxpY2tpbmdBdHRhY2hlZCh0aGlzLl9mbGlja2luZyk7XG4gICAgdmFyIGF4ZXMgPSB0aGlzLl9heGVzO1xuICAgIHZhciBwYW5JbnB1dCA9IHRoaXMuX3BhbklucHV0O1xuICAgIGF4ZXMuZGlzY29ubmVjdChwYW5JbnB1dCk7XG4gICAgYXhlcy5jb25uZWN0KGZsaWNraW5nLmhvcml6b250YWwgPyBbUE9TSVRJT05fS0VZLCBcIlwiXSA6IFtcIlwiLCBQT1NJVElPTl9LRVldLCBwYW5JbnB1dCk7XG4gICAgcGFuSW5wdXQub3B0aW9ucy5zY2FsZSA9IGZsaWNraW5nLmhvcml6b250YWwgPyBbZmxpY2tpbmcuY2FtZXJhLnBhbmVsT3JkZXIgPT09IE9SREVSLlJUTCA/IDEgOiAtMSwgMF0gOiBbMCwgLTFdO1xuICB9O1xuICBfX3Byb3RvLl9yZXNldEludGVybmFsVmFsdWVzID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2ZsaWNraW5nID0gbnVsbDtcbiAgICB0aGlzLl9heGVzID0gbnVsbDtcbiAgICB0aGlzLl9wYW5JbnB1dCA9IG51bGw7XG4gICAgdGhpcy5fYW5pbWF0aW5nQ29udGV4dCA9IHtcbiAgICAgIHN0YXJ0OiAwLFxuICAgICAgZW5kOiAwLFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfTtcbiAgICB0aGlzLl9kcmFnZ2VkID0gZmFsc2U7XG4gIH07XG4gIHJldHVybiBBeGVzQ29udHJvbGxlcjtcbn0oKTtcblxuLyoqXHJcbiAqIEEgY29tcG9uZW50IHRoYXQgbWFuYWdlcyBpbnB1dHMgYW5kIGFuaW1hdGlvbiBvZiBGbGlja2luZ1xyXG4gKiBAa28gRmxpY2tpbmfsnZgg7J6F66ClIOyepey5mCAmIOyVoOuLiOuplOydtOyFmOydhCDri7Tri7ntlZjripQg7Lu07Y+s64SM7Yq4XHJcbiAqL1xudmFyIENvbnRyb2wgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKiogKi9cbiAgZnVuY3Rpb24gQ29udHJvbCgpIHtcbiAgICB0aGlzLl9mbGlja2luZyA9IG51bGw7XG4gICAgdGhpcy5fY29udHJvbGxlciA9IG5ldyBBeGVzQ29udHJvbGxlcigpO1xuICAgIHRoaXMuX2FjdGl2ZVBhbmVsID0gbnVsbDtcbiAgfVxuICB2YXIgX19wcm90byA9IENvbnRyb2wucHJvdG90eXBlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJjb250cm9sbGVyXCIsIHtcbiAgICAvKipcclxuICAgICAqIEEgY29udHJvbGxlciB0aGF0IGhhbmRsZXMgdGhlIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWF4ZXMvIEBlZ2pzL2F4ZXN9IGV2ZW50c1xyXG4gICAgICogQGtvIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWF4ZXMvIEBlZ2pzL2F4ZXN97J2YIOydtOuypO2KuOulvCDsspjrpqztlZjripQg7Luo7Yq466Gk65+sIOy7tO2PrOuEjO2KuFxyXG4gICAgICogQHR5cGUge0F4ZXNDb250cm9sbGVyfVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jb250cm9sbGVyO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJhY3RpdmVJbmRleFwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBJbmRleCBudW1iZXIgb2YgdGhlIHtAbGluayBGbGlja2luZyNjdXJyZW50UGFuZWwgY3VycmVudFBhbmVsfVxyXG4gICAgICogQGtvIHtAbGluayBGbGlja2luZyNjdXJyZW50UGFuZWwgY3VycmVudFBhbmVsfeydmCDsnbjrjbHsiqQg67KI7Zi4XHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgMFxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfYSwgX2I7XG4gICAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5fYWN0aXZlUGFuZWwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pbmRleCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogLTE7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcImFjdGl2ZVBhbmVsXCIsIHtcbiAgICAvKipcclxuICAgICAqIEFuIGFjdGl2ZSBwYW5lbFxyXG4gICAgICogQGtvIO2YhOyerCDshKDtg53rkJwg7Yyo64SQXHJcbiAgICAgKiBAdHlwZSB7UGFuZWwgfCBudWxsfVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9hY3RpdmVQYW5lbDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwiYW5pbWF0aW5nXCIsIHtcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgRmxpY2tpbmcncyBhbmltYXRpbmdcclxuICAgICAqIEBrbyDtmITsnqwg7JWg64uI66mU7J207IWYIOuPmeyekSDsl6zrtoBcclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jb250cm9sbGVyLnN0YXRlLmFuaW1hdGluZztcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwiaG9sZGluZ1wiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHVzZXIgaXMgY2xpY2tpbmcgb3IgdG91Y2hpbmdcclxuICAgICAqIEBrbyDtmITsnqwg7IKs7Jqp7J6Q6rCAIO2BtOumrS/thLDsuZjspJHsnbjsp4Ag7Jes67aAXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY29udHJvbGxlci5zdGF0ZS5ob2xkaW5nO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICAvKipcclxuICAgKiBJbml0aWFsaXplIENvbnRyb2xcclxuICAgKiBAa28gQ29udHJvbOydhCDstIjquLDtmZTtlanri4jri6RcclxuICAgKiBAcGFyYW0ge0ZsaWNraW5nfSBmbGlja2luZyBBbiBpbnN0YW5jZSBvZiB7QGxpbmsgRmxpY2tpbmd9PGtvPkZsaWNraW5n7J2YIOyduOyKpO2EtOyKpDwva28+XHJcbiAgICogQGNoYWluYWJsZVxyXG4gICAqIEByZXR1cm4ge3RoaXN9XHJcbiAgICovXG4gIF9fcHJvdG8uaW5pdCA9IGZ1bmN0aW9uIChmbGlja2luZykge1xuICAgIHRoaXMuX2ZsaWNraW5nID0gZmxpY2tpbmc7XG4gICAgdGhpcy5fY29udHJvbGxlci5pbml0KGZsaWNraW5nKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXHJcbiAgICogRGVzdHJveSBDb250cm9sIGFuZCByZXR1cm4gdG8gaW5pdGlhbCBzdGF0ZVxyXG4gICAqIEBrbyBDb250cm9s7J2EIOy0iOq4sCDsg4Htg5zroZwg65CY64+M66a964uI64ukXHJcbiAgICogQHJldHVybiB7dm9pZH1cclxuICAgKi9cbiAgX19wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2NvbnRyb2xsZXIuZGVzdHJveSgpO1xuICAgIHRoaXMuX2ZsaWNraW5nID0gbnVsbDtcbiAgICB0aGlzLl9hY3RpdmVQYW5lbCA9IG51bGw7XG4gIH07XG4gIC8qKlxyXG4gICAqIEVuYWJsZSBpbnB1dCBmcm9tIHRoZSB1c2VyIChtb3VzZS90b3VjaClcclxuICAgKiBAa28g7IKs7Jqp7J6Q7J2YIOyeheugpSjrp4jsmrDsiqQv7YSw7LmYKeulvCDtmZzshLHtmZTtlanri4jri6RcclxuICAgKiBAY2hhaW5hYmxlXHJcbiAgICogQHJldHVybiB7dGhpc31cclxuICAgKi9cbiAgX19wcm90by5lbmFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fY29udHJvbGxlci5lbmFibGUoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXHJcbiAgICogRGlzYWJsZSBpbnB1dCBmcm9tIHRoZSB1c2VyIChtb3VzZS90b3VjaClcclxuICAgKiBAa28g7IKs7Jqp7J6Q7J2YIOyeheugpSjrp4jsmrDsiqQv7YSw7LmYKeulvCDrp4nsirXri4jri6RcclxuICAgKiBAY2hhaW5hYmxlXHJcbiAgICogQHJldHVybiB7dGhpc31cclxuICAgKi9cbiAgX19wcm90by5kaXNhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2NvbnRyb2xsZXIuZGlzYWJsZSgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcclxuICAgKiBSZWxlYXNlcyBvbmdvaW5nIHVzZXIgaW5wdXQgKG1vdXNlL3RvdWNoKVxyXG4gICAqIEBrbyDsgqzsmqnsnpDsnZgg7ZiE7J6sIOyeheugpSjrp4jsmrDsiqQv7YSw7LmYKeulvCDspJHri6jsi5ztgrXri4jri6RcclxuICAgKiBAY2hhaW5hYmxlXHJcbiAgICogQHJldHVybiB7dGhpc31cclxuICAgKi9cbiAgX19wcm90by5yZWxlYXNlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2NvbnRyb2xsZXIucmVsZWFzZSgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcclxuICAgKiBDaGFuZ2UgdGhlIGRlc3RpbmF0aW9uIGFuZCBkdXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uIGN1cnJlbnRseSBwbGF5aW5nXHJcbiAgICogQGtvIOyerOyDnSDspJHsnbgg7JWg64uI66mU7J207IWY7J2YIOuqqeyggeyngOyZgCDsnqzsg50g7Iuc6rCE7J2EIOuzgOqyve2VqeuLiOuLpFxyXG4gICAqIEBwYXJhbSB7UGFuZWx9IHBhbmVsIFRoZSB0YXJnZXQgcGFuZWwgdG8gbW92ZTxrbz7snbTrj5ntlaAg7Yyo64SQPC9rbz5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gZHVyYXRpb24gRHVyYXRpb24gb2YgdGhlIGFuaW1hdGlvbiAodW5pdDogbXMpPGtvPuyVoOuLiOuplOydtOyFmCDsp4Ttlokg7Iuc6rCEICjri6jsnIQ6IG1zKTwva28+XHJcbiAgICogQHBhcmFtIHtESVJFQ1RJT059IGRpcmVjdGlvbiBEaXJlY3Rpb24gdG8gbW92ZSwgb25seSBhdmFpbGFibGUgaW4gdGhlIHtAbGluayBGbGlja2luZyNjaXJjdWxhciBjaXJjdWxhcn0gbW9kZTxrbz7snbTrj5ntlaAg67Cp7ZalLiB7QGxpbmsgRmxpY2tpbmcjY2lyY3VsYXIgY2lyY3VsYXJ9IOyYteyFmCDtmZzshLHtmZTsi5zsl5Drp4wg7IKs7JqpIOqwgOuKpe2VqeuLiOuLpDwva28+XHJcbiAgICogQGNoYWluYWJsZVxyXG4gICAqIEB0aHJvd3Mge0ZsaWNraW5nRXJyb3J9XHJcbiAgICoge0BsaW5rIEVSUk9SX0NPREUgUE9TSVRJT05fTk9UX1JFQUNIQUJMRX0gV2hlbiB0aGUgZ2l2ZW4gcGFuZWwgaXMgYWxyZWFkeSByZW1vdmVkIG9yIG5vdCBpbiB0aGUgQ2FtZXJhJ3Mge0BsaW5rIENhbWVyYSNyYW5nZSByYW5nZX1cclxuICAgKiA8a28+e0BsaW5rIEVSUk9SX0NPREUgUE9TSVRJT05fTk9UX1JFQUNIQUJMRX0g7KO87Ja07KeEIO2MqOuEkOydtCDsoJzqsbDrkJjsl4jqsbDrgpgsIENhbWVyYeydmCB7QGxpbmsgQ2FtZXJhI3JhbmdlIHJhbmdlfSDrsJbsl5Ag7J6I7J2EIOqyveyasDwva28+XHJcbiAgICogQHJldHVybiB7dGhpc31cclxuICAgKi9cbiAgX19wcm90by51cGRhdGVBbmltYXRpb24gPSBmdW5jdGlvbiAocGFuZWwsIGR1cmF0aW9uLCBkaXJlY3Rpb24pIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLl9jb250cm9sbGVyLnN0YXRlO1xuICAgIHZhciBwb3NpdGlvbiA9IHRoaXMuX2dldFBvc2l0aW9uKHBhbmVsLCBkaXJlY3Rpb24gIT09IG51bGwgJiYgZGlyZWN0aW9uICE9PSB2b2lkIDAgPyBkaXJlY3Rpb24gOiBESVJFQ1RJT04uTk9ORSk7XG4gICAgc3RhdGUudGFyZ2V0UGFuZWwgPSBwYW5lbDtcbiAgICB0aGlzLl9jb250cm9sbGVyLnVwZGF0ZUFuaW1hdGlvbihwb3NpdGlvbiwgZHVyYXRpb24pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcclxuICAgKiBTdG9wcyB0aGUgYW5pbWF0aW9uIGN1cnJlbnRseSBwbGF5aW5nXHJcbiAgICogQGtvIOyerOyDnSDspJHsnbgg7JWg64uI66mU7J207IWY7J2EIOykkeuLqOyLnO2CteuLiOuLpFxyXG4gICAqIEBjaGFpbmFibGVcclxuICAgKiBAcmV0dXJuIHt0aGlzfVxyXG4gICAqL1xuICBfX3Byb3RvLnN0b3BBbmltYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5fY29udHJvbGxlci5zdGF0ZTtcbiAgICBzdGF0ZS50YXJnZXRQYW5lbCA9IG51bGw7XG4gICAgdGhpcy5fY29udHJvbGxlci5zdG9wQW5pbWF0aW9uKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxyXG4gICAqIFVwZGF0ZSBwb3NpdGlvbiBhZnRlciByZXNpemluZ1xyXG4gICAqIEBrbyByZXNpemUg7J207ZuE7JeQIHBvc2l0aW9u7J2EIOyXheuNsOydtO2KuO2VqeuLiOuLpFxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwcm9ncmVzc0luUGFuZWwgUHJldmlvdXMgY2FtZXJhJ3MgcHJvZ3Jlc3MgaW4gYWN0aXZlIHBhbmVsIGJlZm9yZSByZXNpemU8a28+UmVzaXplIOydtOyghCDtmITsnqwg7ISg7YOd65CcIO2MqOuEkCDrgrTsl5DshJzsnZgg7Lm066mU6528IHByb2dyZXNzIOqwkjwva28+XHJcbiAgICogQHRocm93cyB7RmxpY2tpbmdFcnJvcn1cclxuICAgKiB7QGxpbmsgRVJST1JfQ09ERSBOT1RfQVRUQUNIRURfVE9fRkxJQ0tJTkd9IFdoZW4ge0BsaW5rIENhbWVyYSNpbml0IGluaXR9IGlzIG5vdCBjYWxsZWQgYmVmb3JlXHJcbiAgICogPGtvPntAbGluayBFUlJPUl9DT0RFIE5PVF9BVFRBQ0hFRF9UT19GTElDS0lOR30ge0BsaW5rIENhbWVyYSNpbml0IGluaXR97J20IOydtOyghOyXkCDtmLjstpzrkJjsp4Ag7JWK7J2AIOqyveyasDwva28+XHJcbiAgICogQGNoYWluYWJsZVxyXG4gICAqIEByZXR1cm4ge1Byb21pc2U8dm9pZD59XHJcbiAgICovXG4gIF9fcHJvdG8udXBkYXRlUG9zaXRpb24gPSBmdW5jdGlvbiAocHJvZ3Jlc3NJblBhbmVsKSB7XG4gICAgdmFyIGZsaWNraW5nID0gZ2V0RmxpY2tpbmdBdHRhY2hlZCh0aGlzLl9mbGlja2luZyk7XG4gICAgdmFyIGNhbWVyYSA9IGZsaWNraW5nLmNhbWVyYTtcbiAgICB2YXIgYWN0aXZlUGFuZWwgPSB0aGlzLl9hY3RpdmVQYW5lbDtcbiAgICBpZiAoYWN0aXZlUGFuZWwpIHtcbiAgICAgIGNhbWVyYS5sb29rQXQoY2FtZXJhLmNsYW1wVG9SZWFjaGFibGVQb3NpdGlvbihhY3RpdmVQYW5lbC5wb3NpdGlvbikpO1xuICAgIH1cbiAgfTtcbiAgLyoqXHJcbiAgICogVXBkYXRlIHtAbGluayBDb250cm9sI2NvbnRyb2xsZXIgY29udHJvbGxlcn0ncyBzdGF0ZVxyXG4gICAqIEBrbyB7QGxpbmsgQ29udHJvbCNjb250cm9sbGVyIGNvbnRyb2xsZXJ97J2YIOuCtOu2gCDsg4Htg5zrpbwg6rCx7Iug7ZWp64uI64ukXHJcbiAgICogQGNoYWluYWJsZVxyXG4gICAqIEByZXR1cm4ge3RoaXN9XHJcbiAgICovXG4gIF9fcHJvdG8udXBkYXRlSW5wdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZsaWNraW5nID0gZ2V0RmxpY2tpbmdBdHRhY2hlZCh0aGlzLl9mbGlja2luZyk7XG4gICAgdmFyIGNhbWVyYSA9IGZsaWNraW5nLmNhbWVyYTtcbiAgICB0aGlzLl9jb250cm9sbGVyLnVwZGF0ZShjYW1lcmEuY29udHJvbFBhcmFtcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxyXG4gICAqIFJlc2V0IHtAbGluayBDb250cm9sI2FjdGl2ZVBhbmVsIGFjdGl2ZVBhbmVsfSB0byBgbnVsbGBcclxuICAgKiBAa28ge0BsaW5rIENvbnRyb2wjYWN0aXZlUGFuZWwgYWN0aXZlUGFuZWx97J2EIGBudWxsYOuhnCDstIjquLDtmZTtlanri4jri6RcclxuICAgKiBAY2hhaW5hYmxlXHJcbiAgICogQHJldHVybiB7dGhpc31cclxuICAgKi9cbiAgX19wcm90by5yZXNldEFjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9hY3RpdmVQYW5lbCA9IG51bGw7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxyXG4gICAqIE1vdmUge0BsaW5rIENhbWVyYX0gdG8gdGhlIGdpdmVuIHBhbmVsXHJcbiAgICogQGtvIHtAbGluayBDYW1lcmF966W8IO2VtOuLuSDtjKjrhJAg7JyE66GcIOydtOuPme2VqeuLiOuLpFxyXG4gICAqIEBwYXJhbSB7UGFuZWx9IHBhbmVsIFRoZSB0YXJnZXQgcGFuZWwgdG8gbW92ZTxrbz7snbTrj5ntlaAg7Yyo64SQPC9rbz5cclxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBBbiBvcHRpb25zIG9iamVjdDxrbz7smLXshZgg7Jik67iM7KCd7Yq4PC9rbz5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gZHVyYXRpb24gRHVyYXRpb24gb2YgdGhlIGFuaW1hdGlvbiAodW5pdDogbXMpPGtvPuyVoOuLiOuplOydtOyFmCDsp4Ttlokg7Iuc6rCEICjri6jsnIQ6IG1zKTwva28+XHJcbiAgICogQHBhcmFtIHtvYmplY3R9IFtheGVzRXZlbnRdIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWF4ZXMvcmVsZWFzZS9sYXRlc3QvZG9jL2VnLkF4ZXMuaHRtbCNldmVudDpyZWxlYXNlIHJlbGVhc2V9IGV2ZW50IG9mIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWF4ZXMvIEF4ZXN9XHJcbiAgICogPGtvPntAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWF4ZXMvIEF4ZXN97J2YIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWF4ZXMvcmVsZWFzZS9sYXRlc3QvZG9jL2VnLkF4ZXMuaHRtbCNldmVudDpyZWxlYXNlIHJlbGVhc2V9IOydtOuypO2KuDwva28+XHJcbiAgICogQHBhcmFtIHtESVJFQ1RJT059IFtkaXJlY3Rpb249RElSRUNUSU9OLk5PTkVdIERpcmVjdGlvbiB0byBtb3ZlLCBvbmx5IGF2YWlsYWJsZSBpbiB0aGUge0BsaW5rIEZsaWNraW5nI2NpcmN1bGFyIGNpcmN1bGFyfSBtb2RlPGtvPuydtOuPme2VoCDrsKntlqUuIHtAbGluayBGbGlja2luZyNjaXJjdWxhciBjaXJjdWxhcn0g7Ji17IWYIO2ZnOyEse2ZlOyLnOyXkOunjCDsgqzsmqkg6rCA64ql7ZWp64uI64ukPC9rbz5cclxuICAgKiBAZmlyZXMgRmxpY2tpbmcjbW92ZVN0YXJ0XHJcbiAgICogQGZpcmVzIEZsaWNraW5nI21vdmVcclxuICAgKiBAZmlyZXMgRmxpY2tpbmcjbW92ZUVuZFxyXG4gICAqIEBmaXJlcyBGbGlja2luZyN3aWxsQ2hhbmdlXHJcbiAgICogQGZpcmVzIEZsaWNraW5nI2NoYW5nZWRcclxuICAgKiBAZmlyZXMgRmxpY2tpbmcjd2lsbFJlc3RvcmVcclxuICAgKiBAZmlyZXMgRmxpY2tpbmcjcmVzdG9yZWRcclxuICAgKiBAZmlyZXMgRmxpY2tpbmcjbmVlZFBhbmVsXHJcbiAgICogQGZpcmVzIEZsaWNraW5nI3Zpc2libGVDaGFuZ2VcclxuICAgKiBAZmlyZXMgRmxpY2tpbmcjcmVhY2hFZGdlXHJcbiAgICogQHRocm93cyB7RmxpY2tpbmdFcnJvcn1cclxuICAgKiB8Y29kZXxjb25kaXRpb258XHJcbiAgICogfC0tLXwtLS18XHJcbiAgICogfHtAbGluayBFUlJPUl9DT0RFIFBPU0lUSU9OX05PVF9SRUFDSEFCTEV9fFdoZW4gdGhlIGdpdmVuIHBhbmVsIGlzIGFscmVhZHkgcmVtb3ZlZCBvciBub3QgaW4gdGhlIENhbWVyYSdzIHtAbGluayBDYW1lcmEjcmFuZ2UgcmFuZ2V9fFxyXG4gICAqIHx7QGxpbmsgRVJST1JfQ09ERSBOT1RfQVRUQUNIRURfVE9fRkxJQ0tJTkd9fFdoZW4ge0BsaW5rIENvbnRyb2wjaW5pdCBpbml0fSBpcyBub3QgY2FsbGVkIGJlZm9yZXxcclxuICAgKiB8e0BsaW5rIEVSUk9SX0NPREUgQU5JTUFUSU9OX0lOVEVSUlVQVEVEfXxXaGVuIHRoZSBhbmltYXRpb24gaXMgaW50ZXJydXB0ZWQgYnkgdXNlciBpbnB1dHxcclxuICAgKiB8e0BsaW5rIEVSUk9SX0NPREUgU1RPUF9DQUxMRURfQllfVVNFUn18V2hlbiB0aGUgYW5pbWF0aW9uIGlzIGludGVycnVwdGVkIGJ5IHVzZXIgaW5wdXR8XHJcbiAgICogPGtvPlxyXG4gICAqXHJcbiAgICogfGNvZGV8Y29uZGl0aW9ufFxyXG4gICAqIHwtLS18LS0tfFxyXG4gICAqIHx7QGxpbmsgRVJST1JfQ09ERSBQT1NJVElPTl9OT1RfUkVBQ0hBQkxFfXzso7zslrTsp4Qg7Yyo64SQ7J20IOygnOqxsOuQmOyXiOqxsOuCmCwgQ2FtZXJh7J2YIHtAbGluayBDYW1lcmEjcmFuZ2UgcmFuZ2V9IOuwluyXkCDsnojsnYQg6rK97JqwfFxyXG4gICAqIHx7QGxpbmsgRVJST1JfQ09ERSBOT1RfQVRUQUNIRURfVE9fRkxJQ0tJTkd9fHtAbGluayBDb250cm9sI2luaXQgaW5pdH3snbQg7J207KCE7JeQIO2YuOy2nOuQmOyngCDslYrsnYAg6rK97JqwfFxyXG4gICAqIHx7QGxpbmsgRVJST1JfQ09ERSBBTklNQVRJT05fSU5URVJSVVBURUR9fOyCrOyaqeyekCDsnoXroKXsl5Ag7J2Y7ZW0IOyVoOuLiOuplOydtOyFmOydtCDspJHri6jrkJwg6rK97JqwfFxyXG4gICAqIHx7QGxpbmsgRVJST1JfQ09ERSBTVE9QX0NBTExFRF9CWV9VU0VSfXzrsJzsg53rkJwg7J2067Kk7Yq465OkIOykkSDtlZjrgpjrnbzrj4QgYHN0b3AoKWDsnbQg7Zi47Lac65CcIOqyveyasHxcclxuICAgKlxyXG4gICAqIDwva28+XHJcbiAgICogQHJldHVybiB7UHJvbWlzZTx2b2lkPn0gQSBQcm9taXNlIHdoaWNoIHdpbGwgYmUgcmVzb2x2ZWQgYWZ0ZXIgcmVhY2hpbmcgdGhlIHRhcmdldCBwYW5lbDxrbz7tlbTri7kg7Yyo64SQIOuPhOuLrOyLnOyXkCByZXNvbHZl65CY64qUIFByb21pc2U8L2tvPlxyXG4gICAqL1xuICBfX3Byb3RvLm1vdmVUb1BhbmVsID0gZnVuY3Rpb24gKHBhbmVsLCBfYSkge1xuICAgIHZhciBkdXJhdGlvbiA9IF9hLmR1cmF0aW9uLFxuICAgICAgX2IgPSBfYS5kaXJlY3Rpb24sXG4gICAgICBkaXJlY3Rpb24gPSBfYiA9PT0gdm9pZCAwID8gRElSRUNUSU9OLk5PTkUgOiBfYixcbiAgICAgIGF4ZXNFdmVudCA9IF9hLmF4ZXNFdmVudDtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcG9zaXRpb247XG4gICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9jKSB7XG4gICAgICAgIHBvc2l0aW9uID0gdGhpcy5fZ2V0UG9zaXRpb24ocGFuZWwsIGRpcmVjdGlvbik7XG4gICAgICAgIHRoaXMuX3RyaWdnZXJJbmRleENoYW5nZUV2ZW50KHBhbmVsLCBwYW5lbC5wb3NpdGlvbiwgYXhlc0V2ZW50LCBkaXJlY3Rpb24pO1xuICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5fYW5pbWF0ZVRvUG9zaXRpb24oe1xuICAgICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvbixcbiAgICAgICAgICBkdXJhdGlvbjogZHVyYXRpb24sXG4gICAgICAgICAgbmV3QWN0aXZlUGFuZWw6IHBhbmVsLFxuICAgICAgICAgIGF4ZXNFdmVudDogYXhlc0V2ZW50XG4gICAgICAgIH0pXTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuICAvKipcclxuICAgKiBAaW50ZXJuYWxcclxuICAgKi9cbiAgX19wcm90by5zZXRBY3RpdmUgPSBmdW5jdGlvbiAobmV3QWN0aXZlUGFuZWwsIHByZXZBY3RpdmVQYW5lbCwgaXNUcnVzdGVkKSB7XG4gICAgdmFyIF9hO1xuICAgIHZhciBmbGlja2luZyA9IGdldEZsaWNraW5nQXR0YWNoZWQodGhpcy5fZmxpY2tpbmcpO1xuICAgIHRoaXMuX2FjdGl2ZVBhbmVsID0gbmV3QWN0aXZlUGFuZWw7XG4gICAgdGhpcy5fbmV4dFBhbmVsID0gbnVsbDtcbiAgICBmbGlja2luZy5jYW1lcmEudXBkYXRlQWRhcHRpdmVIZWlnaHQoKTtcbiAgICBpZiAobmV3QWN0aXZlUGFuZWwgIT09IHByZXZBY3RpdmVQYW5lbCkge1xuICAgICAgZmxpY2tpbmcudHJpZ2dlcihuZXcgQ29tcG9uZW50RXZlbnQkMShFVkVOVFMuQ0hBTkdFRCwge1xuICAgICAgICBpbmRleDogbmV3QWN0aXZlUGFuZWwuaW5kZXgsXG4gICAgICAgIHBhbmVsOiBuZXdBY3RpdmVQYW5lbCxcbiAgICAgICAgcHJldkluZGV4OiAoX2EgPSBwcmV2QWN0aXZlUGFuZWwgPT09IG51bGwgfHwgcHJldkFjdGl2ZVBhbmVsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcmV2QWN0aXZlUGFuZWwuaW5kZXgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IC0xLFxuICAgICAgICBwcmV2UGFuZWw6IHByZXZBY3RpdmVQYW5lbCxcbiAgICAgICAgaXNUcnVzdGVkOiBpc1RydXN0ZWQsXG4gICAgICAgIGRpcmVjdGlvbjogcHJldkFjdGl2ZVBhbmVsID8gZ2V0RGlyZWN0aW9uJDEocHJldkFjdGl2ZVBhbmVsLnBvc2l0aW9uLCBuZXdBY3RpdmVQYW5lbC5wb3NpdGlvbikgOiBESVJFQ1RJT04uTk9ORVxuICAgICAgfSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmbGlja2luZy50cmlnZ2VyKG5ldyBDb21wb25lbnRFdmVudCQxKEVWRU5UUy5SRVNUT1JFRCwge1xuICAgICAgICBpc1RydXN0ZWQ6IGlzVHJ1c3RlZFxuICAgICAgfSkpO1xuICAgIH1cbiAgfTtcbiAgLyoqXHJcbiAgICogQGludGVybmFsXHJcbiAgICovXG4gIF9fcHJvdG8uY29weSA9IGZ1bmN0aW9uIChjb250cm9sKSB7XG4gICAgdGhpcy5fZmxpY2tpbmcgPSBjb250cm9sLl9mbGlja2luZztcbiAgICB0aGlzLl9hY3RpdmVQYW5lbCA9IGNvbnRyb2wuX2FjdGl2ZVBhbmVsO1xuICAgIHRoaXMuX2NvbnRyb2xsZXIgPSBjb250cm9sLl9jb250cm9sbGVyO1xuICB9O1xuICBfX3Byb3RvLl90cmlnZ2VySW5kZXhDaGFuZ2VFdmVudCA9IGZ1bmN0aW9uIChwYW5lbCwgcG9zaXRpb24sIGF4ZXNFdmVudCwgZGlyZWN0aW9uKSB7XG4gICAgdmFyIF9hO1xuICAgIHZhciBmbGlja2luZyA9IGdldEZsaWNraW5nQXR0YWNoZWQodGhpcy5fZmxpY2tpbmcpO1xuICAgIHZhciB0cmlnZ2VyaW5nRXZlbnQgPSBwYW5lbCAhPT0gdGhpcy5fYWN0aXZlUGFuZWwgPyBFVkVOVFMuV0lMTF9DSEFOR0UgOiBFVkVOVFMuV0lMTF9SRVNUT1JFO1xuICAgIHZhciBjYW1lcmEgPSBmbGlja2luZy5jYW1lcmE7XG4gICAgdmFyIGFjdGl2ZVBhbmVsID0gdGhpcy5fYWN0aXZlUGFuZWw7XG4gICAgdmFyIGV2ZW50ID0gbmV3IENvbXBvbmVudEV2ZW50JDEodHJpZ2dlcmluZ0V2ZW50LCB7XG4gICAgICBpbmRleDogcGFuZWwuaW5kZXgsXG4gICAgICBwYW5lbDogcGFuZWwsXG4gICAgICBpc1RydXN0ZWQ6IChheGVzRXZlbnQgPT09IG51bGwgfHwgYXhlc0V2ZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBheGVzRXZlbnQuaXNUcnVzdGVkKSB8fCBmYWxzZSxcbiAgICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uICE9PSBudWxsICYmIGRpcmVjdGlvbiAhPT0gdm9pZCAwID8gZGlyZWN0aW9uIDogZ2V0RGlyZWN0aW9uJDEoKF9hID0gYWN0aXZlUGFuZWwgPT09IG51bGwgfHwgYWN0aXZlUGFuZWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFjdGl2ZVBhbmVsLnBvc2l0aW9uKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjYW1lcmEucG9zaXRpb24sIHBvc2l0aW9uKVxuICAgIH0pO1xuICAgIHRoaXMuX25leHRQYW5lbCA9IHBhbmVsO1xuICAgIGZsaWNraW5nLnRyaWdnZXIoZXZlbnQpO1xuICAgIGlmIChldmVudC5pc0NhbmNlbGVkKCkpIHtcbiAgICAgIHRocm93IG5ldyBGbGlja2luZ0Vycm9yKE1FU1NBR0UuU1RPUF9DQUxMRURfQllfVVNFUiwgQ09ERS5TVE9QX0NBTExFRF9CWV9VU0VSKTtcbiAgICB9XG4gIH07XG4gIF9fcHJvdG8uX2FuaW1hdGVUb1Bvc2l0aW9uID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIHBvc2l0aW9uID0gX2EucG9zaXRpb24sXG4gICAgICBkdXJhdGlvbiA9IF9hLmR1cmF0aW9uLFxuICAgICAgbmV3QWN0aXZlUGFuZWwgPSBfYS5uZXdBY3RpdmVQYW5lbCxcbiAgICAgIGF4ZXNFdmVudCA9IF9hLmF4ZXNFdmVudDtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZmxpY2tpbmcsIGFuaW1hdGUsIHN0YXRlO1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgZmxpY2tpbmcgPSBnZXRGbGlja2luZ0F0dGFjaGVkKHRoaXMuX2ZsaWNraW5nKTtcbiAgICAgICAgYW5pbWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuX2NvbnRyb2xsZXIuYW5pbWF0ZVRvKHBvc2l0aW9uLCBkdXJhdGlvbiwgYXhlc0V2ZW50KTtcbiAgICAgICAgfTtcbiAgICAgICAgc3RhdGUgPSB0aGlzLl9jb250cm9sbGVyLnN0YXRlO1xuICAgICAgICBzdGF0ZS50YXJnZXRQYW5lbCA9IG5ld0FjdGl2ZVBhbmVsO1xuICAgICAgICBpZiAoZHVyYXRpb24gPD0gMCkge1xuICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBhbmltYXRlKCldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBhbmltYXRlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKF90aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBmbGlja2luZy5yZW5kZXJlci5yZW5kZXIoKV07XG4gICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoYXhlc0V2ZW50ICYmIGVyciBpbnN0YW5jZW9mIEZsaWNraW5nRXJyb3IgJiYgZXJyLmNvZGUgPT09IENPREUuQU5JTUFUSU9OX0lOVEVSUlVQVEVEKSByZXR1cm47XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfSldO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBfX3Byb3RvLl9nZXRQb3NpdGlvbiA9IGZ1bmN0aW9uIChwYW5lbCwgZGlyZWN0aW9uKSB7XG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gdm9pZCAwKSB7XG4gICAgICBkaXJlY3Rpb24gPSBESVJFQ1RJT04uTk9ORTtcbiAgICB9XG4gICAgdmFyIGZsaWNraW5nID0gZ2V0RmxpY2tpbmdBdHRhY2hlZCh0aGlzLl9mbGlja2luZyk7XG4gICAgdmFyIGNhbWVyYSA9IGZsaWNraW5nLmNhbWVyYTtcbiAgICB2YXIgcG9zaXRpb24gPSBwYW5lbC5wb3NpdGlvbjtcbiAgICB2YXIgbmVhcmVzdEFuY2hvciA9IGNhbWVyYS5maW5kTmVhcmVzdEFuY2hvcihwb3NpdGlvbik7XG4gICAgaWYgKHBhbmVsLnJlbW92ZWQgfHwgIW5lYXJlc3RBbmNob3IpIHtcbiAgICAgIHRocm93IG5ldyBGbGlja2luZ0Vycm9yKE1FU1NBR0UuUE9TSVRJT05fTk9UX1JFQUNIQUJMRShwYW5lbC5wb3NpdGlvbiksIENPREUuUE9TSVRJT05fTk9UX1JFQUNIQUJMRSk7XG4gICAgfVxuICAgIGlmICghY2FtZXJhLmNhblJlYWNoKHBhbmVsKSkge1xuICAgICAgLy8gT3ZlcnJpZGUgcG9zaXRpb24gJiBwYW5lbCBpZiB0aGF0IHBhbmVsIGlzIG5vdCByZWFjaGFibGVcbiAgICAgIHBvc2l0aW9uID0gbmVhcmVzdEFuY2hvci5wb3NpdGlvbjtcbiAgICAgIHBhbmVsID0gbmVhcmVzdEFuY2hvci5wYW5lbDtcbiAgICB9IGVsc2UgaWYgKGZsaWNraW5nLmNpcmN1bGFyRW5hYmxlZCkge1xuICAgICAgLy8gQ2lyY3VsYXIgbW9kZSBpcyBlbmFibGVkLCBmaW5kIG5lYXJlc3QgZGlzdGFuY2UgdG8gcGFuZWxcbiAgICAgIHZhciBjYW1Qb3NfMSA9IHRoaXMuX2NvbnRyb2xsZXIucG9zaXRpb247IC8vIEFjdHVhbCBwb3NpdGlvbiBvZiB0aGUgQXhlc1xuICAgICAgdmFyIGNhbVJhbmdlRGlmZiA9IGNhbWVyYS5yYW5nZURpZmY7XG4gICAgICB2YXIgcG9zc2libGVQb3NpdGlvbnMgPSBbcG9zaXRpb24sIHBvc2l0aW9uICsgY2FtUmFuZ2VEaWZmLCBwb3NpdGlvbiAtIGNhbVJhbmdlRGlmZl0uZmlsdGVyKGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gRElSRUNUSU9OLk5PTkUpIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gZGlyZWN0aW9uID09PSBESVJFQ1RJT04uUFJFViA/IHBvcyA8PSBjYW1Qb3NfMSA6IHBvcyA+PSBjYW1Qb3NfMTtcbiAgICAgIH0pO1xuICAgICAgcG9zaXRpb24gPSBwb3NzaWJsZVBvc2l0aW9ucy5yZWR1Y2UoZnVuY3Rpb24gKG5lYXJlc3RQb3NpdGlvbiwgcG9zKSB7XG4gICAgICAgIGlmIChNYXRoLmFicyhjYW1Qb3NfMSAtIHBvcykgPCBNYXRoLmFicyhjYW1Qb3NfMSAtIG5lYXJlc3RQb3NpdGlvbikpIHtcbiAgICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBuZWFyZXN0UG9zaXRpb247XG4gICAgICAgIH1cbiAgICAgIH0sIEluZmluaXR5KTtcbiAgICB9XG4gICAgcmV0dXJuIHBvc2l0aW9uO1xuICB9O1xuICByZXR1cm4gQ29udHJvbDtcbn0oKTtcblxuLyoqXHJcbiAqIEEgZGF0YSBjb21wb25lbnQgdGhhdCBoYXMgYWN0dWFsIHBvc2l0aW9uIHdoZXJlIHRoZSBjYW1lcmEgc2hvdWxkIGJlIHN0b3BwZWQgYXRcclxuICogQGtvIOy5tOuplOudvOqwgCDsoJXsp4DtlbTslbztlZjripQg7Iuk7KCcIOychOy5mOulvCDri7Tqs6Ag7J6I64qUIOuNsOydtO2EsCDsu7Ttj6zrhIztirhcclxuICovXG52YXIgQW5jaG9yUG9pbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcclxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBBbiBvcHRpb25zIG9iamVjdDxrbz7smLXshZgg6rCd7LK0PC9rbz5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuaW5kZXhdIEluZGV4IG9mIEFuY2hvclBvaW50PGtvPkFuY2hvclBvaW507J2YIOyduOuNseyKpDwva28+XHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnBvc2l0aW9uXSBQb3NpdGlvbiBvZiBBbmNob3JQb2ludDxrbz5BbmNob3JQb2ludOydmCDsooztkZw8L2tvPlxyXG4gICAqIEBwYXJhbSB7UGFuZWx9IFtvcHRpb25zLnBhbmVsXSBBIHtAbGluayBQYW5lbH0gaW5zdGFuY2UgQW5jaG9yUG9pbnQgaXMgcmVmZXJlbmNpbmcgdG88a28+QW5jaG9yUG9pbnTqsIAg7LC47KGw7ZWY6rOgIOyeiOuKlCB7QGxpbmsgUGFuZWx9PC9rbz5cclxuICAgKi9cbiAgZnVuY3Rpb24gQW5jaG9yUG9pbnQoX2EpIHtcbiAgICB2YXIgaW5kZXggPSBfYS5pbmRleCxcbiAgICAgIHBvc2l0aW9uID0gX2EucG9zaXRpb24sXG4gICAgICBwYW5lbCA9IF9hLnBhbmVsO1xuICAgIHRoaXMuX2luZGV4ID0gaW5kZXg7XG4gICAgdGhpcy5fcG9zID0gcG9zaXRpb247XG4gICAgdGhpcy5fcGFuZWwgPSBwYW5lbDtcbiAgfVxuICB2YXIgX19wcm90byA9IEFuY2hvclBvaW50LnByb3RvdHlwZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwiaW5kZXhcIiwge1xuICAgIC8qKlxyXG4gICAgICogSW5kZXggb2YgQW5jaG9yUG9pbnRcclxuICAgICAqIEBrbyBBbmNob3JQb2ludOydmCDsnbjrjbHsiqRcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2luZGV4O1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJwb3NpdGlvblwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBQb3NpdGlvbiBvZiBBbmNob3JQb2ludFxyXG4gICAgICogQGtvIEFuY2hvclBvaW507J2YIOyijO2RnFxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcG9zO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJwYW5lbFwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBBIHtAbGluayBQYW5lbH0gaW5zdGFuY2UgQW5jaG9yUG9pbnQgaXMgcmVmZXJlbmNpbmcgdG9cclxuICAgICAqIEBrbyBBbmNob3JQb2ludOqwgCDssLjsobDtlZjqs6Ag7J6I64qUIHtAbGluayBQYW5lbH1cclxuICAgICAqIEB0eXBlIHtQYW5lbH1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcGFuZWw7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIHJldHVybiBBbmNob3JQb2ludDtcbn0oKTtcblxuLyoqXHJcbiAqIEEge0BsaW5rIENvbnRyb2x9IHRoYXQgdXNlcyBhIHJlbGVhc2UgbW9tZW50dW0gdG8gY2hvb3NlIGRlc3RpbmF0aW9uIHBhbmVsXHJcbiAqIEBrbyDsnoXroKXsnYQg7KSR64uo7ZWcIOyLnOygkOydmCDqsIDsho3rj4Tsl5Ag7JiB7Zal67Cb7JWEIOuPhOuLrO2VoCDtjKjrhJDsnYQg6rOE7IKw7ZWY64qUIOydtOuPmSDrsKnsi53snYQg7IKs7Jqp7ZWY64qUIHtAbGluayBDb250cm9sfVxyXG4gKi9cbnZhciBTbmFwQ29udHJvbCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyQzKFNuYXBDb250cm9sLCBfc3VwZXIpO1xuICAvKiogKi9cbiAgZnVuY3Rpb24gU25hcENvbnRyb2woX2EpIHtcbiAgICB2YXIgX2IgPSAoX2EgPT09IHZvaWQgMCA/IHt9IDogX2EpLmNvdW50LFxuICAgICAgY291bnQgPSBfYiA9PT0gdm9pZCAwID8gSW5maW5pdHkgOiBfYjtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgIF90aGlzLl9jb3VudCA9IGNvdW50O1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICB2YXIgX19wcm90byA9IFNuYXBDb250cm9sLnByb3RvdHlwZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwiY291bnRcIiwge1xuICAgIC8qKlxyXG4gICAgICogTWF4aW11bSBudW1iZXIgb2YgcGFuZWxzIGNhbiBnbyBhZnRlciByZWxlYXNlXHJcbiAgICAgKiBAa28g7J6F66ClIOykkeuLqCDsnbTtm4Qg7Ya16rO87ZWY7JesIOydtOuPme2VoCDsiJgg7J6I64qUIO2MqOuEkOydmCDstZzrjIAg6rCv7IiYXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgSW5maW5pdHlcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NvdW50O1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICB0aGlzLl9jb3VudCA9IHZhbDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgLyoqXHJcbiAgICogTW92ZSB7QGxpbmsgQ2FtZXJhfSB0byB0aGUgZ2l2ZW4gcG9zaXRpb25cclxuICAgKiBAa28ge0BsaW5rIENhbWVyYX3rpbwg7KO87Ja07KeEIOyijO2RnOuhnCDsnbTrj5ntlanri4jri6RcclxuICAgKiBAcGFyYW0ge251bWJlcn0gcG9zaXRpb24gVGhlIHRhcmdldCBwb3NpdGlvbiB0byBtb3ZlPGtvPuydtOuPme2VoCDsooztkZw8L2tvPlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkdXJhdGlvbiBEdXJhdGlvbiBvZiB0aGUgcGFuZWwgbW92ZW1lbnQgYW5pbWF0aW9uICh1bml0OiBtcykuPGtvPu2MqOuEkCDsnbTrj5kg7JWg64uI66mU7J207IWYIOynhO2WiSDsi5zqsIQgKOuLqOychDogbXMpPC9rbz5cclxuICAgKiBAcGFyYW0ge29iamVjdH0gW2F4ZXNFdmVudF0ge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtYXhlcy9yZWxlYXNlL2xhdGVzdC9kb2MvZWcuQXhlcy5odG1sI2V2ZW50OnJlbGVhc2UgcmVsZWFzZX0gZXZlbnQgb2Yge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtYXhlcy8gQXhlc31cclxuICAgKiA8a28+e0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtYXhlcy8gQXhlc33snZgge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtYXhlcy9yZWxlYXNlL2xhdGVzdC9kb2MvZWcuQXhlcy5odG1sI2V2ZW50OnJlbGVhc2UgcmVsZWFzZX0g7J2067Kk7Yq4PC9rbz5cclxuICAgKiBAZmlyZXMgRmxpY2tpbmcjbW92ZVN0YXJ0XHJcbiAgICogQGZpcmVzIEZsaWNraW5nI21vdmVcclxuICAgKiBAZmlyZXMgRmxpY2tpbmcjbW92ZUVuZFxyXG4gICAqIEBmaXJlcyBGbGlja2luZyN3aWxsQ2hhbmdlXHJcbiAgICogQGZpcmVzIEZsaWNraW5nI2NoYW5nZWRcclxuICAgKiBAZmlyZXMgRmxpY2tpbmcjd2lsbFJlc3RvcmVcclxuICAgKiBAZmlyZXMgRmxpY2tpbmcjcmVzdG9yZWRcclxuICAgKiBAZmlyZXMgRmxpY2tpbmcjbmVlZFBhbmVsXHJcbiAgICogQGZpcmVzIEZsaWNraW5nI3Zpc2libGVDaGFuZ2VcclxuICAgKiBAZmlyZXMgRmxpY2tpbmcjcmVhY2hFZGdlXHJcbiAgICogQHRocm93cyB7RmxpY2tpbmdFcnJvcn1cclxuICAgKiB8Y29kZXxjb25kaXRpb258XHJcbiAgICogfC0tLXwtLS18XHJcbiAgICogfHtAbGluayBFUlJPUl9DT0RFIFBPU0lUSU9OX05PVF9SRUFDSEFCTEV9fFdoZW4gdGhlIGdpdmVuIHBhbmVsIGlzIGFscmVhZHkgcmVtb3ZlZCBvciBub3QgaW4gdGhlIENhbWVyYSdzIHtAbGluayBDYW1lcmEjcmFuZ2UgcmFuZ2V9fFxyXG4gICAqIHx7QGxpbmsgRVJST1JfQ09ERSBOT1RfQVRUQUNIRURfVE9fRkxJQ0tJTkd9fFdoZW4ge0BsaW5rIENvbnRyb2wjaW5pdCBpbml0fSBpcyBub3QgY2FsbGVkIGJlZm9yZXxcclxuICAgKiB8e0BsaW5rIEVSUk9SX0NPREUgQU5JTUFUSU9OX0lOVEVSUlVQVEVEfXxXaGVuIHRoZSBhbmltYXRpb24gaXMgaW50ZXJydXB0ZWQgYnkgdXNlciBpbnB1dHxcclxuICAgKiB8e0BsaW5rIEVSUk9SX0NPREUgU1RPUF9DQUxMRURfQllfVVNFUn18V2hlbiB0aGUgYW5pbWF0aW9uIGlzIGludGVycnVwdGVkIGJ5IHVzZXIgaW5wdXR8XHJcbiAgICogPGtvPlxyXG4gICAqXHJcbiAgICogfGNvZGV8Y29uZGl0aW9ufFxyXG4gICAqIHwtLS18LS0tfFxyXG4gICAqIHx7QGxpbmsgRVJST1JfQ09ERSBQT1NJVElPTl9OT1RfUkVBQ0hBQkxFfXzso7zslrTsp4Qg7Yyo64SQ7J20IOygnOqxsOuQmOyXiOqxsOuCmCwgQ2FtZXJh7J2YIHtAbGluayBDYW1lcmEjcmFuZ2UgcmFuZ2V9IOuwluyXkCDsnojsnYQg6rK97JqwfFxyXG4gICAqIHx7QGxpbmsgRVJST1JfQ09ERSBOT1RfQVRUQUNIRURfVE9fRkxJQ0tJTkd9fHtAbGluayBDb250cm9sI2luaXQgaW5pdH3snbQg7J207KCE7JeQIO2YuOy2nOuQmOyngCDslYrsnYAg6rK97JqwfFxyXG4gICAqIHx7QGxpbmsgRVJST1JfQ09ERSBBTklNQVRJT05fSU5URVJSVVBURUR9fOyCrOyaqeyekCDsnoXroKXsl5Ag7J2Y7ZW0IOyVoOuLiOuplOydtOyFmOydtCDspJHri6jrkJwg6rK97JqwfFxyXG4gICAqIHx7QGxpbmsgRVJST1JfQ09ERSBTVE9QX0NBTExFRF9CWV9VU0VSfXzrsJzsg53rkJwg7J2067Kk7Yq465OkIOykkSDtlZjrgpjrnbzrj4QgYHN0b3AoKWDsnbQg7Zi47Lac65CcIOqyveyasHxcclxuICAgKlxyXG4gICAqIDwva28+XHJcbiAgICogQHJldHVybiB7UHJvbWlzZTx2b2lkPn0gQSBQcm9taXNlIHdoaWNoIHdpbGwgYmUgcmVzb2x2ZWQgYWZ0ZXIgcmVhY2hpbmcgdGhlIHRhcmdldCBwb3NpdGlvbjxrbz7tlbTri7kg7KKM7ZGcIOuPhOuLrOyLnOyXkCByZXNvbHZl65CY64qUIFByb21pc2U8L2tvPlxyXG4gICAqL1xuICBfX3Byb3RvLm1vdmVUb1Bvc2l0aW9uID0gZnVuY3Rpb24gKHBvc2l0aW9uLCBkdXJhdGlvbiwgYXhlc0V2ZW50KSB7XG4gICAgdmFyIGZsaWNraW5nID0gZ2V0RmxpY2tpbmdBdHRhY2hlZCh0aGlzLl9mbGlja2luZyk7XG4gICAgdmFyIGNhbWVyYSA9IGZsaWNraW5nLmNhbWVyYTtcbiAgICB2YXIgYWN0aXZlQW5jaG9yID0gY2FtZXJhLmZpbmRBY3RpdmVBbmNob3IoKTtcbiAgICB2YXIgYW5jaG9yQXRDYW1lcmEgPSBjYW1lcmEuZmluZE5lYXJlc3RBbmNob3IoY2FtZXJhLnBvc2l0aW9uKTtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLl9jb250cm9sbGVyLnN0YXRlO1xuICAgIGlmICghYWN0aXZlQW5jaG9yIHx8ICFhbmNob3JBdENhbWVyYSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBGbGlja2luZ0Vycm9yKE1FU1NBR0UuUE9TSVRJT05fTk9UX1JFQUNIQUJMRShwb3NpdGlvbiksIENPREUuUE9TSVRJT05fTk9UX1JFQUNIQUJMRSkpO1xuICAgIH1cbiAgICB2YXIgc25hcFRocmVzaG9sZCA9IHRoaXMuX2NhbGNTbmFwVGhyZXNob2xkKGZsaWNraW5nLnRocmVzaG9sZCwgcG9zaXRpb24sIGFjdGl2ZUFuY2hvcik7XG4gICAgdmFyIHBvc0RlbHRhID0gZmxpY2tpbmcuYW5pbWF0aW5nID8gc3RhdGUuZGVsdGEgOiBwb3NpdGlvbiAtIGNhbWVyYS5wb3NpdGlvbjtcbiAgICB2YXIgYWJzUG9zRGVsdGEgPSBNYXRoLmFicyhwb3NEZWx0YSk7XG4gICAgdmFyIHNuYXBEZWx0YSA9IGF4ZXNFdmVudCAmJiBheGVzRXZlbnQuZGVsdGFbUE9TSVRJT05fS0VZXSAhPT0gMCA/IE1hdGguYWJzKGF4ZXNFdmVudC5kZWx0YVtQT1NJVElPTl9LRVldKSA6IGFic1Bvc0RlbHRhO1xuICAgIHZhciB0YXJnZXRBbmNob3I7XG4gICAgaWYgKHNuYXBEZWx0YSA+PSBzbmFwVGhyZXNob2xkICYmIHNuYXBEZWx0YSA+IDApIHtcbiAgICAgIC8vIE1vdmUgdG8gYW5jaG9yIGF0IHBvc2l0aW9uXG4gICAgICB0YXJnZXRBbmNob3IgPSB0aGlzLl9maW5kU25hcHBlZEFuY2hvcihwb3NpdGlvbiwgYW5jaG9yQXRDYW1lcmEpO1xuICAgIH0gZWxzZSBpZiAoYWJzUG9zRGVsdGEgPj0gZmxpY2tpbmcudGhyZXNob2xkICYmIGFic1Bvc0RlbHRhID4gMCkge1xuICAgICAgLy8gTW92ZSB0byB0aGUgYWRqYWNlbnQgcGFuZWxcbiAgICAgIHRhcmdldEFuY2hvciA9IHRoaXMuX2ZpbmRBZGphY2VudEFuY2hvcihwb3NpdGlvbiwgcG9zRGVsdGEsIGFuY2hvckF0Q2FtZXJhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRmFsbGJhY2sgdG8gbmVhcmVzdCBwYW5lbCBmcm9tIGN1cnJlbnQgY2FtZXJhXG4gICAgICByZXR1cm4gdGhpcy5tb3ZlVG9QYW5lbChhbmNob3JBdENhbWVyYS5wYW5lbCwge1xuICAgICAgICBkdXJhdGlvbjogZHVyYXRpb24sXG4gICAgICAgIGF4ZXNFdmVudDogYXhlc0V2ZW50XG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fdHJpZ2dlckluZGV4Q2hhbmdlRXZlbnQodGFyZ2V0QW5jaG9yLnBhbmVsLCBwb3NpdGlvbiwgYXhlc0V2ZW50KTtcbiAgICByZXR1cm4gdGhpcy5fYW5pbWF0ZVRvUG9zaXRpb24oe1xuICAgICAgcG9zaXRpb246IGNhbWVyYS5jbGFtcFRvUmVhY2hhYmxlUG9zaXRpb24odGFyZ2V0QW5jaG9yLnBvc2l0aW9uKSxcbiAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbixcbiAgICAgIG5ld0FjdGl2ZVBhbmVsOiB0YXJnZXRBbmNob3IucGFuZWwsXG4gICAgICBheGVzRXZlbnQ6IGF4ZXNFdmVudFxuICAgIH0pO1xuICB9O1xuICBfX3Byb3RvLl9maW5kU25hcHBlZEFuY2hvciA9IGZ1bmN0aW9uIChwb3NpdGlvbiwgYW5jaG9yQXRDYW1lcmEpIHtcbiAgICB2YXIgZmxpY2tpbmcgPSBnZXRGbGlja2luZ0F0dGFjaGVkKHRoaXMuX2ZsaWNraW5nKTtcbiAgICB2YXIgY2FtZXJhID0gZmxpY2tpbmcuY2FtZXJhO1xuICAgIHZhciBjb3VudCA9IHRoaXMuX2NvdW50O1xuICAgIHZhciBjdXJyZW50UG9zID0gY2FtZXJhLnBvc2l0aW9uO1xuICAgIHZhciBjbGFtcGVkUG9zaXRpb24gPSBjYW1lcmEuY2xhbXBUb1JlYWNoYWJsZVBvc2l0aW9uKHBvc2l0aW9uKTtcbiAgICB2YXIgYW5jaG9yQXRQb3NpdGlvbiA9IGNhbWVyYS5maW5kQW5jaG9ySW5jbHVkZVBvc2l0aW9uKGNsYW1wZWRQb3NpdGlvbik7XG4gICAgaWYgKCFhbmNob3JBdENhbWVyYSB8fCAhYW5jaG9yQXRQb3NpdGlvbikge1xuICAgICAgdGhyb3cgbmV3IEZsaWNraW5nRXJyb3IoTUVTU0FHRS5QT1NJVElPTl9OT1RfUkVBQ0hBQkxFKHBvc2l0aW9uKSwgQ09ERS5QT1NJVElPTl9OT1RfUkVBQ0hBQkxFKTtcbiAgICB9XG4gICAgaWYgKCFpc0Zpbml0ZShjb3VudCkpIHtcbiAgICAgIHJldHVybiBhbmNob3JBdFBvc2l0aW9uO1xuICAgIH1cbiAgICB2YXIgcGFuZWxDb3VudCA9IGZsaWNraW5nLnBhbmVsQ291bnQ7XG4gICAgdmFyIGFuY2hvcnMgPSBjYW1lcmEuYW5jaG9yUG9pbnRzO1xuICAgIHZhciBsb29wQ291bnQgPSBNYXRoLnNpZ24ocG9zaXRpb24gLSBjdXJyZW50UG9zKSAqIE1hdGguZmxvb3IoTWF0aC5hYnMocG9zaXRpb24gLSBjdXJyZW50UG9zKSAvIGNhbWVyYS5yYW5nZURpZmYpO1xuICAgIGlmIChwb3NpdGlvbiA+IGN1cnJlbnRQb3MgJiYgYW5jaG9yQXRQb3NpdGlvbi5pbmRleCA8IGFuY2hvckF0Q2FtZXJhLmluZGV4IHx8IGFuY2hvckF0UG9zaXRpb24ucG9zaXRpb24gPiBhbmNob3JBdENhbWVyYS5wb3NpdGlvbiAmJiBhbmNob3JBdFBvc2l0aW9uLmluZGV4ID09PSBhbmNob3JBdENhbWVyYS5pbmRleCkge1xuICAgICAgbG9vcENvdW50ICs9IDE7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA8IGN1cnJlbnRQb3MgJiYgYW5jaG9yQXRQb3NpdGlvbi5pbmRleCA+IGFuY2hvckF0Q2FtZXJhLmluZGV4IHx8IGFuY2hvckF0UG9zaXRpb24ucG9zaXRpb24gPCBhbmNob3JBdENhbWVyYS5wb3NpdGlvbiAmJiBhbmNob3JBdFBvc2l0aW9uLmluZGV4ID09PSBhbmNob3JBdENhbWVyYS5pbmRleCkge1xuICAgICAgbG9vcENvdW50IC09IDE7XG4gICAgfVxuICAgIHZhciBjaXJjdWxhckluZGV4T2Zmc2V0ID0gbG9vcENvdW50ICogcGFuZWxDb3VudDtcbiAgICB2YXIgYW5jaG9yQXRQb3NpdGlvbkluZGV4ID0gYW5jaG9yQXRQb3NpdGlvbi5pbmRleCArIGNpcmN1bGFySW5kZXhPZmZzZXQ7XG4gICAgaWYgKE1hdGguYWJzKGFuY2hvckF0UG9zaXRpb25JbmRleCAtIGFuY2hvckF0Q2FtZXJhLmluZGV4KSA8PSBjb3VudCkge1xuICAgICAgdmFyIGFuY2hvciA9IGFuY2hvcnNbYW5jaG9yQXRQb3NpdGlvbi5pbmRleF07XG4gICAgICByZXR1cm4gbmV3IEFuY2hvclBvaW50KHtcbiAgICAgICAgaW5kZXg6IGFuY2hvci5pbmRleCxcbiAgICAgICAgcG9zaXRpb246IGFuY2hvci5wb3NpdGlvbiArIGxvb3BDb3VudCAqIGNhbWVyYS5yYW5nZURpZmYsXG4gICAgICAgIHBhbmVsOiBhbmNob3IucGFuZWxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoZmxpY2tpbmcuY2lyY3VsYXJFbmFibGVkKSB7XG4gICAgICB2YXIgdGFyZ2V0QW5jaG9yID0gYW5jaG9yc1tjaXJjdWxhdGVJbmRleChhbmNob3JBdENhbWVyYS5pbmRleCArIE1hdGguc2lnbihwb3NpdGlvbiAtIGN1cnJlbnRQb3MpICogY291bnQsIHBhbmVsQ291bnQpXTtcbiAgICAgIHZhciBsb29wID0gTWF0aC5mbG9vcihjb3VudCAvIHBhbmVsQ291bnQpO1xuICAgICAgaWYgKHBvc2l0aW9uID4gY3VycmVudFBvcyAmJiB0YXJnZXRBbmNob3IuaW5kZXggPCBhbmNob3JBdENhbWVyYS5pbmRleCkge1xuICAgICAgICBsb29wICs9IDE7XG4gICAgICB9IGVsc2UgaWYgKHBvc2l0aW9uIDwgY3VycmVudFBvcyAmJiB0YXJnZXRBbmNob3IuaW5kZXggPiBhbmNob3JBdENhbWVyYS5pbmRleCkge1xuICAgICAgICBsb29wIC09IDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IEFuY2hvclBvaW50KHtcbiAgICAgICAgaW5kZXg6IHRhcmdldEFuY2hvci5pbmRleCxcbiAgICAgICAgcG9zaXRpb246IHRhcmdldEFuY2hvci5wb3NpdGlvbiArIGxvb3AgKiBjYW1lcmEucmFuZ2VEaWZmLFxuICAgICAgICBwYW5lbDogdGFyZ2V0QW5jaG9yLnBhbmVsXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGFuY2hvcnNbY2xhbXAkMShhbmNob3JBdENhbWVyYS5pbmRleCArIE1hdGguc2lnbihwb3NpdGlvbiAtIGN1cnJlbnRQb3MpICogY291bnQsIDAsIGFuY2hvcnMubGVuZ3RoIC0gMSldO1xuICAgIH1cbiAgfTtcbiAgX19wcm90by5fZmluZEFkamFjZW50QW5jaG9yID0gZnVuY3Rpb24gKHBvc2l0aW9uLCBwb3NEZWx0YSwgYW5jaG9yQXRDYW1lcmEpIHtcbiAgICB2YXIgX2E7XG4gICAgdmFyIGZsaWNraW5nID0gZ2V0RmxpY2tpbmdBdHRhY2hlZCh0aGlzLl9mbGlja2luZyk7XG4gICAgdmFyIGNhbWVyYSA9IGZsaWNraW5nLmNhbWVyYTtcbiAgICBpZiAoY2FtZXJhLmNpcmN1bGFyRW5hYmxlZCkge1xuICAgICAgdmFyIGFuY2hvckluY2x1ZGVQb3NpdGlvbiA9IGNhbWVyYS5maW5kQW5jaG9ySW5jbHVkZVBvc2l0aW9uKHBvc2l0aW9uKTtcbiAgICAgIGlmIChhbmNob3JJbmNsdWRlUG9zaXRpb24gJiYgYW5jaG9ySW5jbHVkZVBvc2l0aW9uLnBvc2l0aW9uICE9PSBhbmNob3JBdENhbWVyYS5wb3NpdGlvbikge1xuICAgICAgICByZXR1cm4gYW5jaG9ySW5jbHVkZVBvc2l0aW9uO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgYWRqYWNlbnRBbmNob3IgPSAoX2EgPSBwb3NEZWx0YSA+IDAgPyBjYW1lcmEuZ2V0TmV4dEFuY2hvcihhbmNob3JBdENhbWVyYSkgOiBjYW1lcmEuZ2V0UHJldkFuY2hvcihhbmNob3JBdENhbWVyYSkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGFuY2hvckF0Q2FtZXJhO1xuICAgIHJldHVybiBhZGphY2VudEFuY2hvcjtcbiAgfTtcbiAgX19wcm90by5fY2FsY1NuYXBUaHJlc2hvbGQgPSBmdW5jdGlvbiAodGhyZXNob2xkLCBwb3NpdGlvbiwgYWN0aXZlQW5jaG9yKSB7XG4gICAgdmFyIGlzTmV4dERpcmVjdGlvbiA9IHBvc2l0aW9uID4gYWN0aXZlQW5jaG9yLnBvc2l0aW9uO1xuICAgIHZhciBwYW5lbCA9IGFjdGl2ZUFuY2hvci5wYW5lbDtcbiAgICB2YXIgcGFuZWxTaXplID0gcGFuZWwuc2l6ZTtcbiAgICB2YXIgYWxpZ25Qb3MgPSBwYW5lbC5hbGlnblBvc2l0aW9uO1xuICAgIC8vIE1pbmltdW0gZGlzdGFuY2UgbmVlZGVkIHRvIGRlY2lkZSBwcmV2L25leHQgcGFuZWwgYXMgbmVhcmVzdFxuICAgIC8qXHJcbiAgICAgKiB8ICBQcmV2ICB8ICAgICBOZXh0ICAgICB8XHJcbiAgICAgKiB8PC0tLS0tLT58PC0tLS0tLS0tLS0tLT58XHJcbiAgICAgKiBbICAgICAgICB8PC1BbmNob3IgICAgICBdXHJcbiAgICAgKi9cbiAgICByZXR1cm4gTWF0aC5tYXgodGhyZXNob2xkLCBpc05leHREaXJlY3Rpb24gPyBwYW5lbFNpemUgLSBhbGlnblBvcyArIHBhbmVsLm1hcmdpbi5uZXh0IDogYWxpZ25Qb3MgKyBwYW5lbC5tYXJnaW4ucHJldik7XG4gIH07XG4gIHJldHVybiBTbmFwQ29udHJvbDtcbn0oQ29udHJvbCk7XG5cbi8qKlxyXG4gKiBBIHtAbGluayBDb250cm9sfSB0aGF0IGNhbiBiZSBzY3JvbGxlZCBmcmVlbHkgd2l0aG91dCBhbGlnbm1lbnRcclxuICogQGtvIO2MqOuEkOydtCDsoJXtlbTsp4Qg7KeA7KCQ7JeQIOygleugrOuQmOyngCDslYrqs6AsIOyekOycoOuhreqyjCDsiqTtgazroaTtlaAg7IiYIOyeiOuKlCDsnbTrj5kg67Cp7Iud7J2EIOyCrOyaqe2VmOuKlCB7QGxpbmsgQ29udHJvbH1cclxuICovXG52YXIgRnJlZUNvbnRyb2wgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMkMyhGcmVlQ29udHJvbCwgX3N1cGVyKTtcbiAgLyoqICovXG4gIGZ1bmN0aW9uIEZyZWVDb250cm9sKF9hKSB7XG4gICAgdmFyIF9iID0gKF9hID09PSB2b2lkIDAgPyB7fSA6IF9hKS5zdG9wQXRFZGdlLFxuICAgICAgc3RvcEF0RWRnZSA9IF9iID09PSB2b2lkIDAgPyB0cnVlIDogX2I7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICBfdGhpcy5fc3RvcEF0RWRnZSA9IHN0b3BBdEVkZ2U7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIHZhciBfX3Byb3RvID0gRnJlZUNvbnRyb2wucHJvdG90eXBlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJzdG9wQXRFZGdlXCIsIHtcbiAgICAvKipcclxuICAgICAqIE1ha2Ugc2Nyb2xsIGFuaW1hdGlvbiB0byBzdG9wIGF0IHRoZSBzdGFydC9lbmQgb2YgdGhlIHNjcm9sbCBhcmVhLCBub3QgZ29pbmcgb3V0IHRoZSBib3VuY2UgYXJlYVxyXG4gICAgICogQGtvIOyKpO2BrOuhpCDslaDri4jrqZTsnbTshZjsnYQg7Iqk7YGs66GkIOyYgeyXreydmCDsi5zsnpHqs7wg64Gd67aA67aE7JeQ7IScIOupiOy2lOuPhOuhnSDtlZjsl6wsIOuwlOyatOyKpCDsmIHsl63snYQg64SY7Ja06rCA7KeAIOyViuuPhOuhnSDtlanri4jri6RcclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICogQGRlZmF1bHQgdHJ1ZVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3RvcEF0RWRnZTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgdGhpcy5fc3RvcEF0RWRnZSA9IHZhbDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgLyoqXHJcbiAgICogVXBkYXRlIHBvc2l0aW9uIGFmdGVyIHJlc2l6aW5nXHJcbiAgICogQGtvIHJlc2l6ZSDsnbTtm4Tsl5AgcG9zaXRpb27snYQg7JeF642w7J207Yq47ZWp64uI64ukXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHByb2dyZXNzSW5QYW5lbCBQcmV2aW91cyBjYW1lcmEncyBwcm9ncmVzcyBpbiBhY3RpdmUgcGFuZWwgYmVmb3JlIHJlc2l6ZTxrbz5SZXNpemUg7J207KCEIO2YhOyerCDshKDtg53rkJwg7Yyo64SQIOuCtOyXkOyEnOydmCDsubTrqZTrnbwgcHJvZ3Jlc3Mg6rCSPC9rbz5cclxuICAgKiBAdGhyb3dzIHtGbGlja2luZ0Vycm9yfVxyXG4gICAqIHtAbGluayBFUlJPUl9DT0RFIE5PVF9BVFRBQ0hFRF9UT19GTElDS0lOR30gV2hlbiB7QGxpbmsgQ2FtZXJhI2luaXQgaW5pdH0gaXMgbm90IGNhbGxlZCBiZWZvcmVcclxuICAgKiA8a28+e0BsaW5rIEVSUk9SX0NPREUgTk9UX0FUVEFDSEVEX1RPX0ZMSUNLSU5HfSB7QGxpbmsgQ2FtZXJhI2luaXQgaW5pdH3snbQg7J207KCE7JeQIO2YuOy2nOuQmOyngCDslYrsnYAg6rK97JqwPC9rbz5cclxuICAgKiBAY2hhaW5hYmxlXHJcbiAgICogQHJldHVybiB7UHJvbWlzZTx2b2lkPn1cclxuICAgKi9cbiAgX19wcm90by51cGRhdGVQb3NpdGlvbiA9IGZ1bmN0aW9uIChwcm9ncmVzc0luUGFuZWwpIHtcbiAgICB2YXIgZmxpY2tpbmcgPSBnZXRGbGlja2luZ0F0dGFjaGVkKHRoaXMuX2ZsaWNraW5nKTtcbiAgICB2YXIgY2FtZXJhID0gZmxpY2tpbmcuY2FtZXJhO1xuICAgIHZhciBhY3RpdmVQYW5lbCA9IHRoaXMuX2FjdGl2ZVBhbmVsO1xuICAgIGlmIChhY3RpdmVQYW5lbCkge1xuICAgICAgdmFyIHBhbmVsUmFuZ2UgPSBhY3RpdmVQYW5lbC5yYW5nZTtcbiAgICAgIHZhciBuZXdQb3NpdGlvbiA9IHBhbmVsUmFuZ2UubWluICsgKHBhbmVsUmFuZ2UubWF4IC0gcGFuZWxSYW5nZS5taW4pICogcHJvZ3Jlc3NJblBhbmVsO1xuICAgICAgY2FtZXJhLmxvb2tBdChjYW1lcmEuY2xhbXBUb1JlYWNoYWJsZVBvc2l0aW9uKG5ld1Bvc2l0aW9uKSk7XG4gICAgfVxuICB9O1xuICAvKipcclxuICAgKiBNb3ZlIHtAbGluayBDYW1lcmF9IHRvIHRoZSBnaXZlbiBwb3NpdGlvblxyXG4gICAqIEBrbyB7QGxpbmsgQ2FtZXJhfeulvCDso7zslrTsp4Qg7KKM7ZGc66GcIOydtOuPme2VqeuLiOuLpFxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwb3NpdGlvbiBUaGUgdGFyZ2V0IHBvc2l0aW9uIHRvIG1vdmU8a28+7J2064+Z7ZWgIOyijO2RnDwva28+XHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGR1cmF0aW9uIER1cmF0aW9uIG9mIHRoZSBwYW5lbCBtb3ZlbWVudCBhbmltYXRpb24gKHVuaXQ6IG1zKS48a28+7Yyo64SQIOydtOuPmSDslaDri4jrqZTsnbTshZgg7KeE7ZaJIOyLnOqwhCAo64uo7JyEOiBtcyk8L2tvPlxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbYXhlc0V2ZW50XSB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1heGVzL3JlbGVhc2UvbGF0ZXN0L2RvYy9lZy5BeGVzLmh0bWwjZXZlbnQ6cmVsZWFzZSByZWxlYXNlfSBldmVudCBvZiB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1heGVzLyBBeGVzfVxyXG4gICAqIDxrbz57QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1heGVzLyBBeGVzfeydmCB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1heGVzL3JlbGVhc2UvbGF0ZXN0L2RvYy9lZy5BeGVzLmh0bWwjZXZlbnQ6cmVsZWFzZSByZWxlYXNlfSDsnbTrsqTtirg8L2tvPlxyXG4gICAqIEBmaXJlcyBGbGlja2luZyNtb3ZlU3RhcnRcclxuICAgKiBAZmlyZXMgRmxpY2tpbmcjbW92ZVxyXG4gICAqIEBmaXJlcyBGbGlja2luZyNtb3ZlRW5kXHJcbiAgICogQGZpcmVzIEZsaWNraW5nI3dpbGxDaGFuZ2VcclxuICAgKiBAZmlyZXMgRmxpY2tpbmcjY2hhbmdlZFxyXG4gICAqIEBmaXJlcyBGbGlja2luZyN3aWxsUmVzdG9yZVxyXG4gICAqIEBmaXJlcyBGbGlja2luZyNyZXN0b3JlZFxyXG4gICAqIEBmaXJlcyBGbGlja2luZyNuZWVkUGFuZWxcclxuICAgKiBAZmlyZXMgRmxpY2tpbmcjdmlzaWJsZUNoYW5nZVxyXG4gICAqIEBmaXJlcyBGbGlja2luZyNyZWFjaEVkZ2VcclxuICAgKiBAdGhyb3dzIHtGbGlja2luZ0Vycm9yfVxyXG4gICAqIHxjb2RlfGNvbmRpdGlvbnxcclxuICAgKiB8LS0tfC0tLXxcclxuICAgKiB8e0BsaW5rIEVSUk9SX0NPREUgUE9TSVRJT05fTk9UX1JFQUNIQUJMRX18V2hlbiB0aGUgZ2l2ZW4gcGFuZWwgaXMgYWxyZWFkeSByZW1vdmVkIG9yIG5vdCBpbiB0aGUgQ2FtZXJhJ3Mge0BsaW5rIENhbWVyYSNyYW5nZSByYW5nZX18XHJcbiAgICogfHtAbGluayBFUlJPUl9DT0RFIE5PVF9BVFRBQ0hFRF9UT19GTElDS0lOR318V2hlbiB7QGxpbmsgQ29udHJvbCNpbml0IGluaXR9IGlzIG5vdCBjYWxsZWQgYmVmb3JlfFxyXG4gICAqIHx7QGxpbmsgRVJST1JfQ09ERSBBTklNQVRJT05fSU5URVJSVVBURUR9fFdoZW4gdGhlIGFuaW1hdGlvbiBpcyBpbnRlcnJ1cHRlZCBieSB1c2VyIGlucHV0fFxyXG4gICAqIHx7QGxpbmsgRVJST1JfQ09ERSBTVE9QX0NBTExFRF9CWV9VU0VSfXxXaGVuIHRoZSBhbmltYXRpb24gaXMgaW50ZXJydXB0ZWQgYnkgdXNlciBpbnB1dHxcclxuICAgKiA8a28+XHJcbiAgICpcclxuICAgKiB8Y29kZXxjb25kaXRpb258XHJcbiAgICogfC0tLXwtLS18XHJcbiAgICogfHtAbGluayBFUlJPUl9DT0RFIFBPU0lUSU9OX05PVF9SRUFDSEFCTEV9fOyjvOyWtOynhCDtjKjrhJDsnbQg7KCc6rGw65CY7JeI6rGw64KYLCBDYW1lcmHsnZgge0BsaW5rIENhbWVyYSNyYW5nZSByYW5nZX0g67CW7JeQIOyeiOydhCDqsr3smrB8XHJcbiAgICogfHtAbGluayBFUlJPUl9DT0RFIE5PVF9BVFRBQ0hFRF9UT19GTElDS0lOR318e0BsaW5rIENvbnRyb2wjaW5pdCBpbml0feydtCDsnbTsoITsl5Ag7Zi47Lac65CY7KeAIOyViuydgCDqsr3smrB8XHJcbiAgICogfHtAbGluayBFUlJPUl9DT0RFIEFOSU1BVElPTl9JTlRFUlJVUFRFRH187IKs7Jqp7J6QIOyeheugpeyXkCDsnZjtlbQg7JWg64uI66mU7J207IWY7J20IOykkeuLqOuQnCDqsr3smrB8XHJcbiAgICogfHtAbGluayBFUlJPUl9DT0RFIFNUT1BfQ0FMTEVEX0JZX1VTRVJ9fOuwnOyDneuQnCDsnbTrsqTtirjrk6Qg7KSRIO2VmOuCmOudvOuPhCBgc3RvcCgpYOydtCDtmLjstpzrkJwg6rK97JqwfFxyXG4gICAqXHJcbiAgICogPC9rbz5cclxuICAgKiBAcmV0dXJuIHtQcm9taXNlPHZvaWQ+fSBBIFByb21pc2Ugd2hpY2ggd2lsbCBiZSByZXNvbHZlZCBhZnRlciByZWFjaGluZyB0aGUgdGFyZ2V0IHBvc2l0aW9uPGtvPu2VtOuLuSDsooztkZwg64+E64us7Iuc7JeQIHJlc29sdmXrkJjripQgUHJvbWlzZTwva28+XHJcbiAgICovXG4gIF9fcHJvdG8ubW92ZVRvUG9zaXRpb24gPSBmdW5jdGlvbiAocG9zaXRpb24sIGR1cmF0aW9uLCBheGVzRXZlbnQpIHtcbiAgICB2YXIgZmxpY2tpbmcgPSBnZXRGbGlja2luZ0F0dGFjaGVkKHRoaXMuX2ZsaWNraW5nKTtcbiAgICB2YXIgY2FtZXJhID0gZmxpY2tpbmcuY2FtZXJhO1xuICAgIHZhciB0YXJnZXRQb3MgPSBjYW1lcmEuY2xhbXBUb1JlYWNoYWJsZVBvc2l0aW9uKHBvc2l0aW9uKTtcbiAgICB2YXIgYW5jaG9yQXRQb3NpdGlvbiA9IGNhbWVyYS5maW5kQW5jaG9ySW5jbHVkZVBvc2l0aW9uKHRhcmdldFBvcyk7XG4gICAgaWYgKCFhbmNob3JBdFBvc2l0aW9uKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEZsaWNraW5nRXJyb3IoTUVTU0FHRS5QT1NJVElPTl9OT1RfUkVBQ0hBQkxFKHBvc2l0aW9uKSwgQ09ERS5QT1NJVElPTl9OT1RfUkVBQ0hBQkxFKSk7XG4gICAgfVxuICAgIHZhciB0YXJnZXRQYW5lbCA9IGFuY2hvckF0UG9zaXRpb24ucGFuZWw7XG4gICAgLy8gVHJpZ2dlciBvbmx5IGNoYW5nZSBldmVudFxuICAgIGlmICh0YXJnZXRQYW5lbCAhPT0gdGhpcy5fYWN0aXZlUGFuZWwpIHtcbiAgICAgIHRoaXMuX3RyaWdnZXJJbmRleENoYW5nZUV2ZW50KHRhcmdldFBhbmVsLCBwb3NpdGlvbiwgYXhlc0V2ZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2FuaW1hdGVUb1Bvc2l0aW9uKHtcbiAgICAgIHBvc2l0aW9uOiB0aGlzLl9zdG9wQXRFZGdlID8gdGFyZ2V0UG9zIDogcG9zaXRpb24sXG4gICAgICBkdXJhdGlvbjogZHVyYXRpb24sXG4gICAgICBuZXdBY3RpdmVQYW5lbDogdGFyZ2V0UGFuZWwsXG4gICAgICBheGVzRXZlbnQ6IGF4ZXNFdmVudFxuICAgIH0pO1xuICB9O1xuICByZXR1cm4gRnJlZUNvbnRyb2w7XG59KENvbnRyb2wpO1xuXG4vKipcclxuICogQSB7QGxpbmsgQ29udHJvbH0gdGhhdCBhbGxvdyB5b3UgdG8gc2VsZWN0IHRoZSBtYXhpbXVtIG51bWJlciBvZiBwYW5lbHMgdG8gbW92ZSBhdCBhIHRpbWVcclxuICogQGtvIO2VnOuyiOyXkCDstZzrjIDroZwg7J2064+Z7ZWgIO2MqOuEkOydmCDqsJzsiJjrpbwg7ISg7YOdIOqwgOuKpe2VnCB7QGxpbmsgQ29udHJvbH1cclxuICovXG52YXIgU3RyaWN0Q29udHJvbCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyQzKFN0cmljdENvbnRyb2wsIF9zdXBlcik7XG4gIC8qKiAqL1xuICBmdW5jdGlvbiBTdHJpY3RDb250cm9sKF9hKSB7XG4gICAgdmFyIF9iID0gKF9hID09PSB2b2lkIDAgPyB7fSA6IF9hKS5jb3VudCxcbiAgICAgIGNvdW50ID0gX2IgPT09IHZvaWQgMCA/IDEgOiBfYjtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgIF90aGlzLnNldEFjdGl2ZSA9IGZ1bmN0aW9uIChuZXdBY3RpdmVQYW5lbCwgcHJldkFjdGl2ZVBhbmVsLCBpc1RydXN0ZWQpIHtcbiAgICAgIF9zdXBlci5wcm90b3R5cGUuc2V0QWN0aXZlLmNhbGwoX3RoaXMsIG5ld0FjdGl2ZVBhbmVsLCBwcmV2QWN0aXZlUGFuZWwsIGlzVHJ1c3RlZCk7XG4gICAgICBfdGhpcy51cGRhdGVJbnB1dCgpO1xuICAgIH07XG4gICAgX3RoaXMuX2NvdW50ID0gY291bnQ7XG4gICAgX3RoaXMuX3Jlc2V0SW5kZXhSYW5nZSgpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICB2YXIgX19wcm90byA9IFN0cmljdENvbnRyb2wucHJvdG90eXBlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJjb3VudFwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBNYXhpbXVtIG51bWJlciBvZiBwYW5lbHMgdGhhdCBjYW4gYmUgbW92ZWQgYXQgYSB0aW1lXHJcbiAgICAgKiBAa28g7LWc64yA66GcIOybgOyngeydvCDsiJgg7J6I64qUIO2MqOuEkOydmCDqsJzsiJhcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCAxXHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jb3VudDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgdGhpcy5fY291bnQgPSB2YWw7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIC8qKlxyXG4gICAqIERlc3Ryb3kgQ29udHJvbCBhbmQgcmV0dXJuIHRvIGluaXRpYWwgc3RhdGVcclxuICAgKiBAa28gQ29udHJvbOydhCDstIjquLAg7IOB7YOc66GcIOuQmOuPjOumveuLiOuLpFxyXG4gICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICovXG4gIF9fcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICBfc3VwZXIucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgICB0aGlzLl9yZXNldEluZGV4UmFuZ2UoKTtcbiAgfTtcbiAgLyoqXHJcbiAgICogVXBkYXRlIHtAbGluayBDb250cm9sI2NvbnRyb2xsZXIgY29udHJvbGxlcn0ncyBzdGF0ZVxyXG4gICAqIEBrbyB7QGxpbmsgQ29udHJvbCNjb250cm9sbGVyIGNvbnRyb2xsZXJ97J2YIOuCtOu2gCDsg4Htg5zrpbwg6rCx7Iug7ZWp64uI64ukXHJcbiAgICogQGNoYWluYWJsZVxyXG4gICAqIEByZXR1cm4ge3RoaXN9XHJcbiAgICovXG4gIF9fcHJvdG8udXBkYXRlSW5wdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9hO1xuICAgIHZhciBmbGlja2luZyA9IGdldEZsaWNraW5nQXR0YWNoZWQodGhpcy5fZmxpY2tpbmcpO1xuICAgIHZhciBjYW1lcmEgPSBmbGlja2luZy5jYW1lcmE7XG4gICAgdmFyIHJlbmRlcmVyID0gZmxpY2tpbmcucmVuZGVyZXI7XG4gICAgdmFyIGNvbnRyb2xsZXIgPSB0aGlzLl9jb250cm9sbGVyO1xuICAgIHZhciBjb250cm9sUGFyYW1zID0gY2FtZXJhLmNvbnRyb2xQYXJhbXM7XG4gICAgdmFyIGNvdW50ID0gdGhpcy5fY291bnQ7XG4gICAgdmFyIGFjdGl2ZVBhbmVsID0gY29udHJvbGxlci5zdGF0ZS5hbmltYXRpbmcgPyAoX2EgPSBjYW1lcmEuZmluZE5lYXJlc3RBbmNob3IoY2FtZXJhLnBvc2l0aW9uKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBhbmVsIDogdGhpcy5fYWN0aXZlUGFuZWw7XG4gICAgaWYgKCFhY3RpdmVQYW5lbCkge1xuICAgICAgY29udHJvbGxlci51cGRhdGUoY29udHJvbFBhcmFtcyk7XG4gICAgICB0aGlzLl9yZXNldEluZGV4UmFuZ2UoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB2YXIgY2FtZXJhUmFuZ2UgPSBjb250cm9sUGFyYW1zLnJhbmdlO1xuICAgIHZhciBjdXJyZW50UG9zID0gYWN0aXZlUGFuZWwucG9zaXRpb247XG4gICAgdmFyIGN1cnJlbnRJbmRleCA9IGFjdGl2ZVBhbmVsLmluZGV4O1xuICAgIHZhciBwYW5lbENvdW50ID0gcmVuZGVyZXIucGFuZWxDb3VudDtcbiAgICB2YXIgcHJldlBhbmVsSW5kZXggPSBjdXJyZW50SW5kZXggLSBjb3VudDtcbiAgICB2YXIgbmV4dFBhbmVsSW5kZXggPSBjdXJyZW50SW5kZXggKyBjb3VudDtcbiAgICBpZiAocHJldlBhbmVsSW5kZXggPCAwKSB7XG4gICAgICBwcmV2UGFuZWxJbmRleCA9IGZsaWNraW5nLmNpcmN1bGFyRW5hYmxlZCA/IGdldE1pbnVzQ29tcGVuc2F0ZWRJbmRleCgocHJldlBhbmVsSW5kZXggKyAxKSAlIHBhbmVsQ291bnQgLSAxLCBwYW5lbENvdW50KSA6IGNsYW1wJDEocHJldlBhbmVsSW5kZXgsIDAsIHBhbmVsQ291bnQgLSAxKTtcbiAgICB9XG4gICAgaWYgKG5leHRQYW5lbEluZGV4ID49IHBhbmVsQ291bnQpIHtcbiAgICAgIG5leHRQYW5lbEluZGV4ID0gZmxpY2tpbmcuY2lyY3VsYXJFbmFibGVkID8gbmV4dFBhbmVsSW5kZXggJSBwYW5lbENvdW50IDogY2xhbXAkMShuZXh0UGFuZWxJbmRleCwgMCwgcGFuZWxDb3VudCAtIDEpO1xuICAgIH1cbiAgICB2YXIgcHJldlBhbmVsID0gcmVuZGVyZXIucGFuZWxzW3ByZXZQYW5lbEluZGV4XTtcbiAgICB2YXIgbmV4dFBhbmVsID0gcmVuZGVyZXIucGFuZWxzW25leHRQYW5lbEluZGV4XTtcbiAgICB2YXIgcHJldlBvcyA9IE1hdGgubWF4KHByZXZQYW5lbC5wb3NpdGlvbiwgY2FtZXJhUmFuZ2UubWluKTtcbiAgICB2YXIgbmV4dFBvcyA9IE1hdGgubWluKG5leHRQYW5lbC5wb3NpdGlvbiwgY2FtZXJhUmFuZ2UubWF4KTtcbiAgICBpZiAocHJldlBvcyA+IGN1cnJlbnRQb3MpIHtcbiAgICAgIHByZXZQb3MgLT0gY2FtZXJhLnJhbmdlRGlmZjtcbiAgICB9XG4gICAgaWYgKG5leHRQb3MgPCBjdXJyZW50UG9zKSB7XG4gICAgICBuZXh0UG9zICs9IGNhbWVyYS5yYW5nZURpZmY7XG4gICAgfVxuICAgIGNvbnRyb2xQYXJhbXMucmFuZ2UgPSB7XG4gICAgICBtaW46IHByZXZQb3MsXG4gICAgICBtYXg6IG5leHRQb3NcbiAgICB9O1xuICAgIGlmIChjb250cm9sUGFyYW1zLmNpcmN1bGFyKSB7XG4gICAgICBpZiAoY29udHJvbFBhcmFtcy5wb3NpdGlvbiA8IHByZXZQb3MpIHtcbiAgICAgICAgY29udHJvbFBhcmFtcy5wb3NpdGlvbiArPSBjYW1lcmEucmFuZ2VEaWZmO1xuICAgICAgfVxuICAgICAgaWYgKGNvbnRyb2xQYXJhbXMucG9zaXRpb24gPiBuZXh0UG9zKSB7XG4gICAgICAgIGNvbnRyb2xQYXJhbXMucG9zaXRpb24gLT0gY2FtZXJhLnJhbmdlRGlmZjtcbiAgICAgIH1cbiAgICB9XG4gICAgY29udHJvbFBhcmFtcy5jaXJjdWxhciA9IGZhbHNlO1xuICAgIGNvbnRyb2xsZXIudXBkYXRlKGNvbnRyb2xQYXJhbXMpO1xuICAgIHRoaXMuX2luZGV4UmFuZ2UgPSB7XG4gICAgICBtaW46IHByZXZQYW5lbC5pbmRleCxcbiAgICAgIG1heDogbmV4dFBhbmVsLmluZGV4XG4gICAgfTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgX19wcm90by5tb3ZlVG9QYW5lbCA9IGZ1bmN0aW9uIChwYW5lbCwgb3B0aW9ucykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBmbGlja2luZywgY2FtZXJhLCBjb250cm9sbGVyO1xuICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBmbGlja2luZyA9IGdldEZsaWNraW5nQXR0YWNoZWQodGhpcy5fZmxpY2tpbmcpO1xuICAgICAgICBjYW1lcmEgPSBmbGlja2luZy5jYW1lcmE7XG4gICAgICAgIGNvbnRyb2xsZXIgPSB0aGlzLl9jb250cm9sbGVyO1xuICAgICAgICBjb250cm9sbGVyLnVwZGF0ZShjYW1lcmEuY29udHJvbFBhcmFtcyk7XG4gICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBfc3VwZXIucHJvdG90eXBlLm1vdmVUb1BhbmVsLmNhbGwodGhpcywgcGFuZWwsIG9wdGlvbnMpXTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuICAvKipcclxuICAgKiBNb3ZlIHtAbGluayBDYW1lcmF9IHRvIHRoZSBnaXZlbiBwb3NpdGlvblxyXG4gICAqIEBrbyB7QGxpbmsgQ2FtZXJhfeulvCDso7zslrTsp4Qg7KKM7ZGc66GcIOydtOuPme2VqeuLiOuLpFxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwb3NpdGlvbiBUaGUgdGFyZ2V0IHBvc2l0aW9uIHRvIG1vdmU8a28+7J2064+Z7ZWgIOyijO2RnDwva28+XHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGR1cmF0aW9uIER1cmF0aW9uIG9mIHRoZSBwYW5lbCBtb3ZlbWVudCBhbmltYXRpb24gKHVuaXQ6IG1zKS48a28+7Yyo64SQIOydtOuPmSDslaDri4jrqZTsnbTshZgg7KeE7ZaJIOyLnOqwhCAo64uo7JyEOiBtcyk8L2tvPlxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbYXhlc0V2ZW50XSB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1heGVzL3JlbGVhc2UvbGF0ZXN0L2RvYy9lZy5BeGVzLmh0bWwjZXZlbnQ6cmVsZWFzZSByZWxlYXNlfSBldmVudCBvZiB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1heGVzLyBBeGVzfVxyXG4gICAqIDxrbz57QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1heGVzLyBBeGVzfeydmCB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1heGVzL3JlbGVhc2UvbGF0ZXN0L2RvYy9lZy5BeGVzLmh0bWwjZXZlbnQ6cmVsZWFzZSByZWxlYXNlfSDsnbTrsqTtirg8L2tvPlxyXG4gICAqIEBmaXJlcyBGbGlja2luZyNtb3ZlU3RhcnRcclxuICAgKiBAZmlyZXMgRmxpY2tpbmcjbW92ZVxyXG4gICAqIEBmaXJlcyBGbGlja2luZyNtb3ZlRW5kXHJcbiAgICogQGZpcmVzIEZsaWNraW5nI3dpbGxDaGFuZ2VcclxuICAgKiBAZmlyZXMgRmxpY2tpbmcjY2hhbmdlZFxyXG4gICAqIEBmaXJlcyBGbGlja2luZyN3aWxsUmVzdG9yZVxyXG4gICAqIEBmaXJlcyBGbGlja2luZyNyZXN0b3JlZFxyXG4gICAqIEBmaXJlcyBGbGlja2luZyNuZWVkUGFuZWxcclxuICAgKiBAZmlyZXMgRmxpY2tpbmcjdmlzaWJsZUNoYW5nZVxyXG4gICAqIEBmaXJlcyBGbGlja2luZyNyZWFjaEVkZ2VcclxuICAgKiBAdGhyb3dzIHtGbGlja2luZ0Vycm9yfVxyXG4gICAqIHxjb2RlfGNvbmRpdGlvbnxcclxuICAgKiB8LS0tfC0tLXxcclxuICAgKiB8e0BsaW5rIEVSUk9SX0NPREUgUE9TSVRJT05fTk9UX1JFQUNIQUJMRX18V2hlbiB0aGUgZ2l2ZW4gcGFuZWwgaXMgYWxyZWFkeSByZW1vdmVkIG9yIG5vdCBpbiB0aGUgQ2FtZXJhJ3Mge0BsaW5rIENhbWVyYSNyYW5nZSByYW5nZX18XHJcbiAgICogfHtAbGluayBFUlJPUl9DT0RFIE5PVF9BVFRBQ0hFRF9UT19GTElDS0lOR318V2hlbiB7QGxpbmsgQ29udHJvbCNpbml0IGluaXR9IGlzIG5vdCBjYWxsZWQgYmVmb3JlfFxyXG4gICAqIHx7QGxpbmsgRVJST1JfQ09ERSBBTklNQVRJT05fSU5URVJSVVBURUR9fFdoZW4gdGhlIGFuaW1hdGlvbiBpcyBpbnRlcnJ1cHRlZCBieSB1c2VyIGlucHV0fFxyXG4gICAqIHx7QGxpbmsgRVJST1JfQ09ERSBTVE9QX0NBTExFRF9CWV9VU0VSfXxXaGVuIHRoZSBhbmltYXRpb24gaXMgaW50ZXJydXB0ZWQgYnkgdXNlciBpbnB1dHxcclxuICAgKiA8a28+XHJcbiAgICpcclxuICAgKiB8Y29kZXxjb25kaXRpb258XHJcbiAgICogfC0tLXwtLS18XHJcbiAgICogfHtAbGluayBFUlJPUl9DT0RFIFBPU0lUSU9OX05PVF9SRUFDSEFCTEV9fOyjvOyWtOynhCDtjKjrhJDsnbQg7KCc6rGw65CY7JeI6rGw64KYLCBDYW1lcmHsnZgge0BsaW5rIENhbWVyYSNyYW5nZSByYW5nZX0g67CW7JeQIOyeiOydhCDqsr3smrB8XHJcbiAgICogfHtAbGluayBFUlJPUl9DT0RFIE5PVF9BVFRBQ0hFRF9UT19GTElDS0lOR318e0BsaW5rIENvbnRyb2wjaW5pdCBpbml0feydtCDsnbTsoITsl5Ag7Zi47Lac65CY7KeAIOyViuydgCDqsr3smrB8XHJcbiAgICogfHtAbGluayBFUlJPUl9DT0RFIEFOSU1BVElPTl9JTlRFUlJVUFRFRH187IKs7Jqp7J6QIOyeheugpeyXkCDsnZjtlbQg7JWg64uI66mU7J207IWY7J20IOykkeuLqOuQnCDqsr3smrB8XHJcbiAgICogfHtAbGluayBFUlJPUl9DT0RFIFNUT1BfQ0FMTEVEX0JZX1VTRVJ9fOuwnOyDneuQnCDsnbTrsqTtirjrk6Qg7KSRIO2VmOuCmOudvOuPhCBgc3RvcCgpYOydtCDtmLjstpzrkJwg6rK97JqwfFxyXG4gICAqXHJcbiAgICogPC9rbz5cclxuICAgKiBAcmV0dXJuIHtQcm9taXNlPHZvaWQ+fSBBIFByb21pc2Ugd2hpY2ggd2lsbCBiZSByZXNvbHZlZCBhZnRlciByZWFjaGluZyB0aGUgdGFyZ2V0IHBvc2l0aW9uPGtvPu2VtOuLuSDsooztkZwg64+E64us7Iuc7JeQIHJlc29sdmXrkJjripQgUHJvbWlzZTwva28+XHJcbiAgICovXG4gIF9fcHJvdG8ubW92ZVRvUG9zaXRpb24gPSBmdW5jdGlvbiAocG9zaXRpb24sIGR1cmF0aW9uLCBheGVzRXZlbnQpIHtcbiAgICB2YXIgX2E7XG4gICAgdmFyIGZsaWNraW5nID0gZ2V0RmxpY2tpbmdBdHRhY2hlZCh0aGlzLl9mbGlja2luZyk7XG4gICAgdmFyIGNhbWVyYSA9IGZsaWNraW5nLmNhbWVyYTtcbiAgICB2YXIgY3VycmVudFBhbmVsID0gKF9hID0gdGhpcy5fbmV4dFBhbmVsKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLl9hY3RpdmVQYW5lbDtcbiAgICB2YXIgYXhlc1JhbmdlID0gdGhpcy5fY29udHJvbGxlci5yYW5nZTtcbiAgICB2YXIgaW5kZXhSYW5nZSA9IHRoaXMuX2luZGV4UmFuZ2U7XG4gICAgdmFyIGNhbWVyYVJhbmdlID0gY2FtZXJhLnJhbmdlO1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuX2NvbnRyb2xsZXIuc3RhdGU7XG4gICAgdmFyIGNsYW1wZWRQb3NpdGlvbiA9IGNsYW1wJDEoY2FtZXJhLmNsYW1wVG9SZWFjaGFibGVQb3NpdGlvbihwb3NpdGlvbiksIGF4ZXNSYW5nZVswXSwgYXhlc1JhbmdlWzFdKTtcbiAgICB2YXIgYW5jaG9yQXRQb3NpdGlvbiA9IGNhbWVyYS5maW5kQW5jaG9ySW5jbHVkZVBvc2l0aW9uKGNsYW1wZWRQb3NpdGlvbik7XG4gICAgaWYgKCFhbmNob3JBdFBvc2l0aW9uIHx8ICFjdXJyZW50UGFuZWwpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRmxpY2tpbmdFcnJvcihNRVNTQUdFLlBPU0lUSU9OX05PVF9SRUFDSEFCTEUocG9zaXRpb24pLCBDT0RFLlBPU0lUSU9OX05PVF9SRUFDSEFCTEUpKTtcbiAgICB9XG4gICAgdmFyIHByZXZQb3MgPSBjdXJyZW50UGFuZWwucG9zaXRpb247XG4gICAgdmFyIHBvc0RlbHRhID0gZmxpY2tpbmcuYW5pbWF0aW5nID8gc3RhdGUuZGVsdGEgOiBwb3NpdGlvbiAtIGNhbWVyYS5wb3NpdGlvbjtcbiAgICB2YXIgaXNPdmVyVGhyZXNob2xkID0gTWF0aC5hYnMocG9zRGVsdGEpID49IGZsaWNraW5nLnRocmVzaG9sZDtcbiAgICB2YXIgYWRqYWNlbnRBbmNob3IgPSBwb3NpdGlvbiA+IHByZXZQb3MgPyBjYW1lcmEuZ2V0TmV4dEFuY2hvcihhbmNob3JBdFBvc2l0aW9uKSA6IGNhbWVyYS5nZXRQcmV2QW5jaG9yKGFuY2hvckF0UG9zaXRpb24pO1xuICAgIHZhciB0YXJnZXRQb3M7XG4gICAgdmFyIHRhcmdldFBhbmVsO1xuICAgIHZhciBhbmNob3JzID0gY2FtZXJhLmFuY2hvclBvaW50cztcbiAgICB2YXIgZmlyc3RBbmNob3IgPSBhbmNob3JzWzBdO1xuICAgIHZhciBsYXN0QW5jaG9yID0gYW5jaG9yc1thbmNob3JzLmxlbmd0aCAtIDFdO1xuICAgIHZhciBzaG91bGRCb3VuY2VUb0ZpcnN0ID0gcG9zaXRpb24gPD0gY2FtZXJhUmFuZ2UubWluICYmIGlzQmV0d2VlbihmaXJzdEFuY2hvci5wYW5lbC5pbmRleCwgaW5kZXhSYW5nZS5taW4sIGluZGV4UmFuZ2UubWF4KTtcbiAgICB2YXIgc2hvdWxkQm91bmNlVG9MYXN0ID0gcG9zaXRpb24gPj0gY2FtZXJhUmFuZ2UubWF4ICYmIGlzQmV0d2VlbihsYXN0QW5jaG9yLnBhbmVsLmluZGV4LCBpbmRleFJhbmdlLm1pbiwgaW5kZXhSYW5nZS5tYXgpO1xuICAgIHZhciBpc0FkamFjZW50ID0gYWRqYWNlbnRBbmNob3IgJiYgKGluZGV4UmFuZ2UubWluIDw9IGluZGV4UmFuZ2UubWF4ID8gaXNCZXR3ZWVuKGFkamFjZW50QW5jaG9yLmluZGV4LCBpbmRleFJhbmdlLm1pbiwgaW5kZXhSYW5nZS5tYXgpIDogYWRqYWNlbnRBbmNob3IuaW5kZXggPj0gaW5kZXhSYW5nZS5taW4gfHwgYWRqYWNlbnRBbmNob3IuaW5kZXggPD0gaW5kZXhSYW5nZS5tYXgpO1xuICAgIGlmIChzaG91bGRCb3VuY2VUb0ZpcnN0IHx8IHNob3VsZEJvdW5jZVRvTGFzdCkge1xuICAgICAgLy8gSW4gYm91bmNlIGFyZWFcbiAgICAgIHZhciB0YXJnZXRBbmNob3IgPSBwb3NpdGlvbiA8IGNhbWVyYVJhbmdlLm1pbiA/IGZpcnN0QW5jaG9yIDogbGFzdEFuY2hvcjtcbiAgICAgIHRhcmdldFBhbmVsID0gdGFyZ2V0QW5jaG9yLnBhbmVsO1xuICAgICAgdGFyZ2V0UG9zID0gdGFyZ2V0QW5jaG9yLnBvc2l0aW9uO1xuICAgIH0gZWxzZSBpZiAoaXNPdmVyVGhyZXNob2xkICYmIGFuY2hvckF0UG9zaXRpb24ucG9zaXRpb24gIT09IGN1cnJlbnRQYW5lbC5wb3NpdGlvbikge1xuICAgICAgLy8gTW92ZSB0byBhbmNob3IgYXQgcG9zaXRpb25cbiAgICAgIHRhcmdldFBhbmVsID0gYW5jaG9yQXRQb3NpdGlvbi5wYW5lbDtcbiAgICAgIHRhcmdldFBvcyA9IGFuY2hvckF0UG9zaXRpb24ucG9zaXRpb247XG4gICAgfSBlbHNlIGlmIChpc092ZXJUaHJlc2hvbGQgJiYgaXNBZGphY2VudCkge1xuICAgICAgLy8gTW92ZSB0byBhZGphY2VudCBhbmNob3JcbiAgICAgIHRhcmdldFBhbmVsID0gYWRqYWNlbnRBbmNob3IucGFuZWw7XG4gICAgICB0YXJnZXRQb3MgPSBhZGphY2VudEFuY2hvci5wb3NpdGlvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRmFsbGJhY2sgdG8gbmVhcmVzdCBwYW5lbCBmcm9tIGN1cnJlbnQgY2FtZXJhXG4gICAgICB2YXIgYW5jaG9yQXRDYW1lcmEgPSBjYW1lcmEuZmluZE5lYXJlc3RBbmNob3IoY2FtZXJhLnBvc2l0aW9uKTtcbiAgICAgIGlmICghYW5jaG9yQXRDYW1lcmEpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBGbGlja2luZ0Vycm9yKE1FU1NBR0UuUE9TSVRJT05fTk9UX1JFQUNIQUJMRShwb3NpdGlvbiksIENPREUuUE9TSVRJT05fTk9UX1JFQUNIQUJMRSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMubW92ZVRvUGFuZWwoYW5jaG9yQXRDYW1lcmEucGFuZWwsIHtcbiAgICAgICAgZHVyYXRpb246IGR1cmF0aW9uLFxuICAgICAgICBheGVzRXZlbnQ6IGF4ZXNFdmVudFxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuX3RyaWdnZXJJbmRleENoYW5nZUV2ZW50KHRhcmdldFBhbmVsLCBwb3NpdGlvbiwgYXhlc0V2ZW50KTtcbiAgICByZXR1cm4gdGhpcy5fYW5pbWF0ZVRvUG9zaXRpb24oe1xuICAgICAgcG9zaXRpb246IHRhcmdldFBvcyxcbiAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbixcbiAgICAgIG5ld0FjdGl2ZVBhbmVsOiB0YXJnZXRQYW5lbCxcbiAgICAgIGF4ZXNFdmVudDogYXhlc0V2ZW50XG4gICAgfSk7XG4gIH07XG4gIF9fcHJvdG8uX3Jlc2V0SW5kZXhSYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9pbmRleFJhbmdlID0ge1xuICAgICAgbWluOiAwLFxuICAgICAgbWF4OiAwXG4gICAgfTtcbiAgfTtcbiAgcmV0dXJuIFN0cmljdENvbnRyb2w7XG59KENvbnRyb2wpO1xuXG4vKipcclxuICogQSBtb2RlIG9mIGNhbWVyYVxyXG4gKi9cbnZhciBDYW1lcmFNb2RlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqICovXG4gIGZ1bmN0aW9uIENhbWVyYU1vZGUoZmxpY2tpbmcpIHtcbiAgICB0aGlzLl9mbGlja2luZyA9IGZsaWNraW5nO1xuICB9XG4gIHZhciBfX3Byb3RvID0gQ2FtZXJhTW9kZS5wcm90b3R5cGU7XG4gIF9fcHJvdG8uZ2V0QW5jaG9ycyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcGFuZWxzID0gdGhpcy5fZmxpY2tpbmcucmVuZGVyZXIucGFuZWxzO1xuICAgIHJldHVybiBwYW5lbHMubWFwKGZ1bmN0aW9uIChwYW5lbCwgaW5kZXgpIHtcbiAgICAgIHJldHVybiBuZXcgQW5jaG9yUG9pbnQoe1xuICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgIHBvc2l0aW9uOiBwYW5lbC5wb3NpdGlvbixcbiAgICAgICAgcGFuZWw6IHBhbmVsXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbiAgX19wcm90by5maW5kQW5jaG9ySW5jbHVkZVBvc2l0aW9uID0gZnVuY3Rpb24gKHBvc2l0aW9uKSB7XG4gICAgdmFyIGFuY2hvcnMgPSB0aGlzLl9mbGlja2luZy5jYW1lcmEuYW5jaG9yUG9pbnRzO1xuICAgIHZhciBhbmNob3JzSW5jbHVkaW5nUG9zaXRpb24gPSBhbmNob3JzLmZpbHRlcihmdW5jdGlvbiAoYW5jaG9yKSB7XG4gICAgICByZXR1cm4gYW5jaG9yLnBhbmVsLmluY2x1ZGVQb3NpdGlvbihwb3NpdGlvbiwgdHJ1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGFuY2hvcnNJbmNsdWRpbmdQb3NpdGlvbi5yZWR1Y2UoZnVuY3Rpb24gKG5lYXJlc3QsIGFuY2hvcikge1xuICAgICAgaWYgKCFuZWFyZXN0KSByZXR1cm4gYW5jaG9yO1xuICAgICAgcmV0dXJuIE1hdGguYWJzKG5lYXJlc3QucG9zaXRpb24gLSBwb3NpdGlvbikgPCBNYXRoLmFicyhhbmNob3IucG9zaXRpb24gLSBwb3NpdGlvbikgPyBuZWFyZXN0IDogYW5jaG9yO1xuICAgIH0sIG51bGwpO1xuICB9O1xuICBfX3Byb3RvLmZpbmROZWFyZXN0QW5jaG9yID0gZnVuY3Rpb24gKHBvc2l0aW9uKSB7XG4gICAgdmFyIGFuY2hvcnMgPSB0aGlzLl9mbGlja2luZy5jYW1lcmEuYW5jaG9yUG9pbnRzO1xuICAgIGlmIChhbmNob3JzLmxlbmd0aCA8PSAwKSByZXR1cm4gbnVsbDtcbiAgICB2YXIgcHJldkRpc3QgPSBJbmZpbml0eTtcbiAgICBmb3IgKHZhciBhbmNob3JJZHggPSAwOyBhbmNob3JJZHggPCBhbmNob3JzLmxlbmd0aDsgYW5jaG9ySWR4KyspIHtcbiAgICAgIHZhciBhbmNob3IgPSBhbmNob3JzW2FuY2hvcklkeF07XG4gICAgICB2YXIgZGlzdCA9IE1hdGguYWJzKGFuY2hvci5wb3NpdGlvbiAtIHBvc2l0aW9uKTtcbiAgICAgIGlmIChkaXN0ID4gcHJldkRpc3QpIHtcbiAgICAgICAgLy8gUmV0dXJuIHByZXZpb3VzIGFuY2hvclxuICAgICAgICByZXR1cm4gYW5jaG9yc1thbmNob3JJZHggLSAxXTtcbiAgICAgIH1cbiAgICAgIHByZXZEaXN0ID0gZGlzdDtcbiAgICB9XG4gICAgLy8gUmV0dXJuIGxhc3QgYW5jaG9yXG4gICAgcmV0dXJuIGFuY2hvcnNbYW5jaG9ycy5sZW5ndGggLSAxXTtcbiAgfTtcbiAgX19wcm90by5jbGFtcFRvUmVhY2hhYmxlUG9zaXRpb24gPSBmdW5jdGlvbiAocG9zaXRpb24pIHtcbiAgICB2YXIgY2FtZXJhID0gdGhpcy5fZmxpY2tpbmcuY2FtZXJhO1xuICAgIHZhciByYW5nZSA9IGNhbWVyYS5yYW5nZTtcbiAgICByZXR1cm4gY2xhbXAkMShwb3NpdGlvbiwgcmFuZ2UubWluLCByYW5nZS5tYXgpO1xuICB9O1xuICBfX3Byb3RvLmdldENpcmN1bGFyT2Zmc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAwO1xuICB9O1xuICBfX3Byb3RvLmNhblJlYWNoID0gZnVuY3Rpb24gKHBhbmVsKSB7XG4gICAgdmFyIGNhbWVyYSA9IHRoaXMuX2ZsaWNraW5nLmNhbWVyYTtcbiAgICB2YXIgcmFuZ2UgPSBjYW1lcmEucmFuZ2U7XG4gICAgaWYgKHBhbmVsLnJlbW92ZWQpIHJldHVybiBmYWxzZTtcbiAgICB2YXIgcGFuZWxQb3MgPSBwYW5lbC5wb3NpdGlvbjtcbiAgICByZXR1cm4gcGFuZWxQb3MgPj0gcmFuZ2UubWluICYmIHBhbmVsUG9zIDw9IHJhbmdlLm1heDtcbiAgfTtcbiAgX19wcm90by5jYW5TZWUgPSBmdW5jdGlvbiAocGFuZWwpIHtcbiAgICB2YXIgY2FtZXJhID0gdGhpcy5fZmxpY2tpbmcuY2FtZXJhO1xuICAgIHZhciB2aXNpYmxlUmFuZ2UgPSBjYW1lcmEudmlzaWJsZVJhbmdlO1xuICAgIC8vIFNob3VsZCBub3QgaW5jbHVkZSBtYXJnaW4sIGFzIHdlIGRvbid0IGRlY2xhcmUgd2hhdCB0aGUgbWFyZ2luIGlzIHZpc2libGUgYXMgd2hhdCB0aGUgcGFuZWwgaXMgdmlzaWJsZS5cbiAgICByZXR1cm4gcGFuZWwuaXNWaXNpYmxlT25SYW5nZSh2aXNpYmxlUmFuZ2UubWluLCB2aXNpYmxlUmFuZ2UubWF4KTtcbiAgfTtcbiAgcmV0dXJuIENhbWVyYU1vZGU7XG59KCk7XG5cbnZhciBMaW5lYXJDYW1lcmFNb2RlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzJDMoTGluZWFyQ2FtZXJhTW9kZSwgX3N1cGVyKTtcbiAgZnVuY3Rpb24gTGluZWFyQ2FtZXJhTW9kZSgpIHtcbiAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cbiAgdmFyIF9fcHJvdG8gPSBMaW5lYXJDYW1lcmFNb2RlLnByb3RvdHlwZTtcbiAgX19wcm90by5jaGVja0F2YWlsYWJpbGl0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBJdCdzIGFsd2F5cyBhdmFpbGFibGVcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbiAgX19wcm90by5nZXRSYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHZhciByZW5kZXJlciA9IHRoaXMuX2ZsaWNraW5nLnJlbmRlcmVyO1xuICAgIHZhciBmaXJzdFBhbmVsID0gcmVuZGVyZXIuZ2V0UGFuZWwoMCk7XG4gICAgdmFyIGxhc3RQYW5lbCA9IHJlbmRlcmVyLmdldFBhbmVsKHJlbmRlcmVyLnBhbmVsQ291bnQgLSAxKTtcbiAgICByZXR1cm4ge1xuICAgICAgbWluOiAoX2EgPSBmaXJzdFBhbmVsID09PSBudWxsIHx8IGZpcnN0UGFuZWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZpcnN0UGFuZWwucG9zaXRpb24pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDAsXG4gICAgICBtYXg6IChfYiA9IGxhc3RQYW5lbCA9PT0gbnVsbCB8fCBsYXN0UGFuZWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxhc3RQYW5lbC5wb3NpdGlvbikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMFxuICAgIH07XG4gIH07XG4gIHJldHVybiBMaW5lYXJDYW1lcmFNb2RlO1xufShDYW1lcmFNb2RlKTtcblxuLyoqXHJcbiAqIEEge0BsaW5rIENhbWVyYX0gbW9kZSB0aGF0IGNvbm5lY3RzIHRoZSBsYXN0IHBhbmVsIGFuZCB0aGUgZmlyc3QgcGFuZWwsIGVuYWJsaW5nIGNvbnRpbnVvdXMgbG9vcFxyXG4gKiBAa28g7LKr67KI7Ke4IO2MqOuEkOqzvCDrp4jsp4Drp4kg7Yyo64SQ7J20IOydtOyWtOynhCDsg4Htg5zroZwsIOustO2VnO2eiCDtmozsoITtlaAg7IiYIOyeiOuKlCDsooXrpZjsnZgge0BsaW5rIENhbWVyYX0g66qo65OcXHJcbiAqL1xudmFyIENpcmN1bGFyQ2FtZXJhTW9kZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyQzKENpcmN1bGFyQ2FtZXJhTW9kZSwgX3N1cGVyKTtcbiAgZnVuY3Rpb24gQ2lyY3VsYXJDYW1lcmFNb2RlKCkge1xuICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuICB2YXIgX19wcm90byA9IENpcmN1bGFyQ2FtZXJhTW9kZS5wcm90b3R5cGU7XG4gIF9fcHJvdG8uY2hlY2tBdmFpbGFiaWxpdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZsaWNraW5nID0gdGhpcy5fZmxpY2tpbmc7XG4gICAgdmFyIHJlbmRlcmVyID0gZmxpY2tpbmcucmVuZGVyZXI7XG4gICAgdmFyIHBhbmVscyA9IHJlbmRlcmVyLnBhbmVscztcbiAgICBpZiAocGFuZWxzLmxlbmd0aCA8PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBmaXJzdFBhbmVsID0gcGFuZWxzWzBdO1xuICAgIHZhciBsYXN0UGFuZWwgPSBwYW5lbHNbcGFuZWxzLmxlbmd0aCAtIDFdO1xuICAgIHZhciBmaXJzdFBhbmVsUHJldiA9IGZpcnN0UGFuZWwucmFuZ2UubWluIC0gZmlyc3RQYW5lbC5tYXJnaW4ucHJldjtcbiAgICB2YXIgbGFzdFBhbmVsTmV4dCA9IGxhc3RQYW5lbC5yYW5nZS5tYXggKyBsYXN0UGFuZWwubWFyZ2luLm5leHQ7XG4gICAgdmFyIHZpc2libGVTaXplID0gZmxpY2tpbmcuY2FtZXJhLnNpemU7XG4gICAgdmFyIHBhbmVsU2l6ZVN1bSA9IGxhc3RQYW5lbE5leHQgLSBmaXJzdFBhbmVsUHJldjtcbiAgICB2YXIgY2FuU2V0Q2lyY3VsYXJNb2RlID0gcGFuZWxzLmV2ZXJ5KGZ1bmN0aW9uIChwYW5lbCkge1xuICAgICAgcmV0dXJuIHBhbmVsU2l6ZVN1bSAtIHBhbmVsLnNpemUgPj0gdmlzaWJsZVNpemU7XG4gICAgfSk7XG4gICAgcmV0dXJuIGNhblNldENpcmN1bGFyTW9kZTtcbiAgfTtcbiAgX19wcm90by5nZXRSYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZmxpY2tpbmcgPSB0aGlzLl9mbGlja2luZztcbiAgICB2YXIgcGFuZWxzID0gZmxpY2tpbmcucmVuZGVyZXIucGFuZWxzO1xuICAgIGlmIChwYW5lbHMubGVuZ3RoIDw9IDApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1pbjogMCxcbiAgICAgICAgbWF4OiAwXG4gICAgICB9O1xuICAgIH1cbiAgICB2YXIgZmlyc3RQYW5lbCA9IHBhbmVsc1swXTtcbiAgICB2YXIgbGFzdFBhbmVsID0gcGFuZWxzW3BhbmVscy5sZW5ndGggLSAxXTtcbiAgICB2YXIgZmlyc3RQYW5lbFByZXYgPSBmaXJzdFBhbmVsLnJhbmdlLm1pbiAtIGZpcnN0UGFuZWwubWFyZ2luLnByZXY7XG4gICAgdmFyIGxhc3RQYW5lbE5leHQgPSBsYXN0UGFuZWwucmFuZ2UubWF4ICsgbGFzdFBhbmVsLm1hcmdpbi5uZXh0O1xuICAgIHJldHVybiB7XG4gICAgICBtaW46IGZpcnN0UGFuZWxQcmV2LFxuICAgICAgbWF4OiBsYXN0UGFuZWxOZXh0XG4gICAgfTtcbiAgfTtcbiAgX19wcm90by5nZXRBbmNob3JzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBmbGlja2luZyA9IHRoaXMuX2ZsaWNraW5nO1xuICAgIHZhciBwYW5lbHMgPSBmbGlja2luZy5yZW5kZXJlci5wYW5lbHM7XG4gICAgcmV0dXJuIHBhbmVscy5tYXAoZnVuY3Rpb24gKHBhbmVsLCBpbmRleCkge1xuICAgICAgcmV0dXJuIG5ldyBBbmNob3JQb2ludCh7XG4gICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgcG9zaXRpb246IHBhbmVsLnBvc2l0aW9uLFxuICAgICAgICBwYW5lbDogcGFuZWxcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuICBfX3Byb3RvLmZpbmROZWFyZXN0QW5jaG9yID0gZnVuY3Rpb24gKHBvc2l0aW9uKSB7XG4gICAgdmFyIGNhbWVyYSA9IHRoaXMuX2ZsaWNraW5nLmNhbWVyYTtcbiAgICB2YXIgYW5jaG9ycyA9IGNhbWVyYS5hbmNob3JQb2ludHM7XG4gICAgaWYgKGFuY2hvcnMubGVuZ3RoIDw9IDApIHJldHVybiBudWxsO1xuICAgIHZhciBjYW1SYW5nZSA9IGNhbWVyYS5yYW5nZTtcbiAgICB2YXIgbWluRGlzdCA9IEluZmluaXR5O1xuICAgIHZhciBtaW5EaXN0SW5kZXggPSAtMTtcbiAgICBmb3IgKHZhciBhbmNob3JJZHggPSAwOyBhbmNob3JJZHggPCBhbmNob3JzLmxlbmd0aDsgYW5jaG9ySWR4KyspIHtcbiAgICAgIHZhciBhbmNob3IgPSBhbmNob3JzW2FuY2hvcklkeF07XG4gICAgICB2YXIgZGlzdCA9IE1hdGgubWluKE1hdGguYWJzKGFuY2hvci5wb3NpdGlvbiAtIHBvc2l0aW9uKSwgTWF0aC5hYnMoYW5jaG9yLnBvc2l0aW9uIC0gY2FtUmFuZ2UubWluICsgY2FtUmFuZ2UubWF4IC0gcG9zaXRpb24pLCBNYXRoLmFicyhwb3NpdGlvbiAtIGNhbVJhbmdlLm1pbiArIGNhbVJhbmdlLm1heCAtIGFuY2hvci5wb3NpdGlvbikpO1xuICAgICAgaWYgKGRpc3QgPCBtaW5EaXN0KSB7XG4gICAgICAgIG1pbkRpc3QgPSBkaXN0O1xuICAgICAgICBtaW5EaXN0SW5kZXggPSBhbmNob3JJZHg7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFJldHVybiBsYXN0IGFuY2hvclxuICAgIHJldHVybiBhbmNob3JzW21pbkRpc3RJbmRleF07XG4gIH07XG4gIF9fcHJvdG8uZmluZEFuY2hvckluY2x1ZGVQb3NpdGlvbiA9IGZ1bmN0aW9uIChwb3NpdGlvbikge1xuICAgIHZhciBjYW1lcmEgPSB0aGlzLl9mbGlja2luZy5jYW1lcmE7XG4gICAgdmFyIHJhbmdlID0gY2FtZXJhLnJhbmdlO1xuICAgIHZhciBhbmNob3JzID0gY2FtZXJhLmFuY2hvclBvaW50cztcbiAgICB2YXIgcmFuZ2VEaWZmID0gY2FtZXJhLnJhbmdlRGlmZjtcbiAgICB2YXIgYW5jaG9yQ291bnQgPSBhbmNob3JzLmxlbmd0aDtcbiAgICB2YXIgcG9zaXRpb25JblJhbmdlID0gY2lyY3VsYXRlUG9zaXRpb24ocG9zaXRpb24sIHJhbmdlLm1pbiwgcmFuZ2UubWF4KTtcbiAgICB2YXIgYW5jaG9ySW5SYW5nZSA9IF9zdXBlci5wcm90b3R5cGUuZmluZEFuY2hvckluY2x1ZGVQb3NpdGlvbi5jYWxsKHRoaXMsIHBvc2l0aW9uSW5SYW5nZSk7XG4gICAgaWYgKGFuY2hvckNvdW50ID4gMCAmJiAocG9zaXRpb24gPT09IHJhbmdlLm1pbiB8fCBwb3NpdGlvbiA9PT0gcmFuZ2UubWF4KSkge1xuICAgICAgdmFyIHBvc3NpYmxlQW5jaG9ycyA9IFthbmNob3JJblJhbmdlLCBuZXcgQW5jaG9yUG9pbnQoe1xuICAgICAgICBpbmRleDogMCxcbiAgICAgICAgcG9zaXRpb246IGFuY2hvcnNbMF0ucG9zaXRpb24gKyByYW5nZURpZmYsXG4gICAgICAgIHBhbmVsOiBhbmNob3JzWzBdLnBhbmVsXG4gICAgICB9KSwgbmV3IEFuY2hvclBvaW50KHtcbiAgICAgICAgaW5kZXg6IGFuY2hvckNvdW50IC0gMSxcbiAgICAgICAgcG9zaXRpb246IGFuY2hvcnNbYW5jaG9yQ291bnQgLSAxXS5wb3NpdGlvbiAtIHJhbmdlRGlmZixcbiAgICAgICAgcGFuZWw6IGFuY2hvcnNbYW5jaG9yQ291bnQgLSAxXS5wYW5lbFxuICAgICAgfSldLmZpbHRlcihmdW5jdGlvbiAoYW5jaG9yKSB7XG4gICAgICAgIHJldHVybiAhIWFuY2hvcjtcbiAgICAgIH0pO1xuICAgICAgYW5jaG9ySW5SYW5nZSA9IHBvc3NpYmxlQW5jaG9ycy5yZWR1Y2UoZnVuY3Rpb24gKG5lYXJlc3QsIGFuY2hvcikge1xuICAgICAgICBpZiAoIW5lYXJlc3QpIHJldHVybiBhbmNob3I7XG4gICAgICAgIHJldHVybiBNYXRoLmFicyhuZWFyZXN0LnBvc2l0aW9uIC0gcG9zaXRpb24pIDwgTWF0aC5hYnMoYW5jaG9yLnBvc2l0aW9uIC0gcG9zaXRpb24pID8gbmVhcmVzdCA6IGFuY2hvcjtcbiAgICAgIH0sIG51bGwpO1xuICAgIH1cbiAgICBpZiAoIWFuY2hvckluUmFuZ2UpIHJldHVybiBudWxsO1xuICAgIGlmIChwb3NpdGlvbiA8IHJhbmdlLm1pbikge1xuICAgICAgdmFyIGxvb3BDb3VudCA9IC1NYXRoLmZsb29yKChyYW5nZS5taW4gLSBwb3NpdGlvbikgLyByYW5nZURpZmYpIC0gMTtcbiAgICAgIHJldHVybiBuZXcgQW5jaG9yUG9pbnQoe1xuICAgICAgICBpbmRleDogYW5jaG9ySW5SYW5nZS5pbmRleCxcbiAgICAgICAgcG9zaXRpb246IGFuY2hvckluUmFuZ2UucG9zaXRpb24gKyByYW5nZURpZmYgKiBsb29wQ291bnQsXG4gICAgICAgIHBhbmVsOiBhbmNob3JJblJhbmdlLnBhbmVsXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID4gcmFuZ2UubWF4KSB7XG4gICAgICB2YXIgbG9vcENvdW50ID0gTWF0aC5mbG9vcigocG9zaXRpb24gLSByYW5nZS5tYXgpIC8gcmFuZ2VEaWZmKSArIDE7XG4gICAgICByZXR1cm4gbmV3IEFuY2hvclBvaW50KHtcbiAgICAgICAgaW5kZXg6IGFuY2hvckluUmFuZ2UuaW5kZXgsXG4gICAgICAgIHBvc2l0aW9uOiBhbmNob3JJblJhbmdlLnBvc2l0aW9uICsgcmFuZ2VEaWZmICogbG9vcENvdW50LFxuICAgICAgICBwYW5lbDogYW5jaG9ySW5SYW5nZS5wYW5lbFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBhbmNob3JJblJhbmdlO1xuICB9O1xuICBfX3Byb3RvLmdldENpcmN1bGFyT2Zmc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBmbGlja2luZyA9IHRoaXMuX2ZsaWNraW5nO1xuICAgIHZhciBjYW1lcmEgPSBmbGlja2luZy5jYW1lcmE7XG4gICAgaWYgKCFjYW1lcmEuY2lyY3VsYXJFbmFibGVkKSByZXR1cm4gMDtcbiAgICB2YXIgdG9nZ2xlZCA9IGZsaWNraW5nLnBhbmVscy5maWx0ZXIoZnVuY3Rpb24gKHBhbmVsKSB7XG4gICAgICByZXR1cm4gcGFuZWwudG9nZ2xlZDtcbiAgICB9KTtcbiAgICB2YXIgdG9nZ2xlZFByZXYgPSB0b2dnbGVkLmZpbHRlcihmdW5jdGlvbiAocGFuZWwpIHtcbiAgICAgIHJldHVybiBwYW5lbC50b2dnbGVEaXJlY3Rpb24gPT09IERJUkVDVElPTi5QUkVWO1xuICAgIH0pO1xuICAgIHZhciB0b2dnbGVkTmV4dCA9IHRvZ2dsZWQuZmlsdGVyKGZ1bmN0aW9uIChwYW5lbCkge1xuICAgICAgcmV0dXJuIHBhbmVsLnRvZ2dsZURpcmVjdGlvbiA9PT0gRElSRUNUSU9OLk5FWFQ7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGNQYW5lbEFyZWFTdW0odG9nZ2xlZFByZXYpIC0gdGhpcy5fY2FsY1BhbmVsQXJlYVN1bSh0b2dnbGVkTmV4dCk7XG4gIH07XG4gIF9fcHJvdG8uY2xhbXBUb1JlYWNoYWJsZVBvc2l0aW9uID0gZnVuY3Rpb24gKHBvc2l0aW9uKSB7XG4gICAgLy8gQmFzaWNhbGx5IGFsbCBwb3NpdGlvbiBpcyByZWFjaGFibGUgZm9yIGNpcmN1bGFyIGNhbWVyYVxuICAgIHJldHVybiBwb3NpdGlvbjtcbiAgfTtcbiAgX19wcm90by5jYW5SZWFjaCA9IGZ1bmN0aW9uIChwYW5lbCkge1xuICAgIGlmIChwYW5lbC5yZW1vdmVkKSByZXR1cm4gZmFsc2U7XG4gICAgLy8gQWx3YXlzIHJlYWNoYWJsZSBvbiBjaXJjdWxhciBtb2RlXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG4gIF9fcHJvdG8uY2FuU2VlID0gZnVuY3Rpb24gKHBhbmVsKSB7XG4gICAgdmFyIGNhbWVyYSA9IHRoaXMuX2ZsaWNraW5nLmNhbWVyYTtcbiAgICB2YXIgcmFuZ2UgPSBjYW1lcmEucmFuZ2U7XG4gICAgdmFyIHJhbmdlRGlmZiA9IGNhbWVyYS5yYW5nZURpZmY7XG4gICAgdmFyIHZpc2libGVSYW5nZSA9IGNhbWVyYS52aXNpYmxlUmFuZ2U7XG4gICAgdmFyIHZpc2libGVJbkN1cnJlbnRSYW5nZSA9IF9zdXBlci5wcm90b3R5cGUuY2FuU2VlLmNhbGwodGhpcywgcGFuZWwpO1xuICAgIC8vIENoZWNrIGxvb3BlZCB2aXNpYmxlIGFyZWEgZm9yIGNpcmN1bGFyIGNhc2VcbiAgICBpZiAodmlzaWJsZVJhbmdlLm1pbiA8IHJhbmdlLm1pbikge1xuICAgICAgcmV0dXJuIHZpc2libGVJbkN1cnJlbnRSYW5nZSB8fCBwYW5lbC5pc1Zpc2libGVPblJhbmdlKHZpc2libGVSYW5nZS5taW4gKyByYW5nZURpZmYsIHZpc2libGVSYW5nZS5tYXggKyByYW5nZURpZmYpO1xuICAgIH0gZWxzZSBpZiAodmlzaWJsZVJhbmdlLm1heCA+IHJhbmdlLm1heCkge1xuICAgICAgcmV0dXJuIHZpc2libGVJbkN1cnJlbnRSYW5nZSB8fCBwYW5lbC5pc1Zpc2libGVPblJhbmdlKHZpc2libGVSYW5nZS5taW4gLSByYW5nZURpZmYsIHZpc2libGVSYW5nZS5tYXggLSByYW5nZURpZmYpO1xuICAgIH1cbiAgICByZXR1cm4gdmlzaWJsZUluQ3VycmVudFJhbmdlO1xuICB9O1xuICBfX3Byb3RvLl9jYWxjUGFuZWxBcmVhU3VtID0gZnVuY3Rpb24gKHBhbmVscykge1xuICAgIHJldHVybiBwYW5lbHMucmVkdWNlKGZ1bmN0aW9uIChzdW0sIHBhbmVsKSB7XG4gICAgICByZXR1cm4gc3VtICsgcGFuZWwuc2l6ZUluY2x1ZGluZ01hcmdpbjtcbiAgICB9LCAwKTtcbiAgfTtcbiAgcmV0dXJuIENpcmN1bGFyQ2FtZXJhTW9kZTtcbn0oQ2FtZXJhTW9kZSk7XG5cbnZhciBCb3VuZENhbWVyYU1vZGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMkMyhCb3VuZENhbWVyYU1vZGUsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIEJvdW5kQ2FtZXJhTW9kZSgpIHtcbiAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cbiAgdmFyIF9fcHJvdG8gPSBCb3VuZENhbWVyYU1vZGUucHJvdG90eXBlO1xuICBfX3Byb3RvLmNoZWNrQXZhaWxhYmlsaXR5ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBmbGlja2luZyA9IHRoaXMuX2ZsaWNraW5nO1xuICAgIHZhciByZW5kZXJlciA9IGZsaWNraW5nLnJlbmRlcmVyO1xuICAgIHZhciBmaXJzdFBhbmVsID0gcmVuZGVyZXIuZ2V0UGFuZWwoMCk7XG4gICAgdmFyIGxhc3RQYW5lbCA9IHJlbmRlcmVyLmdldFBhbmVsKHJlbmRlcmVyLnBhbmVsQ291bnQgLSAxKTtcbiAgICBpZiAoIWZpcnN0UGFuZWwgfHwgIWxhc3RQYW5lbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgdmlld3BvcnRTaXplID0gZmxpY2tpbmcuY2FtZXJhLnNpemU7XG4gICAgdmFyIGZpcnN0UGFuZWxQcmV2ID0gZmlyc3RQYW5lbC5yYW5nZS5taW47XG4gICAgdmFyIGxhc3RQYW5lbE5leHQgPSBsYXN0UGFuZWwucmFuZ2UubWF4O1xuICAgIHZhciBwYW5lbEFyZWFTaXplID0gbGFzdFBhbmVsTmV4dCAtIGZpcnN0UGFuZWxQcmV2O1xuICAgIHZhciBpc0JpZ2dlclRoYW5WaWV3cG9ydCA9IHZpZXdwb3J0U2l6ZSA8IHBhbmVsQXJlYVNpemU7XG4gICAgcmV0dXJuIGlzQmlnZ2VyVGhhblZpZXdwb3J0O1xuICB9O1xuICBfX3Byb3RvLmdldFJhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBmbGlja2luZyA9IHRoaXMuX2ZsaWNraW5nO1xuICAgIHZhciByZW5kZXJlciA9IGZsaWNraW5nLnJlbmRlcmVyO1xuICAgIHZhciBhbGlnblBvcyA9IGZsaWNraW5nLmNhbWVyYS5hbGlnblBvc2l0aW9uO1xuICAgIHZhciBmaXJzdFBhbmVsID0gcmVuZGVyZXIuZ2V0UGFuZWwoMCk7XG4gICAgdmFyIGxhc3RQYW5lbCA9IHJlbmRlcmVyLmdldFBhbmVsKHJlbmRlcmVyLnBhbmVsQ291bnQgLSAxKTtcbiAgICBpZiAoIWZpcnN0UGFuZWwgfHwgIWxhc3RQYW5lbCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWluOiAwLFxuICAgICAgICBtYXg6IDBcbiAgICAgIH07XG4gICAgfVxuICAgIHZhciB2aWV3cG9ydFNpemUgPSBmbGlja2luZy5jYW1lcmEuc2l6ZTtcbiAgICB2YXIgZmlyc3RQYW5lbFByZXYgPSBmaXJzdFBhbmVsLnJhbmdlLm1pbjtcbiAgICB2YXIgbGFzdFBhbmVsTmV4dCA9IGxhc3RQYW5lbC5yYW5nZS5tYXg7XG4gICAgdmFyIHBhbmVsQXJlYVNpemUgPSBsYXN0UGFuZWxOZXh0IC0gZmlyc3RQYW5lbFByZXY7XG4gICAgdmFyIGlzQmlnZ2VyVGhhblZpZXdwb3J0ID0gdmlld3BvcnRTaXplIDwgcGFuZWxBcmVhU2l6ZTtcbiAgICB2YXIgZmlyc3RQb3MgPSBmaXJzdFBhbmVsUHJldiArIGFsaWduUG9zO1xuICAgIHZhciBsYXN0UG9zID0gbGFzdFBhbmVsTmV4dCAtIHZpZXdwb3J0U2l6ZSArIGFsaWduUG9zO1xuICAgIGlmIChpc0JpZ2dlclRoYW5WaWV3cG9ydCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWluOiBmaXJzdFBvcyxcbiAgICAgICAgbWF4OiBsYXN0UG9zXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYWxpZ24gPSBmbGlja2luZy5jYW1lcmEuYWxpZ247XG4gICAgICB2YXIgYWxpZ25WYWwgPSB0eXBlb2YgYWxpZ24gPT09IFwib2JqZWN0XCIgPyBhbGlnbi5jYW1lcmEgOiBhbGlnbjtcbiAgICAgIHZhciBwb3MgPSBmaXJzdFBvcyArIHBhcnNlQWxpZ24kMShhbGlnblZhbCwgbGFzdFBvcyAtIGZpcnN0UG9zKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1pbjogcG9zLFxuICAgICAgICBtYXg6IHBvc1xuICAgICAgfTtcbiAgICB9XG4gIH07XG4gIF9fcHJvdG8uZ2V0QW5jaG9ycyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZmxpY2tpbmcgPSB0aGlzLl9mbGlja2luZztcbiAgICB2YXIgY2FtZXJhID0gZmxpY2tpbmcuY2FtZXJhO1xuICAgIHZhciBwYW5lbHMgPSBmbGlja2luZy5yZW5kZXJlci5wYW5lbHM7XG4gICAgaWYgKHBhbmVscy5sZW5ndGggPD0gMCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICB2YXIgcmFuZ2UgPSBmbGlja2luZy5jYW1lcmEucmFuZ2U7XG4gICAgdmFyIHJlYWNoYWJsZVBhbmVscyA9IHBhbmVscy5maWx0ZXIoZnVuY3Rpb24gKHBhbmVsKSB7XG4gICAgICByZXR1cm4gY2FtZXJhLmNhblJlYWNoKHBhbmVsKTtcbiAgICB9KTtcbiAgICBpZiAocmVhY2hhYmxlUGFuZWxzLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciBzaG91bGRQcmVwZW5kQm91bmRBbmNob3IgPSByZWFjaGFibGVQYW5lbHNbMF0ucG9zaXRpb24gIT09IHJhbmdlLm1pbjtcbiAgICAgIHZhciBzaG91bGRBcHBlbmRCb3VuZEFuY2hvciA9IHJlYWNoYWJsZVBhbmVsc1tyZWFjaGFibGVQYW5lbHMubGVuZ3RoIC0gMV0ucG9zaXRpb24gIT09IHJhbmdlLm1heDtcbiAgICAgIHZhciBpbmRleE9mZnNldF8xID0gc2hvdWxkUHJlcGVuZEJvdW5kQW5jaG9yID8gMSA6IDA7XG4gICAgICB2YXIgbmV3QW5jaG9ycyA9IHJlYWNoYWJsZVBhbmVscy5tYXAoZnVuY3Rpb24gKHBhbmVsLCBpZHgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBbmNob3JQb2ludCh7XG4gICAgICAgICAgaW5kZXg6IGlkeCArIGluZGV4T2Zmc2V0XzEsXG4gICAgICAgICAgcG9zaXRpb246IHBhbmVsLnBvc2l0aW9uLFxuICAgICAgICAgIHBhbmVsOiBwYW5lbFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgaWYgKHNob3VsZFByZXBlbmRCb3VuZEFuY2hvcikge1xuICAgICAgICBuZXdBbmNob3JzLnNwbGljZSgwLCAwLCBuZXcgQW5jaG9yUG9pbnQoe1xuICAgICAgICAgIGluZGV4OiAwLFxuICAgICAgICAgIHBvc2l0aW9uOiByYW5nZS5taW4sXG4gICAgICAgICAgcGFuZWw6IHBhbmVsc1tyZWFjaGFibGVQYW5lbHNbMF0uaW5kZXggLSAxXVxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgICBpZiAoc2hvdWxkQXBwZW5kQm91bmRBbmNob3IpIHtcbiAgICAgICAgbmV3QW5jaG9ycy5wdXNoKG5ldyBBbmNob3JQb2ludCh7XG4gICAgICAgICAgaW5kZXg6IG5ld0FuY2hvcnMubGVuZ3RoLFxuICAgICAgICAgIHBvc2l0aW9uOiByYW5nZS5tYXgsXG4gICAgICAgICAgcGFuZWw6IHBhbmVsc1tyZWFjaGFibGVQYW5lbHNbcmVhY2hhYmxlUGFuZWxzLmxlbmd0aCAtIDFdLmluZGV4ICsgMV1cbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ld0FuY2hvcnM7XG4gICAgfSBlbHNlIGlmIChyYW5nZS5taW4gIT09IHJhbmdlLm1heCkge1xuICAgICAgLy8gVGhlcmUncmUgbW9yZSB0aGFuIDIgcGFuZWxzXG4gICAgICB2YXIgbmVhcmVzdFBhbmVsQXRNaW4gPSB0aGlzLl9maW5kTmVhcmVzdFBhbmVsKHJhbmdlLm1pbiwgcGFuZWxzKTtcbiAgICAgIHZhciBwYW5lbEF0TWluID0gbmVhcmVzdFBhbmVsQXRNaW4uaW5kZXggPT09IHBhbmVscy5sZW5ndGggLSAxID8gbmVhcmVzdFBhbmVsQXRNaW4ucHJldigpIDogbmVhcmVzdFBhbmVsQXRNaW47XG4gICAgICB2YXIgcGFuZWxBdE1heCA9IHBhbmVsQXRNaW4ubmV4dCgpO1xuICAgICAgcmV0dXJuIFtuZXcgQW5jaG9yUG9pbnQoe1xuICAgICAgICBpbmRleDogMCxcbiAgICAgICAgcG9zaXRpb246IHJhbmdlLm1pbixcbiAgICAgICAgcGFuZWw6IHBhbmVsQXRNaW5cbiAgICAgIH0pLCBuZXcgQW5jaG9yUG9pbnQoe1xuICAgICAgICBpbmRleDogMSxcbiAgICAgICAgcG9zaXRpb246IHJhbmdlLm1heCxcbiAgICAgICAgcGFuZWw6IHBhbmVsQXRNYXhcbiAgICAgIH0pXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFtuZXcgQW5jaG9yUG9pbnQoe1xuICAgICAgICBpbmRleDogMCxcbiAgICAgICAgcG9zaXRpb246IHJhbmdlLm1pbixcbiAgICAgICAgcGFuZWw6IHRoaXMuX2ZpbmROZWFyZXN0UGFuZWwocmFuZ2UubWluLCBwYW5lbHMpXG4gICAgICB9KV07XG4gICAgfVxuICB9O1xuICBfX3Byb3RvLmZpbmRBbmNob3JJbmNsdWRlUG9zaXRpb24gPSBmdW5jdGlvbiAocG9zaXRpb24pIHtcbiAgICB2YXIgY2FtZXJhID0gdGhpcy5fZmxpY2tpbmcuY2FtZXJhO1xuICAgIHZhciByYW5nZSA9IGNhbWVyYS5yYW5nZTtcbiAgICB2YXIgYW5jaG9ycyA9IGNhbWVyYS5hbmNob3JQb2ludHM7XG4gICAgaWYgKGFuY2hvcnMubGVuZ3RoIDw9IDApIHJldHVybiBudWxsO1xuICAgIGlmIChwb3NpdGlvbiA8PSByYW5nZS5taW4pIHtcbiAgICAgIHJldHVybiBhbmNob3JzWzBdO1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPj0gcmFuZ2UubWF4KSB7XG4gICAgICByZXR1cm4gYW5jaG9yc1thbmNob3JzLmxlbmd0aCAtIDFdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5maW5kQW5jaG9ySW5jbHVkZVBvc2l0aW9uLmNhbGwodGhpcywgcG9zaXRpb24pO1xuICAgIH1cbiAgfTtcbiAgX19wcm90by5fZmluZE5lYXJlc3RQYW5lbCA9IGZ1bmN0aW9uIChwb3MsIHBhbmVscykge1xuICAgIHZhciBwcmV2RGlzdCA9IEluZmluaXR5O1xuICAgIGZvciAodmFyIHBhbmVsSWR4ID0gMDsgcGFuZWxJZHggPCBwYW5lbHMubGVuZ3RoOyBwYW5lbElkeCsrKSB7XG4gICAgICB2YXIgcGFuZWwgPSBwYW5lbHNbcGFuZWxJZHhdO1xuICAgICAgdmFyIGRpc3QgPSBNYXRoLmFicyhwYW5lbC5wb3NpdGlvbiAtIHBvcyk7XG4gICAgICBpZiAoZGlzdCA+IHByZXZEaXN0KSB7XG4gICAgICAgIC8vIFJldHVybiBwcmV2aW91cyBhbmNob3JcbiAgICAgICAgcmV0dXJuIHBhbmVsc1twYW5lbElkeCAtIDFdO1xuICAgICAgfVxuICAgICAgcHJldkRpc3QgPSBkaXN0O1xuICAgIH1cbiAgICAvLyBSZXR1cm4gbGFzdCBhbmNob3JcbiAgICByZXR1cm4gcGFuZWxzW3BhbmVscy5sZW5ndGggLSAxXTtcbiAgfTtcbiAgcmV0dXJuIEJvdW5kQ2FtZXJhTW9kZTtcbn0oQ2FtZXJhTW9kZSk7XG5cbi8qKlxyXG4gKiBBIGNvbXBvbmVudCB0aGF0IG1hbmFnZXMgYWN0dWFsIG1vdmVtZW50IGluc2lkZSB0aGUgdmlld3BvcnRcclxuICogQGtvIOu3sO2PrO2KuCDrgrTsl5DshJzsnZgg7Iuk7KCcIOybgOyngeyehOydhCDri7Tri7ntlZjripQg7Lu07Y+s64SM7Yq4XHJcbiAqL1xudmFyIENhbWVyYSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKiAqL1xuICBmdW5jdGlvbiBDYW1lcmEoZmxpY2tpbmcsIF9hKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB2YXIgX2IgPSAoX2EgPT09IHZvaWQgMCA/IHt9IDogX2EpLmFsaWduLFxuICAgICAgYWxpZ24gPSBfYiA9PT0gdm9pZCAwID8gQUxJR04uQ0VOVEVSIDogX2I7XG4gICAgdGhpcy5fY2hlY2tUcmFuc2xhdGVTdXBwb3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGVfMSwgX2E7XG4gICAgICB2YXIgdHJhbnNmb3JtcyA9IFtcIndlYmtpdFRyYW5zZm9ybVwiLCBcIm1zVHJhbnNmb3JtXCIsIFwiTW96VHJhbnNmb3JtXCIsIFwiT1RyYW5zZm9ybVwiLCBcInRyYW5zZm9ybVwiXTtcbiAgICAgIHZhciBzdXBwb3J0ZWRTdHlsZSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZTtcbiAgICAgIHZhciB0cmFuc2Zvcm1OYW1lID0gXCJcIjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIHRyYW5zZm9ybXNfMSA9IF9fdmFsdWVzJDEodHJhbnNmb3JtcyksIHRyYW5zZm9ybXNfMV8xID0gdHJhbnNmb3Jtc18xLm5leHQoKTsgIXRyYW5zZm9ybXNfMV8xLmRvbmU7IHRyYW5zZm9ybXNfMV8xID0gdHJhbnNmb3Jtc18xLm5leHQoKSkge1xuICAgICAgICAgIHZhciBwcmVmaXhlZFRyYW5zZm9ybSA9IHRyYW5zZm9ybXNfMV8xLnZhbHVlO1xuICAgICAgICAgIGlmIChwcmVmaXhlZFRyYW5zZm9ybSBpbiBzdXBwb3J0ZWRTdHlsZSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtTmFtZSA9IHByZWZpeGVkVHJhbnNmb3JtO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZV8xXzEpIHtcbiAgICAgICAgZV8xID0ge1xuICAgICAgICAgIGVycm9yOiBlXzFfMVxuICAgICAgICB9O1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAodHJhbnNmb3Jtc18xXzEgJiYgIXRyYW5zZm9ybXNfMV8xLmRvbmUgJiYgKF9hID0gdHJhbnNmb3Jtc18xLnJldHVybikpIF9hLmNhbGwodHJhbnNmb3Jtc18xKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghdHJhbnNmb3JtTmFtZSkge1xuICAgICAgICB0aHJvdyBuZXcgRmxpY2tpbmdFcnJvcihNRVNTQUdFLlRSQU5TRk9STV9OT1RfU1VQUE9SVEVELCBDT0RFLlRSQU5TRk9STV9OT1RfU1VQUE9SVEVEKTtcbiAgICAgIH1cbiAgICAgIF90aGlzLl90cmFuc2Zvcm0gPSB0cmFuc2Zvcm1OYW1lO1xuICAgIH07XG4gICAgdGhpcy5fZmxpY2tpbmcgPSBmbGlja2luZztcbiAgICB0aGlzLl9yZXNldEludGVybmFsVmFsdWVzKCk7XG4gICAgLy8gT3B0aW9uc1xuICAgIHRoaXMuX2FsaWduID0gYWxpZ247XG4gIH1cbiAgdmFyIF9fcHJvdG8gPSBDYW1lcmEucHJvdG90eXBlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJlbGVtZW50XCIsIHtcbiAgICAvLyBJbnRlcm5hbCBzdGF0ZXMgZ2V0dGVyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgY2FtZXJhIGVsZW1lbnQoYC5mbGlja2luZy1jYW1lcmFgKVxyXG4gICAgICogQGtvIOy5tOuplOudvCDsl5jrpqzrqLztirgoYC5mbGlja2luZy1jYW1lcmFgKVxyXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9lbDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwiY2hpbGRyZW5cIiwge1xuICAgIC8qKlxyXG4gICAgICogQW4gYXJyYXkgb2YgdGhlIGNoaWxkIGVsZW1lbnRzIG9mIHRoZSBjYW1lcmEgZWxlbWVudChgLmZsaWNraW5nLWNhbWVyYWApXHJcbiAgICAgKiBAa28g7Lm066mU6528IOyXmOumrOuovO2KuChgLmZsaWNraW5nLWNhbWVyYWAp7J2YIOyekOyLnSDsl5jrpqzrqLztirgg67Cw7Je0XHJcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnRbXX1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdG9BcnJheSQyKHRoaXMuX2VsLmNoaWxkcmVuKTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwicG9zaXRpb25cIiwge1xuICAgIC8qKlxyXG4gICAgICogQ3VycmVudCBwb3NpdGlvbiBvZiB0aGUgY2FtZXJhXHJcbiAgICAgKiBAa28gQ2FtZXJh7J2YIO2YhOyerCDsooztkZxcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3Bvc2l0aW9uO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJhbGlnblBvc2l0aW9uXCIsIHtcbiAgICAvKipcclxuICAgICAqIEFsaWduIHBvc2l0aW9uIGluc2lkZSB0aGUgdmlld3BvcnQgd2hlcmUge0BsaW5rIFBhbmVsfSdzIHtAbGluayBQYW5lbCNhbGlnblBvc2l0aW9uIGFsaWduUG9zaXRpb259IHNob3VsZCBiZSBsb2NhdGVkIGF0XHJcbiAgICAgKiBAa28g7Yyo64SQ7J2YIOygleugrCDquLDspIAg7JyE7LmYLiDrt7Dtj6ztirgg64K07JeQ7IScIHtAbGluayBQYW5lbH3snZgge0BsaW5rIFBhbmVsI2FsaWduUG9zaXRpb24gYWxpZ25Qb3NpdGlvbn3snbQg7JyE7LmY7ZW07JW8IO2VmOuKlCDqs7PsnoXri4jri6RcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2FsaWduUG9zO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJvZmZzZXRcIiwge1xuICAgIC8qKlxyXG4gICAgICogUG9zaXRpb24gb2Zmc2V0LCB1c2VkIGZvciB0aGUge0BsaW5rIEZsaWNraW5nI3JlbmRlck9ubHlWaXNpYmxlIHJlbmRlck9ubHlWaXNpYmxlfSBvcHRpb25cclxuICAgICAqIEBrbyBDYW1lcmHsnZgg7KKM7ZGcIOyYpO2UhOyFiy4ge0BsaW5rIEZsaWNraW5nI3JlbmRlck9ubHlWaXNpYmxlIHJlbmRlck9ubHlWaXNpYmxlfSDsmLXshZjsnYQg7JyE7ZW0IOyCrOyaqeuQqeuLiOuLpC5cclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX29mZnNldCAtIHRoaXMuX2NpcmN1bGFyT2Zmc2V0O1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJjaXJjdWxhckVuYWJsZWRcIiwge1xuICAgIC8qKlxyXG4gICAgICogV2hldGhlciB0aGUgYGNpcmN1bGFyYCBvcHRpb24gaXMgZW5hYmxlZC5cclxuICAgICAqIFRoZSB7QGxpbmsgRmxpY2tpbmcjY2lyY3VsYXIgY2lyY3VsYXJ9IG9wdGlvbiBjYW4ndCBiZSBlbmFibGVkIHdoZW4gc3VtIG9mIHRoZSBwYW5lbCBzaXplcyBhcmUgdG9vIHNtYWxsLlxyXG4gICAgICogQGtvIHtAbGluayBGbGlja2luZyNjaXJjdWxhciBjaXJjdWxhcn0g7Ji17IWY7J20IO2ZnOyEse2ZlOuQmOyXiOuKlOyngCDsl6zrtoDrpbwg64KY7YOA64K064qUIOuppOuyhCDrs4DsiJguXHJcbiAgICAgKiB7QGxpbmsgRmxpY2tpbmcjY2lyY3VsYXIgY2lyY3VsYXJ9IOyYteyFmOydgCDtjKjrhJDsnZgg7YGs6riw7J2YIO2VqeydtCDstqnrtoTtlZjsp4Ag7JWK7J2EIOqyveyasCDruYTtmZzshLHtmZTrkKnri4jri6QuXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqIEBkZWZhdWx0IGZhbHNlXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NpcmN1bGFyRW5hYmxlZDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwibW9kZVwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBBIGN1cnJlbnQgY2FtZXJhIG1vZGVcclxuICAgICAqIEB0eXBlIHtDYW1lcmFNb2RlfVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tb2RlO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJyYW5nZVwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBBIHJhbmdlIHRoYXQgQ2FtZXJhJ3Mge0BsaW5rIENhbWVyYSNwb3NpdGlvbiBwb3NpdGlvbn0gY2FuIHJlYWNoXHJcbiAgICAgKiBAa28gQ2FtZXJh7J2YIHtAbGluayBDYW1lcmEjcG9zaXRpb24gcG9zaXRpb2597J20IOuPhOuLrCDqsIDriqXtlZwg67KU7JyEXHJcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG1pbiBBIG1pbmltdW0gcG9zaXRpb248a28+7LWc7IaMIOychOy5mDwva28+XHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbWF4IEEgbWF4aW11bSBwb3NpdGlvbjxrbz7stZzrjIAg7JyE7LmYPC9rbz5cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmFuZ2U7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcInJhbmdlRGlmZlwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBBIGRpZmZlcmVuY2UgYmV0d2VlbiBDYW1lcmEncyBtaW5pbXVtIGFuZCBtYXhpbXVtIHBvc2l0aW9uIHRoYXQgY2FuIHJlYWNoXHJcbiAgICAgKiBAa28gQ2FtZXJh6rCAIOuPhOuLrCDqsIDriqXtlZwg7LWc7IaML+y1nOuMgCDsooztkZzsnZgg7LCo7J20XHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yYW5nZS5tYXggLSB0aGlzLl9yYW5nZS5taW47XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcInZpc2libGVQYW5lbHNcIiwge1xuICAgIC8qKlxyXG4gICAgICogQW4gYXJyYXkgb2YgdmlzaWJsZSBwYW5lbHMgZnJvbSB0aGUgY3VycmVudCBwb3NpdGlvblxyXG4gICAgICogQGtvIO2YhOyerCDrs7TsnbTripQg7Yyo64SQ65Ok7J2YIOuwsOyXtFxyXG4gICAgICogQHR5cGUge1BhbmVsW119XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3Zpc2libGVQYW5lbHM7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcInZpc2libGVSYW5nZVwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBBIHJhbmdlIG9mIHRoZSB2aXNpYmxlIGFyZWEgZnJvbSB0aGUgY3VycmVudCBwb3NpdGlvblxyXG4gICAgICogQGtvIO2YhOyerCDsnITsuZjsl5DshJwg67O07J2064qUIOuylOychFxyXG4gICAgICogQHR5cGUge29iamVjdH1cclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtaW4gQSBtaW5pbXVtIHBvc2l0aW9uPGtvPuy1nOyGjCDsnITsuZg8L2tvPlxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG1pbiBBIG1heGltdW0gcG9zaXRpb248a28+7LWc64yAIOychOy5mDwva28+XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWluOiB0aGlzLl9wb3NpdGlvbiAtIHRoaXMuX2FsaWduUG9zLFxuICAgICAgICBtYXg6IHRoaXMuX3Bvc2l0aW9uIC0gdGhpcy5fYWxpZ25Qb3MgKyB0aGlzLnNpemVcbiAgICAgIH07XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcImFuY2hvclBvaW50c1wiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBBbiBhcnJheSBvZiB7QGxpbmsgQW5jaG9yUG9pbnR9cyB0aGF0IENhbWVyYSBjYW4gYmUgc3RvcHBlZCBhdFxyXG4gICAgICogQGtvIOy5tOuplOudvOqwgCDrj4Tri6wg6rCA64ql7ZWcIHtAbGluayBBbmNob3JQb2ludH3snZgg66qp66GdXHJcbiAgICAgKiBAdHlwZSB7QW5jaG9yUG9pbnRbXX1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYW5jaG9ycztcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwiY29udHJvbFBhcmFtc1wiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBBIGN1cnJlbnQgcGFyYW1ldGVycyBvZiB0aGUgQ2FtZXJhIGZvciB1cGRhdGluZyB7QGxpbmsgQXhlc0NvbnRyb2xsZXJ9XHJcbiAgICAgKiBAa28ge0BsaW5rIEF4ZXNDb250cm9sbGVyfeulvCDsl4XrjbDsnbTtirjtlZjquLAg7JyE7ZWcIO2YhOyerCBDYW1lcmEg7Yyo65+s66+47YSw65OkXHJcbiAgICAgKiBAdHlwZSB7Q29udHJvbFBhcmFtc31cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByYW5nZTogdGhpcy5fcmFuZ2UsXG4gICAgICAgIHBvc2l0aW9uOiB0aGlzLl9wb3NpdGlvbixcbiAgICAgICAgY2lyY3VsYXI6IHRoaXMuX2NpcmN1bGFyRW5hYmxlZFxuICAgICAgfTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwiYXRFZGdlXCIsIHtcbiAgICAvKipcclxuICAgICAqIEEgQm9vbGVhbiB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgQ2FtZXJhJ3Mgb3ZlciB0aGUgbWluaW11bSBvciBtYXhpbXVtIHBvc2l0aW9uIHJlYWNoYWJsZVxyXG4gICAgICogQGtvIO2YhOyerCDsubTrqZTrnbzqsIAg64+E64usIOqwgOuKpe2VnCDrspTsnITsnZgg7LWc7IaMIO2YueydgCDstZzrjIDsoJDsnYQg64SY7Ja07ISw64qU7KeA66W8IOuCmO2DgOuDheuLiOuLpFxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3Bvc2l0aW9uIDw9IHRoaXMuX3JhbmdlLm1pbiB8fCB0aGlzLl9wb3NpdGlvbiA+PSB0aGlzLl9yYW5nZS5tYXg7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcInNpemVcIiwge1xuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSBzaXplIG9mIHRoZSB2aWV3cG9ydFxyXG4gICAgICogQGtvIOu3sO2PrO2KuCDtgazquLDrpbwg67CY7ZmY7ZWp64uI64ukXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBmbGlja2luZyA9IHRoaXMuX2ZsaWNraW5nO1xuICAgICAgcmV0dXJuIGZsaWNraW5nID8gZmxpY2tpbmcuaG9yaXpvbnRhbCA/IGZsaWNraW5nLnZpZXdwb3J0LndpZHRoIDogZmxpY2tpbmcudmlld3BvcnQuaGVpZ2h0IDogMDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwicHJvZ3Jlc3NcIiwge1xuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSBjYW1lcmEncyBwb3NpdGlvbiBwcm9ncmVzcyBmcm9tIHRoZSBmaXJzdCBwYW5lbCB0byBsYXN0IHBhbmVsXHJcbiAgICAgKiBSYW5nZSBpcyBmcm9tIDAgdG8gbGFzdCBwYW5lbCdzIGluZGV4XHJcbiAgICAgKiBAa28g7LKr67KI7Ke4IO2MqOuEkOuhnOu2gO2EsCDrp4jsp4Drp4kg7Yyo64SQ6rmM7KeA7J2YIOy5tOuplOudvCDsnITsuZjsnZgg7KeE7ZaJ64+E66W8IOuwmO2ZmO2VqeuLiOuLpFxyXG4gICAgICog67KU7JyE64qUIDDrtoDthLAg66eI7KeA66eJIO2MqOuEkOydmCDsnbjrjbHsiqTquYzsp4DsnoXri4jri6RcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGZsaWNraW5nID0gdGhpcy5fZmxpY2tpbmc7XG4gICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLl9wb3NpdGlvbiArIHRoaXMuX29mZnNldDtcbiAgICAgIHZhciBuZWFyZXN0QW5jaG9yID0gdGhpcy5maW5kTmVhcmVzdEFuY2hvcih0aGlzLl9wb3NpdGlvbik7XG4gICAgICBpZiAoIWZsaWNraW5nIHx8ICFuZWFyZXN0QW5jaG9yKSB7XG4gICAgICAgIHJldHVybiBOYU47XG4gICAgICB9XG4gICAgICB2YXIgbmVhcmVzdFBhbmVsID0gbmVhcmVzdEFuY2hvci5wYW5lbDtcbiAgICAgIHZhciBwYW5lbFBvcyA9IG5lYXJlc3RQYW5lbC5wb3NpdGlvbiArIG5lYXJlc3RQYW5lbC5vZmZzZXQ7XG4gICAgICB2YXIgYm91bmNlU2l6ZSA9IGZsaWNraW5nLmNvbnRyb2wuY29udHJvbGxlci5ib3VuY2U7XG4gICAgICB2YXIgX2EgPSB0aGlzLnJhbmdlLFxuICAgICAgICBwcmV2UmFuZ2UgPSBfYS5taW4sXG4gICAgICAgIG5leHRSYW5nZSA9IF9hLm1heDtcbiAgICAgIHZhciByYW5nZURpZmYgPSB0aGlzLnJhbmdlRGlmZjtcbiAgICAgIGlmIChwb3NpdGlvbiA9PT0gcGFuZWxQb3MpIHtcbiAgICAgICAgcmV0dXJuIG5lYXJlc3RQYW5lbC5pbmRleDtcbiAgICAgIH1cbiAgICAgIGlmIChwb3NpdGlvbiA8IHBhbmVsUG9zKSB7XG4gICAgICAgIHZhciBwcmV2UGFuZWwgPSBuZWFyZXN0UGFuZWwucHJldigpO1xuICAgICAgICB2YXIgcHJldlBvc2l0aW9uID0gcHJldlBhbmVsID8gcHJldlBhbmVsLnBvc2l0aW9uICsgcHJldlBhbmVsLm9mZnNldCA6IHByZXZSYW5nZSAtIGJvdW5jZVNpemVbMF07XG4gICAgICAgIC8vIExvb3BlZFxuICAgICAgICBpZiAocHJldlBvc2l0aW9uID4gcGFuZWxQb3MpIHtcbiAgICAgICAgICBwcmV2UG9zaXRpb24gLT0gcmFuZ2VEaWZmO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZWFyZXN0UGFuZWwuaW5kZXggLSAxICsgZ2V0UHJvZ3Jlc3MocG9zaXRpb24sIHByZXZQb3NpdGlvbiwgcGFuZWxQb3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG5leHRQYW5lbCA9IG5lYXJlc3RQYW5lbC5uZXh0KCk7XG4gICAgICAgIHZhciBuZXh0UG9zaXRpb24gPSBuZXh0UGFuZWwgPyBuZXh0UGFuZWwucG9zaXRpb24gKyBuZXh0UGFuZWwub2Zmc2V0IDogbmV4dFJhbmdlICsgYm91bmNlU2l6ZVsxXTtcbiAgICAgICAgLy8gTG9vcGVkXG4gICAgICAgIGlmIChuZXh0UG9zaXRpb24gPCBwYW5lbFBvcykge1xuICAgICAgICAgIG5leHRQb3NpdGlvbiArPSByYW5nZURpZmY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5lYXJlc3RQYW5lbC5pbmRleCArIGdldFByb2dyZXNzKHBvc2l0aW9uLCBwYW5lbFBvcywgbmV4dFBvc2l0aW9uKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwicGFuZWxPcmRlclwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL2RpcmVjdGlvbiBkaXJlY3Rpb259IENTUyBwcm9wZXJ0eSBhcHBsaWVkIHRvIHRoZSBjYW1lcmEgZWxlbWVudChgLmZsaWNraW5nLWNhbWVyYWApXHJcbiAgICAgKiBAa28g7Lm066mU6528IOyXmOumrOuovO2KuChgLmZsaWNraW5nLWNhbWVyYWAp7JeQIOyggeyaqeuQnCB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL2RpcmVjdGlvbiBkaXJlY3Rpb259IENTUyDsho3shLFcclxuICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3BhbmVsT3JkZXI7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcImFsaWduXCIsIHtcbiAgICAvLyBPcHRpb25zIEdldHRlclxuICAgIC8qKlxyXG4gICAgICogQSB2YWx1ZSBpbmRpY2F0aW5nIHdoZXJlIHRoZSB7QGxpbmsgQ2FtZXJhI2FsaWduUG9zaXRpb24gYWxpZ25Qb3NpdGlvbn0gc2hvdWxkIGJlIGxvY2F0ZWQgYXQgaW5zaWRlIHRoZSB2aWV3cG9ydCBlbGVtZW50XHJcbiAgICAgKiBAa28ge0BsaW5rIENhbWVyYSNhbGlnblBvc2l0aW9uIGFsaWduUG9zaXRpb2597J20IOu3sO2PrO2KuCDsl5jrpqzrqLztirgg64K07J2YIOyWtOuUlOyXkCDsnITsuZjtlbTslbwg7ZWY64qU7KeA66W8IOuCmO2DgOuCtOuKlCDqsJJcclxuICAgICAqIEB0eXBlIHtBTElHTiB8IHN0cmluZyB8IG51bWJlcn1cclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2FsaWduO1xuICAgIH0sXG4gICAgLy8gT3B0aW9ucyBTZXR0ZXJcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHRoaXMuX2FsaWduID0gdmFsO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICAvKipcclxuICAgKiBJbml0aWFsaXplIENhbWVyYVxyXG4gICAqIEBrbyBDYW1lcmHrpbwg7LSI6riw7ZmU7ZWp64uI64ukXHJcbiAgICogQHRocm93cyB7RmxpY2tpbmdFcnJvcn1cclxuICAgKiB7QGxpbmsgRVJST1JfQ09ERSBWQUxfTVVTVF9OT1RfTlVMTH0gSWYgdGhlIGNhbWVyYSBlbGVtZW50KGAuZmxpY2tpbmctY2FtZXJhYCkgZG9lcyBub3QgZXhpc3QgaW5zaWRlIHZpZXdwb3J0IGVsZW1lbnRcclxuICAgKiA8a28+e0BsaW5rIEVSUk9SX0NPREUgVkFMX01VU1RfTk9UX05VTEx9IOu3sO2PrO2KuCDsl5jrpqzrqLztirgg64K067aA7JeQIOy5tOuplOudvCDsl5jrpqzrqLztirgoYC5mbGlja2luZy1jYW1lcmFgKeqwgCDsobTsnqztlZjsp4Ag7JWK7J2EIOqyveyasDwva28+XHJcbiAgICogQHJldHVybiB7dGhpc31cclxuICAgKi9cbiAgX19wcm90by5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2aWV3cG9ydEVsID0gdGhpcy5fZmxpY2tpbmcudmlld3BvcnQuZWxlbWVudDtcbiAgICBjaGVja0V4aXN0ZW5jZSh2aWV3cG9ydEVsLmZpcnN0RWxlbWVudENoaWxkLCBcIkZpcnN0IGVsZW1lbnQgY2hpbGQgb2YgdGhlIHZpZXdwb3J0IGVsZW1lbnRcIik7XG4gICAgdGhpcy5fZWwgPSB2aWV3cG9ydEVsLmZpcnN0RWxlbWVudENoaWxkO1xuICAgIHRoaXMuX2NoZWNrVHJhbnNsYXRlU3VwcG9ydCgpO1xuICAgIHRoaXMuX3VwZGF0ZU1vZGUoKTtcbiAgICB0aGlzLnVwZGF0ZVBhbmVsT3JkZXIoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXHJcbiAgICogRGVzdHJveSBDYW1lcmEgYW5kIHJldHVybiB0byBpbml0aWFsIHN0YXRlXHJcbiAgICogQGtvIENhbWVyYeulvCDstIjquLAg7IOB7YOc66GcIOuQmOuPjOumveuLiOuLpFxyXG4gICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICovXG4gIF9fcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9yZXNldEludGVybmFsVmFsdWVzKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxyXG4gICAqIE1vdmUgdG8gdGhlIGdpdmVuIHBvc2l0aW9uIGFuZCBhcHBseSBDU1MgdHJhbnNmb3JtXHJcbiAgICogQGtvIO2VtOuLuSDsooztkZzroZwg7J2064+Z7ZWY6rOgLCBDU1MgdHJhbnNmb3Jt7J2EIOyggeyaqe2VqeuLiOuLpFxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgQSBuZXcgcG9zaXRpb248a28+7JuA7KeB7J28IOychOy5mDwva28+XHJcbiAgICogQHRocm93cyB7RmxpY2tpbmdFcnJvcn1cclxuICAgKiB7QGxpbmsgRVJST1JfQ09ERSBOT1RfQVRUQUNIRURfVE9fRkxJQ0tJTkd9IFdoZW4ge0BsaW5rIENhbWVyYSNpbml0IGluaXR9IGlzIG5vdCBjYWxsZWQgYmVmb3JlXHJcbiAgICogPGtvPntAbGluayBFUlJPUl9DT0RFIE5PVF9BVFRBQ0hFRF9UT19GTElDS0lOR30ge0BsaW5rIENhbWVyYSNpbml0IGluaXR97J20IOydtOyghOyXkCDtmLjstpzrkJjsp4Ag7JWK7J2AIOqyveyasDwva28+XHJcbiAgICogQHJldHVybiB7dGhpc31cclxuICAgKi9cbiAgX19wcm90by5sb29rQXQgPSBmdW5jdGlvbiAocG9zKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB2YXIgZmxpY2tpbmcgPSBnZXRGbGlja2luZ0F0dGFjaGVkKHRoaXMuX2ZsaWNraW5nKTtcbiAgICB2YXIgcHJldlBvcyA9IHRoaXMuX3Bvc2l0aW9uO1xuICAgIHRoaXMuX3Bvc2l0aW9uID0gcG9zO1xuICAgIHZhciB0b2dnbGVkID0gdGhpcy5fdG9nZ2xlUGFuZWxzKHByZXZQb3MsIHBvcyk7XG4gICAgdGhpcy5fcmVmcmVzaFZpc2libGVQYW5lbHMoKTtcbiAgICB0aGlzLl9jaGVja05lZWRQYW5lbCgpO1xuICAgIHRoaXMuX2NoZWNrUmVhY2hFbmQocHJldlBvcywgcG9zKTtcbiAgICBpZiAodG9nZ2xlZCkge1xuICAgICAgdm9pZCBmbGlja2luZy5yZW5kZXJlci5yZW5kZXIoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMudXBkYXRlT2Zmc2V0KCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hcHBseVRyYW5zZm9ybSgpO1xuICAgIH1cbiAgfTtcbiAgLyoqXHJcbiAgICogUmV0dXJuIGEgcHJldmlvdXMge0BsaW5rIEFuY2hvclBvaW50fSBvZiBnaXZlbiB7QGxpbmsgQW5jaG9yUG9pbnR9XHJcbiAgICogSWYgaXQgZG9lcyBub3QgZXhpc3QsIHJldHVybiBgbnVsbGAgaW5zdGVhZFxyXG4gICAqIEBrbyDso7zslrTsp4Qge0BsaW5rIEFuY2hvclBvaW50feydmCDsnbTsoIQge0BsaW5rIEFuY2hvclBvaW50feulvCDrsJjtmZjtlanri4jri6RcclxuICAgKiDsobTsnqztlZjsp4Ag7JWK7J2EIOqyveyasCBgbnVsbGDsnYQg67CY7ZmY7ZWp64uI64ukXHJcbiAgICogQHBhcmFtIHtBbmNob3JQb2ludH0gYW5jaG9yIEEgcmVmZXJlbmNlIHtAbGluayBBbmNob3JQb2ludH08a28+6riw7KSAIHtAbGluayBBbmNob3JQb2ludH08L2tvPlxyXG4gICAqIEByZXR1cm4ge0FuY2hvclBvaW50IHwgbnVsbH0gVGhlIHByZXZpb3VzIHtAbGluayBBbmNob3JQb2ludH08a28+7J207KCEIHtAbGluayBBbmNob3JQb2ludH08L2tvPlxyXG4gICAqL1xuICBfX3Byb3RvLmdldFByZXZBbmNob3IgPSBmdW5jdGlvbiAoYW5jaG9yKSB7XG4gICAgaWYgKCF0aGlzLl9jaXJjdWxhckVuYWJsZWQgfHwgYW5jaG9yLmluZGV4ICE9PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYW5jaG9yc1thbmNob3IuaW5kZXggLSAxXSB8fCBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYW5jaG9ycyA9IHRoaXMuX2FuY2hvcnM7XG4gICAgICB2YXIgcmFuZ2VEaWZmID0gdGhpcy5yYW5nZURpZmY7XG4gICAgICB2YXIgbGFzdEFuY2hvciA9IGFuY2hvcnNbYW5jaG9ycy5sZW5ndGggLSAxXTtcbiAgICAgIHJldHVybiBuZXcgQW5jaG9yUG9pbnQoe1xuICAgICAgICBpbmRleDogbGFzdEFuY2hvci5pbmRleCxcbiAgICAgICAgcG9zaXRpb246IGxhc3RBbmNob3IucG9zaXRpb24gLSByYW5nZURpZmYsXG4gICAgICAgIHBhbmVsOiBsYXN0QW5jaG9yLnBhbmVsXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIC8qKlxyXG4gICAqIFJldHVybiBhIG5leHQge0BsaW5rIEFuY2hvclBvaW50fSBvZiBnaXZlbiB7QGxpbmsgQW5jaG9yUG9pbnR9XHJcbiAgICogSWYgaXQgZG9lcyBub3QgZXhpc3QsIHJldHVybiBgbnVsbGAgaW5zdGVhZFxyXG4gICAqIEBrbyDso7zslrTsp4Qge0BsaW5rIEFuY2hvclBvaW50feydmCDri6TsnYwge0BsaW5rIEFuY2hvclBvaW50feulvCDrsJjtmZjtlanri4jri6RcclxuICAgKiDsobTsnqztlZjsp4Ag7JWK7J2EIOqyveyasCBgbnVsbGDsnYQg67CY7ZmY7ZWp64uI64ukXHJcbiAgICogQHBhcmFtIHtBbmNob3JQb2ludH0gYW5jaG9yIEEgcmVmZXJlbmNlIHtAbGluayBBbmNob3JQb2ludH08a28+6riw7KSAIHtAbGluayBBbmNob3JQb2ludH08L2tvPlxyXG4gICAqIEByZXR1cm4ge0FuY2hvclBvaW50IHwgbnVsbH0gVGhlIG5leHQge0BsaW5rIEFuY2hvclBvaW50fTxrbz7ri6TsnYwge0BsaW5rIEFuY2hvclBvaW50fTwva28+XHJcbiAgICovXG4gIF9fcHJvdG8uZ2V0TmV4dEFuY2hvciA9IGZ1bmN0aW9uIChhbmNob3IpIHtcbiAgICB2YXIgYW5jaG9ycyA9IHRoaXMuX2FuY2hvcnM7XG4gICAgaWYgKCF0aGlzLl9jaXJjdWxhckVuYWJsZWQgfHwgYW5jaG9yLmluZGV4ICE9PSBhbmNob3JzLmxlbmd0aCAtIDEpIHtcbiAgICAgIHJldHVybiBhbmNob3JzW2FuY2hvci5pbmRleCArIDFdIHx8IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciByYW5nZURpZmYgPSB0aGlzLnJhbmdlRGlmZjtcbiAgICAgIHZhciBmaXJzdEFuY2hvciA9IGFuY2hvcnNbMF07XG4gICAgICByZXR1cm4gbmV3IEFuY2hvclBvaW50KHtcbiAgICAgICAgaW5kZXg6IGZpcnN0QW5jaG9yLmluZGV4LFxuICAgICAgICBwb3NpdGlvbjogZmlyc3RBbmNob3IucG9zaXRpb24gKyByYW5nZURpZmYsXG4gICAgICAgIHBhbmVsOiBmaXJzdEFuY2hvci5wYW5lbFxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICAvKipcclxuICAgKiBSZXR1cm4gdGhlIGNhbWVyYSdzIHBvc2l0aW9uIHByb2dyZXNzIGluIHRoZSBwYW5lbCBiZWxvd1xyXG4gICAqIFZhbHVlIGlzIGZyb20gMCB0byAxIHdoZW4gdGhlIGNhbWVyYSdzIGluc2lkZSBwYW5lbFxyXG4gICAqIFZhbHVlIGNhbiBiZSBsb3dlciB0aGFuIDAgb3IgYmlnZ2VyIHRoYW4gMSB3aGVuIGl0J3MgaW4gdGhlIG1hcmdpbiBhcmVhXHJcbiAgICogQGtvIO2YhOyerCDsubTrqZTrnbwg7JWE656YIO2MqOuEkOyXkOyEnOydmCDsnITsuZgg7KeE7ZaJ64+E66W8IOuwmO2ZmO2VqeuLiOuLpFxyXG4gICAqIOuwmO2ZmOqwkuydgCDsubTrqZTrnbzqsIAg7Yyo64SQIOuCtOu2gOyXkCDsnojsnYQg6rK97JqwIDDrtoDthLAgMeq5jOyngOydmCDqsJLsnYQg6rCW7Iq164uI64ukXHJcbiAgICog7Yyo64SQ7J2YIG1hcmdpbiDsmIHsl63sl5Ag7J6I7J2EIOqyveyasCAw67O064ukIOyekeqxsOuCmCAx67O064ukIO2BsCDqsJLsnYQg67CY7ZmY7ZWgIOyImCDsnojsirXri4jri6RcclxuICAgKi9cbiAgX19wcm90by5nZXRQcm9ncmVzc0luUGFuZWwgPSBmdW5jdGlvbiAocGFuZWwpIHtcbiAgICB2YXIgcGFuZWxSYW5nZSA9IHBhbmVsLnJhbmdlO1xuICAgIHJldHVybiAodGhpcy5fcG9zaXRpb24gLSBwYW5lbFJhbmdlLm1pbikgLyAocGFuZWxSYW5nZS5tYXggLSBwYW5lbFJhbmdlLm1pbik7XG4gIH07XG4gIC8qKlxyXG4gICAqIFJldHVybiB7QGxpbmsgQW5jaG9yUG9pbnR9IHRoYXQgaW5jbHVkZXMgZ2l2ZW4gcG9zaXRpb25cclxuICAgKiBJZiB0aGVyZSdzIG5vIHtAbGluayBBbmNob3JQb2ludH0gdGhhdCBpbmNsdWRlcyB0aGUgZ2l2ZW4gcG9zaXRpb24sIHJldHVybiBgbnVsbGAgaW5zdGVhZFxyXG4gICAqIEBrbyDso7zslrTsp4Qg7KKM7ZGc66W8IO2PrO2VqO2VmOuKlCB7QGxpbmsgQW5jaG9yUG9pbnR966W8IOuwmO2ZmO2VqeuLiOuLpFxyXG4gICAqIOyjvOyWtOynhCDsooztkZzrpbwg7Y+s7ZWo7ZWY64qUIHtAbGluayBBbmNob3JQb2ludH3qsIAg7JeG7J2EIOqyveyasCBgbnVsbGDsnYQg67CY7ZmY7ZWp64uI64ukXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHBvc2l0aW9uIEEgcG9zaXRpb24gdG8gY2hlY2s8a28+7ZmV7J247ZWgIOyijO2RnDwva28+XHJcbiAgICogQHJldHVybiB7QW5jaG9yUG9pbnQgfCBudWxsfSBUaGUge0BsaW5rIEFuY2hvclBvaW50fSB0aGF0IGluY2x1ZGVzIHRoZSBnaXZlbiBwb3NpdGlvbjxrbz7tlbTri7kg7KKM7ZGc66W8IO2PrO2VqO2VmOuKlCB7QGxpbmsgQW5jaG9yUG9pbnR9PC9rbz5cclxuICAgKi9cbiAgX19wcm90by5maW5kQW5jaG9ySW5jbHVkZVBvc2l0aW9uID0gZnVuY3Rpb24gKHBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuX21vZGUuZmluZEFuY2hvckluY2x1ZGVQb3NpdGlvbihwb3NpdGlvbik7XG4gIH07XG4gIC8qKlxyXG4gICAqIFJldHVybiB7QGxpbmsgQW5jaG9yUG9pbnR9IG5lYXJlc3QgdG8gZ2l2ZW4gcG9zaXRpb25cclxuICAgKiBJZiB0aGVyZSdyZSBubyB7QGxpbmsgQW5jaG9yUG9pbnR9cywgcmV0dXJuIGBudWxsYCBpbnN0ZWFkXHJcbiAgICogQGtvIO2VtOuLuSDsooztkZzsl5DshJwg6rCA7J6lIOqwgOq5jOyatCB7QGxpbmsgQW5jaG9yUG9pbnR966W8IOuwmO2ZmO2VqeuLiOuLpFxyXG4gICAqIHtAbGluayBBbmNob3JQb2ludH3qsIAg7ZWY64KY64+EIOyXhuydhCDqsr3smrAgYG51bGxg7J2EIOuwmO2ZmO2VqeuLiOuLpFxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwb3NpdGlvbiBBIHBvc2l0aW9uIHRvIGNoZWNrPGtvPu2ZleyduO2VoCDsooztkZw8L2tvPlxyXG4gICAqIEByZXR1cm4ge0FuY2hvclBvaW50IHwgbnVsbH0gVGhlIHtAbGluayBBbmNob3JQb2ludH0gbmVhcmVzdCB0byB0aGUgZ2l2ZW4gcG9zaXRpb248a28+7ZW064u5IOyijO2RnOyXkCDqsIDsnqUg7J247KCR7ZWcIHtAbGluayBBbmNob3JQb2ludH08L2tvPlxyXG4gICAqL1xuICBfX3Byb3RvLmZpbmROZWFyZXN0QW5jaG9yID0gZnVuY3Rpb24gKHBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuX21vZGUuZmluZE5lYXJlc3RBbmNob3IocG9zaXRpb24pO1xuICB9O1xuICAvKipcclxuICAgKiBSZXR1cm4ge0BsaW5rIEFuY2hvclBvaW50fSB0aGF0IG1hdGNoZXMge0BsaW5rIEZsaWNraW5nI2N1cnJlbnRQYW5lbH1cclxuICAgKiBAa28g7ZiE7J6sIHtAbGluayBGbGlja2luZyNjdXJyZW50UGFuZWx97JeQIO2VtOuLue2VmOuKlCB7QGxpbmsgQW5jaG9yUG9pbnR966W8IOuwmO2ZmO2VqeuLiOuLpFxyXG4gICAqIEByZXR1cm4ge0FuY2hvclBvaW50IHwgbnVsbH1cclxuICAgKi9cbiAgX19wcm90by5maW5kQWN0aXZlQW5jaG9yID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfYTtcbiAgICB2YXIgZmxpY2tpbmcgPSBnZXRGbGlja2luZ0F0dGFjaGVkKHRoaXMuX2ZsaWNraW5nKTtcbiAgICB2YXIgYWN0aXZlUGFuZWwgPSBmbGlja2luZy5jb250cm9sLmFjdGl2ZVBhbmVsO1xuICAgIGlmICghYWN0aXZlUGFuZWwpIHJldHVybiBudWxsO1xuICAgIHJldHVybiAoX2EgPSBmaW5kJDEodGhpcy5fYW5jaG9ycywgZnVuY3Rpb24gKGFuY2hvcikge1xuICAgICAgcmV0dXJuIGFuY2hvci5wYW5lbC5pbmRleCA9PT0gYWN0aXZlUGFuZWwuaW5kZXg7XG4gICAgfSkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRoaXMuZmluZE5lYXJlc3RBbmNob3IoYWN0aXZlUGFuZWwucG9zaXRpb24pO1xuICB9O1xuICAvKipcclxuICAgKiBDbGFtcCB0aGUgZ2l2ZW4gcG9zaXRpb24gYmV0d2VlbiBjYW1lcmEncyByYW5nZVxyXG4gICAqIEBrbyDso7zslrTsp4Qg7KKM7ZGc66W8IENhbWVyYeqwgCDrj4Tri6wg6rCA64ql7ZWcIOuylOychCDsgqzsnbTsnZgg6rCS7Jy866GcIOunjOuTreuLiOuLpFxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwb3NpdGlvbiBBIHBvc2l0aW9uIHRvIGNsYW1wPGtvPuuylOychOulvCDsoJztlZztlaAg7KKM7ZGcPC9rbz5cclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IEEgY2xhbXBlZCBwb3NpdGlvbjxrbz7rspTsnIQg7KCc7ZWc65CcIOyijO2RnDwva28+XHJcbiAgICovXG4gIF9fcHJvdG8uY2xhbXBUb1JlYWNoYWJsZVBvc2l0aW9uID0gZnVuY3Rpb24gKHBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuX21vZGUuY2xhbXBUb1JlYWNoYWJsZVBvc2l0aW9uKHBvc2l0aW9uKTtcbiAgfTtcbiAgLyoqXHJcbiAgICogQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gcGFuZWwgaXMgaW5zaWRlIG9mIHRoZSBDYW1lcmEncyByYW5nZVxyXG4gICAqIEBrbyDtlbTri7kge0BsaW5rIFBhbmVsfeydtCBDYW1lcmHqsIAg64+E64usIOqwgOuKpe2VnCDrspTsnIQg64K07JeQIOyeiOuKlOyngOulvCDrsJjtmZjtlanri4jri6RcclxuICAgKiBAcGFyYW0gcGFuZWwgQW4gaW5zdGFuY2Ugb2Yge0BsaW5rIFBhbmVsfSB0byBjaGVjazxrbz7tmZXsnbjtlaAge0BsaW5rIFBhbmVsfeydmCDsnbjsiqTthLTsiqQ8L2tvPlxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHBhbmVsJ3MgaW5zaWRlIENhbWVyYSdzIHJhbmdlPGtvPuuPhOuLrCDqsIDriqXtlZwg67KU7JyEIOuCtOyXkCDtlbTri7kg7Yyo64SQ7J20IOyhtOyerO2VmOuKlOyngCDsl6zrtoA8L2tvPlxyXG4gICAqL1xuICBfX3Byb3RvLmNhblJlYWNoID0gZnVuY3Rpb24gKHBhbmVsKSB7XG4gICAgcmV0dXJuIHRoaXMuX21vZGUuY2FuUmVhY2gocGFuZWwpO1xuICB9O1xuICAvKipcclxuICAgKiBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiBwYW5lbCBlbGVtZW50IGlzIHZpc2libGUgYXQgdGhlIGN1cnJlbnQgcG9zaXRpb25cclxuICAgKiBAa28g7ZiE7J6sIOyijO2RnOyXkOyEnCDtlbTri7kg7Yyo64SQIOyXmOumrOuovO2KuOulvCDrs7wg7IiYIOyeiOuKlOyngCDsl6zrtoDrpbwg67CY7ZmY7ZWp64uI64ukXHJcbiAgICogQHBhcmFtIHBhbmVsIEFuIGluc3RhbmNlIG9mIHtAbGluayBQYW5lbH0gdG8gY2hlY2s8a28+7ZmV7J247ZWgIHtAbGluayBQYW5lbH3snZgg7J247Iqk7YS07IqkPC9rbz5cclxuICAgKiBAcmV0dXJuIFdoZXRoZXIgdGhlIHBhbmVsIGVsZW1lbnQgaXMgdmlzaWJsZSBhdCB0aGUgY3VycmVudCBwb3NpdGlvbjxrbz7tmITsnqwg7JyE7LmY7JeQ7IScIO2VtOuLuSDtjKjrhJAg7JeY66as66i87Yq46rCAIOuztOydtOuKlOyngCDsl6zrtoA8L2tvPlxyXG4gICAqL1xuICBfX3Byb3RvLmNhblNlZSA9IGZ1bmN0aW9uIChwYW5lbCkge1xuICAgIHJldHVybiB0aGlzLl9tb2RlLmNhblNlZShwYW5lbCk7XG4gIH07XG4gIC8qKlxyXG4gICAqIFVwZGF0ZSB7QGxpbmsgQ2FtZXJhI3JhbmdlIHJhbmdlfSBvZiBDYW1lcmFcclxuICAgKiBAa28gQ2FtZXJh7J2YIHtAbGluayBDYW1lcmEjcmFuZ2UgcmFuZ2V966W8IOyXheuNsOydtO2KuO2VqeuLiOuLpFxyXG4gICAqIEBtZXRob2RcclxuICAgKiBAYWJzdHJhY3RcclxuICAgKiBAbWVtYmVyb2YgQ2FtZXJhXHJcbiAgICogQGluc3RhbmNlXHJcbiAgICogQG5hbWUgdXBkYXRlUmFuZ2VcclxuICAgKiBAY2hhaW5hYmxlXHJcbiAgICogQHRocm93cyB7RmxpY2tpbmdFcnJvcn1cclxuICAgKiB7QGxpbmsgRVJST1JfQ09ERSBOT1RfQVRUQUNIRURfVE9fRkxJQ0tJTkd9IFdoZW4ge0BsaW5rIENhbWVyYSNpbml0IGluaXR9IGlzIG5vdCBjYWxsZWQgYmVmb3JlXHJcbiAgICogPGtvPntAbGluayBFUlJPUl9DT0RFIE5PVF9BVFRBQ0hFRF9UT19GTElDS0lOR30ge0BsaW5rIENhbWVyYSNpbml0IGluaXR97J20IOydtOyghOyXkCDtmLjstpzrkJjsp4Ag7JWK7J2AIOqyveyasDwva28+XHJcbiAgICogQHJldHVybiB7dGhpc31cclxuICAgKi9cbiAgX19wcm90by51cGRhdGVSYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZmxpY2tpbmcgPSBnZXRGbGlja2luZ0F0dGFjaGVkKHRoaXMuX2ZsaWNraW5nKTtcbiAgICB2YXIgcmVuZGVyZXIgPSBmbGlja2luZy5yZW5kZXJlcjtcbiAgICB2YXIgcGFuZWxzID0gcmVuZGVyZXIucGFuZWxzO1xuICAgIHRoaXMuX3VwZGF0ZU1vZGUoKTtcbiAgICB0aGlzLl9yYW5nZSA9IHRoaXMuX21vZGUuZ2V0UmFuZ2UoKTtcbiAgICBwYW5lbHMuZm9yRWFjaChmdW5jdGlvbiAocGFuZWwpIHtcbiAgICAgIHJldHVybiBwYW5lbC51cGRhdGVDaXJjdWxhclRvZ2dsZURpcmVjdGlvbigpO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcclxuICAgKiBVcGRhdGUgQ2FtZXJhJ3Mge0BsaW5rIENhbWVyYSNhbGlnblBvc2l0aW9uIGFsaWduUG9zaXRpb259XHJcbiAgICogQGtvIENhbWVyYeydmCB7QGxpbmsgQ2FtZXJhI2FsaWduUG9zaXRpb24gYWxpZ25Qb3NpdGlvbn3snYQg7JeF642w7J207Yq47ZWp64uI64ukXHJcbiAgICogQGNoYWluYWJsZVxyXG4gICAqIEByZXR1cm4ge3RoaXN9XHJcbiAgICovXG4gIF9fcHJvdG8udXBkYXRlQWxpZ25Qb3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFsaWduID0gdGhpcy5fYWxpZ247XG4gICAgdmFyIGFsaWduVmFsID0gdHlwZW9mIGFsaWduID09PSBcIm9iamVjdFwiID8gYWxpZ24uY2FtZXJhIDogYWxpZ247XG4gICAgdGhpcy5fYWxpZ25Qb3MgPSBwYXJzZUFsaWduJDEoYWxpZ25WYWwsIHRoaXMuc2l6ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxyXG4gICAqIFVwZGF0ZSBDYW1lcmEncyB7QGxpbmsgQ2FtZXJhI2FuY2hvclBvaW50cyBhbmNob3JQb2ludHN9XHJcbiAgICogQGtvIENhbWVyYeydmCB7QGxpbmsgQ2FtZXJhI2FuY2hvclBvaW50cyBhbmNob3JQb2ludHN966W8IOyXheuNsOydtO2KuO2VqeuLiOuLpFxyXG4gICAqIEB0aHJvd3Mge0ZsaWNraW5nRXJyb3J9XHJcbiAgICoge0BsaW5rIEVSUk9SX0NPREUgTk9UX0FUVEFDSEVEX1RPX0ZMSUNLSU5HfSBXaGVuIHtAbGluayBDYW1lcmEjaW5pdCBpbml0fSBpcyBub3QgY2FsbGVkIGJlZm9yZVxyXG4gICAqIDxrbz57QGxpbmsgRVJST1JfQ09ERSBOT1RfQVRUQUNIRURfVE9fRkxJQ0tJTkd9IHtAbGluayBDYW1lcmEjaW5pdCBpbml0feydtCDsnbTsoITsl5Ag7Zi47Lac65CY7KeAIOyViuydgCDqsr3smrA8L2tvPlxyXG4gICAqIEBjaGFpbmFibGVcclxuICAgKiBAcmV0dXJuIHt0aGlzfVxyXG4gICAqL1xuICBfX3Byb3RvLnVwZGF0ZUFuY2hvcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fYW5jaG9ycyA9IHRoaXMuX21vZGUuZ2V0QW5jaG9ycygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcclxuICAgKiBVcGRhdGUgVmlld3BvcnQncyBoZWlnaHQgdG8gYWN0aXZlIHBhbmVsJ3MgaGVpZ2h0XHJcbiAgICogQGtvIO2YhOyerCDshKDtg53rkJwg7Yyo64SQ7J2YIOuGkuydtOyZgCDrj5nsnbztlZjrj4TroZ0g67ew7Y+s7Yq47J2YIOuGkuydtOulvCDsl4XrjbDsnbTtirjtlanri4jri6RcclxuICAgKiBAdGhyb3dzIHtGbGlja2luZ0Vycm9yfVxyXG4gICAqIHtAbGluayBFUlJPUl9DT0RFIE5PVF9BVFRBQ0hFRF9UT19GTElDS0lOR30gV2hlbiB7QGxpbmsgQ2FtZXJhI2luaXQgaW5pdH0gaXMgbm90IGNhbGxlZCBiZWZvcmVcclxuICAgKiA8a28+e0BsaW5rIEVSUk9SX0NPREUgTk9UX0FUVEFDSEVEX1RPX0ZMSUNLSU5HfSB7QGxpbmsgQ2FtZXJhI2luaXQgaW5pdH3snbQg7J207KCE7JeQIO2YuOy2nOuQmOyngCDslYrsnYAg6rK97JqwPC9rbz5cclxuICAgKiBAY2hhaW5hYmxlXHJcbiAgICogQHJldHVybiB7dGhpc31cclxuICAgKi9cbiAgX19wcm90by51cGRhdGVBZGFwdGl2ZUhlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZmxpY2tpbmcgPSBnZXRGbGlja2luZ0F0dGFjaGVkKHRoaXMuX2ZsaWNraW5nKTtcbiAgICB2YXIgYWN0aXZlUGFuZWwgPSBmbGlja2luZy5jb250cm9sLmFjdGl2ZVBhbmVsO1xuICAgIGlmICghZmxpY2tpbmcuaG9yaXpvbnRhbCB8fCAhZmxpY2tpbmcuYWRhcHRpdmUgfHwgIWFjdGl2ZVBhbmVsKSByZXR1cm47XG4gICAgZmxpY2tpbmcudmlld3BvcnQuc2V0U2l6ZSh7XG4gICAgICBoZWlnaHQ6IGFjdGl2ZVBhbmVsLmhlaWdodFxuICAgIH0pO1xuICB9O1xuICAvKipcclxuICAgKiBVcGRhdGUgY3VycmVudCBvZmZzZXQgb2YgdGhlIGNhbWVyYVxyXG4gICAqIEBrbyDtmITsnqwg7Lm066mU65287J2YIOyYpO2UhOyFi+ydhCDsl4XrjbDsnbTtirjtlanri4jri6RcclxuICAgKiBAY2hhaW5hYmxlXHJcbiAgICogQHJldHVybiB7dGhpc31cclxuICAgKi9cbiAgX19wcm90by51cGRhdGVPZmZzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZsaWNraW5nID0gZ2V0RmxpY2tpbmdBdHRhY2hlZCh0aGlzLl9mbGlja2luZyk7XG4gICAgdmFyIHBvc2l0aW9uID0gdGhpcy5fcG9zaXRpb247XG4gICAgdmFyIHVuUmVuZGVyZWRQYW5lbHMgPSBmbGlja2luZy5wYW5lbHMuZmlsdGVyKGZ1bmN0aW9uIChwYW5lbCkge1xuICAgICAgcmV0dXJuICFwYW5lbC5yZW5kZXJlZDtcbiAgICB9KTtcbiAgICB0aGlzLl9vZmZzZXQgPSB1blJlbmRlcmVkUGFuZWxzLmZpbHRlcihmdW5jdGlvbiAocGFuZWwpIHtcbiAgICAgIHJldHVybiBwYW5lbC5wb3NpdGlvbiArIHBhbmVsLm9mZnNldCA8IHBvc2l0aW9uO1xuICAgIH0pLnJlZHVjZShmdW5jdGlvbiAob2Zmc2V0LCBwYW5lbCkge1xuICAgICAgcmV0dXJuIG9mZnNldCArIHBhbmVsLnNpemVJbmNsdWRpbmdNYXJnaW47XG4gICAgfSwgMCk7XG4gICAgdGhpcy5fY2lyY3VsYXJPZmZzZXQgPSB0aGlzLl9tb2RlLmdldENpcmN1bGFyT2Zmc2V0KCk7XG4gICAgdGhpcy5hcHBseVRyYW5zZm9ybSgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcclxuICAgKiBVcGRhdGUgZGlyZWN0aW9uIHRvIG1hdGNoIHRoZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL2RpcmVjdGlvbiBkaXJlY3Rpb259IENTUyBwcm9wZXJ0eSBhcHBsaWVkIHRvIHRoZSBjYW1lcmEgZWxlbWVudFxyXG4gICAqIEBrbyDsubTrqZTrnbwg7JeY66as66i87Yq47JeQIOyggeyaqeuQnCB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL2RpcmVjdGlvbiBkaXJlY3Rpb259IENTUyDsho3shLHsl5Ag66ee6rKMIOuwqe2WpeydhCDsl4XrjbDsnbTtirjtlanri4jri6RcclxuICAgKiBAcmV0dXJuIHt0aGlzfVxyXG4gICAqL1xuICBfX3Byb3RvLnVwZGF0ZVBhbmVsT3JkZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZsaWNraW5nID0gZ2V0RmxpY2tpbmdBdHRhY2hlZCh0aGlzLl9mbGlja2luZyk7XG4gICAgaWYgKCFmbGlja2luZy5ob3Jpem9udGFsKSByZXR1cm4gdGhpcztcbiAgICB2YXIgZWwgPSB0aGlzLl9lbDtcbiAgICB2YXIgZGlyZWN0aW9uID0gZ2V0U3R5bGUoZWwpLmRpcmVjdGlvbjtcbiAgICBpZiAoZGlyZWN0aW9uICE9PSB0aGlzLl9wYW5lbE9yZGVyKSB7XG4gICAgICB0aGlzLl9wYW5lbE9yZGVyID0gZGlyZWN0aW9uID09PSBPUkRFUi5SVEwgPyBPUkRFUi5SVEwgOiBPUkRFUi5MVFI7XG4gICAgICBpZiAoZmxpY2tpbmcuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgZmxpY2tpbmcuY29udHJvbC5jb250cm9sbGVyLnVwZGF0ZURpcmVjdGlvbigpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXHJcbiAgICogUmVzZXQgdGhlIGhpc3Rvcnkgb2Yge0BsaW5rIEZsaWNraW5nI2V2ZW50Om5lZWRQYW5lbCBuZWVkUGFuZWx9IGV2ZW50cyBzbyBpdCBjYW4gYmUgdHJpZ2dlcmVkIGFnYWluXHJcbiAgICogQGtvIOuwnOyDne2VnCB7QGxpbmsgRmxpY2tpbmcjZXZlbnQ6bmVlZFBhbmVsIG5lZWRQYW5lbH0g7J2067Kk7Yq465Ok7J2EIOy0iOq4sO2ZlO2VmOyXrCDri6Tsi5wg67Cc7IOd7ZWgIOyImCDsnojrj4TroZ0g7ZWp64uI64ukXHJcbiAgICogQGNoYWluYWJsZVxyXG4gICAqIEByZXR1cm4ge3RoaXN9XHJcbiAgICovXG4gIF9fcHJvdG8ucmVzZXROZWVkUGFuZWxIaXN0b3J5ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX25lZWRQYW5lbFRyaWdnZXJlZCA9IHtcbiAgICAgIHByZXY6IGZhbHNlLFxuICAgICAgbmV4dDogZmFsc2VcbiAgICB9O1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcclxuICAgKiBBcHBseSBcInRyYW5zZm9ybVwiIHN0eWxlIHdpdGggdGhlIGN1cnJlbnQgcG9zaXRpb24gdG8gY2FtZXJhIGVsZW1lbnRcclxuICAgKiBAa28g7ZiE7J6sIOychOy5mOulvCDquLDspIDsnLzroZztlZwgdHJhbnNmb3JtIOyKpO2DgOydvOydhCDsubTrqZTrnbwg7JeY66as66i87Yq47JeQIOyggeyaqe2VqeuLiOuLpC5cclxuICAgKiBAcmV0dXJuIHt0aGlzfVxyXG4gICAqL1xuICBfX3Byb3RvLmFwcGx5VHJhbnNmb3JtID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbCA9IHRoaXMuX2VsO1xuICAgIHZhciBmbGlja2luZyA9IGdldEZsaWNraW5nQXR0YWNoZWQodGhpcy5fZmxpY2tpbmcpO1xuICAgIHZhciByZW5kZXJlciA9IGZsaWNraW5nLnJlbmRlcmVyO1xuICAgIGlmIChyZW5kZXJlci5yZW5kZXJpbmcgfHwgIWZsaWNraW5nLmluaXRpYWxpemVkKSByZXR1cm4gdGhpcztcbiAgICB2YXIgYWN0dWFsUG9zaXRpb24gPSB0aGlzLl9wb3NpdGlvbiAtIHRoaXMuX2FsaWduUG9zIC0gdGhpcy5fb2Zmc2V0ICsgdGhpcy5fY2lyY3VsYXJPZmZzZXQ7XG4gICAgZWwuc3R5bGVbdGhpcy5fdHJhbnNmb3JtXSA9IGZsaWNraW5nLmhvcml6b250YWwgPyBcInRyYW5zbGF0ZShcIiArICh0aGlzLl9wYW5lbE9yZGVyID09PSBPUkRFUi5SVEwgPyBhY3R1YWxQb3NpdGlvbiA6IC1hY3R1YWxQb3NpdGlvbikgKyBcInB4KVwiIDogXCJ0cmFuc2xhdGUoMCwgXCIgKyAtYWN0dWFsUG9zaXRpb24gKyBcInB4KVwiO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBfX3Byb3RvLl9yZXNldEludGVybmFsVmFsdWVzID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3Bvc2l0aW9uID0gMDtcbiAgICB0aGlzLl9hbGlnblBvcyA9IDA7XG4gICAgdGhpcy5fb2Zmc2V0ID0gMDtcbiAgICB0aGlzLl9jaXJjdWxhck9mZnNldCA9IDA7XG4gICAgdGhpcy5fY2lyY3VsYXJFbmFibGVkID0gZmFsc2U7XG4gICAgdGhpcy5fcmFuZ2UgPSB7XG4gICAgICBtaW46IDAsXG4gICAgICBtYXg6IDBcbiAgICB9O1xuICAgIHRoaXMuX3Zpc2libGVQYW5lbHMgPSBbXTtcbiAgICB0aGlzLl9hbmNob3JzID0gW107XG4gICAgdGhpcy5fbmVlZFBhbmVsVHJpZ2dlcmVkID0ge1xuICAgICAgcHJldjogZmFsc2UsXG4gICAgICBuZXh0OiBmYWxzZVxuICAgIH07XG4gIH07XG4gIF9fcHJvdG8uX3JlZnJlc2hWaXNpYmxlUGFuZWxzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIGZsaWNraW5nID0gZ2V0RmxpY2tpbmdBdHRhY2hlZCh0aGlzLl9mbGlja2luZyk7XG4gICAgdmFyIHBhbmVscyA9IGZsaWNraW5nLnJlbmRlcmVyLnBhbmVscztcbiAgICB2YXIgbmV3VmlzaWJsZVBhbmVscyA9IHBhbmVscy5maWx0ZXIoZnVuY3Rpb24gKHBhbmVsKSB7XG4gICAgICByZXR1cm4gX3RoaXMuY2FuU2VlKHBhbmVsKTtcbiAgICB9KTtcbiAgICB2YXIgcHJldlZpc2libGVQYW5lbHMgPSB0aGlzLl92aXNpYmxlUGFuZWxzO1xuICAgIHRoaXMuX3Zpc2libGVQYW5lbHMgPSBuZXdWaXNpYmxlUGFuZWxzO1xuICAgIHZhciBhZGRlZCA9IG5ld1Zpc2libGVQYW5lbHMuZmlsdGVyKGZ1bmN0aW9uIChwYW5lbCkge1xuICAgICAgcmV0dXJuICFpbmNsdWRlcyhwcmV2VmlzaWJsZVBhbmVscywgcGFuZWwpO1xuICAgIH0pO1xuICAgIHZhciByZW1vdmVkID0gcHJldlZpc2libGVQYW5lbHMuZmlsdGVyKGZ1bmN0aW9uIChwYW5lbCkge1xuICAgICAgcmV0dXJuICFpbmNsdWRlcyhuZXdWaXNpYmxlUGFuZWxzLCBwYW5lbCk7XG4gICAgfSk7XG4gICAgaWYgKGFkZGVkLmxlbmd0aCA+IDAgfHwgcmVtb3ZlZC5sZW5ndGggPiAwKSB7XG4gICAgICB2b2lkIGZsaWNraW5nLnJlbmRlcmVyLnJlbmRlcigpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICBmbGlja2luZy50cmlnZ2VyKG5ldyBDb21wb25lbnRFdmVudCQxKEVWRU5UUy5WSVNJQkxFX0NIQU5HRSwge1xuICAgICAgICAgIGFkZGVkOiBhZGRlZCxcbiAgICAgICAgICByZW1vdmVkOiByZW1vdmVkLFxuICAgICAgICAgIHZpc2libGVQYW5lbHM6IG5ld1Zpc2libGVQYW5lbHNcbiAgICAgICAgfSkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICBfX3Byb3RvLl9jaGVja05lZWRQYW5lbCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbmVlZFBhbmVsVHJpZ2dlcmVkID0gdGhpcy5fbmVlZFBhbmVsVHJpZ2dlcmVkO1xuICAgIGlmIChuZWVkUGFuZWxUcmlnZ2VyZWQucHJldiAmJiBuZWVkUGFuZWxUcmlnZ2VyZWQubmV4dCkgcmV0dXJuO1xuICAgIHZhciBmbGlja2luZyA9IGdldEZsaWNraW5nQXR0YWNoZWQodGhpcy5fZmxpY2tpbmcpO1xuICAgIHZhciBwYW5lbHMgPSBmbGlja2luZy5yZW5kZXJlci5wYW5lbHM7XG4gICAgaWYgKHBhbmVscy5sZW5ndGggPD0gMCkge1xuICAgICAgaWYgKCFuZWVkUGFuZWxUcmlnZ2VyZWQucHJldikge1xuICAgICAgICBmbGlja2luZy50cmlnZ2VyKG5ldyBDb21wb25lbnRFdmVudCQxKEVWRU5UUy5ORUVEX1BBTkVMLCB7XG4gICAgICAgICAgZGlyZWN0aW9uOiBESVJFQ1RJT04uUFJFVlxuICAgICAgICB9KSk7XG4gICAgICAgIG5lZWRQYW5lbFRyaWdnZXJlZC5wcmV2ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICghbmVlZFBhbmVsVHJpZ2dlcmVkLm5leHQpIHtcbiAgICAgICAgZmxpY2tpbmcudHJpZ2dlcihuZXcgQ29tcG9uZW50RXZlbnQkMShFVkVOVFMuTkVFRF9QQU5FTCwge1xuICAgICAgICAgIGRpcmVjdGlvbjogRElSRUNUSU9OLk5FWFRcbiAgICAgICAgfSkpO1xuICAgICAgICBuZWVkUGFuZWxUcmlnZ2VyZWQubmV4dCA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBjYW1lcmFQb3NpdGlvbiA9IHRoaXMuX3Bvc2l0aW9uO1xuICAgIHZhciBjYW1lcmFTaXplID0gdGhpcy5zaXplO1xuICAgIHZhciBjYW1lcmFSYW5nZSA9IHRoaXMuX3JhbmdlO1xuICAgIHZhciBuZWVkUGFuZWxUaHJlc2hvbGQgPSBmbGlja2luZy5uZWVkUGFuZWxUaHJlc2hvbGQ7XG4gICAgdmFyIGNhbWVyYVByZXYgPSBjYW1lcmFQb3NpdGlvbiAtIHRoaXMuX2FsaWduUG9zO1xuICAgIHZhciBjYW1lcmFOZXh0ID0gY2FtZXJhUHJldiArIGNhbWVyYVNpemU7XG4gICAgdmFyIGZpcnN0UGFuZWwgPSBwYW5lbHNbMF07XG4gICAgdmFyIGxhc3RQYW5lbCA9IHBhbmVsc1twYW5lbHMubGVuZ3RoIC0gMV07XG4gICAgaWYgKCFuZWVkUGFuZWxUcmlnZ2VyZWQucHJldikge1xuICAgICAgdmFyIGZpcnN0UGFuZWxQcmV2ID0gZmlyc3RQYW5lbC5yYW5nZS5taW47XG4gICAgICBpZiAoY2FtZXJhUHJldiA8PSBmaXJzdFBhbmVsUHJldiArIG5lZWRQYW5lbFRocmVzaG9sZCB8fCBjYW1lcmFQb3NpdGlvbiA8PSBjYW1lcmFSYW5nZS5taW4gKyBuZWVkUGFuZWxUaHJlc2hvbGQpIHtcbiAgICAgICAgZmxpY2tpbmcudHJpZ2dlcihuZXcgQ29tcG9uZW50RXZlbnQkMShFVkVOVFMuTkVFRF9QQU5FTCwge1xuICAgICAgICAgIGRpcmVjdGlvbjogRElSRUNUSU9OLlBSRVZcbiAgICAgICAgfSkpO1xuICAgICAgICBuZWVkUGFuZWxUcmlnZ2VyZWQucHJldiA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghbmVlZFBhbmVsVHJpZ2dlcmVkLm5leHQpIHtcbiAgICAgIHZhciBsYXN0UGFuZWxOZXh0ID0gbGFzdFBhbmVsLnJhbmdlLm1heDtcbiAgICAgIGlmIChjYW1lcmFOZXh0ID49IGxhc3RQYW5lbE5leHQgLSBuZWVkUGFuZWxUaHJlc2hvbGQgfHwgY2FtZXJhUG9zaXRpb24gPj0gY2FtZXJhUmFuZ2UubWF4IC0gbmVlZFBhbmVsVGhyZXNob2xkKSB7XG4gICAgICAgIGZsaWNraW5nLnRyaWdnZXIobmV3IENvbXBvbmVudEV2ZW50JDEoRVZFTlRTLk5FRURfUEFORUwsIHtcbiAgICAgICAgICBkaXJlY3Rpb246IERJUkVDVElPTi5ORVhUXG4gICAgICAgIH0pKTtcbiAgICAgICAgbmVlZFBhbmVsVHJpZ2dlcmVkLm5leHQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgX19wcm90by5fY2hlY2tSZWFjaEVuZCA9IGZ1bmN0aW9uIChwcmV2UG9zLCBuZXdQb3MpIHtcbiAgICB2YXIgZmxpY2tpbmcgPSBnZXRGbGlja2luZ0F0dGFjaGVkKHRoaXMuX2ZsaWNraW5nKTtcbiAgICB2YXIgcmFuZ2UgPSB0aGlzLl9yYW5nZTtcbiAgICB2YXIgd2FzQmV0d2VlblJhbmdlID0gcHJldlBvcyA+IHJhbmdlLm1pbiAmJiBwcmV2UG9zIDwgcmFuZ2UubWF4O1xuICAgIHZhciBpc0JldHdlZW5SYW5nZSA9IG5ld1BvcyA+IHJhbmdlLm1pbiAmJiBuZXdQb3MgPCByYW5nZS5tYXg7XG4gICAgaWYgKCF3YXNCZXR3ZWVuUmFuZ2UgfHwgaXNCZXR3ZWVuUmFuZ2UpIHJldHVybjtcbiAgICB2YXIgZGlyZWN0aW9uID0gbmV3UG9zIDw9IHJhbmdlLm1pbiA/IERJUkVDVElPTi5QUkVWIDogRElSRUNUSU9OLk5FWFQ7XG4gICAgZmxpY2tpbmcudHJpZ2dlcihuZXcgQ29tcG9uZW50RXZlbnQkMShFVkVOVFMuUkVBQ0hfRURHRSwge1xuICAgICAgZGlyZWN0aW9uOiBkaXJlY3Rpb25cbiAgICB9KSk7XG4gIH07XG4gIF9fcHJvdG8uX3VwZGF0ZU1vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZsaWNraW5nID0gZ2V0RmxpY2tpbmdBdHRhY2hlZCh0aGlzLl9mbGlja2luZyk7XG4gICAgaWYgKGZsaWNraW5nLmNpcmN1bGFyKSB7XG4gICAgICB2YXIgY2lyY3VsYXJNb2RlID0gbmV3IENpcmN1bGFyQ2FtZXJhTW9kZShmbGlja2luZyk7XG4gICAgICB2YXIgY2FuU2V0Q2lyY3VsYXJNb2RlID0gY2lyY3VsYXJNb2RlLmNoZWNrQXZhaWxhYmlsaXR5KCk7XG4gICAgICBpZiAoY2FuU2V0Q2lyY3VsYXJNb2RlKSB7XG4gICAgICAgIHRoaXMuX21vZGUgPSBjaXJjdWxhck1vZGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZmFsbGJhY2tNb2RlID0gZmxpY2tpbmcuY2lyY3VsYXJGYWxsYmFjaztcbiAgICAgICAgdGhpcy5fbW9kZSA9IGZhbGxiYWNrTW9kZSA9PT0gQ0lSQ1VMQVJfRkFMTEJBQ0suQk9VTkQgPyBuZXcgQm91bmRDYW1lcmFNb2RlKGZsaWNraW5nKSA6IG5ldyBMaW5lYXJDYW1lcmFNb2RlKGZsaWNraW5nKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NpcmN1bGFyRW5hYmxlZCA9IGNhblNldENpcmN1bGFyTW9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fbW9kZSA9IGZsaWNraW5nLmJvdW5kID8gbmV3IEJvdW5kQ2FtZXJhTW9kZShmbGlja2luZykgOiBuZXcgTGluZWFyQ2FtZXJhTW9kZShmbGlja2luZyk7XG4gICAgICB0aGlzLl9jaXJjdWxhckVuYWJsZWQgPSBmYWxzZTtcbiAgICB9XG4gIH07XG4gIF9fcHJvdG8uX3RvZ2dsZVBhbmVscyA9IGZ1bmN0aW9uIChwcmV2UG9zLCBwb3MpIHtcbiAgICBpZiAocG9zID09PSBwcmV2UG9zKSByZXR1cm4gZmFsc2U7XG4gICAgdmFyIGZsaWNraW5nID0gZ2V0RmxpY2tpbmdBdHRhY2hlZCh0aGlzLl9mbGlja2luZyk7XG4gICAgdmFyIHBhbmVscyA9IGZsaWNraW5nLnJlbmRlcmVyLnBhbmVscztcbiAgICB2YXIgdG9nZ2xlZCA9IHBhbmVscy5tYXAoZnVuY3Rpb24gKHBhbmVsKSB7XG4gICAgICByZXR1cm4gcGFuZWwudG9nZ2xlKHByZXZQb3MsIHBvcyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRvZ2dsZWQuc29tZShmdW5jdGlvbiAoaXNUb2dnbGVkKSB7XG4gICAgICByZXR1cm4gaXNUb2dnbGVkO1xuICAgIH0pO1xuICB9O1xuICByZXR1cm4gQ2FtZXJhO1xufSgpO1xuXG4vKipcclxuICogQSBjb21wb25lbnQgdGhhdCBtYW5hZ2VzIHtAbGluayBQYW5lbH0gYW5kIGl0cyBlbGVtZW50c1xyXG4gKiBAa28ge0BsaW5rIFBhbmVsfeqzvCDqt7gg7JeY66as66i87Yq465Ok7J2EIOq0gOumrO2VmOuKlCDsu7Ttj6zrhIztirhcclxuICovXG52YXIgUmVuZGVyZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcclxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBBbiBvcHRpb25zIG9iamVjdDxrbz7smLXshZgg7Jik67iM7KCd7Yq4PC9rbz5cclxuICAgKiBAcGFyYW0ge0NvbnN0YW50cy5BTElHTiB8IHN0cmluZyB8IG51bWJlcn0gW29wdGlvbnMuYWxpZ249XCJjZW50ZXJcIl0gQW4ge0BsaW5rIEZsaWNraW5nI2FsaWduIGFsaWdufSB2YWx1ZSB0aGF0IHdpbGwgYmUgYXBwbGllZCB0byBhbGwgcGFuZWxzPGtvPuyghOyytCDtjKjrhJDsl5Ag7KCB7Jqp65CgIHtAbGluayBGbGlja2luZyNhbGlnbiBhbGlnbn0g6rCSPC9rbz5cclxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMuc3RyYXRlZ3ldIEFuIGluc3RhbmNlIG9mIFJlbmRlcmluZ1N0cmF0ZWd5KGludGVybmFsIG1vZHVsZSk8a28+UmVuZGVyaW5nU3RyYXRlZ3nsnZgg7J247Iqk7YS07IqkKOuCtOu2gCDrqqjrk4gpPC9rbz5cclxuICAgKi9cbiAgZnVuY3Rpb24gUmVuZGVyZXIoX2EpIHtcbiAgICB2YXIgX2IgPSBfYS5hbGlnbixcbiAgICAgIGFsaWduID0gX2IgPT09IHZvaWQgMCA/IEFMSUdOLkNFTlRFUiA6IF9iLFxuICAgICAgc3RyYXRlZ3kgPSBfYS5zdHJhdGVneTtcbiAgICB0aGlzLl9mbGlja2luZyA9IG51bGw7XG4gICAgdGhpcy5fcGFuZWxzID0gW107XG4gICAgdGhpcy5fcmVuZGVyaW5nID0gZmFsc2U7XG4gICAgLy8gQmluZCBvcHRpb25zXG4gICAgdGhpcy5fYWxpZ24gPSBhbGlnbjtcbiAgICB0aGlzLl9zdHJhdGVneSA9IHN0cmF0ZWd5O1xuICB9XG4gIHZhciBfX3Byb3RvID0gUmVuZGVyZXIucHJvdG90eXBlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJwYW5lbHNcIiwge1xuICAgIC8vIEludGVybmFsIHN0YXRlcyBHZXR0ZXJcbiAgICAvKipcclxuICAgICAqIEFycmF5IG9mIHBhbmVsc1xyXG4gICAgICogQGtvIOyghOyytCDtjKjrhJDrk6TsnZgg67Cw7Je0XHJcbiAgICAgKiBAdHlwZSB7UGFuZWxbXX1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQHNlZSBQYW5lbFxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcGFuZWxzO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJyZW5kZXJpbmdcIiwge1xuICAgIC8qKlxyXG4gICAgICogQSBib29sZWFuIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciByZW5kZXJpbmcgaXMgaW4gcHJvZ3Jlc3NcclxuICAgICAqIEBrbyDtmITsnqwg66CM642U66eB7J20IOyLnOyekeuQmOyWtCDrgZ3rgpjquLAg7KCE6rmM7KeA7J2YIOyDge2DnOyduOyngOydmCDsl6zrtoBcclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlcmluZztcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwicGFuZWxDb3VudFwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBDb3VudCBvZiBwYW5lbHNcclxuICAgICAqIEBrbyDsoITssrQg7Yyo64SQ7J2YIOqwnOyImFxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcGFuZWxzLmxlbmd0aDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwic3RyYXRlZ3lcIiwge1xuICAgIC8qKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdHJhdGVneTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwiYWxpZ25cIiwge1xuICAgIC8vIE9wdGlvbnMgR2V0dGVyXG4gICAgLyoqXHJcbiAgICAgKiBBIHtAbGluayBQYW5lbH0ncyB7QGxpbmsgUGFuZWwjYWxpZ24gYWxpZ259IHZhbHVlIHRoYXQgYXBwbGllZCB0byBhbGwgcGFuZWxzXHJcbiAgICAgKiBAa28ge0BsaW5rIFBhbmVsfeyXkCDqs7XthrXsoIHsnLzroZwg7KCB7Jqp7ZWgIHtAbGluayBQYW5lbCNhbGlnbiBhbGlnbn0g6rCSXHJcbiAgICAgKiBAdHlwZSB7Q29uc3RhbnRzLkFMSUdOIHwgc3RyaW5nIHwgbnVtYmVyfVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYWxpZ247XG4gICAgfSxcbiAgICAvLyBPcHRpb25zIFNldHRlclxuICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgdGhpcy5fYWxpZ24gPSB2YWw7XG4gICAgICB2YXIgcGFuZWxBbGlnbiA9IHBhcnNlUGFuZWxBbGlnbih2YWwpO1xuICAgICAgdGhpcy5fcGFuZWxzLmZvckVhY2goZnVuY3Rpb24gKHBhbmVsKSB7XG4gICAgICAgIHBhbmVsLmFsaWduID0gcGFuZWxBbGlnbjtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICAvKipcclxuICAgKiBJbml0aWFsaXplIFJlbmRlcmVyXHJcbiAgICogQGtvIFJlbmRlcmVy66W8IOy0iOq4sO2ZlO2VqeuLiOuLpFxyXG4gICAqIEBwYXJhbSB7RmxpY2tpbmd9IGZsaWNraW5nIEFuIGluc3RhbmNlIG9mIHtAbGluayBGbGlja2luZ308a28+RmxpY2tpbmfsnZgg7J247Iqk7YS07IqkPC9rbz5cclxuICAgKiBAY2hhaW5hYmxlXHJcbiAgICogQHJldHVybiB7dGhpc31cclxuICAgKi9cbiAgX19wcm90by5pbml0ID0gZnVuY3Rpb24gKGZsaWNraW5nKSB7XG4gICAgdGhpcy5fZmxpY2tpbmcgPSBmbGlja2luZztcbiAgICB0aGlzLl9jb2xsZWN0UGFuZWxzKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxyXG4gICAqIERlc3Ryb3kgUmVuZGVyZXIgYW5kIHJldHVybiB0byBpbml0aWFsIHN0YXRlXHJcbiAgICogQGtvIFJlbmRlcmVy66W8IOy0iOq4sCDsg4Htg5zroZwg65CY64+M66a964uI64ukXHJcbiAgICogQHJldHVybiB7dm9pZH1cclxuICAgKi9cbiAgX19wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2ZsaWNraW5nID0gbnVsbDtcbiAgICB0aGlzLl9wYW5lbHMgPSBbXTtcbiAgfTtcbiAgLyoqXHJcbiAgICogUmV0dXJuIHRoZSB7QGxpbmsgUGFuZWx9IGF0IHRoZSBnaXZlbiBpbmRleC4gYG51bGxgIGlmIGl0IGRvZXNuJ3QgZXhpc3RzLlxyXG4gICAqIEBrbyDso7zslrTsp4Qg7J24642x7Iqk7JeQIO2VtOuLue2VmOuKlCB7QGxpbmsgUGFuZWx97J2EIOuwmO2ZmO2VqeuLiOuLpC4g7KO87Ja07KeEIOyduOuNseyKpOyXkCDtlbTri7ntlZjripQg7Yyo64SQ7J20IOyhtOyerO2VmOyngCDslYrsnYQg6rK97JqwIGBudWxsYOydhCDrsJjtmZjtlanri4jri6QuXHJcbiAgICogQHJldHVybiB7UGFuZWwgfCBudWxsfSBQYW5lbCBhdCB0aGUgZ2l2ZW4gaW5kZXg8a28+7KO87Ja07KeEIOyduOuNseyKpOyXkCDtlbTri7ntlZjripQg7Yyo64SQPC9rbz5cclxuICAgKiBAc2VlIFBhbmVsXHJcbiAgICovXG4gIF9fcHJvdG8uZ2V0UGFuZWwgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFuZWxzW2luZGV4XSB8fCBudWxsO1xuICB9O1xuICBfX3Byb3RvLmZvcmNlUmVuZGVyQWxsUGFuZWxzID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3BhbmVscy5mb3JFYWNoKGZ1bmN0aW9uIChwYW5lbCkge1xuICAgICAgcmV0dXJuIHBhbmVsLm1hcmtGb3JTaG93KCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9O1xuICAvKipcclxuICAgKiBVcGRhdGUgYWxsIHBhbmVsIHNpemVzXHJcbiAgICogQGtvIOuqqOuToCDtjKjrhJDsnZgg7YGs6riw66W8IOyXheuNsOydtO2KuO2VqeuLiOuLpFxyXG4gICAqIEBjaGFpbmFibGVcclxuICAgKiBAcmV0dXJuIHt0aGlzfVxyXG4gICAqL1xuICBfX3Byb3RvLnVwZGF0ZVBhbmVsU2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZmxpY2tpbmcgPSBnZXRGbGlja2luZ0F0dGFjaGVkKHRoaXMuX2ZsaWNraW5nKTtcbiAgICB2YXIgcGFuZWxzID0gdGhpcy5fcGFuZWxzO1xuICAgIGlmIChwYW5lbHMubGVuZ3RoIDw9IDApIHJldHVybiB0aGlzO1xuICAgIGlmIChmbGlja2luZy5wYW5lbHNQZXJWaWV3ID4gMCkge1xuICAgICAgdmFyIGZpcnN0UGFuZWwgPSBwYW5lbHNbMF07XG4gICAgICBmaXJzdFBhbmVsLnJlc2l6ZSgpO1xuICAgICAgdGhpcy5fdXBkYXRlUGFuZWxTaXplQnlHcmlkKGZpcnN0UGFuZWwsIHBhbmVscyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZsaWNraW5nLnBhbmVscy5mb3JFYWNoKGZ1bmN0aW9uIChwYW5lbCkge1xuICAgICAgICByZXR1cm4gcGFuZWwucmVzaXplKCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxyXG4gICAqIEluc2VydCBuZXcgcGFuZWxzIGF0IGdpdmVuIGluZGV4XHJcbiAgICogVGhpcyB3aWxsIGluY3JlYXNlIGluZGV4IG9mIHBhbmVscyBhZnRlciBieSB0aGUgbnVtYmVyIG9mIHBhbmVscyBhZGRlZFxyXG4gICAqIEBrbyDso7zslrTsp4Qg7J24642x7Iqk7JeQIOyDiOuhnOyatCDtjKjrhJDrk6TsnYQg7LaU6rCA7ZWp64uI64ukXHJcbiAgICog7ZW064u5IOyduOuNseyKpOuztOuLpCDqsJnqsbDrgpgg7YGwIOyduOuNseyKpOulvCDqsIDsp4Qg6riw7KG0IO2MqOuEkOuTpOydgCDstpTqsIDtlZwg7Yyo64SQ7J2YIOqwnOyImOunjO2BvCDsnbjrjbHsiqTqsIAg7Kad6rCA7ZWp64uI64ukLlxyXG4gICAqIEBwYXJhbSB7QXJyYXk8b2JqZWN0Pn0gaXRlbXMgQW4gYXJyYXkgb2YgaXRlbXMgdG8gaW5zZXJ0PGtvPuy2lOqwgO2VoCDslYTsnbTthZzrk6TsnZgg67Cw7Je0PC9rbz5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gW2l0ZW1zLmluZGV4XSBJbmRleCB0byBpbnNlcnQgbmV3IHBhbmVscyBhdDxrbz7sg4jroZwg7Yyo64SQ65Ok7J2EIOy2lOqwgO2VoCDsnbjrjbHsiqQ8L2tvPlxyXG4gICAqIEBwYXJhbSB7YW55W119IFtpdGVtcy5lbGVtZW50c10gQW4gYXJyYXkgb2YgZWxlbWVudCBvciBmcmFtZXdvcmsgY29tcG9uZW50IHdpdGggZWxlbWVudCBpbiBpdDxrbz7sl5jrpqzrqLztirjsnZgg67Cw7Je0IO2YueydgCDtlITroIjsnoTsm4ztgazsl5DshJwg7JeY66as66i87Yq466W8IO2PrO2VqO2VnCDsu7Ttj6zrhIztirjrk6TsnZgg67Cw7Je0PC9rbz5cclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpdGVtcy5oYXNET01JbkVsZW1lbnRzXSBXaGV0aGVyIGl0IGNvbnRhaW5zIGFjdHVhbCBET00gZWxlbWVudHMuIElmIHNldCB0byB0cnVlLCByZW5kZXJlciB3aWxsIGFkZCB0aGVtIHRvIHRoZSBjYW1lcmEgZWxlbWVudDxrbz7rgrTrtoDsl5Ag7Iuk7KCcIERPTSDsl5jrpqzrqLztirjrk6TsnYQg7Y+s7ZWo7ZWY6rOgIOyeiOuKlOyngCDsl6zrtoAuIHRydWXroZwg7ISk7KCV7ZWgIOqyveyasCwg66CM642U65+s64qUIO2VtOuLuSDsl5jrpqzrqLztirjrk6TsnYQg7Lm066mU6528IOyXmOumrOuovO2KuCDrgrTrtoDsl5Ag7LaU6rCA7ZWp64uI64ukPC9rbz5cclxuICAgKiBAcmV0dXJuIHtQYW5lbFtdfSBBbiBhcnJheSBvZiBwcmVwZW5kZWQgcGFuZWxzPGtvPuy2lOqwgOuQnCDtjKjrhJDrk6TsnZgg67Cw7Je0PC9rbz5cclxuICAgKi9cbiAgX19wcm90by5iYXRjaEluc2VydCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgaXRlbXNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgdmFyIGFsbFBhbmVsc0luc2VydGVkID0gdGhpcy5iYXRjaEluc2VydERlZmVyLmFwcGx5KHRoaXMsIF9fc3ByZWFkJDEoaXRlbXMpKTtcbiAgICBpZiAoYWxsUGFuZWxzSW5zZXJ0ZWQubGVuZ3RoIDw9IDApIHJldHVybiBbXTtcbiAgICB0aGlzLnVwZGF0ZUFmdGVyUGFuZWxDaGFuZ2UoYWxsUGFuZWxzSW5zZXJ0ZWQsIFtdKTtcbiAgICByZXR1cm4gYWxsUGFuZWxzSW5zZXJ0ZWQ7XG4gIH07XG4gIC8qKlxyXG4gICAqIERlZmVycyB1cGRhdGVcclxuICAgKiBjYW1lcmEgcG9zaXRpb24gJiBvdGhlcnMgd2lsbCBiZSB1cGRhdGVkIGFmdGVyIGNhbGxpbmcgdXBkYXRlQWZ0ZXJQYW5lbENoYW5nZVxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqL1xuICBfX3Byb3RvLmJhdGNoSW5zZXJ0RGVmZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgaXRlbXNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgdmFyIHBhbmVscyA9IHRoaXMuX3BhbmVscztcbiAgICB2YXIgZmxpY2tpbmcgPSBnZXRGbGlja2luZ0F0dGFjaGVkKHRoaXMuX2ZsaWNraW5nKTtcbiAgICB2YXIgcHJldkZpcnN0UGFuZWwgPSBwYW5lbHNbMF07XG4gICAgdmFyIGFsaWduID0gcGFyc2VQYW5lbEFsaWduKHRoaXMuX2FsaWduKTtcbiAgICB2YXIgYWxsUGFuZWxzSW5zZXJ0ZWQgPSBpdGVtcy5yZWR1Y2UoZnVuY3Rpb24gKGFkZGVkUGFuZWxzLCBpdGVtKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICB2YXIgaW5zZXJ0aW5nSWR4ID0gZ2V0TWludXNDb21wZW5zYXRlZEluZGV4KGl0ZW0uaW5kZXgsIHBhbmVscy5sZW5ndGgpO1xuICAgICAgdmFyIHBhbmVsc1B1c2hlZCA9IHBhbmVscy5zbGljZShpbnNlcnRpbmdJZHgpO1xuICAgICAgdmFyIHBhbmVsc0luc2VydGVkID0gaXRlbS5lbGVtZW50cy5tYXAoZnVuY3Rpb24gKGVsLCBpZHgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLl9jcmVhdGVQYW5lbChlbCwge1xuICAgICAgICAgIGluZGV4OiBpbnNlcnRpbmdJZHggKyBpZHgsXG4gICAgICAgICAgYWxpZ246IGFsaWduLFxuICAgICAgICAgIGZsaWNraW5nOiBmbGlja2luZ1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgcGFuZWxzLnNwbGljZS5hcHBseShwYW5lbHMsIF9fc3ByZWFkJDEoW2luc2VydGluZ0lkeCwgMF0sIHBhbmVsc0luc2VydGVkKSk7XG4gICAgICBpZiAoaXRlbS5oYXNET01JbkVsZW1lbnRzKSB7XG4gICAgICAgIC8vIEluc2VydCB0aGUgYWN0dWFsIGVsZW1lbnRzIGFzIGNhbWVyYSBlbGVtZW50J3MgY2hpbGRyZW5cbiAgICAgICAgX3RoaXMuX2luc2VydFBhbmVsRWxlbWVudHMocGFuZWxzSW5zZXJ0ZWQsIChfYSA9IHBhbmVsc1B1c2hlZFswXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbnVsbCk7XG4gICAgICB9XG4gICAgICAvLyBSZXNpemUgdGhlIG5ld2x5IGFkZGVkIHBhbmVsc1xuICAgICAgaWYgKGZsaWNraW5nLnBhbmVsc1BlclZpZXcgPiAwKSB7XG4gICAgICAgIHZhciBmaXJzdFBhbmVsID0gcHJldkZpcnN0UGFuZWwgfHwgcGFuZWxzSW5zZXJ0ZWRbMF0ucmVzaXplKCk7XG4gICAgICAgIF90aGlzLl91cGRhdGVQYW5lbFNpemVCeUdyaWQoZmlyc3RQYW5lbCwgcGFuZWxzSW5zZXJ0ZWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFuZWxzSW5zZXJ0ZWQuZm9yRWFjaChmdW5jdGlvbiAocGFuZWwpIHtcbiAgICAgICAgICByZXR1cm4gcGFuZWwucmVzaXplKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgLy8gVXBkYXRlIHBhbmVsIGluZGV4ZXMgJiBwb3NpdGlvbnNcbiAgICAgIHBhbmVsc1B1c2hlZC5mb3JFYWNoKGZ1bmN0aW9uIChwYW5lbCkge1xuICAgICAgICBwYW5lbC5pbmNyZWFzZUluZGV4KHBhbmVsc0luc2VydGVkLmxlbmd0aCk7XG4gICAgICAgIHBhbmVsLnVwZGF0ZVBvc2l0aW9uKCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBfX3NwcmVhZCQxKGFkZGVkUGFuZWxzLCBwYW5lbHNJbnNlcnRlZCk7XG4gICAgfSwgW10pO1xuICAgIHJldHVybiBhbGxQYW5lbHNJbnNlcnRlZDtcbiAgfTtcbiAgLyoqXHJcbiAgICogUmVtb3ZlIHRoZSBwYW5lbCBhdCB0aGUgZ2l2ZW4gaW5kZXhcclxuICAgKiBUaGlzIHdpbGwgZGVjcmVhc2UgaW5kZXggb2YgcGFuZWxzIGFmdGVyIGJ5IHRoZSBudW1iZXIgb2YgcGFuZWxzIHJlbW92ZWRcclxuICAgKiBAa28g7KO87Ja07KeEIOyduOuNseyKpOydmCDtjKjrhJDsnYQg7KCc6rGw7ZWp64uI64ukXHJcbiAgICog7ZW064u5IOyduOuNseyKpOuztOuLpCDtgbAg7J24642x7Iqk66W8IOqwgOynhCDquLDsobQg7Yyo64SQ65Ok7J2AIOygnOqxsO2VnCDtjKjrhJDsnZgg6rCc7IiY66eM7YG8IOyduOuNseyKpOqwgCDqsJDshoztlanri4jri6RcclxuICAgKiBAcGFyYW0ge0FycmF5PG9iamVjdD59IGl0ZW1zIEFuIGFycmF5IG9mIGl0ZW1zIHRvIHJlbW92ZTxrbz7soJzqsbDtlaAg7JWE7J207YWc65Ok7J2YIOuwsOyXtDwva28+XHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtpdGVtcy5pbmRleF0gSW5kZXggb2YgcGFuZWwgdG8gcmVtb3ZlPGtvPuygnOqxsO2VoCDtjKjrhJDsnZgg7J24642x7IqkPC9rbz5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gW2l0ZW1zLmRlbGV0ZUNvdW50PTFdIE51bWJlciBvZiBwYW5lbHMgdG8gcmVtb3ZlIGZyb20gaW5kZXg8a28+YGluZGV4YCDsnbTtm4TroZwg7KCc6rGw7ZWgIO2MqOuEkOydmCDqsJzsiJg8L2tvPlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2l0ZW1zLmhhc0RPTUluRWxlbWVudHM9MV0gV2hldGhlciBpdCBjb250YWlucyBhY3R1YWwgRE9NIGVsZW1lbnRzLiBJZiBzZXQgdG8gdHJ1ZSwgcmVuZGVyZXIgd2lsbCByZW1vdmUgdGhlbSBmcm9tIHRoZSBjYW1lcmEgZWxlbWVudDxrbz7rgrTrtoDsl5Ag7Iuk7KCcIERPTSDsl5jrpqzrqLztirjrk6TsnYQg7Y+s7ZWo7ZWY6rOgIOyeiOuKlOyngCDsl6zrtoAuIHRydWXroZwg7ISk7KCV7ZWgIOqyveyasCwg66CM642U65+s64qUIO2VtOuLuSDsl5jrpqzrqLztirjrk6TsnYQg7Lm066mU6528IOyXmOumrOuovO2KuCDrgrTrtoDsl5DshJwg7KCc6rGw7ZWp64uI64ukPC9rbz5cclxuICAgKiBAcmV0dXJuIEFuIGFycmF5IG9mIHJlbW92ZWQgcGFuZWxzPGtvPuygnOqxsOuQnCDtjKjrhJDrk6TsnZgg67Cw7Je0PC9rbz5cclxuICAgKi9cbiAgX19wcm90by5iYXRjaFJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgaXRlbXNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgdmFyIGFsbFBhbmVsc1JlbW92ZWQgPSB0aGlzLmJhdGNoUmVtb3ZlRGVmZXIuYXBwbHkodGhpcywgX19zcHJlYWQkMShpdGVtcykpO1xuICAgIGlmIChhbGxQYW5lbHNSZW1vdmVkLmxlbmd0aCA8PSAwKSByZXR1cm4gW107XG4gICAgdGhpcy51cGRhdGVBZnRlclBhbmVsQ2hhbmdlKFtdLCBhbGxQYW5lbHNSZW1vdmVkKTtcbiAgICByZXR1cm4gYWxsUGFuZWxzUmVtb3ZlZDtcbiAgfTtcbiAgLyoqXHJcbiAgICogRGVmZXJzIHVwZGF0ZVxyXG4gICAqIGNhbWVyYSBwb3NpdGlvbiAmIG90aGVycyB3aWxsIGJlIHVwZGF0ZWQgYWZ0ZXIgY2FsbGluZyB1cGRhdGVBZnRlclBhbmVsQ2hhbmdlXHJcbiAgICogQGludGVybmFsXHJcbiAgICovXG4gIF9fcHJvdG8uYmF0Y2hSZW1vdmVEZWZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHZhciBpdGVtcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICBpdGVtc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB2YXIgcGFuZWxzID0gdGhpcy5fcGFuZWxzO1xuICAgIHZhciBmbGlja2luZyA9IGdldEZsaWNraW5nQXR0YWNoZWQodGhpcy5fZmxpY2tpbmcpO1xuICAgIHZhciBjb250cm9sID0gZmxpY2tpbmcuY29udHJvbDtcbiAgICB2YXIgYWN0aXZlUGFuZWwgPSBjb250cm9sLmFjdGl2ZVBhbmVsO1xuICAgIHZhciBhbGxQYW5lbHNSZW1vdmVkID0gaXRlbXMucmVkdWNlKGZ1bmN0aW9uIChyZW1vdmVkLCBpdGVtKSB7XG4gICAgICB2YXIgaW5kZXggPSBpdGVtLmluZGV4LFxuICAgICAgICBkZWxldGVDb3VudCA9IGl0ZW0uZGVsZXRlQ291bnQ7XG4gICAgICB2YXIgcmVtb3ZpbmdJZHggPSBnZXRNaW51c0NvbXBlbnNhdGVkSW5kZXgoaW5kZXgsIHBhbmVscy5sZW5ndGgpO1xuICAgICAgdmFyIHBhbmVsc1B1bGxlZCA9IHBhbmVscy5zbGljZShyZW1vdmluZ0lkeCArIGRlbGV0ZUNvdW50KTtcbiAgICAgIHZhciBwYW5lbHNSZW1vdmVkID0gcGFuZWxzLnNwbGljZShyZW1vdmluZ0lkeCwgZGVsZXRlQ291bnQpO1xuICAgICAgaWYgKHBhbmVsc1JlbW92ZWQubGVuZ3RoIDw9IDApIHJldHVybiBbXTtcbiAgICAgIC8vIFVwZGF0ZSBwYW5lbCBpbmRleGVzICYgcG9zaXRpb25zXG4gICAgICBwYW5lbHNQdWxsZWQuZm9yRWFjaChmdW5jdGlvbiAocGFuZWwpIHtcbiAgICAgICAgcGFuZWwuZGVjcmVhc2VJbmRleChwYW5lbHNSZW1vdmVkLmxlbmd0aCk7XG4gICAgICAgIHBhbmVsLnVwZGF0ZVBvc2l0aW9uKCk7XG4gICAgICB9KTtcbiAgICAgIGlmIChpdGVtLmhhc0RPTUluRWxlbWVudHMpIHtcbiAgICAgICAgX3RoaXMuX3JlbW92ZVBhbmVsRWxlbWVudHMocGFuZWxzUmVtb3ZlZCk7XG4gICAgICB9XG4gICAgICAvLyBSZW1vdmUgcGFuZWwgZWxlbWVudHNcbiAgICAgIHBhbmVsc1JlbW92ZWQuZm9yRWFjaChmdW5jdGlvbiAocGFuZWwpIHtcbiAgICAgICAgcmV0dXJuIHBhbmVsLmRlc3Ryb3koKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKGluY2x1ZGVzKHBhbmVsc1JlbW92ZWQsIGFjdGl2ZVBhbmVsKSkge1xuICAgICAgICBjb250cm9sLnJlc2V0QWN0aXZlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX19zcHJlYWQkMShyZW1vdmVkLCBwYW5lbHNSZW1vdmVkKTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIGFsbFBhbmVsc1JlbW92ZWQ7XG4gIH07XG4gIC8qKlxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqL1xuICBfX3Byb3RvLnVwZGF0ZUFmdGVyUGFuZWxDaGFuZ2UgPSBmdW5jdGlvbiAocGFuZWxzQWRkZWQsIHBhbmVsc1JlbW92ZWQpIHtcbiAgICB2YXIgX2E7XG4gICAgdmFyIGZsaWNraW5nID0gZ2V0RmxpY2tpbmdBdHRhY2hlZCh0aGlzLl9mbGlja2luZyk7XG4gICAgdmFyIGNhbWVyYSA9IGZsaWNraW5nLmNhbWVyYSxcbiAgICAgIGNvbnRyb2wgPSBmbGlja2luZy5jb250cm9sO1xuICAgIHZhciBwYW5lbHMgPSB0aGlzLl9wYW5lbHM7XG4gICAgdmFyIGFjdGl2ZVBhbmVsID0gY29udHJvbC5hY3RpdmVQYW5lbDtcbiAgICAvLyBVcGRhdGUgY2FtZXJhICYgY29udHJvbFxuICAgIHRoaXMuX3VwZGF0ZUNhbWVyYUFuZENvbnRyb2woKTtcbiAgICB2b2lkIHRoaXMucmVuZGVyKCk7XG4gICAgaWYgKCFmbGlja2luZy5hbmltYXRpbmcpIHtcbiAgICAgIGlmICghYWN0aXZlUGFuZWwgfHwgYWN0aXZlUGFuZWwucmVtb3ZlZCkge1xuICAgICAgICBpZiAocGFuZWxzLmxlbmd0aCA8PSAwKSB7XG4gICAgICAgICAgLy8gQWxsIHBhbmVscyByZW1vdmVkXG4gICAgICAgICAgY2FtZXJhLmxvb2tBdCgwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgdGFyZ2V0SW5kZXggPSAoX2EgPSBhY3RpdmVQYW5lbCA9PT0gbnVsbCB8fCBhY3RpdmVQYW5lbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWN0aXZlUGFuZWwuaW5kZXgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgICAgaWYgKHRhcmdldEluZGV4ID4gcGFuZWxzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHRhcmdldEluZGV4ID0gcGFuZWxzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZvaWQgY29udHJvbC5tb3ZlVG9QYW5lbChwYW5lbHNbdGFyZ2V0SW5kZXhdLCB7XG4gICAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZvaWQgY29udHJvbC5tb3ZlVG9QYW5lbChhY3RpdmVQYW5lbCwge1xuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZmxpY2tpbmcuY2FtZXJhLnVwZGF0ZU9mZnNldCgpO1xuICAgIGlmIChwYW5lbHNBZGRlZC5sZW5ndGggPiAwIHx8IHBhbmVsc1JlbW92ZWQubGVuZ3RoID4gMCkge1xuICAgICAgZmxpY2tpbmcudHJpZ2dlcihuZXcgQ29tcG9uZW50RXZlbnQkMShFVkVOVFMuUEFORUxfQ0hBTkdFLCB7XG4gICAgICAgIGFkZGVkOiBwYW5lbHNBZGRlZCxcbiAgICAgICAgcmVtb3ZlZDogcGFuZWxzUmVtb3ZlZFxuICAgICAgfSkpO1xuICAgICAgdGhpcy5jaGVja1BhbmVsQ29udGVudHNSZWFkeShfX3NwcmVhZCQxKHBhbmVsc0FkZGVkLCBwYW5lbHNSZW1vdmVkKSk7XG4gICAgfVxuICB9O1xuICAvKipcclxuICAgKiBAaW50ZXJuYWxcclxuICAgKi9cbiAgX19wcm90by5jaGVja1BhbmVsQ29udGVudHNSZWFkeSA9IGZ1bmN0aW9uIChjaGVja2luZ1BhbmVscykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIGZsaWNraW5nID0gZ2V0RmxpY2tpbmdBdHRhY2hlZCh0aGlzLl9mbGlja2luZyk7XG4gICAgdmFyIHJlc2l6ZU9uQ29udGVudHNSZWFkeSA9IGZsaWNraW5nLnJlc2l6ZU9uQ29udGVudHNSZWFkeTtcbiAgICB2YXIgcGFuZWxzID0gdGhpcy5fcGFuZWxzO1xuICAgIGlmICghcmVzaXplT25Db250ZW50c1JlYWR5IHx8IGZsaWNraW5nLnZpcnR1YWxFbmFibGVkKSByZXR1cm47XG4gICAgdmFyIGhhc0NvbnRlbnRzID0gZnVuY3Rpb24gKHBhbmVsKSB7XG4gICAgICByZXR1cm4gcGFuZWwuZWxlbWVudCAmJiAhIXBhbmVsLmVsZW1lbnQucXVlcnlTZWxlY3RvcihcImltZywgdmlkZW9cIik7XG4gICAgfTtcbiAgICBjaGVja2luZ1BhbmVscyA9IGNoZWNraW5nUGFuZWxzLmZpbHRlcihmdW5jdGlvbiAocGFuZWwpIHtcbiAgICAgIHJldHVybiBoYXNDb250ZW50cyhwYW5lbCk7XG4gICAgfSk7XG4gICAgaWYgKGNoZWNraW5nUGFuZWxzLmxlbmd0aCA8PSAwKSByZXR1cm47XG4gICAgdmFyIGNvbnRlbnRzUmVhZHlDaGVja2VyID0gbmV3IEltUmVhZHkoKTtcbiAgICBjaGVja2luZ1BhbmVscy5mb3JFYWNoKGZ1bmN0aW9uIChwYW5lbCkge1xuICAgICAgcGFuZWwubG9hZGluZyA9IHRydWU7XG4gICAgfSk7XG4gICAgY29udGVudHNSZWFkeUNoZWNrZXIub24oXCJyZWFkeUVsZW1lbnRcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmICghX3RoaXMuX2ZsaWNraW5nKSB7XG4gICAgICAgIC8vIFJlbmRlcmVyJ3MgZGVzdHJveSgpIGlzIGNhbGxlZCBiZWZvcmVcbiAgICAgICAgY29udGVudHNSZWFkeUNoZWNrZXIuZGVzdHJveSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgcGFuZWwgPSBjaGVja2luZ1BhbmVsc1tlLmluZGV4XTtcbiAgICAgIHZhciBjYW1lcmEgPSBmbGlja2luZy5jYW1lcmE7XG4gICAgICB2YXIgY29udHJvbCA9IGZsaWNraW5nLmNvbnRyb2w7XG4gICAgICB2YXIgcHJldlByb2dyZXNzSW5QYW5lbCA9IGNvbnRyb2wuYWN0aXZlUGFuZWwgPyBjYW1lcmEuZ2V0UHJvZ3Jlc3NJblBhbmVsKGNvbnRyb2wuYWN0aXZlUGFuZWwpIDogMDtcbiAgICAgIHBhbmVsLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgIHBhbmVsLnJlc2l6ZSgpO1xuICAgICAgcGFuZWxzLnNsaWNlKHBhbmVsLmluZGV4ICsgMSkuZm9yRWFjaChmdW5jdGlvbiAocGFuZWxCZWhpbmQpIHtcbiAgICAgICAgcmV0dXJuIHBhbmVsQmVoaW5kLnVwZGF0ZVBvc2l0aW9uKCk7XG4gICAgICB9KTtcbiAgICAgIGlmICghZmxpY2tpbmcuaW5pdGlhbGl6ZWQpIHJldHVybjtcbiAgICAgIGNhbWVyYS51cGRhdGVSYW5nZSgpO1xuICAgICAgY2FtZXJhLnVwZGF0ZU9mZnNldCgpO1xuICAgICAgY2FtZXJhLnVwZGF0ZUFuY2hvcnMoKTtcbiAgICAgIGlmIChjb250cm9sLmFuaW1hdGluZykgOyBlbHNlIHtcbiAgICAgICAgY29udHJvbC51cGRhdGVQb3NpdGlvbihwcmV2UHJvZ3Jlc3NJblBhbmVsKTtcbiAgICAgICAgY29udHJvbC51cGRhdGVJbnB1dCgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnRlbnRzUmVhZHlDaGVja2VyLm9uKFwicHJlUmVhZHlcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChfdGhpcy5fZmxpY2tpbmcpIHtcbiAgICAgICAgdm9pZCBfdGhpcy5yZW5kZXIoKTtcbiAgICAgIH1cbiAgICAgIGlmIChlLnJlYWR5Q291bnQgPT09IGUudG90YWxDb3VudCkge1xuICAgICAgICBjb250ZW50c1JlYWR5Q2hlY2tlci5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29udGVudHNSZWFkeUNoZWNrZXIub24oXCJyZWFkeVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoX3RoaXMuX2ZsaWNraW5nKSB7XG4gICAgICAgIHZvaWQgX3RoaXMucmVuZGVyKCk7XG4gICAgICB9XG4gICAgICBjb250ZW50c1JlYWR5Q2hlY2tlci5kZXN0cm95KCk7XG4gICAgfSk7XG4gICAgY29udGVudHNSZWFkeUNoZWNrZXIuY2hlY2soY2hlY2tpbmdQYW5lbHMubWFwKGZ1bmN0aW9uIChwYW5lbCkge1xuICAgICAgcmV0dXJuIHBhbmVsLmVsZW1lbnQ7XG4gICAgfSkpO1xuICB9O1xuICBfX3Byb3RvLl91cGRhdGVDYW1lcmFBbmRDb250cm9sID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBmbGlja2luZyA9IGdldEZsaWNraW5nQXR0YWNoZWQodGhpcy5fZmxpY2tpbmcpO1xuICAgIHZhciBjYW1lcmEgPSBmbGlja2luZy5jYW1lcmEsXG4gICAgICBjb250cm9sID0gZmxpY2tpbmcuY29udHJvbDtcbiAgICBjYW1lcmEudXBkYXRlUmFuZ2UoKTtcbiAgICBjYW1lcmEudXBkYXRlT2Zmc2V0KCk7XG4gICAgY2FtZXJhLnVwZGF0ZUFuY2hvcnMoKTtcbiAgICBjYW1lcmEucmVzZXROZWVkUGFuZWxIaXN0b3J5KCk7XG4gICAgY29udHJvbC51cGRhdGVJbnB1dCgpO1xuICB9O1xuICBfX3Byb3RvLl9zaG93T25seVZpc2libGVQYW5lbHMgPSBmdW5jdGlvbiAoZmxpY2tpbmcpIHtcbiAgICB2YXIgcGFuZWxzID0gZmxpY2tpbmcucmVuZGVyZXIucGFuZWxzO1xuICAgIHZhciBjYW1lcmEgPSBmbGlja2luZy5jYW1lcmE7XG4gICAgdmFyIHZpc2libGVJbmRleGVzID0gY2FtZXJhLnZpc2libGVQYW5lbHMucmVkdWNlKGZ1bmN0aW9uICh2aXNpYmxlcywgcGFuZWwpIHtcbiAgICAgIHZpc2libGVzW3BhbmVsLmluZGV4XSA9IHRydWU7XG4gICAgICByZXR1cm4gdmlzaWJsZXM7XG4gICAgfSwge30pO1xuICAgIHBhbmVscy5mb3JFYWNoKGZ1bmN0aW9uIChwYW5lbCkge1xuICAgICAgaWYgKHBhbmVsLmluZGV4IGluIHZpc2libGVJbmRleGVzIHx8IHBhbmVsLmxvYWRpbmcpIHtcbiAgICAgICAgcGFuZWwubWFya0ZvclNob3coKTtcbiAgICAgIH0gZWxzZSBpZiAoIWZsaWNraW5nLmhvbGRpbmcpIHtcbiAgICAgICAgLy8gRHVyaW5nIHRoZSBpbnB1dCBzZXF1ZW5jZSxcbiAgICAgICAgLy8gRG8gbm90IHJlbW92ZSBwYW5lbCBlbGVtZW50cyBhcyBpdCB3b24ndCB0cmlnZ2VyIHRvdWNoZW5kIGV2ZW50LlxuICAgICAgICBwYW5lbC5tYXJrRm9ySGlkZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICBfX3Byb3RvLl91cGRhdGVQYW5lbFNpemVCeUdyaWQgPSBmdW5jdGlvbiAocmVmZXJlbmNlUGFuZWwsIHBhbmVscykge1xuICAgIHZhciBmbGlja2luZyA9IGdldEZsaWNraW5nQXR0YWNoZWQodGhpcy5fZmxpY2tpbmcpO1xuICAgIHZhciBwYW5lbHNQZXJWaWV3ID0gZmxpY2tpbmcucGFuZWxzUGVyVmlldztcbiAgICBpZiAocGFuZWxzUGVyVmlldyA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRmxpY2tpbmdFcnJvcihNRVNTQUdFLldST05HX09QVElPTihcInBhbmVsc1BlclZpZXdcIiwgcGFuZWxzUGVyVmlldyksIENPREUuV1JPTkdfT1BUSU9OKTtcbiAgICB9XG4gICAgaWYgKHBhbmVscy5sZW5ndGggPD0gMCkgcmV0dXJuO1xuICAgIHZhciB2aWV3cG9ydFNpemUgPSBmbGlja2luZy5jYW1lcmEuc2l6ZTtcbiAgICB2YXIgZ2FwID0gcmVmZXJlbmNlUGFuZWwubWFyZ2luLnByZXYgKyByZWZlcmVuY2VQYW5lbC5tYXJnaW4ubmV4dDtcbiAgICB2YXIgcGFuZWxTaXplID0gKHZpZXdwb3J0U2l6ZSAtIGdhcCAqIChwYW5lbHNQZXJWaWV3IC0gMSkpIC8gcGFuZWxzUGVyVmlldztcbiAgICB2YXIgcGFuZWxTaXplT2JqID0gZmxpY2tpbmcuaG9yaXpvbnRhbCA/IHtcbiAgICAgIHdpZHRoOiBwYW5lbFNpemVcbiAgICB9IDoge1xuICAgICAgaGVpZ2h0OiBwYW5lbFNpemVcbiAgICB9O1xuICAgIHZhciBmaXJzdFBhbmVsU2l6ZU9iaiA9IF9fYXNzaWduJDIoe1xuICAgICAgc2l6ZTogcGFuZWxTaXplLFxuICAgICAgbWFyZ2luOiByZWZlcmVuY2VQYW5lbC5tYXJnaW5cbiAgICB9LCAhZmxpY2tpbmcuaG9yaXpvbnRhbCAmJiB7XG4gICAgICBoZWlnaHQ6IHJlZmVyZW5jZVBhbmVsLmhlaWdodFxuICAgIH0pO1xuICAgIGlmICghZmxpY2tpbmcubm9QYW5lbFN0eWxlT3ZlcnJpZGUpIHtcbiAgICAgIHRoaXMuX3N0cmF0ZWd5LnVwZGF0ZVBhbmVsU2l6ZXMoZmxpY2tpbmcsIHBhbmVsU2l6ZU9iaik7XG4gICAgfVxuICAgIGZsaWNraW5nLnBhbmVscy5mb3JFYWNoKGZ1bmN0aW9uIChwYW5lbCkge1xuICAgICAgcmV0dXJuIHBhbmVsLnJlc2l6ZShmaXJzdFBhbmVsU2l6ZU9iaik7XG4gICAgfSk7XG4gIH07XG4gIF9fcHJvdG8uX3JlbW92ZUFsbENoaWxkc0Zyb21DYW1lcmEgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZsaWNraW5nID0gZ2V0RmxpY2tpbmdBdHRhY2hlZCh0aGlzLl9mbGlja2luZyk7XG4gICAgdmFyIGNhbWVyYUVsZW1lbnQgPSBmbGlja2luZy5jYW1lcmEuZWxlbWVudDtcbiAgICAvLyBSZW1vdmUgb3RoZXIgZWxlbWVudHNcbiAgICB3aGlsZSAoY2FtZXJhRWxlbWVudC5maXJzdENoaWxkKSB7XG4gICAgICBjYW1lcmFFbGVtZW50LnJlbW92ZUNoaWxkKGNhbWVyYUVsZW1lbnQuZmlyc3RDaGlsZCk7XG4gICAgfVxuICB9O1xuICBfX3Byb3RvLl9pbnNlcnRQYW5lbEVsZW1lbnRzID0gZnVuY3Rpb24gKHBhbmVscywgbmV4dFNpYmxpbmcpIHtcbiAgICBpZiAobmV4dFNpYmxpbmcgPT09IHZvaWQgMCkge1xuICAgICAgbmV4dFNpYmxpbmcgPSBudWxsO1xuICAgIH1cbiAgICB2YXIgZmxpY2tpbmcgPSBnZXRGbGlja2luZ0F0dGFjaGVkKHRoaXMuX2ZsaWNraW5nKTtcbiAgICB2YXIgY2FtZXJhID0gZmxpY2tpbmcuY2FtZXJhO1xuICAgIHZhciBjYW1lcmFFbGVtZW50ID0gY2FtZXJhLmVsZW1lbnQ7XG4gICAgdmFyIG5leHRTaWJsaW5nRWxlbWVudCA9IChuZXh0U2libGluZyA9PT0gbnVsbCB8fCBuZXh0U2libGluZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbmV4dFNpYmxpbmcuZWxlbWVudCkgfHwgbnVsbDtcbiAgICB2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgcGFuZWxzLmZvckVhY2goZnVuY3Rpb24gKHBhbmVsKSB7XG4gICAgICByZXR1cm4gZnJhZ21lbnQuYXBwZW5kQ2hpbGQocGFuZWwuZWxlbWVudCk7XG4gICAgfSk7XG4gICAgY2FtZXJhRWxlbWVudC5pbnNlcnRCZWZvcmUoZnJhZ21lbnQsIG5leHRTaWJsaW5nRWxlbWVudCk7XG4gIH07XG4gIF9fcHJvdG8uX3JlbW92ZVBhbmVsRWxlbWVudHMgPSBmdW5jdGlvbiAocGFuZWxzKSB7XG4gICAgdmFyIGZsaWNraW5nID0gZ2V0RmxpY2tpbmdBdHRhY2hlZCh0aGlzLl9mbGlja2luZyk7XG4gICAgdmFyIGNhbWVyYUVsZW1lbnQgPSBmbGlja2luZy5jYW1lcmEuZWxlbWVudDtcbiAgICBwYW5lbHMuZm9yRWFjaChmdW5jdGlvbiAocGFuZWwpIHtcbiAgICAgIGNhbWVyYUVsZW1lbnQucmVtb3ZlQ2hpbGQocGFuZWwuZWxlbWVudCk7XG4gICAgfSk7XG4gIH07XG4gIF9fcHJvdG8uX2FmdGVyUmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBmbGlja2luZyA9IGdldEZsaWNraW5nQXR0YWNoZWQodGhpcy5fZmxpY2tpbmcpO1xuICAgIGZsaWNraW5nLmNhbWVyYS5hcHBseVRyYW5zZm9ybSgpO1xuICB9O1xuICByZXR1cm4gUmVuZGVyZXI7XG59KCk7XG5cbi8qKlxyXG4gKlxyXG4gKi9cbnZhciBWYW5pbGxhUmVuZGVyZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMkMyhWYW5pbGxhUmVuZGVyZXIsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIFZhbmlsbGFSZW5kZXJlcigpIHtcbiAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9yZXF1aXJlLWF3YWl0XG4gIHZhciBfX3Byb3RvID0gVmFuaWxsYVJlbmRlcmVyLnByb3RvdHlwZTtcbiAgX19wcm90by5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGZsaWNraW5nLCBzdHJhdGVneTtcbiAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgZmxpY2tpbmcgPSBnZXRGbGlja2luZ0F0dGFjaGVkKHRoaXMuX2ZsaWNraW5nKTtcbiAgICAgICAgc3RyYXRlZ3kgPSB0aGlzLl9zdHJhdGVneTtcbiAgICAgICAgc3RyYXRlZ3kudXBkYXRlUmVuZGVyaW5nUGFuZWxzKGZsaWNraW5nKTtcbiAgICAgICAgc3RyYXRlZ3kucmVuZGVyUGFuZWxzKGZsaWNraW5nKTtcbiAgICAgICAgdGhpcy5fcmVzZXRQYW5lbEVsZW1lbnRPcmRlcigpO1xuICAgICAgICB0aGlzLl9hZnRlclJlbmRlcigpO1xuICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBfX3Byb3RvLl9jb2xsZWN0UGFuZWxzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBmbGlja2luZyA9IGdldEZsaWNraW5nQXR0YWNoZWQodGhpcy5fZmxpY2tpbmcpO1xuICAgIHZhciBjYW1lcmEgPSBmbGlja2luZy5jYW1lcmE7XG4gICAgdGhpcy5fcmVtb3ZlQWxsVGV4dE5vZGVzKCk7XG4gICAgdGhpcy5fcGFuZWxzID0gdGhpcy5fc3RyYXRlZ3kuY29sbGVjdFBhbmVscyhmbGlja2luZywgY2FtZXJhLmNoaWxkcmVuKTtcbiAgfTtcbiAgX19wcm90by5fY3JlYXRlUGFuZWwgPSBmdW5jdGlvbiAoZWwsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RyYXRlZ3kuY3JlYXRlUGFuZWwoZWwsIG9wdGlvbnMpO1xuICB9O1xuICBfX3Byb3RvLl9yZXNldFBhbmVsRWxlbWVudE9yZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBmbGlja2luZyA9IGdldEZsaWNraW5nQXR0YWNoZWQodGhpcy5fZmxpY2tpbmcpO1xuICAgIHZhciBjYW1lcmFFbCA9IGZsaWNraW5nLmNhbWVyYS5lbGVtZW50O1xuICAgIC8vIFdlJ3JlIHVzaW5nIHJldmVyc2VkIHBhbmVscyBoZXJlIGFzIGxhc3QgcGFuZWwgc2hvdWxkIGJlIHRoZSBsYXN0IGVsZW1lbnQgb2YgY2FtZXJhIGVsZW1lbnRcbiAgICB2YXIgcmV2ZXJzZWRFbGVtZW50cyA9IHRoaXMuX3N0cmF0ZWd5LmdldFJlbmRlcmluZ0VsZW1lbnRzQnlPcmRlcihmbGlja2luZykucmV2ZXJzZSgpO1xuICAgIHJldmVyc2VkRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWwsIGlkeCkge1xuICAgICAgdmFyIG5leHRFbCA9IHJldmVyc2VkRWxlbWVudHNbaWR4IC0gMV0gPyByZXZlcnNlZEVsZW1lbnRzW2lkeCAtIDFdIDogbnVsbDtcbiAgICAgIGlmIChlbC5uZXh0RWxlbWVudFNpYmxpbmcgIT09IG5leHRFbCkge1xuICAgICAgICBjYW1lcmFFbC5pbnNlcnRCZWZvcmUoZWwsIG5leHRFbCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIF9fcHJvdG8uX3JlbW92ZUFsbFRleHROb2RlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZmxpY2tpbmcgPSBnZXRGbGlja2luZ0F0dGFjaGVkKHRoaXMuX2ZsaWNraW5nKTtcbiAgICB2YXIgY2FtZXJhRWxlbWVudCA9IGZsaWNraW5nLmNhbWVyYS5lbGVtZW50O1xuICAgIC8vIFJlbW92ZSBhbGwgdGV4dCBub2RlcyBpbiB0aGUgY2FtZXJhIGVsZW1lbnRcbiAgICB0b0FycmF5JDIoY2FtZXJhRWxlbWVudC5jaGlsZE5vZGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpIHtcbiAgICAgICAgY2FtZXJhRWxlbWVudC5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgcmV0dXJuIFZhbmlsbGFSZW5kZXJlcjtcbn0oUmVuZGVyZXIpO1xuXG4vKipcclxuICogQGludGVybmFsXHJcbiAqL1xudmFyIEV4dGVybmFsUmVuZGVyZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMkMyhFeHRlcm5hbFJlbmRlcmVyLCBfc3VwZXIpO1xuICBmdW5jdGlvbiBFeHRlcm5hbFJlbmRlcmVyKCkge1xuICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuICAvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnMgKi9cbiAgdmFyIF9fcHJvdG8gPSBFeHRlcm5hbFJlbmRlcmVyLnByb3RvdHlwZTtcbiAgX19wcm90by5fcmVtb3ZlUGFuZWxFbGVtZW50cyA9IGZ1bmN0aW9uIChwYW5lbHMpIHtcbiAgICAvLyBETyBOT1RISU5HLCBvdmVycmlkZWQgdG8gcHJldmVudCBhbiB1bmV4cGVjdGVkIGVycm9yXG4gIH07XG4gIF9fcHJvdG8uX3JlbW92ZUFsbENoaWxkc0Zyb21DYW1lcmEgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gRE8gTk9USElORywgb3ZlcnJpZGVkIHRvIHByZXZlbnQgYW4gdW5leHBlY3RlZCBlcnJvclxuICB9O1xuICByZXR1cm4gRXh0ZXJuYWxSZW5kZXJlcjtcbn0oUmVuZGVyZXIpO1xuXG4vKipcclxuICogQSBzbGlkZSBkYXRhIGNvbXBvbmVudCB0aGF0IGhvbGRzIGluZm9ybWF0aW9uIG9mIGEgc2luZ2xlIEhUTUxFbGVtZW50XHJcbiAqIEBrbyDsiqzrnbzsnbTrk5wg642w7J207YSwIOy7tO2PrOuEjO2KuOuhnCwg64uo7J28IEhUTUxFbGVtZW507J2YIOygleuztOulvCDqsJbqs6Ag7J6I7Iq164uI64ukXHJcbiAqL1xudmFyIFBhbmVsID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgQW4gb3B0aW9ucyBvYmplY3Q8a28+7Ji17IWYIOyYpOu4jOygne2KuDwva28+XHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmluZGV4XSBBbiBpbml0aWFsIGluZGV4IG9mIHRoZSBwYW5lbDxrbz7tjKjrhJDsnZgg7LSI6riwIOyduOuNseyKpDwva28+XHJcbiAgICogQHBhcmFtIHtDb25zdGFudHMuQUxJR04gfCBzdHJpbmcgfCBudW1iZXJ9IFtvcHRpb25zLmFsaWduXSBBbiBpbml0aWFsIHtAbGluayBGbGlja2luZyNhbGlnbiBhbGlnbn0gdmFsdWUgb2YgdGhlIHBhbmVsPGtvPu2MqOuEkOydmCDstIjquLAge0BsaW5rIEZsaWNraW5nI2FsaWduIGFsaWdufeqwkjwva28+XHJcbiAgICogQHBhcmFtIHtGbGlja2luZ30gW29wdGlvbnMuZmxpY2tpbmddIEEgRmxpY2tpbmcgaW5zdGFuY2UgcGFuZWwncyByZWZlcmVuY2luZzxrbz7tjKjrhJDsnbQg7LC47KGw7ZWY64qUIHtAbGluayBGbGlja2luZ30g7J247Iqk7YS07IqkPC9rbz5cclxuICAgKiBAcGFyYW0ge0ZsaWNraW5nfSBbb3B0aW9ucy5lbGVtZW50UHJvdmlkZXJdIEEgcHJvdmlkZXIgaW5zdGFuY2UgdGhhdCByZWRpcmVjdHMgZWxlbWVudHM8a28+7Iuk7KCcIOyXmOumrOuovO2KuOulvCDrsJjtmZjtlZjripQg7JeY66as66i87Yq4IOqzteq4ieyekOydmCDsnbjsiqTthLTsiqQ8L2tvPlxyXG4gICAqL1xuICBmdW5jdGlvbiBQYW5lbChfYSkge1xuICAgIHZhciBpbmRleCA9IF9hLmluZGV4LFxuICAgICAgYWxpZ24gPSBfYS5hbGlnbixcbiAgICAgIGZsaWNraW5nID0gX2EuZmxpY2tpbmcsXG4gICAgICBlbGVtZW50UHJvdmlkZXIgPSBfYS5lbGVtZW50UHJvdmlkZXI7XG4gICAgdGhpcy5faW5kZXggPSBpbmRleDtcbiAgICB0aGlzLl9mbGlja2luZyA9IGZsaWNraW5nO1xuICAgIHRoaXMuX2VsUHJvdmlkZXIgPSBlbGVtZW50UHJvdmlkZXI7XG4gICAgdGhpcy5fYWxpZ24gPSBhbGlnbjtcbiAgICB0aGlzLl9yZW1vdmVkID0gZmFsc2U7XG4gICAgdGhpcy5fcmVuZGVyZWQgPSB0cnVlO1xuICAgIHRoaXMuX2xvYWRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9yZXNldEludGVybmFsU3RhdGVzKCk7XG4gIH1cbiAgdmFyIF9fcHJvdG8gPSBQYW5lbC5wcm90b3R5cGU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcImVsZW1lbnRcIiwge1xuICAgIC8vIEludGVybmFsIFN0YXRlcyBHZXR0ZXJcbiAgICAvKipcclxuICAgICAqIGBIVE1MRWxlbWVudGAgdGhhdCBwYW5lbCdzIHJlZmVyZW5jaW5nXHJcbiAgICAgKiBAa28g7Yyo64SQ7J20IOywuOyhsO2VmOqzoCDsnojripQgYEhUTUxFbGVtZW50YFxyXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9lbFByb3ZpZGVyLmVsZW1lbnQ7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcImVsZW1lbnRQcm92aWRlclwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZWxQcm92aWRlcjtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwiaW5kZXhcIiwge1xuICAgIC8qKlxyXG4gICAgICogSW5kZXggb2YgdGhlIHBhbmVsXHJcbiAgICAgKiBAa28g7Yyo64SQ7J2YIOyduOuNseyKpFxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5faW5kZXg7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcInBvc2l0aW9uXCIsIHtcbiAgICAvKipcclxuICAgICAqIFBvc2l0aW9uIG9mIHRoZSBwYW5lbCwgaW5jbHVkaW5nIHtAbGluayBQYW5lbCNhbGlnblBvc2l0aW9uIGFsaWduUG9zaXRpb259XHJcbiAgICAgKiBAa28g7Yyo64SQ7J2YIO2YhOyerCDsooztkZwsIHtAbGluayBQYW5lbCNhbGlnblBvc2l0aW9uIGFsaWduUG9zaXRpb2597J2EIO2PrO2VqO2VmOqzoCDsnojsirXri4jri6RcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3BvcyArIHRoaXMuX2FsaWduUG9zO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJzaXplXCIsIHtcbiAgICAvKipcclxuICAgICAqIENhY2hlZCBzaXplIG9mIHRoZSBwYW5lbCBlbGVtZW50XHJcbiAgICAgKiBUaGlzIGlzIGVxdWFsIHRvIHtAbGluayBQYW5lbCNlbGVtZW50IGVsZW1lbnR9J3MgYG9mZnNldFdpZHRoYCBpZiB7QGxpbmsgRmxpY2tpbmcjaG9yaXpvbnRhbCBob3Jpem9udGFsfSBpcyBgdHJ1ZWAsIGFuZCBgb2Zmc2V0SGVpZ2h0YCBlbHNlXHJcbiAgICAgKiBAa28g7Yyo64SQIOyXmOumrOuovO2KuOydmCDsupDsi5zrkJwg7YGs6riwXHJcbiAgICAgKiDsnbQg6rCS7J2AIHtAbGluayBGbGlja2luZyNob3Jpem9udGFsIGhvcml6b250YWx97J20IGB0cnVlYOydvCDqsr3smrAge0BsaW5rIFBhbmVsI2VsZW1lbnQgZWxlbWVudH3snZggYG9mZnNldFdpZHRoYOyZgCDrj5nsnbztlZjqs6AsIGBmYWxzZWDsnbwg6rK97JqwIGBvZmZzZXRIZWlnaHRg7JmAIOuPmeydvO2VqeuLiOuLpFxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2l6ZTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwic2l6ZUluY2x1ZGluZ01hcmdpblwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBQYW5lbCdzIHNpemUgaW5jbHVkaW5nIENTUyBgbWFyZ2luYFxyXG4gICAgICogVGhpcyB2YWx1ZSBpbmNsdWRlcyB7QGxpbmsgUGFuZWwjZWxlbWVudCBlbGVtZW50fSdzIG1hcmdpbiBsZWZ0L3JpZ2h0IGlmIHtAbGluayBGbGlja2luZyNob3Jpem9udGFsIGhvcml6b250YWx9IGlzIGB0cnVlYCwgYW5kIG1hcmdpbiB0b3AvYm90dG9tIGVsc2VcclxuICAgICAqIEBrbyBDU1MgYG1hcmdpbmDsnYQg7Y+s7ZWo7ZWcIO2MqOuEkOydmCDtgazquLBcclxuICAgICAqIOydtCDqsJLsnYAge0BsaW5rIEZsaWNraW5nI2hvcml6b250YWwgaG9yaXpvbnRhbH3snbQgYHRydWVg7J28IOqyveyasCBtYXJnaW4gbGVmdC9yaWdodOydhCDtj6ztlajtlZjqs6AsIGBmYWxzZWDsnbwg6rK97JqwIG1hcmdpbiB0b3AvYm90dG9t7J2EIO2PrO2VqO2VqeuLiOuLpFxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2l6ZSArIHRoaXMuX21hcmdpbi5wcmV2ICsgdGhpcy5fbWFyZ2luLm5leHQ7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcImhlaWdodFwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBIZWlnaHQgb2YgdGhlIHBhbmVsIGVsZW1lbnRcclxuICAgICAqIEBrbyDtjKjrhJAg7JeY66as66i87Yq47J2YIOuGkuydtFxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5faGVpZ2h0O1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJtYXJnaW5cIiwge1xuICAgIC8qKlxyXG4gICAgICogQ2FjaGVkIENTUyBgbWFyZ2luYCB2YWx1ZSBvZiB0aGUgcGFuZWwgZWxlbWVudFxyXG4gICAgICogQGtvIO2MqOuEkCDsl5jrpqzrqLztirjsnZggQ1NTIGBtYXJnaW5gIOqwklxyXG4gICAgICogQHR5cGUge29iamVjdH1cclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwcmV2IENTUyBgbWFyZ2luLWxlZnRgIHdoZW4gdGhlIHtAbGluayBGbGlja2luZyNob3Jpem9udGFsIGhvcml6b250YWx9IGlzIGB0cnVlYCwgYW5kIGBtYXJnaW4tdG9wYCBlbHNlXHJcbiAgICAgKiA8a28+e0BsaW5rIEZsaWNraW5nI2hvcml6b250YWwgaG9yaXpvbnRhbH3snbQgYHRydWVg7J28IOqyveyasCBgbWFyZ2luLWxlZnRgLCBgZmFsc2Vg7J28IOqyveyasCBgbWFyZ2luLXRvcGDsl5Ag7ZW064u57ZWY64qUIOqwkjwva28+XHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbmV4dCBDU1MgYG1hcmdpbi1yaWdodGAgd2hlbiB0aGUge0BsaW5rIEZsaWNraW5nI2hvcml6b250YWwgaG9yaXpvbnRhbH0gaXMgYHRydWVgLCBhbmQgYG1hcmdpbi1ib3R0b21gIGVsc2VcclxuICAgICAqIDxrbz57QGxpbmsgRmxpY2tpbmcjaG9yaXpvbnRhbCBob3Jpem9udGFsfeydtCBgdHJ1ZWDsnbwg6rK97JqwIGBtYXJnaW4tcmlnaHRgLCBgZmFsc2Vg7J28IOqyveyasCBgbWFyZ2luLWJvdHRvbWDsl5Ag7ZW064u57ZWY64qUIOqwkjwva28+XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX21hcmdpbjtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwiYWxpZ25Qb3NpdGlvblwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBBbGlnbiBwb3NpdGlvbiBpbnNpZGUgdGhlIHBhbmVsIHdoZXJlIHtAbGluayBDYW1lcmF9J3Mge0BsaW5rIENhbWVyYSNhbGlnblBvc2l0aW9uIGFsaWduUG9zaXRpb259IGluc2lkZSB2aWV3cG9ydCBzaG91bGQgYmUgbG9jYXRlZCBhdFxyXG4gICAgICogQGtvIO2MqOuEkOydmCDsoJXroKwg6riw7KSAIOychOy5mC4ge0BsaW5rIENhbWVyYX3snZgg67ew7Y+s7Yq4IOuCtOyXkOyEnOydmCB7QGxpbmsgQ2FtZXJhI2FsaWduUG9zaXRpb24gYWxpZ25Qb3NpdGlvbn3snbQg7JyE7LmY7ZW07JW8IO2VmOuKlCDqs7PsnoXri4jri6RcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2FsaWduUG9zO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJyZW1vdmVkXCIsIHtcbiAgICAvKipcclxuICAgICAqIEEgdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBwYW5lbCdzIHtAbGluayBGbGlja2luZyNyZW1vdmUgcmVtb3ZlfWRcclxuICAgICAqIEBrbyDtjKjrhJDsnbQge0BsaW5rIEZsaWNraW5nI3JlbW92ZSByZW1vdmV965CY7JeI64qU7KeAIOyXrOu2gOulvCDrgpjtg4DrgrTripQg6rCSXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVtb3ZlZDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwicmVuZGVyZWRcIiwge1xuICAgIC8qKlxyXG4gICAgICogQSB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIHBhbmVsJ3MgZWxlbWVudCBpcyBiZWluZyByZW5kZXJlZCBvbiB0aGUgc2NyZWVuXHJcbiAgICAgKiBAa28g7Yyo64SQ7J2YIOyXmOumrOuovO2KuOqwgCDtmZTrqbTsg4Hsl5Ag66CM642U66eB65CY6rOg7J6I64qU7KeAIOyXrOu2gOulvCDrgpjtg4DrgrTripQg6rCSXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVuZGVyZWQ7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcImxvYWRpbmdcIiwge1xuICAgIC8qKlxyXG4gICAgICogQSB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIHBhbmVsJ3MgaW1hZ2UvdmlkZW8gaXMgbm90IGxvYWRlZCBhbmQgd2FpdGluZyBmb3IgcmVzaXplXHJcbiAgICAgKiBAa28g7Yyo64SQIOuCtOu2gOydmCDsnbTrr7jsp4Av67mE65SU7Jik6rCAIOyVhOyngSDroZzrk5zrkJjsp4Ag7JWK7JWEIHtAbGluayBQYW5lbCNyZXNpemUgcmVzaXplfeuQoCDqsoPsnbjsp4Drpbwg64KY7YOA64K064qUIOqwklxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2xvYWRpbmc7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHRoaXMuX2xvYWRpbmcgPSB2YWw7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcInJhbmdlXCIsIHtcbiAgICAvKipcclxuICAgICAqIFBhbmVsIGVsZW1lbnQncyByYW5nZSBvZiB0aGUgYm91bmRpbmcgYm94XHJcbiAgICAgKiBAa28g7Yyo64SQIOyXmOumrOuovO2KuOydmCBCb3VuZGluZyBib3gg67KU7JyEXHJcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFttaW5dIEJvdW5kaW5nIGJveCdzIGxlZnQoe0BsaW5rIEZsaWNraW5nI2hvcml6b250YWwgaG9yaXpvbnRhbH06IHRydWUpIC8gdG9wKHtAbGluayBGbGlja2luZyNob3Jpem9udGFsIGhvcml6b250YWx9OiBmYWxzZSlcclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWF4XSBCb3VuZGluZyBib3gncyByaWdodCh7QGxpbmsgRmxpY2tpbmcjaG9yaXpvbnRhbCBob3Jpem9udGFsfTogdHJ1ZSkgLyBib3R0b20oe0BsaW5rIEZsaWNraW5nI2hvcml6b250YWwgaG9yaXpvbnRhbH06IGZhbHNlKVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1pbjogdGhpcy5fcG9zLFxuICAgICAgICBtYXg6IHRoaXMuX3BvcyArIHRoaXMuX3NpemVcbiAgICAgIH07XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcInRvZ2dsZWRcIiwge1xuICAgIC8qKlxyXG4gICAgICogQSB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIHBhbmVsJ3MgcG9zaXRpb24gaXMgdG9nZ2xlZCBieSBjaXJjdWxhciBiZWhhdmlvclxyXG4gICAgICogQGtvIO2MqOuEkOydmCDsnITsuZjqsIAgY2lyY3VsYXIg64+Z7J6R7JeQIOydmO2VtCDthqDquIDrkJjsl4jripTsp4Ag7Jes67aA66W8IOuCmO2DgOuCtOuKlCDqsJJcclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl90b2dnbGVkO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJ0b2dnbGVEaXJlY3Rpb25cIiwge1xuICAgIC8qKlxyXG4gICAgICogQSBkaXJlY3Rpb24gd2hlcmUgdGhlIHBhbmVsJ3MgcG9zaXRpb24gaXMgdG9nZ2xlZFxyXG4gICAgICogQGtvIO2MqOuEkOydmCDsnITsuZjqsIAgY2lyY3VsYXIg64+Z7J6R7JeQIOydmO2VtCDthqDquIDrkJjripQg67Cp7ZalXHJcbiAgICAgKiBAdHlwZSB7RElSRUNUSU9OfVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl90b2dnbGVEaXJlY3Rpb247XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcIm9mZnNldFwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBBY3R1YWwgcG9zaXRpb24gb2Zmc2V0IGRldGVybWluZWQgYnkge0BsaW5rIFBhbmVsI29yZGVyfVxyXG4gICAgICogQGtvIHtAbGluayBQYW5lbCNvcmRlcn3sl5Ag7J2Y7ZWcIOyLpOygnCDsnITsuZgg67OA6rK96rCSXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0b2dnbGVEaXJlY3Rpb24gPSB0aGlzLl90b2dnbGVEaXJlY3Rpb247XG4gICAgICB2YXIgY2FtZXJhUmFuZ2VEaWZmID0gdGhpcy5fZmxpY2tpbmcuY2FtZXJhLnJhbmdlRGlmZjtcbiAgICAgIHJldHVybiB0b2dnbGVEaXJlY3Rpb24gPT09IERJUkVDVElPTi5OT05FIHx8ICF0aGlzLl90b2dnbGVkID8gMCA6IHRvZ2dsZURpcmVjdGlvbiA9PT0gRElSRUNUSU9OLlBSRVYgPyAtY2FtZXJhUmFuZ2VEaWZmIDogY2FtZXJhUmFuZ2VEaWZmO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJwcm9ncmVzc1wiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBQcm9ncmVzcyBvZiBtb3ZlbWVudCBiZXR3ZWVuIHByZXZpb3VzIG9yIG5leHQgcGFuZWwgcmVsYXRpdmUgdG8gY3VycmVudCBwYW5lbFxyXG4gICAgICogQGtvIOydtCDtjKjrhJDroZzrtoDthLAg7J207KCEL+uLpOydjCDtjKjrhJDsnLzroZzsnZgg7J2064+ZIOynhO2WieuloFxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZmxpY2tpbmcgPSB0aGlzLl9mbGlja2luZztcbiAgICAgIHJldHVybiB0aGlzLmluZGV4IC0gZmxpY2tpbmcuY2FtZXJhLnByb2dyZXNzO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJvdXRzZXRQcm9ncmVzc1wiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBQcm9ncmVzcyBvZiBtb3ZlbWVudCBiZXR3ZWVuIHBvaW50cyB0aGF0IHBhbmVsIGlzIGNvbXBsZXRlbHkgaW52aXNpYmxlIG91dHNpZGUgb2Ygdmlld3BvcnQocHJldiBkaXJlY3Rpb246IC0xLCBzZWxlY3RlZCBwb2ludDogMCwgbmV4dCBkaXJlY3Rpb246IDEpXHJcbiAgICAgKiBAa28g7ZiE7J6sIO2MqOuEkOydtCDrt7Dtj6ztirgg7JiB7JetIOuwluycvOuhnCDsmYTsoITtnogg7IKs65287KeA64qUIOyngOygkOydhCDquLDspIDsnLzroZwg7ZWY64qUIOynhO2WieuPhChwcmV267Cp7ZalOiAtMSwg7ISg7YOdIOyngOygkDogMCwgbmV4dOuwqe2WpTogMSlcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbiArIHRoaXMub2Zmc2V0O1xuICAgICAgdmFyIGFsaWduUG9zaXRpb24gPSB0aGlzLl9hbGlnblBvcztcbiAgICAgIHZhciBjYW1lcmEgPSB0aGlzLl9mbGlja2luZy5jYW1lcmE7XG4gICAgICB2YXIgY2FtUG9zID0gY2FtZXJhLnBvc2l0aW9uO1xuICAgICAgaWYgKGNhbVBvcyA9PT0gcG9zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICBpZiAoY2FtUG9zIDwgcG9zaXRpb24pIHtcbiAgICAgICAgdmFyIGRpc2FwcGVhclBvc05leHQgPSBwb3NpdGlvbiArIChjYW1lcmEuc2l6ZSAtIGNhbWVyYS5hbGlnblBvc2l0aW9uKSArIGFsaWduUG9zaXRpb247XG4gICAgICAgIHJldHVybiAtZ2V0UHJvZ3Jlc3MoY2FtUG9zLCBwb3NpdGlvbiwgZGlzYXBwZWFyUG9zTmV4dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZGlzYXBwZWFyUG9zUHJldiA9IHBvc2l0aW9uIC0gKGNhbWVyYS5hbGlnblBvc2l0aW9uICsgdGhpcy5fc2l6ZSAtIGFsaWduUG9zaXRpb24pO1xuICAgICAgICByZXR1cm4gMSAtIGdldFByb2dyZXNzKGNhbVBvcywgZGlzYXBwZWFyUG9zUHJldiwgcG9zaXRpb24pO1xuICAgICAgfVxuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJ2aXNpYmxlUmF0aW9cIiwge1xuICAgIC8qKlxyXG4gICAgICogUGVyY2VudGFnZSBvZiBhcmVhIHdoZXJlIHBhbmVsIGlzIHZpc2libGUgaW4gdGhlIHZpZXdwb3J0XHJcbiAgICAgKiBAa28g67ew7Y+s7Yq4IOyViOyXkOyEnCDtjKjrhJDsnbQg67O07J2064qUIOyYgeyXreydmCDruYTsnKhcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHJhbmdlID0gdGhpcy5yYW5nZTtcbiAgICAgIHZhciBzaXplID0gdGhpcy5fc2l6ZTtcbiAgICAgIHZhciBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgIHZhciB2aXNpYmxlUmFuZ2UgPSB0aGlzLl9mbGlja2luZy5jYW1lcmEudmlzaWJsZVJhbmdlO1xuICAgICAgdmFyIGNoZWNraW5nUmFuZ2UgPSB7XG4gICAgICAgIG1pbjogcmFuZ2UubWluICsgb2Zmc2V0LFxuICAgICAgICBtYXg6IHJhbmdlLm1heCArIG9mZnNldFxuICAgICAgfTtcbiAgICAgIGlmIChjaGVja2luZ1JhbmdlLm1heCA8PSB2aXNpYmxlUmFuZ2UubWluIHx8IGNoZWNraW5nUmFuZ2UubWluID49IHZpc2libGVSYW5nZS5tYXgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICB2YXIgdmlzaWJsZVNpemUgPSBzaXplO1xuICAgICAgaWYgKHZpc2libGVSYW5nZS5taW4gPiBjaGVja2luZ1JhbmdlLm1pbikge1xuICAgICAgICB2aXNpYmxlU2l6ZSAtPSB2aXNpYmxlUmFuZ2UubWluIC0gY2hlY2tpbmdSYW5nZS5taW47XG4gICAgICB9XG4gICAgICBpZiAodmlzaWJsZVJhbmdlLm1heCA8IGNoZWNraW5nUmFuZ2UubWF4KSB7XG4gICAgICAgIHZpc2libGVTaXplIC09IGNoZWNraW5nUmFuZ2UubWF4IC0gdmlzaWJsZVJhbmdlLm1heDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2aXNpYmxlU2l6ZSAvIHNpemU7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcImFsaWduXCIsIHtcbiAgICAvLyBPcHRpb25zIEdldHRlclxuICAgIC8qKlxyXG4gICAgICogQSB2YWx1ZSBpbmRpY2F0aW5nIHdoZXJlIHRoZSB7QGxpbmsgUGFuZWwjYWxpZ25Qb3NpdGlvbiBhbGlnblBvc2l0aW9ufSBzaG91bGQgYmUgbG9jYXRlZCBhdCBpbnNpZGUgdGhlIHBhbmVsIGVsZW1lbnRcclxuICAgICAqIEBrbyB7QGxpbmsgUGFuZWwjYWxpZ25Qb3NpdGlvbiBhbGlnblBvc2l0aW9ufeydtCDtjKjrhJAg64K07J2YIOyWtOuUlOyXkCDsnITsuZjtlbTslbwg7ZWY64qU7KeA66W8IOuCmO2DgOuCtOuKlCDqsJJcclxuICAgICAqIEB0eXBlIHtDb25zdGFudHMuQUxJR04gfCBzdHJpbmcgfCBudW1iZXJ9XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9hbGlnbjtcbiAgICB9LFxuICAgIC8vIE9wdGlvbnMgU2V0dGVyXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICB0aGlzLl9hbGlnbiA9IHZhbDtcbiAgICAgIHRoaXMuX3VwZGF0ZUFsaWduUG9zKCk7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIC8qKlxyXG4gICAqIE1hcmsgcGFuZWwgZWxlbWVudCB0byBiZSBhcHBlbmRlZCBvbiB0aGUgY2FtZXJhIGVsZW1lbnRcclxuICAgKiBAaW50ZXJuYWxcclxuICAgKi9cbiAgX19wcm90by5tYXJrRm9yU2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9yZW5kZXJlZCA9IHRydWU7XG4gICAgdGhpcy5fZWxQcm92aWRlci5zaG93KHRoaXMuX2ZsaWNraW5nKTtcbiAgfTtcbiAgLyoqXHJcbiAgICogTWFyayBwYW5lbCBlbGVtZW50IHRvIGJlIHJlbW92ZWQgZnJvbSB0aGUgY2FtZXJhIGVsZW1lbnRcclxuICAgKiBAaW50ZXJuYWxcclxuICAgKi9cbiAgX19wcm90by5tYXJrRm9ySGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9yZW5kZXJlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2VsUHJvdmlkZXIuaGlkZSh0aGlzLl9mbGlja2luZyk7XG4gIH07XG4gIC8qKlxyXG4gICAqIFVwZGF0ZSBzaXplIG9mIHRoZSBwYW5lbFxyXG4gICAqIEBrbyDtjKjrhJDsnZgg7YGs6riw66W8IOqwseyLoO2VqeuLiOuLpFxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjYWNoZWQgUHJlZGVmaW5lZCBjYWNoZWQgc2l6ZSBvZiB0aGUgcGFuZWw8a28+7IKs7KCE7JeQIOy6kOyLnOuQnCDtjKjrhJDsnZgg7YGs6riwIOygleuztDwva28+XHJcbiAgICogQGNoYWluYWJsZVxyXG4gICAqIEByZXR1cm4ge3RoaXN9XHJcbiAgICovXG4gIF9fcHJvdG8ucmVzaXplID0gZnVuY3Rpb24gKGNhY2hlZCkge1xuICAgIHZhciBfYTtcbiAgICB2YXIgZWwgPSB0aGlzLmVsZW1lbnQ7XG4gICAgdmFyIGZsaWNraW5nID0gdGhpcy5fZmxpY2tpbmc7XG4gICAgdmFyIGhvcml6b250YWwgPSBmbGlja2luZy5ob3Jpem9udGFsLFxuICAgICAgdXNlRnJhY3Rpb25hbFNpemUgPSBmbGlja2luZy51c2VGcmFjdGlvbmFsU2l6ZTtcbiAgICBpZiAoY2FjaGVkKSB7XG4gICAgICB0aGlzLl9zaXplID0gY2FjaGVkLnNpemU7XG4gICAgICB0aGlzLl9tYXJnaW4gPSBfX2Fzc2lnbiQyKHt9LCBjYWNoZWQubWFyZ2luKTtcbiAgICAgIHRoaXMuX2hlaWdodCA9IChfYSA9IGNhY2hlZC5oZWlnaHQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGdldEVsZW1lbnRTaXplKHtcbiAgICAgICAgZWw6IGVsLFxuICAgICAgICBob3Jpem9udGFsOiBmYWxzZSxcbiAgICAgICAgdXNlRnJhY3Rpb25hbFNpemU6IHVzZUZyYWN0aW9uYWxTaXplLFxuICAgICAgICB1c2VPZmZzZXQ6IHRydWUsXG4gICAgICAgIHN0eWxlOiBnZXRTdHlsZShlbClcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZWxTdHlsZSA9IGdldFN0eWxlKGVsKTtcbiAgICAgIHRoaXMuX3NpemUgPSBnZXRFbGVtZW50U2l6ZSh7XG4gICAgICAgIGVsOiBlbCxcbiAgICAgICAgaG9yaXpvbnRhbDogaG9yaXpvbnRhbCxcbiAgICAgICAgdXNlRnJhY3Rpb25hbFNpemU6IHVzZUZyYWN0aW9uYWxTaXplLFxuICAgICAgICB1c2VPZmZzZXQ6IHRydWUsXG4gICAgICAgIHN0eWxlOiBlbFN0eWxlXG4gICAgICB9KTtcbiAgICAgIHRoaXMuX21hcmdpbiA9IGhvcml6b250YWwgPyB7XG4gICAgICAgIHByZXY6IHBhcnNlRmxvYXQoZWxTdHlsZS5tYXJnaW5MZWZ0IHx8IFwiMFwiKSxcbiAgICAgICAgbmV4dDogcGFyc2VGbG9hdChlbFN0eWxlLm1hcmdpblJpZ2h0IHx8IFwiMFwiKVxuICAgICAgfSA6IHtcbiAgICAgICAgcHJldjogcGFyc2VGbG9hdChlbFN0eWxlLm1hcmdpblRvcCB8fCBcIjBcIiksXG4gICAgICAgIG5leHQ6IHBhcnNlRmxvYXQoZWxTdHlsZS5tYXJnaW5Cb3R0b20gfHwgXCIwXCIpXG4gICAgICB9O1xuICAgICAgdGhpcy5faGVpZ2h0ID0gaG9yaXpvbnRhbCA/IGdldEVsZW1lbnRTaXplKHtcbiAgICAgICAgZWw6IGVsLFxuICAgICAgICBob3Jpem9udGFsOiBmYWxzZSxcbiAgICAgICAgdXNlRnJhY3Rpb25hbFNpemU6IHVzZUZyYWN0aW9uYWxTaXplLFxuICAgICAgICB1c2VPZmZzZXQ6IHRydWUsXG4gICAgICAgIHN0eWxlOiBlbFN0eWxlXG4gICAgICB9KSA6IHRoaXMuX3NpemU7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlUG9zaXRpb24oKTtcbiAgICB0aGlzLl91cGRhdGVBbGlnblBvcygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcclxuICAgKiBDaGFuZ2UgcGFuZWwncyBzaXplLiBUaGlzIHdpbGwgY2hhbmdlIHRoZSBhY3R1YWwgc2l6ZSBvZiB0aGUgcGFuZWwgZWxlbWVudCBieSBjaGFuZ2luZyBpdHMgQ1NTIHdpZHRoL2hlaWdodCBwcm9wZXJ0eVxyXG4gICAqIEBrbyDtjKjrhJAg7YGs6riw66W8IOuzgOqyve2VqeuLiOuLpC4g7Yyo64SQIOyXmOumrOuovO2KuOyXkCDtlbTri7kg7YGs6riw7J2YIENTUyB3aWR0aC9oZWlnaHTrpbwg7KCB7Jqp7ZWp64uI64ukXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IFtzaXplXSBOZXcgcGFuZWwgc2l6ZTxrbz7sg4gg7Yyo64SQIO2BrOq4sDwva28+XHJcbiAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbc2l6ZS53aWR0aF0gQ1NTIHN0cmluZyBvciBudW1iZXIoaW4gcHgpPGtvPkNTUyDrrLjsnpDsl7Qg65iQ64qUIOyIq+yekChweCk8L2tvPlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW3NpemUuaGVpZ2h0XSBDU1Mgc3RyaW5nIG9yIG51bWJlcihpbiBweCk8a28+Q1NTIOusuOyekOyXtCDrmJDripQg7Iir7J6QKHB4KTwva28+XHJcbiAgICogQGNoYWluYWJsZVxyXG4gICAqIEByZXR1cm4ge3RoaXN9XHJcbiAgICovXG4gIF9fcHJvdG8uc2V0U2l6ZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gICAgc2V0U2l6ZSh0aGlzLmVsZW1lbnQsIHNpemUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcclxuICAgKiBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiBlbGVtZW50IGlzIGluc2lkZSBvZiB0aGlzIHBhbmVsJ3Mge0BsaW5rIFBhbmVsI2VsZW1lbnQgZWxlbWVudH1cclxuICAgKiBAa28g7ZW064u5IOyXmOumrOuovO2KuOqwgCDsnbQg7Yyo64SQ7J2YIHtAbGluayBQYW5lbCNlbGVtZW50IGVsZW1lbnR9IOuCtOyXkCDtj6ztlajrkJjslrQg7J6I64qU7KeA66W8IOuwmO2ZmO2VqeuLiOuLpFxyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgVGhlIEhUTUxFbGVtZW50IHRvIGNoZWNrPGtvPu2ZleyduO2VmOqzoOyekCDtlZjripQgSFRNTEVsZW1lbnQ8L2tvPlxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IEEgQm9vbGVhbiB2YWx1ZSBpbmRpY2F0aW5nIHRoZSBlbGVtZW50IGlzIGluc2lkZSBvZiB0aGlzIHBhbmVsIHtAbGluayBQYW5lbCNlbGVtZW50IGVsZW1lbnR9PGtvPu2MqOuEkOydmCB7QGxpbmsgUGFuZWwjZWxlbWVudCBlbGVtZW50feuCtOyXkCDtlbTri7kg7JeY66as66i87Yq4IO2PrO2VqCDsl6zrtoA8L2tvPlxyXG4gICAqL1xuICBfX3Byb3RvLmNvbnRhaW5zID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuICEhKChfYSA9IHRoaXMuZWxlbWVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbnRhaW5zKGVsZW1lbnQpKTtcbiAgfTtcbiAgLyoqXHJcbiAgICogUmVzZXQgaW50ZXJuYWwgc3RhdGUgYW5kIHNldCB7QGxpbmsgUGFuZWwjcmVtb3ZlZCByZW1vdmVkfSB0byBgdHJ1ZWBcclxuICAgKiBAa28g64K067aAIOyDge2DnOulvCDstIjquLDtmZTtlZjqs6Age0BsaW5rIFBhbmVsI3JlbW92ZWQgcmVtb3ZlZH3rpbwgYHRydWVg66GcIOyEpOygle2VqeuLiOuLpC5cclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xuICBfX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fcmVzZXRJbnRlcm5hbFN0YXRlcygpO1xuICAgIHRoaXMuX3JlbW92ZWQgPSB0cnVlO1xuICB9O1xuICAvKipcclxuICAgKiBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiBwb3NpdGlvbiBpcyBpbnNpZGUgb2YgdGhpcyBwYW5lbCdzIHtAbGluayBQYW5lbCNyYW5nZSByYW5nZX1cclxuICAgKiBAa28g7KO87Ja07KeEIOyijO2RnOqwgCDtmITsnqwg7Yyo64SQ7J2YIHtAbGluayBQYW5lbCNyYW5nZSByYW5nZX3rgrTsl5Ag7IaN7ZW07J6I64qU7KeA66W8IOuwmO2ZmO2VqeuLiOuLpC5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gcG9zIEEgcG9zaXRpb24gdG8gY2hlY2s8a28+7ZmV7J247ZWY6rOg7J6QIO2VmOuKlCDsooztkZw8L2tvPlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luY2x1ZGVNYXJnaW49ZmFsc2VdIEluY2x1ZGUge0BsaW5rIFBhbmVsI21hcmdpbiBtYXJnaW59IHRvIHRoZSByYW5nZTxrbz7tjKjrhJAg7JiB7Jet7JeQIHtAbGluayBQYW5lbCNtYXJnaW4gbWFyZ2lufeqwkuydhCDtj6ztlajsi5ztgrXri4jri6Q8L2tvPlxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IEEgQm9vbGVhbiB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGdpdmVuIHBvc2l0aW9uIGlzIGluY2x1ZGVkIGluIHRoZSBwYW5lbCByYW5nZTxrbz7tlbTri7kg7KKM7ZGc6rCAIO2MqOuEkCDsmIHsl60g64K07JeQIOyGje2VtOyeiOuKlOyngCDsl6zrtoA8L2tvPlxyXG4gICAqL1xuICBfX3Byb3RvLmluY2x1ZGVQb3NpdGlvbiA9IGZ1bmN0aW9uIChwb3MsIGluY2x1ZGVNYXJnaW4pIHtcbiAgICBpZiAoaW5jbHVkZU1hcmdpbiA9PT0gdm9pZCAwKSB7XG4gICAgICBpbmNsdWRlTWFyZ2luID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmluY2x1ZGVSYW5nZShwb3MsIHBvcywgaW5jbHVkZU1hcmdpbik7XG4gIH07XG4gIC8qKlxyXG4gICAqIENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHJhbmdlIGlzIGZ1bGx5IGluY2x1ZGVkIGluIHRoaXMgcGFuZWwncyBhcmVhIChpbmNsdXNpdmUpXHJcbiAgICogQGtvIOyjvOyWtOynhCDrspTsnITqsIAg7J20IO2MqOuEkCDrgrTrtoDsl5Ag7JmE7KCE7Z6IIO2PrO2VqOuQmOuKlOyngOulvCDrsJjtmZjtlanri4jri6RcclxuICAgKiBAcGFyYW0ge251bWJlcn0gbWluIE1pbmltdW0gdmFsdWUgb2YgdGhlIHJhbmdlIHRvIGNoZWNrPGtvPu2ZleyduO2VmOqzoOyekCDtlZjripQg7LWc7IaMIOuylOychDwva28+XHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG1heCBNYXhpbXVtIHZhbHVlIG9mIHRoZSByYW5nZSB0byBjaGVjazxrbz7tmZXsnbjtlZjqs6DsnpAg7ZWY64qUIOy1nOuMgCDrspTsnIQ8L2tvPlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luY2x1ZGVNYXJnaW49ZmFsc2VdIEluY2x1ZGUge0BsaW5rIFBhbmVsI21hcmdpbiBtYXJnaW59IHRvIHRoZSByYW5nZTxrbz7tjKjrhJAg7JiB7Jet7JeQIHtAbGluayBQYW5lbCNtYXJnaW4gbWFyZ2lufeqwkuydhCDtj6ztlajsi5ztgrXri4jri6Q8L2tvPlxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBBIEJvb2xlYW4gdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBnaXZlbiByYW5nZSBpcyBmdWxseSBpbmNsdWRlZCBpbiB0aGUgcGFuZWwgcmFuZ2U8a28+7ZW064u5IOuylOychOqwgCDtjKjrhJAg7JiB7JetIOuCtOyXkCDsmYTsoITtnogg7IaN7ZW07J6I64qU7KeAIOyXrOu2gDwva28+XHJcbiAgICovXG4gIF9fcHJvdG8uaW5jbHVkZVJhbmdlID0gZnVuY3Rpb24gKG1pbiwgbWF4LCBpbmNsdWRlTWFyZ2luKSB7XG4gICAgaWYgKGluY2x1ZGVNYXJnaW4gPT09IHZvaWQgMCkge1xuICAgICAgaW5jbHVkZU1hcmdpbiA9IGZhbHNlO1xuICAgIH1cbiAgICB2YXIgbWFyZ2luID0gdGhpcy5fbWFyZ2luO1xuICAgIHZhciBwYW5lbFJhbmdlID0gdGhpcy5yYW5nZTtcbiAgICBpZiAoaW5jbHVkZU1hcmdpbikge1xuICAgICAgcGFuZWxSYW5nZS5taW4gLT0gbWFyZ2luLnByZXY7XG4gICAgICBwYW5lbFJhbmdlLm1heCArPSBtYXJnaW4ubmV4dDtcbiAgICB9XG4gICAgcmV0dXJuIG1heCA+PSBwYW5lbFJhbmdlLm1pbiAmJiBtaW4gPD0gcGFuZWxSYW5nZS5tYXg7XG4gIH07XG4gIC8qKlxyXG4gICAqIENoZWNrIHdoZXRoZXIgdGhlIHBhbmVsIGlzIHZpc2JsZSBpbiB0aGUgZ2l2ZW4gcmFuZ2UgKGV4Y2x1c2l2ZSlcclxuICAgKiBAa28g7KO87Ja07KeEIOuylOychCDrgrTsl5DshJwg7J20IO2MqOuEkOydmCDsnbzrtoDqsIAg67O07Jes7KeA64qU7KeA66W8IOuwmO2ZmO2VqeuLiOuLpFxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gTWluaW11bSB2YWx1ZSBvZiB0aGUgcmFuZ2UgdG8gY2hlY2s8a28+7ZmV7J247ZWY6rOg7J6QIO2VmOuKlCDstZzshowg67KU7JyEPC9rbz5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gbWF4IE1heGltdW0gdmFsdWUgb2YgdGhlIHJhbmdlIHRvIGNoZWNrPGtvPu2ZleyduO2VmOqzoOyekCDtlZjripQg7LWc64yAIOuylOychDwva28+XHJcbiAgICogQHJldHVybnMge2Jvb2xlYW59IEEgQm9vbGVhbiB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIHBhbmVsIGlzIHZpc2libGU8a28+7ZW064u5IOuylOychCDrgrTsl5DshJwg7Yyo64SQ7J2EIOuzvCDsiJgg7J6I64qU7KeAIOyXrOu2gDwva28+XHJcbiAgICovXG4gIF9fcHJvdG8uaXNWaXNpYmxlT25SYW5nZSA9IGZ1bmN0aW9uIChtaW4sIG1heCkge1xuICAgIHZhciBwYW5lbFJhbmdlID0gdGhpcy5yYW5nZTtcbiAgICByZXR1cm4gbWF4ID4gcGFuZWxSYW5nZS5taW4gJiYgbWluIDwgcGFuZWxSYW5nZS5tYXg7XG4gIH07XG4gIC8qKlxyXG4gICAqIE1vdmUge0BsaW5rIENhbWVyYX0gdG8gdGhpcyBwYW5lbFxyXG4gICAqIEBrbyB7QGxpbmsgQ2FtZXJhfeulvCDsnbQg7Yyo64SQ66GcIOydtOuPme2VqeuLiOuLpFxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZHVyYXRpb25dIER1cmF0aW9uIG9mIHRoZSBhbmltYXRpb24gKHVuaXQ6IG1zKTxrbz7slaDri4jrqZTsnbTshZgg7KeE7ZaJIOyLnOqwhCAo64uo7JyEOiBtcyk8L2tvPlxyXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fSBBIFByb21pc2Ugd2hpY2ggd2lsbCBiZSByZXNvbHZlZCBhZnRlciByZWFjaGluZyB0aGUgcGFuZWw8a28+7Yyo64SQIOuPhOuLrOyLnOyXkCByZXNvbHZl65CY64qUIFByb21pc2U8L2tvPlxyXG4gICAqL1xuICBfX3Byb3RvLmZvY3VzID0gZnVuY3Rpb24gKGR1cmF0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZsaWNraW5nLm1vdmVUbyh0aGlzLl9pbmRleCwgZHVyYXRpb24pO1xuICB9O1xuICAvKipcclxuICAgKiBHZXQgcHJldmlvdXMoYGluZGV4IC0gMWApIHBhbmVsLiBXaGVuIHRoZSBwcmV2aW91cyBwYW5lbCBkb2VzIG5vdCBleGlzdCwgdGhpcyB3aWxsIHJldHVybiBgbnVsbGAgaW5zdGVhZFxyXG4gICAqIElmIHRoZSB7QGxpbmsgRmxpY2tpbmcjY2lyY3VsYXJFbmFibGVkIGNpcmN1bGFyfSBpcyBlbmFibGVkLCB0aGlzIHdpbGwgcmV0dXJuIHRoZSBsYXN0IHBhbmVsIGlmIGNhbGxlZCBmcm9tIHRoZSBmaXJzdCBwYW5lbFxyXG4gICAqIEBrbyDsnbTsoIQoYGluZGV4IC0gMWApIO2MqOuEkOydhCDrsJjtmZjtlanri4jri6QuIOydtOyghCDtjKjrhJDsnbQg7JeG7J2EIOqyveyasCBgbnVsbGDsnYQg67CY7ZmY7ZWp64uI64ukXHJcbiAgICoge0BsaW5rIEZsaWNraW5nI2NpcmN1bGFyRW5hYmxlZCBjaXJjdWxhcn0g66qo65Oc6rCAIO2ZnOyEse2ZlOuQmOyXiOydhCDrlYwg7LKr67KI7Ke4IO2MqOuEkOyXkOyEnCDsnbQg66mU7IaM65Oc66W8IO2YuOy2nO2VoCDqsr3smrAg66eI7KeA66eJIO2MqOuEkOydhCDrsJjtmZjtlanri4jri6RcclxuICAgKiBAcmV0dXJucyB7UGFuZWwgfCBudWxsfSBUaGUgcHJldmlvdXMgcGFuZWw8a28+7J207KCEIO2MqOuEkDwva28+XHJcbiAgICovXG4gIF9fcHJvdG8ucHJldiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLl9pbmRleDtcbiAgICB2YXIgZmxpY2tpbmcgPSB0aGlzLl9mbGlja2luZztcbiAgICB2YXIgcmVuZGVyZXIgPSBmbGlja2luZy5yZW5kZXJlcjtcbiAgICB2YXIgcGFuZWxDb3VudCA9IHJlbmRlcmVyLnBhbmVsQ291bnQ7XG4gICAgaWYgKHBhbmVsQ291bnQgPT09IDEpIHJldHVybiBudWxsO1xuICAgIHJldHVybiBmbGlja2luZy5jaXJjdWxhckVuYWJsZWQgPyByZW5kZXJlci5nZXRQYW5lbChpbmRleCA9PT0gMCA/IHBhbmVsQ291bnQgLSAxIDogaW5kZXggLSAxKSA6IHJlbmRlcmVyLmdldFBhbmVsKGluZGV4IC0gMSk7XG4gIH07XG4gIC8qKlxyXG4gICAqIEdldCBuZXh0KGBpbmRleCArIDFgKSBwYW5lbC4gV2hlbiB0aGUgbmV4dCBwYW5lbCBkb2VzIG5vdCBleGlzdCwgdGhpcyB3aWxsIHJldHVybiBgbnVsbGAgaW5zdGVhZFxyXG4gICAqIElmIHRoZSB7QGxpbmsgRmxpY2tpbmcjY2lyY3VsYXJFbmFibGVkIGNpcmN1bGFyfSBpcyBlbmFibGVkLCB0aGlzIHdpbGwgcmV0dXJuIHRoZSBmaXJzdCBwYW5lbCBpZiBjYWxsZWQgZnJvbSB0aGUgbGFzdCBwYW5lbFxyXG4gICAqIEBrbyDri6TsnYwoYGluZGV4ICsgMWApIO2MqOuEkOydhCDrsJjtmZjtlanri4jri6QuIOuLpOydjCDtjKjrhJDsnbQg7JeG7J2EIOqyveyasCBgbnVsbGDsnYQg67CY7ZmY7ZWp64uI64ukXHJcbiAgICoge0BsaW5rIEZsaWNraW5nI2NpcmN1bGFyRW5hYmxlZCBjaXJjdWxhcn0g66qo65Oc6rCAIO2ZnOyEse2ZlOuQmOyXiOydhCDrlYwg66eI7KeA66eJIO2MqOuEkOyXkOyEnCDsnbQg66mU7IaM65Oc66W8IO2YuOy2nO2VoCDqsr3smrAg7LKr67KI7Ke4IO2MqOuEkOydhCDrsJjtmZjtlanri4jri6RcclxuICAgKiBAcmV0dXJucyB7UGFuZWwgfCBudWxsfSBUaGUgcHJldmlvdXMgcGFuZWw8a28+64uk7J2MIO2MqOuEkDwva28+XHJcbiAgICovXG4gIF9fcHJvdG8ubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLl9pbmRleDtcbiAgICB2YXIgZmxpY2tpbmcgPSB0aGlzLl9mbGlja2luZztcbiAgICB2YXIgcmVuZGVyZXIgPSBmbGlja2luZy5yZW5kZXJlcjtcbiAgICB2YXIgcGFuZWxDb3VudCA9IHJlbmRlcmVyLnBhbmVsQ291bnQ7XG4gICAgaWYgKHBhbmVsQ291bnQgPT09IDEpIHJldHVybiBudWxsO1xuICAgIHJldHVybiBmbGlja2luZy5jaXJjdWxhckVuYWJsZWQgPyByZW5kZXJlci5nZXRQYW5lbChpbmRleCA9PT0gcGFuZWxDb3VudCAtIDEgPyAwIDogaW5kZXggKyAxKSA6IHJlbmRlcmVyLmdldFBhbmVsKGluZGV4ICsgMSk7XG4gIH07XG4gIC8qKlxyXG4gICAqIEluY3JlYXNlIHBhbmVsJ3MgaW5kZXggYnkgdGhlIGdpdmVuIHZhbHVlXHJcbiAgICogQGtvIO2MqOuEkOydmCDsnbjrjbHsiqTrpbwg7KO87Ja07KeEIOqwkuunjO2BvCDspp3qsIDsi5ztgrXri4jri6RcclxuICAgKiBAaW50ZXJuYWxcclxuICAgKiBAY2hhaW5hYmxlXHJcbiAgICogQHBhcmFtIHZhbCBBbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAwPGtvPjDrs7Tri6Qg6rCZ6rGw64KYIO2BsCDsoJXsiJg8L2tvPlxyXG4gICAqIEByZXR1cm5zIHt0aGlzfVxyXG4gICAqL1xuICBfX3Byb3RvLmluY3JlYXNlSW5kZXggPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgdGhpcy5faW5kZXggKz0gTWF0aC5tYXgodmFsLCAwKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXHJcbiAgICogRGVjcmVhc2UgcGFuZWwncyBpbmRleCBieSB0aGUgZ2l2ZW4gdmFsdWVcclxuICAgKiBAa28g7Yyo64SQ7J2YIOyduOuNseyKpOulvCDso7zslrTsp4Qg6rCS66eM7YG8IOqwkOyGjOyLnO2CteuLiOuLpFxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqIEBjaGFpbmFibGVcclxuICAgKiBAcGFyYW0gdmFsIEFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDA8a28+MOuztOuLpCDqsJnqsbDrgpgg7YGwIOygleyImDwva28+XHJcbiAgICogQHJldHVybnMge3RoaXN9XHJcbiAgICovXG4gIF9fcHJvdG8uZGVjcmVhc2VJbmRleCA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICB0aGlzLl9pbmRleCAtPSBNYXRoLm1heCh2YWwsIDApO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcclxuICAgKiBAaW50ZXJuYWxcclxuICAgKi9cbiAgX19wcm90by51cGRhdGVQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJldlBhbmVsID0gdGhpcy5fZmxpY2tpbmcucmVuZGVyZXIucGFuZWxzW3RoaXMuX2luZGV4IC0gMV07XG4gICAgdGhpcy5fcG9zID0gcHJldlBhbmVsID8gcHJldlBhbmVsLnJhbmdlLm1heCArIHByZXZQYW5lbC5tYXJnaW4ubmV4dCArIHRoaXMuX21hcmdpbi5wcmV2IDogdGhpcy5fbWFyZ2luLnByZXY7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IHRvZ2dsZWRcclxuICAgKi9cbiAgX19wcm90by50b2dnbGUgPSBmdW5jdGlvbiAocHJldlBvcywgbmV3UG9zKSB7XG4gICAgdmFyIHRvZ2dsZURpcmVjdGlvbiA9IHRoaXMuX3RvZ2dsZURpcmVjdGlvbjtcbiAgICB2YXIgdG9nZ2xlUG9zaXRpb24gPSB0aGlzLl90b2dnbGVQb3NpdGlvbjtcbiAgICBpZiAodG9nZ2xlRGlyZWN0aW9uID09PSBESVJFQ1RJT04uTk9ORSB8fCBuZXdQb3MgPT09IHByZXZQb3MpIHJldHVybiBmYWxzZTtcbiAgICB2YXIgcHJldlRvZ2dsZWQgPSB0aGlzLl90b2dnbGVkO1xuICAgIGlmIChuZXdQb3MgPiBwcmV2UG9zKSB7XG4gICAgICBpZiAodG9nZ2xlUG9zaXRpb24gPj0gcHJldlBvcyAmJiB0b2dnbGVQb3NpdGlvbiA8PSBuZXdQb3MpIHtcbiAgICAgICAgdGhpcy5fdG9nZ2xlZCA9IHRvZ2dsZURpcmVjdGlvbiA9PT0gRElSRUNUSU9OLk5FWFQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0b2dnbGVQb3NpdGlvbiA8PSBwcmV2UG9zICYmIHRvZ2dsZVBvc2l0aW9uID49IG5ld1Bvcykge1xuICAgICAgICB0aGlzLl90b2dnbGVkID0gdG9nZ2xlRGlyZWN0aW9uICE9PSBESVJFQ1RJT04uTkVYVDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHByZXZUb2dnbGVkICE9PSB0aGlzLl90b2dnbGVkO1xuICB9O1xuICAvKipcclxuICAgKiBAaW50ZXJuYWxcclxuICAgKi9cbiAgX19wcm90by51cGRhdGVDaXJjdWxhclRvZ2dsZURpcmVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZmxpY2tpbmcgPSB0aGlzLl9mbGlja2luZztcbiAgICBpZiAoIWZsaWNraW5nLmNpcmN1bGFyRW5hYmxlZCkge1xuICAgICAgdGhpcy5fdG9nZ2xlRGlyZWN0aW9uID0gRElSRUNUSU9OLk5PTkU7XG4gICAgICB0aGlzLl90b2dnbGVQb3NpdGlvbiA9IDA7XG4gICAgICB0aGlzLl90b2dnbGVkID0gZmFsc2U7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdmFyIGNhbWVyYSA9IGZsaWNraW5nLmNhbWVyYTtcbiAgICB2YXIgY2FtUmFuZ2UgPSBjYW1lcmEucmFuZ2U7XG4gICAgdmFyIGNhbUFsaWduUG9zaXRpb24gPSBjYW1lcmEuYWxpZ25Qb3NpdGlvbjtcbiAgICB2YXIgY2FtVmlzaWJsZVJhbmdlID0gY2FtZXJhLnZpc2libGVSYW5nZTtcbiAgICB2YXIgY2FtVmlzaWJsZVNpemUgPSBjYW1WaXNpYmxlUmFuZ2UubWF4IC0gY2FtVmlzaWJsZVJhbmdlLm1pbjtcbiAgICB2YXIgbWluaW11bVZpc2libGUgPSBjYW1SYW5nZS5taW4gLSBjYW1BbGlnblBvc2l0aW9uO1xuICAgIHZhciBtYXhpbXVtVmlzaWJsZSA9IGNhbVJhbmdlLm1heCAtIGNhbUFsaWduUG9zaXRpb24gKyBjYW1WaXNpYmxlU2l6ZTtcbiAgICB2YXIgc2hvdWxkQmVWaXNpYmxlQXRNaW4gPSB0aGlzLmluY2x1ZGVSYW5nZShtYXhpbXVtVmlzaWJsZSAtIGNhbVZpc2libGVTaXplLCBtYXhpbXVtVmlzaWJsZSwgZmFsc2UpO1xuICAgIHZhciBzaG91bGRCZVZpc2libGVBdE1heCA9IHRoaXMuaW5jbHVkZVJhbmdlKG1pbmltdW1WaXNpYmxlLCBtaW5pbXVtVmlzaWJsZSArIGNhbVZpc2libGVTaXplLCBmYWxzZSk7XG4gICAgdGhpcy5fdG9nZ2xlZCA9IGZhbHNlO1xuICAgIGlmIChzaG91bGRCZVZpc2libGVBdE1pbikge1xuICAgICAgdGhpcy5fdG9nZ2xlRGlyZWN0aW9uID0gRElSRUNUSU9OLlBSRVY7XG4gICAgICB0aGlzLl90b2dnbGVQb3NpdGlvbiA9IHRoaXMucmFuZ2UubWF4ICsgY2FtUmFuZ2UubWluIC0gY2FtUmFuZ2UubWF4ICsgY2FtQWxpZ25Qb3NpdGlvbjtcbiAgICAgIHRoaXMudG9nZ2xlKEluZmluaXR5LCBjYW1lcmEucG9zaXRpb24pO1xuICAgIH0gZWxzZSBpZiAoc2hvdWxkQmVWaXNpYmxlQXRNYXgpIHtcbiAgICAgIHRoaXMuX3RvZ2dsZURpcmVjdGlvbiA9IERJUkVDVElPTi5ORVhUO1xuICAgICAgdGhpcy5fdG9nZ2xlUG9zaXRpb24gPSB0aGlzLnJhbmdlLm1pbiArIGNhbVJhbmdlLm1heCAtIGNhbVZpc2libGVTaXplICsgY2FtQWxpZ25Qb3NpdGlvbjtcbiAgICAgIHRoaXMudG9nZ2xlKC1JbmZpbml0eSwgY2FtZXJhLnBvc2l0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fdG9nZ2xlRGlyZWN0aW9uID0gRElSRUNUSU9OLk5PTkU7XG4gICAgICB0aGlzLl90b2dnbGVQb3NpdGlvbiA9IDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBfX3Byb3RvLl91cGRhdGVBbGlnblBvcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9hbGlnblBvcyA9IHBhcnNlQWxpZ24kMSh0aGlzLl9hbGlnbiwgdGhpcy5fc2l6ZSk7XG4gIH07XG4gIF9fcHJvdG8uX3Jlc2V0SW50ZXJuYWxTdGF0ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fc2l6ZSA9IDA7XG4gICAgdGhpcy5fcG9zID0gMDtcbiAgICB0aGlzLl9tYXJnaW4gPSB7XG4gICAgICBwcmV2OiAwLFxuICAgICAgbmV4dDogMFxuICAgIH07XG4gICAgdGhpcy5faGVpZ2h0ID0gMDtcbiAgICB0aGlzLl9hbGlnblBvcyA9IDA7XG4gICAgdGhpcy5fdG9nZ2xlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3RvZ2dsZVBvc2l0aW9uID0gMDtcbiAgICB0aGlzLl90b2dnbGVEaXJlY3Rpb24gPSBESVJFQ1RJT04uTk9ORTtcbiAgfTtcbiAgcmV0dXJuIFBhbmVsO1xufSgpO1xuXG52YXIgTm9ybWFsUmVuZGVyaW5nU3RyYXRlZ3kgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBOb3JtYWxSZW5kZXJpbmdTdHJhdGVneShfYSkge1xuICAgIHZhciBwcm92aWRlckN0b3IgPSBfYS5wcm92aWRlckN0b3I7XG4gICAgdGhpcy5fcHJvdmlkZXJDdG9yID0gcHJvdmlkZXJDdG9yO1xuICB9XG4gIHZhciBfX3Byb3RvID0gTm9ybWFsUmVuZGVyaW5nU3RyYXRlZ3kucHJvdG90eXBlO1xuICBfX3Byb3RvLnJlbmRlclBhbmVscyA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBET19OT1RISU5HXG4gIH07XG4gIF9fcHJvdG8uZ2V0UmVuZGVyaW5nSW5kZXhlc0J5T3JkZXIgPSBmdW5jdGlvbiAoZmxpY2tpbmcpIHtcbiAgICB2YXIgcmVuZGVyZWRQYW5lbHMgPSBmbGlja2luZy5yZW5kZXJlci5wYW5lbHMuZmlsdGVyKGZ1bmN0aW9uIChwYW5lbCkge1xuICAgICAgcmV0dXJuIHBhbmVsLnJlbmRlcmVkO1xuICAgIH0pO1xuICAgIHZhciB0b2dnbGVkUHJldiA9IHJlbmRlcmVkUGFuZWxzLmZpbHRlcihmdW5jdGlvbiAocGFuZWwpIHtcbiAgICAgIHJldHVybiBwYW5lbC50b2dnbGVkICYmIHBhbmVsLnRvZ2dsZURpcmVjdGlvbiA9PT0gRElSRUNUSU9OLlBSRVY7XG4gICAgfSk7XG4gICAgdmFyIHRvZ2dsZWROZXh0ID0gcmVuZGVyZWRQYW5lbHMuZmlsdGVyKGZ1bmN0aW9uIChwYW5lbCkge1xuICAgICAgcmV0dXJuIHBhbmVsLnRvZ2dsZWQgJiYgcGFuZWwudG9nZ2xlRGlyZWN0aW9uID09PSBESVJFQ1RJT04uTkVYVDtcbiAgICB9KTtcbiAgICB2YXIgbm90VG9nZ2xlZCA9IHJlbmRlcmVkUGFuZWxzLmZpbHRlcihmdW5jdGlvbiAocGFuZWwpIHtcbiAgICAgIHJldHVybiAhcGFuZWwudG9nZ2xlZDtcbiAgICB9KTtcbiAgICByZXR1cm4gX19zcHJlYWQkMSh0b2dnbGVkUHJldiwgbm90VG9nZ2xlZCwgdG9nZ2xlZE5leHQpLm1hcChmdW5jdGlvbiAocGFuZWwpIHtcbiAgICAgIHJldHVybiBwYW5lbC5pbmRleDtcbiAgICB9KTtcbiAgfTtcbiAgX19wcm90by5nZXRSZW5kZXJpbmdFbGVtZW50c0J5T3JkZXIgPSBmdW5jdGlvbiAoZmxpY2tpbmcpIHtcbiAgICB2YXIgcGFuZWxzID0gZmxpY2tpbmcucGFuZWxzO1xuICAgIHJldHVybiB0aGlzLmdldFJlbmRlcmluZ0luZGV4ZXNCeU9yZGVyKGZsaWNraW5nKS5tYXAoZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICByZXR1cm4gcGFuZWxzW2luZGV4XS5lbGVtZW50O1xuICAgIH0pO1xuICB9O1xuICBfX3Byb3RvLnVwZGF0ZVJlbmRlcmluZ1BhbmVscyA9IGZ1bmN0aW9uIChmbGlja2luZykge1xuICAgIGlmIChmbGlja2luZy5yZW5kZXJPbmx5VmlzaWJsZSkge1xuICAgICAgdGhpcy5fc2hvd09ubHlWaXNpYmxlUGFuZWxzKGZsaWNraW5nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmxpY2tpbmcucGFuZWxzLmZvckVhY2goZnVuY3Rpb24gKHBhbmVsKSB7XG4gICAgICAgIHJldHVybiBwYW5lbC5tYXJrRm9yU2hvdygpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICBfX3Byb3RvLmNvbGxlY3RQYW5lbHMgPSBmdW5jdGlvbiAoZmxpY2tpbmcsIGVsZW1lbnRzKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB2YXIgYWxpZ24gPSBwYXJzZVBhbmVsQWxpZ24oZmxpY2tpbmcucmVuZGVyZXIuYWxpZ24pO1xuICAgIHJldHVybiBlbGVtZW50cy5tYXAoZnVuY3Rpb24gKGVsLCBpbmRleCkge1xuICAgICAgcmV0dXJuIG5ldyBQYW5lbCh7XG4gICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgZWxlbWVudFByb3ZpZGVyOiBuZXcgX3RoaXMuX3Byb3ZpZGVyQ3RvcihlbCksXG4gICAgICAgIGFsaWduOiBhbGlnbixcbiAgICAgICAgZmxpY2tpbmc6IGZsaWNraW5nXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbiAgX19wcm90by5jcmVhdGVQYW5lbCA9IGZ1bmN0aW9uIChlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBQYW5lbChfX2Fzc2lnbiQyKF9fYXNzaWduJDIoe30sIG9wdGlvbnMpLCB7XG4gICAgICBlbGVtZW50UHJvdmlkZXI6IG5ldyB0aGlzLl9wcm92aWRlckN0b3IoZWxlbWVudClcbiAgICB9KSk7XG4gIH07XG4gIF9fcHJvdG8udXBkYXRlUGFuZWxTaXplcyA9IGZ1bmN0aW9uIChmbGlja2luZywgc2l6ZSkge1xuICAgIGZsaWNraW5nLnBhbmVscy5mb3JFYWNoKGZ1bmN0aW9uIChwYW5lbCkge1xuICAgICAgcmV0dXJuIHBhbmVsLnNldFNpemUoc2l6ZSk7XG4gICAgfSk7XG4gIH07XG4gIF9fcHJvdG8uX3Nob3dPbmx5VmlzaWJsZVBhbmVscyA9IGZ1bmN0aW9uIChmbGlja2luZykge1xuICAgIHZhciBwYW5lbHMgPSBmbGlja2luZy5yZW5kZXJlci5wYW5lbHM7XG4gICAgdmFyIGNhbWVyYSA9IGZsaWNraW5nLmNhbWVyYTtcbiAgICB2YXIgdmlzaWJsZUluZGV4ZXMgPSBjYW1lcmEudmlzaWJsZVBhbmVscy5yZWR1Y2UoZnVuY3Rpb24gKHZpc2libGVzLCBwYW5lbCkge1xuICAgICAgdmlzaWJsZXNbcGFuZWwuaW5kZXhdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB2aXNpYmxlcztcbiAgICB9LCB7fSk7XG4gICAgcGFuZWxzLmZvckVhY2goZnVuY3Rpb24gKHBhbmVsKSB7XG4gICAgICBpZiAocGFuZWwuaW5kZXggaW4gdmlzaWJsZUluZGV4ZXMgfHwgcGFuZWwubG9hZGluZykge1xuICAgICAgICBwYW5lbC5tYXJrRm9yU2hvdygpO1xuICAgICAgfSBlbHNlIGlmICghZmxpY2tpbmcuaG9sZGluZykge1xuICAgICAgICAvLyBEdXJpbmcgdGhlIGlucHV0IHNlcXVlbmNlLFxuICAgICAgICAvLyBEbyBub3QgcmVtb3ZlIHBhbmVsIGVsZW1lbnRzIGFzIGl0IHdvbid0IHRyaWdnZXIgdG91Y2hlbmQgZXZlbnQuXG4gICAgICAgIHBhbmVsLm1hcmtGb3JIaWRlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY2FtZXJhLnVwZGF0ZU9mZnNldCgpO1xuICB9O1xuICByZXR1cm4gTm9ybWFsUmVuZGVyaW5nU3RyYXRlZ3k7XG59KCk7XG5cbi8qKlxyXG4gKiBBbiBzbGlkZSBkYXRhIGNvbXBvbmVudCB0aGF0IGhvbGRzIGluZm9ybWF0aW9uIG9mIGEgc2luZ2xlIEhUTUxFbGVtZW50XHJcbiAqIEBrbyDsiqzrnbzsnbTrk5wg642w7J207YSwIOy7tO2PrOuEjO2KuOuhnCwg64uo7J28IEhUTUxFbGVtZW507J2YIOygleuztOulvCDqsJbqs6Ag7J6I7Iq164uI64ukXHJcbiAqL1xudmFyIFZpcnR1YWxQYW5lbCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyQzKFZpcnR1YWxQYW5lbCwgX3N1cGVyKTtcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgQW4gb3B0aW9ucyBvYmplY3Q8a28+7Ji17IWYIOyYpOu4jOygne2KuDwva28+XHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmluZGV4XSBBbiBpbml0aWFsIGluZGV4IG9mIHRoZSBwYW5lbDxrbz7tjKjrhJDsnZgg7LSI6riwIOyduOuNseyKpDwva28+XHJcbiAgICogQHBhcmFtIHtDb25zdGFudHMuQUxJR04gfCBzdHJpbmcgfCBudW1iZXJ9IFtvcHRpb25zLmFsaWduXSBBbiBpbml0aWFsIHtAbGluayBGbGlja2luZyNhbGlnbiBhbGlnbn0gdmFsdWUgb2YgdGhlIHBhbmVsPGtvPu2MqOuEkOydmCDstIjquLAge0BsaW5rIEZsaWNraW5nI2FsaWduIGFsaWdufeqwkjwva28+XHJcbiAgICogQHBhcmFtIHtGbGlja2luZ30gW29wdGlvbnMuZmxpY2tpbmddIEEgRmxpY2tpbmcgaW5zdGFuY2UgcGFuZWwncyByZWZlcmVuY2luZzxrbz7tjKjrhJDsnbQg7LC47KGw7ZWY64qUIHtAbGluayBGbGlja2luZ30g7J247Iqk7YS07IqkPC9rbz5cclxuICAgKi9cbiAgZnVuY3Rpb24gVmlydHVhbFBhbmVsKG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zKSB8fCB0aGlzO1xuICAgIG9wdGlvbnMuZWxlbWVudFByb3ZpZGVyLmluaXQoX3RoaXMpO1xuICAgIF90aGlzLl9lbFByb3ZpZGVyID0gb3B0aW9ucy5lbGVtZW50UHJvdmlkZXI7XG4gICAgX3RoaXMuX2NhY2hlZElubmVySFRNTCA9IG51bGw7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIHZhciBfX3Byb3RvID0gVmlydHVhbFBhbmVsLnByb3RvdHlwZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwiZWxlbWVudFwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBgSFRNTEVsZW1lbnRgIHRoYXQgcGFuZWwncyByZWZlcmVuY2luZ1xyXG4gICAgICogQGtvIO2MqOuEkOydtCDssLjsobDtlZjqs6Ag7J6I64qUIGBIVE1MRWxlbWVudGBcclxuICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZWxQcm92aWRlci5lbGVtZW50O1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJjYWNoZWRJbm5lckhUTUxcIiwge1xuICAgIC8qKlxyXG4gICAgICogQ2FjaGVkIGlubmVySFRNTCBieSB0aGUgcHJldmlvdXMgcmVuZGVyIGZ1bmN0aW9uXHJcbiAgICAgKiBAa28g7J207KCEIOugjOuNlOungeyXkOyEnCDsupDsi5zrkJwgaW5uZXJIVE1MIOygleuztFxyXG4gICAgICogQHR5cGUge3N0cmluZ3xudWxsfVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jYWNoZWRJbm5lckhUTUw7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcImVsZW1lbnRJbmRleFwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBBbiBudW1iZXIgZm9yIGluZGV4aW5nIHdoaWNoIGVsZW1lbnQgaXQgd2lsbCBiZSByZW5kZXJlZCBvblxyXG4gICAgICogQGtvIOuqhyDrsojsp7gg7JeY66as66i87Yq47JeQIOugjOuNlOungeuQoCDqsoPsnbjsp4Drpbwg64KY7YOA64K064qUIOyIq+yekFxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZmxpY2tpbmcgPSB0aGlzLl9mbGlja2luZztcbiAgICAgIHZhciB2aXJ0dWFsRWxDb3VudCA9IGZsaWNraW5nLnBhbmVsc1BlclZpZXcgKyAxO1xuICAgICAgdmFyIHBhbmVsQ291bnQgPSBmbGlja2luZy5wYW5lbENvdW50O1xuICAgICAgdmFyIGluZGV4ID0gdGhpcy5faW5kZXg7XG4gICAgICBpZiAodGhpcy5fdG9nZ2xlZCkge1xuICAgICAgICAvLyBUbyBwcmV2ZW50IGVsZW1lbnQgZHVwbGljYXRpb25cbiAgICAgICAgaW5kZXggPSB0aGlzLl90b2dnbGVEaXJlY3Rpb24gPT09IERJUkVDVElPTi5ORVhUID8gaW5kZXggKyBwYW5lbENvdW50IDogaW5kZXggLSBwYW5lbENvdW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNpcmN1bGF0ZUluZGV4KGluZGV4LCB2aXJ0dWFsRWxDb3VudCk7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIF9fcHJvdG8uY2FjaGVSZW5kZXJSZXN1bHQgPSBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgdGhpcy5fY2FjaGVkSW5uZXJIVE1MID0gcmVzdWx0O1xuICB9O1xuICBfX3Byb3RvLnVuY2FjaGVSZW5kZXJSZXN1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fY2FjaGVkSW5uZXJIVE1MID0gbnVsbDtcbiAgfTtcbiAgX19wcm90by5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZsaWNraW5nID0gdGhpcy5fZmxpY2tpbmc7XG4gICAgdmFyIF9hID0gZmxpY2tpbmcudmlydHVhbCxcbiAgICAgIHJlbmRlclBhbmVsID0gX2EucmVuZGVyUGFuZWwsXG4gICAgICBjYWNoZSA9IF9hLmNhY2hlO1xuICAgIHZhciBlbGVtZW50ID0gdGhpcy5fZWxQcm92aWRlci5lbGVtZW50O1xuICAgIHZhciBuZXdJbm5lckhUTUwgPSB0aGlzLl9jYWNoZWRJbm5lckhUTUwgfHwgcmVuZGVyUGFuZWwodGhpcywgdGhpcy5faW5kZXgpO1xuICAgIGlmIChuZXdJbm5lckhUTUwgPT09IGVsZW1lbnQuaW5uZXJIVE1MKSByZXR1cm47XG4gICAgZWxlbWVudC5pbm5lckhUTUwgPSBuZXdJbm5lckhUTUw7XG4gICAgaWYgKGNhY2hlKSB7XG4gICAgICB0aGlzLmNhY2hlUmVuZGVyUmVzdWx0KG5ld0lubmVySFRNTCk7XG4gICAgfVxuICB9O1xuICBfX3Byb3RvLmluY3JlYXNlSW5kZXggPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgdGhpcy51bmNhY2hlUmVuZGVyUmVzdWx0KCk7XG4gICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuaW5jcmVhc2VJbmRleC5jYWxsKHRoaXMsIHZhbCk7XG4gIH07XG4gIF9fcHJvdG8uZGVjcmVhc2VJbmRleCA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICB0aGlzLnVuY2FjaGVSZW5kZXJSZXN1bHQoKTtcbiAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5kZWNyZWFzZUluZGV4LmNhbGwodGhpcywgdmFsKTtcbiAgfTtcbiAgcmV0dXJuIFZpcnR1YWxQYW5lbDtcbn0oUGFuZWwpO1xuXG52YXIgVmlydHVhbFJlbmRlcmluZ1N0cmF0ZWd5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVmlydHVhbFJlbmRlcmluZ1N0cmF0ZWd5KCkge31cbiAgdmFyIF9fcHJvdG8gPSBWaXJ0dWFsUmVuZGVyaW5nU3RyYXRlZ3kucHJvdG90eXBlO1xuICBfX3Byb3RvLnJlbmRlclBhbmVscyA9IGZ1bmN0aW9uIChmbGlja2luZykge1xuICAgIHZhciB2aXJ0dWFsTWFuYWdlciA9IGZsaWNraW5nLnZpcnR1YWw7XG4gICAgdmFyIHZpc2libGVQYW5lbHMgPSBmbGlja2luZy52aXNpYmxlUGFuZWxzO1xuICAgIHZhciBpbnZpc2libGVJbmRleGVzID0gcmFuZ2UoZmxpY2tpbmcucGFuZWxzUGVyVmlldyArIDEpO1xuICAgIHZpc2libGVQYW5lbHMuZm9yRWFjaChmdW5jdGlvbiAocGFuZWwpIHtcbiAgICAgIHZhciBlbGVtZW50SW5kZXggPSBwYW5lbC5lbGVtZW50SW5kZXg7XG4gICAgICBwYW5lbC5yZW5kZXIoKTtcbiAgICAgIHZpcnR1YWxNYW5hZ2VyLnNob3coZWxlbWVudEluZGV4KTtcbiAgICAgIGludmlzaWJsZUluZGV4ZXNbZWxlbWVudEluZGV4XSA9IC0xO1xuICAgIH0pO1xuICAgIGludmlzaWJsZUluZGV4ZXMuZmlsdGVyKGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHJldHVybiB2YWwgPj0gMDtcbiAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgIHZpcnR1YWxNYW5hZ2VyLmhpZGUoaWR4KTtcbiAgICB9KTtcbiAgfTtcbiAgX19wcm90by5nZXRSZW5kZXJpbmdJbmRleGVzQnlPcmRlciA9IGZ1bmN0aW9uIChmbGlja2luZykge1xuICAgIHZhciB2aXJ0dWFsTWFuYWdlciA9IGZsaWNraW5nLnZpcnR1YWw7XG4gICAgdmFyIHZpc2libGVQYW5lbHMgPSBfX3NwcmVhZCQxKGZsaWNraW5nLnZpc2libGVQYW5lbHMpLmZpbHRlcihmdW5jdGlvbiAocGFuZWwpIHtcbiAgICAgIHJldHVybiBwYW5lbC5yZW5kZXJlZDtcbiAgICB9KS5zb3J0KGZ1bmN0aW9uIChwYW5lbDEsIHBhbmVsMikge1xuICAgICAgcmV0dXJuIHBhbmVsMS5wb3NpdGlvbiArIHBhbmVsMS5vZmZzZXQgLSAocGFuZWwyLnBvc2l0aW9uICsgcGFuZWwyLm9mZnNldCk7XG4gICAgfSk7XG4gICAgaWYgKHZpc2libGVQYW5lbHMubGVuZ3RoIDw9IDApIHJldHVybiB2aXJ0dWFsTWFuYWdlci5lbGVtZW50cy5tYXAoZnVuY3Rpb24gKF8sIGlkeCkge1xuICAgICAgcmV0dXJuIGlkeDtcbiAgICB9KTtcbiAgICB2YXIgdmlzaWJsZUluZGV4ZXMgPSB2aXNpYmxlUGFuZWxzLm1hcChmdW5jdGlvbiAocGFuZWwpIHtcbiAgICAgIHJldHVybiBwYW5lbC5lbGVtZW50SW5kZXg7XG4gICAgfSk7XG4gICAgdmFyIGludmlzaWJsZUluZGV4ZXMgPSB2aXJ0dWFsTWFuYWdlci5lbGVtZW50cy5tYXAoZnVuY3Rpb24gKGVsLCBpZHgpIHtcbiAgICAgIHJldHVybiBfX2Fzc2lnbiQyKF9fYXNzaWduJDIoe30sIGVsKSwge1xuICAgICAgICBpZHg6IGlkeFxuICAgICAgfSk7XG4gICAgfSkuZmlsdGVyKGZ1bmN0aW9uIChlbCkge1xuICAgICAgcmV0dXJuICFlbC52aXNpYmxlO1xuICAgIH0pLm1hcChmdW5jdGlvbiAoZWwpIHtcbiAgICAgIHJldHVybiBlbC5pZHg7XG4gICAgfSk7XG4gICAgcmV0dXJuIF9fc3ByZWFkJDEodmlzaWJsZUluZGV4ZXMsIGludmlzaWJsZUluZGV4ZXMpO1xuICB9O1xuICBfX3Byb3RvLmdldFJlbmRlcmluZ0VsZW1lbnRzQnlPcmRlciA9IGZ1bmN0aW9uIChmbGlja2luZykge1xuICAgIHZhciB2aXJ0dWFsTWFuYWdlciA9IGZsaWNraW5nLnZpcnR1YWw7XG4gICAgdmFyIGVsZW1lbnRzID0gdmlydHVhbE1hbmFnZXIuZWxlbWVudHM7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UmVuZGVyaW5nSW5kZXhlc0J5T3JkZXIoZmxpY2tpbmcpLm1hcChmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgIHJldHVybiBlbGVtZW50c1tpbmRleF0ubmF0aXZlRWxlbWVudDtcbiAgICB9KTtcbiAgfTtcbiAgX19wcm90by51cGRhdGVSZW5kZXJpbmdQYW5lbHMgPSBmdW5jdGlvbiAoZmxpY2tpbmcpIHtcbiAgICB2YXIgcGFuZWxzID0gZmxpY2tpbmcucmVuZGVyZXIucGFuZWxzO1xuICAgIHZhciBjYW1lcmEgPSBmbGlja2luZy5jYW1lcmE7XG4gICAgdmFyIHZpc2libGVJbmRleGVzID0gY2FtZXJhLnZpc2libGVQYW5lbHMucmVkdWNlKGZ1bmN0aW9uICh2aXNpYmxlcywgcGFuZWwpIHtcbiAgICAgIHZpc2libGVzW3BhbmVsLmluZGV4XSA9IHRydWU7XG4gICAgICByZXR1cm4gdmlzaWJsZXM7XG4gICAgfSwge30pO1xuICAgIHBhbmVscy5mb3JFYWNoKGZ1bmN0aW9uIChwYW5lbCkge1xuICAgICAgaWYgKHBhbmVsLmluZGV4IGluIHZpc2libGVJbmRleGVzIHx8IHBhbmVsLmxvYWRpbmcpIHtcbiAgICAgICAgcGFuZWwubWFya0ZvclNob3coKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhbmVsLm1hcmtGb3JIaWRlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY2FtZXJhLnVwZGF0ZU9mZnNldCgpO1xuICB9O1xuICBfX3Byb3RvLmNvbGxlY3RQYW5lbHMgPSBmdW5jdGlvbiAoZmxpY2tpbmcpIHtcbiAgICB2YXIgYWxpZ24gPSBwYXJzZVBhbmVsQWxpZ24oZmxpY2tpbmcucmVuZGVyZXIuYWxpZ24pO1xuICAgIHJldHVybiByYW5nZShmbGlja2luZy52aXJ0dWFsLmluaXRpYWxQYW5lbENvdW50KS5tYXAoZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICByZXR1cm4gbmV3IFZpcnR1YWxQYW5lbCh7XG4gICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgZWxlbWVudFByb3ZpZGVyOiBuZXcgVmlydHVhbEVsZW1lbnRQcm92aWRlcihmbGlja2luZyksXG4gICAgICAgIGFsaWduOiBhbGlnbixcbiAgICAgICAgZmxpY2tpbmc6IGZsaWNraW5nXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbiAgX19wcm90by5jcmVhdGVQYW5lbCA9IGZ1bmN0aW9uIChfZWwsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFZpcnR1YWxQYW5lbChfX2Fzc2lnbiQyKF9fYXNzaWduJDIoe30sIG9wdGlvbnMpLCB7XG4gICAgICBlbGVtZW50UHJvdmlkZXI6IG5ldyBWaXJ0dWFsRWxlbWVudFByb3ZpZGVyKG9wdGlvbnMuZmxpY2tpbmcpXG4gICAgfSkpO1xuICB9O1xuICBfX3Byb3RvLnVwZGF0ZVBhbmVsU2l6ZXMgPSBmdW5jdGlvbiAoZmxpY2tpbmcsIHNpemUpIHtcbiAgICBmbGlja2luZy52aXJ0dWFsLmVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICBzZXRTaXplKGVsLm5hdGl2ZUVsZW1lbnQsIHNpemUpO1xuICAgIH0pO1xuICAgIGZsaWNraW5nLnBhbmVscy5mb3JFYWNoKGZ1bmN0aW9uIChwYW5lbCkge1xuICAgICAgcmV0dXJuIHBhbmVsLnNldFNpemUoc2l6ZSk7XG4gICAgfSk7XG4gIH07XG4gIHJldHVybiBWaXJ0dWFsUmVuZGVyaW5nU3RyYXRlZ3k7XG59KCk7XG5cbi8qKlxyXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcclxuICogQHN1cHBvcnQge1wiaWVcIjogXCI5Kyh3aXRoIHBvbHlmaWxsKVwiLCBcImNoXCIgOiBcImxhdGVzdFwiLCBcImZmXCIgOiBcImxhdGVzdFwiLCAgXCJzZlwiIDogXCJsYXRlc3RcIiwgXCJlZGdlXCIgOiBcImxhdGVzdFwiLCBcImlvc1wiIDogXCI3K1wiLCBcImFuXCIgOiBcIjQuWCtcIn1cclxuICogQHJlcXVpcmVzIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vbmF2ZXIvZWdqcy1jb21wb25lbnR8QGVnanMvY29tcG9uZW50fVxyXG4gKiBAcmVxdWlyZXMge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9uYXZlci9lZ2pzLWF4ZXN8QGVnanMvYXhlc31cclxuICovXG52YXIgRmxpY2tpbmcgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMkMyhGbGlja2luZywgX3N1cGVyKTtcbiAgLyoqXHJcbiAgICogQHBhcmFtIHJvb3QgQSByb290IEhUTUxFbGVtZW50IHRvIGluaXRpYWxpemUgRmxpY2tpbmcgb24gaXQuIFdoZW4gaXQncyBhIHR5cGVvZiBgc3RyaW5nYCwgaXQgc2hvdWxkIGJlIGEgY3NzIHNlbGVjdG9yIHN0cmluZ1xyXG4gICAqIDxrbz5GbGlja2luZ+ydhCDstIjquLDtmZTtlaAgSFRNTEVsZW1lbnTroZwsIGBzdHJpbmdgIO2DgOyeheycvOuhnCDsp4DsoJXsi5wgY3NzIOyEoO2DneyekCDrrLjsnpDsl7TsnYQg7KeA7KCV7ZW07JW8IO2VqeuLiOuLpC48L2tvPlxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucz17fV0gQW4gb3B0aW9ucyBvYmplY3QgZm9yIEZsaWNraW5nLjxrbz5GbGlja2luZ+yXkCDsoIHsmqntlaAg7Ji17IWYIOyYpOu4jOygne2KuDwva28+XHJcbiAgICogQHRocm93cyB7RmxpY2tpbmdFcnJvcn1cclxuICAgKiB8Y29kZXxjb25kaXRpb258XHJcbiAgICogfC0tLXwtLS18XHJcbiAgICogfHtAbGluayBFUlJPUl9DT0RFIFdST05HX1RZUEV9fFdoZW4gdGhlIHJvb3QgaXMgbm90IGVpdGhlciBzdHJpbmcgb3IgSFRNTEVsZW1lbnR8XHJcbiAgICogfHtAbGluayBFUlJPUl9DT0RFIEVMRU1FTlRfTk9UX0ZPVU5EfXxXaGVuIHRoZSBlbGVtZW50IHdpdGggZ2l2ZW4gQ1NTIHNlbGVjdG9yIGRvZXMgbm90IGV4aXN0fFxyXG4gICAqIDxrbz5cclxuICAgKlxyXG4gICAqIHxjb2RlfOyhsOqxtHxcclxuICAgKiB8LS0tfC0tLXxcclxuICAgKiB8e0BsaW5rIEVSUk9SX0NPREUgV1JPTkdfVFlQRX1866Oo7Yq4IOyXmOumrOuovO2KuOqwgCBzdHJpbmfsnbTrgpggSFRNTEVsZW1lbnTqsIAg7JWE64uQIOqyveyasHxcclxuICAgKiB8e0BsaW5rIEVSUk9SX0NPREUgRUxFTUVOVF9OT1RfRk9VTkR9fOyjvOyWtOynhCBDU1Mgc2VsZWN0b3LroZwg7JeY66as66i87Yq466W8IOywvuyngCDrqrvtlojsnYQg6rK97JqwfFxyXG4gICAqXHJcbiAgICogPC9rbz5cclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGBgYHRzXHJcbiAgICogaW1wb3J0IEZsaWNraW5nIGZyb20gXCJAZWdqcy9mbGlja2luZ1wiO1xyXG4gICAqXHJcbiAgICogLy8gQ3JlYXRpbmcgbmV3IGluc3RhbmNlIG9mIEZsaWNraW5nIHdpdGggSFRNTEVsZW1lbnRcclxuICAgKiBjb25zdCBmbGlja2luZyA9IG5ldyBGbGlja2luZyhkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLmZsaWNraW5nLXZpZXdwb3J0XCIpLCB7IGNpcmN1bGFyOiB0cnVlIH0pO1xyXG4gICAqXHJcbiAgICogLy8gQ3JlYXRpbmcgbmV3IGluc3RhbmNlIG9mIEZsaWNraW5nIHdpdGggQ1NTIHNlbGVjdG9yXHJcbiAgICogY29uc3QgZmxpY2tpbmcyID0gbmV3IEZsaWNraW5nKFwiLmZsaWNraW5nLXZpZXdwb3J0XCIsIHsgY2lyY3VsYXI6IHRydWUgfSk7XHJcbiAgICogYGBgXHJcbiAgICovXG4gIGZ1bmN0aW9uIEZsaWNraW5nKHJvb3QsIF9hKSB7XG4gICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsXG4gICAgICBfYyA9IF9iLmFsaWduLFxuICAgICAgYWxpZ24gPSBfYyA9PT0gdm9pZCAwID8gQUxJR04uQ0VOVEVSIDogX2MsXG4gICAgICBfZCA9IF9iLmRlZmF1bHRJbmRleCxcbiAgICAgIGRlZmF1bHRJbmRleCA9IF9kID09PSB2b2lkIDAgPyAwIDogX2QsXG4gICAgICBfZSA9IF9iLmhvcml6b250YWwsXG4gICAgICBob3Jpem9udGFsID0gX2UgPT09IHZvaWQgMCA/IHRydWUgOiBfZSxcbiAgICAgIF9mID0gX2IuY2lyY3VsYXIsXG4gICAgICBjaXJjdWxhciA9IF9mID09PSB2b2lkIDAgPyBmYWxzZSA6IF9mLFxuICAgICAgX2cgPSBfYi5jaXJjdWxhckZhbGxiYWNrLFxuICAgICAgY2lyY3VsYXJGYWxsYmFjayA9IF9nID09PSB2b2lkIDAgPyBDSVJDVUxBUl9GQUxMQkFDSy5MSU5FQVIgOiBfZyxcbiAgICAgIF9oID0gX2IuYm91bmQsXG4gICAgICBib3VuZCA9IF9oID09PSB2b2lkIDAgPyBmYWxzZSA6IF9oLFxuICAgICAgX2ogPSBfYi5hZGFwdGl2ZSxcbiAgICAgIGFkYXB0aXZlID0gX2ogPT09IHZvaWQgMCA/IGZhbHNlIDogX2osXG4gICAgICBfayA9IF9iLnBhbmVsc1BlclZpZXcsXG4gICAgICBwYW5lbHNQZXJWaWV3ID0gX2sgPT09IHZvaWQgMCA/IC0xIDogX2ssXG4gICAgICBfbCA9IF9iLm5vUGFuZWxTdHlsZU92ZXJyaWRlLFxuICAgICAgbm9QYW5lbFN0eWxlT3ZlcnJpZGUgPSBfbCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfbCxcbiAgICAgIF9tID0gX2IucmVzaXplT25Db250ZW50c1JlYWR5LFxuICAgICAgcmVzaXplT25Db250ZW50c1JlYWR5ID0gX20gPT09IHZvaWQgMCA/IGZhbHNlIDogX20sXG4gICAgICBfbyA9IF9iLm5lc3RlZCxcbiAgICAgIG5lc3RlZCA9IF9vID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vLFxuICAgICAgX3AgPSBfYi5uZWVkUGFuZWxUaHJlc2hvbGQsXG4gICAgICBuZWVkUGFuZWxUaHJlc2hvbGQgPSBfcCA9PT0gdm9pZCAwID8gMCA6IF9wLFxuICAgICAgX3EgPSBfYi5wcmV2ZW50RXZlbnRzQmVmb3JlSW5pdCxcbiAgICAgIHByZXZlbnRFdmVudHNCZWZvcmVJbml0ID0gX3EgPT09IHZvaWQgMCA/IHRydWUgOiBfcSxcbiAgICAgIF9yID0gX2IuZGVjZWxlcmF0aW9uLFxuICAgICAgZGVjZWxlcmF0aW9uID0gX3IgPT09IHZvaWQgMCA/IDAuMDA3NSA6IF9yLFxuICAgICAgX3MgPSBfYi5kdXJhdGlvbixcbiAgICAgIGR1cmF0aW9uID0gX3MgPT09IHZvaWQgMCA/IDUwMCA6IF9zLFxuICAgICAgX3QgPSBfYi5lYXNpbmcsXG4gICAgICBlYXNpbmcgPSBfdCA9PT0gdm9pZCAwID8gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIDEgLSBNYXRoLnBvdygxIC0geCwgMyk7XG4gICAgICB9IDogX3QsXG4gICAgICBfdSA9IF9iLmlucHV0VHlwZSxcbiAgICAgIGlucHV0VHlwZSA9IF91ID09PSB2b2lkIDAgPyBbXCJtb3VzZVwiLCBcInRvdWNoXCJdIDogX3UsXG4gICAgICBfdiA9IF9iLm1vdmVUeXBlLFxuICAgICAgbW92ZVR5cGUgPSBfdiA9PT0gdm9pZCAwID8gXCJzbmFwXCIgOiBfdixcbiAgICAgIF93ID0gX2IudGhyZXNob2xkLFxuICAgICAgdGhyZXNob2xkID0gX3cgPT09IHZvaWQgMCA/IDQwIDogX3csXG4gICAgICBfeCA9IF9iLmludGVycnVwdGFibGUsXG4gICAgICBpbnRlcnJ1cHRhYmxlID0gX3ggPT09IHZvaWQgMCA/IHRydWUgOiBfeCxcbiAgICAgIF95ID0gX2IuYm91bmNlLFxuICAgICAgYm91bmNlID0gX3kgPT09IHZvaWQgMCA/IFwiMjAlXCIgOiBfeSxcbiAgICAgIF96ID0gX2IuaU9TRWRnZVN3aXBlVGhyZXNob2xkLFxuICAgICAgaU9TRWRnZVN3aXBlVGhyZXNob2xkID0gX3ogPT09IHZvaWQgMCA/IDMwIDogX3osXG4gICAgICBfMCA9IF9iLnByZXZlbnRDbGlja09uRHJhZyxcbiAgICAgIHByZXZlbnRDbGlja09uRHJhZyA9IF8wID09PSB2b2lkIDAgPyB0cnVlIDogXzAsXG4gICAgICBfMSA9IF9iLnByZXZlbnREZWZhdWx0T25EcmFnLFxuICAgICAgcHJldmVudERlZmF1bHRPbkRyYWcgPSBfMSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfMSxcbiAgICAgIF8yID0gX2IuZGlzYWJsZU9uSW5pdCxcbiAgICAgIGRpc2FibGVPbkluaXQgPSBfMiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfMixcbiAgICAgIF8zID0gX2IuY2hhbmdlT25Ib2xkLFxuICAgICAgY2hhbmdlT25Ib2xkID0gXzMgPT09IHZvaWQgMCA/IGZhbHNlIDogXzMsXG4gICAgICBfNCA9IF9iLnJlbmRlck9ubHlWaXNpYmxlLFxuICAgICAgcmVuZGVyT25seVZpc2libGUgPSBfNCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfNCxcbiAgICAgIF81ID0gX2IudmlydHVhbCxcbiAgICAgIHZpcnR1YWwgPSBfNSA9PT0gdm9pZCAwID8gbnVsbCA6IF81LFxuICAgICAgXzYgPSBfYi5hdXRvSW5pdCxcbiAgICAgIGF1dG9Jbml0ID0gXzYgPT09IHZvaWQgMCA/IHRydWUgOiBfNixcbiAgICAgIF83ID0gX2IuYXV0b1Jlc2l6ZSxcbiAgICAgIGF1dG9SZXNpemUgPSBfNyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF83LFxuICAgICAgXzggPSBfYi51c2VSZXNpemVPYnNlcnZlcixcbiAgICAgIHVzZVJlc2l6ZU9ic2VydmVyID0gXzggPT09IHZvaWQgMCA/IHRydWUgOiBfOCxcbiAgICAgIF85ID0gX2IucmVzaXplRGVib3VuY2UsXG4gICAgICByZXNpemVEZWJvdW5jZSA9IF85ID09PSB2b2lkIDAgPyAwIDogXzksXG4gICAgICBfMTAgPSBfYi5tYXhSZXNpemVEZWJvdW5jZSxcbiAgICAgIG1heFJlc2l6ZURlYm91bmNlID0gXzEwID09PSB2b2lkIDAgPyAxMDAgOiBfMTAsXG4gICAgICBfMTEgPSBfYi51c2VGcmFjdGlvbmFsU2l6ZSxcbiAgICAgIHVzZUZyYWN0aW9uYWxTaXplID0gXzExID09PSB2b2lkIDAgPyBmYWxzZSA6IF8xMSxcbiAgICAgIF8xMiA9IF9iLmV4dGVybmFsUmVuZGVyZXIsXG4gICAgICBleHRlcm5hbFJlbmRlcmVyID0gXzEyID09PSB2b2lkIDAgPyBudWxsIDogXzEyLFxuICAgICAgXzEzID0gX2IucmVuZGVyRXh0ZXJuYWwsXG4gICAgICByZW5kZXJFeHRlcm5hbCA9IF8xMyA9PT0gdm9pZCAwID8gbnVsbCA6IF8xMztcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgIC8vIEludGVybmFsIHN0YXRlc1xuICAgIF90aGlzLl9pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgIF90aGlzLl9wbHVnaW5zID0gW107XG4gICAgLy8gQmluZCBvcHRpb25zXG4gICAgX3RoaXMuX2FsaWduID0gYWxpZ247XG4gICAgX3RoaXMuX2RlZmF1bHRJbmRleCA9IGRlZmF1bHRJbmRleDtcbiAgICBfdGhpcy5faG9yaXpvbnRhbCA9IGhvcml6b250YWw7XG4gICAgX3RoaXMuX2NpcmN1bGFyID0gY2lyY3VsYXI7XG4gICAgX3RoaXMuX2NpcmN1bGFyRmFsbGJhY2sgPSBjaXJjdWxhckZhbGxiYWNrO1xuICAgIF90aGlzLl9ib3VuZCA9IGJvdW5kO1xuICAgIF90aGlzLl9hZGFwdGl2ZSA9IGFkYXB0aXZlO1xuICAgIF90aGlzLl9wYW5lbHNQZXJWaWV3ID0gcGFuZWxzUGVyVmlldztcbiAgICBfdGhpcy5fbm9QYW5lbFN0eWxlT3ZlcnJpZGUgPSBub1BhbmVsU3R5bGVPdmVycmlkZTtcbiAgICBfdGhpcy5fcmVzaXplT25Db250ZW50c1JlYWR5ID0gcmVzaXplT25Db250ZW50c1JlYWR5O1xuICAgIF90aGlzLl9uZXN0ZWQgPSBuZXN0ZWQ7XG4gICAgX3RoaXMuX3ZpcnR1YWwgPSB2aXJ0dWFsO1xuICAgIF90aGlzLl9uZWVkUGFuZWxUaHJlc2hvbGQgPSBuZWVkUGFuZWxUaHJlc2hvbGQ7XG4gICAgX3RoaXMuX3ByZXZlbnRFdmVudHNCZWZvcmVJbml0ID0gcHJldmVudEV2ZW50c0JlZm9yZUluaXQ7XG4gICAgX3RoaXMuX2RlY2VsZXJhdGlvbiA9IGRlY2VsZXJhdGlvbjtcbiAgICBfdGhpcy5fZHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICBfdGhpcy5fZWFzaW5nID0gZWFzaW5nO1xuICAgIF90aGlzLl9pbnB1dFR5cGUgPSBpbnB1dFR5cGU7XG4gICAgX3RoaXMuX21vdmVUeXBlID0gbW92ZVR5cGU7XG4gICAgX3RoaXMuX3RocmVzaG9sZCA9IHRocmVzaG9sZDtcbiAgICBfdGhpcy5faW50ZXJydXB0YWJsZSA9IGludGVycnVwdGFibGU7XG4gICAgX3RoaXMuX2JvdW5jZSA9IGJvdW5jZTtcbiAgICBfdGhpcy5faU9TRWRnZVN3aXBlVGhyZXNob2xkID0gaU9TRWRnZVN3aXBlVGhyZXNob2xkO1xuICAgIF90aGlzLl9wcmV2ZW50Q2xpY2tPbkRyYWcgPSBwcmV2ZW50Q2xpY2tPbkRyYWc7XG4gICAgX3RoaXMuX3ByZXZlbnREZWZhdWx0T25EcmFnID0gcHJldmVudERlZmF1bHRPbkRyYWc7XG4gICAgX3RoaXMuX2Rpc2FibGVPbkluaXQgPSBkaXNhYmxlT25Jbml0O1xuICAgIF90aGlzLl9jaGFuZ2VPbkhvbGQgPSBjaGFuZ2VPbkhvbGQ7XG4gICAgX3RoaXMuX3JlbmRlck9ubHlWaXNpYmxlID0gcmVuZGVyT25seVZpc2libGU7XG4gICAgX3RoaXMuX2F1dG9Jbml0ID0gYXV0b0luaXQ7XG4gICAgX3RoaXMuX2F1dG9SZXNpemUgPSBhdXRvUmVzaXplO1xuICAgIF90aGlzLl91c2VSZXNpemVPYnNlcnZlciA9IHVzZVJlc2l6ZU9ic2VydmVyO1xuICAgIF90aGlzLl9yZXNpemVEZWJvdW5jZSA9IHJlc2l6ZURlYm91bmNlO1xuICAgIF90aGlzLl9tYXhSZXNpemVEZWJvdW5jZSA9IG1heFJlc2l6ZURlYm91bmNlO1xuICAgIF90aGlzLl91c2VGcmFjdGlvbmFsU2l6ZSA9IHVzZUZyYWN0aW9uYWxTaXplO1xuICAgIF90aGlzLl9leHRlcm5hbFJlbmRlcmVyID0gZXh0ZXJuYWxSZW5kZXJlcjtcbiAgICBfdGhpcy5fcmVuZGVyRXh0ZXJuYWwgPSByZW5kZXJFeHRlcm5hbDtcbiAgICAvLyBDcmVhdGUgY29yZSBjb21wb25lbnRzXG4gICAgX3RoaXMuX3ZpZXdwb3J0ID0gbmV3IFZpZXdwb3J0KF90aGlzLCBnZXRFbGVtZW50KHJvb3QpKTtcbiAgICBfdGhpcy5fYXV0b1Jlc2l6ZXIgPSBuZXcgQXV0b1Jlc2l6ZXIoX3RoaXMpO1xuICAgIF90aGlzLl9yZW5kZXJlciA9IF90aGlzLl9jcmVhdGVSZW5kZXJlcigpO1xuICAgIF90aGlzLl9jYW1lcmEgPSBfdGhpcy5fY3JlYXRlQ2FtZXJhKCk7XG4gICAgX3RoaXMuX2NvbnRyb2wgPSBfdGhpcy5fY3JlYXRlQ29udHJvbCgpO1xuICAgIF90aGlzLl92aXJ0dWFsTWFuYWdlciA9IG5ldyBWaXJ0dWFsTWFuYWdlcihfdGhpcywgdmlydHVhbCk7XG4gICAgaWYgKF90aGlzLl9hdXRvSW5pdCkge1xuICAgICAgdm9pZCBfdGhpcy5pbml0KCk7XG4gICAgfVxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICB2YXIgX19wcm90byA9IEZsaWNraW5nLnByb3RvdHlwZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwiY29udHJvbFwiLCB7XG4gICAgLy8gQ29tcG9uZW50c1xuICAgIC8qKlxyXG4gICAgICoge0BsaW5rIENvbnRyb2x9IGluc3RhbmNlIG9mIHRoZSBGbGlja2luZ1xyXG4gICAgICogQGtvIO2YhOyerCBGbGlja2luZ+yXkCDtmZzshLHtmZTrkJwge0BsaW5rIENvbnRyb2x9IOyduOyKpO2EtOyKpFxyXG4gICAgICogQHR5cGUge0NvbnRyb2x9XHJcbiAgICAgKiBAZGVmYXVsdCBTbmFwQ29udHJvbFxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKiBAc2VlIENvbnRyb2xcclxuICAgICAqIEBzZWUgU25hcENvbnRyb2xcclxuICAgICAqIEBzZWUgRnJlZUNvbnRyb2xcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NvbnRyb2w7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcImNhbWVyYVwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiB7QGxpbmsgQ2FtZXJhfSBpbnN0YW5jZSBvZiB0aGUgRmxpY2tpbmdcclxuICAgICAqIEBrbyDtmITsnqwgRmxpY2tpbmfsl5Ag7Zmc7ISx7ZmU65CcIHtAbGluayBDYW1lcmF9IOyduOyKpO2EtOyKpFxyXG4gICAgICogQHR5cGUge0NhbWVyYX1cclxuICAgICAqIEBkZWZhdWx0IExpbmVhckNhbWVyYVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKiBAc2VlIENhbWVyYVxyXG4gICAgICogQHNlZSBMaW5lYXJDYW1lcmFcclxuICAgICAqIEBzZWUgQm91bmRDYW1lcmFcclxuICAgICAqIEBzZWUgQ2lyY3VsYXJDYW1lcmFcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NhbWVyYTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwicmVuZGVyZXJcIiwge1xuICAgIC8qKlxyXG4gICAgICoge0BsaW5rIFJlbmRlcmVyfSBpbnN0YW5jZSBvZiB0aGUgRmxpY2tpbmdcclxuICAgICAqIEBrbyDtmITsnqwgRmxpY2tpbmfsl5Ag7Zmc7ISx7ZmU65CcIHtAbGluayBSZW5kZXJlcn0g7J247Iqk7YS07IqkXHJcbiAgICAgKiBAdHlwZSB7UmVuZGVyZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCBWYW5pbGxhUmVuZGVyZXJcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQHNlZSBSZW5kZXJlclxyXG4gICAgICogQHNlZSBWYW5pbGxhUmVuZGVyZXJcclxuICAgICAqIEBzZWUgRXh0ZXJuYWxSZW5kZXJlclxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVuZGVyZXI7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcInZpZXdwb3J0XCIsIHtcbiAgICAvKipcclxuICAgICAqIEEgY29tcG9uZW50IHRoYXQgbWFuYWdlcyB2aWV3cG9ydCBzaXplXHJcbiAgICAgKiBAa28g67ew7Y+s7Yq4IO2BrOq4sCDsoJXrs7Trpbwg64u064u57ZWY64qUIOy7tO2PrOuEjO2KuFxyXG4gICAgICogQHR5cGUge1ZpZXdwb3J0fVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKiBAc2VlIFZpZXdwb3J0XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl92aWV3cG9ydDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwiaW5pdGlhbGl6ZWRcIiwge1xuICAgIC8vIEludGVybmFsIFN0YXRlc1xuICAgIC8qKlxyXG4gICAgICogV2hldGhlciBGbGlja2luZydzIHtAbGluayBGbGlja2luZyNpbml0IGluaXQoKX0gaXMgY2FsbGVkLlxyXG4gICAgICogVGhpcyBpcyBgdHJ1ZWAgd2hlbiB7QGxpbmsgRmxpY2tpbmcjaW5pdCBpbml0KCl9IGlzIGNhbGxlZCwgYW5kIGlzIGBmYWxzZWAgYWZ0ZXIgY2FsbGluZyB7QGxpbmsgRmxpY2tpbmcjZGVzdHJveSBkZXN0cm95KCl9LlxyXG4gICAgICogQGtvIEZsaWNraW5n7J2YIHtAbGluayBGbGlja2luZyNpbml0IGluaXQoKX3snbQg7Zi47Lac65CY7JeI64qU7KeA66W8IOuCmO2DgOuCtOuKlCDrqaTrsoQg67OA7IiYLlxyXG4gICAgICog7J20IOqwkuydgCB7QGxpbmsgRmxpY2tpbmcjaW5pdCBpbml0KCl97J20IO2YuOy2nOuQmOyXiOycvOuptCBgdHJ1ZWDroZwg67OA7ZWY6rOgLCB7QGxpbmsgRmxpY2tpbmcjZGVzdHJveSBkZXN0cm95KCl97Zi47LacIOydtO2bhOyXkCDri6Tsi5wgYGZhbHNlYOuhnCDrs4Dqsr3rkKnri4jri6QuXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqIEBkZWZhdWx0IGZhbHNlXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2luaXRpYWxpemVkO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJjaXJjdWxhckVuYWJsZWRcIiwge1xuICAgIC8qKlxyXG4gICAgICogV2hldGhlciB0aGUgYGNpcmN1bGFyYCBvcHRpb24gaXMgZW5hYmxlZC5cclxuICAgICAqIFRoZSB7QGxpbmsgRmxpY2tpbmcjY2lyY3VsYXIgY2lyY3VsYXJ9IG9wdGlvbiBjYW4ndCBiZSBlbmFibGVkIHdoZW4gc3VtIG9mIHRoZSBwYW5lbCBzaXplcyBhcmUgdG9vIHNtYWxsLlxyXG4gICAgICogQGtvIHtAbGluayBGbGlja2luZyNjaXJjdWxhciBjaXJjdWxhcn0g7Ji17IWY7J20IO2ZnOyEse2ZlOuQmOyXiOuKlOyngCDsl6zrtoDrpbwg64KY7YOA64K064qUIOuppOuyhCDrs4DsiJguXHJcbiAgICAgKiB7QGxpbmsgRmxpY2tpbmcjY2lyY3VsYXIgY2lyY3VsYXJ9IOyYteyFmOydgCDtjKjrhJDsnZgg7YGs6riw7J2YIO2VqeydtCDstqnrtoTtlZjsp4Ag7JWK7J2EIOqyveyasCDruYTtmZzshLHtmZTrkKnri4jri6QuXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqIEBkZWZhdWx0IGZhbHNlXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NhbWVyYS5jaXJjdWxhckVuYWJsZWQ7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcInZpcnR1YWxFbmFibGVkXCIsIHtcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgdGhlIGB2aXJ0dWFsYCBvcHRpb24gaXMgZW5hYmxlZC5cclxuICAgICAqIFRoZSB7QGxpbmsgRmxpY2tpbmcjdmlydHVhbCB2aXJ0dWFsfSBvcHRpb24gY2FuJ3QgYmUgZW5hYmxlZCB3aGVuICB7QGxpbmsgRmxpY2tpbmcjcGFuZWxzUGVyVmlldyBwYW5lbHNQZXJWaWV3fSBpcyBsZXNzIG9yIGVxdWFsIHRoYW4gemVyby5cclxuICAgICAqIEBrbyB7QGxpbmsgRmxpY2tpbmcjdmlydHVhbCB2aXJ0dWFsfSDsmLXshZjsnbQg7Zmc7ISx7ZmU65CY7JeI64qU7KeAIOyXrOu2gOulvCDrgpjtg4DrgrTripQg66mk67KEIOuzgOyImC5cclxuICAgICAqIHtAbGluayBGbGlja2luZyN2aXJ0dWFsIHZpcnR1YWx9IOyYteyFmOydgCB7QGxpbmsgRmxpY2tpbmcjcGFuZWxzUGVyVmlldyBwYW5lbHNQZXJWaWV3fSDsmLXshZjsnZgg6rCS7J20IDDrs7Tri6Qg6rCZ6rGw64KYIOyekeycvOuptCDruYTtmZzshLHtmZTrkKnri4jri6QuXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqIEBkZWZhdWx0IGZhbHNlXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3BhbmVsc1BlclZpZXcgPiAwICYmIHRoaXMuX3ZpcnR1YWwgIT0gbnVsbDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwiaW5kZXhcIiwge1xuICAgIC8qKlxyXG4gICAgICogSW5kZXggbnVtYmVyIG9mIHRoZSB7QGxpbmsgRmxpY2tpbmcjY3VycmVudFBhbmVsIGN1cnJlbnRQYW5lbH1cclxuICAgICAqIEBrbyB7QGxpbmsgRmxpY2tpbmcjY3VycmVudFBhbmVsIGN1cnJlbnRQYW5lbH3snZgg7J24642x7IqkIOuyiO2YuFxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY29udHJvbC5hY3RpdmVJbmRleDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwiZWxlbWVudFwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBUaGUgcm9vdChgLmZsaWNraW5nLXZpZXdwb3J0YCkgZWxlbWVudFxyXG4gICAgICogQGtvIHJvb3QoYC5mbGlja2luZy12aWV3cG9ydGApIOyXmOumrOuovO2KuFxyXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl92aWV3cG9ydC5lbGVtZW50O1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJjdXJyZW50UGFuZWxcIiwge1xuICAgIC8qKlxyXG4gICAgICogQ3VycmVudGx5IGFjdGl2ZSBwYW5lbFxyXG4gICAgICogQGtvIO2YhOyerCDshKDtg53rkJwg7Yyo64SQXHJcbiAgICAgKiBAdHlwZSB7UGFuZWx9XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqIEBzZWUgUGFuZWxcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NvbnRyb2wuYWN0aXZlUGFuZWw7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcInBhbmVsc1wiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBBcnJheSBvZiBwYW5lbHNcclxuICAgICAqIEBrbyDsoITssrQg7Yyo64SQ65Ok7J2YIOuwsOyXtFxyXG4gICAgICogQHR5cGUge1BhbmVsW119XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqIEBzZWUgUGFuZWxcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlcmVyLnBhbmVscztcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwicGFuZWxDb3VudFwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBDb3VudCBvZiBwYW5lbHNcclxuICAgICAqIEBrbyDsoITssrQg7Yyo64SQ7J2YIOqwnOyImFxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVuZGVyZXIucGFuZWxDb3VudDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwidmlzaWJsZVBhbmVsc1wiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBBcnJheSBvZiBwYW5lbHMgdGhhdCBpcyB2aXNpYmxlIGF0IHRoZSBjdXJyZW50IHBvc2l0aW9uXHJcbiAgICAgKiBAa28g7ZiE7J6sIOuztOydtOuKlCDtjKjrhJDsnZgg67Cw7Je0XHJcbiAgICAgKiBAdHlwZSB7UGFuZWxbXX1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQHNlZSBQYW5lbFxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2FtZXJhLnZpc2libGVQYW5lbHM7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcImFuaW1hdGluZ1wiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIEZsaWNraW5nJ3MgYW5pbWF0aW5nXHJcbiAgICAgKiBAa28g7ZiE7J6sIOyVoOuLiOuplOydtOyFmCDrj5nsnpEg7Jes67aAXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY29udHJvbC5hbmltYXRpbmc7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcImhvbGRpbmdcIiwge1xuICAgIC8qKlxyXG4gICAgICogV2hldGhlciB1c2VyIGlzIGNsaWNraW5nIG9yIHRvdWNoaW5nXHJcbiAgICAgKiBAa28g7ZiE7J6sIOyCrOyaqeyekOqwgCDtgbTrpq0v7YSw7LmY7KSR7J247KeAIOyXrOu2gFxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NvbnRyb2wuaG9sZGluZztcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwiYWN0aXZlUGx1Z2luc1wiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBBIGN1cnJlbnQgbGlzdCBvZiBhY3RpdmF0ZWQgcGx1Z2luc1xyXG4gICAgICogQGtvIO2YhOyerCDtmZzshLHtmZTrkJwg7ZSM65+s6re47J24IOuqqeuhnVxyXG4gICAgICogQHR5cGUge1BsdWdpbltdfVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wbHVnaW5zO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJhbGlnblwiLCB7XG4gICAgLy8gT3B0aW9ucyBHZXR0ZXJcbiAgICAvLyBVSSAvIExBWU9VVFxuICAgIC8qKlxyXG4gICAgICogQWxpZ24gcG9zaXRpb24gb2YgdGhlIHBhbmVscyB3aXRoaW4gdmlld3BvcnQuIFlvdSBjYW4gc2V0IGRpZmZlcmVudCB2YWx1ZXMgZWFjaCBmb3IgdGhlIHBhbmVsIGFuZCBjYW1lcmFcclxuICAgICAqIEBrbyDrt7Dtj6ztirgg64K07JeQ7IScIO2MqOuEkCDsoJXroKzrsKnsi53snYQg7ISk7KCV7ZWY64qUIOyYteyFmC4g7Lm066mU65287JmAIO2MqOuEkCDqsJzrs4TroZwg7Ji17IWY7J2EIOyEpOygle2VoCDsiJjrj4Qg7J6I7Iq164uI64ukXHJcbiAgICAgKiBAdHlwZSB7QUxJR04gfCBzdHJpbmcgfCBudW1iZXIgfCB7IHBhbmVsOiBzdHJpbmcgfCBudW1iZXIsIGNhbWVyYTogc3RyaW5nIHwgbnVtYmVyIH19XHJcbiAgICAgKiBAcHJvcGVydHkge0FMSUdOIHwgc3RyaW5nIHwgbnVtYmVyfSBwYW5lbCBUaGUgYWxpZ24gdmFsdWUgZm9yIGVhY2gge0BsaW5rIFBhbmVsfXM8a28+6rCc6rCc7J2YIHtAbGluayBQYW5lbH3sl5Ag7KCB7Jqp7ZWgIOqwkjwva28+XHJcbiAgICAgKiBAcHJvcGVydHkge0FMSUdOIHwgc3RyaW5nIHwgbnVtYmVyfSBjYW1lcmEgVGhlIGFsaWduIHZhbHVlIGZvciB7QGxpbmsgQ2FtZXJhfTxrbz57QGxpbmsgQ2FtZXJhfeyXkCDsoIHsmqntlaAg6rCSPC9rbz5cclxuICAgICAqIEBkZWZhdWx0IFwiY2VudGVyXCJcclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtZmxpY2tpbmcvT3B0aW9ucyNhbGlnbiBhbGlnbiAoIE9wdGlvbnMgKX1cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBgYGB0c1xyXG4gICAgICogY29uc3QgcG9zc2libGVPcHRpb25zID0gW1xyXG4gICAgICogICAvLyBMaXRlcmFsIHN0cmluZ3NcclxuICAgICAqICAgXCJwcmV2XCIsIFwiY2VudGVyXCIsIFwibmV4dFwiLFxyXG4gICAgICogICAvLyAlIHZhbHVlcywgYXBwbGllZCB0byBib3RoIHBhbmVsICYgY2FtZXJhXHJcbiAgICAgKiAgIFwiMCVcIiwgXCIyNSVcIiwgXCI0MiVcIixcclxuICAgICAqICAgLy8gcHggdmFsdWVzLCBhcml0aG1ldGljIGNhbGN1bGF0aW9uIHdpdGggKCsvLSkgaXMgYWxzbyBhbGxvd2VkLlxyXG4gICAgICogICBcIjBweFwiLCBcIjEwMHB4XCIsIFwiNTAlIC0gMjVweFwiLFxyXG4gICAgICogICAvLyBudW1iZXJzLCBzYW1lIHRvIG51bWJlciArIHB4IChcIjBweFwiLCBcIjEwMHB4XCIpXHJcbiAgICAgKiAgIDAsIDEwMCwgMTAwMCxcclxuICAgICAqICAgLy8gU2V0dGluZyBhIGRpZmZlcmVudCB2YWx1ZSBmb3IgcGFuZWwgJiBjYW1lcmFcclxuICAgICAqICAgeyBwYW5lbDogXCIxMCVcIiwgY2FtZXJhOiBcIjI1JVwiIH1cclxuICAgICAqIF07XHJcbiAgICAgKlxyXG4gICAgICogcG9zc2libGVPcHRpb25zLmZvckVhY2goYWxpZ24gPT4ge1xyXG4gICAgICogICBuZXcgRmxpY2tpbmcoXCIjZWxcIiwgeyBhbGlnbiB9KTtcclxuICAgICAqIH0pO1xyXG4gICAgICogYGBgXHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9hbGlnbjtcbiAgICB9LFxuICAgIC8vIE9wdGlvbnMgU2V0dGVyXG4gICAgLy8gVUkgLyBMQVlPVVRcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHRoaXMuX2FsaWduID0gdmFsO1xuICAgICAgdGhpcy5fcmVuZGVyZXIuYWxpZ24gPSB2YWw7XG4gICAgICB0aGlzLl9jYW1lcmEuYWxpZ24gPSB2YWw7XG4gICAgICB2b2lkIHRoaXMucmVzaXplKCk7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcImRlZmF1bHRJbmRleFwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBJbmRleCBvZiB0aGUgcGFuZWwgdG8gbW92ZSB3aGVuIEZsaWNraW5nJ3Mge0BsaW5rIEZsaWNraW5nI2luaXQgaW5pdCgpfSBpcyBjYWxsZWQuIEEgemVyby1iYXNlZCBpbnRlZ2VyXHJcbiAgICAgKiBAa28gRmxpY2tpbmfsnZgge0BsaW5rIEZsaWNraW5nI2luaXQgaW5pdCgpfeydtCDtmLjstpzrkKAg65WMIOydtOuPme2VoCDrlJTtj7Ttirgg7Yyo64SQ7J2YIOyduOuNseyKpOuhnCwgMOu2gO2EsCDsi5zsnpHtlZjripQg7KCV7IiY7J6F64uI64ukXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgMFxyXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1mbGlja2luZy9PcHRpb25zI2RlZmF1bHRpbmRleCBkZWZhdWx0SW5kZXggKCBPcHRpb25zICl9XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kZWZhdWx0SW5kZXg7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHRoaXMuX2RlZmF1bHRJbmRleCA9IHZhbDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwiaG9yaXpvbnRhbFwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBEaXJlY3Rpb24gb2YgcGFuZWwgbW92ZW1lbnQgKHRydWU6IGhvcml6b250YWwsIGZhbHNlOiB2ZXJ0aWNhbClcclxuICAgICAqIEBrbyDtjKjrhJAg7J2064+ZIOuwqe2WpSAodHJ1ZTog6rCA66Gc67Cp7ZalLCBmYWxzZTog7IS466Gc67Cp7ZalKVxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKiBAZGVmYXVsdCB0cnVlXHJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWZsaWNraW5nL09wdGlvbnMjaG9yaXpvbnRhbCBob3Jpem9udGFsICggT3B0aW9ucyApfVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5faG9yaXpvbnRhbDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgdGhpcy5faG9yaXpvbnRhbCA9IHZhbDtcbiAgICAgIHRoaXMuX2NvbnRyb2wuY29udHJvbGxlci51cGRhdGVEaXJlY3Rpb24oKTtcbiAgICAgIHZvaWQgdGhpcy5yZXNpemUoKTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwiY2lyY3VsYXJcIiwge1xuICAgIC8qKlxyXG4gICAgICogRW5hYmxlcyBjaXJjdWxhcihjb250aW51b3VzIGxvb3ApIG1vZGUsIHdoaWNoIGNvbm5lY3RzIGZpcnN0L2xhc3QgcGFuZWwgZm9yIGNvbnRpbnVvdXMgc2Nyb2xsaW5nLlxyXG4gICAgICogQGtvIOyInO2ZmCDrqqjrk5zrpbwg7Zmc7ISx7ZmU7ZWp64uI64ukLiDsiJztmZgg66qo65Oc7JeQ7ISc64qUIOyWkSDrgZ3snZgg7Yyo64SQ7J20IOyEnOuhnCDsl7DqsrDrkJjslrQg64GK6rmA7JeG64qUIOyKpO2BrOuhpOydtCDqsIDriqXtlanri4jri6QuXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqIEBkZWZhdWx0IGZhbHNlXHJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWZsaWNraW5nL09wdGlvbnMjY2lyY3VsYXIgY2lyY3VsYXIgKCBPcHRpb25zICl9XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jaXJjdWxhcjtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgdGhpcy5fY2lyY3VsYXIgPSB2YWw7XG4gICAgICB2b2lkIHRoaXMucmVzaXplKCk7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcImNpcmN1bGFyRmFsbGJhY2tcIiwge1xuICAgIC8qKlxyXG4gICAgICogU2V0IHBhbmVsIGNvbnRyb2wgbW9kZSBmb3IgdGhlIGNhc2Ugd2hlbiBjaXJjdWxhciBjYW5ub3QgYmUgZW5hYmxlZC5cclxuICAgICAqIFwibGluZWFyXCIgd2lsbCBzZXQgdGhlIHZpZXcncyByYW5nZSBmcm9tIHRoZSB0b3Agb2YgdGhlIGZpcnN0IHBhbmVsIHRvIHRoZSB0b3Agb2YgdGhlIGxhc3QgcGFuZWwuXHJcbiAgICAgKiBcImJvdW5kXCIgd2lsbCBwcmV2ZW50IHRoZSB2aWV3IGZyb20gZ29pbmcgb3V0IG9mIHRoZSBmaXJzdC9sYXN0IHBhbmVsLCBzbyBpdCB3b24ndCBzaG93IGVtcHR5IHNwYWNlcyBiZWZvcmUvYWZ0ZXIgdGhlIGZpcnN0L2xhc3QgcGFuZWwuXHJcbiAgICAgKiBAa28g7Iic7ZmYIOuqqOuTnCDsgqzsmqkg67aI6rCA64ql7IucIOyCrOyaqe2VoCDtjKjrhJAg7KGw7J6RIOuylOychCDshKTsoJUg67Cp7Iud7J2EIOuzgOqyve2VqeuLiOuLpC5cclxuICAgICAqIFwibGluZWFyXCIg7IKs7Jqp7IucIOyLnOygkOydtCDssqvrsojsp7gg7JeY66as66i87Yq4IOychOyXkOyEnOu2gO2EsCDrp4jsp4Drp4kg7JeY66as66i87Yq4IOychOq5jOyngCDsm4Dsp4Hsnbwg7IiYIOyeiOuPhOuhnSDshKTsoJXtlanri4jri6QuXHJcbiAgICAgKiBcImJvdW5kXCIg7IKs7Jqp7IucIOyLnOygkOydtCDssqvrsojsp7gg7JeY66as66i87Yq47JmAIOuniOyngOuniSDsl5jrpqzrqLztirjsnZgg64Gd6rO8IOuBnSDsgqzsnbTsl5DshJwg7JuA7KeB7J28IOyImCDsnojrj4TroZ0g7ISk7KCV7ZWp64uI64ukLlxyXG4gICAgICogQHNlZSBDSVJDVUxBUl9GQUxMQkFDS1xyXG4gICAgICogQHR5cGUge3N0cmluZ31cclxuICAgICAqIEBkZWZhdWx0IFwibGluZWFyXCJcclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtZmxpY2tpbmcvT3B0aW9ucyNjaXJjdWxhcmZhbGxiYWNrIGNpcmN1bGFyRmFsbGJhY2sgKCBPcHRpb25zICl9XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jaXJjdWxhckZhbGxiYWNrO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJib3VuZFwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBQcmV2ZW50IHRoZSB2aWV3KGNhbWVyYSBlbGVtZW50KSBmcm9tIGdvaW5nIG91dCBvZiB0aGUgZmlyc3QvbGFzdCBwYW5lbCwgc28gaXQgd29uJ3Qgc2hvdyBlbXB0eSBzcGFjZXMgYmVmb3JlL2FmdGVyIHRoZSBmaXJzdC9sYXN0IHBhbmVsXHJcbiAgICAgKiBPbmx5IGNhbiBiZSBlbmFibGVkIHdoZW4gYGNpcmN1bGFyPWZhbHNlYFxyXG4gICAgICogQGtvIOu3sCjsubTrqZTrnbwg7JeY66as66i87Yq4KeqwgCDssqvrsojsp7jsmYAg66eI7KeA66eJIO2MqOuEkCDrsJbsnLzroZwg64SY7Ja06rCA7KeAIOuqu+2VmOqyjCDtlZjsl6wsIOyyq+uyiOynuC/rp4jsp4Drp4kg7Yyo64SQIOyghC/tm4TsnZgg67mIIOqzteqwhOydhCDrs7TsnbTsp4Ag7JWK64+E66GdIO2VmOuKlCDsmLXshZjsnoXri4jri6RcclxuICAgICAqIGBjaXJjdWxhcj1mYWxzZWDsnbgg6rK97Jqw7JeQ66eMIOyCrOyaqe2VoCDsiJgg7J6I7Iq164uI64ukXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqIEBkZWZhdWx0IGZhbHNlXHJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWZsaWNraW5nL09wdGlvbnMjYm91bmQgYm91bmQgKCBPcHRpb25zICl9XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9ib3VuZDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgdGhpcy5fYm91bmQgPSB2YWw7XG4gICAgICB2b2lkIHRoaXMucmVzaXplKCk7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcImFkYXB0aXZlXCIsIHtcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZSBoZWlnaHQgb2YgdGhlIHZpZXdwb3J0IGVsZW1lbnQgYWZ0ZXIgbW92ZW1lbnQgc2FtZSB0byB0aGUgaGVpZ2h0IG9mIHRoZSBwYW5lbCBiZWxvdy4gVGhpcyBjYW4gYmUgb25seSBlbmFibGVkIHdoZW4gYGhvcml6b250YWw9dHJ1ZWBcclxuICAgICAqIEBrbyDsnbTrj5ntlZwg7ZuEIOu3sO2PrO2KuCDsl5jrpqzrqLztirjsnZgg7YGs6riw66W8IO2YhOyerCDtjKjrhJDsnZgg64aS7J207JmAIOuPmeydvO2VmOqyjCDshKTsoJXtlanri4jri6QuIGBob3Jpem9udGFsPXRydWVg7J24IOqyveyasOyXkOunjCDsgqzsmqntlaAg7IiYIOyeiOyKteuLiOuLpC5cclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICogQGRlZmF1bHQgZmFsc2VcclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtZmxpY2tpbmcvT3B0aW9ucyNhZGFwdGl2ZSBhZGFwdGl2ZSAoIE9wdGlvbnMgKX1cclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2FkYXB0aXZlO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICB0aGlzLl9hZGFwdGl2ZSA9IHZhbDtcbiAgICAgIHZvaWQgdGhpcy5yZXNpemUoKTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwicGFuZWxzUGVyVmlld1wiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBBIHZpc2libGUgbnVtYmVyIG9mIHBhbmVscyBvbiB2aWV3cG9ydC4gRW5hYmxpbmcgdGhpcyBvcHRpb24gd2lsbCBhdXRvbWF0aWNhbGx5IHJlc2l6ZSBwYW5lbCBzaXplXHJcbiAgICAgKiBAa28g7ZWcIO2ZlOuptOyXkCDrs7TsnbTripQg7Yyo64SQ7J2YIOqwnOyImC4g7J20IOyYteyFmOydhCDtmZzshLHtmZTtlaAg6rK97JqwIO2MqOuEkOydmCDtgazquLDrpbwg6rCV7KCc66GcIOyerOyhsOygle2VqeuLiOuLpFxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IC0xXHJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWZsaWNraW5nL09wdGlvbnMjcGFuZWxzcGVydmlldyBwYW5lbHNQZXJWaWV3ICggT3B0aW9ucyApfVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcGFuZWxzUGVyVmlldztcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgdGhpcy5fcGFuZWxzUGVyVmlldyA9IHZhbDtcbiAgICAgIHZvaWQgdGhpcy5yZXNpemUoKTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwibm9QYW5lbFN0eWxlT3ZlcnJpZGVcIiwge1xuICAgIC8qKlxyXG4gICAgICogRW5hYmxpbmcgdGhpcyBvcHRpb24gd2lsbCBub3QgY2hhbmdlIGB3aWR0aC9oZWlnaHRgIHN0eWxlIG9mIHRoZSBwYW5lbHMgaWYge0BsaW5rIEZsaWNraW5nI3BhbmVsc1BlclZpZXd9IGlzIGVuYWJsZWQuXHJcbiAgICAgKiBUaGlzIGJlaGF2aW9yIGNhbiBiZSB1c2VmdWwgaW4gdGVybXMgb2YgcGVyZm9ybWFuY2Ugd2hlbiB5b3UncmUgbWFudWFsbHkgbWFuYWdpbmcgYWxsIHBhbmVsIHNpemVzXHJcbiAgICAgKiBAa28g7J20IOyYteyFmOydhCDtmZzshLHtmZTtlaAg6rK97JqwLCB7QGxpbmsgRmxpY2tpbmcjcGFuZWxzUGVyVmlld30g7Ji17IWY7J20IO2ZnOyEse2ZlOuQmOyXiOydhCDrlYwg7Yyo64SQ7J2YIGB3aWR0aC9oZWlnaHRgIOyKpO2DgOydvOydhCDrs4Dqsr3tlZjsp4Ag7JWK64+E66GdIOyEpOygle2VqeuLiOuLpC5cclxuICAgICAqIOuqqOuToCDtjKjrhJDrk6TsnZgg7YGs6riw66W8IOyngeygkSDqtIDrpqztlZjqs6Ag7J6I7J2EIOqyveyasCwg7J20IOyYteyFmOydhCDtmZzshLHtmZTtlZjrqbQg7ISx64ql66m07JeQ7IScIOycoOumrO2VoCDsiJgg7J6I7Iq164uI64ukXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqIEBkZWZhdWx0IGZhbHNlXHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9ub1BhbmVsU3R5bGVPdmVycmlkZTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgdGhpcy5fbm9QYW5lbFN0eWxlT3ZlcnJpZGUgPSB2YWw7XG4gICAgICB2b2lkIHRoaXMucmVzaXplKCk7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcInJlc2l6ZU9uQ29udGVudHNSZWFkeVwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBFbmFibGluZyB0aGlzIG9wdGlvbiB3aWxsIGF1dG9tYXRpY2FsbHkgY2FsbCB7QGxpbmsgRmxpY2tpbmcjcmVzaXplfSB3aGVuIGFsbCBpbWFnZS92aWRlbyBpbnNpZGUgcGFuZWxzIGFyZSBsb2FkZWQuXHJcbiAgICAgKiBUaGlzIGNhbiBiZSB1c2VmdWwgd2hlbiB5b3UgaGF2ZSBjb250ZW50cyBpbnNpZGUgRmxpY2tpbmcgdGhhdCBjaGFuZ2VzIGl0cyBzaXplIHdoZW4gaXQncyBsb2FkZWRcclxuICAgICAqIEBrbyDsnbQg7Ji17IWY7J2EIO2ZnOyEse2ZlO2VoCDqsr3smrAsIEZsaWNraW5nIO2MqOuEkCDrgrTrtoDsnZgg7J2066+47KeAL+u5hOuUlOyYpOuTpOydtCDroZzrk5zrkJjsl4jsnYQg65WMIOyekOuPmeycvOuhnCB7QGxpbmsgRmxpY2tpbmcjcmVzaXplfeulvCDtmLjstpztlanri4jri6QuXHJcbiAgICAgKiDsnbQg64+Z7J6R7J2AIEZsaWNraW5nIOuCtOu2gOyXkCDroZzrk5wg7KCEL+2bhOuhnCDtgazquLDqsIAg67OA7ZWY64qUIOy9mO2FkOy4oOulvCDtj6ztlajtlZjqs6Ag7J6I7J2EIOuVjCDsnKDsmqntlZjqsowg7IKs7Jqp7ZWY7IukIOyImCDsnojsirXri4jri6QuXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqIEBkZWZhdWx0IGZhbHNlXHJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWZsaWNraW5nL09wdGlvbnMjcmVzaXplT25Db250ZW50c1JlYWR5IHJlc2l6ZU9uQ29udGVudHNSZWFkeSAoIE9wdGlvbnMgKX1cclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3Jlc2l6ZU9uQ29udGVudHNSZWFkeTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgdGhpcy5fcmVzaXplT25Db250ZW50c1JlYWR5ID0gdmFsO1xuICAgICAgaWYgKHZhbCkge1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5jaGVja1BhbmVsQ29udGVudHNSZWFkeSh0aGlzLl9yZW5kZXJlci5wYW5lbHMpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJuZXN0ZWRcIiwge1xuICAgIC8qKlxyXG4gICAgICogSWYgeW91IGVuYWJsZSB0aGlzIG9wdGlvbiBvbiBjaGlsZCBGbGlja2luZyB3aGVuIHRoZSBGbGlja2luZyBpcyBwbGFjZWQgaW5zaWRlIHRoZSBGbGlja2luZywgdGhlIHBhcmVudCBGbGlja2luZyB3aWxsIG1vdmUgaW4gdGhlIHNhbWUgZGlyZWN0aW9uIGFmdGVyIHRoZSBjaGlsZCBGbGlja2luZyByZWFjaGVzIHRoZSBmaXJzdC9sYXN0IHBhbmVsLlxyXG4gICAgICogSWYgdGhlIHBhcmVudCBGbGlja2luZyBhbmQgY2hpbGQgRmxpY2tpbmcgaGF2ZSBkaWZmZXJlbnQgaG9yaXpvbnRhbCBvcHRpb24sIHlvdSBkbyBub3QgbmVlZCB0byBzZXQgdGhpcyBvcHRpb24uXHJcbiAgICAgKiBAa28gRmxpY2tpbmcg64K067aA7JeQIEZsaWNraW5n7J20IOuwsOy5mOuQoCDrlYwg7ZWY7JyEIEZsaWNraW5n7JeQ7IScIOydtCDsmLXshZjsnYQg7Zmc7ISx7ZmU7ZWY66m0IO2VmOychCBGbGlja2luZ+ydtCDssqsv66eI7KeA66eJIO2MqOuEkOyXkCDrj4Tri6ztlZwg65Kk67aA7YSwIOqwmeydgCDrsKntlqXsnLzroZwg7IOB7JyEIEZsaWNraW5n7J20IOybgOyngeyeheuLiOuLpC5cclxuICAgICAqIOunjOyVvSDsg4HsnIQgRmxpY2tpbmfqs7wg7ZWY7JyEIEZsaWNraW5n7J20IOyEnOuhnCDri6TrpbggaG9yaXpvbnRhbCDsmLXshZjsnYQg6rCA7KeA6rOgIOyeiOuLpOuptCDsnbQg7Ji17IWY7J2EIOyEpOygle2VoCDtlYTsmpTqsIAg7JeG7Iq164uI64ukLlxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1mbGlja2luZy9PcHRpb25zI25lc3RlZCBuZXN0ZWQgKCBPcHRpb25zICl9XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9uZXN0ZWQ7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHRoaXMuX25lc3RlZCA9IHZhbDtcbiAgICAgIHZhciBheGVzID0gdGhpcy5fY29udHJvbC5jb250cm9sbGVyLmF4ZXM7XG4gICAgICBpZiAoYXhlcykge1xuICAgICAgICBheGVzLm9wdGlvbnMubmVzdGVkID0gdmFsO1xuICAgICAgfVxuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJuZWVkUGFuZWxUaHJlc2hvbGRcIiwge1xuICAgIC8vIEVWRU5UU1xuICAgIC8qKlxyXG4gICAgICogQSBUaHJlc2hvbGQgZnJvbSB2aWV3cG9ydCBlZGdlIGJlZm9yZSB0cmlnZ2VyaW5nIGBuZWVkUGFuZWxgIGV2ZW50XHJcbiAgICAgKiBAa28gYG5lZWRQYW5lbGDsnbTrsqTtirjqsIAg67Cc7IOd7ZWY6riwIOychO2VnCDrt7Dtj6ztirgg64Gd7Jy866Gc67aA7YSw7J2YIOy1nOuMgCDqsbDrpqxcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWZsaWNraW5nL09wdGlvbnMjbmVlZHBhbmVsdGhyZXNob2xkIG5lZWRQYW5lbFRocmVzaG9sZCAoIE9wdGlvbnMgKX1cclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX25lZWRQYW5lbFRocmVzaG9sZDtcbiAgICB9LFxuICAgIC8vIEVWRU5UU1xuICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgdGhpcy5fbmVlZFBhbmVsVGhyZXNob2xkID0gdmFsO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJwcmV2ZW50RXZlbnRzQmVmb3JlSW5pdFwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBXaGVuIGVuYWJsZWQsIGV2ZW50cyBhcmUgbm90IHRyaWdnZXJlZCBiZWZvcmUgYHJlYWR5YCB3aGVuIGluaXRpYWxpemluZ1xyXG4gICAgICogQGtvIO2ZnOyEse2ZlO2VoCDqsr3smrAg7LSI6riw7ZmU7IucIGByZWFkeWAg7J2067Kk7Yq4IOydtOyghOydmCDsnbTrsqTtirjqsIAg67Cc7IOd7ZWY7KeAIOyViuyKteuLiOuLpC5cclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICogQGRlZmF1bHQgdHJ1ZVxyXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1mbGlja2luZy9PcHRpb25zI3ByZXZlbnRldmVudHNiZWZvcmVpbml0IHByZXZlbnRFdmVudHNCZWZvcmVJbml0ICggT3B0aW9ucyApfVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJldmVudEV2ZW50c0JlZm9yZUluaXQ7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHRoaXMuX3ByZXZlbnRFdmVudHNCZWZvcmVJbml0ID0gdmFsO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJkZWNlbGVyYXRpb25cIiwge1xuICAgIC8vIEFOSU1BVElPTlxuICAgIC8qKlxyXG4gICAgICogRGVjZWxlcmF0aW9uIHZhbHVlIGZvciBwYW5lbCBtb3ZlbWVudCBhbmltYXRpb24gd2hpY2ggaXMgdHJpZ2dlcmVkIGJ5IHVzZXIgaW5wdXQuIEEgaGlnaGVyIHZhbHVlIG1lYW5zIGEgc2hvcnRlciBhbmltYXRpb24gdGltZVxyXG4gICAgICogQGtvIOyCrOyaqeyekOydmCDrj5nsnpHsnLzroZwg6rCA7IaN64+E6rCAIOyggeyaqeuQnCDtjKjrhJAg7J2064+ZIOyVoOuLiOuplOydtOyFmOydmCDqsJDsho3rj4QuIOqwkuydtCDrhpLsnYTsiJjroZ0g7JWg64uI66mU7J207IWYIOyLpO2WiSDsi5zqsITsnbQg7Ken7JWE7KeR64uI64ukXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgMC4wMDc1XHJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWZsaWNraW5nL09wdGlvbnMjZGVjZWxlcmF0aW9uIGRlY2VsZXJhdGlvbiAoIE9wdGlvbnMgKX1cclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2RlY2VsZXJhdGlvbjtcbiAgICB9LFxuICAgIC8vIEFOSU1BVElPTlxuICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgdGhpcy5fZGVjZWxlcmF0aW9uID0gdmFsO1xuICAgICAgdmFyIGF4ZXMgPSB0aGlzLl9jb250cm9sLmNvbnRyb2xsZXIuYXhlcztcbiAgICAgIGlmIChheGVzKSB7XG4gICAgICAgIGF4ZXMub3B0aW9ucy5kZWNlbGVyYXRpb24gPSB2YWw7XG4gICAgICB9XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcImVhc2luZ1wiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBBbiBlYXNpbmcgZnVuY3Rpb24gYXBwbGllZCB0byB0aGUgcGFuZWwgbW92ZW1lbnQgYW5pbWF0aW9uLiBEZWZhdWx0IHZhbHVlIGlzIGBlYXNlT3V0Q3ViaWNgXHJcbiAgICAgKiBAa28g7Yyo64SQIOydtOuPmSDslaDri4jrqZTsnbTshZjsl5Ag7KCB7Jqp7ZWgIGVhc2luZyDtlajsiJguIOq4sOuzuOqwkuydgCBgZWFzZU91dEN1YmljYOydtOuLpFxyXG4gICAgICogQHR5cGUge2Z1bmN0aW9ufVxyXG4gICAgICogQGRlZmF1bHQgeCA9PiAxIC0gTWF0aC5wb3coMSAtIHgsIDMpXHJcbiAgICAgKiBAc2VlIEVhc2luZyBGdW5jdGlvbnMgQ2hlYXQgU2hlZXQge0BsaW5rIGh0dHA6Ly9lYXNpbmdzLm5ldC99IDxrbz7snbTsp5Ug7ZWo7IiYIENoZWF0IFNoZWV0IHtAbGluayBodHRwOi8vZWFzaW5ncy5uZXQvfTwva28+XHJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWZsaWNraW5nL09wdGlvbnMjZWFzaW5nIEVhc2luZyAoIE9wdGlvbnMgKX1cclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2Vhc2luZztcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgdGhpcy5fZWFzaW5nID0gdmFsO1xuICAgICAgdmFyIGF4ZXMgPSB0aGlzLl9jb250cm9sLmNvbnRyb2xsZXIuYXhlcztcbiAgICAgIGlmIChheGVzKSB7XG4gICAgICAgIGF4ZXMub3B0aW9ucy5lYXNpbmcgPSB2YWw7XG4gICAgICB9XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcImR1cmF0aW9uXCIsIHtcbiAgICAvKipcclxuICAgICAqIERlZmF1bHQgZHVyYXRpb24gb2YgdGhlIGFuaW1hdGlvbiAobXMpXHJcbiAgICAgKiBAa28g65SU7Y+07Yq4IOyVoOuLiOuplOydtOyFmCDsnqzsg50g7Iuc6rCEIChtcylcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCA1MDBcclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtZmxpY2tpbmcvT3B0aW9ucyNkdXJhdGlvbiBkdXJhdGlvbiAoIE9wdGlvbnMgKX1cclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2R1cmF0aW9uO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICB0aGlzLl9kdXJhdGlvbiA9IHZhbDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwiaW5wdXRUeXBlXCIsIHtcbiAgICAvLyBJTlBVVFxuICAgIC8qKlxyXG4gICAgICogVHlwZXMgb2YgaW5wdXQgZGV2aWNlcyB0byBlbmFibGVcclxuICAgICAqIEBrbyDtmZzshLHtmZTtlaAg7J6F66ClIOyepey5mCDsooXrpZhcclxuICAgICAqIEB0eXBlIHtzdHJpbmdbXX1cclxuICAgICAqIEBkZWZhdWx0IFtcInRvdWNoXCIsIFwibW91c2VcIl1cclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtYXhlcy9PcHRpb25zI3BhbmlucHV0LW9wdGlvbnMgUG9zc2libGUgdmFsdWVzIChQYW5JbnB1dE9wdGlvbiNpbnB1dFR5cGUpfVxyXG4gICAgICogPGtvPntAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWF4ZXMvT3B0aW9ucyNwYW5pbnB1dC1vcHRpb25zIOqwgOuKpe2VnCDqsJLrk6QgKFBhbklucHV0T3B0aW9uI2lucHV0VHlwZSl9PC9rbz5cclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtZmxpY2tpbmcvT3B0aW9ucyNpbnB1dHR5cGUgaW5wdXRUeXBlICggT3B0aW9ucyApfVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5faW5wdXRUeXBlO1xuICAgIH0sXG4gICAgLy8gSU5QVVRcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHRoaXMuX2lucHV0VHlwZSA9IHZhbDtcbiAgICAgIHZhciBwYW5JbnB1dCA9IHRoaXMuX2NvbnRyb2wuY29udHJvbGxlci5wYW5JbnB1dDtcbiAgICAgIGlmIChwYW5JbnB1dCkge1xuICAgICAgICBwYW5JbnB1dC5vcHRpb25zLmlucHV0VHlwZSA9IHZhbDtcbiAgICAgIH1cbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwibW92ZVR5cGVcIiwge1xuICAgIC8qKlxyXG4gICAgICogTW92ZW1lbnQgc3R5bGUgYnkgdXNlciBpbnB1dC4gVGhpcyB3aWxsIGNoYW5nZSBpbnN0YW5jZSB0eXBlIG9mIHtAbGluayBGbGlja2luZyNjb250cm9sfVxyXG4gICAgICogWW91IGNhbiB1c2UgdGhlIHZhbHVlcyBvZiB0aGUgY29uc3RhbnQge0BsaW5rIE1PVkVfVFlQRX1cclxuICAgICAqIEBrbyDsgqzsmqnsnpAg7J6F66Cl7JeQIOydmO2VnCDsnbTrj5kg67Cp7IudLiDsnbQg6rCS7JeQIOuUsOudvCB7QGxpbmsgRmxpY2tpbmcjY29udHJvbH3snZgg7J247Iqk7YS07IqkIO2DgOyeheydtCDqsrDsoJXrkKnri4jri6RcclxuICAgICAqIOyDgeyImCB7QGxpbmsgTU9WRV9UWVBFfeyXkCDsoJXsnZjrkJwg6rCS65Ok7J2EIOydtOyaqe2VoCDsiJgg7J6I7Iq164uI64ukXHJcbiAgICAgKiBAdHlwZSB7TU9WRV9UWVBFIHwgUGFpcjxzdHJpbmcsIG9iamVjdD59XHJcbiAgICAgKiBAZGVmYXVsdCBcInNuYXBcIlxyXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1mbGlja2luZy9PcHRpb25zI21vdmV0eXBlIG1vdmVUeXBlICggT3B0aW9ucyApfVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIHxtb3ZlVHlwZXxjb250cm9sfG9wdGlvbnN8XHJcbiAgICAgKiB8Oi0tLTp8Oi0tLTp8Oi0tLTp8XHJcbiAgICAgKiB8XCJzbmFwXCJ8e0BsaW5rIFNuYXBDb250cm9sfXx8XHJcbiAgICAgKiB8XCJmcmVlU2Nyb2xsXCJ8e0BsaW5rIEZyZWVDb250cm9sfXx7QGxpbmsgRnJlZUNvbnRyb2xPcHRpb25zfXxcclxuICAgICAqXHJcbiAgICAgKiBgYGB0c1xyXG4gICAgICogaW1wb3J0IEZsaWNraW5nLCB7IE1PVkVfVFlQRSB9IGZyb20gXCJAZWdqcy9mbGlja2luZ1wiO1xyXG4gICAgICpcclxuICAgICAqIGNvbnN0IGZsaWNraW5nID0gbmV3IEZsaWNraW5nKHtcclxuICAgICAqICAgbW92ZVR5cGU6IE1PVkVfVFlQRS5TTkFQXHJcbiAgICAgKiB9KTtcclxuICAgICAqIGBgYFxyXG4gICAgICpcclxuICAgICAqIGBgYHRzXHJcbiAgICAgKiBjb25zdCBmbGlja2luZyA9IG5ldyBGbGlja2luZyh7XHJcbiAgICAgKiAgIC8vIElmIHlvdSB3YW50IG1vcmUgc3BlY2lmaWMgc2V0dGluZ3MgZm9yIHRoZSBtb3ZlVHlwZVxyXG4gICAgICogICAvLyBbbW92ZVR5cGUsIG9wdGlvbnMgZm9yIHRoYXQgbW92ZVR5cGVdXHJcbiAgICAgKiAgIC8vIEluIHRoaXMgY2FzZSwgaXQncyBbXCJmcmVlU2Nyb2xsXCIsIEZyZWVDb250cm9sT3B0aW9uc11cclxuICAgICAqICAgbW92ZVR5cGU6IFtNT1ZFX1RZUEUuRlJFRV9TQ1JPTEwsIHsgc3RvcEF0RWRnZTogdHJ1ZSB9XVxyXG4gICAgICogfSk7XHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX21vdmVUeXBlO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICB0aGlzLl9tb3ZlVHlwZSA9IHZhbDtcbiAgICAgIHZhciBwcmV2Q29udHJvbCA9IHRoaXMuX2NvbnRyb2w7XG4gICAgICB2YXIgbmV3Q29udHJvbCA9IHRoaXMuX2NyZWF0ZUNvbnRyb2woKTtcbiAgICAgIHZhciBhY3RpdmVQYW5lbCA9IHByZXZDb250cm9sLmFjdGl2ZVBhbmVsO1xuICAgICAgbmV3Q29udHJvbC5jb3B5KHByZXZDb250cm9sKTtcbiAgICAgIHZhciBwcmV2UHJvZ3Jlc3NJblBhbmVsID0gYWN0aXZlUGFuZWwgPyB0aGlzLl9jYW1lcmEuZ2V0UHJvZ3Jlc3NJblBhbmVsKGFjdGl2ZVBhbmVsKSA6IDA7XG4gICAgICB0aGlzLl9jb250cm9sID0gbmV3Q29udHJvbDtcbiAgICAgIHRoaXMuX2NvbnRyb2wudXBkYXRlUG9zaXRpb24ocHJldlByb2dyZXNzSW5QYW5lbCk7XG4gICAgICB0aGlzLl9jb250cm9sLnVwZGF0ZUlucHV0KCk7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcInRocmVzaG9sZFwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBNb3ZlbWVudCB0aHJlc2hvbGQgdG8gY2hhbmdlIHBhbmVsICh1bml0OiBweCkuIEl0IHNob3VsZCBiZSBkcmFnZ2VkIGFib3ZlIHRoZSB0aHJlc2hvbGQgdG8gY2hhbmdlIHRoZSBjdXJyZW50IHBhbmVsLlxyXG4gICAgICogQGtvIO2MqOuEkCDrs4Dqsr3snYQg7JyE7ZWcIOydtOuPmSDsnoTqs4TqsJIgKOuLqOychDogcHgpLiDso7zslrTsp4Qg6rCSIOydtOyDgeycvOuhnCDsiqTtgazroaTtlbTslbzrp4wg7Yyo64SQIOuzgOqyveydtCDqsIDriqXtlZjri6QuXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgNDBcclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtZmxpY2tpbmcvT3B0aW9ucyN0aHJlc2hvbGQgVGhyZXNob2xkICggT3B0aW9ucyApfVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdGhyZXNob2xkO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICB0aGlzLl90aHJlc2hvbGQgPSB2YWw7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcImludGVycnVwdGFibGVcIiwge1xuICAgIC8qKlxyXG4gICAgICogU2V0IGFuaW1hdGlvbiB0byBiZSBpbnRlcnJ1cHRhYmxlIGJ5IGNsaWNrL3RvdWNoLlxyXG4gICAgICogQGtvIOyCrOyaqeyekOydmCDtgbTrpq0v7YSw7LmY66GcIOyduO2VtCDslaDri4jrqZTsnbTshZjsnYQg64+E7KSR7JeQIOupiOy2nCDsiJgg7J6I64+E66GdIOyEpOygle2VqeuLiOuLpC5cclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICogQGRlZmF1bHQgdHJ1ZVxyXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1mbGlja2luZy9PcHRpb25zI2ludGVycnVwdGFibGUgSW50ZXJydXB0YWJsZSAoIE9wdGlvbnMgKX1cclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ludGVycnVwdGFibGU7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHRoaXMuX2ludGVycnVwdGFibGUgPSB2YWw7XG4gICAgICB2YXIgYXhlcyA9IHRoaXMuX2NvbnRyb2wuY29udHJvbGxlci5heGVzO1xuICAgICAgaWYgKGF4ZXMpIHtcbiAgICAgICAgYXhlcy5vcHRpb25zLmludGVycnVwdGFibGUgPSB2YWw7XG4gICAgICB9XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcImJvdW5jZVwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBUaGUgc2l6ZSB2YWx1ZSBvZiB0aGUgYm91bmNlIGFyZWEuIE9ubHkgY2FuIGJlIGVuYWJsZWQgd2hlbiBgY2lyY3VsYXI9ZmFsc2VgLlxyXG4gICAgICogWW91IGNhbiBzZXQgZGlmZmVyZW50IGJvdW5jZSB2YWx1ZSBmb3IgcHJldi9uZXh0IGRpcmVjdGlvbiBieSB1c2luZyBhcnJheS5cclxuICAgICAqIGBudW1iZXJgIGZvciBweCB2YWx1ZSwgYW5kIGBzdHJpbmdgIGZvciBweCwgYW5kICUgdmFsdWUgcmVsYXRpdmUgdG8gdmlld3BvcnQgc2l6ZS5cclxuICAgICAqIFlvdSBoYXZlIHRvIGNhbGwge0BsaW5rIENvbnRyb2wjdXBkYXRlSW5wdXR9IGFmdGVyIGNoYW5naW5nIHRoaXMgdG8gdGFrZSBlZmZlY3QuXHJcbiAgICAgKiBAa28gRmxpY2tpbmfsnbQg7LWc64yAIOyYgeyXreydhCDrhJjslrTshJwg6rCIIOyImCDsnojripQg7LWc64yAIO2BrOq4sC4gYGNpcmN1bGFyPWZhbHNlYOyduCDqsr3smrDsl5Drp4wg7IKs7Jqp7ZWgIOyImCDsnojsirXri4jri6QuXHJcbiAgICAgKiDrsLDsl7TsnYQg7Ya17ZW0IHByZXYvbmV4dCDrsKntlqXsl5Ag64yA7ZW0IOyEnOuhnCDri6Trpbgg67CU7Jq07IqkIOqwkuydhCDsp4DsoJXtlaAg7IiYIOyeiOyKteuLiOuLpC5cclxuICAgICAqIGBudW1iZXJg66W8IO2Gte2VtCBweOqwkuydhCwgYHN0aXJuZ2DsnYQg7Ya17ZW0IHB4IO2YueydgCDrt7Dtj6ztirgg7YGs6riwIOuMgOu5hCAl6rCS7J2EIOyCrOyaqe2VoCDsiJgg7J6I7Iq164uI64ukLlxyXG4gICAgICog7J20IOqwkuydhCDrs4Dqsr3si5wge0BsaW5rIENvbnRyb2wjdXBkYXRlSW5wdXR966W8IO2YuOy2nO2VtOyVvCDtlanri4jri6QuXHJcbiAgICAgKiBAdHlwZSB7c3RyaW5nIHwgbnVtYmVyIHwgQXJyYXk8c3RyaW5nIHwgbnVtYmVyPn1cclxuICAgICAqIEBkZWZhdWx0IFwiMjAlXCJcclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtZmxpY2tpbmcvT3B0aW9ucyNib3VuY2UgYm91bmNlICggT3B0aW9ucyApfVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGBgYHRzXHJcbiAgICAgKiBjb25zdCBwb3NzaWJsZU9wdGlvbnMgPSBbXHJcbiAgICAgKiAgIC8vICUgdmFsdWVzLCByZWxhdGl2ZSB0byB2aWV3cG9ydCBlbGVtZW50KFwiLmZsaWNraW5nLXZpZXdwb3J0XCIpJ3Mgc2l6ZVxyXG4gICAgICogICBcIjAlXCIsIFwiMjUlXCIsIFwiNDIlXCIsXHJcbiAgICAgKiAgIC8vIHB4IHZhbHVlcywgYXJpdGhtZXRpYyBjYWxjdWxhdGlvbiB3aXRoICgrLy0pIGlzIGFsc28gYWxsb3dlZC5cclxuICAgICAqICAgXCIwcHhcIiwgXCIxMDBweFwiLCBcIjUwJSAtIDI1cHhcIixcclxuICAgICAqICAgLy8gbnVtYmVycywgc2FtZSB0byBudW1iZXIgKyBweCAoXCIwcHhcIiwgXCIxMDBweFwiKVxyXG4gICAgICogICAwLCAxMDAsIDEwMDBcclxuICAgICAqIF07XHJcbiAgICAgKiBgYGBcclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYGBgdHNcclxuICAgICAqIGNvbnN0IGZsaWNraW5nID0gbmV3IEZsaWNraW5nKFwiI2VsXCIsIHsgYm91bmNlOiBcIjIwJVwiIH0pO1xyXG4gICAgICpcclxuICAgICAqIGZsaWNraW5nLmJvdW5jZSA9IFwiMTAwJVwiO1xyXG4gICAgICogZmxpY2tpbmcuY29udHJvbC51cGRhdGVJbnB1dCgpOyAvLyBDYWxsIHRoaXMgdG8gdXBkYXRlIVxyXG4gICAgICogYGBgXHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9ib3VuY2U7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHRoaXMuX2JvdW5jZSA9IHZhbDtcbiAgICAgIHRoaXMuX2NvbnRyb2wudXBkYXRlSW5wdXQoKTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwiaU9TRWRnZVN3aXBlVGhyZXNob2xkXCIsIHtcbiAgICAvKipcclxuICAgICAqIFNpemUgb2YgdGhlIGFyZWEgZnJvbSB0aGUgcmlnaHQgZWRnZSBpbiBpT1Mgc2FmYXJpIChpbiBweCkgd2hpY2ggZW5hYmxlcyBzd2lwZS1iYWNrIG9yIHN3aXBlLWZvcndhcmRcclxuICAgICAqIEBrbyBpT1MgU2FmYXJp7JeQ7IScIHN3aXBl66W8IO2Gte2VnCDrkqTroZzqsIDquLAv7JWe7Jy866Gc6rCA6riw66W8IO2ZnOyEse2ZlO2VmOuKlCDsmKTrpbjsqr0g64Gd7Jy866Gc67aA7YSw7J2YIOyYgeyXreydmCDtgazquLAgKHB4KVxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDMwXHJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWZsaWNraW5nL09wdGlvbnMjaW9zZWRnZXN3aXBldGhyZXNob2xkIGlPU0VkZ2VTd2lwZVRocmVzaG9sZCAoIE9wdGlvbnMgKX1cclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2lPU0VkZ2VTd2lwZVRocmVzaG9sZDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgdGhpcy5faU9TRWRnZVN3aXBlVGhyZXNob2xkID0gdmFsO1xuICAgICAgdmFyIHBhbklucHV0ID0gdGhpcy5fY29udHJvbC5jb250cm9sbGVyLnBhbklucHV0O1xuICAgICAgaWYgKHBhbklucHV0KSB7XG4gICAgICAgIHBhbklucHV0Lm9wdGlvbnMuaU9TRWRnZVN3aXBlVGhyZXNob2xkID0gdmFsO1xuICAgICAgfVxuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJwcmV2ZW50Q2xpY2tPbkRyYWdcIiwge1xuICAgIC8qKlxyXG4gICAgICogQXV0b21hdGljYWxseSBwcmV2ZW50IGBjbGlja2AgZXZlbnQgaWYgdGhlIHVzZXIgaGFzIGRyYWdnZWQgYXQgbGVhc3QgYSBzaW5nbGUgcGl4ZWwgb24gdGhlIHZpZXdwb3J0IGVsZW1lbnRcclxuICAgICAqIEBrbyDsgqzsmqnsnpDqsIAg67ew7Y+s7Yq4IOyYgeyXreydhCAx7ZS97IWA7J20652864+EIOuTnOuemOq3uO2WiOydhCDqsr3smrAg7J6Q64+Z7Jy866GcIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9rby9kb2NzL1dlYi9BUEkvRWxlbWVudC9jbGlja19ldmVudCBjbGlja30g7J2067Kk7Yq466W8IOy3qOyGjO2VqeuLiOuLpFxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKiBAZGVmYXVsdCB0cnVlXHJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWZsaWNraW5nL09wdGlvbnMjcHJldmVudGNsaWNrb25kcmFnIHByZXZlbnRDbGlja09uRHJhZyAoIE9wdGlvbnMgKX1cclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3ByZXZlbnRDbGlja09uRHJhZztcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgdmFyIHByZXZWYWwgPSB0aGlzLl9wcmV2ZW50Q2xpY2tPbkRyYWc7XG4gICAgICBpZiAodmFsID09PSBwcmV2VmFsKSByZXR1cm47XG4gICAgICB2YXIgY29udHJvbGxlciA9IHRoaXMuX2NvbnRyb2wuY29udHJvbGxlcjtcbiAgICAgIGlmICh2YWwpIHtcbiAgICAgICAgY29udHJvbGxlci5hZGRQcmV2ZW50Q2xpY2tIYW5kbGVyKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250cm9sbGVyLnJlbW92ZVByZXZlbnRDbGlja0hhbmRsZXIoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3ByZXZlbnRDbGlja09uRHJhZyA9IHZhbDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwicHJldmVudERlZmF1bHRPbkRyYWdcIiwge1xuICAgIC8qKlxyXG4gICAgICogV2hldGhlciB0byB1c2UgdGhlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9rby9kb2NzL1dlYi9BUEkvRXZlbnQvcHJldmVudERlZmF1bHQgcHJldmVudERlZmF1bHR9IHdoZW4gdGhlIHVzZXIgc3RhcnRzIGRyYWdnaW5nXHJcbiAgICAgKiBAa28g7IKs7Jqp7J6Q6rCAIOuTnOuemOq3uOulvCDsi5zsnpHtlaAg65WMIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9rby9kb2NzL1dlYi9BUEkvRXZlbnQvcHJldmVudERlZmF1bHQgcHJldmVudERlZmF1bHR9IOyLpO2WiSDsl6zrtoBcclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICogQGRlZmF1bHQgZmFsc2VcclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtZmxpY2tpbmcvT3B0aW9ucyNwcmV2ZW50RGVmYXVsdE9uRHJhZyBwcmV2ZW50RGVmYXVsdE9uRHJhZyAoIE9wdGlvbnMgKX1cclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3ByZXZlbnREZWZhdWx0T25EcmFnO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICB0aGlzLl9wcmV2ZW50RGVmYXVsdE9uRHJhZyA9IHZhbDtcbiAgICAgIHZhciBwYW5JbnB1dCA9IHRoaXMuX2NvbnRyb2wuY29udHJvbGxlci5wYW5JbnB1dDtcbiAgICAgIGlmIChwYW5JbnB1dCkge1xuICAgICAgICBwYW5JbnB1dC5vcHRpb25zLnByZXZlbnREZWZhdWx0T25EcmFnID0gdmFsO1xuICAgICAgfVxuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJkaXNhYmxlT25Jbml0XCIsIHtcbiAgICAvKipcclxuICAgICAqIEF1dG9tYXRpY2FsbHkgY2FsbCB7QGxpbmsgRmxpY2tpbmcjZGlzYWJsZUlucHV0IGRpc2FibGVJbnB1dCgpfSBvbiBpbml0aWFsaXphdGlvblxyXG4gICAgICogQGtvIEZsaWNraW5nIGluaXTsi5zsl5Age0BsaW5rIEZsaWNraW5nI2Rpc2FibGVJbnB1dCBkaXNhYmxlSW5wdXQoKX3snYQg67CU66GcIO2YuOy2nO2VqeuLiOuLpFxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1mbGlja2luZy9PcHRpb25zI2Rpc2FibGVvbmluaXQgZGlzYWJsZU9uSW5pdCAoIE9wdGlvbnMgKX1cclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2Rpc2FibGVPbkluaXQ7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHRoaXMuX2Rpc2FibGVPbkluaXQgPSB2YWw7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcImNoYW5nZU9uSG9sZFwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBDaGFuZ2UgYWN0aXZlIHBhbmVsIGluZGV4IG9uIG1vdXNlL3RvdWNoIGhvbGQgd2hpbGUgYW5pbWF0aW5nLlxyXG4gICAgICogYGluZGV4YCBvZiB0aGUgYHdpbGxDaGFuZ2VgL2B3aWxsUmVzdG9yZWAgZXZlbnQgd2lsbCBiZSB1c2VkIGFzIG5ldyBpbmRleC5cclxuICAgICAqIEBrbyDslaDri4jrqZTsnbTshZgg64+E7KSRIOuniOyasOyKpC/thLDsuZgg7J6F66Cl7IucIO2YhOyerCDtmZzshLHtmZTrkJwg7Yyo64SQ7J2YIOyduOuNseyKpOulvCDrs4Dqsr3tlanri4jri6QuXHJcbiAgICAgKiBgd2lsbENoYW5nZWAvYHdpbGxSZXN0b3JlYCDsnbTrsqTtirjsnZggYGluZGV4YOqwkuydtCDsg4jroZzsmrQg7J24642x7Iqk66GcIOyCrOyaqeuQoCDqsoPsnoXri4jri6QuXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqIEBkZWZhdWx0IGZhbHNlXHJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWZsaWNraW5nL09wdGlvbnMjY2hhbmdlb25ob2xkIGNoYW5nZU9uSG9sZCAoIE9wdGlvbnMgKX1cclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NoYW5nZU9uSG9sZDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgdGhpcy5fY2hhbmdlT25Ib2xkID0gdmFsO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJyZW5kZXJPbmx5VmlzaWJsZVwiLCB7XG4gICAgLy8gUEVSRk9STUFOQ0VcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgdG8gcmVuZGVyIHZpc2libGUgcGFuZWxzIG9ubHkuIFRoaXMgY2FuIGRyYW1hdGljYWxseSBpbmNyZWFzZSBwZXJmb3JtYW5jZSB3aGVuIHRoZXJlJ3JlIG1hbnkgcGFuZWxzXHJcbiAgICAgKiBAa28g67O07J2064qUIO2MqOuEkOunjCDroIzrjZTrp4HtlaDsp4Ag7Jes67aA66W8IOyEpOygle2VqeuLiOuLpC4g7Yyo64SQ7J20IOunjuydhCDqsr3smrDsl5Ag7Y287Y+s66i87Iqk66W8IO2BrOqyjCDtlqXsg4Hsi5ztgqwg7IiYIOyeiOyKteuLiOuLpFxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1mbGlja2luZy9PcHRpb25zI3JlbmRlcm9ubHl2aXNpYmxlIHJlbmRlck9ubHlWaXNpYmxlICggT3B0aW9ucyApfVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVuZGVyT25seVZpc2libGU7XG4gICAgfSxcbiAgICAvLyBQRVJGT1JNQU5DRVxuICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgdGhpcy5fcmVuZGVyT25seVZpc2libGUgPSB2YWw7XG4gICAgICB2b2lkIHRoaXMuX3JlbmRlcmVyLnJlbmRlcigpO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJ2aXJ0dWFsXCIsIHtcbiAgICAvKipcclxuICAgICAqIEJ5IGVuYWJsaW5nIHRoaXMgb3B0aW9uLCBpdCB3aWxsIHJlZHVjZSBtZW1vcnkgY29uc3VtcHRpb24gYnkgcmVzdHJpY3RpbmcgdGhlIG51bWJlciBvZiBET00gZWxlbWVudHMgdG8gYHBhbmVsc1BlclZpZXcgKyAxYFxyXG4gICAgICogTXVzdCBiZSB1c2VkIHdpdGggYHBhbmVsc1BlcnZpZXdgLlxyXG4gICAgICogQWZ0ZXIgRmxpY2tpbmcncyBpbml0aWFsaXplZCwgdGhpcyBwcm9wZXJ0eSBjYW4gYmUgdXNlZCB0byBhZGQvcmVtb3ZlIHRoZSBwYW5lbCBjb3VudC5cclxuICAgICAqIEBrbyDsnbQg7Ji17IWY7J2EIO2ZnOyEse2ZlO2VoCDqsr3smrAg7Yyo64SQIOyXmOumrOuovO2KuOydmCDqsJzsiJjrpbwgYHBhbmVsc1BlclZpZXcgKyAxYCDqsJzroZwg6rOg7KCV7ZWo7Jy866Gc7I2oLCDrqZTrqqjrpqwg7IKs7Jqp65+J7J2EIOykhOydvCDsiJgg7J6I7Iq164uI64ukLlxyXG4gICAgICogYHBhbmVsc1BlclZpZXdgIOyYteyFmOqzvCDtlajqu5gg7IKs7Jqp65CY7Ja07JW866eMIO2VqeuLiOuLpC5cclxuICAgICAqIEZsaWNraW5nIOy0iOq4sO2ZlCDsnbTtm4Tsl5AsIOydtCDtlITroZztjbzti7DripQg66CM642U66eB7ZWY64qUIO2MqOuEkOydmCDqsJzsiJjrpbwg7LaU6rCAL+ygnOqxsO2VmOq4sCDsnITtlbQg7IKs7Jqp65CgIOyImCDsnojsirXri4jri6QuXHJcbiAgICAgKiBAdHlwZSB7VmlydHVhbE1hbmFnZXJ9XHJcbiAgICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSByZW5kZXJQYW5lbCBBIHJlbmRlcmluZyBmdW5jdGlvbiBmb3IgdGhlIHBhbmVsIGVsZW1lbnQncyBpbm5lckhUTUw8a28+7Yyo64SQIOyXmOumrOuovO2KuOydmCBpbm5lckhUTUzsnYQg66CM642U66eB7ZWY64qUIO2VqOyImDwva28+XHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gaW5pdGlhbFBhbmVsQ291bnQgSW5pdGlhbCBwYW5lbCBjb3VudCB0byByZW5kZXI8a28+7LWc7LSI66GcIOugjOuNlOunge2VoCDtjKjrhJDsnZgg6rCc7IiYPC9rbz5cclxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2NhY2hlPWZhbHNlXSBXaGV0aGVyIHRvIGNhY2hlIHJlbmRlcmVkIHBhbmVsJ3MgaW5uZXJIVE1MPGtvPuugjOuNlOungeuQnCDtjKjrhJDsnZggaW5uZXJIVE1MIOygleuztOulvCDsupDsi5ztlaDsp4Ag7Jes67aAPC9rbz5cclxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbcGFuZWxDbGFzcz1cImZsaWNraW5nLXBhbmVsXCJdIFRoZSBjbGFzcyBuYW1lIHRoYXQgd2lsbCBiZSBhcHBsaWVkIHRvIHJlbmRlcmVkIHBhbmVsIGVsZW1lbnRzPGtvPuugjOuNlOungeuQmOuKlCDtjKjrhJAg7JeY66as66i87Yq47JeQIOyggeyaqeuQoCDtgbTrnpjsiqQg7J2066aEPC9rbz5cclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtZmxpY2tpbmcvT3B0aW9ucyN2aXJ0dWFsIHZpcnR1YWwgKCBPcHRpb25zICl9XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYGBgdHNcclxuICAgICAqIGltcG9ydCBGbGlja2luZywgeyBWaXJ0dWFsUGFuZWwgfSBmcm9tIFwiQGVnanMvZmxpY2tpbmdcIjtcclxuICAgICAqXHJcbiAgICAgKiBjb25zdCBmbGlja2luZyA9IG5ldyBGbGlja2luZyhcIiNzb21lX2VsXCIsIHtcclxuICAgICAqICAgcGFuZWxzUGVyVmlldzogMyxcclxuICAgICAqICAgdmlydHVhbDoge1xyXG4gICAgICogICAgIHJlbmRlclBhbmVsOiAocGFuZWw6IFZpcnR1YWxQYW5lbCwgaW5kZXg6IG51bWJlcikgPT4gYFBhbmVsICR7aW5kZXh9YCxcclxuICAgICAqICAgICBpbml0aWFsUGFuZWxDb3VudDogMTAwXHJcbiAgICAgKiAgIH1cclxuICAgICAqIH0pO1xyXG4gICAgICpcclxuICAgICAqIC8vIEFkZCAxMDAgdmlydHVhbCBwYW5lbHMgKGF0IHRoZSBlbmQpXHJcbiAgICAgKiBmbGlja2luZy52aXJ0dWFsLmFwcGVuZCgxMDApO1xyXG4gICAgICpcclxuICAgICAqIC8vIFJlbW92ZSAxMDAgdmlydHVhbCBwYW5lbHMgZnJvbSAwIHRvIDEwMFxyXG4gICAgICogZmxpY2tpbmcudmlydHVhbC5yZW1vdmUoMCwgMTAwKTtcclxuICAgICAqIGBgYFxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdmlydHVhbE1hbmFnZXI7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcImF1dG9Jbml0XCIsIHtcbiAgICAvLyBPVEhFUlNcbiAgICAvKipcclxuICAgICAqIENhbGwge0BsaW5rIEZsaWNraW5nI2luaXQgaW5pdCgpfSBhdXRvbWF0aWNhbGx5IHdoZW4gY3JlYXRpbmcgRmxpY2tpbmcncyBpbnN0YW5jZVxyXG4gICAgICogQGtvIEZsaWNraW5nIOyduOyKpO2EtOyKpOulvCDsg53shLHtlaAg65WMIOyekOuPmeycvOuhnCB7QGxpbmsgRmxpY2tpbmcjaW5pdCBpbml0KCl966W8IO2YuOy2nO2VqeuLiOuLpFxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKiBAZGVmYXVsdCB0cnVlXHJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWZsaWNraW5nL09wdGlvbnMjYXV0b2luaXQgYXV0b0luaXQgKCBPcHRpb25zICl9XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2F1dG9Jbml0O1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJhdXRvUmVzaXplXCIsIHtcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgdG8gYXV0b21hdGljYWxseSBjYWxsIHtAbGluayBGbGlja2luZyNyZXNpemUgcmVzaXplKCl9IHdoZW4gdGhlIHZpZXdwb3J0IGVsZW1lbnQoLmZsaWNraW5nLXZpZXdwb3J0KSdzIHNpemUgaXMgY2hhbmdlZFxyXG4gICAgICogQGtvIOu3sO2PrO2KuCDsl5jrpqzrqLztirgoLmZsaWNraW5nLXZpZXdwb3J0KeydmCDtgazquLAg67OA6rK97IucIHtAbGluayBGbGlja2luZyNyZXNpemUgcmVzaXplKCl9IOuplOyGjOuTnOulvCDsnpDrj5nsnLzroZwg7Zi47Lac7ZWg7KeAIOyXrOu2gOulvCDshKTsoJXtlanri4jri6RcclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICogQGRlZmF1bHQgdHJ1ZVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYXV0b1Jlc2l6ZTtcbiAgICB9LFxuICAgIC8vIE9USEVSU1xuICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgdGhpcy5fYXV0b1Jlc2l6ZSA9IHZhbDtcbiAgICAgIGlmICh2YWwpIHtcbiAgICAgICAgdGhpcy5fYXV0b1Jlc2l6ZXIuZW5hYmxlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9hdXRvUmVzaXplci5kaXNhYmxlKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcInVzZVJlc2l6ZU9ic2VydmVyXCIsIHtcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgdG8gbGlzdGVuIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvUmVzaXplT2JzZXJ2ZXIgUmVzaXplT2JzZXJ2ZXJ9J3MgZXZlbnQgaW5zdGVhZCBvZiBXaW5kb3cncyB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcva28vZG9jcy9XZWIvQVBJL1dpbmRvdy9yZXNpemVfZXZlbnQgcmVzaXplfSBldmVudCB3aGVuIHVzaW5nIHRoZSBgYXV0b1Jlc2l6ZWAgb3B0aW9uXHJcbiAgICAgKiBAa28gYXV0b1Jlc2l6ZSDsmLXshZgg7IKs7Jqp7IucIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvUmVzaXplT2JzZXJ2ZXIgUmVzaXplT2JzZXJ2ZXJ97J2YIOydtOuypO2KuOulvCBXaW5kb3fqsJ3ssrTsnZgge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2tvL2RvY3MvV2ViL0FQSS9XaW5kb3cvcmVzaXplX2V2ZW50IHJlc2l6ZX0g7J2067Kk7Yq4IOuMgOyLoCDsiJjsi6DtlaDsp4Ag7Jes67aA66W8IOyEpOygle2VqeuLiOuLpFxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKiBAZGVmYXVsdCB0cnVlXHJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWZsaWNraW5nL09wdGlvbnMjdXNlcmVzaXplb2JzZXJ2ZXIgdXNlUmVzaXplT2JzZXJ2ZXIgKCBPcHRpb25zICl9XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl91c2VSZXNpemVPYnNlcnZlcjtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgdGhpcy5fdXNlUmVzaXplT2JzZXJ2ZXIgPSB2YWw7XG4gICAgICBpZiAodGhpcy5fYXV0b1Jlc2l6ZSkge1xuICAgICAgICB0aGlzLl9hdXRvUmVzaXplci5lbmFibGUoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwicmVzaXplRGVib3VuY2VcIiwge1xuICAgIC8qKlxyXG4gICAgICogRGVsYXlzIHNpemUgcmVjYWxjdWxhdGlvbiBmcm9tIGBhdXRvUmVzaXplYCBieSB0aGUgZ2l2ZW4gdGltZSBpbiBtaWxpc2Vjb25kLlxyXG4gICAgICogSWYgdGhlIHNpemUgaXMgY2hhbmdlZCBhZ2FpbiB3aGlsZSBiZWluZyBkZWxheWVkLCBpdCBjYW5jZWxzIHRoZSBwcmV2aW91cyBvbmUgYW5kIGRlbGF5cyBmcm9tIHRoZSBiZWdpbm5pbmcgYWdhaW4uXHJcbiAgICAgKiBUaGlzIGNhbiBpbmNyZWFzZSBwZXJmb3JtYW5jZSBieSBwcmV2ZW50aW5nIGByZXNpemVgIGJlaW5nIGNhbGxlZCB0b28gb2Z0ZW4uXHJcbiAgICAgKiBAa28gYGF1dG9SZXNpemVgIOyEpOygleyLnOyXkCDtmLjstpzrkJjripQg7YGs6riwIOyerOqzhOyCsOydhCDso7zslrTsp4Qg7Iuc6rCEKOuLqOychDogbXMp66eM7YG8IOyngOyXsOyLnO2CteuLiOuLpC5cclxuICAgICAqIOyngOyXsOyLnO2CpOuKlCDrj4TspJEg7YGs6riw6rCAIOuLpOyLnCDrs4Dqsr3rkJjsl4jsnYQg6rK97JqwLCDsnbTsoIQg6rKD7J2EIOy3qOyGjO2VmOqzoCDso7zslrTsp4Qg7Iuc6rCE66eM7YG8IOuLpOyLnCDsp4Dsl7Dsi5ztgrXri4jri6QuXHJcbiAgICAgKiDsnbTrpbwg7Ya17ZW0IGByZXNpemVg6rCAIOuEiOustCDrp47snbQg7Zi47Lac65CY64qUIOqyg+ydhCDrsKnsp4DtlZjsl6wg7ISx64ql7J2EIO2WpeyDgeyLnO2CrCDsiJgg7J6I7Iq164uI64ukLlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtZmxpY2tpbmcvT3B0aW9ucyNyZXNpemVkZWJvdW5jZSByZXNpemVEZWJvdW5jZSAoIE9wdGlvbnMgKX1cclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3Jlc2l6ZURlYm91bmNlO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJtYXhSZXNpemVEZWJvdW5jZVwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbWF4aW11bSB0aW1lIGZvciBzaXplIHJlY2FsY3VsYXRpb24gZGVsYXkgd2hlbiB1c2luZyBgcmVzaXplRGVib3VuY2VgLCBpbiBtaWxpc2Vjb25kLlxyXG4gICAgICogVGhpcyBndWFyYW50ZWVzIHRoYXQgc2l6ZSByZWNhbGN1bGF0aW9uIGlzIHBlcmZvcm1lZCBhdCBsZWFzdCBvbmNlIGV2ZXJ5IChuKW1zLlxyXG4gICAgICogQGtvIGByZXNpemVEZWJvdW5jZWAg7IKs7Jqp7Iuc7JeQIO2BrOq4sCDsnqzqs4TsgrDsnbQg7KeA7Jew65CY64qUIOy1nOuMgCDsi5zqsITsnYQg7KeA7KCV7ZWp64uI64ukLiAo64uo7JyEOiBtcylcclxuICAgICAqIOydtOulvCDthrXtlbQsIOyggeyWtOuPhCAobiltc+yXkCDtlZzrsojsnYAg7YGs6riwIOyerOqzhOyCsOydhCDsiJjtlontlZjripQg6rKD7J2EIOuztOyepe2VoCDsiJgg7J6I7Iq164uI64ukLlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDEwMFxyXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1mbGlja2luZy9PcHRpb25zI21heHJlc2l6ZWRlYm91bmNlIG1heFJlc2l6ZURlYm91bmNlICggT3B0aW9ucyApfVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbWF4UmVzaXplRGVib3VuY2U7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcInVzZUZyYWN0aW9uYWxTaXplXCIsIHtcbiAgICAvKipcclxuICAgICAqIEJ5IGVuYWJsaW5nIHRoaXMsIEZsaWNraW5nIHdpbGwgY2FsY3VsYXRlIGFsbCBpbnRlcm5hbCBzaXplIHdpdGggQ1NTIHdpZHRoIGNvbXB1dGVkIHdpdGggZ2V0Q29tcHV0ZWRTdHlsZS5cclxuICAgICAqIFRoaXMgY2FuIHByZXZlbnQgMXB4IG9mZnNldCBpc3N1ZSBpbiBzb21lIGNhc2VzIHdoZXJlIHBhbmVsIHNpemUgaGFzIHRoZSBmcmFjdGlvbmFsIHBhcnQuXHJcbiAgICAgKiBBbGwgc2l6ZXMgd2lsbCBoYXZlIHRoZSBvcmlnaW5hbCBzaXplIGJlZm9yZSBDU1Mge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy90cmFuc2Zvcm0gdHJhbnNmb3JtfSBpcyBhcHBsaWVkIG9uIHRoZSBlbGVtZW50LlxyXG4gICAgICogQGtvIOydtCDsmLXshZjsnYQg7Zmc7ISx7ZmU7ZWgIOqyveyasCwgRmxpY2tpbmfsnYAg64K067aA7J2YIOuqqOuToCDtgazquLDrpbwge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50L2dldEJvdW5kaW5nQ2xpZW50UmVjdCBnZXRCb3VuZGluZ0NsaWVudFJlY3R966W8IOydtOyaqe2VmOyXrCDqs4TsgrDtlanri4jri6QuXHJcbiAgICAgKiDsnbTrpbwg7Ya17ZW0LCDtjKjrhJAg7YGs6riw7JeQIOyGjOyImOygkOydhCDtj6ztlajtlaAg6rK97Jqw7JeQIOuwnOyDne2VoCDsiJgg7J6I64qUIOydvOu2gCAxcHgg7Jik7ZSE7IWLIOydtOyKiOulvCDtlbTqsrAg6rCA64ql7ZWp64uI64ukLlxyXG4gICAgICog66qo65OgIO2BrOq4sOuKlCBDU1Mge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy90cmFuc2Zvcm0gdHJhbnNmb3JtfeydtCDsl5jrpqzrqLztirjsl5Ag7KCB7Jqp65CY6riwIOydtOyghOydmCDtgazquLDrpbwg7IKs7Jqp7ZWgIOqyg+yeheuLiOuLpC5cclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICogQGRlZmF1bHQgZmFsc2VcclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtZmxpY2tpbmcvT3B0aW9ucyN1c2VmcmFjdGlvbmFsc2l6ZSB1c2VGcmFjdGlvbmFsU2l6ZSAoIE9wdGlvbnMgKX1cclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3VzZUZyYWN0aW9uYWxTaXplO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJleHRlcm5hbFJlbmRlcmVyXCIsIHtcbiAgICAvKipcclxuICAgICAqIFRoaXMgaXMgYW4gb3B0aW9uIGZvciB0aGUgZnJhbWV3b3JrcyhSZWFjdCwgVnVlLCBBbmd1bGFyLCAuLi4pLiBEb24ndCBzZXQgaXQgYXMgaXQncyBhdXRvbWF0aWNhbGx5IG1hbmFnZWQgYnkgRmxpY2tpbmcuXHJcbiAgICAgKiBAa28g7ZSE66CI7J6E7JuM7YGsKFJlYWN0LCBWdWUsIEFuZ3VsYXIsIC4uLinsl5DshJzrp4wg7IKs7Jqp7ZWY64qUIOyYteyFmOycvOuhnCwg7J6Q64+Z7Jy866GcIOyEpOygleuQmOuvgOuhnCDrlLDroZwg7IKs7Jqp7ZWY7IukIO2VhOyalCDsl4bsirXri4jri6QhXHJcbiAgICAgKiBAZGVmYXVsdCBudWxsXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZXh0ZXJuYWxSZW5kZXJlcjtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwicmVuZGVyRXh0ZXJuYWxcIiwge1xuICAgIC8qKlxyXG4gICAgICogVGhpcyBpcyBhbiBvcHRpb24gZm9yIHRoZSBmcmFtZXdvcmtzKFJlYWN0LCBWdWUsIEFuZ3VsYXIsIC4uLikuIERvbid0IHNldCBpdCBhcyBpdCdzIGF1dG9tYXRpY2FsbHkgbWFuYWdlZCBieSBGbGlja2luZy5cclxuICAgICAqIEBrbyDtlITroIjsnoTsm4ztgawoUmVhY3QsIFZ1ZSwgQW5ndWxhciwgLi4uKeyXkOyEnOunjCDsgqzsmqntlZjripQg7Ji17IWY7Jy866GcLCDsnpDrj5nsnLzroZwg7ISk7KCV65CY66+A66GcIOuUsOuhnCDsgqzsmqntlZjsi6Qg7ZWE7JqUIOyXhuyKteuLiOuLpCFcclxuICAgICAqIEBkZWZhdWx0IG51bGxcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKiBAZGVwcmVjYXRlZFxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVuZGVyRXh0ZXJuYWw7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIC8qKlxyXG4gICAqIEluaXRpYWxpemUgRmxpY2tpbmcgYW5kIG1vdmUgdG8gdGhlIGRlZmF1bHQgaW5kZXhcclxuICAgKiBUaGlzIGlzIGF1dG9tYXRpY2FsbHkgY2FsbGVkIG9uIEZsaWNraW5nJ3MgY29uc3RydWN0b3Igd2hlbiBgYXV0b0luaXRgIGlzIHRydWUoZGVmYXVsdClcclxuICAgKiBAa28gRmxpY2tpbmfsnYQg7LSI6riw7ZmU7ZWY6rOgLCDrlJTtj7Ttirgg7J24642x7Iqk66GcIOydtOuPme2VqeuLiOuLpFxyXG4gICAqIOydtCDrqZTshozrk5zripQgYGF1dG9Jbml0YCDsmLXshZjsnbQgdHJ1ZShkZWZhdWx0KeydvCDqsr3smrAgRmxpY2tpbmfsnbQg7IOd7ISx65CgIOuVjCDsnpDrj5nsnLzroZwg7Zi47Lac65Cp64uI64ukXHJcbiAgICogQGZpcmVzIEZsaWNraW5nI3JlYWR5XHJcbiAgICogQHJldHVybiB7UHJvbWlzZTx2b2lkPn1cclxuICAgKi9cbiAgX19wcm90by5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgaWYgKHRoaXMuX2luaXRpYWxpemVkKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgdmFyIGNhbWVyYSA9IHRoaXMuX2NhbWVyYTtcbiAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLl9yZW5kZXJlcjtcbiAgICB2YXIgY29udHJvbCA9IHRoaXMuX2NvbnRyb2w7XG4gICAgdmFyIHZpcnR1YWxNYW5hZ2VyID0gdGhpcy5fdmlydHVhbE1hbmFnZXI7XG4gICAgdmFyIG9yaWdpbmFsVHJpZ2dlciA9IHRoaXMudHJpZ2dlcjtcbiAgICB2YXIgcHJldmVudEV2ZW50c0JlZm9yZUluaXQgPSB0aGlzLl9wcmV2ZW50RXZlbnRzQmVmb3JlSW5pdDtcbiAgICBjYW1lcmEuaW5pdCgpO1xuICAgIHZpcnR1YWxNYW5hZ2VyLmluaXQoKTtcbiAgICByZW5kZXJlci5pbml0KHRoaXMpO1xuICAgIGNvbnRyb2wuaW5pdCh0aGlzKTtcbiAgICBpZiAocHJldmVudEV2ZW50c0JlZm9yZUluaXQpIHtcbiAgICAgIHRoaXMudHJpZ2dlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgfTtcbiAgICB9XG4gICAgdGhpcy5faW5pdGlhbFJlc2l6ZSgpO1xuICAgIC8vIExvb2sgYXQgaW5pdGlhbCBwYW5lbFxuICAgIHRoaXMuX21vdmVUb0luaXRpYWxQYW5lbCgpO1xuICAgIGlmICh0aGlzLl9hdXRvUmVzaXplKSB7XG4gICAgICB0aGlzLl9hdXRvUmVzaXplci5lbmFibGUoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3ByZXZlbnRDbGlja09uRHJhZykge1xuICAgICAgY29udHJvbC5jb250cm9sbGVyLmFkZFByZXZlbnRDbGlja0hhbmRsZXIoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2Rpc2FibGVPbkluaXQpIHtcbiAgICAgIHRoaXMuZGlzYWJsZUlucHV0KCk7XG4gICAgfVxuICAgIHJlbmRlcmVyLmNoZWNrUGFuZWxDb250ZW50c1JlYWR5KHJlbmRlcmVyLnBhbmVscyk7XG4gICAgdGhpcy5faW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIHJldHVybiByZW5kZXJlci5yZW5kZXIoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIERvbmUgaW5pdGlhbGl6aW5nICYgZW1pdCByZWFkeSBldmVudFxuICAgICAgX3RoaXMuX3BsdWdpbnMuZm9yRWFjaChmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgICAgIHJldHVybiBwbHVnaW4uaW5pdChfdGhpcyk7XG4gICAgICB9KTtcbiAgICAgIGlmIChwcmV2ZW50RXZlbnRzQmVmb3JlSW5pdCkge1xuICAgICAgICBfdGhpcy50cmlnZ2VyID0gb3JpZ2luYWxUcmlnZ2VyO1xuICAgICAgfVxuICAgICAgX3RoaXMudHJpZ2dlcihuZXcgQ29tcG9uZW50RXZlbnQkMShFVkVOVFMuUkVBRFkpKTtcbiAgICB9KTtcbiAgfTtcbiAgLyoqXHJcbiAgICogRGVzdHJveSBGbGlja2luZyBhbmQgcmVtb3ZlIGFsbCBldmVudCBoYW5kbGVyc1xyXG4gICAqIEBrbyBGbGlja2luZ+qzvCDtlZjsnIQg7Lu07Y+s64SM7Yq465Ok7J2EIOy0iOq4sCDsg4Htg5zroZwg65CY64+M66as6rOgLCDrtoDssKnrkJwg66qo65OgIOydtOuypO2KuCDtlbjrk6Trn6zrpbwg7KCc6rGw7ZWp64uI64ukXHJcbiAgICogQHJldHVybiB7dm9pZH1cclxuICAgKi9cbiAgX19wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMub2ZmKCk7XG4gICAgdGhpcy5fYXV0b1Jlc2l6ZXIuZGlzYWJsZSgpO1xuICAgIHRoaXMuX2NvbnRyb2wuZGVzdHJveSgpO1xuICAgIHRoaXMuX2NhbWVyYS5kZXN0cm95KCk7XG4gICAgdGhpcy5fcmVuZGVyZXIuZGVzdHJveSgpO1xuICAgIHRoaXMuX3BsdWdpbnMuZm9yRWFjaChmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgICByZXR1cm4gcGx1Z2luLmRlc3Ryb3koKTtcbiAgICB9KTtcbiAgICB0aGlzLl9pbml0aWFsaXplZCA9IGZhbHNlO1xuICB9O1xuICAvKipcclxuICAgKiBNb3ZlIHRvIHRoZSBwcmV2aW91cyBwYW5lbCAoY3VycmVudCBpbmRleCAtIDEpXHJcbiAgICogQGtvIOydtOyghCDtjKjrhJDroZwg7J2064+Z7ZWp64uI64ukICjtmITsnqwg7J24642x7IqkIC0gMSlcclxuICAgKiBAcGFyYW0ge251bWJlcn0gW2R1cmF0aW9uPXtAbGluayBGbGlja2luZyNkdXJhdGlvbiBvcHRpb25zLmR1cmF0aW9ufV0gRHVyYXRpb24gb2YgdGhlIHBhbmVsIG1vdmVtZW50IGFuaW1hdGlvbiAodW5pdDogbXMpPGtvPu2MqOuEkCDsnbTrj5kg7JWg64uI66mU7J207IWYIOynhO2WiSDsi5zqsIQgKOuLqOychDogbXMpPC9rbz5cclxuICAgKiBAYXN5bmNcclxuICAgKiBAZmlyZXMgRmxpY2tpbmcjbW92ZVN0YXJ0XHJcbiAgICogQGZpcmVzIEZsaWNraW5nI21vdmVcclxuICAgKiBAZmlyZXMgRmxpY2tpbmcjbW92ZUVuZFxyXG4gICAqIEBmaXJlcyBGbGlja2luZyN3aWxsQ2hhbmdlXHJcbiAgICogQGZpcmVzIEZsaWNraW5nI2NoYW5nZWRcclxuICAgKiBAZmlyZXMgRmxpY2tpbmcjd2lsbFJlc3RvcmVcclxuICAgKiBAZmlyZXMgRmxpY2tpbmcjcmVzdG9yZWRcclxuICAgKiBAZmlyZXMgRmxpY2tpbmcjbmVlZFBhbmVsXHJcbiAgICogQGZpcmVzIEZsaWNraW5nI3Zpc2libGVDaGFuZ2VcclxuICAgKiBAZmlyZXMgRmxpY2tpbmcjcmVhY2hFZGdlXHJcbiAgICogQHRocm93cyB7RmxpY2tpbmdFcnJvcn1cclxuICAgKiB8Y29kZXxjb25kaXRpb258XHJcbiAgICogfC0tLXwtLS18XHJcbiAgICogfHtAbGluayBFUlJPUl9DT0RFIElOREVYX09VVF9PRl9SQU5HRX18V2hlbiB0aGUgcHJldmlvdXMgcGFuZWwgZG9lcyBub3QgZXhpc3R8XHJcbiAgICogfHtAbGluayBFUlJPUl9DT0RFIEFOSU1BVElPTl9BTFJFQURZX1BMQVlJTkd9fFdoZW4gdGhlIGFuaW1hdGlvbiBpcyBhbHJlYWR5IHBsYXlpbmd8XHJcbiAgICogfHtAbGluayBFUlJPUl9DT0RFIEFOSU1BVElPTl9JTlRFUlJVUFRFRH18V2hlbiB0aGUgYW5pbWF0aW9uIGlzIGludGVycnVwdGVkIGJ5IHVzZXIgaW5wdXR8XHJcbiAgICogfHtAbGluayBFUlJPUl9DT0RFIFNUT1BfQ0FMTEVEX0JZX1VTRVJ9fFdoZW4gdGhlIGFueSBvZiB0aGUgZXZlbnQncyBgc3RvcCgpYCBpcyBjYWxsZWR8XHJcbiAgICogPGtvPlxyXG4gICAqXHJcbiAgICogfGNvZGV8Y29uZGl0aW9ufFxyXG4gICAqIHwtLS18LS0tfFxyXG4gICAqIHx7QGxpbmsgRVJST1JfQ09ERSBJTkRFWF9PVVRfT0ZfUkFOR0V9fOydtOyghCDtjKjrhJDsnbQg7KG07J6s7ZWY7KeAIOyViuydhCDqsr3smrB8XHJcbiAgICogfHtAbGluayBFUlJPUl9DT0RFIEFOSU1BVElPTl9BTFJFQURZX1BMQVlJTkd9fOyVoOuLiOuplOydtOyFmOydtCDsnbTrr7gg7KeE7ZaJ7KSR7J24IOqyveyasHxcclxuICAgKiB8e0BsaW5rIEVSUk9SX0NPREUgQU5JTUFUSU9OX0lOVEVSUlVQVEVEfXzsgqzsmqnsnpAg7J6F66Cl7JeQIOydmO2VtCDslaDri4jrqZTsnbTshZjsnbQg7KSR64uo65CcIOqyveyasHxcclxuICAgKiB8e0BsaW5rIEVSUk9SX0NPREUgU1RPUF9DQUxMRURfQllfVVNFUn1867Cc7IOd65CcIOydtOuypO2KuOuTpCDspJEg7ZWY64KY652864+EIGBzdG9wKClg7J20IO2YuOy2nOuQnCDqsr3smrB8XHJcbiAgICogPC9rbz5cclxuICAgKiBAcmV0dXJuIHtQcm9taXNlPHZvaWQ+fSBBIFByb21pc2Ugd2hpY2ggd2lsbCBiZSByZXNvbHZlZCBhZnRlciByZWFjaGluZyB0aGUgcHJldmlvdXMgcGFuZWw8a28+7J207KCEIO2MqOuEkCDrj4Tri6zsi5zsl5AgcmVzb2x2ZeuQmOuKlCBQcm9taXNlPC9rbz5cclxuICAgKi9cbiAgX19wcm90by5wcmV2ID0gZnVuY3Rpb24gKGR1cmF0aW9uKSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgaWYgKGR1cmF0aW9uID09PSB2b2lkIDApIHtcbiAgICAgIGR1cmF0aW9uID0gdGhpcy5fZHVyYXRpb247XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm1vdmVUbygoX2MgPSAoX2IgPSAoX2EgPSB0aGlzLl9jb250cm9sLmFjdGl2ZVBhbmVsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucHJldigpKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaW5kZXgpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IC0xLCBkdXJhdGlvbiwgRElSRUNUSU9OLlBSRVYpO1xuICB9O1xuICAvKipcclxuICAgKiBNb3ZlIHRvIHRoZSBuZXh0IHBhbmVsIChjdXJyZW50IGluZGV4ICsgMSlcclxuICAgKiBAa28g64uk7J2MIO2MqOuEkOuhnCDsnbTrj5ntlanri4jri6QgKO2YhOyerCDsnbjrjbHsiqQgKyAxKVxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZHVyYXRpb249e0BsaW5rIEZsaWNraW5nI2R1cmF0aW9uIG9wdGlvbnMuZHVyYXRpb259XSBEdXJhdGlvbiBvZiB0aGUgcGFuZWwgbW92ZW1lbnQgYW5pbWF0aW9uICh1bml0OiBtcykuPGtvPu2MqOuEkCDsnbTrj5kg7JWg64uI66mU7J207IWYIOynhO2WiSDsi5zqsIQgKOuLqOychDogbXMpPC9rbz5cclxuICAgKiBAYXN5bmNcclxuICAgKiBAZmlyZXMgRmxpY2tpbmcjbW92ZVN0YXJ0XHJcbiAgICogQGZpcmVzIEZsaWNraW5nI21vdmVcclxuICAgKiBAZmlyZXMgRmxpY2tpbmcjbW92ZUVuZFxyXG4gICAqIEBmaXJlcyBGbGlja2luZyN3aWxsQ2hhbmdlXHJcbiAgICogQGZpcmVzIEZsaWNraW5nI2NoYW5nZWRcclxuICAgKiBAZmlyZXMgRmxpY2tpbmcjd2lsbFJlc3RvcmVcclxuICAgKiBAZmlyZXMgRmxpY2tpbmcjcmVzdG9yZWRcclxuICAgKiBAZmlyZXMgRmxpY2tpbmcjbmVlZFBhbmVsXHJcbiAgICogQGZpcmVzIEZsaWNraW5nI3Zpc2libGVDaGFuZ2VcclxuICAgKiBAZmlyZXMgRmxpY2tpbmcjcmVhY2hFZGdlXHJcbiAgICogQHRocm93cyB7RmxpY2tpbmdFcnJvcn1cclxuICAgKiB8Y29kZXxjb25kaXRpb258XHJcbiAgICogfC0tLXwtLS18XHJcbiAgICogfHtAbGluayBFUlJPUl9DT0RFIElOREVYX09VVF9PRl9SQU5HRX18V2hlbiB0aGUgbmV4dCBwYW5lbCBkb2VzIG5vdCBleGlzdHxcclxuICAgKiB8e0BsaW5rIEVSUk9SX0NPREUgQU5JTUFUSU9OX0FMUkVBRFlfUExBWUlOR318V2hlbiB0aGUgYW5pbWF0aW9uIGlzIGFscmVhZHkgcGxheWluZ3xcclxuICAgKiB8e0BsaW5rIEVSUk9SX0NPREUgQU5JTUFUSU9OX0lOVEVSUlVQVEVEfXxXaGVuIHRoZSBhbmltYXRpb24gaXMgaW50ZXJydXB0ZWQgYnkgdXNlciBpbnB1dHxcclxuICAgKiB8e0BsaW5rIEVSUk9SX0NPREUgU1RPUF9DQUxMRURfQllfVVNFUn18V2hlbiB0aGUgYW55IG9mIHRoZSBldmVudCdzIGBzdG9wKClgIGlzIGNhbGxlZHxcclxuICAgKiA8a28+XHJcbiAgICpcclxuICAgKiB8Y29kZXxjb25kaXRpb258XHJcbiAgICogfC0tLXwtLS18XHJcbiAgICogfHtAbGluayBFUlJPUl9DT0RFIElOREVYX09VVF9PRl9SQU5HRX1864uk7J2MIO2MqOuEkOydtCDsobTsnqztlZjsp4Ag7JWK7J2EIOqyveyasHxcclxuICAgKiB8e0BsaW5rIEVSUk9SX0NPREUgQU5JTUFUSU9OX0FMUkVBRFlfUExBWUlOR3187JWg64uI66mU7J207IWY7J20IOydtOuvuCDsp4TtlonspJHsnbgg6rK97JqwfFxyXG4gICAqIHx7QGxpbmsgRVJST1JfQ09ERSBBTklNQVRJT05fSU5URVJSVVBURUR9fOyCrOyaqeyekCDsnoXroKXsl5Ag7J2Y7ZW0IOyVoOuLiOuplOydtOyFmOydtCDspJHri6jrkJwg6rK97JqwfFxyXG4gICAqIHx7QGxpbmsgRVJST1JfQ09ERSBTVE9QX0NBTExFRF9CWV9VU0VSfXzrsJzsg53rkJwg7J2067Kk7Yq465OkIOykkSDtlZjrgpjrnbzrj4QgYHN0b3AoKWDsnbQg7Zi47Lac65CcIOqyveyasHxcclxuICAgKlxyXG4gICAqIDwva28+XHJcbiAgICogQHJldHVybiB7UHJvbWlzZTx2b2lkPn0gQSBQcm9taXNlIHdoaWNoIHdpbGwgYmUgcmVzb2x2ZWQgYWZ0ZXIgcmVhY2hpbmcgdGhlIG5leHQgcGFuZWw8a28+64uk7J2MIO2MqOuEkCDrj4Tri6zsi5zsl5AgcmVzb2x2ZeuQmOuKlCBQcm9taXNlPC9rbz5cclxuICAgKi9cbiAgX19wcm90by5uZXh0ID0gZnVuY3Rpb24gKGR1cmF0aW9uKSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgaWYgKGR1cmF0aW9uID09PSB2b2lkIDApIHtcbiAgICAgIGR1cmF0aW9uID0gdGhpcy5fZHVyYXRpb247XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm1vdmVUbygoX2MgPSAoX2IgPSAoX2EgPSB0aGlzLl9jb250cm9sLmFjdGl2ZVBhbmVsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubmV4dCgpKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaW5kZXgpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHRoaXMuX3JlbmRlcmVyLnBhbmVsQ291bnQsIGR1cmF0aW9uLCBESVJFQ1RJT04uTkVYVCk7XG4gIH07XG4gIC8qKlxyXG4gICAqIE1vdmUgdG8gdGhlIHBhbmVsIHdpdGggZ2l2ZW4gaW5kZXhcclxuICAgKiBAa28g7KO87Ja07KeEIOyduOuNseyKpOyXkCDtlbTri7ntlZjripQg7Yyo64SQ66GcIOydtOuPme2VqeuLiOuLpFxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIHBhbmVsIHRvIG1vdmU8a28+7J2064+Z7ZWgIO2MqOuEkOydmCDsnbjrjbHsiqQ8L2tvPlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZHVyYXRpb249e0BsaW5rIEZsaWNraW5nI2R1cmF0aW9uIG9wdGlvbnMuZHVyYXRpb259XSBEdXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uICh1bml0OiBtcyk8a28+7JWg64uI66mU7J207IWYIOynhO2WiSDsi5zqsIQgKOuLqOychDogbXMpPC9rbz5cclxuICAgKiBAcGFyYW0ge0RJUkVDVElPTn0gW2RpcmVjdGlvbj1ESVJFQ1RJT04uTk9ORV0gRGlyZWN0aW9uIHRvIG1vdmUsIG9ubHkgYXZhaWxhYmxlIGluIHRoZSB7QGxpbmsgRmxpY2tpbmcjY2lyY3VsYXIgY2lyY3VsYXJ9IG1vZGU8a28+7J2064+Z7ZWgIOuwqe2WpS4ge0BsaW5rIEZsaWNraW5nI2NpcmN1bGFyIGNpcmN1bGFyfSDsmLXshZgg7Zmc7ISx7ZmU7Iuc7JeQ66eMIOyCrOyaqSDqsIDriqXtlanri4jri6Q8L2tvPlxyXG4gICAqIEBhc3luY1xyXG4gICAqIEBmaXJlcyBGbGlja2luZyNtb3ZlU3RhcnRcclxuICAgKiBAZmlyZXMgRmxpY2tpbmcjbW92ZVxyXG4gICAqIEBmaXJlcyBGbGlja2luZyNtb3ZlRW5kXHJcbiAgICogQGZpcmVzIEZsaWNraW5nI3dpbGxDaGFuZ2VcclxuICAgKiBAZmlyZXMgRmxpY2tpbmcjY2hhbmdlZFxyXG4gICAqIEBmaXJlcyBGbGlja2luZyN3aWxsUmVzdG9yZVxyXG4gICAqIEBmaXJlcyBGbGlja2luZyNyZXN0b3JlZFxyXG4gICAqIEBmaXJlcyBGbGlja2luZyNuZWVkUGFuZWxcclxuICAgKiBAZmlyZXMgRmxpY2tpbmcjdmlzaWJsZUNoYW5nZVxyXG4gICAqIEBmaXJlcyBGbGlja2luZyNyZWFjaEVkZ2VcclxuICAgKiBAdGhyb3dzIHtGbGlja2luZ0Vycm9yfVxyXG4gICAqIHxjb2RlfGNvbmRpdGlvbnxcclxuICAgKiB8LS0tfC0tLXxcclxuICAgKiB8e0BsaW5rIEVSUk9SX0NPREUgSU5ERVhfT1VUX09GX1JBTkdFfXxXaGVuIHRoZSByb290IGlzIG5vdCBlaXRoZXIgc3RyaW5nIG9yIEhUTUxFbGVtZW50fFxyXG4gICAqIHx7QGxpbmsgRVJST1JfQ09ERSBBTklNQVRJT05fQUxSRUFEWV9QTEFZSU5HfXxXaGVuIHRoZSBhbmltYXRpb24gaXMgYWxyZWFkeSBwbGF5aW5nfFxyXG4gICAqIHx7QGxpbmsgRVJST1JfQ09ERSBBTklNQVRJT05fSU5URVJSVVBURUR9fFdoZW4gdGhlIGFuaW1hdGlvbiBpcyBpbnRlcnJ1cHRlZCBieSB1c2VyIGlucHV0fFxyXG4gICAqIHx7QGxpbmsgRVJST1JfQ09ERSBTVE9QX0NBTExFRF9CWV9VU0VSfXxXaGVuIHRoZSBhbnkgb2YgdGhlIGV2ZW50J3MgYHN0b3AoKWAgaXMgY2FsbGVkfFxyXG4gICAqIDxrbz5cclxuICAgKlxyXG4gICAqIHxjb2RlfGNvbmRpdGlvbnxcclxuICAgKiB8LS0tfC0tLXxcclxuICAgKiB8e0BsaW5rIEVSUk9SX0NPREUgSU5ERVhfT1VUX09GX1JBTkdFfXztlbTri7kg7J24642x7Iqk66W8IOqwgOynhCDtjKjrhJDsnbQg7KG07J6s7ZWY7KeAIOyViuydhCDqsr3smrB8XHJcbiAgICogfHtAbGluayBFUlJPUl9DT0RFIEFOSU1BVElPTl9BTFJFQURZX1BMQVlJTkd9fOyVoOuLiOuplOydtOyFmOydtCDsnbTrr7gg7KeE7ZaJ7KSR7J24IOqyveyasHxcclxuICAgKiB8e0BsaW5rIEVSUk9SX0NPREUgQU5JTUFUSU9OX0lOVEVSUlVQVEVEfXzsgqzsmqnsnpAg7J6F66Cl7JeQIOydmO2VtCDslaDri4jrqZTsnbTshZjsnbQg7KSR64uo65CcIOqyveyasHxcclxuICAgKiB8e0BsaW5rIEVSUk9SX0NPREUgU1RPUF9DQUxMRURfQllfVVNFUn1867Cc7IOd65CcIOydtOuypO2KuOuTpCDspJEg7ZWY64KY652864+EIGBzdG9wKClg7J20IO2YuOy2nOuQnCDqsr3smrB8XHJcbiAgICpcclxuICAgKiA8L2tvPlxyXG4gICAqIEByZXR1cm4ge1Byb21pc2U8dm9pZD59IEEgUHJvbWlzZSB3aGljaCB3aWxsIGJlIHJlc29sdmVkIGFmdGVyIHJlYWNoaW5nIHRoZSB0YXJnZXQgcGFuZWw8a28+7ZW064u5IO2MqOuEkCDrj4Tri6zsi5zsl5AgcmVzb2x2ZeuQmOuKlCBQcm9taXNlPC9rbz5cclxuICAgKi9cbiAgX19wcm90by5tb3ZlVG8gPSBmdW5jdGlvbiAoaW5kZXgsIGR1cmF0aW9uLCBkaXJlY3Rpb24pIHtcbiAgICBpZiAoZHVyYXRpb24gPT09IHZvaWQgMCkge1xuICAgICAgZHVyYXRpb24gPSB0aGlzLl9kdXJhdGlvbjtcbiAgICB9XG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gdm9pZCAwKSB7XG4gICAgICBkaXJlY3Rpb24gPSBESVJFQ1RJT04uTk9ORTtcbiAgICB9XG4gICAgdmFyIHJlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXI7XG4gICAgdmFyIHBhbmVsQ291bnQgPSByZW5kZXJlci5wYW5lbENvdW50O1xuICAgIHZhciBwYW5lbCA9IHJlbmRlcmVyLmdldFBhbmVsKGluZGV4KTtcbiAgICBpZiAoIXBhbmVsKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEZsaWNraW5nRXJyb3IoTUVTU0FHRS5JTkRFWF9PVVRfT0ZfUkFOR0UoaW5kZXgsIDAsIHBhbmVsQ291bnQgLSAxKSwgQ09ERS5JTkRFWF9PVVRfT0ZfUkFOR0UpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2NvbnRyb2wuYW5pbWF0aW5nKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEZsaWNraW5nRXJyb3IoTUVTU0FHRS5BTklNQVRJT05fQUxSRUFEWV9QTEFZSU5HLCBDT0RFLkFOSU1BVElPTl9BTFJFQURZX1BMQVlJTkcpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2NvbnRyb2wuaG9sZGluZykge1xuICAgICAgdGhpcy5fY29udHJvbC5jb250cm9sbGVyLnJlbGVhc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRyb2wubW92ZVRvUGFuZWwocGFuZWwsIHtcbiAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbixcbiAgICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uXG4gICAgfSk7XG4gIH07XG4gIC8qKlxyXG4gICAqIENoYW5nZSB0aGUgZGVzdGluYXRpb24gYW5kIGR1cmF0aW9uIG9mIHRoZSBhbmltYXRpb24gY3VycmVudGx5IHBsYXlpbmdcclxuICAgKiBAa28g7J6s7IOdIOykkeyduCDslaDri4jrqZTsnbTshZjsnZgg66qp7KCB7KeA7JmAIOyerOyDnSDsi5zqsITsnYQg67OA6rK97ZWp64uI64ukXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgcGFuZWwgdG8gbW92ZTxrbz7snbTrj5ntlaAg7Yyo64SQ7J2YIOyduOuNseyKpDwva28+XHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGR1cmF0aW9uIER1cmF0aW9uIG9mIHRoZSBhbmltYXRpb24gKHVuaXQ6IG1zKTxrbz7slaDri4jrqZTsnbTshZgg7KeE7ZaJIOyLnOqwhCAo64uo7JyEOiBtcyk8L2tvPlxyXG4gICAqIEBwYXJhbSB7RElSRUNUSU9OfSBkaXJlY3Rpb24gRGlyZWN0aW9uIHRvIG1vdmUsIG9ubHkgYXZhaWxhYmxlIGluIHRoZSB7QGxpbmsgRmxpY2tpbmcjY2lyY3VsYXIgY2lyY3VsYXJ9IG1vZGU8a28+7J2064+Z7ZWgIOuwqe2WpS4ge0BsaW5rIEZsaWNraW5nI2NpcmN1bGFyIGNpcmN1bGFyfSDsmLXshZgg7Zmc7ISx7ZmU7Iuc7JeQ66eMIOyCrOyaqSDqsIDriqXtlanri4jri6Q8L2tvPlxyXG4gICAqIEB0aHJvd3Mge0ZsaWNraW5nRXJyb3J9XHJcbiAgICoge0BsaW5rIEVSUk9SX0NPREUgSU5ERVhfT1VUX09GX1JBTkdFfSBXaGVuIHRoZSByb290IGlzIG5vdCBlaXRoZXIgc3RyaW5nIG9yIEhUTUxFbGVtZW50XHJcbiAgICogPGtvPntAbGluayBFUlJPUl9DT0RFIElOREVYX09VVF9PRl9SQU5HRX0g7ZW064u5IOyduOuNseyKpOulvCDqsIDsp4Qg7Yyo64SQ7J20IOyhtOyerO2VmOyngCDslYrsnYQg6rK97JqwPC9rbz5cclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xuICBfX3Byb3RvLnVwZGF0ZUFuaW1hdGlvbiA9IGZ1bmN0aW9uIChpbmRleCwgZHVyYXRpb24sIGRpcmVjdGlvbikge1xuICAgIGlmICghdGhpcy5fY29udHJvbC5hbmltYXRpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHJlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXI7XG4gICAgdmFyIHBhbmVsQ291bnQgPSByZW5kZXJlci5wYW5lbENvdW50O1xuICAgIHZhciBwYW5lbCA9IHJlbmRlcmVyLmdldFBhbmVsKGluZGV4KTtcbiAgICBpZiAoIXBhbmVsKSB7XG4gICAgICB0aHJvdyBuZXcgRmxpY2tpbmdFcnJvcihNRVNTQUdFLklOREVYX09VVF9PRl9SQU5HRShpbmRleCwgMCwgcGFuZWxDb3VudCAtIDEpLCBDT0RFLklOREVYX09VVF9PRl9SQU5HRSk7XG4gICAgfVxuICAgIHRoaXMuX2NvbnRyb2wudXBkYXRlQW5pbWF0aW9uKHBhbmVsLCBkdXJhdGlvbiwgZGlyZWN0aW9uKTtcbiAgfTtcbiAgLyoqXHJcbiAgICogU3RvcHMgdGhlIGFuaW1hdGlvbiBjdXJyZW50bHkgcGxheWluZ1xyXG4gICAqIEBrbyDsnqzsg50g7KSR7J24IOyVoOuLiOuplOydtOyFmOydhCDspJHri6jsi5ztgrXri4jri6RcclxuICAgKiBAZmlyZXMgRmxpY2tpbmcjbW92ZUVuZFxyXG4gICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICovXG4gIF9fcHJvdG8uc3RvcEFuaW1hdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuX2NvbnRyb2wuYW5pbWF0aW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2NvbnRyb2wuc3RvcEFuaW1hdGlvbigpO1xuICB9O1xuICAvKipcclxuICAgKiBSZXR1cm4gdGhlIHtAbGluayBQYW5lbH0gYXQgdGhlIGdpdmVuIGluZGV4LiBgbnVsbGAgaWYgaXQgZG9lc24ndCBleGlzdHMuXHJcbiAgICogQGtvIOyjvOyWtOynhCDsnbjrjbHsiqTsl5Ag7ZW064u57ZWY64qUIHtAbGluayBQYW5lbH3snYQg67CY7ZmY7ZWp64uI64ukLiDso7zslrTsp4Qg7J24642x7Iqk7JeQIO2VtOuLue2VmOuKlCDtjKjrhJDsnbQg7KG07J6s7ZWY7KeAIOyViuydhCDqsr3smrAgYG51bGxg7J2EIOuwmO2ZmO2VqeuLiOuLpC5cclxuICAgKiBAcmV0dXJuIHtQYW5lbCB8IG51bGx9IFBhbmVsIGF0IHRoZSBnaXZlbiBpbmRleDxrbz7so7zslrTsp4Qg7J24642x7Iqk7JeQIO2VtOuLue2VmOuKlCDtjKjrhJA8L2tvPlxyXG4gICAqIEBzZWUgUGFuZWxcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGBgYHRzXHJcbiAgICogY29uc3QgcGFuZWwgPSBmbGlja2luZy5nZXRQYW5lbCgwKTtcclxuICAgKiAvLyBXaGljaCBpcyBhIHNob3J0aGFuZCB0by4uLlxyXG4gICAqIGNvbnN0IHNhbWVQYW5lbCA9IGZsaWNraW5nLnBhbmVsc1swXTtcclxuICAgKiBgYGBcclxuICAgKi9cbiAgX19wcm90by5nZXRQYW5lbCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgIHJldHVybiB0aGlzLl9yZW5kZXJlci5nZXRQYW5lbChpbmRleCk7XG4gIH07XG4gIC8qKlxyXG4gICAqIEVuYWJsZSBpbnB1dCBmcm9tIHRoZSB1c2VyIChtb3VzZS90b3VjaClcclxuICAgKiBAa28g7IKs7Jqp7J6Q7J2YIOyeheugpSjrp4jsmrDsiqQv7YSw7LmYKeulvCDtmZzshLHtmZTtlanri4jri6RcclxuICAgKiBAcmV0dXJuIHt0aGlzfVxyXG4gICAqL1xuICBfX3Byb3RvLmVuYWJsZUlucHV0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2NvbnRyb2wuZW5hYmxlKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxyXG4gICAqIERpc2FibGUgaW5wdXQgZnJvbSB0aGUgdXNlciAobW91c2UvdG91Y2gpXHJcbiAgICogQGtvIOyCrOyaqeyekOydmCDsnoXroKUo66eI7Jqw7IqkL+2EsOy5mCnrpbwg66eJ7Iq164uI64ukXHJcbiAgICogQHJldHVybiB7dGhpc31cclxuICAgKi9cbiAgX19wcm90by5kaXNhYmxlSW5wdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fY29udHJvbC5kaXNhYmxlKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxyXG4gICAqIEdldCBjdXJyZW50IGZsaWNraW5nIHN0YXR1cy4gWW91IGNhbiByZXN0b3JlIGN1cnJlbnQgc3RhdGUgYnkgZ2l2aW5nIHJldHVybmVkIHZhbHVlIHRvIHtAbGluayBGbGlja2luZyNzZXRTdGF0dXMgc2V0U3RhdHVzKCl9XHJcbiAgICogQGtvIO2YhOyerCDsg4Htg5zrpbwg67CY7ZmY7ZWp64uI64ukLiDrsJjtmZjrsJvsnYAg6rCS7J2EIHtAbGluayBGbGlja2luZyNzZXRTdGF0dXMgc2V0U3RhdHVzKCl9IOuplOyGjOuTnOydmCDsnbjsnpDroZwg7KeA7KCV7ZWY66m0IO2YhOyerCDsg4Htg5zrpbwg67O17JuQ7ZWgIOyImCDsnojsirXri4jri6RcclxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBTdGF0dXMgcmV0cmlldmluZyBvcHRpb25zPGtvPlN0YXR1cyDrsJjtmZgg7Ji17IWYPC9rbz5cclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmluZGV4PXRydWVdIEluY2x1ZGUgY3VycmVudCBwYW5lbCBpbmRleCB0byB0aGUgcmV0dXJuaW5nIHN0YXR1cy4gQ2FtZXJhIHdpbGwgYXV0b21hdGljYWxseSBtb3ZlIHRvIHRoZSBnaXZlbiBpbmRleCB3aGVuIHRoZSB7QGxpbmsgRmxpY2tpbmcjc2V0U3RhdHVzIHNldFN0YXR1c30gaXMgY2FsbGVkPGtvPu2YhOyerCDtjKjrhJAg7J24642x7Iqk66W8IOuwmO2ZmOqwkuyXkCDtj6ztlajsi5ztgrXri4jri6QuIHtAbGluayBGbGlja2luZyNzZXRTdGF0dXMgc2V0U3RhdHVzfSDtmLjstpzsi5wg7J6Q64+Z7Jy866GcIO2VtOuLuSDsnbjrjbHsiqTroZwg7Lm066mU652866W8IOybgOyngeyeheuLiOuLpDwva28+XHJcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5wb3NpdGlvbj10cnVlXSBJbmNsdWRlIGNhbWVyYSBwb3NpdGlvbiB0byB0aGUgcmV0dXJuaW5nIHN0YXR1cy4gVGhpcyB3b3JrcyBvbmx5IHdoZW4gdGhlIHtAbGluayBGbGlja2luZyNtb3ZlVHlwZSBtb3ZlVHlwZX0gaXMgYGZyZWVTY3JvbGxgPGtvPuy5tOuplOudvOydmCDtmITsnqwg7JyE7LmY66W8IOuwmO2ZmOqwkuyXkCDtj6ztlajsi5ztgrXri4jri6QuIOydtCDsmLXshZjsnYAge0BsaW5rIEZsaWNraW5nI21vdmVUeXBlIG1vdmVUeXBlfeydtCBgZnJlZVNjcm9sbGDsnbwg6rK97Jqw7JeQ66eMIOuPmeyeke2VqeuLiOuLpDwva28+XHJcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5pbmNsdWRlUGFuZWxIVE1MPWZhbHNlXSBJbmNsdWRlIHBhbmVsJ3MgYG91dGVySFRNTGAgdG8gdGhlIHJldHVybmluZyBzdGF0dXM8a28+7Yyo64SQ7J2YIGBvdXRlckhUTUxg7J2EIOuwmO2ZmOqwkuyXkCDtj6ztlajsi5ztgrXri4jri6Q8L2tvPlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudmlzaWJsZVBhbmVsc09ubHk9ZmFsc2VdIEluY2x1ZGUgb25seSB7QGxpbmsgRmxpY2tpbmcjdmlzaWJsZVBhbmVsIHZpc2libGVQYW5lbH0ncyBIVE1MLiBUaGlzIG9wdGlvbiBpcyBhdmFpbGFibGUgb25seSB3aGVuIHRoZSBgaW5jbHVkZVBhbmVsSFRNTGAgaXMgdHJ1ZVxyXG4gICAqIDxrbz7tmITsnqwg67O07J2064qUIO2MqOuEkCh7QGxpbmsgRmxpY2tpbmcjdmlzaWJsZVBhbmVsIHZpc2libGVQYW5lbH0p7J2YIEhUTUzrp4wg67CY7ZmY7ZWp64uI64ukLiBgaW5jbHVkZVBhbmVsSFRNTGDsnbQgYHRydWVg7J28IOqyveyasOyXkOunjCDrj5nsnpHtlanri4jri6QuPC9rbz5cclxuICAgKiBAcmV0dXJuIHtTdGF0dXN9IEFuIG9iamVjdCB3aXRoIGN1cnJlbnQgc3RhdHVzIHZhbHVlIGluZm9ybWF0aW9uPGtvPu2YhOyerCDsg4Htg5zqsJIg7KCV67O066W8IOqwgOynhCDqsJ3ssrQuPC9rbz5cclxuICAgKi9cbiAgX19wcm90by5nZXRTdGF0dXMgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgX2IsIF9jO1xuICAgIHZhciBfZCA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLFxuICAgICAgX2UgPSBfZC5pbmRleCxcbiAgICAgIGluZGV4ID0gX2UgPT09IHZvaWQgMCA/IHRydWUgOiBfZSxcbiAgICAgIF9mID0gX2QucG9zaXRpb24sXG4gICAgICBwb3NpdGlvbiA9IF9mID09PSB2b2lkIDAgPyB0cnVlIDogX2YsXG4gICAgICBfZyA9IF9kLmluY2x1ZGVQYW5lbEhUTUwsXG4gICAgICBpbmNsdWRlUGFuZWxIVE1MID0gX2cgPT09IHZvaWQgMCA/IGZhbHNlIDogX2csXG4gICAgICBfaCA9IF9kLnZpc2libGVQYW5lbHNPbmx5LFxuICAgICAgdmlzaWJsZVBhbmVsc09ubHkgPSBfaCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfaDtcbiAgICB2YXIgY2FtZXJhID0gdGhpcy5fY2FtZXJhO1xuICAgIHZhciBwYW5lbHMgPSB2aXNpYmxlUGFuZWxzT25seSA/IHRoaXMudmlzaWJsZVBhbmVscyA6IHRoaXMucGFuZWxzO1xuICAgIHZhciBzdGF0dXMgPSB7XG4gICAgICBwYW5lbHM6IHBhbmVscy5tYXAoZnVuY3Rpb24gKHBhbmVsKSB7XG4gICAgICAgIHZhciBwYW5lbEluZm8gPSB7XG4gICAgICAgICAgaW5kZXg6IHBhbmVsLmluZGV4XG4gICAgICAgIH07XG4gICAgICAgIGlmIChpbmNsdWRlUGFuZWxIVE1MKSB7XG4gICAgICAgICAgcGFuZWxJbmZvLmh0bWwgPSBwYW5lbC5lbGVtZW50Lm91dGVySFRNTDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFuZWxJbmZvO1xuICAgICAgfSlcbiAgICB9O1xuICAgIGlmIChpbmRleCkge1xuICAgICAgc3RhdHVzLmluZGV4ID0gdGhpcy5pbmRleDtcbiAgICB9XG4gICAgaWYgKHBvc2l0aW9uKSB7XG4gICAgICB2YXIgbmVhcmVzdEFuY2hvciA9IGNhbWVyYS5maW5kTmVhcmVzdEFuY2hvcihjYW1lcmEucG9zaXRpb24pO1xuICAgICAgaWYgKG5lYXJlc3RBbmNob3IpIHtcbiAgICAgICAgc3RhdHVzLnBvc2l0aW9uID0ge1xuICAgICAgICAgIHBhbmVsOiBuZWFyZXN0QW5jaG9yLnBhbmVsLmluZGV4LFxuICAgICAgICAgIHByb2dyZXNzSW5QYW5lbDogY2FtZXJhLmdldFByb2dyZXNzSW5QYW5lbChuZWFyZXN0QW5jaG9yLnBhbmVsKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodmlzaWJsZVBhbmVsc09ubHkpIHtcbiAgICAgIHZhciB2aXNpYmxlUGFuZWxzID0gdGhpcy52aXNpYmxlUGFuZWxzO1xuICAgICAgc3RhdHVzLnZpc2libGVPZmZzZXQgPSAoX2MgPSAoX2IgPSB2aXNpYmxlUGFuZWxzWzBdKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaW5kZXgpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IDA7XG4gICAgfVxuICAgIHJldHVybiBzdGF0dXM7XG4gIH07XG4gIC8qKlxyXG4gICAqIFJlc3RvcmUgdG8gdGhlIHN0YXRlIG9mIHRoZSBnaXZlbiB7QGxpbmsgU3RhdHVzfVxyXG4gICAqIEBrbyDso7zslrTsp4Qge0BsaW5rIFN0YXR1c33snZgg7IOB7YOc66GcIOuzteybkO2VqeuLiOuLpFxyXG4gICAqIEBwYXJhbSB7UGFydGlhbDxTdGF0dXM+fSBzdGF0dXMgU3RhdHVzIHZhbHVlIHRvIGJlIHJlc3RvcmVkLiBZb3Ugc2hvdWxkIHVzZSB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSB7QGxpbmsgRmxpY2tpbmcjZ2V0U3RhdHVzIGdldFN0YXR1cygpfSBtZXRob2Q8a28+67O17JuQ7ZWgIOyDge2DnCDqsJIuIHtAbGluayBGbGlja2luZyNnZXRTdGF0dXMgZ2V0U3RhdHVzKCl9IOuplOyEnOuTnOydmCDrsJjtmZjqsJLsnYQg7KeA7KCV7ZWY66m0IOuQqeuLiOuLpDwva28+XHJcbiAgICogQHJldHVybiB7dm9pZH1cclxuICAgKi9cbiAgX19wcm90by5zZXRTdGF0dXMgPSBmdW5jdGlvbiAoc3RhdHVzKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICghdGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgIHRocm93IG5ldyBGbGlja2luZ0Vycm9yKE1FU1NBR0UuTk9UX0lOSVRJQUxJWkVELCBDT0RFLk5PVF9JTklUSUFMSVpFRCk7XG4gICAgfVxuICAgIHZhciBpbmRleCA9IHN0YXR1cy5pbmRleCxcbiAgICAgIHBvc2l0aW9uID0gc3RhdHVzLnBvc2l0aW9uLFxuICAgICAgdmlzaWJsZU9mZnNldCA9IHN0YXR1cy52aXNpYmxlT2Zmc2V0LFxuICAgICAgcGFuZWxzID0gc3RhdHVzLnBhbmVscztcbiAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLl9yZW5kZXJlcjtcbiAgICB2YXIgY29udHJvbCA9IHRoaXMuX2NvbnRyb2w7XG4gICAgLy8gQ2FuJ3QgYWRkL3JlbW92ZSBwYW5lbHMgb24gZXh0ZXJuYWwgcmVuZGVyaW5nXG4gICAgaWYgKCgoX2EgPSBwYW5lbHNbMF0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odG1sKSAmJiAhdGhpcy5fcmVuZGVyRXh0ZXJuYWwpIHtcbiAgICAgIHJlbmRlcmVyLmJhdGNoUmVtb3ZlKHtcbiAgICAgICAgaW5kZXg6IDAsXG4gICAgICAgIGRlbGV0ZUNvdW50OiB0aGlzLnBhbmVscy5sZW5ndGgsXG4gICAgICAgIGhhc0RPTUluRWxlbWVudHM6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmVuZGVyZXIuYmF0Y2hJbnNlcnQoe1xuICAgICAgICBpbmRleDogMCxcbiAgICAgICAgZWxlbWVudHM6IHBhcnNlRWxlbWVudChwYW5lbHMubWFwKGZ1bmN0aW9uIChwYW5lbCkge1xuICAgICAgICAgIHJldHVybiBwYW5lbC5odG1sO1xuICAgICAgICB9KSksXG4gICAgICAgIGhhc0RPTUluRWxlbWVudHM6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoaW5kZXggIT0gbnVsbCkge1xuICAgICAgdmFyIHBhbmVsSW5kZXggPSB2aXNpYmxlT2Zmc2V0ID8gaW5kZXggLSB2aXNpYmxlT2Zmc2V0IDogaW5kZXg7XG4gICAgICB2b2lkIHRoaXMubW92ZVRvKHBhbmVsSW5kZXgsIDApLmNhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAocG9zaXRpb24gJiYgdGhpcy5fbW92ZVR5cGUgPT09IE1PVkVfVFlQRS5GUkVFX1NDUk9MTCkge1xuICAgICAgdmFyIHBhbmVsID0gcG9zaXRpb24ucGFuZWwsXG4gICAgICAgIHByb2dyZXNzSW5QYW5lbCA9IHBvc2l0aW9uLnByb2dyZXNzSW5QYW5lbDtcbiAgICAgIHZhciBwYW5lbEluZGV4ID0gdmlzaWJsZU9mZnNldCA/IHBhbmVsIC0gdmlzaWJsZU9mZnNldCA6IHBhbmVsO1xuICAgICAgdmFyIHBhbmVsUmFuZ2UgPSByZW5kZXJlci5wYW5lbHNbcGFuZWxJbmRleF0ucmFuZ2U7XG4gICAgICB2YXIgbmV3Q2FtZXJhUG9zID0gcGFuZWxSYW5nZS5taW4gKyAocGFuZWxSYW5nZS5tYXggLSBwYW5lbFJhbmdlLm1pbikgKiBwcm9ncmVzc0luUGFuZWw7XG4gICAgICB2b2lkIGNvbnRyb2wubW92ZVRvUG9zaXRpb24obmV3Q2FtZXJhUG9zLCAwKS5jYXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIC8qKlxyXG4gICAqIEFkZCBwbHVnaW5zIHRoYXQgY2FuIGhhdmUgZGlmZmVyZW50IGVmZmVjdHMgb24gRmxpY2tpbmdcclxuICAgKiBAa28g7ZSM66as7YK57JeQIOuLpOyWke2VnCDtmqjqs7zrpbwg67aA7Jes7ZWgIOyImCDsnojripQg7ZSM65+s6re47J247J2EIOy2lOqwgO2VqeuLiOuLpFxyXG4gICAqIEBwYXJhbSB7Li4uUGx1Z2lufSBwbHVnaW5zIFRoZSBwbHVnaW4ocykgdG8gYWRkPGtvPuy2lOqwgO2VoCDtlIzrn6zqt7jsnbgo65OkKTwva28+XHJcbiAgICogQHJldHVybiB7dGhpc31cclxuICAgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9uYXZlci9lZ2pzLWZsaWNraW5nLXBsdWdpbnNcclxuICAgKi9cbiAgX19wcm90by5hZGRQbHVnaW5zID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfYTtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHZhciBwbHVnaW5zID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHBsdWdpbnNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2luaXRpYWxpemVkKSB7XG4gICAgICBwbHVnaW5zLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0uaW5pdChfdGhpcyk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgKF9hID0gdGhpcy5fcGx1Z2lucykucHVzaC5hcHBseShfYSwgX19zcHJlYWQkMShwbHVnaW5zKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxyXG4gICAqIFJlbW92ZSBwbHVnaW5zIGZyb20gRmxpY2tpbmcuXHJcbiAgICogQGtvIO2UjOumrO2CueycvOuhnOu2gO2EsCDtlIzrn6zqt7jsnbjrk6TsnYQg7KCc6rGw7ZWp64uI64ukLlxyXG4gICAqIEBwYXJhbSB7Li4uUGx1Z2lufSBwbHVnaW4gVGhlIHBsdWdpbihzKSB0byByZW1vdmUuPGtvPuygnOqxsCDtlIzrn6zqt7jsnbgo65OkKS48L2tvPlxyXG4gICAqIEByZXR1cm4ge3RoaXN9XHJcbiAgICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vbmF2ZXIvZWdqcy1mbGlja2luZy1wbHVnaW5zXHJcbiAgICovXG4gIF9fcHJvdG8ucmVtb3ZlUGx1Z2lucyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHZhciBwbHVnaW5zID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHBsdWdpbnNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgcGx1Z2lucy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICB2YXIgZm91bmRJbmRleCA9IGZpbmRJbmRleChfdGhpcy5fcGx1Z2lucywgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICByZXR1cm4gdmFsID09PSBpdGVtO1xuICAgICAgfSk7XG4gICAgICBpZiAoZm91bmRJbmRleCA+PSAwKSB7XG4gICAgICAgIGl0ZW0uZGVzdHJveSgpO1xuICAgICAgICBfdGhpcy5fcGx1Z2lucy5zcGxpY2UoZm91bmRJbmRleCwgMSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxyXG4gICAqIFVwZGF0ZSB2aWV3cG9ydC9wYW5lbCBzaXplc1xyXG4gICAqIEBrbyDtjKjrhJAg67CPIOu3sO2PrO2KuOydmCDtgazquLDrpbwg6rCx7Iug7ZWp64uI64ukXHJcbiAgICogQG1ldGhvZFxyXG4gICAqIEBmaXJlcyBGbGlja2luZyNiZWZvcmVSZXNpemVcclxuICAgKiBAZmlyZXMgRmxpY2tpbmcjYWZ0ZXJSZXNpemVcclxuICAgKiBAcmV0dXJuIHt0aGlzfVxyXG4gICAqL1xuICBfX3Byb3RvLnJlc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdmlld3BvcnQsIHJlbmRlcmVyLCBjYW1lcmEsIGNvbnRyb2wsIGFjdGl2ZVBhbmVsLCBwcmV2V2lkdGgsIHByZXZIZWlnaHQsIHByZXZQcm9ncmVzc0luUGFuZWwsIG5ld1dpZHRoLCBuZXdIZWlnaHQsIHNpemVDaGFuZ2VkO1xuICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgdmlld3BvcnQgPSB0aGlzLl92aWV3cG9ydDtcbiAgICAgICAgICAgIHJlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXI7XG4gICAgICAgICAgICBjYW1lcmEgPSB0aGlzLl9jYW1lcmE7XG4gICAgICAgICAgICBjb250cm9sID0gdGhpcy5fY29udHJvbDtcbiAgICAgICAgICAgIGFjdGl2ZVBhbmVsID0gY29udHJvbC5hY3RpdmVQYW5lbDtcbiAgICAgICAgICAgIHByZXZXaWR0aCA9IHZpZXdwb3J0LndpZHRoO1xuICAgICAgICAgICAgcHJldkhlaWdodCA9IHZpZXdwb3J0LmhlaWdodDtcbiAgICAgICAgICAgIHByZXZQcm9ncmVzc0luUGFuZWwgPSBhY3RpdmVQYW5lbCA/IGNhbWVyYS5nZXRQcm9ncmVzc0luUGFuZWwoYWN0aXZlUGFuZWwpIDogMDtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcihuZXcgQ29tcG9uZW50RXZlbnQkMShFVkVOVFMuQkVGT1JFX1JFU0laRSwge1xuICAgICAgICAgICAgICB3aWR0aDogcHJldldpZHRoLFxuICAgICAgICAgICAgICBoZWlnaHQ6IHByZXZIZWlnaHQsXG4gICAgICAgICAgICAgIGVsZW1lbnQ6IHZpZXdwb3J0LmVsZW1lbnRcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHZpZXdwb3J0LnJlc2l6ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgcmVuZGVyZXIuZm9yY2VSZW5kZXJBbGxQYW5lbHMoKV07XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgX2Euc2VudCgpOyAvLyBSZW5kZXIgYWxsIHBhbmVsIGVsZW1lbnRzLCB0byB1cGRhdGUgc2l6ZXNcbiAgICAgICAgICAgIGlmICghdGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZW5kZXJlci51cGRhdGVQYW5lbFNpemUoKTtcbiAgICAgICAgICAgIGNhbWVyYS51cGRhdGVBbGlnblBvcygpO1xuICAgICAgICAgICAgY2FtZXJhLnVwZGF0ZVJhbmdlKCk7XG4gICAgICAgICAgICBjYW1lcmEudXBkYXRlQW5jaG9ycygpO1xuICAgICAgICAgICAgY2FtZXJhLnVwZGF0ZUFkYXB0aXZlSGVpZ2h0KCk7XG4gICAgICAgICAgICBjYW1lcmEudXBkYXRlUGFuZWxPcmRlcigpO1xuICAgICAgICAgICAgY2FtZXJhLnVwZGF0ZU9mZnNldCgpO1xuICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgcmVuZGVyZXIucmVuZGVyKCldO1xuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY29udHJvbC5hbmltYXRpbmcpIDsgZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnRyb2wudXBkYXRlUG9zaXRpb24ocHJldlByb2dyZXNzSW5QYW5lbCk7XG4gICAgICAgICAgICAgIGNvbnRyb2wudXBkYXRlSW5wdXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld1dpZHRoID0gdmlld3BvcnQud2lkdGg7XG4gICAgICAgICAgICBuZXdIZWlnaHQgPSB2aWV3cG9ydC5oZWlnaHQ7XG4gICAgICAgICAgICBzaXplQ2hhbmdlZCA9IG5ld1dpZHRoICE9PSBwcmV2V2lkdGggfHwgbmV3SGVpZ2h0ICE9PSBwcmV2SGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKG5ldyBDb21wb25lbnRFdmVudCQxKEVWRU5UUy5BRlRFUl9SRVNJWkUsIHtcbiAgICAgICAgICAgICAgd2lkdGg6IHZpZXdwb3J0LndpZHRoLFxuICAgICAgICAgICAgICBoZWlnaHQ6IHZpZXdwb3J0LmhlaWdodCxcbiAgICAgICAgICAgICAgcHJldjoge1xuICAgICAgICAgICAgICAgIHdpZHRoOiBwcmV2V2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBwcmV2SGVpZ2h0XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNpemVDaGFuZ2VkOiBzaXplQ2hhbmdlZCxcbiAgICAgICAgICAgICAgZWxlbWVudDogdmlld3BvcnQuZWxlbWVudFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbiAgLyoqXHJcbiAgICogQWRkIG5ldyBwYW5lbHMgYWZ0ZXIgdGhlIGxhc3QgcGFuZWxcclxuICAgKiBAa28g7Yyo64SQIOuqqeuhneydmCDsoJzsnbwg64Gd7JeQIOyDiOuhnOyatCDtjKjrhJDrk6TsnYQg7LaU6rCA7ZWp64uI64ukXHJcbiAgICogQHBhcmFtIHtFbGVtZW50TGlrZSB8IEVsZW1lbnRMaWtlW119IGVsZW1lbnQgQSBuZXcgSFRNTEVsZW1lbnQsIGEgb3V0ZXJIVE1MIG9mIGVsZW1lbnQsIG9yIGFuIGFycmF5IG9mIGJvdGhcclxuICAgKiA8a28+7IOI66Gc7Jq0IEhUTUxFbGVtZW50LCDtmLnsnYAg7JeY66as66i87Yq47J2YIG91dGVySFRNTCwg7Zi57J2AIOq3uOqyg+uTpOydmCDrsLDsl7Q8L2tvPlxyXG4gICAqIEByZXR1cm4ge1BhbmVsW119IEFuIGFycmF5IG9mIGFwcGVuZGVkIHBhbmVsczxrbz7stpTqsIDrkJwg7Yyo64SQ65Ok7J2YIOuwsOyXtDwva28+XHJcbiAgICogQHNlZSBQYW5lbFxyXG4gICAqIEBzZWUgRWxlbWVudExpa2VcclxuICAgKiBAdGhyb3dzIHtGbGlja2luZ0Vycm9yfSB7QGxpbmsgRVJST1JfQ09ERSBFUlJPUl9DT0RFLk5PVF9BTExPV0VEX0lOX0ZSQU1FV09SS30gaWYgY2FsbGVkIG9uIGZyYW1ld29ya3MgKFJlYWN0LCBBbmd1bGFyLCBWdWUuLi4pXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBgYGB0c1xyXG4gICAqIGNvbnN0IGZsaWNraW5nID0gbmV3IEZsaWNraW5nKFwiI2ZsaWNrXCIpO1xyXG4gICAqIC8vIFRoZXNlIGFyZSBwb3NzaWJsZSBwYXJhbWV0ZXJzXHJcbiAgICogZmxpY2tpbmcuYXBwZW5kKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpO1xyXG4gICAqIGZsaWNraW5nLmFwcGVuZChcIlxcPGRpdlxcPlBhbmVsXFw8L2RpdlxcPlwiKTtcclxuICAgKiBmbGlja2luZy5hcHBlbmQoW1wiXFw8ZGl2XFw+UGFuZWxcXDwvZGl2XFw+XCIsIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIildKTtcclxuICAgKiAvLyBFdmVuIHRoaXMgaXMgcG9zc2libGVcclxuICAgKiBmbGlja2luZy5hcHBlbmQoXCJcXDxkaXZcXD5QYW5lbCAxXFw8L2RpdlxcPlxcPGRpdlxcPlBhbmVsIDJcXDwvZGl2XFw+XCIpO1xyXG4gICAqIGBgYFxyXG4gICAqL1xuICBfX3Byb3RvLmFwcGVuZCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgcmV0dXJuIHRoaXMuaW5zZXJ0KHRoaXMuX3JlbmRlcmVyLnBhbmVsQ291bnQsIGVsZW1lbnQpO1xuICB9O1xuICAvKipcclxuICAgKiBBZGQgbmV3IHBhbmVscyBiZWZvcmUgdGhlIGZpcnN0IHBhbmVsXHJcbiAgICogVGhpcyB3aWxsIGluY3JlYXNlIGluZGV4IG9mIHBhbmVscyBhZnRlciBieSB0aGUgbnVtYmVyIG9mIHBhbmVscyBhZGRlZFxyXG4gICAqIEBrbyDtjKjrhJAg66qp66Gd7J2YIOygnOydvCDslZ4oaW5kZXggMCnsl5Ag7IOI66Gc7Jq0IO2MqOuEkOuTpOydhCDstpTqsIDtlanri4jri6RcclxuICAgKiDstpTqsIDtlZwg7Yyo64SQ7J2YIOqwnOyImOunjO2BvCDquLDsobQg7Yyo64SQ65Ok7J2YIOyduOuNseyKpOqwgCDspp3qsIDtlanri4jri6QuXHJcbiAgICogQHBhcmFtIHtFbGVtZW50TGlrZSB8IEVsZW1lbnRMaWtlW119IGVsZW1lbnQgQSBuZXcgSFRNTEVsZW1lbnQsIGEgb3V0ZXJIVE1MIG9mIGVsZW1lbnQsIG9yIGFuIGFycmF5IG9mIGJvdGhcclxuICAgKiA8a28+7IOI66Gc7Jq0IEhUTUxFbGVtZW50LCDtmLnsnYAg7JeY66as66i87Yq47J2YIG91dGVySFRNTCwg7Zi57J2AIOq3uOqyg+uTpOydmCDrsLDsl7Q8L2tvPlxyXG4gICAqIEByZXR1cm4ge1BhbmVsW119IEFuIGFycmF5IG9mIHByZXBlbmRlZCBwYW5lbHM8a28+7LaU6rCA65CcIO2MqOuEkOuTpOydmCDrsLDsl7Q8L2tvPlxyXG4gICAqIEBzZWUgUGFuZWxcclxuICAgKiBAc2VlIEVsZW1lbnRMaWtlXHJcbiAgICogQHRocm93cyB7RmxpY2tpbmdFcnJvcn0ge0BsaW5rIEVSUk9SX0NPREUgRVJST1JfQ09ERS5OT1RfQUxMT1dFRF9JTl9GUkFNRVdPUkt9IGlmIGNhbGxlZCBvbiBmcmFtZXdvcmtzIChSZWFjdCwgQW5ndWxhciwgVnVlLi4uKVxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogYGBgdHNcclxuICAgKiBjb25zdCBmbGlja2luZyA9IG5ldyBlZy5GbGlja2luZyhcIiNmbGlja1wiKTtcclxuICAgKiBmbGlja2luZy5wcmVwZW5kKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpO1xyXG4gICAqIGZsaWNraW5nLnByZXBlbmQoXCJcXDxkaXZcXD5QYW5lbFxcPC9kaXZcXD5cIik7XHJcbiAgICogZmxpY2tpbmcucHJlcGVuZChbXCJcXDxkaXZcXD5QYW5lbFxcPC9kaXZcXD5cIiwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKV0pO1xyXG4gICAqIC8vIEV2ZW4gdGhpcyBpcyBwb3NzaWJsZVxyXG4gICAqIGZsaWNraW5nLnByZXBlbmQoXCJcXDxkaXZcXD5QYW5lbCAxXFw8L2RpdlxcPlxcPGRpdlxcPlBhbmVsIDJcXDwvZGl2XFw+XCIpO1xyXG4gICAqIGBgYFxyXG4gICAqL1xuICBfX3Byb3RvLnByZXBlbmQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIHJldHVybiB0aGlzLmluc2VydCgwLCBlbGVtZW50KTtcbiAgfTtcbiAgLyoqXHJcbiAgICogSW5zZXJ0IG5ldyBwYW5lbHMgYXQgZ2l2ZW4gaW5kZXhcclxuICAgKiBUaGlzIHdpbGwgaW5jcmVhc2UgaW5kZXggb2YgcGFuZWxzIGFmdGVyIGJ5IHRoZSBudW1iZXIgb2YgcGFuZWxzIGFkZGVkXHJcbiAgICogQGtvIOyjvOyWtOynhCDsnbjrjbHsiqTsl5Ag7IOI66Gc7Jq0IO2MqOuEkOuTpOydhCDstpTqsIDtlanri4jri6RcclxuICAgKiDtlbTri7kg7J24642x7Iqk67O064ukIOqwmeqxsOuCmCDtgbAg7J24642x7Iqk66W8IOqwgOynhCDquLDsobQg7Yyo64SQ65Ok7J2AIOy2lOqwgO2VnCDtjKjrhJDsnZgg6rCc7IiY66eM7YG8IOyduOuNseyKpOqwgCDspp3qsIDtlanri4jri6QuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IHRvIGluc2VydCBuZXcgcGFuZWxzIGF0PGtvPuyDiOuhnCDtjKjrhJDrk6TsnYQg7LaU6rCA7ZWgIOyduOuNseyKpDwva28+XHJcbiAgICogQHBhcmFtIHtFbGVtZW50TGlrZSB8IEVsZW1lbnRMaWtlW119IGVsZW1lbnQgQSBuZXcgSFRNTEVsZW1lbnQsIGEgb3V0ZXJIVE1MIG9mIGVsZW1lbnQsIG9yIGFuIGFycmF5IG9mIGJvdGhcclxuICAgKiA8a28+7IOI66Gc7Jq0IEhUTUxFbGVtZW50LCDtmLnsnYAg7JeY66as66i87Yq47J2YIG91dGVySFRNTCwg7Zi57J2AIOq3uOqyg+uTpOydmCDrsLDsl7Q8L2tvPlxyXG4gICAqIEByZXR1cm4ge1BhbmVsW119IEFuIGFycmF5IG9mIHByZXBlbmRlZCBwYW5lbHM8a28+7LaU6rCA65CcIO2MqOuEkOuTpOydmCDrsLDsl7Q8L2tvPlxyXG4gICAqIEB0aHJvd3Mge0ZsaWNraW5nRXJyb3J9IHtAbGluayBFUlJPUl9DT0RFIEVSUk9SX0NPREUuTk9UX0FMTE9XRURfSU5fRlJBTUVXT1JLfSBpZiBjYWxsZWQgb24gZnJhbWV3b3JrcyAoUmVhY3QsIEFuZ3VsYXIsIFZ1ZS4uLilcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGBgYHRzXHJcbiAgICogY29uc3QgZmxpY2tpbmcgPSBuZXcgZWcuRmxpY2tpbmcoXCIjZmxpY2tcIik7XHJcbiAgICogZmxpY2tpbmcuaW5zZXJ0KDAsIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpO1xyXG4gICAqIGZsaWNraW5nLmluc2VydCgyLCBcIlxcPGRpdlxcPlBhbmVsXFw8L2RpdlxcPlwiKTtcclxuICAgKiBmbGlja2luZy5pbnNlcnQoMSwgW1wiXFw8ZGl2XFw+UGFuZWxcXDwvZGl2XFw+XCIsIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIildKTtcclxuICAgKiAvLyBFdmVuIHRoaXMgaXMgcG9zc2libGVcclxuICAgKiBmbGlja2luZy5pbnNlcnQoMywgXCJcXDxkaXZcXD5QYW5lbCAxXFw8L2RpdlxcPlxcPGRpdlxcPlBhbmVsIDJcXDwvZGl2XFw+XCIpO1xyXG4gICAqIGBgYFxyXG4gICAqL1xuICBfX3Byb3RvLmluc2VydCA9IGZ1bmN0aW9uIChpbmRleCwgZWxlbWVudCkge1xuICAgIGlmICh0aGlzLl9yZW5kZXJFeHRlcm5hbCkge1xuICAgICAgdGhyb3cgbmV3IEZsaWNraW5nRXJyb3IoTUVTU0FHRS5OT1RfQUxMT1dFRF9JTl9GUkFNRVdPUkssIENPREUuTk9UX0FMTE9XRURfSU5fRlJBTUVXT1JLKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3JlbmRlcmVyLmJhdGNoSW5zZXJ0KHtcbiAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgIGVsZW1lbnRzOiBwYXJzZUVsZW1lbnQoZWxlbWVudCksXG4gICAgICBoYXNET01JbkVsZW1lbnRzOiB0cnVlXG4gICAgfSk7XG4gIH07XG4gIC8qKlxyXG4gICAqIFJlbW92ZSB0aGUgcGFuZWwgYXQgdGhlIGdpdmVuIGluZGV4XHJcbiAgICogVGhpcyB3aWxsIGRlY3JlYXNlIGluZGV4IG9mIHBhbmVscyBhZnRlciBieSB0aGUgbnVtYmVyIG9mIHBhbmVscyByZW1vdmVkXHJcbiAgICogQGtvIOyjvOyWtOynhCDsnbjrjbHsiqTsnZgg7Yyo64SQ7J2EIOygnOqxsO2VqeuLiOuLpFxyXG4gICAqIO2VtOuLuSDsnbjrjbHsiqTrs7Tri6Qg7YGwIOyduOuNseyKpOulvCDqsIDsp4Qg6riw7KG0IO2MqOuEkOuTpOydgCDsoJzqsbDtlZwg7Yyo64SQ7J2YIOqwnOyImOunjO2BvCDsnbjrjbHsiqTqsIAg6rCQ7IaM7ZWp64uI64ukXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IG9mIHBhbmVsIHRvIHJlbW92ZTxrbz7soJzqsbDtlaAg7Yyo64SQ7J2YIOyduOuNseyKpDwva28+XHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtkZWxldGVDb3VudD0xXSBOdW1iZXIgb2YgcGFuZWxzIHRvIHJlbW92ZSBmcm9tIGluZGV4PGtvPmBpbmRleGAg7J207ZuE66GcIOygnOqxsO2VoCDtjKjrhJDsnZgg6rCc7IiYPC9rbz5cclxuICAgKiBAcmV0dXJuIHtQYW5lbFtdfSBBbiBhcnJheSBvZiByZW1vdmVkIHBhbmVsczxrbz7soJzqsbDrkJwg7Yyo64SQ65Ok7J2YIOuwsOyXtDwva28+XHJcbiAgICovXG4gIF9fcHJvdG8ucmVtb3ZlID0gZnVuY3Rpb24gKGluZGV4LCBkZWxldGVDb3VudCkge1xuICAgIGlmIChkZWxldGVDb3VudCA9PT0gdm9pZCAwKSB7XG4gICAgICBkZWxldGVDb3VudCA9IDE7XG4gICAgfVxuICAgIGlmICh0aGlzLl9yZW5kZXJFeHRlcm5hbCkge1xuICAgICAgdGhyb3cgbmV3IEZsaWNraW5nRXJyb3IoTUVTU0FHRS5OT1RfQUxMT1dFRF9JTl9GUkFNRVdPUkssIENPREUuTk9UX0FMTE9XRURfSU5fRlJBTUVXT1JLKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3JlbmRlcmVyLmJhdGNoUmVtb3ZlKHtcbiAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgIGRlbGV0ZUNvdW50OiBkZWxldGVDb3VudCxcbiAgICAgIGhhc0RPTUluRWxlbWVudHM6IHRydWVcbiAgICB9KTtcbiAgfTtcbiAgX19wcm90by5fY3JlYXRlQ29udHJvbCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX2E7XG4gICAgdmFyIG1vdmVUeXBlID0gdGhpcy5fbW92ZVR5cGU7XG4gICAgdmFyIG1vdmVUeXBlcyA9IE9iamVjdC5rZXlzKE1PVkVfVFlQRSkubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJldHVybiBNT1ZFX1RZUEVba2V5XTtcbiAgICB9KTtcbiAgICB2YXIgbW92ZVR5cGVTdHIgPSBBcnJheS5pc0FycmF5KG1vdmVUeXBlKSA/IG1vdmVUeXBlWzBdIDogbW92ZVR5cGU7XG4gICAgdmFyIG1vdmVUeXBlT3B0aW9ucyA9IEFycmF5LmlzQXJyYXkobW92ZVR5cGUpID8gKF9hID0gbW92ZVR5cGVbMV0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHt9IDoge307XG4gICAgaWYgKCFpbmNsdWRlcyhtb3ZlVHlwZXMsIG1vdmVUeXBlU3RyKSkge1xuICAgICAgdGhyb3cgbmV3IEZsaWNraW5nRXJyb3IoTUVTU0FHRS5XUk9OR19PUFRJT04oXCJtb3ZlVHlwZVwiLCBKU09OLnN0cmluZ2lmeShtb3ZlVHlwZSkpLCBDT0RFLldST05HX09QVElPTik7XG4gICAgfVxuICAgIHN3aXRjaCAobW92ZVR5cGVTdHIpIHtcbiAgICAgIGNhc2UgTU9WRV9UWVBFLlNOQVA6XG4gICAgICAgIHJldHVybiBuZXcgU25hcENvbnRyb2wobW92ZVR5cGVPcHRpb25zKTtcbiAgICAgIGNhc2UgTU9WRV9UWVBFLkZSRUVfU0NST0xMOlxuICAgICAgICByZXR1cm4gbmV3IEZyZWVDb250cm9sKG1vdmVUeXBlT3B0aW9ucyk7XG4gICAgICBjYXNlIE1PVkVfVFlQRS5TVFJJQ1Q6XG4gICAgICAgIHJldHVybiBuZXcgU3RyaWN0Q29udHJvbChtb3ZlVHlwZU9wdGlvbnMpO1xuICAgIH1cbiAgfTtcbiAgX19wcm90by5fY3JlYXRlQ2FtZXJhID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9jaXJjdWxhciAmJiB0aGlzLl9ib3VuZCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUud2FybihcIlxcXCJjaXJjdWxhclxcXCIgYW5kIFxcXCJib3VuZFxcXCIgb3B0aW9uIGNhbm5vdCBiZSB1c2VkIHRvZ2V0aGVyLCBpZ25vcmluZyBib3VuZC5cIik7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQ2FtZXJhKHRoaXMsIHtcbiAgICAgIGFsaWduOiB0aGlzLl9hbGlnblxuICAgIH0pO1xuICB9O1xuICBfX3Byb3RvLl9jcmVhdGVSZW5kZXJlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZXJuYWxSZW5kZXJlciA9IHRoaXMuX2V4dGVybmFsUmVuZGVyZXI7XG4gICAgaWYgKHRoaXMuX3ZpcnR1YWwgJiYgdGhpcy5fcGFuZWxzUGVyVmlldyA8PSAwKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgY29uc29sZS53YXJuKFwiXFxcInZpcnR1YWxcXFwiIGFuZCBcXFwicGFuZWxzUGVyVmlld1xcXCIgb3B0aW9uIHNob3VsZCBiZSB1c2VkIHRvZ2V0aGVyLCBpZ25vcmluZyB2aXJ0dWFsLlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGV4dGVybmFsUmVuZGVyZXIgPyBleHRlcm5hbFJlbmRlcmVyIDogdGhpcy5fcmVuZGVyRXh0ZXJuYWwgPyB0aGlzLl9jcmVhdGVFeHRlcm5hbFJlbmRlcmVyKCkgOiB0aGlzLl9jcmVhdGVWYW5pbGxhUmVuZGVyZXIoKTtcbiAgfTtcbiAgX19wcm90by5fY3JlYXRlRXh0ZXJuYWxSZW5kZXJlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX2EgPSB0aGlzLl9yZW5kZXJFeHRlcm5hbCxcbiAgICAgIHJlbmRlcmVyID0gX2EucmVuZGVyZXIsXG4gICAgICByZW5kZXJlck9wdGlvbnMgPSBfYS5yZW5kZXJlck9wdGlvbnM7XG4gICAgcmV0dXJuIG5ldyByZW5kZXJlcihfX2Fzc2lnbiQyKHtcbiAgICAgIGFsaWduOiB0aGlzLl9hbGlnblxuICAgIH0sIHJlbmRlcmVyT3B0aW9ucykpO1xuICB9O1xuICBfX3Byb3RvLl9jcmVhdGVWYW5pbGxhUmVuZGVyZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZpcnR1YWwgPSB0aGlzLnZpcnR1YWxFbmFibGVkO1xuICAgIHJldHVybiBuZXcgVmFuaWxsYVJlbmRlcmVyKHtcbiAgICAgIGFsaWduOiB0aGlzLl9hbGlnbixcbiAgICAgIHN0cmF0ZWd5OiB2aXJ0dWFsID8gbmV3IFZpcnR1YWxSZW5kZXJpbmdTdHJhdGVneSgpIDogbmV3IE5vcm1hbFJlbmRlcmluZ1N0cmF0ZWd5KHtcbiAgICAgICAgcHJvdmlkZXJDdG9yOiBWYW5pbGxhRWxlbWVudFByb3ZpZGVyXG4gICAgICB9KVxuICAgIH0pO1xuICB9O1xuICBfX3Byb3RvLl9tb3ZlVG9Jbml0aWFsUGFuZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXI7XG4gICAgdmFyIGNvbnRyb2wgPSB0aGlzLl9jb250cm9sO1xuICAgIHZhciBjYW1lcmEgPSB0aGlzLl9jYW1lcmE7XG4gICAgdmFyIGRlZmF1bHRQYW5lbCA9IHJlbmRlcmVyLmdldFBhbmVsKHRoaXMuX2RlZmF1bHRJbmRleCkgfHwgcmVuZGVyZXIuZ2V0UGFuZWwoMCk7XG4gICAgaWYgKCFkZWZhdWx0UGFuZWwpIHJldHVybjtcbiAgICB2YXIgbmVhcmVzdEFuY2hvciA9IGNhbWVyYS5maW5kTmVhcmVzdEFuY2hvcihkZWZhdWx0UGFuZWwucG9zaXRpb24pO1xuICAgIHZhciBpbml0aWFsUGFuZWwgPSBuZWFyZXN0QW5jaG9yICYmIGRlZmF1bHRQYW5lbC5pbmRleCAhPT0gbmVhcmVzdEFuY2hvci5wYW5lbC5pbmRleCA/IG5lYXJlc3RBbmNob3IucGFuZWwgOiBkZWZhdWx0UGFuZWw7XG4gICAgY29udHJvbC5zZXRBY3RpdmUoaW5pdGlhbFBhbmVsLCBudWxsLCBmYWxzZSk7XG4gICAgaWYgKCFuZWFyZXN0QW5jaG9yKSB7XG4gICAgICB0aHJvdyBuZXcgRmxpY2tpbmdFcnJvcihNRVNTQUdFLlBPU0lUSU9OX05PVF9SRUFDSEFCTEUoaW5pdGlhbFBhbmVsLnBvc2l0aW9uKSwgQ09ERS5QT1NJVElPTl9OT1RfUkVBQ0hBQkxFKTtcbiAgICB9XG4gICAgdmFyIHBvc2l0aW9uID0gaW5pdGlhbFBhbmVsLnBvc2l0aW9uO1xuICAgIGlmICghY2FtZXJhLmNhblJlYWNoKGluaXRpYWxQYW5lbCkpIHtcbiAgICAgIHBvc2l0aW9uID0gbmVhcmVzdEFuY2hvci5wb3NpdGlvbjtcbiAgICB9XG4gICAgY2FtZXJhLmxvb2tBdChwb3NpdGlvbik7XG4gICAgY29udHJvbC51cGRhdGVJbnB1dCgpO1xuICAgIGNhbWVyYS51cGRhdGVPZmZzZXQoKTtcbiAgfTtcbiAgX19wcm90by5faW5pdGlhbFJlc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdmlld3BvcnQgPSB0aGlzLl92aWV3cG9ydDtcbiAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLl9yZW5kZXJlcjtcbiAgICB2YXIgY2FtZXJhID0gdGhpcy5fY2FtZXJhO1xuICAgIHZhciBjb250cm9sID0gdGhpcy5fY29udHJvbDtcbiAgICB0aGlzLnRyaWdnZXIobmV3IENvbXBvbmVudEV2ZW50JDEoRVZFTlRTLkJFRk9SRV9SRVNJWkUsIHtcbiAgICAgIHdpZHRoOiAwLFxuICAgICAgaGVpZ2h0OiAwLFxuICAgICAgZWxlbWVudDogdmlld3BvcnQuZWxlbWVudFxuICAgIH0pKTtcbiAgICB2aWV3cG9ydC5yZXNpemUoKTtcbiAgICByZW5kZXJlci51cGRhdGVQYW5lbFNpemUoKTtcbiAgICBjYW1lcmEudXBkYXRlQWxpZ25Qb3MoKTtcbiAgICBjYW1lcmEudXBkYXRlUmFuZ2UoKTtcbiAgICBjYW1lcmEudXBkYXRlQW5jaG9ycygpO1xuICAgIGNhbWVyYS51cGRhdGVPZmZzZXQoKTtcbiAgICBjb250cm9sLnVwZGF0ZUlucHV0KCk7XG4gICAgdmFyIG5ld1dpZHRoID0gdmlld3BvcnQud2lkdGg7XG4gICAgdmFyIG5ld0hlaWdodCA9IHZpZXdwb3J0LmhlaWdodDtcbiAgICB2YXIgc2l6ZUNoYW5nZWQgPSBuZXdXaWR0aCAhPT0gMCB8fCBuZXdIZWlnaHQgIT09IDA7XG4gICAgdGhpcy50cmlnZ2VyKG5ldyBDb21wb25lbnRFdmVudCQxKEVWRU5UUy5BRlRFUl9SRVNJWkUsIHtcbiAgICAgIHdpZHRoOiB2aWV3cG9ydC53aWR0aCxcbiAgICAgIGhlaWdodDogdmlld3BvcnQuaGVpZ2h0LFxuICAgICAgcHJldjoge1xuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgaGVpZ2h0OiAwXG4gICAgICB9LFxuICAgICAgc2l6ZUNoYW5nZWQ6IHNpemVDaGFuZ2VkLFxuICAgICAgZWxlbWVudDogdmlld3BvcnQuZWxlbWVudFxuICAgIH0pKTtcbiAgfTtcbiAgLyoqXHJcbiAgICogVmVyc2lvbiBpbmZvIHN0cmluZ1xyXG4gICAqIEBrbyDrsoTsoITsoJXrs7Qg66y47J6Q7Je0XHJcbiAgICogQHR5cGUge3N0cmluZ31cclxuICAgKiBAcmVhZG9ubHlcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGBgYHRzXHJcbiAgICogRmxpY2tpbmcuVkVSU0lPTjsgIC8vIGV4KSA0LjAuMFxyXG4gICAqIGBgYFxyXG4gICAqL1xuICBGbGlja2luZy5WRVJTSU9OID0gXCI0LjExLjRcIjtcbiAgcmV0dXJuIEZsaWNraW5nO1xufShDb21wb25lbnQpO1xuXG4vKipcclxuICogRGVjb3JhdG9yIHRoYXQgbWFrZXMgdGhlIG1ldGhvZCBvZiBmbGlja2luZyBhdmFpbGFibGUgaW4gdGhlIGZyYW1ld29yay5cclxuICogQGtvIO2UhOugiOyehOybjO2BrOyXkOyEnCDtlIzrpqztgrnsnZgg66mU7IaM65Oc66W8IOyCrOyaqe2VoCDsiJgg7J6I6rKMIO2VmOuKlCDrjbDsvZTroIjsnbTthLAuXHJcbiAqIEBtZW1iZXJvZiBlZy5GbGlja2luZ1xyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGBqc1xyXG4gKiBpbXBvcnQgRmxpY2tpbmcsIHsgd2l0aEZsaWNraW5nTWV0aG9kcyB9IGZyb20gXCJAZWdqcy9mbGlja2luZ1wiO1xyXG4gKlxyXG4gKiBjbGFzcyBGbGlja2luZyBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxQYXJ0aWFsPEZsaWNraW5nUHJvcHMgJiBGbGlja2luZ09wdGlvbnM+PiB7XHJcbiAqICAgJiM2NDt3aXRoRmxpY2tpbmdNZXRob2RzXHJcbiAqICAgcHJpdmF0ZSBmbGlja2luZzogRmxpY2tpbmc7XHJcbiAqIH1cclxuICogYGBgXHJcbiAqL1xudmFyIHdpdGhGbGlja2luZ01ldGhvZHMgPSBmdW5jdGlvbiAocHJvdG90eXBlLCBmbGlja2luZ05hbWUpIHtcbiAgW0NvbXBvbmVudC5wcm90b3R5cGUsIEZsaWNraW5nLnByb3RvdHlwZV0uZm9yRWFjaChmdW5jdGlvbiAocHJvdG8pIHtcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwcm90bykuZmlsdGVyKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICByZXR1cm4gIXByb3RvdHlwZVtuYW1lXSAmJiBuYW1lLmluZGV4T2YoXCJfXCIpICE9PSAwICYmIG5hbWUgIT09IFwiY29uc3RydWN0b3JcIjtcbiAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocHJvdG8sIG5hbWUpO1xuICAgICAgaWYgKGRlc2NyaXB0b3IudmFsdWUpIHtcbiAgICAgICAgLy8gUHVibGljIEZ1bmN0aW9uXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90b3R5cGUsIG5hbWUsIHtcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoX2EgPSBkZXNjcmlwdG9yLnZhbHVlKS5jYWxsLmFwcGx5KF9hLCBfX3NwcmVhZCQxKFt0aGlzW2ZsaWNraW5nTmFtZV1dLCBhcmdzKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBnZXR0ZXJEZXNjcmlwdG9yID0ge307XG4gICAgICAgIGlmIChkZXNjcmlwdG9yLmdldCkge1xuICAgICAgICAgIGdldHRlckRlc2NyaXB0b3IuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgdmFyIGZsaWNraW5nID0gdGhpc1tmbGlja2luZ05hbWVdO1xuICAgICAgICAgICAgcmV0dXJuIGZsaWNraW5nICYmICgoX2EgPSBkZXNjcmlwdG9yLmdldCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoZmxpY2tpbmcpKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZXNjcmlwdG9yLnNldCkge1xuICAgICAgICAgIGdldHRlckRlc2NyaXB0b3Iuc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoX2EgPSBkZXNjcmlwdG9yLnNldCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwuYXBwbHkoX2EsIF9fc3ByZWFkJDEoW3RoaXNbZmxpY2tpbmdOYW1lXV0sIGFyZ3MpKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90b3R5cGUsIG5hbWUsIGdldHRlckRlc2NyaXB0b3IpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn07XG5cbnZhciBzeW5jID0gKGZ1bmN0aW9uIChmbGlja2luZywgZGlmZlJlc3VsdCwgcmVuZGVyZWQpIHtcbiAgdmFyIHJlbmRlcmVyID0gZmxpY2tpbmcucmVuZGVyZXI7XG4gIHZhciBwYW5lbHMgPSByZW5kZXJlci5wYW5lbHM7XG4gIHZhciBwcmV2TGlzdCA9IF9fc3ByZWFkJDEoZGlmZlJlc3VsdC5wcmV2TGlzdCk7XG4gIHZhciBhZGRlZCA9IFtdO1xuICB2YXIgcmVtb3ZlZCA9IFtdO1xuICBpZiAoZGlmZlJlc3VsdC5yZW1vdmVkLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgZW5kSWR4XzEgPSAtMTtcbiAgICB2YXIgcHJldklkeF8xID0gLTE7XG4gICAgZGlmZlJlc3VsdC5yZW1vdmVkLmZvckVhY2goZnVuY3Rpb24gKHJlbW92ZWRJZHgpIHtcbiAgICAgIGlmIChlbmRJZHhfMSA8IDApIHtcbiAgICAgICAgZW5kSWR4XzEgPSByZW1vdmVkSWR4O1xuICAgICAgfVxuICAgICAgaWYgKHByZXZJZHhfMSA+PSAwICYmIHJlbW92ZWRJZHggIT09IHByZXZJZHhfMSAtIDEpIHtcbiAgICAgICAgcmVtb3ZlZC5wdXNoLmFwcGx5KHJlbW92ZWQsIF9fc3ByZWFkJDEoYmF0Y2hSZW1vdmUocmVuZGVyZXIsIHByZXZJZHhfMSwgZW5kSWR4XzEgKyAxKSkpO1xuICAgICAgICBlbmRJZHhfMSA9IHJlbW92ZWRJZHg7XG4gICAgICAgIHByZXZJZHhfMSA9IHJlbW92ZWRJZHg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcmV2SWR4XzEgPSByZW1vdmVkSWR4O1xuICAgICAgfVxuICAgICAgcHJldkxpc3Quc3BsaWNlKHJlbW92ZWRJZHgsIDEpO1xuICAgIH0pO1xuICAgIHJlbW92ZWQucHVzaC5hcHBseShyZW1vdmVkLCBfX3NwcmVhZCQxKGJhdGNoUmVtb3ZlKHJlbmRlcmVyLCBwcmV2SWR4XzEsIGVuZElkeF8xICsgMSkpKTtcbiAgfVxuICBkaWZmUmVzdWx0Lm9yZGVyZWQuZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgX2IgPSBfX3JlYWQkMShfYSwgMiksXG4gICAgICBmcm9tID0gX2JbMF0sXG4gICAgICB0byA9IF9iWzFdO1xuICAgIHZhciBwcmV2UGFuZWwgPSBwYW5lbHMuc3BsaWNlKGZyb20sIDEpWzBdO1xuICAgIHBhbmVscy5zcGxpY2UodG8sIDAsIHByZXZQYW5lbCk7XG4gIH0pO1xuICBpZiAoZGlmZlJlc3VsdC5vcmRlcmVkLmxlbmd0aCA+IDApIHtcbiAgICBwYW5lbHMuZm9yRWFjaChmdW5jdGlvbiAocGFuZWwsIGlkeCkge1xuICAgICAgdmFyIGluZGV4RGlmZiA9IGlkeCAtIHBhbmVsLmluZGV4O1xuICAgICAgaWYgKGluZGV4RGlmZiA+IDApIHtcbiAgICAgICAgcGFuZWwuaW5jcmVhc2VJbmRleChpbmRleERpZmYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFuZWwuZGVjcmVhc2VJbmRleCgtaW5kZXhEaWZmKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBwYW5lbHMuc29ydChmdW5jdGlvbiAocGFuZWwxLCBwYW5lbDIpIHtcbiAgICAgIHJldHVybiBwYW5lbDEuaW5kZXggLSBwYW5lbDIuaW5kZXg7XG4gICAgfSk7XG4gICAgcGFuZWxzLmZvckVhY2goZnVuY3Rpb24gKHBhbmVsKSB7XG4gICAgICBwYW5lbC51cGRhdGVQb3NpdGlvbigpO1xuICAgIH0pO1xuICB9XG4gIGlmIChkaWZmUmVzdWx0LmFkZGVkLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgc3RhcnRJZHhfMSA9IC0xO1xuICAgIHZhciBwcmV2SWR4XzIgPSAtMTtcbiAgICB2YXIgYWRkZWRFbGVtZW50c18xID0gcmVuZGVyZWQuc2xpY2UocHJldkxpc3QubGVuZ3RoKTtcbiAgICBkaWZmUmVzdWx0LmFkZGVkLmZvckVhY2goZnVuY3Rpb24gKGFkZGVkSWR4LCBpZHgpIHtcbiAgICAgIGlmIChzdGFydElkeF8xIDwgMCkge1xuICAgICAgICBzdGFydElkeF8xID0gaWR4O1xuICAgICAgfVxuICAgICAgaWYgKHByZXZJZHhfMiA+PSAwICYmIGFkZGVkSWR4ICE9PSBwcmV2SWR4XzIgKyAxKSB7XG4gICAgICAgIGFkZGVkLnB1c2guYXBwbHkoYWRkZWQsIF9fc3ByZWFkJDEoYmF0Y2hJbnNlcnQocmVuZGVyZXIsIGRpZmZSZXN1bHQsIGFkZGVkRWxlbWVudHNfMSwgc3RhcnRJZHhfMSwgaWR4ICsgMSkpKTtcbiAgICAgICAgc3RhcnRJZHhfMSA9IC0xO1xuICAgICAgICBwcmV2SWR4XzIgPSAtMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByZXZJZHhfMiA9IGFkZGVkSWR4O1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChzdGFydElkeF8xID49IDApIHtcbiAgICAgIGFkZGVkLnB1c2guYXBwbHkoYWRkZWQsIF9fc3ByZWFkJDEoYmF0Y2hJbnNlcnQocmVuZGVyZXIsIGRpZmZSZXN1bHQsIGFkZGVkRWxlbWVudHNfMSwgc3RhcnRJZHhfMSkpKTtcbiAgICB9XG4gIH1cbiAgaWYgKGRpZmZSZXN1bHQuYWRkZWQubGVuZ3RoID4gMCB8fCBkaWZmUmVzdWx0LnJlbW92ZWQubGVuZ3RoID4gMCkge1xuICAgIHJlbmRlcmVyLnVwZGF0ZUFmdGVyUGFuZWxDaGFuZ2UoYWRkZWQsIHJlbW92ZWQpO1xuICB9XG59KTtcbnZhciBiYXRjaEluc2VydCA9IGZ1bmN0aW9uIChyZW5kZXJlciwgZGlmZlJlc3VsdCwgYWRkZWRFbGVtZW50cywgc3RhcnRJZHgsIGVuZElkeCkge1xuICByZXR1cm4gcmVuZGVyZXIuYmF0Y2hJbnNlcnREZWZlci5hcHBseShyZW5kZXJlciwgX19zcHJlYWQkMShkaWZmUmVzdWx0LmFkZGVkLnNsaWNlKHN0YXJ0SWR4LCBlbmRJZHgpLm1hcChmdW5jdGlvbiAoaW5kZXgsIGVsSWR4KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgIGVsZW1lbnRzOiBbYWRkZWRFbGVtZW50c1tlbElkeF1dLFxuICAgICAgaGFzRE9NSW5FbGVtZW50czogZmFsc2VcbiAgICB9O1xuICB9KSkpO1xufTtcbnZhciBiYXRjaFJlbW92ZSA9IGZ1bmN0aW9uIChyZW5kZXJlciwgc3RhcnRJZHgsIGVuZElkeCkge1xuICB2YXIgcmVtb3ZlZCA9IHJlbmRlcmVyLnBhbmVscy5zbGljZShzdGFydElkeCwgZW5kSWR4KTtcbiAgcmV0dXJuIHJlbmRlcmVyLmJhdGNoUmVtb3ZlRGVmZXIoe1xuICAgIGluZGV4OiBzdGFydElkeCxcbiAgICBkZWxldGVDb3VudDogcmVtb3ZlZC5sZW5ndGgsXG4gICAgaGFzRE9NSW5FbGVtZW50czogZmFsc2VcbiAgfSk7XG59O1xuXG52YXIgZ2V0UmVuZGVyaW5nUGFuZWxzID0gKGZ1bmN0aW9uIChmbGlja2luZywgZGlmZlJlc3VsdCkge1xuICB2YXIgcmVtb3ZlZFBhbmVscyA9IGRpZmZSZXN1bHQucmVtb3ZlZC5yZWR1Y2UoZnVuY3Rpb24gKG1hcCwgaWR4KSB7XG4gICAgbWFwW2lkeF0gPSB0cnVlO1xuICAgIHJldHVybiBtYXA7XG4gIH0sIHt9KTtcbiAgdmFyIG1haW50YWluZWRNYXAgPSBkaWZmUmVzdWx0Lm1haW50YWluZWQucmVkdWNlKGZ1bmN0aW9uIChtYXAsIF9hKSB7XG4gICAgdmFyIF9iID0gX19yZWFkJDEoX2EsIDIpLFxuICAgICAgcHJldiA9IF9iWzBdLFxuICAgICAgY3VycmVudCA9IF9iWzFdO1xuICAgIG1hcFtwcmV2XSA9IGN1cnJlbnQ7XG4gICAgcmV0dXJuIG1hcDtcbiAgfSwge30pO1xuICByZXR1cm4gX19zcHJlYWQkMShmbGlja2luZy5wYW5lbHMuZmlsdGVyKGZ1bmN0aW9uIChwYW5lbCkge1xuICAgIHJldHVybiAhcmVtb3ZlZFBhbmVsc1twYW5lbC5pbmRleF07XG4gIH0pXG4gIC8vIFNvcnQgcGFuZWxzIGJ5IHBvc2l0aW9uXG4gIC5zb3J0KGZ1bmN0aW9uIChwYW5lbDEsIHBhbmVsMikge1xuICAgIHJldHVybiBwYW5lbDEucG9zaXRpb24gKyBwYW5lbDEub2Zmc2V0IC0gKHBhbmVsMi5wb3NpdGlvbiArIHBhbmVsMi5vZmZzZXQpO1xuICB9KS5tYXAoZnVuY3Rpb24gKHBhbmVsKSB7XG4gICAgcmV0dXJuIGRpZmZSZXN1bHQubGlzdFttYWludGFpbmVkTWFwW3BhbmVsLmluZGV4XV07XG4gIH0pLCBkaWZmUmVzdWx0LmFkZGVkLm1hcChmdW5jdGlvbiAoaWR4KSB7XG4gICAgcmV0dXJuIGRpZmZSZXN1bHQubGlzdFtpZHhdO1xuICB9KSk7XG59KTtcblxudmFyIGdldERlZmF1bHRDYW1lcmFUcmFuc2Zvcm0gPSAoZnVuY3Rpb24gKGFsaWduLCBob3Jpem9udGFsLCBmaXJzdFBhbmVsU2l6ZSkge1xuICBpZiAoYWxpZ24gPT09IHZvaWQgMCkge1xuICAgIGFsaWduID0gQUxJR04uQ0VOVEVSO1xuICB9XG4gIGlmIChob3Jpem9udGFsID09PSB2b2lkIDApIHtcbiAgICBob3Jpem9udGFsID0gdHJ1ZTtcbiAgfVxuICB2YXIgY2FtZXJhQWxpZ24gPSBnZXRDYW1lcmFBbGlnbihhbGlnbik7XG4gIHZhciBwYW5lbEFsaWduID0gZ2V0UGFuZWxBbGlnbihhbGlnbik7XG4gIGlmIChwYW5lbEFsaWduID09IG51bGwpIHJldHVybiBcIlwiO1xuICB2YXIgY2FtUG9zaXRpb24gPSBcImNhbGMoXCIgKyBjYW1lcmFBbGlnbiArIFwiIC0gKFwiICsgKGZpcnN0UGFuZWxTaXplIHx8IFwiMHB4XCIpICsgXCIgKiBcIiArIHBhbmVsQWxpZ24ucGVyY2VudGFnZSArIFwiKSAtIFwiICsgcGFuZWxBbGlnbi5hYnNvbHV0ZSArIFwicHgpXCI7XG4gIHJldHVybiBob3Jpem9udGFsID8gXCJ0cmFuc2xhdGUoXCIgKyBjYW1Qb3NpdGlvbiArIFwiKVwiIDogXCJ0cmFuc2xhdGUoMCwgXCIgKyBjYW1Qb3NpdGlvbiArIFwiKVwiO1xufSk7XG52YXIgZ2V0Q2FtZXJhQWxpZ24gPSBmdW5jdGlvbiAoYWxpZ24pIHtcbiAgdmFyIGFsaWduVmFsID0gdHlwZW9mIGFsaWduID09PSBcIm9iamVjdFwiID8gYWxpZ24uY2FtZXJhIDogYWxpZ247XG4gIHJldHVybiBwYXJzZUFsaWduKGFsaWduVmFsKTtcbn07XG52YXIgZ2V0UGFuZWxBbGlnbiA9IGZ1bmN0aW9uIChhbGlnbikge1xuICB2YXIgYWxpZ25WYWwgPSB0eXBlb2YgYWxpZ24gPT09IFwib2JqZWN0XCIgPyBhbGlnbi5wYW5lbCA6IGFsaWduO1xuICByZXR1cm4gcGFyc2VBcml0aG1ldGljRXhwcmVzc2lvbihwYXJzZUFsaWduKGFsaWduVmFsKSk7XG59O1xudmFyIHBhcnNlQWxpZ24gPSBmdW5jdGlvbiAoYWxpZ25WYWwpIHtcbiAgaWYgKHR5cGVvZiBhbGlnblZhbCA9PT0gXCJudW1iZXJcIikge1xuICAgIHJldHVybiBhbGlnblZhbCArIFwicHhcIjtcbiAgfVxuICBzd2l0Y2ggKGFsaWduVmFsKSB7XG4gICAgY2FzZSBBTElHTi5DRU5URVI6XG4gICAgICByZXR1cm4gXCI1MCVcIjtcbiAgICBjYXNlIEFMSUdOLk5FWFQ6XG4gICAgICByZXR1cm4gXCIxMDAlXCI7XG4gICAgY2FzZSBBTElHTi5QUkVWOlxuICAgICAgcmV0dXJuIFwiMCVcIjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGFsaWduVmFsO1xuICB9XG59O1xuXG4vKlxuQ29weXJpZ2h0IChjKSAyMDE1LXByZXNlbnQgTkFWRVIgQ29ycC5cbm5hbWU6IEBlZ2pzL3JlYWN0LWZsaWNraW5nXG5saWNlbnNlOiBNSVRcbmF1dGhvcjogTkFWRVIgQ29ycC5cbnJlcG9zaXRvcnk6IGh0dHBzOi8vZ2l0aHViLmNvbS9uYXZlci9lZ2pzLWZsaWNraW5nL3RyZWUvbWFzdGVyL3BhY2thZ2VzL3JlYWN0LWZsaWNraW5nXG52ZXJzaW9uOiA0LjExLjRcbiovXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cblxudmFyIGV4dGVuZFN0YXRpY3MkNCA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gIGV4dGVuZFN0YXRpY3MkNCA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCB7XG4gICAgX19wcm90b19fOiBbXVxuICB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBkLl9fcHJvdG9fXyA9IGI7XG4gIH0gfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdO1xuICB9O1xuICByZXR1cm4gZXh0ZW5kU3RhdGljcyQ0KGQsIGIpO1xufTtcbmZ1bmN0aW9uIF9fZXh0ZW5kcyQ0KGQsIGIpIHtcbiAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbCkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICBleHRlbmRTdGF0aWNzJDQoZCwgYik7XG4gIGZ1bmN0aW9uIF9fKCkge1xuICAgIHRoaXMuY29uc3RydWN0b3IgPSBkO1xuICB9XG4gIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn1cbnZhciBfX2Fzc2lnbiQzID0gZnVuY3Rpb24gKCkge1xuICBfX2Fzc2lnbiQzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XG4gICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcbiAgICB9XG4gICAgcmV0dXJuIHQ7XG4gIH07XG4gIHJldHVybiBfX2Fzc2lnbiQzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcbiAgdmFyIHQgPSB7fTtcbiAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApIHRbcF0gPSBzW3BdO1xuICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpIHRbcFtpXV0gPSBzW3BbaV1dO1xuICB9XG4gIHJldHVybiB0O1xufVxuZnVuY3Rpb24gX19kZWNvcmF0ZSQxKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYyxcbiAgICBkO1xuICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO2Vsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59XG5mdW5jdGlvbiBfX2F3YWl0ZXIkMSh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkge1xuICAgICAgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7XG4gICAgfVxuICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBfX2dlbmVyYXRvciQxKHRoaXNBcmcsIGJvZHkpIHtcbiAgdmFyIF8gPSB7XG4gICAgICBsYWJlbDogMCxcbiAgICAgIHNlbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdO1xuICAgICAgICByZXR1cm4gdFsxXTtcbiAgICAgIH0sXG4gICAgICB0cnlzOiBbXSxcbiAgICAgIG9wczogW11cbiAgICB9LFxuICAgIGYsXG4gICAgeSxcbiAgICB0LFxuICAgIGc7XG4gIHJldHVybiBnID0ge1xuICAgIG5leHQ6IHZlcmIoMCksXG4gICAgXCJ0aHJvd1wiOiB2ZXJiKDEpLFxuICAgIFwicmV0dXJuXCI6IHZlcmIoMilcbiAgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pLCBnO1xuICBmdW5jdGlvbiB2ZXJiKG4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHYpIHtcbiAgICAgIHJldHVybiBzdGVwKFtuLCB2XSk7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgIHdoaWxlIChnICYmIChnID0gMCwgb3BbMF0gJiYgKF8gPSAwKSksIF8pIHRyeSB7XG4gICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHQgPSBvcDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIF8ubGFiZWwrKztcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IG9wWzFdLFxuICAgICAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgICAgICB9O1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgXy5sYWJlbCsrO1xuICAgICAgICAgIHkgPSBvcFsxXTtcbiAgICAgICAgICBvcCA9IFswXTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY2FzZSA3OlxuICAgICAgICAgIG9wID0gXy5vcHMucG9wKCk7XG4gICAgICAgICAgXy50cnlzLnBvcCgpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7XG4gICAgICAgICAgICBfID0gMDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSB7XG4gICAgICAgICAgICBfLmxhYmVsID0gb3BbMV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7XG4gICAgICAgICAgICBfLmxhYmVsID0gdFsxXTtcbiAgICAgICAgICAgIHQgPSBvcDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkge1xuICAgICAgICAgICAgXy5sYWJlbCA9IHRbMl07XG4gICAgICAgICAgICBfLm9wcy5wdXNoKG9wKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgXy50cnlzLnBvcCgpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgb3AgPSBbNiwgZV07XG4gICAgICB5ID0gMDtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgZiA9IHQgPSAwO1xuICAgIH1cbiAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsXG4gICAgICBkb25lOiB0cnVlXG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gX19zcHJlYWRBcnJheSh0bywgZnJvbSwgcGFjaykge1xuICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xuICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcbiAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XG4gICAgICBhcltpXSA9IGZyb21baV07XG4gICAgfVxuICB9XG4gIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xufVxuXG52YXIgREVGQVVMVF9QUk9QUyA9IHtcbiAgdmlld3BvcnRUYWc6IFwiZGl2XCIsXG4gIGNhbWVyYVRhZzogXCJkaXZcIixcbiAgY2FtZXJhQ2xhc3M6IFwiXCIsXG4gIHJlbmRlck9uU2FtZUtleTogZmFsc2UsXG4gIHBsdWdpbnM6IFtdLFxuICB1c2VGaW5kRE9NTm9kZTogZmFsc2UsXG4gIGhpZGVCZWZvcmVJbml0OiBmYWxzZSxcbiAgb25SZWFkeTogZnVuY3Rpb24gKGUpIHt9LFxuICBvbkJlZm9yZVJlc2l6ZTogZnVuY3Rpb24gKGUpIHt9LFxuICBvbkFmdGVyUmVzaXplOiBmdW5jdGlvbiAoZSkge30sXG4gIG9uSG9sZFN0YXJ0OiBmdW5jdGlvbiAoZSkge30sXG4gIG9uSG9sZEVuZDogZnVuY3Rpb24gKGUpIHt9LFxuICBvbk1vdmVTdGFydDogZnVuY3Rpb24gKGUpIHt9LFxuICBvbk1vdmU6IGZ1bmN0aW9uIChlKSB7fSxcbiAgb25Nb3ZlRW5kOiBmdW5jdGlvbiAoZSkge30sXG4gIG9uV2lsbENoYW5nZTogZnVuY3Rpb24gKGUpIHt9LFxuICBvbkNoYW5nZWQ6IGZ1bmN0aW9uIChlKSB7fSxcbiAgb25XaWxsUmVzdG9yZTogZnVuY3Rpb24gKGUpIHt9LFxuICBvblJlc3RvcmVkOiBmdW5jdGlvbiAoZSkge30sXG4gIG9uU2VsZWN0OiBmdW5jdGlvbiAoZSkge30sXG4gIG9uTmVlZFBhbmVsOiBmdW5jdGlvbiAoZSkge30sXG4gIG9uVmlzaWJsZUNoYW5nZTogZnVuY3Rpb24gKGUpIHt9LFxuICBvblJlYWNoRWRnZTogZnVuY3Rpb24gKGUpIHt9LFxuICBvblBhbmVsQ2hhbmdlOiBmdW5jdGlvbiAoZSkge31cbn07XG5cbnZhciBSZWFjdFJlbmRlcmVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzJDQoUmVhY3RSZW5kZXJlciwgX3N1cGVyKTtcbiAgZnVuY3Rpb24gUmVhY3RSZW5kZXJlcihvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9ucykgfHwgdGhpcztcbiAgICBfdGhpcy5fcmVhY3RGbGlja2luZyA9IG9wdGlvbnMucmVhY3RGbGlja2luZztcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9yZXF1aXJlLWF3YWl0XG4gIHZhciBfX3Byb3RvID0gUmVhY3RSZW5kZXJlci5wcm90b3R5cGU7XG4gIF9fcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGZsaWNraW5nLCByZWFjdEZsaWNraW5nLCBzdHJhdGVneTtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICByZXR1cm4gX19nZW5lcmF0b3IkMSh0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgZmxpY2tpbmcgPSBnZXRGbGlja2luZ0F0dGFjaGVkKHRoaXMuX2ZsaWNraW5nKTtcbiAgICAgICAgcmVhY3RGbGlja2luZyA9IHRoaXMuX3JlYWN0RmxpY2tpbmc7XG4gICAgICAgIHN0cmF0ZWd5ID0gdGhpcy5fc3RyYXRlZ3k7XG4gICAgICAgIHRoaXMuX3JlbmRlcmluZyA9IHRydWU7XG4gICAgICAgIHN0cmF0ZWd5LnVwZGF0ZVJlbmRlcmluZ1BhbmVscyhmbGlja2luZyk7XG4gICAgICAgIHN0cmF0ZWd5LnJlbmRlclBhbmVscyhmbGlja2luZyk7XG4gICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgIHJlYWN0RmxpY2tpbmcucmVuZGVyRW1pdHRlci5vbmNlKFwicmVuZGVyXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLl9yZW5kZXJpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIF90aGlzLl9hZnRlclJlbmRlcigpO1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJlYWN0RmxpY2tpbmcuZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgfSldO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG4gIF9fcHJvdG8uZm9yY2VSZW5kZXJBbGxQYW5lbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcmVhY3RGbGlja2luZztcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICByZXR1cm4gX19nZW5lcmF0b3IkMSh0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHJlYWN0RmxpY2tpbmcgPSB0aGlzLl9yZWFjdEZsaWNraW5nO1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIF9zdXBlci5wcm90b3R5cGUuZm9yY2VSZW5kZXJBbGxQYW5lbHMuY2FsbCh0aGlzKV07XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICAgIHJlYWN0RmxpY2tpbmcucmVuZGVyRW1pdHRlci5vbmNlKFwicmVuZGVyXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fcmVuZGVyaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmVhY3RGbGlja2luZy5mb3JjZVVwZGF0ZSgpO1xuICAgICAgICAgICAgfSldO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbiAgX19wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIF9zdXBlci5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuICAgIHRoaXMuX3JlYWN0RmxpY2tpbmcucmVuZGVyRW1pdHRlci5vZmYoXCJyZW5kZXJcIik7XG4gIH07XG4gIF9fcHJvdG8uX2NvbGxlY3RQYW5lbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZsaWNraW5nID0gZ2V0RmxpY2tpbmdBdHRhY2hlZCh0aGlzLl9mbGlja2luZyk7XG4gICAgdmFyIHJlYWN0RmxpY2tpbmcgPSB0aGlzLl9yZWFjdEZsaWNraW5nO1xuICAgIHZhciByZWFjdFBhbmVscyA9IHJlYWN0RmxpY2tpbmcucmVhY3RQYW5lbHM7XG4gICAgdGhpcy5fcGFuZWxzID0gdGhpcy5fc3RyYXRlZ3kuY29sbGVjdFBhbmVscyhmbGlja2luZywgcmVhY3RQYW5lbHMpO1xuICB9O1xuICBfX3Byb3RvLl9jcmVhdGVQYW5lbCA9IGZ1bmN0aW9uIChleHRlcm5hbENvbXBvbmVudCwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLl9zdHJhdGVneS5jcmVhdGVQYW5lbChleHRlcm5hbENvbXBvbmVudCwgb3B0aW9ucyk7XG4gIH07XG4gIHJldHVybiBSZWFjdFJlbmRlcmVyO1xufShFeHRlcm5hbFJlbmRlcmVyKTtcblxudmFyIFN0cmljdFBhbmVsID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzJDQoU3RyaWN0UGFuZWwsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIFN0cmljdFBhbmVsKCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIF90aGlzLl9oaWRlID0gZmFsc2U7XG4gICAgX3RoaXMuX2VsUmVmID0gY3JlYXRlUmVmKCk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIHZhciBfX3Byb3RvID0gU3RyaWN0UGFuZWwucHJvdG90eXBlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJuYXRpdmVFbGVtZW50XCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9lbFJlZi5jdXJyZW50O1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJyZW5kZXJlZFwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gIXRoaXMuX2hpZGU7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIF9fcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9oaWRlID8gY3JlYXRlRWxlbWVudChGcmFnbWVudCwgbnVsbCkgOiB0aGlzLl9nZXRFbGVtZW50KCk7XG4gIH07XG4gIF9fcHJvdG8uc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9oaWRlID0gZmFsc2U7XG4gIH07XG4gIF9fcHJvdG8uaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9oaWRlID0gdHJ1ZTtcbiAgfTtcbiAgX19wcm90by5fZ2V0RWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcm4oayQxLm9ubHkodGhpcy5wcm9wcy5jaGlsZHJlbiksIHtcbiAgICAgIHJlZjogdGhpcy5fZWxSZWZcbiAgICB9KTtcbiAgfTtcbiAgcmV0dXJuIFN0cmljdFBhbmVsO1xufShDb21wb25lbnQkMSk7XG5cbnZhciBOb25TdHJpY3RQYW5lbCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyQ0KE5vblN0cmljdFBhbmVsLCBfc3VwZXIpO1xuICBmdW5jdGlvbiBOb25TdHJpY3RQYW5lbCgpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICBfdGhpcy5faGlkZSA9IGZhbHNlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICB2YXIgX19wcm90byA9IE5vblN0cmljdFBhbmVsLnByb3RvdHlwZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwibmF0aXZlRWxlbWVudFwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gb24odGhpcyk7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcInJlbmRlcmVkXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAhdGhpcy5faGlkZTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgX19wcm90by5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hpZGUgPyBjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsKSA6IHRoaXMucHJvcHMuY2hpbGRyZW47XG4gIH07XG4gIF9fcHJvdG8uc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9oaWRlID0gZmFsc2U7XG4gIH07XG4gIF9fcHJvdG8uaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9oaWRlID0gdHJ1ZTtcbiAgfTtcbiAgcmV0dXJuIE5vblN0cmljdFBhbmVsO1xufShDb21wb25lbnQkMSk7XG5cbi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgTkFWRVIgQ29ycC5cbiAqIGVnanMgcHJvamVjdHMgYXJlIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG52YXIgVmlld3BvcnRTbG90ID0gUmVhY3RfX2RlZmF1bHQubWVtbyhmdW5jdGlvbiAocHJvcHMpIHtcbiAgcmV0dXJuIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoUmVhY3RfX2RlZmF1bHQuRnJhZ21lbnQsIG51bGwsIHByb3BzLmNoaWxkcmVuKTtcbn0pO1xuXG52YXIgUmVhY3RFbGVtZW50UHJvdmlkZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBSZWFjdEVsZW1lbnRQcm92aWRlcihlbCkge1xuICAgIHRoaXMuX2VsID0gZWw7XG4gIH1cbiAgdmFyIF9fcHJvdG8gPSBSZWFjdEVsZW1lbnRQcm92aWRlci5wcm90b3R5cGU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcImVsZW1lbnRcIiwge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2VsLm5hdGl2ZUVsZW1lbnQ7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcInJlbmRlcmVkXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9lbC5yZW5kZXJlZDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgX19wcm90by5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2VsLnNob3coKTtcbiAgfTtcbiAgX19wcm90by5oaWRlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2VsLmhpZGUoKTtcbiAgfTtcbiAgcmV0dXJuIFJlYWN0RWxlbWVudFByb3ZpZGVyO1xufSgpO1xuXG52YXIgRmxpY2tpbmckMSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyQ0KEZsaWNraW5nJDEsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIEZsaWNraW5nJDEocHJvcHMpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwcm9wcykgfHwgdGhpcztcbiAgICBfdGhpcy5fcGFuZWxzID0gW107XG4gICAgX3RoaXMuX3JlbmRlckVtaXR0ZXIgPSBuZXcgQ29tcG9uZW50KCk7XG4gICAgdmFyIGNoaWxkcmVuID0gX3RoaXMuX2dldENoaWxkcmVuKCk7XG4gICAgX3RoaXMuX3BhbmVscyA9IF90aGlzLl9jcmVhdGVQYW5lbFJlZnMocHJvcHMsIGNoaWxkcmVuKTtcbiAgICBfdGhpcy5fcHJldkNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIHZhciBfX3Byb3RvID0gRmxpY2tpbmckMS5wcm90b3R5cGU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcInJlYWN0UGFuZWxzXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wYW5lbHMubWFwKGZ1bmN0aW9uIChwYW5lbCkge1xuICAgICAgICByZXR1cm4gcGFuZWwuY3VycmVudDtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJyZW5kZXJFbWl0dGVyXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJFbWl0dGVyO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBfX3Byb3RvLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHJlbmRlcmVyT3B0aW9ucyA9IHtcbiAgICAgIHJlYWN0RmxpY2tpbmc6IHRoaXMsXG4gICAgICBhbGlnbjogcHJvcHMuYWxpZ24sXG4gICAgICBzdHJhdGVneTogcHJvcHMudmlydHVhbCAmJiBwcm9wcy5wYW5lbHNQZXJWaWV3ID4gMCA/IG5ldyBWaXJ0dWFsUmVuZGVyaW5nU3RyYXRlZ3koKSA6IG5ldyBOb3JtYWxSZW5kZXJpbmdTdHJhdGVneSh7XG4gICAgICAgIHByb3ZpZGVyQ3RvcjogUmVhY3RFbGVtZW50UHJvdmlkZXJcbiAgICAgIH0pXG4gICAgfTtcbiAgICB2YXIgZmxpY2tpbmcgPSBuZXcgRmxpY2tpbmcodGhpcy5fdmlld3BvcnRFbGVtZW50LCBfX2Fzc2lnbiQzKF9fYXNzaWduJDMoe30sIHByb3BzKSwge1xuICAgICAgZXh0ZXJuYWxSZW5kZXJlcjogbmV3IFJlYWN0UmVuZGVyZXIocmVuZGVyZXJPcHRpb25zKVxuICAgIH0pKTtcbiAgICB0aGlzLl92YW5pbGxhRmxpY2tpbmcgPSBmbGlja2luZztcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9nZXRDaGlsZHJlbigpO1xuICAgIHRoaXMuX2pzeERpZmZlciA9IG5ldyBMaXN0RGlmZmVyKGNoaWxkcmVuLCBmdW5jdGlvbiAocGFuZWwpIHtcbiAgICAgIHJldHVybiBwYW5lbC5rZXk7XG4gICAgfSk7XG4gICAgdGhpcy5fcGx1Z2luc0RpZmZlciA9IG5ldyBMaXN0RGlmZmVyKCk7XG4gICAgdGhpcy5fcHJldkNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgdGhpcy5fYmluZEV2ZW50cygpO1xuICAgIHRoaXMuX2NoZWNrUGx1Z2lucygpO1xuICAgIGlmIChwcm9wcy5zdGF0dXMpIHtcbiAgICAgIGZsaWNraW5nLnNldFN0YXR1cyhwcm9wcy5zdGF0dXMpO1xuICAgIH1cbiAgfTtcbiAgX19wcm90by5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX2E7XG4gICAgKF9hID0gdGhpcy5fdmFuaWxsYUZsaWNraW5nKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGVzdHJveSgpO1xuICB9O1xuICBfX3Byb3RvLnNob3VsZENvbXBvbmVudFVwZGF0ZSA9IGZ1bmN0aW9uIChuZXh0UHJvcHMpIHtcbiAgICB2YXIgdmFuaWxsYUZsaWNraW5nID0gdGhpcy5fdmFuaWxsYUZsaWNraW5nO1xuICAgIHZhciBwcmV2UHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIGlmICghdmFuaWxsYUZsaWNraW5nIHx8ICF2YW5pbGxhRmxpY2tpbmcuaW5pdGlhbGl6ZWQpIHJldHVybiBmYWxzZTtcbiAgICB2YXIgY2hpbGRyZW4gPSBuZXh0UHJvcHMuY2hpbGRyZW4sXG4gICAgICByZXN0UHJvcHMgPSBfX3Jlc3QobmV4dFByb3BzLCBbXCJjaGlsZHJlblwiXSk7XG4gICAgZm9yICh2YXIga2V5IGluIHJlc3RQcm9wcykge1xuICAgICAgaWYgKHByZXZQcm9wc1trZXldICE9PSBuZXh0UHJvcHNba2V5XSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHByZXZDaGlsZHJlbiA9IHRoaXMuX3ByZXZDaGlsZHJlbjtcbiAgICB2YXIgbmV4dENoaWxkcmVuID0gdGhpcy5fZ2V0Q2hpbGRyZW4oY2hpbGRyZW4pO1xuICAgIGlmIChuZXh0UHJvcHMucmVuZGVyT25TYW1lS2V5IHx8ICF0aGlzLl9oYXNTYW1lQ2hpbGRyZW4ocHJldkNoaWxkcmVuLCBuZXh0Q2hpbGRyZW4pKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG4gIF9fcHJvdG8uYmVmb3JlUmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2YW5pbGxhRmxpY2tpbmcgPSB0aGlzLl92YW5pbGxhRmxpY2tpbmc7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgcHJldkNoaWxkcmVuID0gdGhpcy5fcHJldkNoaWxkcmVuO1xuICAgIC8vIElnbm9yZSB1cGRhdGVzIGJlZm9yZSBpbml0LCB0aGV5IHdpbGwgYmUgdXBkYXRlZCBhZnRlciBcInJlYWR5XCIgZXZlbnQncyBmb3JjZSB1cGRhdGVcbiAgICAvLyBBbHNvLCBwcmV2ZW50IHVwZGF0ZXMgd2hlbiBhbm90aGVyIHVwZGF0ZSBpcyBhbHJlYWR5IHF1ZXVlZC5cbiAgICAvLyBUaGlzIHVzdWFsbHkgaGFwcGVucyB3aGVuIHJlbmRlcigpIGNhbGxlZCB0d2ljZSB3aXRob3V0IGNhbGxpbmcgY29tcG9uZW50RGlkTW91bnQsIGxpa2UgaW4gdGhlIGNhc2Ugb2YgUmVhY3QuU3RyaWN0TW9kZS5cbiAgICBpZiAoIXZhbmlsbGFGbGlja2luZyB8fCAhdmFuaWxsYUZsaWNraW5nLmluaXRpYWxpemVkIHx8IHRoaXMuX2RpZmZSZXN1bHQpIHJldHVybjtcbiAgICB2YXIgbmV4dENoaWxkcmVuID0gdGhpcy5fZ2V0Q2hpbGRyZW4ocHJvcHMuY2hpbGRyZW4pO1xuICAgIGlmIChwcm9wcy5yZW5kZXJPblNhbWVLZXkgfHwgIXRoaXMuX2hhc1NhbWVDaGlsZHJlbihwcmV2Q2hpbGRyZW4sIG5leHRDaGlsZHJlbikpIHtcbiAgICAgIHRoaXMuX3BhbmVscyA9IHRoaXMuX2NyZWF0ZVBhbmVsUmVmcyhwcm9wcywgbmV4dENoaWxkcmVuKTtcbiAgICAgIHRoaXMuX2RpZmZSZXN1bHQgPSB0aGlzLl9qc3hEaWZmZXIudXBkYXRlKG5leHRDaGlsZHJlbik7XG4gICAgICB0aGlzLl9wcmV2Q2hpbGRyZW4gPSBuZXh0Q2hpbGRyZW47XG4gICAgfVxuICB9O1xuICBfX3Byb3RvLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZmxpY2tpbmcgPSB0aGlzLl92YW5pbGxhRmxpY2tpbmc7XG4gICAgdmFyIHJlbmRlckVtaXR0ZXIgPSB0aGlzLl9yZW5kZXJFbWl0dGVyO1xuICAgIHZhciBkaWZmUmVzdWx0ID0gdGhpcy5fZGlmZlJlc3VsdDtcbiAgICB0aGlzLl9jaGVja1BsdWdpbnMoKTtcbiAgICByZW5kZXJFbWl0dGVyLnRyaWdnZXIoXCJyZW5kZXJcIik7XG4gICAgZmxpY2tpbmcuY2FtZXJhLnVwZGF0ZU9mZnNldCgpO1xuICAgIC8vIE9taXQgJ3ZpcnR1YWwnLCBhcyBpdCBjYW4ndCBoYXZlIGFueSBzZXR0ZXJcbiAgICB2YXIgX2EgPSB0aGlzLnByb3BzO1xuICAgICAgX2EudmlydHVhbDtcbiAgICAgIHZhciBwcm9wcyA9IF9fcmVzdChfYSwgW1widmlydHVhbFwiXSk7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgICBpZiAoa2V5IGluIGZsaWNraW5nICYmIGZsaWNraW5nW2tleV0gIT09IHByb3BzW2tleV0pIHtcbiAgICAgICAgZmxpY2tpbmdba2V5XSA9IHByb3BzW2tleV07XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghZGlmZlJlc3VsdCB8fCAhZmxpY2tpbmcuaW5pdGlhbGl6ZWQpIHJldHVybjtcbiAgICBzeW5jKGZsaWNraW5nLCBkaWZmUmVzdWx0LCB0aGlzLnJlYWN0UGFuZWxzKTtcbiAgICB0aGlzLl9kaWZmUmVzdWx0ID0gbnVsbDtcbiAgfTtcbiAgX19wcm90by5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB2YXIgX2EsIF9iO1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIFZpZXdwb3J0ID0gcHJvcHMudmlld3BvcnRUYWc7XG4gICAgdmFyIENhbWVyYSA9IHByb3BzLmNhbWVyYVRhZztcbiAgICB2YXIgYXR0cmlidXRlcyA9IHt9O1xuICAgIHZhciBmbGlja2luZyA9IHRoaXMuX3ZhbmlsbGFGbGlja2luZztcbiAgICB0aGlzLmJlZm9yZVJlbmRlcigpO1xuICAgIGZvciAodmFyIG5hbWUgaW4gcHJvcHMpIHtcbiAgICAgIGlmICghKG5hbWUgaW4gREVGQVVMVF9QUk9QUykgJiYgIShuYW1lIGluIEZsaWNraW5nLnByb3RvdHlwZSkpIHtcbiAgICAgICAgYXR0cmlidXRlc1tuYW1lXSA9IHByb3BzW25hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgaW5pdGlhbGl6ZWQgPSBmbGlja2luZyAmJiBmbGlja2luZy5pbml0aWFsaXplZDtcbiAgICB2YXIgdmlld3BvcnRDbGFzc2VzID0gW1wiZmxpY2tpbmctdmlld3BvcnRcIl07XG4gICAgdmFyIGNhbWVyYUNsYXNzZXMgPSBbXCJmbGlja2luZy1jYW1lcmFcIl07XG4gICAgdmFyIGlzSG9yaXpvbnRhbCA9IGZsaWNraW5nID8gZmxpY2tpbmcuaG9yaXpvbnRhbCA6IChfYSA9IHByb3BzLmhvcml6b250YWwpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRydWU7XG4gICAgaWYgKCFpc0hvcml6b250YWwpIHtcbiAgICAgIHZpZXdwb3J0Q2xhc3Nlcy5wdXNoKFwidmVydGljYWxcIik7XG4gICAgfVxuICAgIGlmIChwcm9wcy5oaWRlQmVmb3JlSW5pdCAmJiAhaW5pdGlhbGl6ZWQpIHtcbiAgICAgIHZpZXdwb3J0Q2xhc3Nlcy5wdXNoKFwiZmxpY2tpbmctaGlkZGVuXCIpO1xuICAgIH1cbiAgICBpZiAoYXR0cmlidXRlcy5jbGFzc05hbWUpIHtcbiAgICAgIHZpZXdwb3J0Q2xhc3Nlcy5wdXNoKGF0dHJpYnV0ZXMuY2xhc3NOYW1lKTtcbiAgICB9XG4gICAgaWYgKHByb3BzLmNhbWVyYUNsYXNzKSB7XG4gICAgICBjYW1lcmFDbGFzc2VzLnB1c2gocHJvcHMuY2FtZXJhQ2xhc3MpO1xuICAgIH1cbiAgICB2YXIgY2FtZXJhUHJvcHMgPSAhaW5pdGlhbGl6ZWQgJiYgcHJvcHMuZmlyc3RQYW5lbFNpemUgPyB7XG4gICAgICBzdHlsZToge1xuICAgICAgICB0cmFuc2Zvcm06IGdldERlZmF1bHRDYW1lcmFUcmFuc2Zvcm0odGhpcy5wcm9wcy5hbGlnbiwgdGhpcy5wcm9wcy5ob3Jpem9udGFsLCB0aGlzLnByb3BzLmZpcnN0UGFuZWxTaXplKVxuICAgICAgfVxuICAgIH0gOiB7fTtcbiAgICB2YXIgcGFuZWxzID0gISFwcm9wcy52aXJ0dWFsICYmICgoX2IgPSBwcm9wcy5wYW5lbHNQZXJWaWV3KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAtMSkgPiAwID8gdGhpcy5fZ2V0VmlydHVhbFBhbmVscygpIDogdGhpcy5fZ2V0UGFuZWxzKCk7XG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoVmlld3BvcnQsIF9fYXNzaWduJDMoe30sIGF0dHJpYnV0ZXMsIHtcbiAgICAgIGNsYXNzTmFtZTogdmlld3BvcnRDbGFzc2VzLmpvaW4oXCIgXCIpLFxuICAgICAgcmVmOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICBlICYmIChfdGhpcy5fdmlld3BvcnRFbGVtZW50ID0gZSk7XG4gICAgICB9XG4gICAgfSksIGNyZWF0ZUVsZW1lbnQoQ2FtZXJhLCBfX2Fzc2lnbiQzKHtcbiAgICAgIGNsYXNzTmFtZTogY2FtZXJhQ2xhc3Nlcy5qb2luKFwiIFwiKVxuICAgIH0sIGNhbWVyYVByb3BzKSwgcGFuZWxzKSwgdGhpcy5fZ2V0Vmlld3BvcnRTbG90KCkpO1xuICB9O1xuICBfX3Byb3RvLl9jcmVhdGVQYW5lbFJlZnMgPSBmdW5jdGlvbiAocHJvcHMsIGNoaWxkcmVuKSB7XG4gICAgdmFyIF9hO1xuICAgIHZhciBwYW5lbHNQZXJWaWV3ID0gKF9hID0gcHJvcHMucGFuZWxzUGVyVmlldykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogLTE7XG4gICAgcmV0dXJuIHBhbmVsc1BlclZpZXcgPiAwICYmICEhcHJvcHMudmlydHVhbCA/IHJhbmdlKHBhbmVsc1BlclZpZXcgKyAxKS5tYXAoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZVJlZigpO1xuICAgIH0pIDogY2hpbGRyZW4ubWFwKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBjcmVhdGVSZWYoKTtcbiAgICB9KTtcbiAgfTtcbiAgX19wcm90by5fYmluZEV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHZhciBmbGlja2luZyA9IHRoaXMuX3ZhbmlsbGFGbGlja2luZztcbiAgICBPYmplY3Qua2V5cyhFVkVOVFMpLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50S2V5KSB7XG4gICAgICB2YXIgZXZlbnROYW1lID0gRVZFTlRTW2V2ZW50S2V5XTtcbiAgICAgIHZhciBwcm9wTmFtZSA9IFwib25cIi5jb25jYXQoZXZlbnROYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgZXZlbnROYW1lLnNsaWNlKDEpKTtcbiAgICAgIGZsaWNraW5nLm9uKGV2ZW50TmFtZSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZS5jdXJyZW50VGFyZ2V0ID0gX3RoaXM7XG4gICAgICAgIHZhciBldnRIYW5kbGVyID0gX3RoaXMucHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICBldnRIYW5kbGVyKGUpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgZmxpY2tpbmcub25jZShFVkVOVFMuUkVBRFksIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLmZvcmNlVXBkYXRlKCk7XG4gICAgfSk7XG4gIH07XG4gIF9fcHJvdG8uX2NoZWNrUGx1Z2lucyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZmxpY2tpbmcgPSB0aGlzLl92YW5pbGxhRmxpY2tpbmc7XG4gICAgdmFyIF9hID0gdGhpcy5fcGx1Z2luc0RpZmZlci51cGRhdGUodGhpcy5wcm9wcy5wbHVnaW5zKSxcbiAgICAgIGxpc3QgPSBfYS5saXN0LFxuICAgICAgYWRkZWQgPSBfYS5hZGRlZCxcbiAgICAgIHJlbW92ZWQgPSBfYS5yZW1vdmVkLFxuICAgICAgcHJldkxpc3QgPSBfYS5wcmV2TGlzdDtcbiAgICBmbGlja2luZy5hZGRQbHVnaW5zLmFwcGx5KGZsaWNraW5nLCBhZGRlZC5tYXAoZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICByZXR1cm4gbGlzdFtpbmRleF07XG4gICAgfSkpO1xuICAgIGZsaWNraW5nLnJlbW92ZVBsdWdpbnMuYXBwbHkoZmxpY2tpbmcsIHJlbW92ZWQubWFwKGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgcmV0dXJuIHByZXZMaXN0W2luZGV4XTtcbiAgICB9KSk7XG4gIH07XG4gIF9fcHJvdG8uX2hhc1NhbWVDaGlsZHJlbiA9IGZ1bmN0aW9uIChwcmV2Q2hpbGRyZW4sIG5leHRDaGlsZHJlbikge1xuICAgIGlmIChwcmV2Q2hpbGRyZW4ubGVuZ3RoICE9PSBuZXh0Q2hpbGRyZW4ubGVuZ3RoIHx8IHByZXZDaGlsZHJlbi5sZW5ndGggPT09IDApIHJldHVybiBmYWxzZTtcbiAgICB2YXIgc2FtZSA9IHByZXZDaGlsZHJlbi5ldmVyeShmdW5jdGlvbiAoY2hpbGQsIGlkeCkge1xuICAgICAgdmFyIG5leHRDaGlsZCA9IG5leHRDaGlsZHJlbltpZHhdO1xuICAgICAgaWYgKGNoaWxkLmtleSAmJiBuZXh0Q2hpbGQua2V5KSB7XG4gICAgICAgIHJldHVybiBjaGlsZC5rZXkgPT09IG5leHRDaGlsZC5rZXk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY2hpbGQgPT09IG5leHRDaGlsZDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gc2FtZTtcbiAgfTtcbiAgX19wcm90by5fZ2V0Q2hpbGRyZW4gPSBmdW5jdGlvbiAoY2hpbGRyZW4pIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIGlmIChjaGlsZHJlbiA9PT0gdm9pZCAwKSB7XG4gICAgICBjaGlsZHJlbiA9IHRoaXMucHJvcHMuY2hpbGRyZW47XG4gICAgfVxuICAgIHJldHVybiBrJDEudG9BcnJheShjaGlsZHJlbikuZmlsdGVyKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgcmV0dXJuIGNoaWxkLnR5cGUgIT09IFZpZXdwb3J0U2xvdDtcbiAgICB9KS5yZWR1Y2UoZnVuY3Rpb24gKGFsbCwgY2hpbGQpIHtcbiAgICAgIHJldHVybiBfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIGFsbCwgdHJ1ZSksIF90aGlzLl91bnBhY2tGcmFnbWVudChjaGlsZCksIHRydWUpO1xuICAgIH0sIFtdKTtcbiAgfTtcbiAgX19wcm90by5fZ2V0Vmlld3BvcnRTbG90ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBrJDEudG9BcnJheSh0aGlzLnByb3BzLmNoaWxkcmVuKS5maWx0ZXIoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICByZXR1cm4gY2hpbGQudHlwZSA9PT0gVmlld3BvcnRTbG90O1xuICAgIH0pO1xuICB9O1xuICBfX3Byb3RvLl91bnBhY2tGcmFnbWVudCA9IGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgcmV0dXJuIHRoaXMuX2lzRnJhZ21lbnQoY2hpbGQpID8gayQxLnRvQXJyYXkoY2hpbGQucHJvcHMuY2hpbGRyZW4pLnJlZHVjZShmdW5jdGlvbiAoYWxsQ2hpbGRzLCBmcmFnQ2hpbGQpIHtcbiAgICAgIHJldHVybiBfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIGFsbENoaWxkcywgdHJ1ZSksIF90aGlzLl91bnBhY2tGcmFnbWVudChmcmFnQ2hpbGQpLCB0cnVlKTtcbiAgICB9LCBbXSkgOiBbY2hpbGRdO1xuICB9O1xuICBfX3Byb3RvLl9nZXRWaXJ0dWFsUGFuZWxzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIF9hID0gdGhpcy5wcm9wcy52aXJ0dWFsLnBhbmVsQ2xhc3MsXG4gICAgICBwYW5lbENsYXNzID0gX2EgPT09IHZvaWQgMCA/IFwiZmxpY2tpbmctcGFuZWxcIiA6IF9hO1xuICAgIHZhciBwYW5lbHNQZXJWaWV3ID0gdGhpcy5wcm9wcy5wYW5lbHNQZXJWaWV3O1xuICAgIHZhciBmbGlja2luZyA9IHRoaXMuX3ZhbmlsbGFGbGlja2luZztcbiAgICB2YXIgaW5pdGlhbGl6ZWQgPSBmbGlja2luZyAmJiBmbGlja2luZy5pbml0aWFsaXplZDtcbiAgICB2YXIgcmVuZGVyaW5nSW5kZXhlcyA9IGluaXRpYWxpemVkID8gZmxpY2tpbmcucmVuZGVyZXIuc3RyYXRlZ3kuZ2V0UmVuZGVyaW5nSW5kZXhlc0J5T3JkZXIoZmxpY2tpbmcpIDogcmFuZ2UocGFuZWxzUGVyVmlldyArIDEpO1xuICAgIHZhciBmaXJzdFBhbmVsID0gZmxpY2tpbmcgJiYgZmxpY2tpbmcucGFuZWxzWzBdO1xuICAgIHZhciBzaXplID0gZmlyc3RQYW5lbCA/IGZsaWNraW5nLmhvcml6b250YWwgPyB7XG4gICAgICB3aWR0aDogZmlyc3RQYW5lbC5zaXplXG4gICAgfSA6IHtcbiAgICAgIGhlaWdodDogZmlyc3RQYW5lbC5zaXplXG4gICAgfSA6IHt9O1xuICAgIHJldHVybiByZW5kZXJpbmdJbmRleGVzLm1hcChmdW5jdGlvbiAoaWR4KSB7XG4gICAgICByZXR1cm4gY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgIGtleTogaWR4LFxuICAgICAgICBcImRhdGEtZWxlbWVudC1pbmRleFwiOiBpZHgsXG4gICAgICAgIHJlZjogX3RoaXMuX3BhbmVsc1tpZHhdLFxuICAgICAgICBjbGFzc05hbWU6IHBhbmVsQ2xhc3MsXG4gICAgICAgIHN0eWxlOiBzaXplXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbiAgX19wcm90by5fZ2V0UGFuZWxzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIG9yaWdDaGlsZHJlbiA9IHRoaXMuX2dldENoaWxkcmVuKCk7XG4gICAgdmFyIHZhbmlsbGFGbGlja2luZyA9IHRoaXMuX3ZhbmlsbGFGbGlja2luZztcbiAgICB2YXIgZGlmZlJlc3VsdCA9IHRoaXMuX2RpZmZSZXN1bHQ7XG4gICAgdmFyIGNoaWxkcmVuID0gdmFuaWxsYUZsaWNraW5nICYmIHZhbmlsbGFGbGlja2luZy5pbml0aWFsaXplZCA/IGRpZmZSZXN1bHQgPyBnZXRSZW5kZXJpbmdQYW5lbHModmFuaWxsYUZsaWNraW5nLCBkaWZmUmVzdWx0KSA6IGdldFJlbmRlcmluZ1BhbmVscyh2YW5pbGxhRmxpY2tpbmcsIGRpZmYob3JpZ0NoaWxkcmVuLCBvcmlnQ2hpbGRyZW4pKSA6IG9yaWdDaGlsZHJlbjtcbiAgICByZXR1cm4gdGhpcy5wcm9wcy51c2VGaW5kRE9NTm9kZSA/IGNoaWxkcmVuLm1hcChmdW5jdGlvbiAoY2hpbGQsIGlkeCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoTm9uU3RyaWN0UGFuZWwsIHtcbiAgICAgICAga2V5OiBjaGlsZC5rZXksXG4gICAgICAgIHJlZjogX3RoaXMuX3BhbmVsc1tpZHhdXG4gICAgICB9LCBjaGlsZCk7XG4gICAgfSkgOiBjaGlsZHJlbi5tYXAoZnVuY3Rpb24gKGNoaWxkLCBpZHgpIHtcbiAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KFN0cmljdFBhbmVsLCB7XG4gICAgICAgIGtleTogY2hpbGQua2V5LFxuICAgICAgICByZWY6IF90aGlzLl9wYW5lbHNbaWR4XVxuICAgICAgfSwgY2hpbGQpO1xuICAgIH0pO1xuICB9O1xuICBfX3Byb3RvLl9pc0ZyYWdtZW50ID0gZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgaWYgKGNoaWxkLnR5cGUpIHtcbiAgICAgIHJldHVybiBjaGlsZC50eXBlID09PSBGcmFnbWVudDtcbiAgICB9XG4gICAgcmV0dXJuIGNoaWxkID09PSBGcmFnbWVudDtcbiAgfTtcbiAgRmxpY2tpbmckMS5kZWZhdWx0UHJvcHMgPSBERUZBVUxUX1BST1BTO1xuICBfX2RlY29yYXRlJDEoW3dpdGhGbGlja2luZ01ldGhvZHNdLCBGbGlja2luZyQxLnByb3RvdHlwZSwgXCJfdmFuaWxsYUZsaWNraW5nXCIsIHZvaWQgMCk7XG4gIHJldHVybiBGbGlja2luZyQxO1xufShDb21wb25lbnQkMSk7XG5cbmV4cG9ydCBkZWZhdWx0IEZsaWNraW5nJDE7XG5leHBvcnQgeyBBTElHTiwgQW5jaG9yUG9pbnQsIEFuaW1hdGluZ1N0YXRlLCBBeGVzQ29udHJvbGxlciwgQm91bmRDYW1lcmFNb2RlLCBDSVJDVUxBUl9GQUxMQkFDSywgQ0xBU1MsIENhbWVyYSwgQ2lyY3VsYXJDYW1lcmFNb2RlLCBDb250cm9sLCBESVJFQ1RJT04sIERpc2FibGVkU3RhdGUsIERyYWdnaW5nU3RhdGUsIENPREUgYXMgRVJST1JfQ09ERSwgRVZFTlRTLCBFeHRlcm5hbFJlbmRlcmVyLCBGbGlja2luZ0Vycm9yLCBGcmVlQ29udHJvbCwgSG9sZGluZ1N0YXRlLCBJZGxlU3RhdGUsIExpbmVhckNhbWVyYU1vZGUsIE1PVkVfVFlQRSwgTm9ybWFsUmVuZGVyaW5nU3RyYXRlZ3ksIE9SREVSLCBQYW5lbCwgUmVuZGVyZXIsIFNuYXBDb250cm9sLCBTdGF0ZSwgU3RhdGVNYWNoaW5lLCBTdHJpY3RDb250cm9sLCBWYW5pbGxhRWxlbWVudFByb3ZpZGVyLCBWYW5pbGxhUmVuZGVyZXIsIFZpZXdwb3J0LCBWaWV3cG9ydFNsb3QsIFZpcnR1YWxFbGVtZW50UHJvdmlkZXIsIFZpcnR1YWxNYW5hZ2VyLCBWaXJ0dWFsUGFuZWwsIFZpcnR1YWxSZW5kZXJpbmdTdHJhdGVneSwgY2hlY2tFeGlzdGVuY2UsIGNpcmN1bGF0ZUluZGV4LCBjaXJjdWxhdGVQb3NpdGlvbiwgY2xhbXAkMSBhcyBjbGFtcCwgZmluZCQxIGFzIGZpbmQsIGZpbmRJbmRleCwgZmluZFJpZ2h0LCBnZXREZWZhdWx0Q2FtZXJhVHJhbnNmb3JtLCBnZXREaXJlY3Rpb24kMSBhcyBnZXREaXJlY3Rpb24sIGdldEVsZW1lbnQsIGdldEVsZW1lbnRTaXplLCBnZXRGbGlja2luZ0F0dGFjaGVkLCBnZXRNaW51c0NvbXBlbnNhdGVkSW5kZXgsIGdldFByb2dyZXNzLCBnZXRSZW5kZXJpbmdQYW5lbHMsIGdldFN0eWxlLCBpbmNsdWRlcywgaXNCZXR3ZWVuLCBpc1N0cmluZywgbWVyZ2UsIHBhcnNlQWxpZ24kMSBhcyBwYXJzZUFsaWduLCBwYXJzZUFyaXRobWV0aWNFeHByZXNzaW9uLCBwYXJzZUFyaXRobWV0aWNTaXplLCBwYXJzZUJvdW5jZSwgcGFyc2VDU1NTaXplVmFsdWUsIHBhcnNlRWxlbWVudCwgcGFyc2VQYW5lbEFsaWduLCByYW5nZSwgc2V0UHJvdG90eXBlT2YsIHNldFNpemUsIHN5bmMsIHRvQXJyYXkkMiBhcyB0b0FycmF5LCB3aXRoRmxpY2tpbmdNZXRob2RzIH07XG4iLCIvLyBJbXBvcnRzXG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL3NvdXJjZU1hcHMuanNcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0dFVF9VUkxfSU1QT1JUX19fIGZyb20gXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvZ2V0VXJsLmpzXCI7XG52YXIgX19fQ1NTX0xPQURFUl9VUkxfSU1QT1JUXzBfX18gPSBuZXcgVVJMKFwiLi4vYXNzZXRzL21vYmlsZS9pY29uLWhhbWJ1cmdlci5zdmdcIiwgaW1wb3J0Lm1ldGEudXJsKTtcbnZhciBfX19DU1NfTE9BREVSX1VSTF9JTVBPUlRfMV9fXyA9IG5ldyBVUkwoXCIuLi9hc3NldHMvbW9iaWxlL2ljb24tY3Jvc3Muc3ZnXCIsIGltcG9ydC5tZXRhLnVybCk7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyk7XG52YXIgX19fQ1NTX0xPQURFUl9VUkxfUkVQTEFDRU1FTlRfMF9fXyA9IF9fX0NTU19MT0FERVJfR0VUX1VSTF9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9VUkxfSU1QT1JUXzBfX18pO1xudmFyIF9fX0NTU19MT0FERVJfVVJMX1JFUExBQ0VNRU5UXzFfX18gPSBfX19DU1NfTE9BREVSX0dFVF9VUkxfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfVVJMX0lNUE9SVF8xX19fKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBgLypcbiEgdGFpbHdpbmRjc3MgdjMuNC43IHwgTUlUIExpY2Vuc2UgfCBodHRwczovL3RhaWx3aW5kY3NzLmNvbVxuKi8vKlxuMS4gUHJldmVudCBwYWRkaW5nIGFuZCBib3JkZXIgZnJvbSBhZmZlY3RpbmcgZWxlbWVudCB3aWR0aC4gKGh0dHBzOi8vZ2l0aHViLmNvbS9tb3pkZXZzL2Nzc3JlbWVkeS9pc3N1ZXMvNClcbjIuIEFsbG93IGFkZGluZyBhIGJvcmRlciB0byBhbiBlbGVtZW50IGJ5IGp1c3QgYWRkaW5nIGEgYm9yZGVyLXdpZHRoLiAoaHR0cHM6Ly9naXRodWIuY29tL3RhaWx3aW5kY3NzL3RhaWx3aW5kY3NzL3B1bGwvMTE2KVxuKi9cblxuKixcbjo6YmVmb3JlLFxuOjphZnRlciB7XG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7IC8qIDEgKi9cbiAgYm9yZGVyLXdpZHRoOiAwOyAvKiAyICovXG4gIGJvcmRlci1zdHlsZTogc29saWQ7IC8qIDIgKi9cbiAgYm9yZGVyLWNvbG9yOiAjZTVlN2ViOyAvKiAyICovXG59XG5cbjo6YmVmb3JlLFxuOjphZnRlciB7XG4gIC0tdHctY29udGVudDogJyc7XG59XG5cbi8qXG4xLiBVc2UgYSBjb25zaXN0ZW50IHNlbnNpYmxlIGxpbmUtaGVpZ2h0IGluIGFsbCBicm93c2Vycy5cbjIuIFByZXZlbnQgYWRqdXN0bWVudHMgb2YgZm9udCBzaXplIGFmdGVyIG9yaWVudGF0aW9uIGNoYW5nZXMgaW4gaU9TLlxuMy4gVXNlIGEgbW9yZSByZWFkYWJsZSB0YWIgc2l6ZS5cbjQuIFVzZSB0aGUgdXNlcidzIGNvbmZpZ3VyZWQgXFxgc2Fuc1xcYCBmb250LWZhbWlseSBieSBkZWZhdWx0LlxuNS4gVXNlIHRoZSB1c2VyJ3MgY29uZmlndXJlZCBcXGBzYW5zXFxgIGZvbnQtZmVhdHVyZS1zZXR0aW5ncyBieSBkZWZhdWx0LlxuNi4gVXNlIHRoZSB1c2VyJ3MgY29uZmlndXJlZCBcXGBzYW5zXFxgIGZvbnQtdmFyaWF0aW9uLXNldHRpbmdzIGJ5IGRlZmF1bHQuXG43LiBEaXNhYmxlIHRhcCBoaWdobGlnaHRzIG9uIGlPU1xuKi9cblxuaHRtbCxcbjpob3N0IHtcbiAgbGluZS1oZWlnaHQ6IDEuNTsgLyogMSAqL1xuICAtd2Via2l0LXRleHQtc2l6ZS1hZGp1c3Q6IDEwMCU7IC8qIDIgKi9cbiAgLW1vei10YWItc2l6ZTogNDsgLyogMyAqL1xuICAtby10YWItc2l6ZTogNDtcbiAgICAgdGFiLXNpemU6IDQ7IC8qIDMgKi9cbiAgZm9udC1mYW1pbHk6IHVpLXNhbnMtc2VyaWYsIHN5c3RlbS11aSwgc2Fucy1zZXJpZiwgXCJBcHBsZSBDb2xvciBFbW9qaVwiLCBcIlNlZ29lIFVJIEVtb2ppXCIsIFwiU2Vnb2UgVUkgU3ltYm9sXCIsIFwiTm90byBDb2xvciBFbW9qaVwiOyAvKiA0ICovXG4gIGZvbnQtZmVhdHVyZS1zZXR0aW5nczogbm9ybWFsOyAvKiA1ICovXG4gIGZvbnQtdmFyaWF0aW9uLXNldHRpbmdzOiBub3JtYWw7IC8qIDYgKi9cbiAgLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOiB0cmFuc3BhcmVudDsgLyogNyAqL1xufVxuXG4vKlxuMS4gUmVtb3ZlIHRoZSBtYXJnaW4gaW4gYWxsIGJyb3dzZXJzLlxuMi4gSW5oZXJpdCBsaW5lLWhlaWdodCBmcm9tIFxcYGh0bWxcXGAgc28gdXNlcnMgY2FuIHNldCB0aGVtIGFzIGEgY2xhc3MgZGlyZWN0bHkgb24gdGhlIFxcYGh0bWxcXGAgZWxlbWVudC5cbiovXG5cbmJvZHkge1xuICBtYXJnaW46IDA7IC8qIDEgKi9cbiAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7IC8qIDIgKi9cbn1cblxuLypcbjEuIEFkZCB0aGUgY29ycmVjdCBoZWlnaHQgaW4gRmlyZWZveC5cbjIuIENvcnJlY3QgdGhlIGluaGVyaXRhbmNlIG9mIGJvcmRlciBjb2xvciBpbiBGaXJlZm94LiAoaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTkwNjU1KVxuMy4gRW5zdXJlIGhvcml6b250YWwgcnVsZXMgYXJlIHZpc2libGUgYnkgZGVmYXVsdC5cbiovXG5cbmhyIHtcbiAgaGVpZ2h0OiAwOyAvKiAxICovXG4gIGNvbG9yOiBpbmhlcml0OyAvKiAyICovXG4gIGJvcmRlci10b3Atd2lkdGg6IDFweDsgLyogMyAqL1xufVxuXG4vKlxuQWRkIHRoZSBjb3JyZWN0IHRleHQgZGVjb3JhdGlvbiBpbiBDaHJvbWUsIEVkZ2UsIGFuZCBTYWZhcmkuXG4qL1xuXG5hYmJyOndoZXJlKFt0aXRsZV0pIHtcbiAgLXdlYmtpdC10ZXh0LWRlY29yYXRpb246IHVuZGVybGluZSBkb3R0ZWQ7XG4gICAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmUgZG90dGVkO1xufVxuXG4vKlxuUmVtb3ZlIHRoZSBkZWZhdWx0IGZvbnQgc2l6ZSBhbmQgd2VpZ2h0IGZvciBoZWFkaW5ncy5cbiovXG5cbmgxLFxuaDIsXG5oMyxcbmg0LFxuaDUsXG5oNiB7XG4gIGZvbnQtc2l6ZTogaW5oZXJpdDtcbiAgZm9udC13ZWlnaHQ6IGluaGVyaXQ7XG59XG5cbi8qXG5SZXNldCBsaW5rcyB0byBvcHRpbWl6ZSBmb3Igb3B0LWluIHN0eWxpbmcgaW5zdGVhZCBvZiBvcHQtb3V0LlxuKi9cblxuYSB7XG4gIGNvbG9yOiBpbmhlcml0O1xuICB0ZXh0LWRlY29yYXRpb246IGluaGVyaXQ7XG59XG5cbi8qXG5BZGQgdGhlIGNvcnJlY3QgZm9udCB3ZWlnaHQgaW4gRWRnZSBhbmQgU2FmYXJpLlxuKi9cblxuYixcbnN0cm9uZyB7XG4gIGZvbnQtd2VpZ2h0OiBib2xkZXI7XG59XG5cbi8qXG4xLiBVc2UgdGhlIHVzZXIncyBjb25maWd1cmVkIFxcYG1vbm9cXGAgZm9udC1mYW1pbHkgYnkgZGVmYXVsdC5cbjIuIFVzZSB0aGUgdXNlcidzIGNvbmZpZ3VyZWQgXFxgbW9ub1xcYCBmb250LWZlYXR1cmUtc2V0dGluZ3MgYnkgZGVmYXVsdC5cbjMuIFVzZSB0aGUgdXNlcidzIGNvbmZpZ3VyZWQgXFxgbW9ub1xcYCBmb250LXZhcmlhdGlvbi1zZXR0aW5ncyBieSBkZWZhdWx0LlxuNC4gQ29ycmVjdCB0aGUgb2RkIFxcYGVtXFxgIGZvbnQgc2l6aW5nIGluIGFsbCBicm93c2Vycy5cbiovXG5cbmNvZGUsXG5rYmQsXG5zYW1wLFxucHJlIHtcbiAgZm9udC1mYW1pbHk6IHVpLW1vbm9zcGFjZSwgU0ZNb25vLVJlZ3VsYXIsIE1lbmxvLCBNb25hY28sIENvbnNvbGFzLCBcIkxpYmVyYXRpb24gTW9ub1wiLCBcIkNvdXJpZXIgTmV3XCIsIG1vbm9zcGFjZTsgLyogMSAqL1xuICBmb250LWZlYXR1cmUtc2V0dGluZ3M6IG5vcm1hbDsgLyogMiAqL1xuICBmb250LXZhcmlhdGlvbi1zZXR0aW5nczogbm9ybWFsOyAvKiAzICovXG4gIGZvbnQtc2l6ZTogMWVtOyAvKiA0ICovXG59XG5cbi8qXG5BZGQgdGhlIGNvcnJlY3QgZm9udCBzaXplIGluIGFsbCBicm93c2Vycy5cbiovXG5cbnNtYWxsIHtcbiAgZm9udC1zaXplOiA4MCU7XG59XG5cbi8qXG5QcmV2ZW50IFxcYHN1YlxcYCBhbmQgXFxgc3VwXFxgIGVsZW1lbnRzIGZyb20gYWZmZWN0aW5nIHRoZSBsaW5lIGhlaWdodCBpbiBhbGwgYnJvd3NlcnMuXG4qL1xuXG5zdWIsXG5zdXAge1xuICBmb250LXNpemU6IDc1JTtcbiAgbGluZS1oZWlnaHQ6IDA7XG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgdmVydGljYWwtYWxpZ246IGJhc2VsaW5lO1xufVxuXG5zdWIge1xuICBib3R0b206IC0wLjI1ZW07XG59XG5cbnN1cCB7XG4gIHRvcDogLTAuNWVtO1xufVxuXG4vKlxuMS4gUmVtb3ZlIHRleHQgaW5kZW50YXRpb24gZnJvbSB0YWJsZSBjb250ZW50cyBpbiBDaHJvbWUgYW5kIFNhZmFyaS4gKGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTk5OTA4OCwgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTIwMTI5NylcbjIuIENvcnJlY3QgdGFibGUgYm9yZGVyIGNvbG9yIGluaGVyaXRhbmNlIGluIGFsbCBDaHJvbWUgYW5kIFNhZmFyaS4gKGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTkzNTcyOSwgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE5NTAxNilcbjMuIFJlbW92ZSBnYXBzIGJldHdlZW4gdGFibGUgYm9yZGVycyBieSBkZWZhdWx0LlxuKi9cblxudGFibGUge1xuICB0ZXh0LWluZGVudDogMDsgLyogMSAqL1xuICBib3JkZXItY29sb3I6IGluaGVyaXQ7IC8qIDIgKi9cbiAgYm9yZGVyLWNvbGxhcHNlOiBjb2xsYXBzZTsgLyogMyAqL1xufVxuXG4vKlxuMS4gQ2hhbmdlIHRoZSBmb250IHN0eWxlcyBpbiBhbGwgYnJvd3NlcnMuXG4yLiBSZW1vdmUgdGhlIG1hcmdpbiBpbiBGaXJlZm94IGFuZCBTYWZhcmkuXG4zLiBSZW1vdmUgZGVmYXVsdCBwYWRkaW5nIGluIGFsbCBicm93c2Vycy5cbiovXG5cbmJ1dHRvbixcbmlucHV0LFxub3B0Z3JvdXAsXG5zZWxlY3QsXG50ZXh0YXJlYSB7XG4gIGZvbnQtZmFtaWx5OiBpbmhlcml0OyAvKiAxICovXG4gIGZvbnQtZmVhdHVyZS1zZXR0aW5nczogaW5oZXJpdDsgLyogMSAqL1xuICBmb250LXZhcmlhdGlvbi1zZXR0aW5nczogaW5oZXJpdDsgLyogMSAqL1xuICBmb250LXNpemU6IDEwMCU7IC8qIDEgKi9cbiAgZm9udC13ZWlnaHQ6IGluaGVyaXQ7IC8qIDEgKi9cbiAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7IC8qIDEgKi9cbiAgbGV0dGVyLXNwYWNpbmc6IGluaGVyaXQ7IC8qIDEgKi9cbiAgY29sb3I6IGluaGVyaXQ7IC8qIDEgKi9cbiAgbWFyZ2luOiAwOyAvKiAyICovXG4gIHBhZGRpbmc6IDA7IC8qIDMgKi9cbn1cblxuLypcblJlbW92ZSB0aGUgaW5oZXJpdGFuY2Ugb2YgdGV4dCB0cmFuc2Zvcm0gaW4gRWRnZSBhbmQgRmlyZWZveC5cbiovXG5cbmJ1dHRvbixcbnNlbGVjdCB7XG4gIHRleHQtdHJhbnNmb3JtOiBub25lO1xufVxuXG4vKlxuMS4gQ29ycmVjdCB0aGUgaW5hYmlsaXR5IHRvIHN0eWxlIGNsaWNrYWJsZSB0eXBlcyBpbiBpT1MgYW5kIFNhZmFyaS5cbjIuIFJlbW92ZSBkZWZhdWx0IGJ1dHRvbiBzdHlsZXMuXG4qL1xuXG5idXR0b24sXG5pbnB1dDp3aGVyZShbdHlwZT0nYnV0dG9uJ10pLFxuaW5wdXQ6d2hlcmUoW3R5cGU9J3Jlc2V0J10pLFxuaW5wdXQ6d2hlcmUoW3R5cGU9J3N1Ym1pdCddKSB7XG4gIC13ZWJraXQtYXBwZWFyYW5jZTogYnV0dG9uOyAvKiAxICovXG4gIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50OyAvKiAyICovXG4gIGJhY2tncm91bmQtaW1hZ2U6IG5vbmU7IC8qIDIgKi9cbn1cblxuLypcblVzZSB0aGUgbW9kZXJuIEZpcmVmb3ggZm9jdXMgc3R5bGUgZm9yIGFsbCBmb2N1c2FibGUgZWxlbWVudHMuXG4qL1xuXG46LW1vei1mb2N1c3Jpbmcge1xuICBvdXRsaW5lOiBhdXRvO1xufVxuXG4vKlxuUmVtb3ZlIHRoZSBhZGRpdGlvbmFsIFxcYDppbnZhbGlkXFxgIHN0eWxlcyBpbiBGaXJlZm94LiAoaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvZ2Vja28tZGV2L2Jsb2IvMmY5ZWFjZDlkM2Q5OTVjOTM3YjQyNTFhNTU1N2Q5NWQ0OTRjOWJlMS9sYXlvdXQvc3R5bGUvcmVzL2Zvcm1zLmNzcyNMNzI4LUw3MzcpXG4qL1xuXG46LW1vei11aS1pbnZhbGlkIHtcbiAgYm94LXNoYWRvdzogbm9uZTtcbn1cblxuLypcbkFkZCB0aGUgY29ycmVjdCB2ZXJ0aWNhbCBhbGlnbm1lbnQgaW4gQ2hyb21lIGFuZCBGaXJlZm94LlxuKi9cblxucHJvZ3Jlc3Mge1xuICB2ZXJ0aWNhbC1hbGlnbjogYmFzZWxpbmU7XG59XG5cbi8qXG5Db3JyZWN0IHRoZSBjdXJzb3Igc3R5bGUgb2YgaW5jcmVtZW50IGFuZCBkZWNyZW1lbnQgYnV0dG9ucyBpbiBTYWZhcmkuXG4qL1xuXG46Oi13ZWJraXQtaW5uZXItc3Bpbi1idXR0b24sXG46Oi13ZWJraXQtb3V0ZXItc3Bpbi1idXR0b24ge1xuICBoZWlnaHQ6IGF1dG87XG59XG5cbi8qXG4xLiBDb3JyZWN0IHRoZSBvZGQgYXBwZWFyYW5jZSBpbiBDaHJvbWUgYW5kIFNhZmFyaS5cbjIuIENvcnJlY3QgdGhlIG91dGxpbmUgc3R5bGUgaW4gU2FmYXJpLlxuKi9cblxuW3R5cGU9J3NlYXJjaCddIHtcbiAgLXdlYmtpdC1hcHBlYXJhbmNlOiB0ZXh0ZmllbGQ7IC8qIDEgKi9cbiAgb3V0bGluZS1vZmZzZXQ6IC0ycHg7IC8qIDIgKi9cbn1cblxuLypcblJlbW92ZSB0aGUgaW5uZXIgcGFkZGluZyBpbiBDaHJvbWUgYW5kIFNhZmFyaSBvbiBtYWNPUy5cbiovXG5cbjo6LXdlYmtpdC1zZWFyY2gtZGVjb3JhdGlvbiB7XG4gIC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZTtcbn1cblxuLypcbjEuIENvcnJlY3QgdGhlIGluYWJpbGl0eSB0byBzdHlsZSBjbGlja2FibGUgdHlwZXMgaW4gaU9TIGFuZCBTYWZhcmkuXG4yLiBDaGFuZ2UgZm9udCBwcm9wZXJ0aWVzIHRvIFxcYGluaGVyaXRcXGAgaW4gU2FmYXJpLlxuKi9cblxuOjotd2Via2l0LWZpbGUtdXBsb2FkLWJ1dHRvbiB7XG4gIC13ZWJraXQtYXBwZWFyYW5jZTogYnV0dG9uOyAvKiAxICovXG4gIGZvbnQ6IGluaGVyaXQ7IC8qIDIgKi9cbn1cblxuLypcbkFkZCB0aGUgY29ycmVjdCBkaXNwbGF5IGluIENocm9tZSBhbmQgU2FmYXJpLlxuKi9cblxuc3VtbWFyeSB7XG4gIGRpc3BsYXk6IGxpc3QtaXRlbTtcbn1cblxuLypcblJlbW92ZXMgdGhlIGRlZmF1bHQgc3BhY2luZyBhbmQgYm9yZGVyIGZvciBhcHByb3ByaWF0ZSBlbGVtZW50cy5cbiovXG5cbmJsb2NrcXVvdGUsXG5kbCxcbmRkLFxuaDEsXG5oMixcbmgzLFxuaDQsXG5oNSxcbmg2LFxuaHIsXG5maWd1cmUsXG5wLFxucHJlIHtcbiAgbWFyZ2luOiAwO1xufVxuXG5maWVsZHNldCB7XG4gIG1hcmdpbjogMDtcbiAgcGFkZGluZzogMDtcbn1cblxubGVnZW5kIHtcbiAgcGFkZGluZzogMDtcbn1cblxub2wsXG51bCxcbm1lbnUge1xuICBsaXN0LXN0eWxlOiBub25lO1xuICBtYXJnaW46IDA7XG4gIHBhZGRpbmc6IDA7XG59XG5cbi8qXG5SZXNldCBkZWZhdWx0IHN0eWxpbmcgZm9yIGRpYWxvZ3MuXG4qL1xuZGlhbG9nIHtcbiAgcGFkZGluZzogMDtcbn1cblxuLypcblByZXZlbnQgcmVzaXppbmcgdGV4dGFyZWFzIGhvcml6b250YWxseSBieSBkZWZhdWx0LlxuKi9cblxudGV4dGFyZWEge1xuICByZXNpemU6IHZlcnRpY2FsO1xufVxuXG4vKlxuMS4gUmVzZXQgdGhlIGRlZmF1bHQgcGxhY2Vob2xkZXIgb3BhY2l0eSBpbiBGaXJlZm94LiAoaHR0cHM6Ly9naXRodWIuY29tL3RhaWx3aW5kbGFicy90YWlsd2luZGNzcy9pc3N1ZXMvMzMwMClcbjIuIFNldCB0aGUgZGVmYXVsdCBwbGFjZWhvbGRlciBjb2xvciB0byB0aGUgdXNlcidzIGNvbmZpZ3VyZWQgZ3JheSA0MDAgY29sb3IuXG4qL1xuXG5pbnB1dDo6LW1vei1wbGFjZWhvbGRlciwgdGV4dGFyZWE6Oi1tb3otcGxhY2Vob2xkZXIge1xuICBvcGFjaXR5OiAxOyAvKiAxICovXG4gIGNvbG9yOiAjOWNhM2FmOyAvKiAyICovXG59XG5cbmlucHV0OjpwbGFjZWhvbGRlcixcbnRleHRhcmVhOjpwbGFjZWhvbGRlciB7XG4gIG9wYWNpdHk6IDE7IC8qIDEgKi9cbiAgY29sb3I6ICM5Y2EzYWY7IC8qIDIgKi9cbn1cblxuLypcblNldCB0aGUgZGVmYXVsdCBjdXJzb3IgZm9yIGJ1dHRvbnMuXG4qL1xuXG5idXR0b24sXG5bcm9sZT1cImJ1dHRvblwiXSB7XG4gIGN1cnNvcjogcG9pbnRlcjtcbn1cblxuLypcbk1ha2Ugc3VyZSBkaXNhYmxlZCBidXR0b25zIGRvbid0IGdldCB0aGUgcG9pbnRlciBjdXJzb3IuXG4qL1xuOmRpc2FibGVkIHtcbiAgY3Vyc29yOiBkZWZhdWx0O1xufVxuXG4vKlxuMS4gTWFrZSByZXBsYWNlZCBlbGVtZW50cyBcXGBkaXNwbGF5OiBibG9ja1xcYCBieSBkZWZhdWx0LiAoaHR0cHM6Ly9naXRodWIuY29tL21vemRldnMvY3NzcmVtZWR5L2lzc3Vlcy8xNClcbjIuIEFkZCBcXGB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlXFxgIHRvIGFsaWduIHJlcGxhY2VkIGVsZW1lbnRzIG1vcmUgc2Vuc2libHkgYnkgZGVmYXVsdC4gKGh0dHBzOi8vZ2l0aHViLmNvbS9qZW5zaW1tb25zL2Nzc3JlbWVkeS9pc3N1ZXMvMTQjaXNzdWVjb21tZW50LTYzNDkzNDIxMClcbiAgIFRoaXMgY2FuIHRyaWdnZXIgYSBwb29ybHkgY29uc2lkZXJlZCBsaW50IGVycm9yIGluIHNvbWUgdG9vbHMgYnV0IGlzIGluY2x1ZGVkIGJ5IGRlc2lnbi5cbiovXG5cbmltZyxcbnN2ZyxcbnZpZGVvLFxuY2FudmFzLFxuYXVkaW8sXG5pZnJhbWUsXG5lbWJlZCxcbm9iamVjdCB7XG4gIGRpc3BsYXk6IGJsb2NrOyAvKiAxICovXG4gIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7IC8qIDIgKi9cbn1cblxuLypcbkNvbnN0cmFpbiBpbWFnZXMgYW5kIHZpZGVvcyB0byB0aGUgcGFyZW50IHdpZHRoIGFuZCBwcmVzZXJ2ZSB0aGVpciBpbnRyaW5zaWMgYXNwZWN0IHJhdGlvLiAoaHR0cHM6Ly9naXRodWIuY29tL21vemRldnMvY3NzcmVtZWR5L2lzc3Vlcy8xNClcbiovXG5cbmltZyxcbnZpZGVvIHtcbiAgbWF4LXdpZHRoOiAxMDAlO1xuICBoZWlnaHQ6IGF1dG87XG59XG5cbi8qIE1ha2UgZWxlbWVudHMgd2l0aCB0aGUgSFRNTCBoaWRkZW4gYXR0cmlidXRlIHN0YXkgaGlkZGVuIGJ5IGRlZmF1bHQgKi9cbltoaWRkZW5dIHtcbiAgZGlzcGxheTogbm9uZTtcbn1cblxuKiwgOjpiZWZvcmUsIDo6YWZ0ZXIge1xuICAtLXR3LWJvcmRlci1zcGFjaW5nLXg6IDA7XG4gIC0tdHctYm9yZGVyLXNwYWNpbmcteTogMDtcbiAgLS10dy10cmFuc2xhdGUteDogMDtcbiAgLS10dy10cmFuc2xhdGUteTogMDtcbiAgLS10dy1yb3RhdGU6IDA7XG4gIC0tdHctc2tldy14OiAwO1xuICAtLXR3LXNrZXcteTogMDtcbiAgLS10dy1zY2FsZS14OiAxO1xuICAtLXR3LXNjYWxlLXk6IDE7XG4gIC0tdHctcGFuLXg6ICA7XG4gIC0tdHctcGFuLXk6ICA7XG4gIC0tdHctcGluY2gtem9vbTogIDtcbiAgLS10dy1zY3JvbGwtc25hcC1zdHJpY3RuZXNzOiBwcm94aW1pdHk7XG4gIC0tdHctZ3JhZGllbnQtZnJvbS1wb3NpdGlvbjogIDtcbiAgLS10dy1ncmFkaWVudC12aWEtcG9zaXRpb246ICA7XG4gIC0tdHctZ3JhZGllbnQtdG8tcG9zaXRpb246ICA7XG4gIC0tdHctb3JkaW5hbDogIDtcbiAgLS10dy1zbGFzaGVkLXplcm86ICA7XG4gIC0tdHctbnVtZXJpYy1maWd1cmU6ICA7XG4gIC0tdHctbnVtZXJpYy1zcGFjaW5nOiAgO1xuICAtLXR3LW51bWVyaWMtZnJhY3Rpb246ICA7XG4gIC0tdHctcmluZy1pbnNldDogIDtcbiAgLS10dy1yaW5nLW9mZnNldC13aWR0aDogMHB4O1xuICAtLXR3LXJpbmctb2Zmc2V0LWNvbG9yOiAjZmZmO1xuICAtLXR3LXJpbmctY29sb3I6IHJnYig1OSAxMzAgMjQ2IC8gMC41KTtcbiAgLS10dy1yaW5nLW9mZnNldC1zaGFkb3c6IDAgMCAjMDAwMDtcbiAgLS10dy1yaW5nLXNoYWRvdzogMCAwICMwMDAwO1xuICAtLXR3LXNoYWRvdzogMCAwICMwMDAwO1xuICAtLXR3LXNoYWRvdy1jb2xvcmVkOiAwIDAgIzAwMDA7XG4gIC0tdHctYmx1cjogIDtcbiAgLS10dy1icmlnaHRuZXNzOiAgO1xuICAtLXR3LWNvbnRyYXN0OiAgO1xuICAtLXR3LWdyYXlzY2FsZTogIDtcbiAgLS10dy1odWUtcm90YXRlOiAgO1xuICAtLXR3LWludmVydDogIDtcbiAgLS10dy1zYXR1cmF0ZTogIDtcbiAgLS10dy1zZXBpYTogIDtcbiAgLS10dy1kcm9wLXNoYWRvdzogIDtcbiAgLS10dy1iYWNrZHJvcC1ibHVyOiAgO1xuICAtLXR3LWJhY2tkcm9wLWJyaWdodG5lc3M6ICA7XG4gIC0tdHctYmFja2Ryb3AtY29udHJhc3Q6ICA7XG4gIC0tdHctYmFja2Ryb3AtZ3JheXNjYWxlOiAgO1xuICAtLXR3LWJhY2tkcm9wLWh1ZS1yb3RhdGU6ICA7XG4gIC0tdHctYmFja2Ryb3AtaW52ZXJ0OiAgO1xuICAtLXR3LWJhY2tkcm9wLW9wYWNpdHk6ICA7XG4gIC0tdHctYmFja2Ryb3Atc2F0dXJhdGU6ICA7XG4gIC0tdHctYmFja2Ryb3Atc2VwaWE6ICA7XG4gIC0tdHctY29udGFpbi1zaXplOiAgO1xuICAtLXR3LWNvbnRhaW4tbGF5b3V0OiAgO1xuICAtLXR3LWNvbnRhaW4tcGFpbnQ6ICA7XG4gIC0tdHctY29udGFpbi1zdHlsZTogIDtcbn1cblxuOjpiYWNrZHJvcCB7XG4gIC0tdHctYm9yZGVyLXNwYWNpbmcteDogMDtcbiAgLS10dy1ib3JkZXItc3BhY2luZy15OiAwO1xuICAtLXR3LXRyYW5zbGF0ZS14OiAwO1xuICAtLXR3LXRyYW5zbGF0ZS15OiAwO1xuICAtLXR3LXJvdGF0ZTogMDtcbiAgLS10dy1za2V3LXg6IDA7XG4gIC0tdHctc2tldy15OiAwO1xuICAtLXR3LXNjYWxlLXg6IDE7XG4gIC0tdHctc2NhbGUteTogMTtcbiAgLS10dy1wYW4teDogIDtcbiAgLS10dy1wYW4teTogIDtcbiAgLS10dy1waW5jaC16b29tOiAgO1xuICAtLXR3LXNjcm9sbC1zbmFwLXN0cmljdG5lc3M6IHByb3hpbWl0eTtcbiAgLS10dy1ncmFkaWVudC1mcm9tLXBvc2l0aW9uOiAgO1xuICAtLXR3LWdyYWRpZW50LXZpYS1wb3NpdGlvbjogIDtcbiAgLS10dy1ncmFkaWVudC10by1wb3NpdGlvbjogIDtcbiAgLS10dy1vcmRpbmFsOiAgO1xuICAtLXR3LXNsYXNoZWQtemVybzogIDtcbiAgLS10dy1udW1lcmljLWZpZ3VyZTogIDtcbiAgLS10dy1udW1lcmljLXNwYWNpbmc6ICA7XG4gIC0tdHctbnVtZXJpYy1mcmFjdGlvbjogIDtcbiAgLS10dy1yaW5nLWluc2V0OiAgO1xuICAtLXR3LXJpbmctb2Zmc2V0LXdpZHRoOiAwcHg7XG4gIC0tdHctcmluZy1vZmZzZXQtY29sb3I6ICNmZmY7XG4gIC0tdHctcmluZy1jb2xvcjogcmdiKDU5IDEzMCAyNDYgLyAwLjUpO1xuICAtLXR3LXJpbmctb2Zmc2V0LXNoYWRvdzogMCAwICMwMDAwO1xuICAtLXR3LXJpbmctc2hhZG93OiAwIDAgIzAwMDA7XG4gIC0tdHctc2hhZG93OiAwIDAgIzAwMDA7XG4gIC0tdHctc2hhZG93LWNvbG9yZWQ6IDAgMCAjMDAwMDtcbiAgLS10dy1ibHVyOiAgO1xuICAtLXR3LWJyaWdodG5lc3M6ICA7XG4gIC0tdHctY29udHJhc3Q6ICA7XG4gIC0tdHctZ3JheXNjYWxlOiAgO1xuICAtLXR3LWh1ZS1yb3RhdGU6ICA7XG4gIC0tdHctaW52ZXJ0OiAgO1xuICAtLXR3LXNhdHVyYXRlOiAgO1xuICAtLXR3LXNlcGlhOiAgO1xuICAtLXR3LWRyb3Atc2hhZG93OiAgO1xuICAtLXR3LWJhY2tkcm9wLWJsdXI6ICA7XG4gIC0tdHctYmFja2Ryb3AtYnJpZ2h0bmVzczogIDtcbiAgLS10dy1iYWNrZHJvcC1jb250cmFzdDogIDtcbiAgLS10dy1iYWNrZHJvcC1ncmF5c2NhbGU6ICA7XG4gIC0tdHctYmFja2Ryb3AtaHVlLXJvdGF0ZTogIDtcbiAgLS10dy1iYWNrZHJvcC1pbnZlcnQ6ICA7XG4gIC0tdHctYmFja2Ryb3Atb3BhY2l0eTogIDtcbiAgLS10dy1iYWNrZHJvcC1zYXR1cmF0ZTogIDtcbiAgLS10dy1iYWNrZHJvcC1zZXBpYTogIDtcbiAgLS10dy1jb250YWluLXNpemU6ICA7XG4gIC0tdHctY29udGFpbi1sYXlvdXQ6ICA7XG4gIC0tdHctY29udGFpbi1wYWludDogIDtcbiAgLS10dy1jb250YWluLXN0eWxlOiAgO1xufVxyXG4ucG9pbnRlci1ldmVudHMtbm9uZSB7XG4gIHBvaW50ZXItZXZlbnRzOiBub25lO1xufVxyXG4udmlzaWJsZSB7XG4gIHZpc2liaWxpdHk6IHZpc2libGU7XG59XHJcbi5pbnZpc2libGUge1xuICB2aXNpYmlsaXR5OiBoaWRkZW47XG59XHJcbi5jb2xsYXBzZSB7XG4gIHZpc2liaWxpdHk6IGNvbGxhcHNlO1xufVxyXG4uc3RhdGljIHtcbiAgcG9zaXRpb246IHN0YXRpYztcbn1cclxuLlxcXFwhZml4ZWQge1xuICBwb3NpdGlvbjogZml4ZWQgIWltcG9ydGFudDtcbn1cclxuLmZpeGVkIHtcbiAgcG9zaXRpb246IGZpeGVkO1xufVxyXG4uYWJzb2x1dGUge1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG59XHJcbi5yZWxhdGl2ZSB7XG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcbn1cclxuLmJvdHRvbS0wIHtcbiAgYm90dG9tOiAwcHg7XG59XHJcbi5ib3R0b20tXFxcXFs0NXB4XFxcXF0ge1xuICBib3R0b206IDQ1cHg7XG59XHJcbi5sZWZ0LTAge1xuICBsZWZ0OiAwcHg7XG59XHJcbi5yaWdodC0wIHtcbiAgcmlnaHQ6IDBweDtcbn1cclxuLnJpZ2h0LVxcXFxbLTMxcHhcXFxcXSB7XG4gIHJpZ2h0OiAtMzFweDtcbn1cclxuLnJpZ2h0LVxcXFxbMjRweFxcXFxdIHtcbiAgcmlnaHQ6IDI0cHg7XG59XHJcbi5yaWdodC1cXFxcWzI2cHhcXFxcXSB7XG4gIHJpZ2h0OiAyNnB4O1xufVxyXG4ucmlnaHQtXFxcXFs0MHB4XFxcXF0ge1xuICByaWdodDogNDBweDtcbn1cclxuLnRvcC0wIHtcbiAgdG9wOiAwcHg7XG59XHJcbi50b3AtXFxcXFstMTVweFxcXFxdIHtcbiAgdG9wOiAtMTVweDtcbn1cclxuLnRvcC1cXFxcWzExMHB4XFxcXF0ge1xuICB0b3A6IDExMHB4O1xufVxyXG4udG9wLVxcXFxbMTI2cHhcXFxcXSB7XG4gIHRvcDogMTI2cHg7XG59XHJcbi4tei0wIHtcbiAgei1pbmRleDogMDtcbn1cclxuLnotMCB7XG4gIHotaW5kZXg6IDA7XG59XHJcbi56LTQwIHtcbiAgei1pbmRleDogNDA7XG59XHJcbi56LVxcXFxbMVxcXFxdIHtcbiAgei1pbmRleDogMTtcbn1cclxuLnotXFxcXFsyXFxcXF0ge1xuICB6LWluZGV4OiAyO1xufVxyXG4ubXgtYXV0byB7XG4gIG1hcmdpbi1sZWZ0OiBhdXRvO1xuICBtYXJnaW4tcmlnaHQ6IGF1dG87XG59XHJcbi5tYi0wIHtcbiAgbWFyZ2luLWJvdHRvbTogMHB4O1xufVxyXG4ubWItXFxcXFsxMDFweFxcXFxdIHtcbiAgbWFyZ2luLWJvdHRvbTogMTAxcHg7XG59XHJcbi5tYi1cXFxcWzk2cHhcXFxcXSB7XG4gIG1hcmdpbi1ib3R0b206IDk2cHg7XG59XHJcbi5tYi1hdXRvIHtcbiAgbWFyZ2luLWJvdHRvbTogYXV0bztcbn1cclxuLm1sLVxcXFxbNTlweFxcXFxdIHtcbiAgbWFyZ2luLWxlZnQ6IDU5cHg7XG59XHJcbi5tdC0wIHtcbiAgbWFyZ2luLXRvcDogMHB4O1xufVxyXG4ubXQtXFxcXFs0NHB4XFxcXF0ge1xuICBtYXJnaW4tdG9wOiA0NHB4O1xufVxyXG4ubXQtXFxcXFs1NnB4XFxcXF0ge1xuICBtYXJnaW4tdG9wOiA1NnB4O1xufVxyXG4ubXQtXFxcXFs3MHB4XFxcXF0ge1xuICBtYXJnaW4tdG9wOiA3MHB4O1xufVxyXG4ubXQtXFxcXFsxMDBweFxcXFxdIHtcbiAgbWFyZ2luLXRvcDogMTAwcHg7XG59XHJcbi5ibG9jayB7XG4gIGRpc3BsYXk6IGJsb2NrO1xufVxyXG4uZmxleCB7XG4gIGRpc3BsYXk6IGZsZXg7XG59XHJcbi50YWJsZSB7XG4gIGRpc3BsYXk6IHRhYmxlO1xufVxyXG4uZ3JpZCB7XG4gIGRpc3BsYXk6IGdyaWQ7XG59XHJcbi5jb250ZW50cyB7XG4gIGRpc3BsYXk6IGNvbnRlbnRzO1xufVxyXG4uaGlkZGVuIHtcbiAgZGlzcGxheTogbm9uZTtcbn1cclxuLnNpemUtXFxcXFs0MHB4XFxcXF0ge1xuICB3aWR0aDogNDBweDtcbiAgaGVpZ2h0OiA0MHB4O1xufVxyXG4uc2l6ZS1mdWxsIHtcbiAgd2lkdGg6IDEwMCU7XG4gIGhlaWdodDogMTAwJTtcbn1cclxuLmgtXFxcXFsxMTBweFxcXFxdIHtcbiAgaGVpZ2h0OiAxMTBweDtcbn1cclxuLmgtXFxcXFsxOHB4XFxcXF0ge1xuICBoZWlnaHQ6IDE4cHg7XG59XHJcbi5oLVxcXFxbMjAwcHhcXFxcXSB7XG4gIGhlaWdodDogMjAwcHg7XG59XHJcbi5oLVxcXFxbMjBweFxcXFxdIHtcbiAgaGVpZ2h0OiAyMHB4O1xufVxyXG4uaC1cXFxcWzIzM3B4XFxcXF0ge1xuICBoZWlnaHQ6IDIzM3B4O1xufVxyXG4uaC1cXFxcWzI4cHhcXFxcXSB7XG4gIGhlaWdodDogMjhweDtcbn1cclxuLmgtXFxcXFsyOTJweFxcXFxdIHtcbiAgaGVpZ2h0OiAyOTJweDtcbn1cclxuLmgtXFxcXFs2NHB4XFxcXF0ge1xuICBoZWlnaHQ6IDY0cHg7XG59XHJcbi5oLVxcXFxbNzJweFxcXFxdIHtcbiAgaGVpZ2h0OiA3MnB4O1xufVxyXG4uaC1maXQge1xuICBoZWlnaHQ6IC1tb3otZml0LWNvbnRlbnQ7XG4gIGhlaWdodDogZml0LWNvbnRlbnQ7XG59XHJcbi5oLWZ1bGwge1xuICBoZWlnaHQ6IDEwMCU7XG59XHJcbi5taW4taC1kdmgge1xuICBtaW4taGVpZ2h0OiAxMDBkdmg7XG59XHJcbi5taW4taC1zY3JlZW4ge1xuICBtaW4taGVpZ2h0OiAxMDB2aDtcbn1cclxuLnctMSB7XG4gIHdpZHRoOiAwLjI1cmVtO1xufVxyXG4udy0zIHtcbiAgd2lkdGg6IDAuNzVyZW07XG59XHJcbi53LVxcXFxbMTc3cHhcXFxcXSB7XG4gIHdpZHRoOiAxNzdweDtcbn1cclxuLnctXFxcXFsxOTlweFxcXFxdIHtcbiAgd2lkdGg6IDE5OXB4O1xufVxyXG4udy1cXFxcWzIwcHhcXFxcXSB7XG4gIHdpZHRoOiAyMHB4O1xufVxyXG4udy1cXFxcWzI0cHhcXFxcXSB7XG4gIHdpZHRoOiAyNHB4O1xufVxyXG4udy1cXFxcWzM5MHB4XFxcXF0ge1xuICB3aWR0aDogMzkwcHg7XG59XHJcbi53LVxcXFxbNjJweFxcXFxdIHtcbiAgd2lkdGg6IDYycHg7XG59XHJcbi53LWZpdCB7XG4gIHdpZHRoOiAtbW96LWZpdC1jb250ZW50O1xuICB3aWR0aDogZml0LWNvbnRlbnQ7XG59XHJcbi53LWZ1bGwge1xuICB3aWR0aDogMTAwJTtcbn1cclxuLm1pbi13LVxcXFxbMTQ3cHhcXFxcXSB7XG4gIG1pbi13aWR0aDogMTQ3cHg7XG59XHJcbi5tYXgtdy1cXFxcWzEzNDJweFxcXFxdIHtcbiAgbWF4LXdpZHRoOiAxMzQycHg7XG59XHJcbi5tYXgtdy1cXFxcWzE0NDBweFxcXFxdIHtcbiAgbWF4LXdpZHRoOiAxNDQwcHg7XG59XHJcbi5tYXgtdy1cXFxcWzE5MHB4XFxcXF0ge1xuICBtYXgtd2lkdGg6IDE5MHB4O1xufVxyXG4ubWF4LXctXFxcXFsyNTJweFxcXFxdIHtcbiAgbWF4LXdpZHRoOiAyNTJweDtcbn1cclxuLm1heC13LVxcXFxbMjgxcHhcXFxcXSB7XG4gIG1heC13aWR0aDogMjgxcHg7XG59XHJcbi5tYXgtdy1cXFxcWzQzOHB4XFxcXF0ge1xuICBtYXgtd2lkdGg6IDQzOHB4O1xufVxyXG4ubWF4LXctXFxcXFs3MzBweFxcXFxdIHtcbiAgbWF4LXdpZHRoOiA3MzBweDtcbn1cclxuLm1heC13LVxcXFxbY2FsY1xcXFwoMTI3NXB4XFxcXCszOXB4XFxcXClcXFxcXSB7XG4gIG1heC13aWR0aDogY2FsYygxMjc1cHggKyAzOXB4KTtcbn1cclxuLm1heC13LWZ1bGwge1xuICBtYXgtd2lkdGg6IDEwMCU7XG59XHJcbi5mbGV4LXNocmluayB7XG4gIGZsZXgtc2hyaW5rOiAxO1xufVxyXG4uYm9yZGVyLWNvbGxhcHNlIHtcbiAgYm9yZGVyLWNvbGxhcHNlOiBjb2xsYXBzZTtcbn1cclxuLnRyYW5zbGF0ZS14LVxcXFxbMTUwXFxcXCVcXFxcXSB7XG4gIC0tdHctdHJhbnNsYXRlLXg6IDE1MCU7XG4gIHRyYW5zZm9ybTogdHJhbnNsYXRlKHZhcigtLXR3LXRyYW5zbGF0ZS14KSwgdmFyKC0tdHctdHJhbnNsYXRlLXkpKSByb3RhdGUodmFyKC0tdHctcm90YXRlKSkgc2tld1godmFyKC0tdHctc2tldy14KSkgc2tld1kodmFyKC0tdHctc2tldy15KSkgc2NhbGVYKHZhcigtLXR3LXNjYWxlLXgpKSBzY2FsZVkodmFyKC0tdHctc2NhbGUteSkpO1xufVxyXG4udHJhbnNsYXRlLXktXFxcXFswcHhcXFxcXSB7XG4gIC0tdHctdHJhbnNsYXRlLXk6IDBweDtcbiAgdHJhbnNmb3JtOiB0cmFuc2xhdGUodmFyKC0tdHctdHJhbnNsYXRlLXgpLCB2YXIoLS10dy10cmFuc2xhdGUteSkpIHJvdGF0ZSh2YXIoLS10dy1yb3RhdGUpKSBza2V3WCh2YXIoLS10dy1za2V3LXgpKSBza2V3WSh2YXIoLS10dy1za2V3LXkpKSBzY2FsZVgodmFyKC0tdHctc2NhbGUteCkpIHNjYWxlWSh2YXIoLS10dy1zY2FsZS15KSk7XG59XHJcbi5zY2FsZS0xMDUge1xuICAtLXR3LXNjYWxlLXg6IDEuMDU7XG4gIC0tdHctc2NhbGUteTogMS4wNTtcbiAgdHJhbnNmb3JtOiB0cmFuc2xhdGUodmFyKC0tdHctdHJhbnNsYXRlLXgpLCB2YXIoLS10dy10cmFuc2xhdGUteSkpIHJvdGF0ZSh2YXIoLS10dy1yb3RhdGUpKSBza2V3WCh2YXIoLS10dy1za2V3LXgpKSBza2V3WSh2YXIoLS10dy1za2V3LXkpKSBzY2FsZVgodmFyKC0tdHctc2NhbGUteCkpIHNjYWxlWSh2YXIoLS10dy1zY2FsZS15KSk7XG59XHJcbi50cmFuc2Zvcm0ge1xuICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSh2YXIoLS10dy10cmFuc2xhdGUteCksIHZhcigtLXR3LXRyYW5zbGF0ZS15KSkgcm90YXRlKHZhcigtLXR3LXJvdGF0ZSkpIHNrZXdYKHZhcigtLXR3LXNrZXcteCkpIHNrZXdZKHZhcigtLXR3LXNrZXcteSkpIHNjYWxlWCh2YXIoLS10dy1zY2FsZS14KSkgc2NhbGVZKHZhcigtLXR3LXNjYWxlLXkpKTtcbn1cclxuLnJlc2l6ZSB7XG4gIHJlc2l6ZTogYm90aDtcbn1cclxuLmZsZXgtcm93IHtcbiAgZmxleC1kaXJlY3Rpb246IHJvdztcbn1cclxuLmZsZXgtY29sIHtcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbn1cclxuLmZsZXgtY29sLXJldmVyc2Uge1xuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uLXJldmVyc2U7XG59XHJcbi5pdGVtcy1zdGFydCB7XG4gIGFsaWduLWl0ZW1zOiBmbGV4LXN0YXJ0O1xufVxyXG4uaXRlbXMtY2VudGVyIHtcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbn1cclxuLmp1c3RpZnktc3RhcnQge1xuICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtc3RhcnQ7XG59XHJcbi5qdXN0aWZ5LWVuZCB7XG4gIGp1c3RpZnktY29udGVudDogZmxleC1lbmQ7XG59XHJcbi5qdXN0aWZ5LWNlbnRlciB7XG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xufVxyXG4uanVzdGlmeS1iZXR3ZWVuIHtcbiAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xufVxyXG4uZ2FwLVxcXFxbMTZweFxcXFxdIHtcbiAgZ2FwOiAxNnB4O1xufVxyXG4uZ2FwLVxcXFxbMjBweFxcXFxdIHtcbiAgZ2FwOiAyMHB4O1xufVxyXG4uZ2FwLVxcXFxbMjRweFxcXFxdIHtcbiAgZ2FwOiAyNHB4O1xufVxyXG4uZ2FwLVxcXFxbMjhweFxcXFxdIHtcbiAgZ2FwOiAyOHB4O1xufVxyXG4uZ2FwLVxcXFxbMzJweFxcXFxdIHtcbiAgZ2FwOiAzMnB4O1xufVxyXG4uZ2FwLVxcXFxbNDBweFxcXFxdIHtcbiAgZ2FwOiA0MHB4O1xufVxyXG4uZ2FwLVxcXFxbNDdweFxcXFxdIHtcbiAgZ2FwOiA0N3B4O1xufVxyXG4uZ2FwLVxcXFxbNDhweFxcXFxdIHtcbiAgZ2FwOiA0OHB4O1xufVxyXG4uZ2FwLVxcXFxbNTFweFxcXFxdIHtcbiAgZ2FwOiA1MXB4O1xufVxyXG4uc2VsZi1hdXRvIHtcbiAgYWxpZ24tc2VsZjogYXV0bztcbn1cclxuLnNlbGYtc3RhcnQge1xuICBhbGlnbi1zZWxmOiBmbGV4LXN0YXJ0O1xufVxyXG4uc2VsZi1lbmQge1xuICBhbGlnbi1zZWxmOiBmbGV4LWVuZDtcbn1cclxuLm92ZXJmbG93LWhpZGRlbiB7XG4gIG92ZXJmbG93OiBoaWRkZW47XG59XHJcbi5vdmVyZmxvdy14LWNsaXAge1xuICBvdmVyZmxvdy14OiBjbGlwO1xufVxyXG4ucm91bmRlZCB7XG4gIGJvcmRlci1yYWRpdXM6IDAuMjVyZW07XG59XHJcbi5ib3JkZXIge1xuICBib3JkZXItd2lkdGg6IDFweDtcbn1cclxuLmJnLVxcXFxbXFxcXCMxOTE5MjFcXFxcXSB7XG4gIC0tdHctYmctb3BhY2l0eTogMTtcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDI1IDI1IDMzIC8gdmFyKC0tdHctYmctb3BhY2l0eSkpO1xufVxyXG4uYmctXFxcXFtcXFxcI0Y5NEY0RlxcXFxdIHtcbiAgLS10dy1iZy1vcGFjaXR5OiAxO1xuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMjQ5IDc5IDc5IC8gdmFyKC0tdHctYmctb3BhY2l0eSkpO1xufVxyXG4uYmctYmxhY2sge1xuICAtLXR3LWJnLW9wYWNpdHk6IDE7XG4gIGJhY2tncm91bmQtY29sb3I6IHJnYigwIDAgMCAvIHZhcigtLXR3LWJnLW9wYWNpdHkpKTtcbn1cclxuLnN0cm9rZS1cXFxcW1xcXFwjRjk0RjRGXFxcXF0ge1xuICBzdHJva2U6ICNGOTRGNEY7XG59XHJcbi5zdHJva2UtXFxcXFtcXFxcI0ZGOTM5M1xcXFxdIHtcbiAgc3Ryb2tlOiAjRkY5MzkzO1xufVxyXG4ub2JqZWN0LWNvbnRhaW4ge1xuICAtby1vYmplY3QtZml0OiBjb250YWluO1xuICAgICBvYmplY3QtZml0OiBjb250YWluO1xufVxyXG4ub2JqZWN0LWNvdmVyIHtcbiAgLW8tb2JqZWN0LWZpdDogY292ZXI7XG4gICAgIG9iamVjdC1maXQ6IGNvdmVyO1xufVxyXG4ub2JqZWN0LWZpbGwge1xuICAtby1vYmplY3QtZml0OiBmaWxsO1xuICAgICBvYmplY3QtZml0OiBmaWxsO1xufVxyXG4ub2JqZWN0LXNjYWxlLWRvd24ge1xuICAtby1vYmplY3QtZml0OiBzY2FsZS1kb3duO1xuICAgICBvYmplY3QtZml0OiBzY2FsZS1kb3duO1xufVxyXG4ub2JqZWN0LWJvdHRvbSB7XG4gIC1vLW9iamVjdC1wb3NpdGlvbjogYm90dG9tO1xuICAgICBvYmplY3QtcG9zaXRpb246IGJvdHRvbTtcbn1cclxuLm9iamVjdC1jZW50ZXIge1xuICAtby1vYmplY3QtcG9zaXRpb246IGNlbnRlcjtcbiAgICAgb2JqZWN0LXBvc2l0aW9uOiBjZW50ZXI7XG59XHJcbi5vYmplY3QtcmlnaHQge1xuICAtby1vYmplY3QtcG9zaXRpb246IHJpZ2h0O1xuICAgICBvYmplY3QtcG9zaXRpb246IHJpZ2h0O1xufVxyXG4ub2JqZWN0LXRvcCB7XG4gIC1vLW9iamVjdC1wb3NpdGlvbjogdG9wO1xuICAgICBvYmplY3QtcG9zaXRpb246IHRvcDtcbn1cclxuLnB4LTAge1xuICBwYWRkaW5nLWxlZnQ6IDBweDtcbiAgcGFkZGluZy1yaWdodDogMHB4O1xufVxyXG4ucHgtXFxcXFsyNHB4XFxcXF0ge1xuICBwYWRkaW5nLWxlZnQ6IDI0cHg7XG4gIHBhZGRpbmctcmlnaHQ6IDI0cHg7XG59XHJcbi5weC1cXFxcWzQwcHhcXFxcXSB7XG4gIHBhZGRpbmctbGVmdDogNDBweDtcbiAgcGFkZGluZy1yaWdodDogNDBweDtcbn1cclxuLnB5LTAge1xuICBwYWRkaW5nLXRvcDogMHB4O1xuICBwYWRkaW5nLWJvdHRvbTogMHB4O1xufVxyXG4ucHktXFxcXFs3MnB4XFxcXF0ge1xuICBwYWRkaW5nLXRvcDogNzJweDtcbiAgcGFkZGluZy1ib3R0b206IDcycHg7XG59XHJcbi5wbC0wIHtcbiAgcGFkZGluZy1sZWZ0OiAwcHg7XG59XHJcbi5wbC1cXFxcWzMzcHhcXFxcXSB7XG4gIHBhZGRpbmctbGVmdDogMzNweDtcbn1cclxuLnBsLVxcXFxbMzlweFxcXFxdIHtcbiAgcGFkZGluZy1sZWZ0OiAzOXB4O1xufVxyXG4ucGwtXFxcXFs0MHB4XFxcXF0ge1xuICBwYWRkaW5nLWxlZnQ6IDQwcHg7XG59XHJcbi5wci0wIHtcbiAgcGFkZGluZy1yaWdodDogMHB4O1xufVxyXG4ucHItXFxcXFs0MHB4XFxcXF0ge1xuICBwYWRkaW5nLXJpZ2h0OiA0MHB4O1xufVxyXG4ucHQtXFxcXFszMnB4XFxcXF0ge1xuICBwYWRkaW5nLXRvcDogMzJweDtcbn1cclxuLnRleHQtY2VudGVyIHtcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xufVxyXG4udGV4dC1zdGFydCB7XG4gIHRleHQtYWxpZ246IHN0YXJ0O1xufVxyXG4udGV4dC1lbmQge1xuICB0ZXh0LWFsaWduOiBlbmQ7XG59XHJcbi5mb250LWNvbW1pc3Npb25lciB7XG4gIGZvbnQtZmFtaWx5OiBcIkNvbW1pc3Npb25lclwiLCBzYW5zLXNlcmlmO1xufVxyXG4udGV4dC1cXFxcWzE1cHhcXFxcXSB7XG4gIGZvbnQtc2l6ZTogMTVweDtcbn1cclxuLnRleHQtXFxcXFsxNnB4XFxcXF0ge1xuICBmb250LXNpemU6IDE2cHg7XG59XHJcbi50ZXh0LVxcXFxbMThweFxcXFxdIHtcbiAgZm9udC1zaXplOiAxOHB4O1xufVxyXG4udGV4dC1cXFxcWzMycHhcXFxcXSB7XG4gIGZvbnQtc2l6ZTogMzJweDtcbn1cclxuLnRleHQtXFxcXFs0MHB4XFxcXF0ge1xuICBmb250LXNpemU6IDQwcHg7XG59XHJcbi50ZXh0LVxcXFxbODBweFxcXFxdIHtcbiAgZm9udC1zaXplOiA4MHB4O1xufVxyXG4uZm9udC1leHRyYWJvbGQge1xuICBmb250LXdlaWdodDogODAwO1xufVxyXG4ubGVhZGluZy1cXFxcWzIwcHhcXFxcXSB7XG4gIGxpbmUtaGVpZ2h0OiAyMHB4O1xufVxyXG4ubGVhZGluZy1cXFxcWzI1cHhcXFxcXSB7XG4gIGxpbmUtaGVpZ2h0OiAyNXB4O1xufVxyXG4ubGVhZGluZy1cXFxcWzMycHhcXFxcXSB7XG4gIGxpbmUtaGVpZ2h0OiAzMnB4O1xufVxyXG4ubGVhZGluZy1cXFxcWzQwcHhcXFxcXSB7XG4gIGxpbmUtaGVpZ2h0OiA0MHB4O1xufVxyXG4ubGVhZGluZy1cXFxcWzg4cHhcXFxcXSB7XG4gIGxpbmUtaGVpZ2h0OiA4OHB4O1xufVxyXG4udGV4dC1cXFxcW1xcXFwjRjk0RjRGXFxcXF0ge1xuICAtLXR3LXRleHQtb3BhY2l0eTogMTtcbiAgY29sb3I6IHJnYigyNDkgNzkgNzkgLyB2YXIoLS10dy10ZXh0LW9wYWNpdHkpKTtcbn1cclxuLnRleHQtd2hpdGUge1xuICAtLXR3LXRleHQtb3BhY2l0eTogMTtcbiAgY29sb3I6IHJnYigyNTUgMjU1IDI1NSAvIHZhcigtLXR3LXRleHQtb3BhY2l0eSkpO1xufVxyXG4udGV4dC13aGl0ZVxcXFwvMjUge1xuICBjb2xvcjogcmdiKDI1NSAyNTUgMjU1IC8gMC4yNSk7XG59XHJcbi51bmRlcmxpbmUge1xuICB0ZXh0LWRlY29yYXRpb24tbGluZTogdW5kZXJsaW5lO1xufVxyXG4ub3ZlcmxpbmUge1xuICB0ZXh0LWRlY29yYXRpb24tbGluZTogb3ZlcmxpbmU7XG59XHJcbi51bmRlcmxpbmUtb2Zmc2V0LVxcXFxbMTJweFxcXFxdIHtcbiAgdGV4dC11bmRlcmxpbmUtb2Zmc2V0OiAxMnB4O1xufVxyXG4ub3BhY2l0eS0wIHtcbiAgb3BhY2l0eTogMDtcbn1cclxuLm91dGxpbmUge1xuICBvdXRsaW5lLXN0eWxlOiBzb2xpZDtcbn1cclxuLmZpbHRlciB7XG4gIGZpbHRlcjogdmFyKC0tdHctYmx1cikgdmFyKC0tdHctYnJpZ2h0bmVzcykgdmFyKC0tdHctY29udHJhc3QpIHZhcigtLXR3LWdyYXlzY2FsZSkgdmFyKC0tdHctaHVlLXJvdGF0ZSkgdmFyKC0tdHctaW52ZXJ0KSB2YXIoLS10dy1zYXR1cmF0ZSkgdmFyKC0tdHctc2VwaWEpIHZhcigtLXR3LWRyb3Atc2hhZG93KTtcbn1cclxuLnRyYW5zaXRpb24ge1xuICB0cmFuc2l0aW9uLXByb3BlcnR5OiBjb2xvciwgYmFja2dyb3VuZC1jb2xvciwgYm9yZGVyLWNvbG9yLCB0ZXh0LWRlY29yYXRpb24tY29sb3IsIGZpbGwsIHN0cm9rZSwgb3BhY2l0eSwgYm94LXNoYWRvdywgdHJhbnNmb3JtLCBmaWx0ZXIsIC13ZWJraXQtYmFja2Ryb3AtZmlsdGVyO1xuICB0cmFuc2l0aW9uLXByb3BlcnR5OiBjb2xvciwgYmFja2dyb3VuZC1jb2xvciwgYm9yZGVyLWNvbG9yLCB0ZXh0LWRlY29yYXRpb24tY29sb3IsIGZpbGwsIHN0cm9rZSwgb3BhY2l0eSwgYm94LXNoYWRvdywgdHJhbnNmb3JtLCBmaWx0ZXIsIGJhY2tkcm9wLWZpbHRlcjtcbiAgdHJhbnNpdGlvbi1wcm9wZXJ0eTogY29sb3IsIGJhY2tncm91bmQtY29sb3IsIGJvcmRlci1jb2xvciwgdGV4dC1kZWNvcmF0aW9uLWNvbG9yLCBmaWxsLCBzdHJva2UsIG9wYWNpdHksIGJveC1zaGFkb3csIHRyYW5zZm9ybSwgZmlsdGVyLCBiYWNrZHJvcC1maWx0ZXIsIC13ZWJraXQtYmFja2Ryb3AtZmlsdGVyO1xuICB0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbjogY3ViaWMtYmV6aWVyKDAuNCwgMCwgMC4yLCAxKTtcbiAgdHJhbnNpdGlvbi1kdXJhdGlvbjogMTUwbXM7XG59XHJcbi50cmFuc2l0aW9uLWFsbCB7XG4gIHRyYW5zaXRpb24tcHJvcGVydHk6IGFsbDtcbiAgdHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLjQsIDAsIDAuMiwgMSk7XG4gIHRyYW5zaXRpb24tZHVyYXRpb246IDE1MG1zO1xufVxyXG5cclxuaDEge1xuICBmb250LXNpemU6IDQwcHg7XG4gIGZvbnQtd2VpZ2h0OiA4MDA7XG4gIGxpbmUtaGVpZ2h0OiA0MHB4O1xufVxyXG5cclxuQG1lZGlhIChtaW4td2lkdGg6IDc2OHB4KSB7XG5cbiAgaDEge1xuICAgIGZvbnQtc2l6ZTogNTZweDtcbiAgICBsaW5lLWhlaWdodDogNTZweDtcbiAgfVxufVxyXG5cclxuQG1lZGlhIChtaW4td2lkdGg6IDEyODBweCkge1xuXG4gIGgxIHtcbiAgICBmb250LXNpemU6IDgwcHg7XG4gICAgbGluZS1oZWlnaHQ6IDg4cHg7XG4gIH1cbn1cclxuXHJcbmgyIHtcbiAgZm9udC1zaXplOiAzMnB4O1xuICBmb250LXdlaWdodDogODAwO1xuICBsaW5lLWhlaWdodDogNDBweDtcbn1cclxuXHJcbkBtZWRpYSAobWluLXdpZHRoOiAxMjgwcHgpIHtcblxuICBoMiB7XG4gICAgZm9udC1zaXplOiA1NnB4O1xuICAgIGxpbmUtaGVpZ2h0OiA2NHB4O1xuICB9XG59XHJcblxyXG5oMyB7XG4gIGZvbnQtc2l6ZTogMTVweDtcbiAgZm9udC13ZWlnaHQ6IDgwMDtcbiAgbGluZS1oZWlnaHQ6IDIwcHg7XG59XHJcblxyXG5AbWVkaWEgKG1pbi13aWR0aDogMTI4MHB4KSB7XG5cbiAgaDMge1xuICAgIGZvbnQtc2l6ZTogMjBweDtcbiAgICBsaW5lLWhlaWdodDogMzJweDtcbiAgfVxufVxyXG5cclxucCB7XG4gIGZvbnQtc2l6ZTogMTVweDtcbiAgbGluZS1oZWlnaHQ6IDI1cHg7XG59XHJcblxyXG5AbWVkaWEgKG1pbi13aWR0aDogMTI4MHB4KSB7XG5cbiAgcCB7XG4gICAgZm9udC1zaXplOiAxOHB4O1xuICAgIGxpbmUtaGVpZ2h0OiAzMnB4O1xuICB9XG59XHJcblxyXG5hIHtcbiAgZm9udC1zaXplOiAxNXB4O1xufVxyXG5cclxuQG1lZGlhIChtaW4td2lkdGg6IDEyODBweCkge1xuXG4gIGEge1xuICAgIGZvbnQtc2l6ZTogMTZweDtcbiAgfVxufVxyXG5cclxuLnByZXZpb3VzLFxyXG4ubmV4dCB7XG4gIHN0cm9rZTogI0Y5NEY0RjtcbiAgdHJhbnNpdGlvbi1wcm9wZXJ0eTogYWxsO1xuICB0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbjogY3ViaWMtYmV6aWVyKDAuNCwgMCwgMC4yLCAxKTtcbiAgdHJhbnNpdGlvbi1kdXJhdGlvbjogMTUwbXM7XG59XHJcbi5wcmV2aW91czpob3ZlcixcclxuLm5leHQ6aG92ZXIge1xuICBzdHJva2U6ICNGRjkzOTM7XG59XHJcblxyXG4ucGFuZWwge1xyXG4gIHdpZHRoOiAxMDAlO1xyXG4gIGhlaWdodDogMTAwJTtcclxuICBkaXNwbGF5OiBmbGV4O1xyXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XHJcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XHJcbiAgZm9udC1zaXplOiAyNHB4O1xyXG59XHJcblxyXG4uaW1hZ2UtY29udGFpbmVyOmhvdmVyIHtcbiAgY3Vyc29yOiBncmFiO1xufVxyXG5cclxuLmltYWdlLWNvbnRhaW5lcjphY3RpdmUge1xuICBjdXJzb3I6IGdyYWJiaW5nO1xufVxyXG5cclxuLmltYWdlLWNvbnRhaW5lciB7XHJcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xyXG59XHJcblxyXG4uY2Fyb3VzZWxJbWFnZSB7XG4gIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICB3aWR0aDogMTAwJTtcbiAgLW8tb2JqZWN0LWZpdDogY292ZXI7XG4gICAgIG9iamVjdC1maXQ6IGNvdmVyO1xuICAtby1vYmplY3QtcG9zaXRpb246IHJpZ2h0O1xuICAgICBvYmplY3QtcG9zaXRpb246IHJpZ2h0O1xufVxyXG5cclxuQG1lZGlhIChtaW4td2lkdGg6IDc2OHB4KSB7XG5cbiAgLmNhcm91c2VsSW1hZ2Uge1xuICAgIGhlaWdodDogNDcycHg7XG4gIH1cbn1cclxuXHJcbkBtZWRpYSAobWluLXdpZHRoOiAxMjgwcHgpIHtcblxuICAuY2Fyb3VzZWxJbWFnZSB7XG4gICAgaGVpZ2h0OiAxMDAlO1xuICB9XG59XHJcblxyXG4uYW5pbWF0aW9uRWxlbWVudCB7XG4gIHRyYW5zaXRpb24tcHJvcGVydHk6IHRyYW5zZm9ybTtcbiAgdHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLjQsIDAsIDAuMiwgMSk7XG4gIHRyYW5zaXRpb24tZHVyYXRpb246IDE1MG1zO1xufVxyXG5cclxuLmFuaW1hdGlvbkVsZW1lbnQuYW5pbWF0ZVRyYW5zaXRpb24ge1xuICAtLXR3LXRyYW5zbGF0ZS15OiAwcHg7XG4gIC0tdHctc2NhbGUteDogMS4wNTtcbiAgLS10dy1zY2FsZS15OiAxLjA1O1xuICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSh2YXIoLS10dy10cmFuc2xhdGUteCksIHZhcigtLXR3LXRyYW5zbGF0ZS15KSkgcm90YXRlKHZhcigtLXR3LXJvdGF0ZSkpIHNrZXdYKHZhcigtLXR3LXNrZXcteCkpIHNrZXdZKHZhcigtLXR3LXNrZXcteSkpIHNjYWxlWCh2YXIoLS10dy1zY2FsZS14KSkgc2NhbGVZKHZhcigtLXR3LXNjYWxlLXkpKTtcbn1cclxuXHJcbi5hbmltYXRpb25FbGVtZW50IHtcbiAgdHJhbnNpdGlvbi1kdXJhdGlvbjogNTAwbXM7XG59XHJcblxyXG4uaW1hZ2UtY29udGFpbmVyOjphZnRlciB7XG4gIGhlaWdodDogMjAwcHg7XG4gIHdpZHRoOiAxMDAlO1xyXG4gIGNvbnRlbnQ6ICcnO1xyXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcclxuICBib3R0b206IDA7XHJcbiAgbGVmdDogMDtcclxuICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQodG8gYm90dG9tLCByZ2JhKDAsIDAsIDAsIDApIDAlLCByZ2JhKDAsIDAsIDAsIDAuNSkgMTAwJSk7XHJcbiAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG59XHJcblxyXG4jbW9iaWxlTmF2IHtcbiAgaGVpZ2h0OiAxOHB4O1xuICB3aWR0aDogMjRweDtcclxuICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJHtfX19DU1NfTE9BREVSX1VSTF9SRVBMQUNFTUVOVF8wX19ffSk7XG59XHJcblxyXG4jbWFzayB7XG4gIHBvaW50ZXItZXZlbnRzOiBub25lO1xufVxyXG5cclxuI21vYmlsZU5hdi5vcGVuIHtcbiAgaGVpZ2h0OiAyMHB4O1xuICB3aWR0aDogMjBweDtcclxuICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJHtfX19DU1NfTE9BREVSX1VSTF9SRVBMQUNFTUVOVF8xX19ffSk7XG59XHJcblxyXG5ib2R5OmhhcygjbW9iaWxlTmF2Lm9wZW4pICNtb2JpbGVNZW51IHtcbiAgLS10dy10cmFuc2xhdGUteDogMHB4O1xuICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSh2YXIoLS10dy10cmFuc2xhdGUteCksIHZhcigtLXR3LXRyYW5zbGF0ZS15KSkgcm90YXRlKHZhcigtLXR3LXJvdGF0ZSkpIHNrZXdYKHZhcigtLXR3LXNrZXcteCkpIHNrZXdZKHZhcigtLXR3LXNrZXcteSkpIHNjYWxlWCh2YXIoLS10dy1zY2FsZS14KSkgc2NhbGVZKHZhcigtLXR3LXNjYWxlLXkpKTtcbn1cclxuXHJcbiNtb2JpbGVNZW51IHtcclxuICB0cmFuc2l0aW9uOiBhbGwgMC41cyBlYXNlIDBzO1xyXG4gIGRpc3BsYXk6IGZsZXg7XHJcbiAgLS10dy10cmFuc2xhdGUteDogMTUwJTtcclxuICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSh2YXIoLS10dy10cmFuc2xhdGUteCksIHZhcigtLXR3LXRyYW5zbGF0ZS15KSkgcm90YXRlKHZhcigtLXR3LXJvdGF0ZSkpIHNrZXdYKHZhcigtLXR3LXNrZXcteCkpIHNrZXdZKHZhcigtLXR3LXNrZXcteSkpIHNjYWxlWCh2YXIoLS10dy1zY2FsZS14KSkgc2NhbGVZKHZhcigtLXR3LXNjYWxlLXkpKTtcclxufVxyXG5cclxuQG1lZGlhIChtaW4td2lkdGg6IDc2OHB4KSB7XG5cbiAgI21vYmlsZU1lbnUge1xuICAgIGRpc3BsYXk6IG5vbmU7XG4gIH1cbn1cclxuXHJcbkBtZWRpYSAobWF4LXdpZHRoOiA3NjhweCkge1xyXG4gIGJvZHk6aGFzKCNtb2JpbGVNZW51Lm9wZW4pICNtb2JpbGVNZW51TGlzdCB7XG4gICAgcG9pbnRlci1ldmVudHM6IGF1dG87XG4gIH1cclxuXHJcbiAgYm9keTpoYXMoI21vYmlsZU5hdi5vcGVuKSAjbWFzayB7XG4gICAgcG9pbnRlci1ldmVudHM6IGF1dG87XG4gIH1cclxuXHJcbiAgYm9keTpoYXMoI21vYmlsZU5hdi5vcGVuKSB7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBtaW4taGVpZ2h0OiAxMDB2aDtcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xuICB9XHJcbn1cclxuXHJcbi5ob3ZlclxcXFw6Y3Vyc29yLWdyYWI6aG92ZXIge1xuICBjdXJzb3I6IGdyYWI7XG59XHJcblxyXG4uaG92ZXJcXFxcOmJnLVxcXFxbXFxcXCM0MzQzNTZcXFxcXTpob3ZlciB7XG4gIC0tdHctYmctb3BhY2l0eTogMTtcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDY3IDY3IDg2IC8gdmFyKC0tdHctYmctb3BhY2l0eSkpO1xufVxyXG5cclxuLmhvdmVyXFxcXDpiZy1cXFxcW1xcXFwjRkY5MzkzXFxcXF06aG92ZXIge1xuICAtLXR3LWJnLW9wYWNpdHk6IDE7XG4gIGJhY2tncm91bmQtY29sb3I6IHJnYigyNTUgMTQ3IDE0NyAvIHZhcigtLXR3LWJnLW9wYWNpdHkpKTtcbn1cclxuXHJcbi5ob3ZlclxcXFw6Zm9udC1ib2xkOmhvdmVyIHtcbiAgZm9udC13ZWlnaHQ6IDcwMDtcbn1cclxuXHJcbi5ob3ZlclxcXFw6dGV4dC1cXFxcW1xcXFwjRkY5MzkzXFxcXF06aG92ZXIge1xuICAtLXR3LXRleHQtb3BhY2l0eTogMTtcbiAgY29sb3I6IHJnYigyNTUgMTQ3IDE0NyAvIHZhcigtLXR3LXRleHQtb3BhY2l0eSkpO1xufVxyXG5cclxuQG1lZGlhIChtaW4td2lkdGg6IDc2OHB4KSB7XG5cbiAgLm1kXFxcXDphYnNvbHV0ZSB7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICB9XG5cbiAgLm1kXFxcXDpsZWZ0LVxcXFxbLTMxcHhcXFxcXSB7XG4gICAgbGVmdDogLTMxcHg7XG4gIH1cblxuICAubWRcXFxcOnRvcC1cXFxcWzIyMHB4XFxcXF0ge1xuICAgIHRvcDogMjIwcHg7XG4gIH1cblxuICAubWRcXFxcOm1iLTAge1xuICAgIG1hcmdpbi1ib3R0b206IDBweDtcbiAgfVxuXG4gIC5tZFxcXFw6bXQtXFxcXFstMTIwcHhcXFxcXSB7XG4gICAgbWFyZ2luLXRvcDogLTEyMHB4O1xuICB9XG5cbiAgLm1kXFxcXDptdC1cXFxcWzEyMHB4XFxcXF0ge1xuICAgIG1hcmdpbi10b3A6IDEyMHB4O1xuICB9XG5cbiAgLm1kXFxcXDptdC1cXFxcWzc3cHhcXFxcXSB7XG4gICAgbWFyZ2luLXRvcDogNzdweDtcbiAgfVxuXG4gIC5tZFxcXFw6bXQtXFxcXFs3MHB4XFxcXF0ge1xuICAgIG1hcmdpbi10b3A6IDcwcHg7XG4gIH1cblxuICAubWRcXFxcOmJsb2NrIHtcbiAgICBkaXNwbGF5OiBibG9jaztcbiAgfVxuXG4gIC5tZFxcXFw6ZmxleCB7XG4gICAgZGlzcGxheTogZmxleDtcbiAgfVxuXG4gIC5tZFxcXFw6aGlkZGVuIHtcbiAgICBkaXNwbGF5OiBub25lO1xuICB9XG5cbiAgLm1kXFxcXDpoLVxcXFxbMTc4cHhcXFxcXSB7XG4gICAgaGVpZ2h0OiAxNzhweDtcbiAgfVxuXG4gIC5tZFxcXFw6aC1cXFxcWzIwMHB4XFxcXF0ge1xuICAgIGhlaWdodDogMjAwcHg7XG4gIH1cblxuICAubWRcXFxcOmgtXFxcXFszNTJweFxcXFxdIHtcbiAgICBoZWlnaHQ6IDM1MnB4O1xuICB9XG5cbiAgLm1kXFxcXDpoLVxcXFxbNDcycHhcXFxcXSB7XG4gICAgaGVpZ2h0OiA0NzJweDtcbiAgfVxuXG4gIC5tZFxcXFw6aC1cXFxcWzUzOHB4XFxcXF0ge1xuICAgIGhlaWdodDogNTM4cHg7XG4gIH1cblxuICAubWRcXFxcOmgtXFxcXFs2MDZweFxcXFxdIHtcbiAgICBoZWlnaHQ6IDYwNnB4O1xuICB9XG5cbiAgLm1kXFxcXDpoLVxcXFxbNjA4cHhcXFxcXSB7XG4gICAgaGVpZ2h0OiA2MDhweDtcbiAgfVxuXG4gIC5tZFxcXFw6aC1cXFxcWzY0OHB4XFxcXF0ge1xuICAgIGhlaWdodDogNjQ4cHg7XG4gIH1cblxuICAubWRcXFxcOmgtXFxcXFs2NThweFxcXFxdIHtcbiAgICBoZWlnaHQ6IDY1OHB4O1xuICB9XG5cbiAgLm1kXFxcXDpoLVxcXFxbNzk3cHhcXFxcXSB7XG4gICAgaGVpZ2h0OiA3OTdweDtcbiAgfVxuXG4gIC5tZFxcXFw6bWluLWgtXFxcXFs0NzJweFxcXFxdIHtcbiAgICBtaW4taGVpZ2h0OiA0NzJweDtcbiAgfVxuXG4gIC5tZFxcXFw6bWluLWgtc2NyZWVuIHtcbiAgICBtaW4taGVpZ2h0OiAxMDB2aDtcbiAgfVxuXG4gIC5tZFxcXFw6dy0xXFxcXC8yIHtcbiAgICB3aWR0aDogNTAlO1xuICB9XG5cbiAgLm1kXFxcXDp3LTNcXFxcLzUge1xuICAgIHdpZHRoOiA2MCU7XG4gIH1cblxuICAubWRcXFxcOnctXFxcXFsxNDAwcHhcXFxcXSB7XG4gICAgd2lkdGg6IDE0MDBweDtcbiAgfVxuXG4gIC5tZFxcXFw6dy1cXFxcWzM1NXB4XFxcXF0ge1xuICAgIHdpZHRoOiAzNTVweDtcbiAgfVxuXG4gIC5tZFxcXFw6dy1cXFxcWzM5MHB4XFxcXF0ge1xuICAgIHdpZHRoOiAzOTBweDtcbiAgfVxuXG4gIC5tZFxcXFw6dy1cXFxcWzczNXB4XFxcXF0ge1xuICAgIHdpZHRoOiA3MzVweDtcbiAgfVxuXG4gIC5tZFxcXFw6dy1maXQge1xuICAgIHdpZHRoOiAtbW96LWZpdC1jb250ZW50O1xuICAgIHdpZHRoOiBmaXQtY29udGVudDtcbiAgfVxuXG4gIC5tZFxcXFw6dy1mdWxsIHtcbiAgICB3aWR0aDogMTAwJTtcbiAgfVxuXG4gIC5tZFxcXFw6bWF4LXctXFxcXFsyNTBweFxcXFxdIHtcbiAgICBtYXgtd2lkdGg6IDI1MHB4O1xuICB9XG5cbiAgLm1kXFxcXDptYXgtdy1cXFxcWzI4MXB4XFxcXF0ge1xuICAgIG1heC13aWR0aDogMjgxcHg7XG4gIH1cblxuICAubWRcXFxcOm1heC13LVxcXFxbMzk4cHhcXFxcXSB7XG4gICAgbWF4LXdpZHRoOiAzOThweDtcbiAgfVxuXG4gIC5tZFxcXFw6bWF4LXctXFxcXFs3MzVweFxcXFxdIHtcbiAgICBtYXgtd2lkdGg6IDczNXB4O1xuICB9XG5cbiAgLm1kXFxcXDpmbGV4LXJvdyB7XG4gICAgZmxleC1kaXJlY3Rpb246IHJvdztcbiAgfVxuXG4gIC5tZFxcXFw6aXRlbXMtc3RhcnQge1xuICAgIGFsaWduLWl0ZW1zOiBmbGV4LXN0YXJ0O1xuICB9XG5cbiAgLm1kXFxcXDppdGVtcy1jZW50ZXIge1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gIH1cblxuICAubWRcXFxcOmp1c3RpZnktZW5kIHtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtZW5kO1xuICB9XG5cbiAgLm1kXFxcXDpnYXAtXFxcXFszOXB4XFxcXF0ge1xuICAgIGdhcDogMzlweDtcbiAgfVxuXG4gIC5tZFxcXFw6Z2FwLVxcXFxbNDhweFxcXFxdIHtcbiAgICBnYXA6IDQ4cHg7XG4gIH1cblxuICAubWRcXFxcOnNlbGYtZW5kIHtcbiAgICBhbGlnbi1zZWxmOiBmbGV4LWVuZDtcbiAgfVxuXG4gIC5tZFxcXFw6b2JqZWN0LVxcXFxbMTAwXFxcXCVfMFxcXFwlXFxcXF0ge1xuICAgIC1vLW9iamVjdC1wb3NpdGlvbjogMTAwJSAwJTtcbiAgICAgICBvYmplY3QtcG9zaXRpb246IDEwMCUgMCU7XG4gIH1cblxuICAubWRcXFxcOnB4LTAge1xuICAgIHBhZGRpbmctbGVmdDogMHB4O1xuICAgIHBhZGRpbmctcmlnaHQ6IDBweDtcbiAgfVxuXG4gIC5tZFxcXFw6cHktMCB7XG4gICAgcGFkZGluZy10b3A6IDBweDtcbiAgICBwYWRkaW5nLWJvdHRvbTogMHB4O1xuICB9XG5cbiAgLm1kXFxcXDpweC1cXFxcWzQwcHhcXFxcXSB7XG4gICAgcGFkZGluZy1sZWZ0OiA0MHB4O1xuICAgIHBhZGRpbmctcmlnaHQ6IDQwcHg7XG4gIH1cblxuICAubWRcXFxcOnBsLVxcXFxbMzlweFxcXFxdIHtcbiAgICBwYWRkaW5nLWxlZnQ6IDM5cHg7XG4gIH1cblxuICAubWRcXFxcOnBsLVxcXFxbNjlweFxcXFxdIHtcbiAgICBwYWRkaW5nLWxlZnQ6IDY5cHg7XG4gIH1cblxuICAubWRcXFxcOnByLVxcXFxbNDBweFxcXFxdIHtcbiAgICBwYWRkaW5nLXJpZ2h0OiA0MHB4O1xuICB9XG5cbiAgLm1kXFxcXDp0ZXh0LVxcXFxbNTZweFxcXFxdIHtcbiAgICBmb250LXNpemU6IDU2cHg7XG4gIH1cblxuICAubWRcXFxcOmxlYWRpbmctXFxcXFs1NnB4XFxcXF0ge1xuICAgIGxpbmUtaGVpZ2h0OiA1NnB4O1xuICB9XG5cbiAgLm1kXFxcXDpvcGFjaXR5LTAge1xuICAgIG9wYWNpdHk6IDA7XG4gIH1cbn1cclxuXHJcbkBtZWRpYSAobWluLXdpZHRoOiAxMDI0cHgpIHtcblxuICAubGdcXFxcOm10LTAge1xuICAgIG1hcmdpbi10b3A6IDBweDtcbiAgfVxuXG4gIC5sZ1xcXFw6bXQtXFxcXFstMjAwcHhcXFxcXSB7XG4gICAgbWFyZ2luLXRvcDogLTIwMHB4O1xuICB9XG5cbiAgLmxnXFxcXDpoLVxcXFxbNTYwcHhcXFxcXSB7XG4gICAgaGVpZ2h0OiA1NjBweDtcbiAgfVxuXG4gIC5sZ1xcXFw6aC1cXFxcWzc1MHB4XFxcXF0ge1xuICAgIGhlaWdodDogNzUwcHg7XG4gIH1cblxuICAubGdcXFxcOnctXFxcXFs1MzBweFxcXFxdIHtcbiAgICB3aWR0aDogNTMwcHg7XG4gIH1cblxuICAubGdcXFxcOm1heC13LVxcXFxbNTMwcHhcXFxcXSB7XG4gICAgbWF4LXdpZHRoOiA1MzBweDtcbiAgfVxuXG4gIC5sZ1xcXFw6bWF4LXctZnVsbCB7XG4gICAgbWF4LXdpZHRoOiAxMDAlO1xuICB9XG5cbiAgLmxnXFxcXDpnYXAtXFxcXFs1MHB4XFxcXF0ge1xuICAgIGdhcDogNTBweDtcbiAgfVxuXG4gIC5sZ1xcXFw6cHgtMCB7XG4gICAgcGFkZGluZy1sZWZ0OiAwcHg7XG4gICAgcGFkZGluZy1yaWdodDogMHB4O1xuICB9XG5cbiAgLmxnXFxcXDpwbC1cXFxcWzkwcHhcXFxcXSB7XG4gICAgcGFkZGluZy1sZWZ0OiA5MHB4O1xuICB9XG5cbiAgLmxnXFxcXDpwci1cXFxcWzIwcHhcXFxcXSB7XG4gICAgcGFkZGluZy1yaWdodDogMjBweDtcbiAgfVxuXG4gIC5sZ1xcXFw6cHItXFxcXFs2MHB4XFxcXF0ge1xuICAgIHBhZGRpbmctcmlnaHQ6IDYwcHg7XG4gIH1cbn1cclxuXHJcbkBtZWRpYSAobWluLXdpZHRoOiAxMjgwcHgpIHtcblxuICAueGxcXFxcOmJvdHRvbS1cXFxcWzY4cHhcXFxcXSB7XG4gICAgYm90dG9tOiA2OHB4O1xuICB9XG5cbiAgLnhsXFxcXDpsZWZ0LVxcXFxbLTY3cHhcXFxcXSB7XG4gICAgbGVmdDogLTY3cHg7XG4gIH1cblxuICAueGxcXFxcOnJpZ2h0LVxcXFxbLTY3cHhcXFxcXSB7XG4gICAgcmlnaHQ6IC02N3B4O1xuICB9XG5cbiAgLnhsXFxcXDpyaWdodC1cXFxcWzE1NHB4XFxcXF0ge1xuICAgIHJpZ2h0OiAxNTRweDtcbiAgfVxuXG4gIC54bFxcXFw6dG9wLVxcXFxbMTg2cHhcXFxcXSB7XG4gICAgdG9wOiAxODZweDtcbiAgfVxuXG4gIC54bFxcXFw6dG9wLVxcXFxbMjM0cHhcXFxcXSB7XG4gICAgdG9wOiAyMzRweDtcbiAgfVxuXG4gIC54bFxcXFw6bWItXFxcXFsxMTVweFxcXFxdIHtcbiAgICBtYXJnaW4tYm90dG9tOiAxMTVweDtcbiAgfVxuXG4gIC54bFxcXFw6bWwtXFxcXFstNjdweFxcXFxdIHtcbiAgICBtYXJnaW4tbGVmdDogLTY3cHg7XG4gIH1cblxuICAueGxcXFxcOm1sLVxcXFxbOThweFxcXFxdIHtcbiAgICBtYXJnaW4tbGVmdDogOThweDtcbiAgfVxuXG4gIC54bFxcXFw6bXItXFxcXFstMTYwcHhcXFxcXSB7XG4gICAgbWFyZ2luLXJpZ2h0OiAtMTYwcHg7XG4gIH1cblxuICAueGxcXFxcOm10LVxcXFxbMTEycHhcXFxcXSB7XG4gICAgbWFyZ2luLXRvcDogMTEycHg7XG4gIH1cblxuICAueGxcXFxcOm10LVxcXFxbMTIwcHhcXFxcXSB7XG4gICAgbWFyZ2luLXRvcDogMTIwcHg7XG4gIH1cblxuICAueGxcXFxcOm10LVxcXFxbMjAwcHhcXFxcXSB7XG4gICAgbWFyZ2luLXRvcDogMjAwcHg7XG4gIH1cblxuICAueGxcXFxcOmJsb2NrIHtcbiAgICBkaXNwbGF5OiBibG9jaztcbiAgfVxuXG4gIC54bFxcXFw6aC1cXFxcWzExMDBweFxcXFxdIHtcbiAgICBoZWlnaHQ6IDExMDBweDtcbiAgfVxuXG4gIC54bFxcXFw6aC1cXFxcWzUyOHB4XFxcXF0ge1xuICAgIGhlaWdodDogNTI4cHg7XG4gIH1cblxuICAueGxcXFxcOmgtXFxcXFs2MHB4XFxcXF0ge1xuICAgIGhlaWdodDogNjBweDtcbiAgfVxuXG4gIC54bFxcXFw6aC1cXFxcWzYxcHhcXFxcXSB7XG4gICAgaGVpZ2h0OiA2MXB4O1xuICB9XG5cbiAgLnhsXFxcXDpoLVxcXFxbNzI4cHhcXFxcXSB7XG4gICAgaGVpZ2h0OiA3MjhweDtcbiAgfVxuXG4gIC54bFxcXFw6aC1cXFxcWzc4NHB4XFxcXF0ge1xuICAgIGhlaWdodDogNzg0cHg7XG4gIH1cblxuICAueGxcXFxcOmgtXFxcXFs4MDBweFxcXFxdIHtcbiAgICBoZWlnaHQ6IDgwMHB4O1xuICB9XG5cbiAgLnhsXFxcXDpoLVxcXFxbOTg0cHhcXFxcXSB7XG4gICAgaGVpZ2h0OiA5ODRweDtcbiAgfVxuXG4gIC54bFxcXFw6bWluLWgtXFxcXFs3MjhweFxcXFxdIHtcbiAgICBtaW4taGVpZ2h0OiA3MjhweDtcbiAgfVxuXG4gIC54bFxcXFw6dy1cXFxcWzEzNHB4XFxcXF0ge1xuICAgIHdpZHRoOiAxMzRweDtcbiAgfVxuXG4gIC54bFxcXFw6dy1cXFxcWzEzNXB4XFxcXF0ge1xuICAgIHdpZHRoOiAxMzVweDtcbiAgfVxuXG4gIC54bFxcXFw6dy1cXFxcWzQ0NXB4XFxcXF0ge1xuICAgIHdpZHRoOiA0NDVweDtcbiAgfVxuXG4gIC54bFxcXFw6dy1cXFxcWzUwNHB4XFxcXF0ge1xuICAgIHdpZHRoOiA1MDRweDtcbiAgfVxuXG4gIC54bFxcXFw6dy1cXFxcWzcwNXB4XFxcXF0ge1xuICAgIHdpZHRoOiA3MDVweDtcbiAgfVxuXG4gIC54bFxcXFw6dy1cXFxcWzg5NXB4XFxcXF0ge1xuICAgIHdpZHRoOiA4OTVweDtcbiAgfVxuXG4gIC54bFxcXFw6dy1maXQge1xuICAgIHdpZHRoOiAtbW96LWZpdC1jb250ZW50O1xuICAgIHdpZHRoOiBmaXQtY29udGVudDtcbiAgfVxuXG4gIC54bFxcXFw6bWluLXctXFxcXFsxOTlweFxcXFxdIHtcbiAgICBtaW4td2lkdGg6IDE5OXB4O1xuICB9XG5cbiAgLnhsXFxcXDptYXgtdy1cXFxcWzIyNXB4XFxcXF0ge1xuICAgIG1heC13aWR0aDogMjI1cHg7XG4gIH1cblxuICAueGxcXFxcOm1heC13LVxcXFxbNDd2d1xcXFxdIHtcbiAgICBtYXgtd2lkdGg6IDQ3dnc7XG4gIH1cblxuICAueGxcXFxcOm1heC13LVxcXFxbNTQwcHhcXFxcXSB7XG4gICAgbWF4LXdpZHRoOiA1NDBweDtcbiAgfVxuXG4gIC54bFxcXFw6bWF4LXctXFxcXFs2MzVweFxcXFxdIHtcbiAgICBtYXgtd2lkdGg6IDYzNXB4O1xuICB9XG5cbiAgLnhsXFxcXDptYXgtdy1cXFxcWzY4MHB4XFxcXF0ge1xuICAgIG1heC13aWR0aDogNjgwcHg7XG4gIH1cblxuICAueGxcXFxcOm1heC13LWZ1bGwge1xuICAgIG1heC13aWR0aDogMTAwJTtcbiAgfVxuXG4gIC54bFxcXFw6anVzdGlmeS1lbmQge1xuICAgIGp1c3RpZnktY29udGVudDogZmxleC1lbmQ7XG4gIH1cblxuICAueGxcXFxcOmdhcC1cXFxcWzQzcHhcXFxcXSB7XG4gICAgZ2FwOiA0M3B4O1xuICB9XG5cbiAgLnhsXFxcXDpnYXAtXFxcXFs0OHB4XFxcXF0ge1xuICAgIGdhcDogNDhweDtcbiAgfVxuXG4gIC54bFxcXFw6Z2FwLVxcXFxbNTZweFxcXFxdIHtcbiAgICBnYXA6IDU2cHg7XG4gIH1cblxuICAueGxcXFxcOm9iamVjdC1jZW50ZXIge1xuICAgIC1vLW9iamVjdC1wb3NpdGlvbjogY2VudGVyO1xuICAgICAgIG9iamVjdC1wb3NpdGlvbjogY2VudGVyO1xuICB9XG5cbiAgLnhsXFxcXDpweC0wIHtcbiAgICBwYWRkaW5nLWxlZnQ6IDBweDtcbiAgICBwYWRkaW5nLXJpZ2h0OiAwcHg7XG4gIH1cblxuICAueGxcXFxcOnBsLTAge1xuICAgIHBhZGRpbmctbGVmdDogMHB4O1xuICB9XG5cbiAgLnhsXFxcXDpwbC1cXFxcWzE1NHB4XFxcXF0ge1xuICAgIHBhZGRpbmctbGVmdDogMTU0cHg7XG4gIH1cblxuICAueGxcXFxcOnBsLVxcXFxbMzlweFxcXFxdIHtcbiAgICBwYWRkaW5nLWxlZnQ6IDM5cHg7XG4gIH1cblxuICAueGxcXFxcOnBsLVxcXFxbNjlweFxcXFxdIHtcbiAgICBwYWRkaW5nLWxlZnQ6IDY5cHg7XG4gIH1cblxuICAueGxcXFxcOnByLTAge1xuICAgIHBhZGRpbmctcmlnaHQ6IDBweDtcbiAgfVxuXG4gIC54bFxcXFw6cHItXFxcXFsxMDZweFxcXFxdIHtcbiAgICBwYWRkaW5nLXJpZ2h0OiAxMDZweDtcbiAgfVxuXG4gIC54bFxcXFw6dGV4dC1cXFxcWzE2cHhcXFxcXSB7XG4gICAgZm9udC1zaXplOiAxNnB4O1xuICB9XG5cbiAgLnhsXFxcXDp0ZXh0LVxcXFxbMThweFxcXFxdIHtcbiAgICBmb250LXNpemU6IDE4cHg7XG4gIH1cblxuICAueGxcXFxcOnRleHQtXFxcXFsyMHB4XFxcXF0ge1xuICAgIGZvbnQtc2l6ZTogMjBweDtcbiAgfVxuXG4gIC54bFxcXFw6dGV4dC1cXFxcWzU2cHhcXFxcXSB7XG4gICAgZm9udC1zaXplOiA1NnB4O1xuICB9XG5cbiAgLnhsXFxcXDp0ZXh0LVxcXFxbODBweFxcXFxdIHtcbiAgICBmb250LXNpemU6IDgwcHg7XG4gIH1cblxuICAueGxcXFxcOmxlYWRpbmctXFxcXFszMnB4XFxcXF0ge1xuICAgIGxpbmUtaGVpZ2h0OiAzMnB4O1xuICB9XG5cbiAgLnhsXFxcXDpsZWFkaW5nLVxcXFxbNjRweFxcXFxdIHtcbiAgICBsaW5lLWhlaWdodDogNjRweDtcbiAgfVxuXG4gIC54bFxcXFw6bGVhZGluZy1cXFxcWzg4cHhcXFxcXSB7XG4gICAgbGluZS1oZWlnaHQ6IDg4cHg7XG4gIH1cbn1cclxuXHJcbkBtZWRpYSAobWluLXdpZHRoOiAxNTAwcHgpIHtcblxuICAuc2NyZWVuMTUwMFxcXFw6bWF4LXctXFxcXFs3MDVweFxcXFxdIHtcbiAgICBtYXgtd2lkdGg6IDcwNXB4O1xuICB9XG59XHJcbmAsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazov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QUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBLGlCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUEsV0FBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxXQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBLHdCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQSx1QkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBLHNCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLHFCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLGtCQUFtQjtFQUFuQixrQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQSxrQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxrQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxrQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUEsc0JBQW1CO0tBQW5CO0FBQW1CO0FBQW5CO0VBQUEsb0JBQW1CO0tBQW5CO0FBQW1CO0FBQW5CO0VBQUEsbUJBQW1CO0tBQW5CO0FBQW1CO0FBQW5CO0VBQUEseUJBQW1CO0tBQW5CO0FBQW1CO0FBQW5CO0VBQUEsMEJBQW1CO0tBQW5CO0FBQW1CO0FBQW5CO0VBQUEsMEJBQW1CO0tBQW5CO0FBQW1CO0FBQW5CO0VBQUEseUJBQW1CO0tBQW5CO0FBQW1CO0FBQW5CO0VBQUEsdUJBQW1CO0tBQW5CO0FBQW1CO0FBQW5CO0VBQUEsaUJBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsa0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsa0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsZ0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsaUJBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFB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OztFQTdHQTtJQUFBO0VBNkdBOztFQTdHQTtJQUFBO0VBNkdBOztFQTdHQTtJQUFBO0VBNkdBOztFQTdHQTtJQUFBO0VBNkdBOztFQTdHQTtJQUFBO0VBNkdBOztFQTdHQTtJQUFBO0VBNkdBOztFQTdHQTtJQUFBO0VBNkdBOztFQTdHQTtJQUFBO0VBNkdBOztFQTdHQTtJQUFBO0VBNkdBOztFQTdHQTtJQUFBO0VBNkdBOztFQTdHQTtJQUFBO0VBNkdBOztFQTdHQTtJQUFBO0VBNkdBOztFQTdHQTtJQUFBO0VBNkdBOztFQTdHQTtJQUFBO0VBNkdBOztFQTdHQTtJQUFBO0VBNkdBOztFQTdHQTtJQUFBO0VBNkdBOztFQTdHQTtJQUFBO0VBNkdBOztFQTdHQTtJQUFBO0VBNkdBOztFQTdHQTtJQUFBO0VBNkdBOztFQTdHQTtJQUFBO0VBNkdBOztFQTdHQTtJQUFBO0VBNkdBOztFQTdHQTtJQUFBO0VBNkdBOztFQTdHQTtJQUFBO0VBNkdBOztFQTdHQTtJQUFBO0VBNkdBOztFQTdHQTtJQUFBO0VBNkdBOztFQTdHQTtJQUFBLHVCQTZHQTtJQTdHQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQSwyQkE2R0E7T0E3R0E7RUE2R0E7O0VBN0dBO0lBQUEsaUJBNkdBO0lBN0dBO0VBNkdBOztFQTdHQTtJQUFBLGdCQTZHQTtJQTdHQTtFQTZHQTs7RUE3R0E7SUFBQSxrQkE2R0E7SUE3R0E7RUE2R0E7O0VBN0dBO0lBQUE7RUE2R0E7O0VBN0dBO0lBQUE7RUE2R0E7O0VBN0dBO0lBQUE7RUE2R0E7O0VBN0dBO0lBQUE7RUE2R0E7O0VBN0dBO0lBQUE7RUE2R0E7O0VBN0dBO0lBQUE7RUE2R0E7QUFBQTs7QUE3R0E7O0VBQUE7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQSxpQkE2R0E7SUE3R0E7RUE2R0E7O0VBN0dBO0lBQUE7RUE2R0E7O0VBN0dBO0lBQUE7RUE2R0E7O0VBN0dBO0lBQUE7RUE2R0E7QUFBQTs7QUE3R0E7O0VBQUE7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQSx1QkE2R0E7SUE3R0E7RUE2R0E7O0VBN0dBO0lBQUE7RUE2R0E7O0VBN0dBO0lBQUE7RUE2R0E7O0VBN0dBO0lBQUE7RUE2R0E7O0VBN0dBO0lBQUE7RUE2R0E7O0VBN0dBO0lBQUE7RUE2R0E7O0VBN0dBO0lBQUE7RUE2R0E7O0VBN0dBO0lBQUE7RUE2R0E7O0VBN0dBO0lBQUE7RUE2R0E7O0VBN0dBO0lBQUE7RUE2R0E7O0VBN0dBO0lBQUE7RUE2R0E7O0VBN0dBO0lBQUE7RUE2R0E7O0VBN0dBO0lBQUEsMEJBNkdBO09BN0dBO0VBNkdBOztFQTdHQTtJQUFBLGlCQTZHQTtJQTdHQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTtBQUFBOztBQTdHQTs7RUFBQTtJQUFBO0VBNkdBO0FBQUFcIixcInNvdXJjZXNDb250ZW50XCI6W1wiQHRhaWx3aW5kIGJhc2U7XFxyXFxuQHRhaWx3aW5kIGNvbXBvbmVudHM7XFxyXFxuQHRhaWx3aW5kIHV0aWxpdGllcztcXHJcXG5cXHJcXG5oMSB7XFxyXFxuICBAYXBwbHkgdGV4dC1bNDBweF0gZm9udC1leHRyYWJvbGQgbGVhZGluZy1bNDBweF0gbWQ6dGV4dC1bNTZweF0gbWQ6bGVhZGluZy1bNTZweF0geGw6dGV4dC1bODBweF0geGw6bGVhZGluZy1bODhweF07XFxyXFxufVxcclxcblxcclxcbmgyIHtcXHJcXG4gIEBhcHBseSB0ZXh0LVszMnB4XSBmb250LWV4dHJhYm9sZCBsZWFkaW5nLVs0MHB4XSB4bDp0ZXh0LVs1NnB4XSB4bDpsZWFkaW5nLVs2NHB4XTtcXHJcXG59XFxyXFxuXFxyXFxuaDMge1xcclxcbiAgQGFwcGx5IHRleHQtWzE1cHhdIGZvbnQtZXh0cmFib2xkIGxlYWRpbmctWzIwcHhdIHhsOnRleHQtWzIwcHhdIHhsOmxlYWRpbmctWzMycHhdO1xcclxcbn1cXHJcXG5cXHJcXG5wIHtcXHJcXG4gIEBhcHBseSB0ZXh0LVsxNXB4XSBsZWFkaW5nLVsyNXB4XSB4bDp0ZXh0LVsxOHB4XSB4bDpsZWFkaW5nLVszMnB4XTtcXHJcXG59XFxyXFxuXFxyXFxuYSB7XFxyXFxuICBAYXBwbHkgdGV4dC1bMTVweF0geGw6dGV4dC1bMTZweF07XFxyXFxufVxcclxcblxcclxcbi5wcmV2aW91cyxcXHJcXG4ubmV4dCB7XFxyXFxuICBAYXBwbHkgc3Ryb2tlLVsjRjk0RjRGXSB0cmFuc2l0aW9uLWFsbDtcXHJcXG59XFxyXFxuLnByZXZpb3VzOmhvdmVyLFxcclxcbi5uZXh0OmhvdmVyIHtcXHJcXG4gIEBhcHBseSBzdHJva2UtWyNGRjkzOTNdO1xcclxcbn1cXHJcXG5cXHJcXG4ucGFuZWwge1xcclxcbiAgd2lkdGg6IDEwMCU7XFxyXFxuICBoZWlnaHQ6IDEwMCU7XFxyXFxuICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXHJcXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcclxcbiAgZm9udC1zaXplOiAyNHB4O1xcclxcbn1cXHJcXG5cXHJcXG4uaW1hZ2UtY29udGFpbmVyIHtcXHJcXG4gIEBhcHBseSBob3ZlcjpjdXJzb3ItZ3JhYiBhY3RpdmU6Y3Vyc29yLWdyYWJiaW5nO1xcclxcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcclxcbn1cXHJcXG5cXHJcXG4uY2Fyb3VzZWxJbWFnZSB7XFxyXFxuICBAYXBwbHkgcG9pbnRlci1ldmVudHMtbm9uZSB3LWZ1bGwgb2JqZWN0LWNvdmVyIG9iamVjdC1yaWdodCBtZDpoLVs0NzJweF0geGw6aC1mdWxsO1xcclxcbn1cXHJcXG5cXHJcXG4uYW5pbWF0aW9uRWxlbWVudCB7XFxyXFxuICBAYXBwbHkgdHJhbnNpdGlvbi10cmFuc2Zvcm07XFxyXFxufVxcclxcblxcclxcbi5hbmltYXRpb25FbGVtZW50LmFuaW1hdGVUcmFuc2l0aW9uIHtcXHJcXG4gIEBhcHBseSB0cmFuc2xhdGUteS1bMHB4XSBzY2FsZS0xMDUgdHJhbnNmb3JtO1xcclxcbn1cXHJcXG5cXHJcXG4uYW5pbWF0aW9uRWxlbWVudCB7XFxyXFxuICBAYXBwbHkgZHVyYXRpb24tNTAwO1xcclxcbn1cXHJcXG5cXHJcXG4uaW1hZ2UtY29udGFpbmVyOjphZnRlciB7XFxyXFxuICBAYXBwbHkgaC1bMjAwcHhdIHctZnVsbDtcXHJcXG4gIGNvbnRlbnQ6ICcnO1xcclxcbiAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbiAgYm90dG9tOiAwO1xcclxcbiAgbGVmdDogMDtcXHJcXG4gIGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudCh0byBib3R0b20sIHJnYmEoMCwgMCwgMCwgMCkgMCUsIHJnYmEoMCwgMCwgMCwgMC41KSAxMDAlKTtcXHJcXG4gIHBvaW50ZXItZXZlbnRzOiBub25lO1xcclxcbn1cXHJcXG5cXHJcXG4jbW9iaWxlTmF2IHtcXHJcXG4gIEBhcHBseSBoLVsxOHB4XSB3LVsyNHB4XTtcXHJcXG4gIGJhY2tncm91bmQtaW1hZ2U6IHVybCgnLi4vYXNzZXRzL21vYmlsZS9pY29uLWhhbWJ1cmdlci5zdmcnKTtcXHJcXG59XFxyXFxuXFxyXFxuI21hc2sge1xcclxcbiAgQGFwcGx5IHBvaW50ZXItZXZlbnRzLW5vbmU7XFxyXFxufVxcclxcblxcclxcbiNtb2JpbGVOYXYub3BlbiB7XFxyXFxuICBAYXBwbHkgaC1bMjBweF0gdy1bMjBweF07XFxyXFxuICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJy4uL2Fzc2V0cy9tb2JpbGUvaWNvbi1jcm9zcy5zdmcnKTtcXHJcXG59XFxyXFxuXFxyXFxuYm9keTpoYXMoI21vYmlsZU5hdi5vcGVuKSAjbW9iaWxlTWVudSB7XFxyXFxuICBAYXBwbHkgdHJhbnNsYXRlLXgtMDtcXHJcXG59XFxyXFxuXFxyXFxuI21vYmlsZU1lbnUge1xcclxcbiAgdHJhbnNpdGlvbjogYWxsIDAuNXMgZWFzZSAwcztcXHJcXG4gIEBhcHBseSBmbGV4IHRyYW5zbGF0ZS14LVsxNTAlXSBtZDpoaWRkZW47XFxyXFxufVxcclxcblxcclxcbkBtZWRpYSAobWF4LXdpZHRoOiA3NjhweCkge1xcclxcbiAgYm9keTpoYXMoI21vYmlsZU1lbnUub3BlbikgI21vYmlsZU1lbnVMaXN0IHtcXHJcXG4gICAgQGFwcGx5IHBvaW50ZXItZXZlbnRzLWF1dG87XFxyXFxuICB9XFxyXFxuXFxyXFxuICBib2R5OmhhcygjbW9iaWxlTmF2Lm9wZW4pICNtYXNrIHtcXHJcXG4gICAgQGFwcGx5IHBvaW50ZXItZXZlbnRzLWF1dG87XFxyXFxuICB9XFxyXFxuXFxyXFxuICBib2R5OmhhcygjbW9iaWxlTmF2Lm9wZW4pIHtcXHJcXG4gICAgQGFwcGx5IGZsZXggbWluLWgtc2NyZWVuIG92ZXJmbG93LWhpZGRlbjtcXHJcXG4gIH1cXHJcXG59XFxyXFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiIsIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fIGZyb20gXCIuLi8uLi8uLi9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9zb3VyY2VNYXBzLmpzXCI7XG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fIGZyb20gXCIuLi8uLi8uLi9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIjtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBgLmZsaWNraW5nLXZpZXdwb3J0IHtcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xuICBvdmVyZmxvdzogaGlkZGVuO1xufVxuXG4uZmxpY2tpbmctdmlld3BvcnQudmVydGljYWwge1xuICBkaXNwbGF5OiBpbmxpbmUtZmxleDtcbn1cblxuLmZsaWNraW5nLXZpZXdwb3J0LnZlcnRpY2FsID4gLmZsaWNraW5nLWNhbWVyYSB7XG4gIGRpc3BsYXk6IGlubGluZS1mbGV4O1xuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xufVxuXG4uZmxpY2tpbmctdmlld3BvcnQuZmxpY2tpbmctaGlkZGVuID4gLmZsaWNraW5nLWNhbWVyYSA+ICoge1xuICB2aXNpYmlsaXR5OiBoaWRkZW47XG59XG5cbi5mbGlja2luZy1jYW1lcmEge1xuICB3aWR0aDogMTAwJTtcbiAgaGVpZ2h0OiAxMDAlO1xuICBkaXNwbGF5OiBmbGV4O1xuICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gIGZsZXgtZGlyZWN0aW9uOiByb3c7XG4gIHotaW5kZXg6IDE7XG4gIHdpbGwtY2hhbmdlOiB0cmFuc2Zvcm07XG59XG5cbi5mbGlja2luZy1jYW1lcmEgPiAqIHtcbiAgZmxleC1zaHJpbms6IDA7XG59XG5gLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly8uL25vZGVfbW9kdWxlcy9AZWdqcy9wcmVhY3QtZmxpY2tpbmcvZGlzdC9mbGlja2luZy5jc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUE7RUFDRSxrQkFBa0I7RUFDbEIsZ0JBQWdCO0FBQ2xCOztBQUVBO0VBR0Usb0JBQW9CO0FBQ3RCOztBQUVBO0VBR0Usb0JBQW9CO0VBSVosc0JBQXNCO0FBQ2hDOztBQUVBO0VBQ0Usa0JBQWtCO0FBQ3BCOztBQUVBO0VBQ0UsV0FBVztFQUNYLFlBQVk7RUFHWixhQUFhO0VBQ2Isa0JBQWtCO0VBSVYsbUJBQW1CO0VBQzNCLFVBQVU7RUFDVixzQkFBc0I7QUFDeEI7O0FBRUE7RUFFTSxjQUFjO0FBQ3BCXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIi5mbGlja2luZy12aWV3cG9ydCB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBvdmVyZmxvdzogaGlkZGVuO1xcbn1cXG5cXG4uZmxpY2tpbmctdmlld3BvcnQudmVydGljYWwge1xcbiAgZGlzcGxheTogLXdlYmtpdC1pbmxpbmUtYm94O1xcbiAgZGlzcGxheTogLW1zLWlubGluZS1mbGV4Ym94O1xcbiAgZGlzcGxheTogaW5saW5lLWZsZXg7XFxufVxcblxcbi5mbGlja2luZy12aWV3cG9ydC52ZXJ0aWNhbCA+IC5mbGlja2luZy1jYW1lcmEge1xcbiAgZGlzcGxheTogLXdlYmtpdC1pbmxpbmUtYm94O1xcbiAgZGlzcGxheTogLW1zLWlubGluZS1mbGV4Ym94O1xcbiAgZGlzcGxheTogaW5saW5lLWZsZXg7XFxuICAtd2Via2l0LWJveC1vcmllbnQ6IHZlcnRpY2FsO1xcbiAgLXdlYmtpdC1ib3gtZGlyZWN0aW9uOiBub3JtYWw7XFxuICAgICAgLW1zLWZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICAgICAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxufVxcblxcbi5mbGlja2luZy12aWV3cG9ydC5mbGlja2luZy1oaWRkZW4gPiAuZmxpY2tpbmctY2FtZXJhID4gKiB7XFxuICB2aXNpYmlsaXR5OiBoaWRkZW47XFxufVxcblxcbi5mbGlja2luZy1jYW1lcmEge1xcbiAgd2lkdGg6IDEwMCU7XFxuICBoZWlnaHQ6IDEwMCU7XFxuICBkaXNwbGF5OiAtd2Via2l0LWJveDtcXG4gIGRpc3BsYXk6IC1tcy1mbGV4Ym94O1xcbiAgZGlzcGxheTogZmxleDtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIC13ZWJraXQtYm94LW9yaWVudDogaG9yaXpvbnRhbDtcXG4gIC13ZWJraXQtYm94LWRpcmVjdGlvbjogbm9ybWFsO1xcbiAgICAgIC1tcy1mbGV4LWRpcmVjdGlvbjogcm93O1xcbiAgICAgICAgICBmbGV4LWRpcmVjdGlvbjogcm93O1xcbiAgei1pbmRleDogMTtcXG4gIHdpbGwtY2hhbmdlOiB0cmFuc2Zvcm07XFxufVxcblxcbi5mbGlja2luZy1jYW1lcmEgPiAqIHtcXG4gIC1tcy1mbGV4LW5lZ2F0aXZlOiAwO1xcbiAgICAgIGZsZXgtc2hyaW5rOiAwO1xcbn1cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qXG4gIE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gIEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKSB7XG4gIHZhciBsaXN0ID0gW107XG5cbiAgLy8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuICBsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICB2YXIgY29udGVudCA9IFwiXCI7XG4gICAgICB2YXIgbmVlZExheWVyID0gdHlwZW9mIGl0ZW1bNV0gIT09IFwidW5kZWZpbmVkXCI7XG4gICAgICBpZiAoaXRlbVs0XSkge1xuICAgICAgICBjb250ZW50ICs9IFwiQHN1cHBvcnRzIChcIi5jb25jYXQoaXRlbVs0XSwgXCIpIHtcIik7XG4gICAgICB9XG4gICAgICBpZiAoaXRlbVsyXSkge1xuICAgICAgICBjb250ZW50ICs9IFwiQG1lZGlhIFwiLmNvbmNhdChpdGVtWzJdLCBcIiB7XCIpO1xuICAgICAgfVxuICAgICAgaWYgKG5lZWRMYXllcikge1xuICAgICAgICBjb250ZW50ICs9IFwiQGxheWVyXCIuY29uY2F0KGl0ZW1bNV0ubGVuZ3RoID4gMCA/IFwiIFwiLmNvbmNhdChpdGVtWzVdKSA6IFwiXCIsIFwiIHtcIik7XG4gICAgICB9XG4gICAgICBjb250ZW50ICs9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSk7XG4gICAgICBpZiAobmVlZExheWVyKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJ9XCI7XG4gICAgICB9XG4gICAgICBpZiAoaXRlbVsyXSkge1xuICAgICAgICBjb250ZW50ICs9IFwifVwiO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZW1bNF0pIHtcbiAgICAgICAgY29udGVudCArPSBcIn1cIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH0pLmpvaW4oXCJcIik7XG4gIH07XG5cbiAgLy8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3RcbiAgbGlzdC5pID0gZnVuY3Rpb24gaShtb2R1bGVzLCBtZWRpYSwgZGVkdXBlLCBzdXBwb3J0cywgbGF5ZXIpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsIHVuZGVmaW5lZF1dO1xuICAgIH1cbiAgICB2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xuICAgIGlmIChkZWR1cGUpIHtcbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdGhpcy5sZW5ndGg7IGsrKykge1xuICAgICAgICB2YXIgaWQgPSB0aGlzW2tdWzBdO1xuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBfayA9IDA7IF9rIDwgbW9kdWxlcy5sZW5ndGg7IF9rKyspIHtcbiAgICAgIHZhciBpdGVtID0gW10uY29uY2F0KG1vZHVsZXNbX2tdKTtcbiAgICAgIGlmIChkZWR1cGUgJiYgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgbGF5ZXIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVtWzVdID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgaXRlbVs1XSA9IGxheWVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1bMV0gPSBcIkBsYXllclwiLmNvbmNhdChpdGVtWzVdLmxlbmd0aCA+IDAgPyBcIiBcIi5jb25jYXQoaXRlbVs1XSkgOiBcIlwiLCBcIiB7XCIpLmNvbmNhdChpdGVtWzFdLCBcIn1cIik7XG4gICAgICAgICAgaXRlbVs1XSA9IGxheWVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobWVkaWEpIHtcbiAgICAgICAgaWYgKCFpdGVtWzJdKSB7XG4gICAgICAgICAgaXRlbVsyXSA9IG1lZGlhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1bMV0gPSBcIkBtZWRpYSBcIi5jb25jYXQoaXRlbVsyXSwgXCIge1wiKS5jb25jYXQoaXRlbVsxXSwgXCJ9XCIpO1xuICAgICAgICAgIGl0ZW1bMl0gPSBtZWRpYTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHN1cHBvcnRzKSB7XG4gICAgICAgIGlmICghaXRlbVs0XSkge1xuICAgICAgICAgIGl0ZW1bNF0gPSBcIlwiLmNvbmNhdChzdXBwb3J0cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbVsxXSA9IFwiQHN1cHBvcnRzIChcIi5jb25jYXQoaXRlbVs0XSwgXCIpIHtcIikuY29uY2F0KGl0ZW1bMV0sIFwifVwiKTtcbiAgICAgICAgICBpdGVtWzRdID0gc3VwcG9ydHM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxpc3QucHVzaChpdGVtKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBsaXN0O1xufTsiLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7XG4gIGlmICghb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBpZiAoIXVybCkge1xuICAgIHJldHVybiB1cmw7XG4gIH1cbiAgdXJsID0gU3RyaW5nKHVybC5fX2VzTW9kdWxlID8gdXJsLmRlZmF1bHQgOiB1cmwpO1xuXG4gIC8vIElmIHVybCBpcyBhbHJlYWR5IHdyYXBwZWQgaW4gcXVvdGVzLCByZW1vdmUgdGhlbVxuICBpZiAoL15bJ1wiXS4qWydcIl0kLy50ZXN0KHVybCkpIHtcbiAgICB1cmwgPSB1cmwuc2xpY2UoMSwgLTEpO1xuICB9XG4gIGlmIChvcHRpb25zLmhhc2gpIHtcbiAgICB1cmwgKz0gb3B0aW9ucy5oYXNoO1xuICB9XG5cbiAgLy8gU2hvdWxkIHVybCBiZSB3cmFwcGVkP1xuICAvLyBTZWUgaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzcy12YWx1ZXMtMy8jdXJsc1xuICBpZiAoL1tcIicoKSBcXHRcXG5dfCglMjApLy50ZXN0KHVybCkgfHwgb3B0aW9ucy5uZWVkUXVvdGVzKSB7XG4gICAgcmV0dXJuIFwiXFxcIlwiLmNvbmNhdCh1cmwucmVwbGFjZSgvXCIvZywgJ1xcXFxcIicpLnJlcGxhY2UoL1xcbi9nLCBcIlxcXFxuXCIpLCBcIlxcXCJcIik7XG4gIH1cbiAgcmV0dXJuIHVybDtcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgdmFyIGNvbnRlbnQgPSBpdGVtWzFdO1xuICB2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG4gIGlmICghY3NzTWFwcGluZykge1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG4gIGlmICh0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdmFyIGJhc2U2NCA9IGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KGNzc01hcHBpbmcpKSkpO1xuICAgIHZhciBkYXRhID0gXCJzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxcIi5jb25jYXQoYmFzZTY0KTtcbiAgICB2YXIgc291cmNlTWFwcGluZyA9IFwiLyojIFwiLmNvbmNhdChkYXRhLCBcIiAqL1wiKTtcbiAgICByZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChbc291cmNlTWFwcGluZ10pLmpvaW4oXCJcXG5cIik7XG4gIH1cbiAgcmV0dXJuIFtjb250ZW50XS5qb2luKFwiXFxuXCIpO1xufTsiLCJ2YXIgbixsLHUsdCxpLG8scixmLGUsYyxzLGEsaD17fSxwPVtdLHY9L2FjaXR8ZXgoPzpzfGd8bnxwfCQpfHJwaHxncmlkfG93c3xtbmN8bnR3fGluZVtjaF18em9vfF5vcmR8aXRlcmEvaSx5PUFycmF5LmlzQXJyYXk7ZnVuY3Rpb24gZChuLGwpe2Zvcih2YXIgdSBpbiBsKW5bdV09bFt1XTtyZXR1cm4gbn1mdW5jdGlvbiB3KG4pe3ZhciBsPW4ucGFyZW50Tm9kZTtsJiZsLnJlbW92ZUNoaWxkKG4pfWZ1bmN0aW9uIF8obCx1LHQpe3ZhciBpLG8scixmPXt9O2ZvcihyIGluIHUpXCJrZXlcIj09cj9pPXVbcl06XCJyZWZcIj09cj9vPXVbcl06ZltyXT11W3JdO2lmKGFyZ3VtZW50cy5sZW5ndGg+MiYmKGYuY2hpbGRyZW49YXJndW1lbnRzLmxlbmd0aD4zP24uY2FsbChhcmd1bWVudHMsMik6dCksXCJmdW5jdGlvblwiPT10eXBlb2YgbCYmbnVsbCE9bC5kZWZhdWx0UHJvcHMpZm9yKHIgaW4gbC5kZWZhdWx0UHJvcHMpdm9pZCAwPT09ZltyXSYmKGZbcl09bC5kZWZhdWx0UHJvcHNbcl0pO3JldHVybiBnKGwsZixpLG8sbnVsbCl9ZnVuY3Rpb24gZyhuLHQsaSxvLHIpe3ZhciBmPXt0eXBlOm4scHJvcHM6dCxrZXk6aSxyZWY6byxfX2s6bnVsbCxfXzpudWxsLF9fYjowLF9fZTpudWxsLF9fZDp2b2lkIDAsX19jOm51bGwsY29uc3RydWN0b3I6dm9pZCAwLF9fdjpudWxsPT1yPysrdTpyLF9faTotMSxfX3U6MH07cmV0dXJuIG51bGw9PXImJm51bGwhPWwudm5vZGUmJmwudm5vZGUoZiksZn1mdW5jdGlvbiBtKCl7cmV0dXJue2N1cnJlbnQ6bnVsbH19ZnVuY3Rpb24gayhuKXtyZXR1cm4gbi5jaGlsZHJlbn1mdW5jdGlvbiBiKG4sbCl7dGhpcy5wcm9wcz1uLHRoaXMuY29udGV4dD1sfWZ1bmN0aW9uIHgobixsKXtpZihudWxsPT1sKXJldHVybiBuLl9fP3gobi5fXyxuLl9faSsxKTpudWxsO2Zvcih2YXIgdTtsPG4uX19rLmxlbmd0aDtsKyspaWYobnVsbCE9KHU9bi5fX2tbbF0pJiZudWxsIT11Ll9fZSlyZXR1cm4gdS5fX2U7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2Ygbi50eXBlP3gobik6bnVsbH1mdW5jdGlvbiBDKG4pe3ZhciBsLHU7aWYobnVsbCE9KG49bi5fXykmJm51bGwhPW4uX19jKXtmb3Iobi5fX2U9bi5fX2MuYmFzZT1udWxsLGw9MDtsPG4uX19rLmxlbmd0aDtsKyspaWYobnVsbCE9KHU9bi5fX2tbbF0pJiZudWxsIT11Ll9fZSl7bi5fX2U9bi5fX2MuYmFzZT11Ll9fZTticmVha31yZXR1cm4gQyhuKX19ZnVuY3Rpb24gTShuKXsoIW4uX19kJiYobi5fX2Q9ITApJiZpLnB1c2gobikmJiFQLl9fcisrfHxvIT09bC5kZWJvdW5jZVJlbmRlcmluZykmJigobz1sLmRlYm91bmNlUmVuZGVyaW5nKXx8cikoUCl9ZnVuY3Rpb24gUCgpe3ZhciBuLHUsdCxvLHIsZSxjLHM7Zm9yKGkuc29ydChmKTtuPWkuc2hpZnQoKTspbi5fX2QmJih1PWkubGVuZ3RoLG89dm9pZCAwLGU9KHI9KHQ9bikuX192KS5fX2UsYz1bXSxzPVtdLHQuX19QJiYoKG89ZCh7fSxyKSkuX192PXIuX192KzEsbC52bm9kZSYmbC52bm9kZShvKSxPKHQuX19QLG8scix0Ll9fbix0Ll9fUC5uYW1lc3BhY2VVUkksMzImci5fX3U/W2VdOm51bGwsYyxudWxsPT1lP3gocik6ZSwhISgzMiZyLl9fdSkscyksby5fX3Y9ci5fX3Ysby5fXy5fX2tbby5fX2ldPW8saihjLG8scyksby5fX2UhPWUmJkMobykpLGkubGVuZ3RoPnUmJmkuc29ydChmKSk7UC5fX3I9MH1mdW5jdGlvbiBTKG4sbCx1LHQsaSxvLHIsZixlLGMscyl7dmFyIGEsdix5LGQsdyxfPXQmJnQuX19rfHxwLGc9bC5sZW5ndGg7Zm9yKHUuX19kPWUsJCh1LGwsXyksZT11Ll9fZCxhPTA7YTxnO2ErKyludWxsIT0oeT11Ll9fa1thXSkmJlwiYm9vbGVhblwiIT10eXBlb2YgeSYmXCJmdW5jdGlvblwiIT10eXBlb2YgeSYmKHY9LTE9PT15Ll9faT9oOl9beS5fX2ldfHxoLHkuX19pPWEsTyhuLHksdixpLG8scixmLGUsYyxzKSxkPXkuX19lLHkucmVmJiZ2LnJlZiE9eS5yZWYmJih2LnJlZiYmTih2LnJlZixudWxsLHkpLHMucHVzaCh5LnJlZix5Ll9fY3x8ZCx5KSksbnVsbD09dyYmbnVsbCE9ZCYmKHc9ZCksNjU1MzYmeS5fX3V8fHYuX19rPT09eS5fX2s/ZT1JKHksZSxuKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiB5LnR5cGUmJnZvaWQgMCE9PXkuX19kP2U9eS5fX2Q6ZCYmKGU9ZC5uZXh0U2libGluZykseS5fX2Q9dm9pZCAwLHkuX191Jj0tMTk2NjA5KTt1Ll9fZD1lLHUuX19lPXd9ZnVuY3Rpb24gJChuLGwsdSl7dmFyIHQsaSxvLHIsZixlPWwubGVuZ3RoLGM9dS5sZW5ndGgscz1jLGE9MDtmb3Iobi5fX2s9W10sdD0wO3Q8ZTt0Kyspcj10K2EsbnVsbCE9KGk9bi5fX2tbdF09bnVsbD09KGk9bFt0XSl8fFwiYm9vbGVhblwiPT10eXBlb2YgaXx8XCJmdW5jdGlvblwiPT10eXBlb2YgaT9udWxsOlwic3RyaW5nXCI9PXR5cGVvZiBpfHxcIm51bWJlclwiPT10eXBlb2YgaXx8XCJiaWdpbnRcIj09dHlwZW9mIGl8fGkuY29uc3RydWN0b3I9PVN0cmluZz9nKG51bGwsaSxudWxsLG51bGwsbnVsbCk6eShpKT9nKGsse2NoaWxkcmVuOml9LG51bGwsbnVsbCxudWxsKTp2b2lkIDA9PT1pLmNvbnN0cnVjdG9yJiZpLl9fYj4wP2coaS50eXBlLGkucHJvcHMsaS5rZXksaS5yZWY/aS5yZWY6bnVsbCxpLl9fdik6aSk/KGkuX189bixpLl9fYj1uLl9fYisxLGY9TChpLHUscixzKSxpLl9faT1mLG89bnVsbCwtMSE9PWYmJihzLS0sKG89dVtmXSkmJihvLl9fdXw9MTMxMDcyKSksbnVsbD09b3x8bnVsbD09PW8uX192PygtMT09ZiYmYS0tLFwiZnVuY3Rpb25cIiE9dHlwZW9mIGkudHlwZSYmKGkuX191fD02NTUzNikpOmYhPT1yJiYoZj09ci0xP2E9Zi1yOmY9PXIrMT9hKys6Zj5yP3M+ZS1yP2ErPWYtcjphLS06ZjxyJiZhKyssZiE9PXQrYSYmKGkuX191fD02NTUzNikpKToobz11W3JdKSYmbnVsbD09by5rZXkmJm8uX19lJiYwPT0oMTMxMDcyJm8uX191KSYmKG8uX19lPT1uLl9fZCYmKG4uX19kPXgobykpLFYobyxvLCExKSx1W3JdPW51bGwscy0tKTtpZihzKWZvcih0PTA7dDxjO3QrKyludWxsIT0obz11W3RdKSYmMD09KDEzMTA3MiZvLl9fdSkmJihvLl9fZT09bi5fX2QmJihuLl9fZD14KG8pKSxWKG8sbykpfWZ1bmN0aW9uIEkobixsLHUpe3ZhciB0LGk7aWYoXCJmdW5jdGlvblwiPT10eXBlb2Ygbi50eXBlKXtmb3IodD1uLl9fayxpPTA7dCYmaTx0Lmxlbmd0aDtpKyspdFtpXSYmKHRbaV0uX189bixsPUkodFtpXSxsLHUpKTtyZXR1cm4gbH1uLl9fZSE9bCYmKGwmJm4udHlwZSYmIXUuY29udGFpbnMobCkmJihsPXgobikpLHUuaW5zZXJ0QmVmb3JlKG4uX19lLGx8fG51bGwpLGw9bi5fX2UpO2Rve2w9bCYmbC5uZXh0U2libGluZ313aGlsZShudWxsIT1sJiY4PT09bC5ub2RlVHlwZSk7cmV0dXJuIGx9ZnVuY3Rpb24gSChuLGwpe3JldHVybiBsPWx8fFtdLG51bGw9PW58fFwiYm9vbGVhblwiPT10eXBlb2Ygbnx8KHkobik/bi5zb21lKGZ1bmN0aW9uKG4pe0gobixsKX0pOmwucHVzaChuKSksbH1mdW5jdGlvbiBMKG4sbCx1LHQpe3ZhciBpPW4ua2V5LG89bi50eXBlLHI9dS0xLGY9dSsxLGU9bFt1XTtpZihudWxsPT09ZXx8ZSYmaT09ZS5rZXkmJm89PT1lLnR5cGUmJjA9PSgxMzEwNzImZS5fX3UpKXJldHVybiB1O2lmKHQ+KG51bGwhPWUmJjA9PSgxMzEwNzImZS5fX3UpPzE6MCkpZm9yKDtyPj0wfHxmPGwubGVuZ3RoOyl7aWYocj49MCl7aWYoKGU9bFtyXSkmJjA9PSgxMzEwNzImZS5fX3UpJiZpPT1lLmtleSYmbz09PWUudHlwZSlyZXR1cm4gcjtyLS19aWYoZjxsLmxlbmd0aCl7aWYoKGU9bFtmXSkmJjA9PSgxMzEwNzImZS5fX3UpJiZpPT1lLmtleSYmbz09PWUudHlwZSlyZXR1cm4gZjtmKyt9fXJldHVybi0xfWZ1bmN0aW9uIFQobixsLHUpe1wiLVwiPT09bFswXT9uLnNldFByb3BlcnR5KGwsbnVsbD09dT9cIlwiOnUpOm5bbF09bnVsbD09dT9cIlwiOlwibnVtYmVyXCIhPXR5cGVvZiB1fHx2LnRlc3QobCk/dTp1K1wicHhcIn1mdW5jdGlvbiBBKG4sbCx1LHQsaSl7dmFyIG87bjppZihcInN0eWxlXCI9PT1sKWlmKFwic3RyaW5nXCI9PXR5cGVvZiB1KW4uc3R5bGUuY3NzVGV4dD11O2Vsc2V7aWYoXCJzdHJpbmdcIj09dHlwZW9mIHQmJihuLnN0eWxlLmNzc1RleHQ9dD1cIlwiKSx0KWZvcihsIGluIHQpdSYmbCBpbiB1fHxUKG4uc3R5bGUsbCxcIlwiKTtpZih1KWZvcihsIGluIHUpdCYmdVtsXT09PXRbbF18fFQobi5zdHlsZSxsLHVbbF0pfWVsc2UgaWYoXCJvXCI9PT1sWzBdJiZcIm5cIj09PWxbMV0pbz1sIT09KGw9bC5yZXBsYWNlKC8oUG9pbnRlckNhcHR1cmUpJHxDYXB0dXJlJC9pLFwiJDFcIikpLGw9bC50b0xvd2VyQ2FzZSgpaW4gbnx8XCJvbkZvY3VzT3V0XCI9PT1sfHxcIm9uRm9jdXNJblwiPT09bD9sLnRvTG93ZXJDYXNlKCkuc2xpY2UoMik6bC5zbGljZSgyKSxuLmx8fChuLmw9e30pLG4ubFtsK29dPXUsdT90P3UudT10LnU6KHUudT1lLG4uYWRkRXZlbnRMaXN0ZW5lcihsLG8/czpjLG8pKTpuLnJlbW92ZUV2ZW50TGlzdGVuZXIobCxvP3M6YyxvKTtlbHNle2lmKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj09aSlsPWwucmVwbGFjZSgveGxpbmsoSHw6aCkvLFwiaFwiKS5yZXBsYWNlKC9zTmFtZSQvLFwic1wiKTtlbHNlIGlmKFwid2lkdGhcIiE9bCYmXCJoZWlnaHRcIiE9bCYmXCJocmVmXCIhPWwmJlwibGlzdFwiIT1sJiZcImZvcm1cIiE9bCYmXCJ0YWJJbmRleFwiIT1sJiZcImRvd25sb2FkXCIhPWwmJlwicm93U3BhblwiIT1sJiZcImNvbFNwYW5cIiE9bCYmXCJyb2xlXCIhPWwmJlwicG9wb3ZlclwiIT1sJiZsIGluIG4pdHJ5e25bbF09bnVsbD09dT9cIlwiOnU7YnJlYWsgbn1jYXRjaChuKXt9XCJmdW5jdGlvblwiPT10eXBlb2YgdXx8KG51bGw9PXV8fCExPT09dSYmXCItXCIhPT1sWzRdP24ucmVtb3ZlQXR0cmlidXRlKGwpOm4uc2V0QXR0cmlidXRlKGwsXCJwb3BvdmVyXCI9PWwmJjE9PXU/XCJcIjp1KSl9fWZ1bmN0aW9uIEYobil7cmV0dXJuIGZ1bmN0aW9uKHUpe2lmKHRoaXMubCl7dmFyIHQ9dGhpcy5sW3UudHlwZStuXTtpZihudWxsPT11LnQpdS50PWUrKztlbHNlIGlmKHUudDx0LnUpcmV0dXJuO3JldHVybiB0KGwuZXZlbnQ/bC5ldmVudCh1KTp1KX19fWZ1bmN0aW9uIE8obix1LHQsaSxvLHIsZixlLGMscyl7dmFyIGEsaCxwLHYsdyxfLGcsbSx4LEMsTSxQLCQsSSxILEwsVD11LnR5cGU7aWYodm9pZCAwIT09dS5jb25zdHJ1Y3RvcilyZXR1cm4gbnVsbDsxMjgmdC5fX3UmJihjPSEhKDMyJnQuX191KSxyPVtlPXUuX19lPXQuX19lXSksKGE9bC5fX2IpJiZhKHUpO246aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgVCl0cnl7aWYobT11LnByb3BzLHg9XCJwcm90b3R5cGVcImluIFQmJlQucHJvdG90eXBlLnJlbmRlcixDPShhPVQuY29udGV4dFR5cGUpJiZpW2EuX19jXSxNPWE/Qz9DLnByb3BzLnZhbHVlOmEuX186aSx0Ll9fYz9nPShoPXUuX19jPXQuX19jKS5fXz1oLl9fRTooeD91Ll9fYz1oPW5ldyBUKG0sTSk6KHUuX19jPWg9bmV3IGIobSxNKSxoLmNvbnN0cnVjdG9yPVQsaC5yZW5kZXI9cSksQyYmQy5zdWIoaCksaC5wcm9wcz1tLGguc3RhdGV8fChoLnN0YXRlPXt9KSxoLmNvbnRleHQ9TSxoLl9fbj1pLHA9aC5fX2Q9ITAsaC5fX2g9W10saC5fc2I9W10pLHgmJm51bGw9PWguX19zJiYoaC5fX3M9aC5zdGF0ZSkseCYmbnVsbCE9VC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMmJihoLl9fcz09aC5zdGF0ZSYmKGguX19zPWQoe30saC5fX3MpKSxkKGguX19zLFQuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKG0saC5fX3MpKSksdj1oLnByb3BzLHc9aC5zdGF0ZSxoLl9fdj11LHApeCYmbnVsbD09VC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMmJm51bGwhPWguY29tcG9uZW50V2lsbE1vdW50JiZoLmNvbXBvbmVudFdpbGxNb3VudCgpLHgmJm51bGwhPWguY29tcG9uZW50RGlkTW91bnQmJmguX19oLnB1c2goaC5jb21wb25lbnREaWRNb3VudCk7ZWxzZXtpZih4JiZudWxsPT1ULmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyYmbSE9PXYmJm51bGwhPWguY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyYmaC5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG0sTSksIWguX19lJiYobnVsbCE9aC5zaG91bGRDb21wb25lbnRVcGRhdGUmJiExPT09aC5zaG91bGRDb21wb25lbnRVcGRhdGUobSxoLl9fcyxNKXx8dS5fX3Y9PT10Ll9fdikpe2Zvcih1Ll9fdiE9PXQuX192JiYoaC5wcm9wcz1tLGguc3RhdGU9aC5fX3MsaC5fX2Q9ITEpLHUuX19lPXQuX19lLHUuX19rPXQuX19rLHUuX19rLmZvckVhY2goZnVuY3Rpb24obil7biYmKG4uX189dSl9KSxQPTA7UDxoLl9zYi5sZW5ndGg7UCsrKWguX19oLnB1c2goaC5fc2JbUF0pO2guX3NiPVtdLGguX19oLmxlbmd0aCYmZi5wdXNoKGgpO2JyZWFrIG59bnVsbCE9aC5jb21wb25lbnRXaWxsVXBkYXRlJiZoLmNvbXBvbmVudFdpbGxVcGRhdGUobSxoLl9fcyxNKSx4JiZudWxsIT1oLmNvbXBvbmVudERpZFVwZGF0ZSYmaC5fX2gucHVzaChmdW5jdGlvbigpe2guY29tcG9uZW50RGlkVXBkYXRlKHYsdyxfKX0pfWlmKGguY29udGV4dD1NLGgucHJvcHM9bSxoLl9fUD1uLGguX19lPSExLCQ9bC5fX3IsST0wLHgpe2ZvcihoLnN0YXRlPWguX19zLGguX19kPSExLCQmJiQodSksYT1oLnJlbmRlcihoLnByb3BzLGguc3RhdGUsaC5jb250ZXh0KSxIPTA7SDxoLl9zYi5sZW5ndGg7SCsrKWguX19oLnB1c2goaC5fc2JbSF0pO2guX3NiPVtdfWVsc2UgZG97aC5fX2Q9ITEsJCYmJCh1KSxhPWgucmVuZGVyKGgucHJvcHMsaC5zdGF0ZSxoLmNvbnRleHQpLGguc3RhdGU9aC5fX3N9d2hpbGUoaC5fX2QmJisrSTwyNSk7aC5zdGF0ZT1oLl9fcyxudWxsIT1oLmdldENoaWxkQ29udGV4dCYmKGk9ZChkKHt9LGkpLGguZ2V0Q2hpbGRDb250ZXh0KCkpKSx4JiYhcCYmbnVsbCE9aC5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSYmKF89aC5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSh2LHcpKSxTKG4seShMPW51bGwhPWEmJmEudHlwZT09PWsmJm51bGw9PWEua2V5P2EucHJvcHMuY2hpbGRyZW46YSk/TDpbTF0sdSx0LGksbyxyLGYsZSxjLHMpLGguYmFzZT11Ll9fZSx1Ll9fdSY9LTE2MSxoLl9faC5sZW5ndGgmJmYucHVzaChoKSxnJiYoaC5fX0U9aC5fXz1udWxsKX1jYXRjaChuKXtpZih1Ll9fdj1udWxsLGN8fG51bGwhPXIpe2Zvcih1Ll9fdXw9Yz8xNjA6MzI7ZSYmOD09PWUubm9kZVR5cGUmJmUubmV4dFNpYmxpbmc7KWU9ZS5uZXh0U2libGluZztyW3IuaW5kZXhPZihlKV09bnVsbCx1Ll9fZT1lfWVsc2UgdS5fX2U9dC5fX2UsdS5fX2s9dC5fX2s7bC5fX2Uobix1LHQpfWVsc2UgbnVsbD09ciYmdS5fX3Y9PT10Ll9fdj8odS5fX2s9dC5fX2ssdS5fX2U9dC5fX2UpOnUuX19lPXoodC5fX2UsdSx0LGksbyxyLGYsYyxzKTsoYT1sLmRpZmZlZCkmJmEodSl9ZnVuY3Rpb24gaihuLHUsdCl7dS5fX2Q9dm9pZCAwO2Zvcih2YXIgaT0wO2k8dC5sZW5ndGg7aSsrKU4odFtpXSx0WysraV0sdFsrK2ldKTtsLl9fYyYmbC5fX2ModSxuKSxuLnNvbWUoZnVuY3Rpb24odSl7dHJ5e249dS5fX2gsdS5fX2g9W10sbi5zb21lKGZ1bmN0aW9uKG4pe24uY2FsbCh1KX0pfWNhdGNoKG4pe2wuX19lKG4sdS5fX3YpfX0pfWZ1bmN0aW9uIHoobCx1LHQsaSxvLHIsZixlLGMpe3ZhciBzLGEscCx2LGQsXyxnLG09dC5wcm9wcyxrPXUucHJvcHMsYj11LnR5cGU7aWYoXCJzdmdcIj09PWI/bz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI6XCJtYXRoXCI9PT1iP289XCJodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MXCI6b3x8KG89XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCIpLG51bGwhPXIpZm9yKHM9MDtzPHIubGVuZ3RoO3MrKylpZigoZD1yW3NdKSYmXCJzZXRBdHRyaWJ1dGVcImluIGQ9PSEhYiYmKGI/ZC5sb2NhbE5hbWU9PT1iOjM9PT1kLm5vZGVUeXBlKSl7bD1kLHJbc109bnVsbDticmVha31pZihudWxsPT1sKXtpZihudWxsPT09YilyZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoayk7bD1kb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobyxiLGsuaXMmJmspLHI9bnVsbCxlPSExfWlmKG51bGw9PT1iKW09PT1rfHxlJiZsLmRhdGE9PT1rfHwobC5kYXRhPWspO2Vsc2V7aWYocj1yJiZuLmNhbGwobC5jaGlsZE5vZGVzKSxtPXQucHJvcHN8fGgsIWUmJm51bGwhPXIpZm9yKG09e30scz0wO3M8bC5hdHRyaWJ1dGVzLmxlbmd0aDtzKyspbVsoZD1sLmF0dHJpYnV0ZXNbc10pLm5hbWVdPWQudmFsdWU7Zm9yKHMgaW4gbSlpZihkPW1bc10sXCJjaGlsZHJlblwiPT1zKTtlbHNlIGlmKFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIj09cylwPWQ7ZWxzZSBpZihcImtleVwiIT09cyYmIShzIGluIGspKXtpZihcInZhbHVlXCI9PXMmJlwiZGVmYXVsdFZhbHVlXCJpbiBrfHxcImNoZWNrZWRcIj09cyYmXCJkZWZhdWx0Q2hlY2tlZFwiaW4gayljb250aW51ZTtBKGwscyxudWxsLGQsbyl9Zm9yKHMgaW4gaylkPWtbc10sXCJjaGlsZHJlblwiPT1zP3Y9ZDpcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI9PXM/YT1kOlwidmFsdWVcIj09cz9fPWQ6XCJjaGVja2VkXCI9PXM/Zz1kOlwia2V5XCI9PT1zfHxlJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiBkfHxtW3NdPT09ZHx8QShsLHMsZCxtW3NdLG8pO2lmKGEpZXx8cCYmKGEuX19odG1sPT09cC5fX2h0bWx8fGEuX19odG1sPT09bC5pbm5lckhUTUwpfHwobC5pbm5lckhUTUw9YS5fX2h0bWwpLHUuX19rPVtdO2Vsc2UgaWYocCYmKGwuaW5uZXJIVE1MPVwiXCIpLFMobCx5KHYpP3Y6W3ZdLHUsdCxpLFwiZm9yZWlnbk9iamVjdFwiPT09Yj9cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIjpvLHIsZixyP3JbMF06dC5fX2smJngodCwwKSxlLGMpLG51bGwhPXIpZm9yKHM9ci5sZW5ndGg7cy0tOyludWxsIT1yW3NdJiZ3KHJbc10pO2V8fChzPVwidmFsdWVcIix2b2lkIDAhPT1fJiYoXyE9PWxbc118fFwicHJvZ3Jlc3NcIj09PWImJiFffHxcIm9wdGlvblwiPT09YiYmXyE9PW1bc10pJiZBKGwscyxfLG1bc10sbykscz1cImNoZWNrZWRcIix2b2lkIDAhPT1nJiZnIT09bFtzXSYmQShsLHMsZyxtW3NdLG8pKX1yZXR1cm4gbH1mdW5jdGlvbiBOKG4sdSx0KXt0cnl7aWYoXCJmdW5jdGlvblwiPT10eXBlb2Ygbil7dmFyIGk9XCJmdW5jdGlvblwiPT10eXBlb2Ygbi5fX3U7aSYmbi5fX3UoKSxpJiZudWxsPT11fHwobi5fX3U9bih1KSl9ZWxzZSBuLmN1cnJlbnQ9dX1jYXRjaChuKXtsLl9fZShuLHQpfX1mdW5jdGlvbiBWKG4sdSx0KXt2YXIgaSxvO2lmKGwudW5tb3VudCYmbC51bm1vdW50KG4pLChpPW4ucmVmKSYmKGkuY3VycmVudCYmaS5jdXJyZW50IT09bi5fX2V8fE4oaSxudWxsLHUpKSxudWxsIT0oaT1uLl9fYykpe2lmKGkuY29tcG9uZW50V2lsbFVubW91bnQpdHJ5e2kuY29tcG9uZW50V2lsbFVubW91bnQoKX1jYXRjaChuKXtsLl9fZShuLHUpfWkuYmFzZT1pLl9fUD1udWxsfWlmKGk9bi5fX2spZm9yKG89MDtvPGkubGVuZ3RoO28rKylpW29dJiZWKGlbb10sdSx0fHxcImZ1bmN0aW9uXCIhPXR5cGVvZiBuLnR5cGUpO3R8fG51bGw9PW4uX19lfHx3KG4uX19lKSxuLl9fYz1uLl9fPW4uX19lPW4uX19kPXZvaWQgMH1mdW5jdGlvbiBxKG4sbCx1KXtyZXR1cm4gdGhpcy5jb25zdHJ1Y3RvcihuLHUpfWZ1bmN0aW9uIEIodSx0LGkpe3ZhciBvLHIsZixlO2wuX18mJmwuX18odSx0KSxyPShvPVwiZnVuY3Rpb25cIj09dHlwZW9mIGkpP251bGw6aSYmaS5fX2t8fHQuX19rLGY9W10sZT1bXSxPKHQsdT0oIW8mJml8fHQpLl9faz1fKGssbnVsbCxbdV0pLHJ8fGgsaCx0Lm5hbWVzcGFjZVVSSSwhbyYmaT9baV06cj9udWxsOnQuZmlyc3RDaGlsZD9uLmNhbGwodC5jaGlsZE5vZGVzKTpudWxsLGYsIW8mJmk/aTpyP3IuX19lOnQuZmlyc3RDaGlsZCxvLGUpLGooZix1LGUpfWZ1bmN0aW9uIEQobixsKXtCKG4sbCxEKX1mdW5jdGlvbiBFKGwsdSx0KXt2YXIgaSxvLHIsZixlPWQoe30sbC5wcm9wcyk7Zm9yKHIgaW4gbC50eXBlJiZsLnR5cGUuZGVmYXVsdFByb3BzJiYoZj1sLnR5cGUuZGVmYXVsdFByb3BzKSx1KVwia2V5XCI9PXI/aT11W3JdOlwicmVmXCI9PXI/bz11W3JdOmVbcl09dm9pZCAwPT09dVtyXSYmdm9pZCAwIT09Zj9mW3JdOnVbcl07cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg+MiYmKGUuY2hpbGRyZW49YXJndW1lbnRzLmxlbmd0aD4zP24uY2FsbChhcmd1bWVudHMsMik6dCksZyhsLnR5cGUsZSxpfHxsLmtleSxvfHxsLnJlZixudWxsKX1mdW5jdGlvbiBHKG4sbCl7dmFyIHU9e19fYzpsPVwiX19jQ1wiK2ErKyxfXzpuLENvbnN1bWVyOmZ1bmN0aW9uKG4sbCl7cmV0dXJuIG4uY2hpbGRyZW4obCl9LFByb3ZpZGVyOmZ1bmN0aW9uKG4pe3ZhciB1LHQ7cmV0dXJuIHRoaXMuZ2V0Q2hpbGRDb250ZXh0fHwodT1bXSwodD17fSlbbF09dGhpcyx0aGlzLmdldENoaWxkQ29udGV4dD1mdW5jdGlvbigpe3JldHVybiB0fSx0aGlzLmNvbXBvbmVudFdpbGxVbm1vdW50PWZ1bmN0aW9uKCl7dT1udWxsfSx0aGlzLnNob3VsZENvbXBvbmVudFVwZGF0ZT1mdW5jdGlvbihuKXt0aGlzLnByb3BzLnZhbHVlIT09bi52YWx1ZSYmdS5zb21lKGZ1bmN0aW9uKG4pe24uX19lPSEwLE0obil9KX0sdGhpcy5zdWI9ZnVuY3Rpb24obil7dS5wdXNoKG4pO3ZhciBsPW4uY29tcG9uZW50V2lsbFVubW91bnQ7bi5jb21wb25lbnRXaWxsVW5tb3VudD1mdW5jdGlvbigpe3UmJnUuc3BsaWNlKHUuaW5kZXhPZihuKSwxKSxsJiZsLmNhbGwobil9fSksbi5jaGlsZHJlbn19O3JldHVybiB1LlByb3ZpZGVyLl9fPXUuQ29uc3VtZXIuY29udGV4dFR5cGU9dX1uPXAuc2xpY2UsbD17X19lOmZ1bmN0aW9uKG4sbCx1LHQpe2Zvcih2YXIgaSxvLHI7bD1sLl9fOylpZigoaT1sLl9fYykmJiFpLl9fKXRyeXtpZigobz1pLmNvbnN0cnVjdG9yKSYmbnVsbCE9by5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3ImJihpLnNldFN0YXRlKG8uZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKG4pKSxyPWkuX19kKSxudWxsIT1pLmNvbXBvbmVudERpZENhdGNoJiYoaS5jb21wb25lbnREaWRDYXRjaChuLHR8fHt9KSxyPWkuX19kKSxyKXJldHVybiBpLl9fRT1pfWNhdGNoKGwpe249bH10aHJvdyBufX0sdT0wLHQ9ZnVuY3Rpb24obil7cmV0dXJuIG51bGwhPW4mJm51bGw9PW4uY29uc3RydWN0b3J9LGIucHJvdG90eXBlLnNldFN0YXRlPWZ1bmN0aW9uKG4sbCl7dmFyIHU7dT1udWxsIT10aGlzLl9fcyYmdGhpcy5fX3MhPT10aGlzLnN0YXRlP3RoaXMuX19zOnRoaXMuX19zPWQoe30sdGhpcy5zdGF0ZSksXCJmdW5jdGlvblwiPT10eXBlb2YgbiYmKG49bihkKHt9LHUpLHRoaXMucHJvcHMpKSxuJiZkKHUsbiksbnVsbCE9biYmdGhpcy5fX3YmJihsJiZ0aGlzLl9zYi5wdXNoKGwpLE0odGhpcykpfSxiLnByb3RvdHlwZS5mb3JjZVVwZGF0ZT1mdW5jdGlvbihuKXt0aGlzLl9fdiYmKHRoaXMuX19lPSEwLG4mJnRoaXMuX19oLnB1c2gobiksTSh0aGlzKSl9LGIucHJvdG90eXBlLnJlbmRlcj1rLGk9W10scj1cImZ1bmN0aW9uXCI9PXR5cGVvZiBQcm9taXNlP1Byb21pc2UucHJvdG90eXBlLnRoZW4uYmluZChQcm9taXNlLnJlc29sdmUoKSk6c2V0VGltZW91dCxmPWZ1bmN0aW9uKG4sbCl7cmV0dXJuIG4uX192Ll9fYi1sLl9fdi5fX2J9LFAuX19yPTAsZT0wLGM9RighMSkscz1GKCEwKSxhPTA7ZXhwb3J0e2IgYXMgQ29tcG9uZW50LGsgYXMgRnJhZ21lbnQsRSBhcyBjbG9uZUVsZW1lbnQsRyBhcyBjcmVhdGVDb250ZXh0LF8gYXMgY3JlYXRlRWxlbWVudCxtIGFzIGNyZWF0ZVJlZixfIGFzIGgsRCBhcyBoeWRyYXRlLHQgYXMgaXNWYWxpZEVsZW1lbnQsbCBhcyBvcHRpb25zLEIgYXMgcmVuZGVyLEggYXMgdG9DaGlsZEFycmF5fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByZWFjdC5tb2R1bGUuanMubWFwXG4iLCJpbXBvcnR7b3B0aW9ucyBhcyBufWZyb21cInByZWFjdFwiO3ZhciB0LHIsdSxpLG89MCxmPVtdLGM9bixlPWMuX19iLGE9Yy5fX3Isdj1jLmRpZmZlZCxsPWMuX19jLG09Yy51bm1vdW50LHM9Yy5fXztmdW5jdGlvbiBkKG4sdCl7Yy5fX2gmJmMuX19oKHIsbixvfHx0KSxvPTA7dmFyIHU9ci5fX0h8fChyLl9fSD17X186W10sX19oOltdfSk7cmV0dXJuIG4+PXUuX18ubGVuZ3RoJiZ1Ll9fLnB1c2goe30pLHUuX19bbl19ZnVuY3Rpb24gaChuKXtyZXR1cm4gbz0xLHAoRCxuKX1mdW5jdGlvbiBwKG4sdSxpKXt2YXIgbz1kKHQrKywyKTtpZihvLnQ9biwhby5fX2MmJihvLl9fPVtpP2kodSk6RCh2b2lkIDAsdSksZnVuY3Rpb24obil7dmFyIHQ9by5fX04/by5fX05bMF06by5fX1swXSxyPW8udCh0LG4pO3QhPT1yJiYoby5fX049W3Isby5fX1sxXV0sby5fX2Muc2V0U3RhdGUoe30pKX1dLG8uX19jPXIsIXIudSkpe3ZhciBmPWZ1bmN0aW9uKG4sdCxyKXtpZighby5fX2MuX19IKXJldHVybiEwO3ZhciB1PW8uX19jLl9fSC5fXy5maWx0ZXIoZnVuY3Rpb24obil7cmV0dXJuISFuLl9fY30pO2lmKHUuZXZlcnkoZnVuY3Rpb24obil7cmV0dXJuIW4uX19OfSkpcmV0dXJuIWN8fGMuY2FsbCh0aGlzLG4sdCxyKTt2YXIgaT0hMTtyZXR1cm4gdS5mb3JFYWNoKGZ1bmN0aW9uKG4pe2lmKG4uX19OKXt2YXIgdD1uLl9fWzBdO24uX189bi5fX04sbi5fX049dm9pZCAwLHQhPT1uLl9fWzBdJiYoaT0hMCl9fSksISghaSYmby5fX2MucHJvcHM9PT1uKSYmKCFjfHxjLmNhbGwodGhpcyxuLHQscikpfTtyLnU9ITA7dmFyIGM9ci5zaG91bGRDb21wb25lbnRVcGRhdGUsZT1yLmNvbXBvbmVudFdpbGxVcGRhdGU7ci5jb21wb25lbnRXaWxsVXBkYXRlPWZ1bmN0aW9uKG4sdCxyKXtpZih0aGlzLl9fZSl7dmFyIHU9YztjPXZvaWQgMCxmKG4sdCxyKSxjPXV9ZSYmZS5jYWxsKHRoaXMsbix0LHIpfSxyLnNob3VsZENvbXBvbmVudFVwZGF0ZT1mfXJldHVybiBvLl9fTnx8by5fX31mdW5jdGlvbiB5KG4sdSl7dmFyIGk9ZCh0KyssMyk7IWMuX19zJiZDKGkuX19ILHUpJiYoaS5fXz1uLGkuaT11LHIuX19ILl9faC5wdXNoKGkpKX1mdW5jdGlvbiBfKG4sdSl7dmFyIGk9ZCh0KyssNCk7IWMuX19zJiZDKGkuX19ILHUpJiYoaS5fXz1uLGkuaT11LHIuX19oLnB1c2goaSkpfWZ1bmN0aW9uIEEobil7cmV0dXJuIG89NSxUKGZ1bmN0aW9uKCl7cmV0dXJue2N1cnJlbnQ6bn19LFtdKX1mdW5jdGlvbiBGKG4sdCxyKXtvPTYsXyhmdW5jdGlvbigpe3JldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIG4/KG4odCgpKSxmdW5jdGlvbigpe3JldHVybiBuKG51bGwpfSk6bj8obi5jdXJyZW50PXQoKSxmdW5jdGlvbigpe3JldHVybiBuLmN1cnJlbnQ9bnVsbH0pOnZvaWQgMH0sbnVsbD09cj9yOnIuY29uY2F0KG4pKX1mdW5jdGlvbiBUKG4scil7dmFyIHU9ZCh0KyssNyk7cmV0dXJuIEModS5fX0gscikmJih1Ll9fPW4oKSx1Ll9fSD1yLHUuX19oPW4pLHUuX199ZnVuY3Rpb24gcShuLHQpe3JldHVybiBvPTgsVChmdW5jdGlvbigpe3JldHVybiBufSx0KX1mdW5jdGlvbiB4KG4pe3ZhciB1PXIuY29udGV4dFtuLl9fY10saT1kKHQrKyw5KTtyZXR1cm4gaS5jPW4sdT8obnVsbD09aS5fXyYmKGkuX189ITAsdS5zdWIocikpLHUucHJvcHMudmFsdWUpOm4uX199ZnVuY3Rpb24gUChuLHQpe2MudXNlRGVidWdWYWx1ZSYmYy51c2VEZWJ1Z1ZhbHVlKHQ/dChuKTpuKX1mdW5jdGlvbiBiKG4pe3ZhciB1PWQodCsrLDEwKSxpPWgoKTtyZXR1cm4gdS5fXz1uLHIuY29tcG9uZW50RGlkQ2F0Y2h8fChyLmNvbXBvbmVudERpZENhdGNoPWZ1bmN0aW9uKG4sdCl7dS5fXyYmdS5fXyhuLHQpLGlbMV0obil9KSxbaVswXSxmdW5jdGlvbigpe2lbMV0odm9pZCAwKX1dfWZ1bmN0aW9uIGcoKXt2YXIgbj1kKHQrKywxMSk7aWYoIW4uX18pe2Zvcih2YXIgdT1yLl9fdjtudWxsIT09dSYmIXUuX19tJiZudWxsIT09dS5fXzspdT11Ll9fO3ZhciBpPXUuX19tfHwodS5fX209WzAsMF0pO24uX189XCJQXCIraVswXStcIi1cIitpWzFdKyt9cmV0dXJuIG4uX199ZnVuY3Rpb24gaigpe2Zvcih2YXIgbjtuPWYuc2hpZnQoKTspaWYobi5fX1AmJm4uX19IKXRyeXtuLl9fSC5fX2guZm9yRWFjaCh6KSxuLl9fSC5fX2guZm9yRWFjaChCKSxuLl9fSC5fX2g9W119Y2F0Y2godCl7bi5fX0guX19oPVtdLGMuX19lKHQsbi5fX3YpfX1jLl9fYj1mdW5jdGlvbihuKXtyPW51bGwsZSYmZShuKX0sYy5fXz1mdW5jdGlvbihuLHQpe24mJnQuX19rJiZ0Ll9fay5fX20mJihuLl9fbT10Ll9fay5fX20pLHMmJnMobix0KX0sYy5fX3I9ZnVuY3Rpb24obil7YSYmYShuKSx0PTA7dmFyIGk9KHI9bi5fX2MpLl9fSDtpJiYodT09PXI/KGkuX19oPVtdLHIuX19oPVtdLGkuX18uZm9yRWFjaChmdW5jdGlvbihuKXtuLl9fTiYmKG4uX189bi5fX04pLG4uaT1uLl9fTj12b2lkIDB9KSk6KGkuX19oLmZvckVhY2goeiksaS5fX2guZm9yRWFjaChCKSxpLl9faD1bXSx0PTApKSx1PXJ9LGMuZGlmZmVkPWZ1bmN0aW9uKG4pe3YmJnYobik7dmFyIHQ9bi5fX2M7dCYmdC5fX0gmJih0Ll9fSC5fX2gubGVuZ3RoJiYoMSE9PWYucHVzaCh0KSYmaT09PWMucmVxdWVzdEFuaW1hdGlvbkZyYW1lfHwoKGk9Yy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpfHx3KShqKSksdC5fX0guX18uZm9yRWFjaChmdW5jdGlvbihuKXtuLmkmJihuLl9fSD1uLmkpLG4uaT12b2lkIDB9KSksdT1yPW51bGx9LGMuX19jPWZ1bmN0aW9uKG4sdCl7dC5zb21lKGZ1bmN0aW9uKG4pe3RyeXtuLl9faC5mb3JFYWNoKHopLG4uX19oPW4uX19oLmZpbHRlcihmdW5jdGlvbihuKXtyZXR1cm4hbi5fX3x8QihuKX0pfWNhdGNoKHIpe3Quc29tZShmdW5jdGlvbihuKXtuLl9faCYmKG4uX19oPVtdKX0pLHQ9W10sYy5fX2UocixuLl9fdil9fSksbCYmbChuLHQpfSxjLnVubW91bnQ9ZnVuY3Rpb24obil7bSYmbShuKTt2YXIgdCxyPW4uX19jO3ImJnIuX19IJiYoci5fX0guX18uZm9yRWFjaChmdW5jdGlvbihuKXt0cnl7eihuKX1jYXRjaChuKXt0PW59fSksci5fX0g9dm9pZCAwLHQmJmMuX19lKHQsci5fX3YpKX07dmFyIGs9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lO2Z1bmN0aW9uIHcobil7dmFyIHQscj1mdW5jdGlvbigpe2NsZWFyVGltZW91dCh1KSxrJiZjYW5jZWxBbmltYXRpb25GcmFtZSh0KSxzZXRUaW1lb3V0KG4pfSx1PXNldFRpbWVvdXQociwxMDApO2smJih0PXJlcXVlc3RBbmltYXRpb25GcmFtZShyKSl9ZnVuY3Rpb24geihuKXt2YXIgdD1yLHU9bi5fX2M7XCJmdW5jdGlvblwiPT10eXBlb2YgdSYmKG4uX19jPXZvaWQgMCx1KCkpLHI9dH1mdW5jdGlvbiBCKG4pe3ZhciB0PXI7bi5fX2M9bi5fXygpLHI9dH1mdW5jdGlvbiBDKG4sdCl7cmV0dXJuIW58fG4ubGVuZ3RoIT09dC5sZW5ndGh8fHQuc29tZShmdW5jdGlvbih0LHIpe3JldHVybiB0IT09bltyXX0pfWZ1bmN0aW9uIEQobix0KXtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiB0P3Qobik6dH1leHBvcnR7cSBhcyB1c2VDYWxsYmFjayx4IGFzIHVzZUNvbnRleHQsUCBhcyB1c2VEZWJ1Z1ZhbHVlLHkgYXMgdXNlRWZmZWN0LGIgYXMgdXNlRXJyb3JCb3VuZGFyeSxnIGFzIHVzZUlkLEYgYXMgdXNlSW1wZXJhdGl2ZUhhbmRsZSxfIGFzIHVzZUxheW91dEVmZmVjdCxUIGFzIHVzZU1lbW8scCBhcyB1c2VSZWR1Y2VyLEEgYXMgdXNlUmVmLGggYXMgdXNlU3RhdGV9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aG9va3MubW9kdWxlLmpzLm1hcFxuIiwiaW1wb3J0e29wdGlvbnMgYXMgcixGcmFnbWVudCBhcyBlfWZyb21cInByZWFjdFwiO2V4cG9ydHtGcmFnbWVudH1mcm9tXCJwcmVhY3RcIjt2YXIgdD0vW1wiJjxdLztmdW5jdGlvbiBuKHIpe2lmKDA9PT1yLmxlbmd0aHx8ITE9PT10LnRlc3QocikpcmV0dXJuIHI7Zm9yKHZhciBlPTAsbj0wLG89XCJcIixmPVwiXCI7bjxyLmxlbmd0aDtuKyspe3N3aXRjaChyLmNoYXJDb2RlQXQobikpe2Nhc2UgMzQ6Zj1cIiZxdW90O1wiO2JyZWFrO2Nhc2UgMzg6Zj1cIiZhbXA7XCI7YnJlYWs7Y2FzZSA2MDpmPVwiJmx0O1wiO2JyZWFrO2RlZmF1bHQ6Y29udGludWV9biE9PWUmJihvKz1yLnNsaWNlKGUsbikpLG8rPWYsZT1uKzF9cmV0dXJuIG4hPT1lJiYobys9ci5zbGljZShlLG4pKSxvfXZhciBvPS9hY2l0fGV4KD86c3xnfG58cHwkKXxycGh8Z3JpZHxvd3N8bW5jfG50d3xpbmVbY2hdfHpvb3xeb3JkfGl0ZXJhL2ksZj0wLGk9QXJyYXkuaXNBcnJheTtmdW5jdGlvbiB1KGUsdCxuLG8saSx1KXt0fHwodD17fSk7dmFyIGEsYyxwPXQ7aWYoXCJyZWZcImluIHApZm9yKGMgaW4gcD17fSx0KVwicmVmXCI9PWM/YT10W2NdOnBbY109dFtjXTt2YXIgbD17dHlwZTplLHByb3BzOnAsa2V5Om4scmVmOmEsX19rOm51bGwsX186bnVsbCxfX2I6MCxfX2U6bnVsbCxfX2Q6dm9pZCAwLF9fYzpudWxsLGNvbnN0cnVjdG9yOnZvaWQgMCxfX3Y6LS1mLF9faTotMSxfX3U6MCxfX3NvdXJjZTppLF9fc2VsZjp1fTtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBlJiYoYT1lLmRlZmF1bHRQcm9wcykpZm9yKGMgaW4gYSl2b2lkIDA9PT1wW2NdJiYocFtjXT1hW2NdKTtyZXR1cm4gci52bm9kZSYmci52bm9kZShsKSxsfWZ1bmN0aW9uIGEocil7dmFyIHQ9dShlLHt0cGw6cixleHByczpbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywxKX0pO3JldHVybiB0LmtleT10Ll9fdix0fXZhciBjPXt9LHA9L1tBLVpdL2c7ZnVuY3Rpb24gbChlLHQpe2lmKHIuYXR0cil7dmFyIGY9ci5hdHRyKGUsdCk7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGYpcmV0dXJuIGZ9aWYoXCJyZWZcIj09PWV8fFwia2V5XCI9PT1lKXJldHVyblwiXCI7aWYoXCJzdHlsZVwiPT09ZSYmXCJvYmplY3RcIj09dHlwZW9mIHQpe3ZhciBpPVwiXCI7Zm9yKHZhciB1IGluIHQpe3ZhciBhPXRbdV07aWYobnVsbCE9YSYmXCJcIiE9PWEpe3ZhciBsPVwiLVwiPT11WzBdP3U6Y1t1XXx8KGNbdV09dS5yZXBsYWNlKHAsXCItJCZcIikudG9Mb3dlckNhc2UoKSksXz1cIjtcIjtcIm51bWJlclwiIT10eXBlb2YgYXx8bC5zdGFydHNXaXRoKFwiLS1cIil8fG8udGVzdChsKXx8KF89XCJweDtcIiksaT1pK2wrXCI6XCIrYStffX1yZXR1cm4gZSsnPVwiJytpKydcIid9cmV0dXJuIG51bGw9PXR8fCExPT09dHx8XCJmdW5jdGlvblwiPT10eXBlb2YgdHx8XCJvYmplY3RcIj09dHlwZW9mIHQ/XCJcIjohMD09PXQ/ZTplKyc9XCInK24odCkrJ1wiJ31mdW5jdGlvbiBfKHIpe2lmKG51bGw9PXJ8fFwiYm9vbGVhblwiPT10eXBlb2Ygcnx8XCJmdW5jdGlvblwiPT10eXBlb2YgcilyZXR1cm4gbnVsbDtpZihcIm9iamVjdFwiPT10eXBlb2Ygcil7aWYodm9pZCAwPT09ci5jb25zdHJ1Y3RvcilyZXR1cm4gcjtpZihpKHIpKXtmb3IodmFyIGU9MDtlPHIubGVuZ3RoO2UrKylyW2VdPV8ocltlXSk7cmV0dXJuIHJ9fXJldHVybiBuKFwiXCIrcil9ZXhwb3J0e3UgYXMganN4LGwgYXMganN4QXR0cix1IGFzIGpzeERFVixfIGFzIGpzeEVzY2FwZSxhIGFzIGpzeFRlbXBsYXRlLHUgYXMganN4c307XG4vLyMgc291cmNlTWFwcGluZ1VSTD1qc3hSdW50aW1lLm1vZHVsZS5qcy5tYXBcbiIsIlxuICAgICAgaW1wb3J0IEFQSSBmcm9tIFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiO1xuICAgICAgaW1wb3J0IGRvbUFQSSBmcm9tIFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3N0eWxlRG9tQVBJLmpzXCI7XG4gICAgICBpbXBvcnQgaW5zZXJ0Rm4gZnJvbSBcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRCeVNlbGVjdG9yLmpzXCI7XG4gICAgICBpbXBvcnQgc2V0QXR0cmlidXRlcyBmcm9tIFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3NldEF0dHJpYnV0ZXNXaXRob3V0QXR0cmlidXRlcy5qc1wiO1xuICAgICAgaW1wb3J0IGluc2VydFN0eWxlRWxlbWVudCBmcm9tIFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydFN0eWxlRWxlbWVudC5qc1wiO1xuICAgICAgaW1wb3J0IHN0eWxlVGFnVHJhbnNmb3JtRm4gZnJvbSBcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZVRhZ1RyYW5zZm9ybS5qc1wiO1xuICAgICAgaW1wb3J0IGNvbnRlbnQsICogYXMgbmFtZWRFeHBvcnQgZnJvbSBcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vZ2xvYmFscy5jc3NcIjtcbiAgICAgIFxuICAgICAgXG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuc3R5bGVUYWdUcmFuc2Zvcm0gPSBzdHlsZVRhZ1RyYW5zZm9ybUZuO1xub3B0aW9ucy5zZXRBdHRyaWJ1dGVzID0gc2V0QXR0cmlidXRlcztcblxuICAgICAgb3B0aW9ucy5pbnNlcnQgPSBpbnNlcnRGbi5iaW5kKG51bGwsIFwiaGVhZFwiKTtcbiAgICBcbm9wdGlvbnMuZG9tQVBJID0gZG9tQVBJO1xub3B0aW9ucy5pbnNlcnRTdHlsZUVsZW1lbnQgPSBpbnNlcnRTdHlsZUVsZW1lbnQ7XG5cbnZhciB1cGRhdGUgPSBBUEkoY29udGVudCwgb3B0aW9ucyk7XG5cblxuaWYgKG1vZHVsZS5ob3QpIHtcbiAgaWYgKCFjb250ZW50LmxvY2FscyB8fCBtb2R1bGUuaG90LmludmFsaWRhdGUpIHtcbiAgICB2YXIgaXNFcXVhbExvY2FscyA9IGZ1bmN0aW9uIGlzRXF1YWxMb2NhbHMoYSwgYiwgaXNOYW1lZEV4cG9ydCkge1xuICBpZiAoIWEgJiYgYiB8fCBhICYmICFiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwO1xuICBmb3IgKHAgaW4gYSkge1xuICAgIGlmIChpc05hbWVkRXhwb3J0ICYmIHAgPT09IFwiZGVmYXVsdFwiKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udGludWVcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoYVtwXSAhPT0gYltwXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBmb3IgKHAgaW4gYikge1xuICAgIGlmIChpc05hbWVkRXhwb3J0ICYmIHAgPT09IFwiZGVmYXVsdFwiKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udGludWVcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoIWFbcF0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuICAgIHZhciBpc05hbWVkRXhwb3J0ID0gIWNvbnRlbnQubG9jYWxzO1xuICAgIHZhciBvbGRMb2NhbHMgPSBpc05hbWVkRXhwb3J0ID8gbmFtZWRFeHBvcnQgOiBjb250ZW50LmxvY2FscztcblxuICAgIG1vZHVsZS5ob3QuYWNjZXB0KFxuICAgICAgXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL2dsb2JhbHMuY3NzXCIsXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghaXNFcXVhbExvY2FscyhvbGRMb2NhbHMsIGlzTmFtZWRFeHBvcnQgPyBuYW1lZEV4cG9ydCA6IGNvbnRlbnQubG9jYWxzLCBpc05hbWVkRXhwb3J0KSkge1xuICAgICAgICAgICAgICAgIG1vZHVsZS5ob3QuaW52YWxpZGF0ZSgpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgb2xkTG9jYWxzID0gaXNOYW1lZEV4cG9ydCA/IG5hbWVkRXhwb3J0IDogY29udGVudC5sb2NhbHM7XG5cbiAgICAgICAgICAgICAgdXBkYXRlKGNvbnRlbnQpO1xuICAgICAgfVxuICAgIClcbiAgfVxuXG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHtcbiAgICB1cGRhdGUoKTtcbiAgfSk7XG59XG5cblxuZXhwb3J0ICogZnJvbSBcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vZ2xvYmFscy5jc3NcIjtcbiAgICAgICBleHBvcnQgZGVmYXVsdCBjb250ZW50ICYmIGNvbnRlbnQubG9jYWxzID8gY29udGVudC5sb2NhbHMgOiB1bmRlZmluZWQ7XG4iLCJcbiAgICAgIGltcG9ydCBBUEkgZnJvbSBcIiEuLi8uLi8uLi9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiO1xuICAgICAgaW1wb3J0IGRvbUFQSSBmcm9tIFwiIS4uLy4uLy4uL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc3R5bGVEb21BUEkuanNcIjtcbiAgICAgIGltcG9ydCBpbnNlcnRGbiBmcm9tIFwiIS4uLy4uLy4uL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5zZXJ0QnlTZWxlY3Rvci5qc1wiO1xuICAgICAgaW1wb3J0IHNldEF0dHJpYnV0ZXMgZnJvbSBcIiEuLi8uLi8uLi9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3NldEF0dHJpYnV0ZXNXaXRob3V0QXR0cmlidXRlcy5qc1wiO1xuICAgICAgaW1wb3J0IGluc2VydFN0eWxlRWxlbWVudCBmcm9tIFwiIS4uLy4uLy4uL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5zZXJ0U3R5bGVFbGVtZW50LmpzXCI7XG4gICAgICBpbXBvcnQgc3R5bGVUYWdUcmFuc2Zvcm1GbiBmcm9tIFwiIS4uLy4uLy4uL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc3R5bGVUYWdUcmFuc2Zvcm0uanNcIjtcbiAgICAgIGltcG9ydCBjb250ZW50LCAqIGFzIG5hbWVkRXhwb3J0IGZyb20gXCIhIS4uLy4uLy4uL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vLi4vcG9zdGNzcy1sb2FkZXIvZGlzdC9janMuanMhLi9mbGlja2luZy5jc3NcIjtcbiAgICAgIFxuICAgICAgXG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuc3R5bGVUYWdUcmFuc2Zvcm0gPSBzdHlsZVRhZ1RyYW5zZm9ybUZuO1xub3B0aW9ucy5zZXRBdHRyaWJ1dGVzID0gc2V0QXR0cmlidXRlcztcblxuICAgICAgb3B0aW9ucy5pbnNlcnQgPSBpbnNlcnRGbi5iaW5kKG51bGwsIFwiaGVhZFwiKTtcbiAgICBcbm9wdGlvbnMuZG9tQVBJID0gZG9tQVBJO1xub3B0aW9ucy5pbnNlcnRTdHlsZUVsZW1lbnQgPSBpbnNlcnRTdHlsZUVsZW1lbnQ7XG5cbnZhciB1cGRhdGUgPSBBUEkoY29udGVudCwgb3B0aW9ucyk7XG5cblxuaWYgKG1vZHVsZS5ob3QpIHtcbiAgaWYgKCFjb250ZW50LmxvY2FscyB8fCBtb2R1bGUuaG90LmludmFsaWRhdGUpIHtcbiAgICB2YXIgaXNFcXVhbExvY2FscyA9IGZ1bmN0aW9uIGlzRXF1YWxMb2NhbHMoYSwgYiwgaXNOYW1lZEV4cG9ydCkge1xuICBpZiAoIWEgJiYgYiB8fCBhICYmICFiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwO1xuICBmb3IgKHAgaW4gYSkge1xuICAgIGlmIChpc05hbWVkRXhwb3J0ICYmIHAgPT09IFwiZGVmYXVsdFwiKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udGludWVcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoYVtwXSAhPT0gYltwXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBmb3IgKHAgaW4gYikge1xuICAgIGlmIChpc05hbWVkRXhwb3J0ICYmIHAgPT09IFwiZGVmYXVsdFwiKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udGludWVcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoIWFbcF0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuICAgIHZhciBpc05hbWVkRXhwb3J0ID0gIWNvbnRlbnQubG9jYWxzO1xuICAgIHZhciBvbGRMb2NhbHMgPSBpc05hbWVkRXhwb3J0ID8gbmFtZWRFeHBvcnQgOiBjb250ZW50LmxvY2FscztcblxuICAgIG1vZHVsZS5ob3QuYWNjZXB0KFxuICAgICAgXCIhIS4uLy4uLy4uL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vLi4vcG9zdGNzcy1sb2FkZXIvZGlzdC9janMuanMhLi9mbGlja2luZy5jc3NcIixcbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFpc0VxdWFsTG9jYWxzKG9sZExvY2FscywgaXNOYW1lZEV4cG9ydCA/IG5hbWVkRXhwb3J0IDogY29udGVudC5sb2NhbHMsIGlzTmFtZWRFeHBvcnQpKSB7XG4gICAgICAgICAgICAgICAgbW9kdWxlLmhvdC5pbnZhbGlkYXRlKCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBvbGRMb2NhbHMgPSBpc05hbWVkRXhwb3J0ID8gbmFtZWRFeHBvcnQgOiBjb250ZW50LmxvY2FscztcblxuICAgICAgICAgICAgICB1cGRhdGUoY29udGVudCk7XG4gICAgICB9XG4gICAgKVxuICB9XG5cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkge1xuICAgIHVwZGF0ZSgpO1xuICB9KTtcbn1cblxuXG5leHBvcnQgKiBmcm9tIFwiISEuLi8uLi8uLi9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uLy4uL3Bvc3Rjc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vZmxpY2tpbmcuY3NzXCI7XG4gICAgICAgZXhwb3J0IGRlZmF1bHQgY29udGVudCAmJiBjb250ZW50LmxvY2FscyA/IGNvbnRlbnQubG9jYWxzIDogdW5kZWZpbmVkO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBzdHlsZXNJbkRPTSA9IFtdO1xuZnVuY3Rpb24gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcikge1xuICB2YXIgcmVzdWx0ID0gLTE7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzSW5ET00ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoc3R5bGVzSW5ET01baV0uaWRlbnRpZmllciA9PT0gaWRlbnRpZmllcikge1xuICAgICAgcmVzdWx0ID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbW9kdWxlc1RvRG9tKGxpc3QsIG9wdGlvbnMpIHtcbiAgdmFyIGlkQ291bnRNYXAgPSB7fTtcbiAgdmFyIGlkZW50aWZpZXJzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gbGlzdFtpXTtcbiAgICB2YXIgaWQgPSBvcHRpb25zLmJhc2UgPyBpdGVtWzBdICsgb3B0aW9ucy5iYXNlIDogaXRlbVswXTtcbiAgICB2YXIgY291bnQgPSBpZENvdW50TWFwW2lkXSB8fCAwO1xuICAgIHZhciBpZGVudGlmaWVyID0gXCJcIi5jb25jYXQoaWQsIFwiIFwiKS5jb25jYXQoY291bnQpO1xuICAgIGlkQ291bnRNYXBbaWRdID0gY291bnQgKyAxO1xuICAgIHZhciBpbmRleEJ5SWRlbnRpZmllciA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgIHZhciBvYmogPSB7XG4gICAgICBjc3M6IGl0ZW1bMV0sXG4gICAgICBtZWRpYTogaXRlbVsyXSxcbiAgICAgIHNvdXJjZU1hcDogaXRlbVszXSxcbiAgICAgIHN1cHBvcnRzOiBpdGVtWzRdLFxuICAgICAgbGF5ZXI6IGl0ZW1bNV1cbiAgICB9O1xuICAgIGlmIChpbmRleEJ5SWRlbnRpZmllciAhPT0gLTEpIHtcbiAgICAgIHN0eWxlc0luRE9NW2luZGV4QnlJZGVudGlmaWVyXS5yZWZlcmVuY2VzKys7XG4gICAgICBzdHlsZXNJbkRPTVtpbmRleEJ5SWRlbnRpZmllcl0udXBkYXRlcihvYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdXBkYXRlciA9IGFkZEVsZW1lbnRTdHlsZShvYmosIG9wdGlvbnMpO1xuICAgICAgb3B0aW9ucy5ieUluZGV4ID0gaTtcbiAgICAgIHN0eWxlc0luRE9NLnNwbGljZShpLCAwLCB7XG4gICAgICAgIGlkZW50aWZpZXI6IGlkZW50aWZpZXIsXG4gICAgICAgIHVwZGF0ZXI6IHVwZGF0ZXIsXG4gICAgICAgIHJlZmVyZW5jZXM6IDFcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZGVudGlmaWVycy5wdXNoKGlkZW50aWZpZXIpO1xuICB9XG4gIHJldHVybiBpZGVudGlmaWVycztcbn1cbmZ1bmN0aW9uIGFkZEVsZW1lbnRTdHlsZShvYmosIG9wdGlvbnMpIHtcbiAgdmFyIGFwaSA9IG9wdGlvbnMuZG9tQVBJKG9wdGlvbnMpO1xuICBhcGkudXBkYXRlKG9iaik7XG4gIHZhciB1cGRhdGVyID0gZnVuY3Rpb24gdXBkYXRlcihuZXdPYmopIHtcbiAgICBpZiAobmV3T2JqKSB7XG4gICAgICBpZiAobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJiBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJiBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwICYmIG5ld09iai5zdXBwb3J0cyA9PT0gb2JqLnN1cHBvcnRzICYmIG5ld09iai5sYXllciA9PT0gb2JqLmxheWVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGFwaS51cGRhdGUob2JqID0gbmV3T2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXBpLnJlbW92ZSgpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHVwZGF0ZXI7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChsaXN0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBsaXN0ID0gbGlzdCB8fCBbXTtcbiAgdmFyIGxhc3RJZGVudGlmaWVycyA9IG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZShuZXdMaXN0KSB7XG4gICAgbmV3TGlzdCA9IG5ld0xpc3QgfHwgW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW2ldO1xuICAgICAgdmFyIGluZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgICBzdHlsZXNJbkRPTVtpbmRleF0ucmVmZXJlbmNlcy0tO1xuICAgIH1cbiAgICB2YXIgbmV3TGFzdElkZW50aWZpZXJzID0gbW9kdWxlc1RvRG9tKG5ld0xpc3QsIG9wdGlvbnMpO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgX2lkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbX2ldO1xuICAgICAgdmFyIF9pbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKF9pZGVudGlmaWVyKTtcbiAgICAgIGlmIChzdHlsZXNJbkRPTVtfaW5kZXhdLnJlZmVyZW5jZXMgPT09IDApIHtcbiAgICAgICAgc3R5bGVzSW5ET01bX2luZGV4XS51cGRhdGVyKCk7XG4gICAgICAgIHN0eWxlc0luRE9NLnNwbGljZShfaW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH1cbiAgICBsYXN0SWRlbnRpZmllcnMgPSBuZXdMYXN0SWRlbnRpZmllcnM7XG4gIH07XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgbWVtbyA9IHt9O1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cbmZ1bmN0aW9uIGdldFRhcmdldCh0YXJnZXQpIHtcbiAgaWYgKHR5cGVvZiBtZW1vW3RhcmdldF0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB2YXIgc3R5bGVUYXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7XG5cbiAgICAvLyBTcGVjaWFsIGNhc2UgdG8gcmV0dXJuIGhlYWQgb2YgaWZyYW1lIGluc3RlYWQgb2YgaWZyYW1lIGl0c2VsZlxuICAgIGlmICh3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQgJiYgc3R5bGVUYXJnZXQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgYWNjZXNzIHRvIGlmcmFtZSBpcyBibG9ja2VkXG4gICAgICAgIC8vIGR1ZSB0byBjcm9zcy1vcmlnaW4gcmVzdHJpY3Rpb25zXG4gICAgICAgIHN0eWxlVGFyZ2V0ID0gc3R5bGVUYXJnZXQuY29udGVudERvY3VtZW50LmhlYWQ7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgIHN0eWxlVGFyZ2V0ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgbWVtb1t0YXJnZXRdID0gc3R5bGVUYXJnZXQ7XG4gIH1cbiAgcmV0dXJuIG1lbW9bdGFyZ2V0XTtcbn1cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBpbnNlcnRCeVNlbGVjdG9yKGluc2VydCwgc3R5bGUpIHtcbiAgdmFyIHRhcmdldCA9IGdldFRhcmdldChpbnNlcnQpO1xuICBpZiAoIXRhcmdldCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0JyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG4gIH1cbiAgdGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gaW5zZXJ0QnlTZWxlY3RvcjsiLCJcInVzZSBzdHJpY3RcIjtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucykge1xuICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgb3B0aW9ucy5zZXRBdHRyaWJ1dGVzKGVsZW1lbnQsIG9wdGlvbnMuYXR0cmlidXRlcyk7XG4gIG9wdGlvbnMuaW5zZXJ0KGVsZW1lbnQsIG9wdGlvbnMub3B0aW9ucyk7XG4gIHJldHVybiBlbGVtZW50O1xufVxubW9kdWxlLmV4cG9ydHMgPSBpbnNlcnRTdHlsZUVsZW1lbnQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gc2V0QXR0cmlidXRlc1dpdGhvdXRBdHRyaWJ1dGVzKHN0eWxlRWxlbWVudCkge1xuICB2YXIgbm9uY2UgPSB0eXBlb2YgX193ZWJwYWNrX25vbmNlX18gIT09IFwidW5kZWZpbmVkXCIgPyBfX3dlYnBhY2tfbm9uY2VfXyA6IG51bGw7XG4gIGlmIChub25jZSkge1xuICAgIHN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJub25jZVwiLCBub25jZSk7XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gc2V0QXR0cmlidXRlc1dpdGhvdXRBdHRyaWJ1dGVzOyIsIlwidXNlIHN0cmljdFwiO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cbmZ1bmN0aW9uIGFwcGx5KHN0eWxlRWxlbWVudCwgb3B0aW9ucywgb2JqKSB7XG4gIHZhciBjc3MgPSBcIlwiO1xuICBpZiAob2JqLnN1cHBvcnRzKSB7XG4gICAgY3NzICs9IFwiQHN1cHBvcnRzIChcIi5jb25jYXQob2JqLnN1cHBvcnRzLCBcIikge1wiKTtcbiAgfVxuICBpZiAob2JqLm1lZGlhKSB7XG4gICAgY3NzICs9IFwiQG1lZGlhIFwiLmNvbmNhdChvYmoubWVkaWEsIFwiIHtcIik7XG4gIH1cbiAgdmFyIG5lZWRMYXllciA9IHR5cGVvZiBvYmoubGF5ZXIgIT09IFwidW5kZWZpbmVkXCI7XG4gIGlmIChuZWVkTGF5ZXIpIHtcbiAgICBjc3MgKz0gXCJAbGF5ZXJcIi5jb25jYXQob2JqLmxheWVyLmxlbmd0aCA+IDAgPyBcIiBcIi5jb25jYXQob2JqLmxheWVyKSA6IFwiXCIsIFwiIHtcIik7XG4gIH1cbiAgY3NzICs9IG9iai5jc3M7XG4gIGlmIChuZWVkTGF5ZXIpIHtcbiAgICBjc3MgKz0gXCJ9XCI7XG4gIH1cbiAgaWYgKG9iai5tZWRpYSkge1xuICAgIGNzcyArPSBcIn1cIjtcbiAgfVxuICBpZiAob2JqLnN1cHBvcnRzKSB7XG4gICAgY3NzICs9IFwifVwiO1xuICB9XG4gIHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwO1xuICBpZiAoc291cmNlTWFwICYmIHR5cGVvZiBidG9hICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgY3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIi5jb25jYXQoYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSwgXCIgKi9cIik7XG4gIH1cblxuICAvLyBGb3Igb2xkIElFXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi9cbiAgb3B0aW9ucy5zdHlsZVRhZ1RyYW5zZm9ybShjc3MsIHN0eWxlRWxlbWVudCwgb3B0aW9ucy5vcHRpb25zKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpIHtcbiAgLy8gaXN0YW5idWwgaWdub3JlIGlmXG4gIGlmIChzdHlsZUVsZW1lbnQucGFyZW50Tm9kZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdHlsZUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQpO1xufVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cbmZ1bmN0aW9uIGRvbUFQSShvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUoKSB7fSxcbiAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge31cbiAgICB9O1xuICB9XG4gIHZhciBzdHlsZUVsZW1lbnQgPSBvcHRpb25zLmluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKTtcbiAgcmV0dXJuIHtcbiAgICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZShvYmopIHtcbiAgICAgIGFwcGx5KHN0eWxlRWxlbWVudCwgb3B0aW9ucywgb2JqKTtcbiAgICB9LFxuICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCk7XG4gICAgfVxuICB9O1xufVxubW9kdWxlLmV4cG9ydHMgPSBkb21BUEk7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gc3R5bGVUYWdUcmFuc2Zvcm0oY3NzLCBzdHlsZUVsZW1lbnQpIHtcbiAgaWYgKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgIHN0eWxlRWxlbWVudC5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCk7XG4gICAgfVxuICAgIHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBzdHlsZVRhZ1RyYW5zZm9ybTsiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IEJsb2NrMTtcbnZhciBqc3hfcnVudGltZV8xID0gcmVxdWlyZShcInByZWFjdC9qc3gtcnVudGltZVwiKTtcbnZhciBwcmVhY3Rfcm91dGVyXzEgPSByZXF1aXJlKFwicHJlYWN0LXJvdXRlclwiKTtcbnZhciBpbWFnZV9oZXJvX2pwZ18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi8uLi9hc3NldHMvZGVza3RvcC9pbWFnZS1oZXJvLmpwZ1wiKSk7XG52YXIgaW1hZ2VfaGVyb19qcGdfMiA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vYXNzZXRzL3RhYmxldC9pbWFnZS1oZXJvLmpwZ1wiKSk7XG52YXIgaW1hZ2VfaGVyb19qcGdfMyA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vYXNzZXRzL21vYmlsZS9pbWFnZS1oZXJvLmpwZ1wiKSk7XG52YXIgaXRlbXMgPSB7XG4gICAgdGl0bGU6ICdCcmFuZGluZyAmIHdlYnNpdGUgZGVzaWduIGFnZW5jeScsXG4gICAgZGVzY3JpcHRpb246ICdXZSBzcGVjaWFsaXplIGluIHZpc3VhbCBzdG9yeXRlbGxpbmcgYnkgY3JlYXRpbmcgY29oZXNpdmUgYnJhbmQgYW5kIHdlYnNpdGUgZGVzaWduIHNvbHV0aW9ucyBmb3Igc21hbGwgYnVzaW5lc3NlcywgZ2l2aW5nIGxhc3RpbmcgaW1wcmVzc2lvbnMgdG8gYXVkaWVuY2VzIGluIGEgZGlnaXRhbCB3b3JsZC4nLFxuICAgIGJ1dHRvbjogJ0xlYXJuIE1vcmUnLFxufTtcbnZhciBsaW5rSXRlbXMgPSB7XG4gICAgdGl0bGU6ICdMZWFybiBNb3JlJyxcbiAgICBocmVmOiAnIycsXG59O1xuZnVuY3Rpb24gQmxvY2sxKCkge1xuICAgIHJldHVybiAoKDAsIGpzeF9ydW50aW1lXzEuanN4cykoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwicmVsYXRpdmUgbWItWzk2cHhdIGZsZXggdy1mdWxsIG1heC13LVtjYWxjKDEyNzVweCszOXB4KV0gZmxleC1jb2wtcmV2ZXJzZSBpdGVtcy1jZW50ZXIganVzdGlmeS1iZXR3ZWVuIG1kOm1iLTAgbWQ6aC1bNjA2cHhdIG1kOmZsZXgtcm93IG1kOml0ZW1zLXN0YXJ0IG1kOnNlbGYtZW5kIG1kOnBsLVszOXB4XSB4bDpoLVs4MDBweF1cIiwgY2hpbGRyZW46IFsoMCwganN4X3J1bnRpbWVfMS5qc3hzKShcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJyZWxhdGl2ZSB6LVsxXSBtdC1bNTZweF0gZmxleCB3LWZpdCBtYXgtdy1bNzMwcHhdIGZsZXgtY29sIGl0ZW1zLWNlbnRlciBnYXAtWzQwcHhdIHB4LVsyNHB4XSBtZDptdC1bNzdweF0gbWQ6dy1mdWxsIG1kOml0ZW1zLXN0YXJ0IG1kOmdhcC1bNDhweF0gbWQ6cHgtMCB4bDptdC1bMTEycHhdXCIsIGNoaWxkcmVuOiBbKDAsIGpzeF9ydW50aW1lXzEuanN4cykoXCJzZWN0aW9uXCIsIHsgY2xhc3NOYW1lOiBcImZsZXggZmxleC1jb2wgZ2FwLVsyMHB4XSBtZDpnYXAtWzM5cHhdXCIsIGNoaWxkcmVuOiBbKDAsIGpzeF9ydW50aW1lXzEuanN4KShcImgxXCIsIHsgY2xhc3NOYW1lOiBcInctZnVsbCBtZDptYXgtdy1bMzk4cHhdIHhsOm1heC13LVs2ODBweF1cIiwgY2hpbGRyZW46IGl0ZW1zLnRpdGxlIH0pLCAoMCwganN4X3J1bnRpbWVfMS5qc3gpKFwicFwiLCB7IGNsYXNzTmFtZTogXCJ3LWZ1bGwgbWQ6bWF4LXctWzM5OHB4XSB4bDptYXgtdy1bNTQwcHhdXCIsIGNoaWxkcmVuOiBpdGVtcy5kZXNjcmlwdGlvbiB9KV0gfSksICgwLCBqc3hfcnVudGltZV8xLmpzeCkocHJlYWN0X3JvdXRlcl8xLkxpbmssIHsgY2xhc3NOYW1lOiBcImZsZXggaC1bNzJweF0gdy1bMTc3cHhdIGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciBzZWxmLXN0YXJ0IGJnLVsjRjk0RjRGXSB0ZXh0LVsxOHB4XSBmb250LWV4dHJhYm9sZCB0ZXh0LXdoaXRlIHRyYW5zaXRpb24gaG92ZXI6YmctWyNGRjkzOTNdXCIsIGhyZWY6IGxpbmtJdGVtcy5ocmVmLCBjaGlsZHJlbjogbGlua0l0ZW1zLnRpdGxlIH0pXSB9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4cykoXCJwaWN0dXJlXCIsIHsgY2xhc3NOYW1lOiBcInJpZ2h0LTAgdy1mdWxsIG1kOmFic29sdXRlIG1kOmgtWzYwOHB4XSBtZDp3LWZpdCB4bDpoLVs4MDBweF1cIiwgY2hpbGRyZW46IFsoMCwganN4X3J1bnRpbWVfMS5qc3gpKFwic291cmNlXCIsIHsgbWVkaWE6IFwiKG1heC13aWR0aDogNzY4cHgpXCIsIHNyY1NldDogaW1hZ2VfaGVyb19qcGdfMy5kZWZhdWx0IH0pLCAoMCwganN4X3J1bnRpbWVfMS5qc3gpKFwic291cmNlXCIsIHsgbWVkaWE6IFwiKG1heC13aWR0aDogMTAyNHB4KVwiLCBzcmNTZXQ6IGltYWdlX2hlcm9fanBnXzIuZGVmYXVsdCB9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4KShcImltZ1wiLCB7IGNsYXNzTmFtZTogXCJtZDpvYmplY3QtZml0IHNpemUtZnVsbCBvYmplY3QtY292ZXIgbWQ6aC1bNjA2cHhdIHhsOmgtWzgwMHB4XVwiLCBzcmM6IGltYWdlX2hlcm9fanBnXzEuZGVmYXVsdCwgYWx0OiBcIm1lbiB3b3JraW5nIG9uIGNvbXB1dGVyc1wiIH0pXSB9KV0gfSkpO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBCbG9jazI7XG52YXIganN4X3J1bnRpbWVfMSA9IHJlcXVpcmUoXCJwcmVhY3QvanN4LXJ1bnRpbWVcIik7XG52YXIgcHJlYWN0X3JvdXRlcl8xID0gcmVxdWlyZShcInByZWFjdC1yb3V0ZXJcIik7XG52YXIgaW1hZ2Vfc3RyYXRlZ2ljX2pwZ18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi8uLi9hc3NldHMvZGVza3RvcC9pbWFnZS1zdHJhdGVnaWMuanBnXCIpKTtcbnZhciBpbWFnZV9zdHJhdGVnaWNfanBnXzIgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uLy4uL2Fzc2V0cy9tb2JpbGUvaW1hZ2Utc3RyYXRlZ2ljLmpwZ1wiKSk7XG52YXIgYmdfcGF0dGVybl93YXZlX3JlZF9zdmdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vYXNzZXRzL2Rlc2t0b3AvYmctcGF0dGVybi13YXZlLXJlZC5zdmdcIikpO1xudmFyIGl0ZW1zID0ge1xuICAgIHRpdGxlOiAnRGVzaWduIGlzIHN0cmF0ZWdpYy4nLFxuICAgIGRlc2NyaXB0aW9uOiAn4oCcQSB3ZWxsLWNyYWZ0ZWQgZGVzaWduIHN0cmF0ZWd5IGNvbnNpc3RlbnRseSBwcm9kdWNlcyBkZXNpcmVkIG91dGNvbWVzIGFuZCBicmFuZCBhd2FyZW5lc3MuIFdlIGFyZSBmaXJtIGJlbGlldmVycyB0aGF0IHN1Y2Nlc3MgbGllcyBpbiBjcmVhdGl2ZSBjb2xsYWJvcmF0aW9uIHdpdGggb3VyIGNsaWVudHMu4oCdJyxcbiAgICBsaW5rVGl0bGU6ICdTY2hlZHVsZSBhIENhbGwnLFxufTtcbmZ1bmN0aW9uIEJsb2NrMigpIHtcbiAgICByZXR1cm4gKCgwLCBqc3hfcnVudGltZV8xLmpzeHMpKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJlbGF0aXZlIGZsZXggdy1mdWxsIGZsZXgtY29sIG1kOmgtWzY0OHB4XSBtZDpmbGV4LXJvdyAgbWQ6anVzdGlmeS1lbmQgbGc6aC1bNzUwcHhdIHhsOmgtWzk4NHB4XVwiLCBjaGlsZHJlbjogWygwLCBqc3hfcnVudGltZV8xLmpzeHMpKFwicGljdHVyZVwiLCB7IGNoaWxkcmVuOiBbKDAsIGpzeF9ydW50aW1lXzEuanN4KShcInNvdXJjZVwiLCB7IG1lZGlhOiBcIihtYXgtd2lkdGg6IDc2OHB4KVwiLCBzcmNTZXQ6IGltYWdlX3N0cmF0ZWdpY19qcGdfMi5kZWZhdWx0IH0pLCAoMCwganN4X3J1bnRpbWVfMS5qc3gpKFwiaW1nXCIsIHsgY2xhc3NOYW1lOiBcImxlZnQtMCBvYmplY3QtY292ZXIgbWQ6YWJzb2x1dGUgbWQ6aC1bNjU4cHhdIG1kOnctWzczNXB4XSBtZDpvYmplY3QtWzEwMCVfMCVdIHhsOmgtWzk4NHB4XSB4bDpvYmplY3QtY2VudGVyXCIsIGhlaWdodDogOTg0LCB3aWR0aDogNzM1LCBzcmM6IGltYWdlX3N0cmF0ZWdpY19qcGdfMS5kZWZhdWx0LCBhbHQ6IFwic3RyYXRlZ2ljXCIgfSldIH0pLCAoMCwganN4X3J1bnRpbWVfMS5qc3gpKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJlbGF0aXZlIGZsZXggaXRlbXMtY2VudGVyIGJnLVsjMTkxOTIxXSBweS1bNzJweF0gbWQ6aC1bNTM4cHhdIG1kOnctWzM5MHB4XSBtZDpweS0wIG1kOnBsLVs2OXB4XSBtZDpwci1bNDBweF0gbGc6aC1bNTYwcHhdIGxnOnctWzUzMHB4XSBsZzpwbC1bOTBweF0gbGc6cHItWzYwcHhdIHhsOmgtWzc4NHB4XSB4bDp3LVs3MDVweF0geGw6cGwtWzE1NHB4XSB4bDpwci1bMTA2cHhdXCIsIGNoaWxkcmVuOiAoMCwganN4X3J1bnRpbWVfMS5qc3hzKShcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmbGV4IGZsZXgtY29sIGdhcC1bNDhweF0gcHgtWzI0cHhdIG1kOnB4LTBcIiwgY2hpbGRyZW46IFsoMCwganN4X3J1bnRpbWVfMS5qc3gpKFwiaW1nXCIsIHsgY2xhc3NOYW1lOiBcImFic29sdXRlIHRvcC1bLTE1cHhdIGgtWzI4cHhdIHctWzYycHhdIG1kOmxlZnQtWy0zMXB4XSBtZDp0b3AtWzIyMHB4XSB4bDpsZWZ0LVstNjdweF0geGw6dG9wLVsyMzRweF0geGw6aC1bNjFweF0geGw6dy1bMTM1cHhdXCIsIHdpZHRoOiAxMzUsIGhlaWdodDogNjEsIHNyYzogYmdfcGF0dGVybl93YXZlX3JlZF9zdmdfMS5kZWZhdWx0LCBhbHQ6IFwicGF0dGVyblwiIH0pLCAoMCwganN4X3J1bnRpbWVfMS5qc3hzKShcInNlY3Rpb25cIiwgeyBjbGFzc05hbWU6IFwiZmxleCBmbGV4LWNvbCBnYXAtWzMycHhdIG1kOm1heC13LVsyODFweF0gbGc6bWF4LXctZnVsbCB4bDpnYXAtWzQzcHhdXCIsIGNoaWxkcmVuOiBbKDAsIGpzeF9ydW50aW1lXzEuanN4cykoXCJoMlwiLCB7IGNsYXNzTmFtZTogXCJ0ZXh0LXdoaXRlIG1kOm1heC13LVsyNTBweF0gbGc6bWF4LXctZnVsbFwiLCBjaGlsZHJlbjogWygwLCBqc3hfcnVudGltZV8xLmpzeCkoXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBcInRleHQtWyNGOTRGNEZdXCIsIGNoaWxkcmVuOiBpdGVtcy50aXRsZS5zcGxpdCgnICcpWzBdIH0pLCBcIiBcIi5jb25jYXQoaXRlbXMudGl0bGUuc3BsaXQoJyAnKS5zbGljZSgxKS5qb2luKCcgJykpXSB9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4KShcInBcIiwgeyBjbGFzc05hbWU6IFwidGV4dC13aGl0ZVwiLCBjaGlsZHJlbjogaXRlbXMuZGVzY3JpcHRpb24gfSldIH0pLCAoMCwganN4X3J1bnRpbWVfMS5qc3gpKHByZWFjdF9yb3V0ZXJfMS5MaW5rLCB7IGNsYXNzTmFtZTogXCJmb250LWV4dHJhYm9sZCB0ZXh0LVsjRjk0RjRGXSB1bmRlcmxpbmUgdW5kZXJsaW5lLW9mZnNldC1bMTJweF0gdHJhbnNpdGlvbiBob3Zlcjp0ZXh0LVsjRkY5MzkzXVwiLCBocmVmOiBcIiNcIiwgY2hpbGRyZW46IGl0ZW1zLmxpbmtUaXRsZSB9KV0gfSkgfSldIH0pKTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gQmxvY2szO1xudmFyIGpzeF9ydW50aW1lXzEgPSByZXF1aXJlKFwicHJlYWN0L2pzeC1ydW50aW1lXCIpO1xudmFyIHRpdGxlID0gJ091ciBhcHByb2FjaCBmb3IgY3JlYXRpbmcgYSB3aW5uaW5nIGJyYW5kJztcbnZhciBpdGVtcyA9IFtcbiAgICB7XG4gICAgICAgIHRpdGxlOiAnQnJhbmQgU3RyYXRlZ3knLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ0JyYW5kIHN0cmF0ZWd5IGlzIGNyaXRpY2FsIGZvciBsb25nLXRlcm0gc3VjY2Vzcy4gT3V0c2hpbmluZyBjb21wZXRpdG9ycyBhbmQgY2FwdHVyaW5nIHRoZSB0YXJnZXQgYXVkaWVuY2UgYXJlIGtleS4nLFxuICAgIH0sXG4gICAge1xuICAgICAgICB0aXRsZTogJ0JyYW5kIERlc2lnbicsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnS2VlcGluZyB0aGUgYnJhbmQgZGVzaWduIHVuaXF1ZSBhbmQgbWVhbmluZ2Z1bCBoZWxwcyBpbiBjb21tdW5pY2F0aW5nIHRoZSBicmFuZOKAmXMgdGltZWxlc3MgdmFsdWUgZWZmZWN0aXZlbHkuJyxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgdGl0bGU6ICdXZWIgRGVzaWduJyxcbiAgICAgICAgZGVzY3JpcHRpb246ICdBIGJlYXV0aWZ1bGx5IGNyYWZ0ZWQgd2Vic2l0ZSBpcyB0aGUgYmVzdCB0b29sIGZvciBicmFuZCBhd2FyZW5lc3MsIGFuZCB1bHRpbWF0ZWx5IHJlc3VsdHMgaW4gaW5jcmVhc2VkIHJldmVudWVzLiAnLFxuICAgIH0sXG5dO1xuZnVuY3Rpb24gQmxvY2szKCkge1xuICAgIHJldHVybiAoKDAsIGpzeF9ydW50aW1lXzEuanN4cykoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmxleCB3LWZ1bGwgZmxleC1jb2wganVzdGlmeS1iZXR3ZWVuIG1kOmZsZXgtcm93IHhsOmp1c3RpZnktZW5kIHhsOnBsLVszOXB4XVwiLCBjaGlsZHJlbjogWygwLCBqc3hfcnVudGltZV8xLmpzeCkoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwicmVsYXRpdmUgei1bMl0gZmxleCB3LWZ1bGwganVzdGlmeS1jZW50ZXIgcHgtWzI0cHhdIGxnOnB4LTAgeGw6bXItWy0xNjBweF0geGw6dy1maXRcIiwgY2hpbGRyZW46ICgwLCBqc3hfcnVudGltZV8xLmpzeCkoXCJoMlwiLCB7IGNsYXNzTmFtZTogXCJ6LVsyXSBoLWZpdCB3LWZ1bGwgbWF4LXctWzI4MXB4XSBtZDptdC1bMTIwcHhdIGxnOm10LTAgeGw6bXQtWzIwMHB4XSB4bDptYXgtdy1bNTQwcHhdIHhsOnBsLTBcIiwgY2hpbGRyZW46IHRpdGxlIH0pIH0pLCAoMCwganN4X3J1bnRpbWVfMS5qc3gpKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInotWzFdIGZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIGJnLVsjRjk0RjRGXSBtZDptdC1bLTEyMHB4XSBtZDpoLVs3OTdweF0gbWQ6dy1bMTQwMHB4XSBsZzptdC1bLTIwMHB4XSB4bDpoLVsxMTAwcHhdIHhsOnctWzg5NXB4XSB4bDpqdXN0aWZ5LWVuZCB4bDpwci1bMTA2cHhdXCIsIGNoaWxkcmVuOiAoMCwganN4X3J1bnRpbWVfMS5qc3gpKFwidWxcIiwgeyBjbGFzc05hbWU6IFwiZmxleCBmbGV4LWNvbCBnYXAtWzQwcHhdIHhsOmdhcC1bNTZweF1cIiwgY2hpbGRyZW46IGl0ZW1zLm1hcChmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHsgcmV0dXJuICgoMCwganN4X3J1bnRpbWVfMS5qc3hzKShcImxpXCIsIHsgY2xhc3NOYW1lOiBcImZsZXggZmxleC1jb2wgZ2FwLVsyNHB4XSBtZDpoLVsyMDBweF0gbWQ6dy1bMzU1cHhdIHhsOnctWzUwNHB4XVwiLCBjaGlsZHJlbjogWygwLCBqc3hfcnVudGltZV8xLmpzeCkoXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBcImFic29sdXRlIHRleHQtWzgwcHhdIGZvbnQtZXh0cmFib2xkIGxlYWRpbmctWzg4cHhdIHRleHQtd2hpdGUvMjVcIiwgY2hpbGRyZW46IChpbmRleCArIDEpLnRvTG9jYWxlU3RyaW5nKCdlbi1VUycsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbmltdW1JbnRlZ2VyRGlnaXRzOiAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlR3JvdXBpbmc6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSB9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4cykoXCJzZWN0aW9uXCIsIHsgY2xhc3NOYW1lOiBcIm1sLVs1OXB4XSBtdC1bNDRweF0gZmxleCBmbGV4LWNvbCBnYXAtWzI0cHhdXCIsIGNoaWxkcmVuOiBbKDAsIGpzeF9ydW50aW1lXzEuanN4KShcImgzXCIsIHsgY2xhc3NOYW1lOiBcInRleHQtd2hpdGVcIiwgY2hpbGRyZW46IGl0ZW0udGl0bGUgfSksICgwLCBqc3hfcnVudGltZV8xLmpzeCkoXCJwXCIsIHsgY2xhc3NOYW1lOiBcInRleHQtd2hpdGVcIiwgY2hpbGRyZW46IGl0ZW0uZGVzY3JpcHRpb24gfSldIH0pXSB9LCBpdGVtKSk7IH0pIH0pIH0pXSB9KSk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbnZhciBfYTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IEJsb2NrNDtcbnZhciBqc3hfcnVudGltZV8xID0gcmVxdWlyZShcInByZWFjdC9qc3gtcnVudGltZVwiKTtcbnZhciBpbWFnZV9zbGlkZV8xX2pwZ18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi8uLi9hc3NldHMvZGVza3RvcC9pbWFnZS1zbGlkZS0xLmpwZ1wiKSk7XG52YXIgaW1hZ2Vfc2xpZGVfMl9qcGdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vYXNzZXRzL2Rlc2t0b3AvaW1hZ2Utc2xpZGUtMi5qcGdcIikpO1xudmFyIGltYWdlX3NsaWRlXzNfanBnXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uLy4uL2Fzc2V0cy9kZXNrdG9wL2ltYWdlLXNsaWRlLTMuanBnXCIpKTtcbnZhciBiZ19wYXR0ZXJuX3dhdnlfd2hpdGVfc3ZnXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uLy4uL2Fzc2V0cy9kZXNrdG9wL2JnLXBhdHRlcm4td2F2eS13aGl0ZS5zdmdcIikpO1xudmFyIGhvb2tzXzEgPSByZXF1aXJlKFwicHJlYWN0L2hvb2tzXCIpO1xudmFyIHByZWFjdF9mbGlja2luZ18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJAZWdqcy9wcmVhY3QtZmxpY2tpbmdcIikpO1xucmVxdWlyZShcIkBlZ2pzL3ByZWFjdC1mbGlja2luZy9kaXN0L2ZsaWNraW5nLmNzc1wiKTtcbnZhciBUaXRsZUtleTtcbihmdW5jdGlvbiAoVGl0bGVLZXkpIHtcbiAgICBUaXRsZUtleVtUaXRsZUtleVtcImd1aWRlbGluZXNcIl0gPSAwXSA9IFwiZ3VpZGVsaW5lc1wiO1xuICAgIFRpdGxlS2V5W1RpdGxlS2V5W1wibWVyY2hhbmRpc2VcIl0gPSAxXSA9IFwibWVyY2hhbmRpc2VcIjtcbiAgICBUaXRsZUtleVtUaXRsZUtleVtcImRlc2lnblwiXSA9IDJdID0gXCJkZXNpZ25cIjtcbn0pKFRpdGxlS2V5IHx8IChUaXRsZUtleSA9IHt9KSk7XG52YXIgdGl0bGUgPSAoX2EgPSB7fSxcbiAgICBfYVtUaXRsZUtleS5ndWlkZWxpbmVzXSA9IHtcbiAgICAgICAgbWFpblRpdGxlOiAnQnJhbmQgbmFtaW5nICYgZ3VpZGVsaW5lcycsXG4gICAgICAgIHRpdGxlOiAnTGVhbiBQcm9kdWN0IFJvYWRtYXAnLFxuICAgICAgICBkZXNjcmlwdGlvbjogJzIwMTkgUHJvamVjdCcsXG4gICAgfSxcbiAgICBfYVtUaXRsZUtleS5tZXJjaGFuZGlzZV0gPSB7XG4gICAgICAgIG1haW5UaXRsZTogJ0JyYW5kIGlkZW50aXR5ICYgbWVyY2hhbmRpc2UnLFxuICAgICAgICB0aXRsZTogJ05ldyBNYWplc3RpYyBIb3RlbCcsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnMjAxOCBQcm9qZWN0JyxcbiAgICB9LFxuICAgIF9hW1RpdGxlS2V5LmRlc2lnbl0gPSB7XG4gICAgICAgIG1haW5UaXRsZTogJ0JyYW5kIGlkZW50aXR5ICYgd2ViIGRlc2lnbicsXG4gICAgICAgIHRpdGxlOiAnQ3J5cHRvIERhc2hib2FyZCcsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnMjAxNiBQcm9qZWN0JyxcbiAgICB9LFxuICAgIF9hKTtcbnZhciB0aXRsZXNCdXR0b25zID0ge1xuICAgIHByZXZpb3VzOiAncHJldmlvdXMgc2xpZGUnLFxuICAgIG5leHQ6ICduZXh0IHNsaWRlJyxcbn07XG5mdW5jdGlvbiBCbG9jazQoKSB7XG4gICAgdmFyIGZsaWNraW5nID0gKDAsIGhvb2tzXzEudXNlUmVmKSgpO1xuICAgIHZhciBtYWluVGl0bGVSZWYgPSAoMCwgaG9va3NfMS51c2VSZWYpKG51bGwpO1xuICAgIHZhciBzZWN0aW9uUmVmID0gKDAsIGhvb2tzXzEudXNlUmVmKShudWxsKTtcbiAgICB2YXIgX2EgPSAoMCwgaG9va3NfMS51c2VTdGF0ZSkoVGl0bGVLZXkuZ3VpZGVsaW5lcyksIGN1cnJlbnRTbGlkZSA9IF9hWzBdLCBzZXRDdXJyZW50U2xpZGUgPSBfYVsxXTtcbiAgICB2YXIgX2IgPSAoMCwgaG9va3NfMS51c2VTdGF0ZSkoZmFsc2UpLCBpc1BsYXlpbmcgPSBfYlswXSwgc2V0SXNQbGF5aW5nID0gX2JbMV07XG4gICAgcmV0dXJuICgoMCwganN4X3J1bnRpbWVfMS5qc3hzKShcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJyZWxhdGl2ZSBmbGV4IHctZnVsbCBmbGV4LWNvbC1yZXZlcnNlIGp1c3RpZnktc3RhcnQgbWQ6bWluLWgtWzQ3MnB4XSBtZDpmbGV4LXJvdyB4bDptaW4taC1bNzI4cHhdXCIsIGNoaWxkcmVuOiBbKDAsIGpzeF9ydW50aW1lXzEuanN4cykoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwicmVsYXRpdmUgei1bMV0gZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgYmctWyMxOTE5MjFdIHBsLVs0MHB4XSBtZDpoLVszNTJweF0gbWQ6dy0xLzIgbWQ6bWF4LXctWzczNXB4XSB4bDpoLVs1MjhweF1cIiwgY2hpbGRyZW46IFsoMCwganN4X3J1bnRpbWVfMS5qc3gpKFwiaW1nXCIsIHsgYWx0OiBcInBhdHRlcm5cIiwgY2xhc3NOYW1lOiBcImFic29sdXRlIHJpZ2h0LVstMzFweF0gdG9wLVsxMjZweF0gei1bMl0gaGlkZGVuIGgtWzI4cHhdIHctWzYycHhdIG1kOmJsb2NrIHhsOnJpZ2h0LVstNjdweF0geGw6dG9wLVsxODZweF0geGw6aC1bNjBweF0geGw6dy1bMTM0cHhdXCIsIHNyYzogYmdfcGF0dGVybl93YXZ5X3doaXRlX3N2Z18xLmRlZmF1bHQsIHdpZHRoOiAxMzQsIGhlaWdodDogNjAgfSksICgwLCBqc3hfcnVudGltZV8xLmpzeHMpKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZsZXggaC1bMjMzcHhdIHctWzM5MHB4XSBmbGV4LWNvbCBqdXN0aWZ5LWNlbnRlciBnYXAtWzUxcHhdIHhsOnctWzQ0NXB4XVwiLCBjaGlsZHJlbjogWygwLCBqc3hfcnVudGltZV8xLmpzeCkoXCJoMlwiLCB7IHJlZjogbWFpblRpdGxlUmVmLCBjbGFzc05hbWU6IFwiYW5pbWF0aW9uRWxlbWVudCBtYXgtdy1bMjgxcHhdIHRleHQtd2hpdGUgeGw6bWF4LXctZnVsbFwiLCBjaGlsZHJlbjogdGl0bGVbY3VycmVudFNsaWRlXS5tYWluVGl0bGUgfSksICgwLCBqc3hfcnVudGltZV8xLmpzeHMpKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZsZXggZ2FwLVsxNnB4XVwiLCBjaGlsZHJlbjogWygwLCBqc3hfcnVudGltZV8xLmpzeCkoXCJidXR0b25cIiwgeyBkaXNhYmxlZDogaXNQbGF5aW5nLCBvbkNsaWNrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdm9pZCAoKF9hID0gZmxpY2tpbmcuY3VycmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnByZXYoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgdGl0bGU6IFwicHJldmlvdXMgc2xpZGVcIiwgdHlwZTogXCJidXR0b25cIiwgY2xhc3NOYW1lOiBcInByZXZpb3VzIHJlbGF0aXZlIHotNDAgc2l6ZS1bNDBweF1cIiwgY2hpbGRyZW46ICgwLCBqc3hfcnVudGltZV8xLmpzeHMpKFwic3ZnXCIsIHsgd2lkdGg6IFwiNDBcIiwgaGVpZ2h0OiBcIjQwXCIsIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIGNoaWxkcmVuOiBbKDAsIGpzeF9ydW50aW1lXzEuanN4KShcInRpdGxlXCIsIHsgY2hpbGRyZW46IHRpdGxlc0J1dHRvbnMucHJldmlvdXMgfSksICgwLCBqc3hfcnVudGltZV8xLmpzeHMpKFwiZ1wiLCB7IHRyYW5zZm9ybTogXCJtYXRyaXgoLTEgMCAwIDEgNDAgMClcIiwgZmlsbDogXCJub25lXCIsIGZpbGxSdWxlOiBcImV2ZW5vZGRcIiwgY2hpbGRyZW46IFsoMCwganN4X3J1bnRpbWVfMS5qc3gpKFwiY2lyY2xlXCIsIHsgY3g6IFwiMjBcIiwgY3k6IFwiMjBcIiwgcjogXCIxOS41XCIgfSksICgwLCBqc3hfcnVudGltZV8xLmpzeCkoXCJwYXRoXCIsIHsgc3Ryb2tlV2lkdGg6IFwiMlwiLCBkOiBcIk0xNy41IDE1bDUgNS01IDVcIiB9KV0gfSldIH0pIH0pLCAoMCwganN4X3J1bnRpbWVfMS5qc3gpKFwiYnV0dG9uXCIsIHsgZGlzYWJsZWQ6IGlzUGxheWluZywgb25DbGljazogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZvaWQgKChfYSA9IGZsaWNraW5nLmN1cnJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5uZXh0KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHRpdGxlOiBcIm5leHQgc2xpZGVcIiwgdHlwZTogXCJidXR0b25cIiwgY2xhc3NOYW1lOiBcInByZXZpb3VzIHJlbGF0aXZlIHotNDAgc2l6ZS1bNDBweF1cIiwgY2hpbGRyZW46ICgwLCBqc3hfcnVudGltZV8xLmpzeHMpKFwic3ZnXCIsIHsgd2lkdGg6IFwiNDBcIiwgaGVpZ2h0OiBcIjQwXCIsIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIGNoaWxkcmVuOiBbKDAsIGpzeF9ydW50aW1lXzEuanN4KShcInRpdGxlXCIsIHsgY2hpbGRyZW46IHRpdGxlc0J1dHRvbnMubmV4dCB9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4cykoXCJnXCIsIHsgZmlsbDogXCJub25lXCIsIGZpbGxSdWxlOiBcImV2ZW5vZGRcIiwgY2hpbGRyZW46IFsoMCwganN4X3J1bnRpbWVfMS5qc3gpKFwiY2lyY2xlXCIsIHsgY3g6IFwiMjBcIiwgY3k6IFwiMjBcIiwgcjogXCIxOS41XCIgfSksICgwLCBqc3hfcnVudGltZV8xLmpzeCkoXCJwYXRoXCIsIHsgc3Ryb2tlV2lkdGg6IFwiMlwiLCBkOiBcIk0xNy41IDE1bDUgNS01IDVcIiB9KV0gfSldIH0pIH0pXSB9KV0gfSldIH0pLCAoMCwganN4X3J1bnRpbWVfMS5qc3hzKShcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJyZWxhdGl2ZSByaWdodC0wIHotMCBtZDphYnNvbHV0ZSBtZDp3LTMvNSB4bDpoLVs3MjhweF0geGw6dy1bODk1cHhdIFwiLCBjaGlsZHJlbjogWygwLCBqc3hfcnVudGltZV8xLmpzeHMpKHByZWFjdF9mbGlja2luZ18xLmRlZmF1bHQsIHsgb25Nb3ZlU3RhcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldElzUGxheWluZyh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoX2EgPSBtYWluVGl0bGVSZWYuY3VycmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNsYXNzTGlzdC5hZGQoJ2FuaW1hdGVUcmFuc2l0aW9uJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKF9iID0gc2VjdGlvblJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2xhc3NMaXN0LmFkZCgnYW5pbWF0ZVRyYW5zaXRpb24nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIG9uTW92ZUVuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0SXNQbGF5aW5nKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoX2EgPSBtYWluVGl0bGVSZWYuY3VycmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNsYXNzTGlzdC5yZW1vdmUoJ2FuaW1hdGVUcmFuc2l0aW9uJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKF9iID0gc2VjdGlvblJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2xhc3NMaXN0LnJlbW92ZSgnYW5pbWF0ZVRyYW5zaXRpb24nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHJlZjogZmxpY2tpbmcsIGNpcmN1bGFyOiB0cnVlLCBvbkNoYW5nZWQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0Q3VycmVudFNsaWRlKGUuaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgY2hpbGRyZW46IFsoMCwganN4X3J1bnRpbWVfMS5qc3gpKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInBhbmVsIGltYWdlLWNvbnRhaW5lclwiLCBjaGlsZHJlbjogKDAsIGpzeF9ydW50aW1lXzEuanN4KShcImltZ1wiLCB7IGNsYXNzTmFtZTogXCJjYXJvdXNlbEltYWdlXCIsIHNyYzogaW1hZ2Vfc2xpZGVfMV9qcGdfMS5kZWZhdWx0LCBhbHQ6IFwiU2xpZGUgMVwiIH0pIH0sIFRpdGxlS2V5Lmd1aWRlbGluZXMpLCAoMCwganN4X3J1bnRpbWVfMS5qc3gpKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInBhbmVsIGltYWdlLWNvbnRhaW5lclwiLCBjaGlsZHJlbjogKDAsIGpzeF9ydW50aW1lXzEuanN4KShcImltZ1wiLCB7IGNsYXNzTmFtZTogXCJjYXJvdXNlbEltYWdlXCIsIHNyYzogaW1hZ2Vfc2xpZGVfMl9qcGdfMS5kZWZhdWx0LCBhbHQ6IFwiU2xpZGUgMlwiIH0pIH0sIFRpdGxlS2V5Lm1lcmNoYW5kaXNlKSwgKDAsIGpzeF9ydW50aW1lXzEuanN4KShcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJwYW5lbCBpbWFnZS1jb250YWluZXJcIiwgY2hpbGRyZW46ICgwLCBqc3hfcnVudGltZV8xLmpzeCkoXCJpbWdcIiwgeyBjbGFzc05hbWU6IFwiY2Fyb3VzZWxJbWFnZVwiLCBzcmM6IGltYWdlX3NsaWRlXzNfanBnXzEuZGVmYXVsdCwgYWx0OiBcIlNsaWRlIDNcIiB9KSB9LCBUaXRsZUtleS5kZXNpZ24pXSB9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4cykoXCJzZWN0aW9uXCIsIHsgcmVmOiBzZWN0aW9uUmVmLCBjbGFzc05hbWU6IFwiYW5pbWF0aW9uRWxlbWVudCBhYnNvbHV0ZSBib3R0b20tWzQ1cHhdIHJpZ2h0LVs0MHB4XSB6LVsxXSBmbGV4IGZsZXgtY29sIHRleHQtZW5kIHhsOmJvdHRvbS1bNjhweF0geGw6cmlnaHQtWzE1NHB4XVwiLCBjaGlsZHJlbjogWygwLCBqc3hfcnVudGltZV8xLmpzeCkoXCJoM1wiLCB7IGNsYXNzTmFtZTogXCJ0ZXh0LXdoaXRlXCIsIGNoaWxkcmVuOiB0aXRsZVtjdXJyZW50U2xpZGVdLnRpdGxlIH0pLCAoMCwganN4X3J1bnRpbWVfMS5qc3gpKFwicFwiLCB7IGNsYXNzTmFtZTogXCJ0ZXh0LXdoaXRlXCIsIGNoaWxkcmVuOiB0aXRsZVtjdXJyZW50U2xpZGVdLmRlc2NyaXB0aW9uIH0pXSB9KV0gfSldIH0pKTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gRm9vdGVyO1xudmFyIGpzeF9ydW50aW1lXzEgPSByZXF1aXJlKFwicHJlYWN0L2pzeC1ydW50aW1lXCIpO1xudmFyIGJnX3BhdHRlcm5fd2F2ZV9yZWRfc3ZnXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uLy4uL2Fzc2V0cy9kZXNrdG9wL2JnLXBhdHRlcm4td2F2ZS1yZWQuc3ZnXCIpKTtcbnZhciBpdGVtcyA9IHtcbiAgICB0aXRsZTogJ0xldOKAmXMgYnVpbGQgc29tZXRoaW5nIGdyZWF0IHRvZ2V0aGVyLicsXG4gICAgYnV0dG9uRGVzY3JpcHRpb246ICdTY2hlZHVsZSBhIENhbGwnLFxufTtcbmZ1bmN0aW9uIEZvb3RlcigpIHtcbiAgICByZXR1cm4gKCgwLCBqc3hfcnVudGltZV8xLmpzeHMpKFwiZm9vdGVyXCIsIHsgY2xhc3NOYW1lOiBcIm14LWF1dG8gbWItWzEwMXB4XSBtdC1bMTAwcHhdIGZsZXggdy1mdWxsIG1heC13LVsxMzQycHhdIGl0ZW1zLWNlbnRlciBvdmVyZmxvdy1oaWRkZW4gcHgtWzI0cHhdIG1kOm10LVs3MHB4XSBtZDpweC1bNDBweF0geGw6bWItWzExNXB4XSB4bDptbC1bLTY3cHhdIHhsOm10LVsxMjBweF0geGw6cHgtMFwiLCBjaGlsZHJlbjogWygwLCBqc3hfcnVudGltZV8xLmpzeCkoXCJpbWdcIiwgeyBjbGFzc05hbWU6IFwiaGlkZGVuIHhsOmJsb2NrXCIsIGFsdDogXCJwYXR0ZXJuXCIsIHNyYzogYmdfcGF0dGVybl93YXZlX3JlZF9zdmdfMS5kZWZhdWx0LCB3aWR0aDogMTM0LCBoZWlnaHQ6IDYwIH0pLCAoMCwganN4X3J1bnRpbWVfMS5qc3hzKShcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmbGV4IHctZnVsbCBmbGV4LWNvbCBqdXN0aWZ5LWJldHdlZW4gZ2FwLVs0N3B4XSBtZDpmbGV4LXJvdyBtZDppdGVtcy1jZW50ZXIgeGw6bWwtWzk4cHhdXCIsIGNoaWxkcmVuOiBbKDAsIGpzeF9ydW50aW1lXzEuanN4KShcImgyXCIsIHsgY2xhc3NOYW1lOiBcIm1kOm1heC13LVszOThweF0geGw6bWF4LXctWzYzNXB4XVwiLCBjaGlsZHJlbjogaXRlbXMudGl0bGUgfSksICgwLCBqc3hfcnVudGltZV8xLmpzeCkoXCJidXR0b25cIiwgeyB0eXBlOiBcImJ1dHRvblwiLCBjbGFzc05hbWU6IFwiaC1bNjRweF0gdy1bMTk5cHhdIGJnLVsjRjk0RjRGXSB0ZXh0LVsxNnB4XSBmb250LWV4dHJhYm9sZCB0ZXh0LXdoaXRlIHRyYW5zaXRpb24gaG92ZXI6YmctWyNGRjkzOTNdXCIsIGNoaWxkcmVuOiBpdGVtcy5idXR0b25EZXNjcmlwdGlvbiB9KV0gfSldIH0pKTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gTmF2YmFyO1xudmFyIGpzeF9ydW50aW1lXzEgPSByZXF1aXJlKFwicHJlYWN0L2pzeC1ydW50aW1lXCIpO1xudmFyIGhvb2tzXzEgPSByZXF1aXJlKFwicHJlYWN0L2hvb2tzXCIpO1xudmFyIGxvZ29fc3ZnXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uLy4uL2Fzc2V0cy9kZXNrdG9wL2xvZ28uc3ZnXCIpKTtcbnZhciBwcmVhY3Rfcm91dGVyXzEgPSByZXF1aXJlKFwicHJlYWN0LXJvdXRlclwiKTtcbnZhciBpdGVtcyA9IFtcbiAgICB7XG4gICAgICAgIHRpdGxlOiAnQWJvdXQnLFxuICAgICAgICBocmVmOiAnIycsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHRpdGxlOiAnU2VydmljZScsXG4gICAgICAgIGhyZWY6ICcjJyxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgdGl0bGU6ICdQcm9qZWN0cycsXG4gICAgICAgIGhyZWY6ICcjJyxcbiAgICB9LFxuXTtcbnZhciBidXR0b25UaXRsZSA9ICdTY2hlZHVsZSBhIENhbGwnO1xuZnVuY3Rpb24gTmF2YmFyKCkge1xuICAgIHZhciBtZW51QnV0dG9uUmVmID0gKDAsIGhvb2tzXzEudXNlUmVmKShudWxsKTtcbiAgICBmdW5jdGlvbiBoYW5kbGVPcGVuKCkge1xuICAgICAgICBpZiAobWVudUJ1dHRvblJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICBtZW51QnV0dG9uUmVmLmN1cnJlbnQuY2xhc3NMaXN0LnRvZ2dsZSgnb3BlbicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAoKDAsIGpzeF9ydW50aW1lXzEuanN4cykoXCJuYXZcIiwgeyBjbGFzc05hbWU6IFwicmVsYXRpdmUgei1bMl0gZmxleCBoLVsxMTBweF0gdy1mdWxsIG1heC13LVtjYWxjKDEyNzVweCszOXB4KV0gaXRlbXMtY2VudGVyIGp1c3RpZnktYmV0d2VlbiBzZWxmLWVuZCBvdmVyZmxvdy14LWNsaXAgcGwtWzM5cHhdIG1kOmgtWzE3OHB4XVwiLCBjaGlsZHJlbjogWygwLCBqc3hfcnVudGltZV8xLmpzeCkoXCJkaXZcIiwgeyBpZDogXCJtYXNrXCIsIGNsYXNzTmFtZTogXCJmaXhlZCBsZWZ0LTAgdG9wLTAgei1bMV0gZmxleCBzaXplLWZ1bGxcIiB9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4cykoXCJkaXZcIiwgeyBpZDogXCJtb2JpbGVNZW51XCIsIGNsYXNzTmFtZTogXCJhYnNvbHV0ZSByaWdodC1bMjZweF0gdG9wLVsxMTBweF0gei00MCBmbGV4IGgtWzI5MnB4XSB3LWZ1bGwgbWF4LXctWzI1MnB4XSBmbGV4LWNvbCBpdGVtcy1jZW50ZXIgZ2FwLVsyNHB4XSBiZy1ibGFjayBwdC1bMzJweF1cIiwgY2hpbGRyZW46IFsoMCwganN4X3J1bnRpbWVfMS5qc3gpKFwidWxcIiwgeyBjbGFzc05hbWU6IFwiIHJlbGF0aXZlIHotNDAgZmxleCBmbGV4LWNvbCBpdGVtcy1jZW50ZXIgZ2FwLVsyNHB4XVwiLCBjaGlsZHJlbjogaXRlbXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiAoKDAsIGpzeF9ydW50aW1lXzEuanN4KShcImxpXCIsIHsgY2xhc3NOYW1lOiBcInJlbGF0aXZlIHotNDBcIiwgY2hpbGRyZW46ICgwLCBqc3hfcnVudGltZV8xLmpzeCkocHJlYWN0X3JvdXRlcl8xLkxpbmssIHsgY2xhc3NOYW1lOiBcIiByZWxhdGl2ZSB6LTQwIHRleHQtWzE4cHhdIGxlYWRpbmctWzMycHhdIHRleHQtd2hpdGUgdHJhbnNpdGlvbi1hbGxcIiwgaHJlZjogaXRlbS5ocmVmLCBjaGlsZHJlbjogaXRlbS50aXRsZSB9KSB9LCBpdGVtLnRpdGxlKSk7IH0pIH0pLCAoMCwganN4X3J1bnRpbWVfMS5qc3gpKFwiYnV0dG9uXCIsIHsgdHlwZTogXCJidXR0b25cIiwgY2xhc3NOYW1lOiBcInJlbGF0aXZlIHotNDAgaC1bNjRweF0gdy1bMTk5cHhdIGJnLVsjRjk0RjRGXSB0ZXh0LVsxNnB4XSBmb250LWV4dHJhYm9sZCB0ZXh0LXdoaXRlXCIsIGNoaWxkcmVuOiBidXR0b25UaXRsZSB9KV0gfSksICgwLCBqc3hfcnVudGltZV8xLmpzeCkoXCJpbWdcIiwgeyBjbGFzc05hbWU6IFwicmVsYXRpdmUgLXotMCBmbGV4XCIsIHNyYzogbG9nb19zdmdfMS5kZWZhdWx0LCBhbHQ6IFwibG9nb1wiIH0pLCAoMCwganN4X3J1bnRpbWVfMS5qc3hzKShcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJoaWRkZW4gc2l6ZS1mdWxsIG1heC13LVs0MzhweF0gaXRlbXMtY2VudGVyIGdhcC1bMjhweF0gYmctWyNGOTRGNEZdIHBsLVszM3B4XSBwci1bNDBweF0gbWQ6ZmxleCBsZzptYXgtdy1bNTMwcHhdIGxnOmdhcC1bNTBweF0gbGc6cHItWzIwcHhdIHhsOm1heC13LVs0N3Z3XSB4bDpnYXAtWzQ4cHhdIHhsOnBsLVs2OXB4XSB4bDpwci0wIHNjcmVlbjE1MDA6bWF4LXctWzcwNXB4XVwiLCBjaGlsZHJlbjogWygwLCBqc3hfcnVudGltZV8xLmpzeCkoXCJ1bFwiLCB7IGNsYXNzTmFtZTogXCJmbGV4IHctZnVsbCBtYXgtdy1bMTkwcHhdIGp1c3RpZnktYmV0d2VlbiB4bDptYXgtdy1bMjI1cHhdXCIsIGNoaWxkcmVuOiBpdGVtcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuICgoMCwganN4X3J1bnRpbWVfMS5qc3gpKFwibGlcIiwgeyBjaGlsZHJlbjogKDAsIGpzeF9ydW50aW1lXzEuanN4KShwcmVhY3Rfcm91dGVyXzEuTGluaywgeyBjbGFzc05hbWU6IFwiIGxlYWRpbmctWzMycHhdIHRleHQtd2hpdGUgdHJhbnNpdGlvbi1hbGwgaG92ZXI6Zm9udC1ib2xkXCIsIGhyZWY6IGl0ZW0uaHJlZiwgY2hpbGRyZW46IGl0ZW0udGl0bGUgfSkgfSwgaXRlbS50aXRsZSkpOyB9KSB9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4KShcImJ1dHRvblwiLCB7IHR5cGU6IFwiYnV0dG9uXCIsIGNsYXNzTmFtZTogXCJoLVs2NHB4XSBtaW4tdy1bMTQ3cHhdIGJnLVsjMTkxOTIxXSB0ZXh0LVsxNnB4XSBmb250LWV4dHJhYm9sZCB0ZXh0LXdoaXRlIHRyYW5zaXRpb24gaG92ZXI6YmctWyM0MzQzNTZdIHhsOm1pbi13LVsxOTlweF1cIiwgY2hpbGRyZW46IGJ1dHRvblRpdGxlIH0pXSB9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4KShcImJ1dHRvblwiLCB7IHJlZjogbWVudUJ1dHRvblJlZiwgb25DbGljazogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVPcGVuKCk7XG4gICAgICAgICAgICAgICAgfSwgaWQ6IFwibW9iaWxlTmF2XCIsIHRpdGxlOiBcIm1vYmlsZSBuYXZpZ2F0aW9uXCIsIHR5cGU6IFwiYnV0dG9uXCIsIGNsYXNzTmFtZTogXCJhYnNvbHV0ZSByaWdodC1bMjRweF0gei1bMl0gbWQ6b3BhY2l0eS0wXCIgfSldIH0pKTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGpzeF9ydW50aW1lXzEgPSByZXF1aXJlKFwicHJlYWN0L2pzeC1ydW50aW1lXCIpO1xudmFyIHByZWFjdF8xID0gcmVxdWlyZShcInByZWFjdFwiKTtcbi8vIGltcG9ydCBEYXRhQ29udGV4dCBmcm9tICcuL19saWIvRGF0YUNvbnRleHQnOyAvLyBwbGFjZWhvbGRlclxudmFyIE5hdmJhcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2NvbXBvbmVudHMvTmF2YmFyXCIpKTtcbnZhciBwYWdlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vcGFnZVwiKSk7XG52YXIgRm9vdGVyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vY29tcG9uZW50cy9Gb290ZXJcIikpO1xucmVxdWlyZShcIi4vZ2xvYmFscy5jc3NcIik7XG5kb2N1bWVudC5ib2R5LmNsYXNzTmFtZSA9XG4gICAgJ21pbi1oLWR2aCBteC1hdXRvIG1kOm1pbi1oLXNjcmVlbiBtYXgtdy1bMTQ0MHB4XSAgZmxleCBmbGV4LWNvbCBpdGVtcy1jZW50ZXIgZm9udC1jb21taXNzaW9uZXIganVzdGlmeS1zcGFjZS1iZXR3ZWVuJztcbmZ1bmN0aW9uIEFwcCgpIHtcbiAgICByZXR1cm4gKCgwLCBqc3hfcnVudGltZV8xLmpzeHMpKGpzeF9ydW50aW1lXzEuRnJhZ21lbnQsIHsgY2hpbGRyZW46IFsoMCwganN4X3J1bnRpbWVfMS5qc3gpKE5hdmJhcl8xLmRlZmF1bHQsIHt9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4KShcIm1haW5cIiwgeyBjbGFzc05hbWU6IFwibXgtYXV0byBtYi1hdXRvIGZsZXggIHctZnVsbCBmbGV4LWNvbCBpdGVtcy1jZW50ZXIgb3ZlcmZsb3cteC1jbGlwXCIsIGNoaWxkcmVuOiAoMCwganN4X3J1bnRpbWVfMS5qc3gpKHBhZ2VfMS5kZWZhdWx0LCB7fSkgfSksICgwLCBqc3hfcnVudGltZV8xLmpzeCkoRm9vdGVyXzEuZGVmYXVsdCwge30pXSB9KSk7XG59XG5mdW5jdGlvbiBCb2R5KCkge1xuICAgIHJldHVybiAoMCwganN4X3J1bnRpbWVfMS5qc3gpKEFwcCwge30pO1xufVxuKDAsIHByZWFjdF8xLnJlbmRlcikoKDAsIGpzeF9ydW50aW1lXzEuanN4KShCb2R5LCB7fSksIGRvY3VtZW50LmJvZHkpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIganN4X3J1bnRpbWVfMSA9IHJlcXVpcmUoXCJwcmVhY3QvanN4LXJ1bnRpbWVcIik7XG52YXIgQmxvY2sxXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vY29tcG9uZW50cy9CbG9jazFcIikpO1xudmFyIEJsb2NrMl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2NvbXBvbmVudHMvQmxvY2syXCIpKTtcbnZhciBCbG9jazNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9jb21wb25lbnRzL0Jsb2NrM1wiKSk7XG52YXIgQmxvY2s0XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vY29tcG9uZW50cy9CbG9jazRcIikpO1xudmFyIEhvbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICgoMCwganN4X3J1bnRpbWVfMS5qc3hzKShqc3hfcnVudGltZV8xLkZyYWdtZW50LCB7IGNoaWxkcmVuOiBbKDAsIGpzeF9ydW50aW1lXzEuanN4KShCbG9jazFfMS5kZWZhdWx0LCB7fSksICgwLCBqc3hfcnVudGltZV8xLmpzeCkoQmxvY2syXzEuZGVmYXVsdCwge30pLCAoMCwganN4X3J1bnRpbWVfMS5qc3gpKEJsb2NrM18xLmRlZmF1bHQsIHt9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4KShCbG9jazRfMS5kZWZhdWx0LCB7fSldIH0pKTtcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBIb21lO1xuIiwiaW1wb3J0e2NyZWF0ZUNvbnRleHQgYXMgbixDb21wb25lbnQgYXMgdCx0b0NoaWxkQXJyYXkgYXMgcixjbG9uZUVsZW1lbnQgYXMgaSxoIGFzIG99ZnJvbVwicHJlYWN0XCI7aW1wb3J0e3VzZUNvbnRleHQgYXMgZSx1c2VTdGF0ZSBhcyB1LHVzZUVmZmVjdCBhcyBmfWZyb21cInByZWFjdC9ob29rc1wiO3ZhciBhPXt9O2Z1bmN0aW9uIGMobix0KXtmb3IodmFyIHIgaW4gdCluW3JdPXRbcl07cmV0dXJuIG59ZnVuY3Rpb24gcyhuLHQscil7dmFyIGksbz0vKD86XFw/KFteI10qKSk/KCMuKik/JC8sZT1uLm1hdGNoKG8pLHU9e307aWYoZSYmZVsxXSlmb3IodmFyIGY9ZVsxXS5zcGxpdChcIiZcIiksYz0wO2M8Zi5sZW5ndGg7YysrKXt2YXIgcz1mW2NdLnNwbGl0KFwiPVwiKTt1W2RlY29kZVVSSUNvbXBvbmVudChzWzBdKV09ZGVjb2RlVVJJQ29tcG9uZW50KHMuc2xpY2UoMSkuam9pbihcIj1cIikpfW49ZChuLnJlcGxhY2UobyxcIlwiKSksdD1kKHR8fFwiXCIpO2Zvcih2YXIgaD1NYXRoLm1heChuLmxlbmd0aCx0Lmxlbmd0aCksdj0wO3Y8aDt2KyspaWYodFt2XSYmXCI6XCI9PT10W3ZdLmNoYXJBdCgwKSl7dmFyIGw9dFt2XS5yZXBsYWNlKC8oXjp8WysqP10rJCkvZyxcIlwiKSxwPSh0W3ZdLm1hdGNoKC9bKyo/XSskLyl8fGEpWzBdfHxcIlwiLG09fnAuaW5kZXhPZihcIitcIikseT1+cC5pbmRleE9mKFwiKlwiKSxVPW5bdl18fFwiXCI7aWYoIVUmJiF5JiYocC5pbmRleE9mKFwiP1wiKTwwfHxtKSl7aT0hMTticmVha31pZih1W2xdPWRlY29kZVVSSUNvbXBvbmVudChVKSxtfHx5KXt1W2xdPW4uc2xpY2UodikubWFwKGRlY29kZVVSSUNvbXBvbmVudCkuam9pbihcIi9cIik7YnJlYWt9fWVsc2UgaWYodFt2XSE9PW5bdl0pe2k9ITE7YnJlYWt9cmV0dXJuKCEwPT09ci5kZWZhdWx0fHwhMSE9PWkpJiZ1fWZ1bmN0aW9uIGgobix0KXtyZXR1cm4gbi5yYW5rPHQucmFuaz8xOm4ucmFuaz50LnJhbms/LTE6bi5pbmRleC10LmluZGV4fWZ1bmN0aW9uIHYobix0KXtyZXR1cm4gbi5pbmRleD10LG4ucmFuaz1mdW5jdGlvbihuKXtyZXR1cm4gbi5wcm9wcy5kZWZhdWx0PzA6ZChuLnByb3BzLnBhdGgpLm1hcChsKS5qb2luKFwiXCIpfShuKSxuLnByb3BzfWZ1bmN0aW9uIGQobil7cmV0dXJuIG4ucmVwbGFjZSgvKF5cXC8rfFxcLyskKS9nLFwiXCIpLnNwbGl0KFwiL1wiKX1mdW5jdGlvbiBsKG4pe3JldHVyblwiOlwiPT1uLmNoYXJBdCgwKT8xK1wiKis/XCIuaW5kZXhPZihuLmNoYXJBdChuLmxlbmd0aC0xKSl8fDQ6NX12YXIgcD17fSxtPVtdLHk9W10sVT1udWxsLGc9e3VybDpSKCl9LGs9bihnKTtmdW5jdGlvbiBDKCl7dmFyIG49ZShrKTtpZihuPT09Zyl7dmFyIHQ9dSgpWzFdO2YoZnVuY3Rpb24oKXtyZXR1cm4geS5wdXNoKHQpLGZ1bmN0aW9uKCl7cmV0dXJuIHkuc3BsaWNlKHkuaW5kZXhPZih0KSwxKX19LFtdKX1yZXR1cm5bbiwkXX1mdW5jdGlvbiBSKCl7dmFyIG47cmV0dXJuXCJcIisoKG49VSYmVS5sb2NhdGlvbj9VLmxvY2F0aW9uOlUmJlUuZ2V0Q3VycmVudExvY2F0aW9uP1UuZ2V0Q3VycmVudExvY2F0aW9uKCk6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGxvY2F0aW9uP2xvY2F0aW9uOnApLnBhdGhuYW1lfHxcIlwiKSsobi5zZWFyY2h8fFwiXCIpfWZ1bmN0aW9uICQobix0KXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9ITEpLFwic3RyaW5nXCIhPXR5cGVvZiBuJiZuLnVybCYmKHQ9bi5yZXBsYWNlLG49bi51cmwpLGZ1bmN0aW9uKG4pe2Zvcih2YXIgdD1tLmxlbmd0aDt0LS07KWlmKG1bdF0uY2FuUm91dGUobikpcmV0dXJuITA7cmV0dXJuITF9KG4pJiZmdW5jdGlvbihuLHQpe3ZvaWQgMD09PXQmJih0PVwicHVzaFwiKSxVJiZVW3RdP1VbdF0obik6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGhpc3RvcnkmJmhpc3RvcnlbdCtcIlN0YXRlXCJdJiZoaXN0b3J5W3QrXCJTdGF0ZVwiXShudWxsLG51bGwsbil9KG4sdD9cInJlcGxhY2VcIjpcInB1c2hcIiksSShuKX1mdW5jdGlvbiBJKG4pe2Zvcih2YXIgdD0hMSxyPTA7cjxtLmxlbmd0aDtyKyspbVtyXS5yb3V0ZVRvKG4pJiYodD0hMCk7cmV0dXJuIHR9ZnVuY3Rpb24gTShuKXtpZihuJiZuLmdldEF0dHJpYnV0ZSl7dmFyIHQ9bi5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpLHI9bi5nZXRBdHRyaWJ1dGUoXCJ0YXJnZXRcIik7aWYodCYmdC5tYXRjaCgvXlxcLy9nKSYmKCFyfHxyLm1hdGNoKC9eXz9zZWxmJC9pKSkpcmV0dXJuICQodCl9fWZ1bmN0aW9uIGIobil7cmV0dXJuIG4uc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uJiZuLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpLG4uc3RvcFByb3BhZ2F0aW9uJiZuLnN0b3BQcm9wYWdhdGlvbigpLG4ucHJldmVudERlZmF1bHQoKSwhMX1mdW5jdGlvbiBXKG4pe2lmKCEobi5jdHJsS2V5fHxuLm1ldGFLZXl8fG4uYWx0S2V5fHxuLnNoaWZ0S2V5fHxuLmJ1dHRvbikpe3ZhciB0PW4udGFyZ2V0O2Rve2lmKFwiYVwiPT09dC5sb2NhbE5hbWUmJnQuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSl7aWYodC5oYXNBdHRyaWJ1dGUoXCJkYXRhLW5hdGl2ZVwiKXx8dC5oYXNBdHRyaWJ1dGUoXCJuYXRpdmVcIikpcmV0dXJuO2lmKE0odCkpcmV0dXJuIGIobil9fXdoaWxlKHQ9dC5wYXJlbnROb2RlKX19dmFyIHc9ITE7ZnVuY3Rpb24gRChuKXtuLmhpc3RvcnkmJihVPW4uaGlzdG9yeSksdGhpcy5zdGF0ZT17dXJsOm4udXJsfHxSKCl9fWMoRC5wcm90b3R5cGU9bmV3IHQse3Nob3VsZENvbXBvbmVudFVwZGF0ZTpmdW5jdGlvbihuKXtyZXR1cm4hMCE9PW4uc3RhdGljfHxuLnVybCE9PXRoaXMucHJvcHMudXJsfHxuLm9uQ2hhbmdlIT09dGhpcy5wcm9wcy5vbkNoYW5nZX0sY2FuUm91dGU6ZnVuY3Rpb24obil7dmFyIHQ9cih0aGlzLnByb3BzLmNoaWxkcmVuKTtyZXR1cm4gdm9pZCAwIT09dGhpcy5nKHQsbil9LHJvdXRlVG86ZnVuY3Rpb24obil7dGhpcy5zZXRTdGF0ZSh7dXJsOm59KTt2YXIgdD10aGlzLmNhblJvdXRlKG4pO3JldHVybiB0aGlzLnB8fHRoaXMuZm9yY2VVcGRhdGUoKSx0fSxjb21wb25lbnRXaWxsTW91bnQ6ZnVuY3Rpb24oKXt0aGlzLnA9ITB9LGNvbXBvbmVudERpZE1vdW50OmZ1bmN0aW9uKCl7dmFyIG49dGhpczt3fHwodz0hMCxVfHxhZGRFdmVudExpc3RlbmVyKFwicG9wc3RhdGVcIixmdW5jdGlvbigpe0koUigpKX0pLGFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLFcpKSxtLnB1c2godGhpcyksVSYmKHRoaXMudT1VLmxpc3RlbihmdW5jdGlvbih0KXt2YXIgcj10LmxvY2F0aW9ufHx0O24ucm91dGVUbyhcIlwiKyhyLnBhdGhuYW1lfHxcIlwiKSsoci5zZWFyY2h8fFwiXCIpKX0pKSx0aGlzLnA9ITF9LGNvbXBvbmVudFdpbGxVbm1vdW50OmZ1bmN0aW9uKCl7XCJmdW5jdGlvblwiPT10eXBlb2YgdGhpcy51JiZ0aGlzLnUoKSxtLnNwbGljZShtLmluZGV4T2YodGhpcyksMSl9LGNvbXBvbmVudFdpbGxVcGRhdGU6ZnVuY3Rpb24oKXt0aGlzLnA9ITB9LGNvbXBvbmVudERpZFVwZGF0ZTpmdW5jdGlvbigpe3RoaXMucD0hMX0sZzpmdW5jdGlvbihuLHQpe249bi5maWx0ZXIodikuc29ydChoKTtmb3IodmFyIHI9MDtyPG4ubGVuZ3RoO3IrKyl7dmFyIGk9bltyXSxvPXModCxpLnByb3BzLnBhdGgsaS5wcm9wcyk7aWYobylyZXR1cm5baSxvXX19LHJlbmRlcjpmdW5jdGlvbihuLHQpe3ZhciBlLHUsZj1uLm9uQ2hhbmdlLGE9dC51cmwscz10aGlzLmMsaD10aGlzLmcocihuLmNoaWxkcmVuKSxhKTtpZihoJiYodT1pKGhbMF0sYyhjKHt1cmw6YSxtYXRjaGVzOmU9aFsxXX0sZSkse2tleTp2b2lkIDAscmVmOnZvaWQgMH0pKSksYSE9PShzJiZzLnVybCkpe2MoZyxzPXRoaXMuYz17dXJsOmEscHJldmlvdXM6cyYmcy51cmwsY3VycmVudDp1LHBhdGg6dT91LnByb3BzLnBhdGg6bnVsbCxtYXRjaGVzOmV9KSxzLnJvdXRlcj10aGlzLHMuYWN0aXZlPXU/W3VdOltdO2Zvcih2YXIgdj15Lmxlbmd0aDt2LS07KXlbdl0oe30pO1wiZnVuY3Rpb25cIj09dHlwZW9mIGYmJmYocyl9cmV0dXJuIG8oay5Qcm92aWRlcix7dmFsdWU6c30sdSl9fSk7dmFyIEU9ZnVuY3Rpb24obil7cmV0dXJuIG8oXCJhXCIsYyh7b25DbGljazpXfSxuKSl9LEw9ZnVuY3Rpb24obil7cmV0dXJuIG8obi5jb21wb25lbnQsbil9O2V4cG9ydHtFIGFzIExpbmssTCBhcyBSb3V0ZSxEIGFzIFJvdXRlcixEIGFzIGRlZmF1bHQscyBhcyBleGVjLFIgYXMgZ2V0Q3VycmVudFVybCwkIGFzIHJvdXRlLEMgYXMgdXNlUm91dGVyfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByZWFjdC1yb3V0ZXIubW9kdWxlLmpzLm1hcFxuIiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdGlmIChjYWNoZWRNb2R1bGUuZXJyb3IgIT09IHVuZGVmaW5lZCkgdGhyb3cgY2FjaGVkTW9kdWxlLmVycm9yO1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHRpZDogbW9kdWxlSWQsXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHR0cnkge1xuXHRcdHZhciBleGVjT3B0aW9ucyA9IHsgaWQ6IG1vZHVsZUlkLCBtb2R1bGU6IG1vZHVsZSwgZmFjdG9yeTogX193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0sIHJlcXVpcmU6IF9fd2VicGFja19yZXF1aXJlX18gfTtcblx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmkuZm9yRWFjaChmdW5jdGlvbihoYW5kbGVyKSB7IGhhbmRsZXIoZXhlY09wdGlvbnMpOyB9KTtcblx0XHRtb2R1bGUgPSBleGVjT3B0aW9ucy5tb2R1bGU7XG5cdFx0ZXhlY09wdGlvbnMuZmFjdG9yeS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBleGVjT3B0aW9ucy5yZXF1aXJlKTtcblx0fSBjYXRjaChlKSB7XG5cdFx0bW9kdWxlLmVycm9yID0gZTtcblx0XHR0aHJvdyBlO1xuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4vLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuX193ZWJwYWNrX3JlcXVpcmVfXy5tID0gX193ZWJwYWNrX21vZHVsZXNfXztcblxuLy8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbl9fd2VicGFja19yZXF1aXJlX18uYyA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfXztcblxuLy8gZXhwb3NlIHRoZSBtb2R1bGUgZXhlY3V0aW9uIGludGVyY2VwdG9yXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmkgPSBbXTtcblxuIiwiLy8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbl9fd2VicGFja19yZXF1aXJlX18ubiA9IChtb2R1bGUpID0+IHtcblx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG5cdFx0KCkgPT4gKG1vZHVsZVsnZGVmYXVsdCddKSA6XG5cdFx0KCkgPT4gKG1vZHVsZSk7XG5cdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsIHsgYTogZ2V0dGVyIH0pO1xuXHRyZXR1cm4gZ2V0dGVyO1xufTsiLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCIvLyBUaGlzIGZ1bmN0aW9uIGFsbG93IHRvIHJlZmVyZW5jZSBhbGwgY2h1bmtzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmh1ID0gKGNodW5rSWQpID0+IHtcblx0Ly8gcmV0dXJuIHVybCBmb3IgZmlsZW5hbWVzIGJhc2VkIG9uIHRlbXBsYXRlXG5cdHJldHVybiBcIlwiICsgY2h1bmtJZCArIFwiLlwiICsgX193ZWJwYWNrX3JlcXVpcmVfXy5oKCkgKyBcIi5ob3QtdXBkYXRlLmpzXCI7XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18uaG1yRiA9ICgpID0+IChcIm1haW4uXCIgKyBfX3dlYnBhY2tfcmVxdWlyZV9fLmgoKSArIFwiLmhvdC11cGRhdGUuanNvblwiKTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLmggPSAoKSA9PiAoXCI0NDgwOTliMTdkZDI1MWQzM2RlNlwiKSIsIl9fd2VicGFja19yZXF1aXJlX18uZyA9IChmdW5jdGlvbigpIHtcblx0aWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSAnb2JqZWN0JykgcmV0dXJuIGdsb2JhbFRoaXM7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIHRoaXMgfHwgbmV3IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcpIHJldHVybiB3aW5kb3c7XG5cdH1cbn0pKCk7IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSIsInZhciBpblByb2dyZXNzID0ge307XG52YXIgZGF0YVdlYnBhY2tQcmVmaXggPSBcImZsYXNrLXByZWFjdC10eXBlc2NyaXB0LXRhaWx3aW5kLXRlbXBsYXRlOlwiO1xuLy8gbG9hZFNjcmlwdCBmdW5jdGlvbiB0byBsb2FkIGEgc2NyaXB0IHZpYSBzY3JpcHQgdGFnXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmwgPSAodXJsLCBkb25lLCBrZXksIGNodW5rSWQpID0+IHtcblx0aWYoaW5Qcm9ncmVzc1t1cmxdKSB7IGluUHJvZ3Jlc3NbdXJsXS5wdXNoKGRvbmUpOyByZXR1cm47IH1cblx0dmFyIHNjcmlwdCwgbmVlZEF0dGFjaDtcblx0aWYoa2V5ICE9PSB1bmRlZmluZWQpIHtcblx0XHR2YXIgc2NyaXB0cyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic2NyaXB0XCIpO1xuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBzY3JpcHRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgcyA9IHNjcmlwdHNbaV07XG5cdFx0XHRpZihzLmdldEF0dHJpYnV0ZShcInNyY1wiKSA9PSB1cmwgfHwgcy5nZXRBdHRyaWJ1dGUoXCJkYXRhLXdlYnBhY2tcIikgPT0gZGF0YVdlYnBhY2tQcmVmaXggKyBrZXkpIHsgc2NyaXB0ID0gczsgYnJlYWs7IH1cblx0XHR9XG5cdH1cblx0aWYoIXNjcmlwdCkge1xuXHRcdG5lZWRBdHRhY2ggPSB0cnVlO1xuXHRcdHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuXG5cdFx0c2NyaXB0LmNoYXJzZXQgPSAndXRmLTgnO1xuXHRcdHNjcmlwdC50aW1lb3V0ID0gMTIwO1xuXHRcdGlmIChfX3dlYnBhY2tfcmVxdWlyZV9fLm5jKSB7XG5cdFx0XHRzY3JpcHQuc2V0QXR0cmlidXRlKFwibm9uY2VcIiwgX193ZWJwYWNrX3JlcXVpcmVfXy5uYyk7XG5cdFx0fVxuXHRcdHNjcmlwdC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXdlYnBhY2tcIiwgZGF0YVdlYnBhY2tQcmVmaXggKyBrZXkpO1xuXG5cdFx0c2NyaXB0LnNyYyA9IHVybDtcblx0fVxuXHRpblByb2dyZXNzW3VybF0gPSBbZG9uZV07XG5cdHZhciBvblNjcmlwdENvbXBsZXRlID0gKHByZXYsIGV2ZW50KSA9PiB7XG5cdFx0Ly8gYXZvaWQgbWVtIGxlYWtzIGluIElFLlxuXHRcdHNjcmlwdC5vbmVycm9yID0gc2NyaXB0Lm9ubG9hZCA9IG51bGw7XG5cdFx0Y2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuXHRcdHZhciBkb25lRm5zID0gaW5Qcm9ncmVzc1t1cmxdO1xuXHRcdGRlbGV0ZSBpblByb2dyZXNzW3VybF07XG5cdFx0c2NyaXB0LnBhcmVudE5vZGUgJiYgc2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcblx0XHRkb25lRm5zICYmIGRvbmVGbnMuZm9yRWFjaCgoZm4pID0+IChmbihldmVudCkpKTtcblx0XHRpZihwcmV2KSByZXR1cm4gcHJldihldmVudCk7XG5cdH1cblx0dmFyIHRpbWVvdXQgPSBzZXRUaW1lb3V0KG9uU2NyaXB0Q29tcGxldGUuYmluZChudWxsLCB1bmRlZmluZWQsIHsgdHlwZTogJ3RpbWVvdXQnLCB0YXJnZXQ6IHNjcmlwdCB9KSwgMTIwMDAwKTtcblx0c2NyaXB0Lm9uZXJyb3IgPSBvblNjcmlwdENvbXBsZXRlLmJpbmQobnVsbCwgc2NyaXB0Lm9uZXJyb3IpO1xuXHRzY3JpcHQub25sb2FkID0gb25TY3JpcHRDb21wbGV0ZS5iaW5kKG51bGwsIHNjcmlwdC5vbmxvYWQpO1xuXHRuZWVkQXR0YWNoICYmIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbn07IiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwidmFyIGN1cnJlbnRNb2R1bGVEYXRhID0ge307XG52YXIgaW5zdGFsbGVkTW9kdWxlcyA9IF9fd2VicGFja19yZXF1aXJlX18uYztcblxuLy8gbW9kdWxlIGFuZCByZXF1aXJlIGNyZWF0aW9uXG52YXIgY3VycmVudENoaWxkTW9kdWxlO1xudmFyIGN1cnJlbnRQYXJlbnRzID0gW107XG5cbi8vIHN0YXR1c1xudmFyIHJlZ2lzdGVyZWRTdGF0dXNIYW5kbGVycyA9IFtdO1xudmFyIGN1cnJlbnRTdGF0dXMgPSBcImlkbGVcIjtcblxuLy8gd2hpbGUgZG93bmxvYWRpbmdcbnZhciBibG9ja2luZ1Byb21pc2VzID0gMDtcbnZhciBibG9ja2luZ1Byb21pc2VzV2FpdGluZyA9IFtdO1xuXG4vLyBUaGUgdXBkYXRlIGluZm9cbnZhciBjdXJyZW50VXBkYXRlQXBwbHlIYW5kbGVycztcbnZhciBxdWV1ZWRJbnZhbGlkYXRlZE1vZHVsZXM7XG5cbl9fd2VicGFja19yZXF1aXJlX18uaG1yRCA9IGN1cnJlbnRNb2R1bGVEYXRhO1xuXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmkucHVzaChmdW5jdGlvbiAob3B0aW9ucykge1xuXHR2YXIgbW9kdWxlID0gb3B0aW9ucy5tb2R1bGU7XG5cdHZhciByZXF1aXJlID0gY3JlYXRlUmVxdWlyZShvcHRpb25zLnJlcXVpcmUsIG9wdGlvbnMuaWQpO1xuXHRtb2R1bGUuaG90ID0gY3JlYXRlTW9kdWxlSG90T2JqZWN0KG9wdGlvbnMuaWQsIG1vZHVsZSk7XG5cdG1vZHVsZS5wYXJlbnRzID0gY3VycmVudFBhcmVudHM7XG5cdG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xuXHRjdXJyZW50UGFyZW50cyA9IFtdO1xuXHRvcHRpb25zLnJlcXVpcmUgPSByZXF1aXJlO1xufSk7XG5cbl9fd2VicGFja19yZXF1aXJlX18uaG1yQyA9IHt9O1xuX193ZWJwYWNrX3JlcXVpcmVfXy5obXJJID0ge307XG5cbmZ1bmN0aW9uIGNyZWF0ZVJlcXVpcmUocmVxdWlyZSwgbW9kdWxlSWQpIHtcblx0dmFyIG1lID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF07XG5cdGlmICghbWUpIHJldHVybiByZXF1aXJlO1xuXHR2YXIgZm4gPSBmdW5jdGlvbiAocmVxdWVzdCkge1xuXHRcdGlmIChtZS5ob3QuYWN0aXZlKSB7XG5cdFx0XHRpZiAoaW5zdGFsbGVkTW9kdWxlc1tyZXF1ZXN0XSkge1xuXHRcdFx0XHR2YXIgcGFyZW50cyA9IGluc3RhbGxlZE1vZHVsZXNbcmVxdWVzdF0ucGFyZW50cztcblx0XHRcdFx0aWYgKHBhcmVudHMuaW5kZXhPZihtb2R1bGVJZCkgPT09IC0xKSB7XG5cdFx0XHRcdFx0cGFyZW50cy5wdXNoKG1vZHVsZUlkKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y3VycmVudFBhcmVudHMgPSBbbW9kdWxlSWRdO1xuXHRcdFx0XHRjdXJyZW50Q2hpbGRNb2R1bGUgPSByZXF1ZXN0O1xuXHRcdFx0fVxuXHRcdFx0aWYgKG1lLmNoaWxkcmVuLmluZGV4T2YocmVxdWVzdCkgPT09IC0xKSB7XG5cdFx0XHRcdG1lLmNoaWxkcmVuLnB1c2gocmVxdWVzdCk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnNvbGUud2Fybihcblx0XHRcdFx0XCJbSE1SXSB1bmV4cGVjdGVkIHJlcXVpcmUoXCIgK1xuXHRcdFx0XHRcdHJlcXVlc3QgK1xuXHRcdFx0XHRcdFwiKSBmcm9tIGRpc3Bvc2VkIG1vZHVsZSBcIiArXG5cdFx0XHRcdFx0bW9kdWxlSWRcblx0XHRcdCk7XG5cdFx0XHRjdXJyZW50UGFyZW50cyA9IFtdO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVxdWlyZShyZXF1ZXN0KTtcblx0fTtcblx0dmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciA9IGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0cmV0dXJuIHJlcXVpcmVbbmFtZV07XG5cdFx0XHR9LFxuXHRcdFx0c2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdFx0cmVxdWlyZVtuYW1lXSA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH07XG5cdH07XG5cdGZvciAodmFyIG5hbWUgaW4gcmVxdWlyZSkge1xuXHRcdGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocmVxdWlyZSwgbmFtZSkgJiYgbmFtZSAhPT0gXCJlXCIpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbiwgbmFtZSwgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKG5hbWUpKTtcblx0XHR9XG5cdH1cblx0Zm4uZSA9IGZ1bmN0aW9uIChjaHVua0lkLCBmZXRjaFByaW9yaXR5KSB7XG5cdFx0cmV0dXJuIHRyYWNrQmxvY2tpbmdQcm9taXNlKHJlcXVpcmUuZShjaHVua0lkLCBmZXRjaFByaW9yaXR5KSk7XG5cdH07XG5cdHJldHVybiBmbjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTW9kdWxlSG90T2JqZWN0KG1vZHVsZUlkLCBtZSkge1xuXHR2YXIgX21haW4gPSBjdXJyZW50Q2hpbGRNb2R1bGUgIT09IG1vZHVsZUlkO1xuXHR2YXIgaG90ID0ge1xuXHRcdC8vIHByaXZhdGUgc3R1ZmZcblx0XHRfYWNjZXB0ZWREZXBlbmRlbmNpZXM6IHt9LFxuXHRcdF9hY2NlcHRlZEVycm9ySGFuZGxlcnM6IHt9LFxuXHRcdF9kZWNsaW5lZERlcGVuZGVuY2llczoge30sXG5cdFx0X3NlbGZBY2NlcHRlZDogZmFsc2UsXG5cdFx0X3NlbGZEZWNsaW5lZDogZmFsc2UsXG5cdFx0X3NlbGZJbnZhbGlkYXRlZDogZmFsc2UsXG5cdFx0X2Rpc3Bvc2VIYW5kbGVyczogW10sXG5cdFx0X21haW46IF9tYWluLFxuXHRcdF9yZXF1aXJlU2VsZjogZnVuY3Rpb24gKCkge1xuXHRcdFx0Y3VycmVudFBhcmVudHMgPSBtZS5wYXJlbnRzLnNsaWNlKCk7XG5cdFx0XHRjdXJyZW50Q2hpbGRNb2R1bGUgPSBfbWFpbiA/IHVuZGVmaW5lZCA6IG1vZHVsZUlkO1xuXHRcdFx0X193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCk7XG5cdFx0fSxcblxuXHRcdC8vIE1vZHVsZSBBUElcblx0XHRhY3RpdmU6IHRydWUsXG5cdFx0YWNjZXB0OiBmdW5jdGlvbiAoZGVwLCBjYWxsYmFjaywgZXJyb3JIYW5kbGVyKSB7XG5cdFx0XHRpZiAoZGVwID09PSB1bmRlZmluZWQpIGhvdC5fc2VsZkFjY2VwdGVkID0gdHJ1ZTtcblx0XHRcdGVsc2UgaWYgKHR5cGVvZiBkZXAgPT09IFwiZnVuY3Rpb25cIikgaG90Ll9zZWxmQWNjZXB0ZWQgPSBkZXA7XG5cdFx0XHRlbHNlIGlmICh0eXBlb2YgZGVwID09PSBcIm9iamVjdFwiICYmIGRlcCAhPT0gbnVsbCkge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGRlcC5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGhvdC5fYWNjZXB0ZWREZXBlbmRlbmNpZXNbZGVwW2ldXSA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9O1xuXHRcdFx0XHRcdGhvdC5fYWNjZXB0ZWRFcnJvckhhbmRsZXJzW2RlcFtpXV0gPSBlcnJvckhhbmRsZXI7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGhvdC5fYWNjZXB0ZWREZXBlbmRlbmNpZXNbZGVwXSA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9O1xuXHRcdFx0XHRob3QuX2FjY2VwdGVkRXJyb3JIYW5kbGVyc1tkZXBdID0gZXJyb3JIYW5kbGVyO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZGVjbGluZTogZnVuY3Rpb24gKGRlcCkge1xuXHRcdFx0aWYgKGRlcCA9PT0gdW5kZWZpbmVkKSBob3QuX3NlbGZEZWNsaW5lZCA9IHRydWU7XG5cdFx0XHRlbHNlIGlmICh0eXBlb2YgZGVwID09PSBcIm9iamVjdFwiICYmIGRlcCAhPT0gbnVsbClcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkZXAubGVuZ3RoOyBpKyspXG5cdFx0XHRcdFx0aG90Ll9kZWNsaW5lZERlcGVuZGVuY2llc1tkZXBbaV1dID0gdHJ1ZTtcblx0XHRcdGVsc2UgaG90Ll9kZWNsaW5lZERlcGVuZGVuY2llc1tkZXBdID0gdHJ1ZTtcblx0XHR9LFxuXHRcdGRpc3Bvc2U6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuXHRcdFx0aG90Ll9kaXNwb3NlSGFuZGxlcnMucHVzaChjYWxsYmFjayk7XG5cdFx0fSxcblx0XHRhZGREaXNwb3NlSGFuZGxlcjogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG5cdFx0XHRob3QuX2Rpc3Bvc2VIYW5kbGVycy5wdXNoKGNhbGxiYWNrKTtcblx0XHR9LFxuXHRcdHJlbW92ZURpc3Bvc2VIYW5kbGVyOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcblx0XHRcdHZhciBpZHggPSBob3QuX2Rpc3Bvc2VIYW5kbGVycy5pbmRleE9mKGNhbGxiYWNrKTtcblx0XHRcdGlmIChpZHggPj0gMCkgaG90Ll9kaXNwb3NlSGFuZGxlcnMuc3BsaWNlKGlkeCwgMSk7XG5cdFx0fSxcblx0XHRpbnZhbGlkYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGlzLl9zZWxmSW52YWxpZGF0ZWQgPSB0cnVlO1xuXHRcdFx0c3dpdGNoIChjdXJyZW50U3RhdHVzKSB7XG5cdFx0XHRcdGNhc2UgXCJpZGxlXCI6XG5cdFx0XHRcdFx0Y3VycmVudFVwZGF0ZUFwcGx5SGFuZGxlcnMgPSBbXTtcblx0XHRcdFx0XHRPYmplY3Qua2V5cyhfX3dlYnBhY2tfcmVxdWlyZV9fLmhtckkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHRcdFx0XHRcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5obXJJW2tleV0oXG5cdFx0XHRcdFx0XHRcdG1vZHVsZUlkLFxuXHRcdFx0XHRcdFx0XHRjdXJyZW50VXBkYXRlQXBwbHlIYW5kbGVyc1xuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRzZXRTdGF0dXMoXCJyZWFkeVwiKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcInJlYWR5XCI6XG5cdFx0XHRcdFx0T2JqZWN0LmtleXMoX193ZWJwYWNrX3JlcXVpcmVfXy5obXJJKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0XHRcdFx0XHRcdF9fd2VicGFja19yZXF1aXJlX18uaG1ySVtrZXldKFxuXHRcdFx0XHRcdFx0XHRtb2R1bGVJZCxcblx0XHRcdFx0XHRcdFx0Y3VycmVudFVwZGF0ZUFwcGx5SGFuZGxlcnNcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgXCJwcmVwYXJlXCI6XG5cdFx0XHRcdGNhc2UgXCJjaGVja1wiOlxuXHRcdFx0XHRjYXNlIFwiZGlzcG9zZVwiOlxuXHRcdFx0XHRjYXNlIFwiYXBwbHlcIjpcblx0XHRcdFx0XHQocXVldWVkSW52YWxpZGF0ZWRNb2R1bGVzID0gcXVldWVkSW52YWxpZGF0ZWRNb2R1bGVzIHx8IFtdKS5wdXNoKFxuXHRcdFx0XHRcdFx0bW9kdWxlSWRcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdC8vIGlnbm9yZSByZXF1ZXN0cyBpbiBlcnJvciBzdGF0ZXNcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Ly8gTWFuYWdlbWVudCBBUElcblx0XHRjaGVjazogaG90Q2hlY2ssXG5cdFx0YXBwbHk6IGhvdEFwcGx5LFxuXHRcdHN0YXR1czogZnVuY3Rpb24gKGwpIHtcblx0XHRcdGlmICghbCkgcmV0dXJuIGN1cnJlbnRTdGF0dXM7XG5cdFx0XHRyZWdpc3RlcmVkU3RhdHVzSGFuZGxlcnMucHVzaChsKTtcblx0XHR9LFxuXHRcdGFkZFN0YXR1c0hhbmRsZXI6IGZ1bmN0aW9uIChsKSB7XG5cdFx0XHRyZWdpc3RlcmVkU3RhdHVzSGFuZGxlcnMucHVzaChsKTtcblx0XHR9LFxuXHRcdHJlbW92ZVN0YXR1c0hhbmRsZXI6IGZ1bmN0aW9uIChsKSB7XG5cdFx0XHR2YXIgaWR4ID0gcmVnaXN0ZXJlZFN0YXR1c0hhbmRsZXJzLmluZGV4T2YobCk7XG5cdFx0XHRpZiAoaWR4ID49IDApIHJlZ2lzdGVyZWRTdGF0dXNIYW5kbGVycy5zcGxpY2UoaWR4LCAxKTtcblx0XHR9LFxuXG5cdFx0Ly9pbmhlcml0IGZyb20gcHJldmlvdXMgZGlzcG9zZSBjYWxsXG5cdFx0ZGF0YTogY3VycmVudE1vZHVsZURhdGFbbW9kdWxlSWRdXG5cdH07XG5cdGN1cnJlbnRDaGlsZE1vZHVsZSA9IHVuZGVmaW5lZDtcblx0cmV0dXJuIGhvdDtcbn1cblxuZnVuY3Rpb24gc2V0U3RhdHVzKG5ld1N0YXR1cykge1xuXHRjdXJyZW50U3RhdHVzID0gbmV3U3RhdHVzO1xuXHR2YXIgcmVzdWx0cyA9IFtdO1xuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgcmVnaXN0ZXJlZFN0YXR1c0hhbmRsZXJzLmxlbmd0aDsgaSsrKVxuXHRcdHJlc3VsdHNbaV0gPSByZWdpc3RlcmVkU3RhdHVzSGFuZGxlcnNbaV0uY2FsbChudWxsLCBuZXdTdGF0dXMpO1xuXG5cdHJldHVybiBQcm9taXNlLmFsbChyZXN1bHRzKS50aGVuKGZ1bmN0aW9uICgpIHt9KTtcbn1cblxuZnVuY3Rpb24gdW5ibG9jaygpIHtcblx0aWYgKC0tYmxvY2tpbmdQcm9taXNlcyA9PT0gMCkge1xuXHRcdHNldFN0YXR1cyhcInJlYWR5XCIpLnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKGJsb2NraW5nUHJvbWlzZXMgPT09IDApIHtcblx0XHRcdFx0dmFyIGxpc3QgPSBibG9ja2luZ1Byb21pc2VzV2FpdGluZztcblx0XHRcdFx0YmxvY2tpbmdQcm9taXNlc1dhaXRpbmcgPSBbXTtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0bGlzdFtpXSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gdHJhY2tCbG9ja2luZ1Byb21pc2UocHJvbWlzZSkge1xuXHRzd2l0Y2ggKGN1cnJlbnRTdGF0dXMpIHtcblx0XHRjYXNlIFwicmVhZHlcIjpcblx0XHRcdHNldFN0YXR1cyhcInByZXBhcmVcIik7XG5cdFx0LyogZmFsbHRocm91Z2ggKi9cblx0XHRjYXNlIFwicHJlcGFyZVwiOlxuXHRcdFx0YmxvY2tpbmdQcm9taXNlcysrO1xuXHRcdFx0cHJvbWlzZS50aGVuKHVuYmxvY2ssIHVuYmxvY2spO1xuXHRcdFx0cmV0dXJuIHByb21pc2U7XG5cdFx0ZGVmYXVsdDpcblx0XHRcdHJldHVybiBwcm9taXNlO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHdhaXRGb3JCbG9ja2luZ1Byb21pc2VzKGZuKSB7XG5cdGlmIChibG9ja2luZ1Byb21pc2VzID09PSAwKSByZXR1cm4gZm4oKTtcblx0cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG5cdFx0YmxvY2tpbmdQcm9taXNlc1dhaXRpbmcucHVzaChmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXNvbHZlKGZuKCkpO1xuXHRcdH0pO1xuXHR9KTtcbn1cblxuZnVuY3Rpb24gaG90Q2hlY2soYXBwbHlPblVwZGF0ZSkge1xuXHRpZiAoY3VycmVudFN0YXR1cyAhPT0gXCJpZGxlXCIpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJjaGVjaygpIGlzIG9ubHkgYWxsb3dlZCBpbiBpZGxlIHN0YXR1c1wiKTtcblx0fVxuXHRyZXR1cm4gc2V0U3RhdHVzKFwiY2hlY2tcIilcblx0XHQudGhlbihfX3dlYnBhY2tfcmVxdWlyZV9fLmhtck0pXG5cdFx0LnRoZW4oZnVuY3Rpb24gKHVwZGF0ZSkge1xuXHRcdFx0aWYgKCF1cGRhdGUpIHtcblx0XHRcdFx0cmV0dXJuIHNldFN0YXR1cyhhcHBseUludmFsaWRhdGVkTW9kdWxlcygpID8gXCJyZWFkeVwiIDogXCJpZGxlXCIpLnRoZW4oXG5cdFx0XHRcdFx0ZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gc2V0U3RhdHVzKFwicHJlcGFyZVwiKS50aGVuKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dmFyIHVwZGF0ZWRNb2R1bGVzID0gW107XG5cdFx0XHRcdGN1cnJlbnRVcGRhdGVBcHBseUhhbmRsZXJzID0gW107XG5cblx0XHRcdFx0cmV0dXJuIFByb21pc2UuYWxsKFxuXHRcdFx0XHRcdE9iamVjdC5rZXlzKF9fd2VicGFja19yZXF1aXJlX18uaG1yQykucmVkdWNlKGZ1bmN0aW9uIChcblx0XHRcdFx0XHRcdHByb21pc2VzLFxuXHRcdFx0XHRcdFx0a2V5XG5cdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmhtckNba2V5XShcblx0XHRcdFx0XHRcdFx0dXBkYXRlLmMsXG5cdFx0XHRcdFx0XHRcdHVwZGF0ZS5yLFxuXHRcdFx0XHRcdFx0XHR1cGRhdGUubSxcblx0XHRcdFx0XHRcdFx0cHJvbWlzZXMsXG5cdFx0XHRcdFx0XHRcdGN1cnJlbnRVcGRhdGVBcHBseUhhbmRsZXJzLFxuXHRcdFx0XHRcdFx0XHR1cGRhdGVkTW9kdWxlc1xuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdHJldHVybiBwcm9taXNlcztcblx0XHRcdFx0XHR9LCBbXSlcblx0XHRcdFx0KS50aGVuKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRyZXR1cm4gd2FpdEZvckJsb2NraW5nUHJvbWlzZXMoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0aWYgKGFwcGx5T25VcGRhdGUpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGludGVybmFsQXBwbHkoYXBwbHlPblVwZGF0ZSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gc2V0U3RhdHVzKFwicmVhZHlcIikudGhlbihmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHVwZGF0ZWRNb2R1bGVzO1xuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblx0XHR9KTtcbn1cblxuZnVuY3Rpb24gaG90QXBwbHkob3B0aW9ucykge1xuXHRpZiAoY3VycmVudFN0YXR1cyAhPT0gXCJyZWFkeVwiKSB7XG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0XHRcImFwcGx5KCkgaXMgb25seSBhbGxvd2VkIGluIHJlYWR5IHN0YXR1cyAoc3RhdGU6IFwiICtcblx0XHRcdFx0XHRjdXJyZW50U3RhdHVzICtcblx0XHRcdFx0XHRcIilcIlxuXHRcdFx0KTtcblx0XHR9KTtcblx0fVxuXHRyZXR1cm4gaW50ZXJuYWxBcHBseShvcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gaW50ZXJuYWxBcHBseShvcHRpb25zKSB7XG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdGFwcGx5SW52YWxpZGF0ZWRNb2R1bGVzKCk7XG5cblx0dmFyIHJlc3VsdHMgPSBjdXJyZW50VXBkYXRlQXBwbHlIYW5kbGVycy5tYXAoZnVuY3Rpb24gKGhhbmRsZXIpIHtcblx0XHRyZXR1cm4gaGFuZGxlcihvcHRpb25zKTtcblx0fSk7XG5cdGN1cnJlbnRVcGRhdGVBcHBseUhhbmRsZXJzID0gdW5kZWZpbmVkO1xuXG5cdHZhciBlcnJvcnMgPSByZXN1bHRzXG5cdFx0Lm1hcChmdW5jdGlvbiAocikge1xuXHRcdFx0cmV0dXJuIHIuZXJyb3I7XG5cdFx0fSlcblx0XHQuZmlsdGVyKEJvb2xlYW4pO1xuXG5cdGlmIChlcnJvcnMubGVuZ3RoID4gMCkge1xuXHRcdHJldHVybiBzZXRTdGF0dXMoXCJhYm9ydFwiKS50aGVuKGZ1bmN0aW9uICgpIHtcblx0XHRcdHRocm93IGVycm9yc1swXTtcblx0XHR9KTtcblx0fVxuXG5cdC8vIE5vdyBpbiBcImRpc3Bvc2VcIiBwaGFzZVxuXHR2YXIgZGlzcG9zZVByb21pc2UgPSBzZXRTdGF0dXMoXCJkaXNwb3NlXCIpO1xuXG5cdHJlc3VsdHMuZm9yRWFjaChmdW5jdGlvbiAocmVzdWx0KSB7XG5cdFx0aWYgKHJlc3VsdC5kaXNwb3NlKSByZXN1bHQuZGlzcG9zZSgpO1xuXHR9KTtcblxuXHQvLyBOb3cgaW4gXCJhcHBseVwiIHBoYXNlXG5cdHZhciBhcHBseVByb21pc2UgPSBzZXRTdGF0dXMoXCJhcHBseVwiKTtcblxuXHR2YXIgZXJyb3I7XG5cdHZhciByZXBvcnRFcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcblx0XHRpZiAoIWVycm9yKSBlcnJvciA9IGVycjtcblx0fTtcblxuXHR2YXIgb3V0ZGF0ZWRNb2R1bGVzID0gW107XG5cdHJlc3VsdHMuZm9yRWFjaChmdW5jdGlvbiAocmVzdWx0KSB7XG5cdFx0aWYgKHJlc3VsdC5hcHBseSkge1xuXHRcdFx0dmFyIG1vZHVsZXMgPSByZXN1bHQuYXBwbHkocmVwb3J0RXJyb3IpO1xuXHRcdFx0aWYgKG1vZHVsZXMpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0b3V0ZGF0ZWRNb2R1bGVzLnB1c2gobW9kdWxlc1tpXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXG5cdHJldHVybiBQcm9taXNlLmFsbChbZGlzcG9zZVByb21pc2UsIGFwcGx5UHJvbWlzZV0pLnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdC8vIGhhbmRsZSBlcnJvcnMgaW4gYWNjZXB0IGhhbmRsZXJzIGFuZCBzZWxmIGFjY2VwdGVkIG1vZHVsZSBsb2FkXG5cdFx0aWYgKGVycm9yKSB7XG5cdFx0XHRyZXR1cm4gc2V0U3RhdHVzKFwiZmFpbFwiKS50aGVuKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRpZiAocXVldWVkSW52YWxpZGF0ZWRNb2R1bGVzKSB7XG5cdFx0XHRyZXR1cm4gaW50ZXJuYWxBcHBseShvcHRpb25zKS50aGVuKGZ1bmN0aW9uIChsaXN0KSB7XG5cdFx0XHRcdG91dGRhdGVkTW9kdWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChtb2R1bGVJZCkge1xuXHRcdFx0XHRcdGlmIChsaXN0LmluZGV4T2YobW9kdWxlSWQpIDwgMCkgbGlzdC5wdXNoKG1vZHVsZUlkKTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHJldHVybiBsaXN0O1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNldFN0YXR1cyhcImlkbGVcIikudGhlbihmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gb3V0ZGF0ZWRNb2R1bGVzO1xuXHRcdH0pO1xuXHR9KTtcbn1cblxuZnVuY3Rpb24gYXBwbHlJbnZhbGlkYXRlZE1vZHVsZXMoKSB7XG5cdGlmIChxdWV1ZWRJbnZhbGlkYXRlZE1vZHVsZXMpIHtcblx0XHRpZiAoIWN1cnJlbnRVcGRhdGVBcHBseUhhbmRsZXJzKSBjdXJyZW50VXBkYXRlQXBwbHlIYW5kbGVycyA9IFtdO1xuXHRcdE9iamVjdC5rZXlzKF9fd2VicGFja19yZXF1aXJlX18uaG1ySSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0XHRxdWV1ZWRJbnZhbGlkYXRlZE1vZHVsZXMuZm9yRWFjaChmdW5jdGlvbiAobW9kdWxlSWQpIHtcblx0XHRcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5obXJJW2tleV0oXG5cdFx0XHRcdFx0bW9kdWxlSWQsXG5cdFx0XHRcdFx0Y3VycmVudFVwZGF0ZUFwcGx5SGFuZGxlcnNcblx0XHRcdFx0KTtcblx0XHRcdH0pO1xuXHRcdH0pO1xuXHRcdHF1ZXVlZEludmFsaWRhdGVkTW9kdWxlcyA9IHVuZGVmaW5lZDtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxufSIsInZhciBzY3JpcHRVcmw7XG5pZiAoX193ZWJwYWNrX3JlcXVpcmVfXy5nLmltcG9ydFNjcmlwdHMpIHNjcmlwdFVybCA9IF9fd2VicGFja19yZXF1aXJlX18uZy5sb2NhdGlvbiArIFwiXCI7XG52YXIgZG9jdW1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLmcuZG9jdW1lbnQ7XG5pZiAoIXNjcmlwdFVybCAmJiBkb2N1bWVudCkge1xuXHRpZiAoZG9jdW1lbnQuY3VycmVudFNjcmlwdClcblx0XHRzY3JpcHRVcmwgPSBkb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYztcblx0aWYgKCFzY3JpcHRVcmwpIHtcblx0XHR2YXIgc2NyaXB0cyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic2NyaXB0XCIpO1xuXHRcdGlmKHNjcmlwdHMubGVuZ3RoKSB7XG5cdFx0XHR2YXIgaSA9IHNjcmlwdHMubGVuZ3RoIC0gMTtcblx0XHRcdHdoaWxlIChpID4gLTEgJiYgKCFzY3JpcHRVcmwgfHwgIS9eaHR0cChzPyk6Ly50ZXN0KHNjcmlwdFVybCkpKSBzY3JpcHRVcmwgPSBzY3JpcHRzW2ktLV0uc3JjO1xuXHRcdH1cblx0fVxufVxuLy8gV2hlbiBzdXBwb3J0aW5nIGJyb3dzZXJzIHdoZXJlIGFuIGF1dG9tYXRpYyBwdWJsaWNQYXRoIGlzIG5vdCBzdXBwb3J0ZWQgeW91IG11c3Qgc3BlY2lmeSBhbiBvdXRwdXQucHVibGljUGF0aCBtYW51YWxseSB2aWEgY29uZmlndXJhdGlvblxuLy8gb3IgcGFzcyBhbiBlbXB0eSBzdHJpbmcgKFwiXCIpIGFuZCBzZXQgdGhlIF9fd2VicGFja19wdWJsaWNfcGF0aF9fIHZhcmlhYmxlIGZyb20geW91ciBjb2RlIHRvIHVzZSB5b3VyIG93biBsb2dpYy5cbmlmICghc2NyaXB0VXJsKSB0aHJvdyBuZXcgRXJyb3IoXCJBdXRvbWF0aWMgcHVibGljUGF0aCBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlclwiKTtcbnNjcmlwdFVybCA9IHNjcmlwdFVybC5yZXBsYWNlKC8jLiokLywgXCJcIikucmVwbGFjZSgvXFw/LiokLywgXCJcIikucmVwbGFjZSgvXFwvW15cXC9dKyQvLCBcIi9cIik7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBzY3JpcHRVcmw7IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5iID0gZG9jdW1lbnQuYmFzZVVSSSB8fCBzZWxmLmxvY2F0aW9uLmhyZWY7XG5cbi8vIG9iamVjdCB0byBzdG9yZSBsb2FkZWQgYW5kIGxvYWRpbmcgY2h1bmtzXG4vLyB1bmRlZmluZWQgPSBjaHVuayBub3QgbG9hZGVkLCBudWxsID0gY2h1bmsgcHJlbG9hZGVkL3ByZWZldGNoZWRcbi8vIFtyZXNvbHZlLCByZWplY3QsIFByb21pc2VdID0gY2h1bmsgbG9hZGluZywgMCA9IGNodW5rIGxvYWRlZFxudmFyIGluc3RhbGxlZENodW5rcyA9IF9fd2VicGFja19yZXF1aXJlX18uaG1yU19qc29ucCA9IF9fd2VicGFja19yZXF1aXJlX18uaG1yU19qc29ucCB8fCB7XG5cdFwibWFpblwiOiAwXG59O1xuXG4vLyBubyBjaHVuayBvbiBkZW1hbmQgbG9hZGluZ1xuXG4vLyBubyBwcmVmZXRjaGluZ1xuXG4vLyBubyBwcmVsb2FkZWRcblxudmFyIGN1cnJlbnRVcGRhdGVkTW9kdWxlc0xpc3Q7XG52YXIgd2FpdGluZ1VwZGF0ZVJlc29sdmVzID0ge307XG5mdW5jdGlvbiBsb2FkVXBkYXRlQ2h1bmsoY2h1bmtJZCwgdXBkYXRlZE1vZHVsZXNMaXN0KSB7XG5cdGN1cnJlbnRVcGRhdGVkTW9kdWxlc0xpc3QgPSB1cGRhdGVkTW9kdWxlc0xpc3Q7XG5cdHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdFx0d2FpdGluZ1VwZGF0ZVJlc29sdmVzW2NodW5rSWRdID0gcmVzb2x2ZTtcblx0XHQvLyBzdGFydCB1cGRhdGUgY2h1bmsgbG9hZGluZ1xuXHRcdHZhciB1cmwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLnAgKyBfX3dlYnBhY2tfcmVxdWlyZV9fLmh1KGNodW5rSWQpO1xuXHRcdC8vIGNyZWF0ZSBlcnJvciBiZWZvcmUgc3RhY2sgdW53b3VuZCB0byBnZXQgdXNlZnVsIHN0YWNrdHJhY2UgbGF0ZXJcblx0XHR2YXIgZXJyb3IgPSBuZXcgRXJyb3IoKTtcblx0XHR2YXIgbG9hZGluZ0VuZGVkID0gKGV2ZW50KSA9PiB7XG5cdFx0XHRpZih3YWl0aW5nVXBkYXRlUmVzb2x2ZXNbY2h1bmtJZF0pIHtcblx0XHRcdFx0d2FpdGluZ1VwZGF0ZVJlc29sdmVzW2NodW5rSWRdID0gdW5kZWZpbmVkXG5cdFx0XHRcdHZhciBlcnJvclR5cGUgPSBldmVudCAmJiAoZXZlbnQudHlwZSA9PT0gJ2xvYWQnID8gJ21pc3NpbmcnIDogZXZlbnQudHlwZSk7XG5cdFx0XHRcdHZhciByZWFsU3JjID0gZXZlbnQgJiYgZXZlbnQudGFyZ2V0ICYmIGV2ZW50LnRhcmdldC5zcmM7XG5cdFx0XHRcdGVycm9yLm1lc3NhZ2UgPSAnTG9hZGluZyBob3QgdXBkYXRlIGNodW5rICcgKyBjaHVua0lkICsgJyBmYWlsZWQuXFxuKCcgKyBlcnJvclR5cGUgKyAnOiAnICsgcmVhbFNyYyArICcpJztcblx0XHRcdFx0ZXJyb3IubmFtZSA9ICdDaHVua0xvYWRFcnJvcic7XG5cdFx0XHRcdGVycm9yLnR5cGUgPSBlcnJvclR5cGU7XG5cdFx0XHRcdGVycm9yLnJlcXVlc3QgPSByZWFsU3JjO1xuXHRcdFx0XHRyZWplY3QoZXJyb3IpO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5sKHVybCwgbG9hZGluZ0VuZGVkKTtcblx0fSk7XG59XG5cbnNlbGZbXCJ3ZWJwYWNrSG90VXBkYXRlZmxhc2tfcHJlYWN0X3R5cGVzY3JpcHRfdGFpbHdpbmRfdGVtcGxhdGVcIl0gPSAoY2h1bmtJZCwgbW9yZU1vZHVsZXMsIHJ1bnRpbWUpID0+IHtcblx0Zm9yKHZhciBtb2R1bGVJZCBpbiBtb3JlTW9kdWxlcykge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhtb3JlTW9kdWxlcywgbW9kdWxlSWQpKSB7XG5cdFx0XHRjdXJyZW50VXBkYXRlW21vZHVsZUlkXSA9IG1vcmVNb2R1bGVzW21vZHVsZUlkXTtcblx0XHRcdGlmKGN1cnJlbnRVcGRhdGVkTW9kdWxlc0xpc3QpIGN1cnJlbnRVcGRhdGVkTW9kdWxlc0xpc3QucHVzaChtb2R1bGVJZCk7XG5cdFx0fVxuXHR9XG5cdGlmKHJ1bnRpbWUpIGN1cnJlbnRVcGRhdGVSdW50aW1lLnB1c2gocnVudGltZSk7XG5cdGlmKHdhaXRpbmdVcGRhdGVSZXNvbHZlc1tjaHVua0lkXSkge1xuXHRcdHdhaXRpbmdVcGRhdGVSZXNvbHZlc1tjaHVua0lkXSgpO1xuXHRcdHdhaXRpbmdVcGRhdGVSZXNvbHZlc1tjaHVua0lkXSA9IHVuZGVmaW5lZDtcblx0fVxufTtcblxudmFyIGN1cnJlbnRVcGRhdGVDaHVua3M7XG52YXIgY3VycmVudFVwZGF0ZTtcbnZhciBjdXJyZW50VXBkYXRlUmVtb3ZlZENodW5rcztcbnZhciBjdXJyZW50VXBkYXRlUnVudGltZTtcbmZ1bmN0aW9uIGFwcGx5SGFuZGxlcihvcHRpb25zKSB7XG5cdGlmIChfX3dlYnBhY2tfcmVxdWlyZV9fLmYpIGRlbGV0ZSBfX3dlYnBhY2tfcmVxdWlyZV9fLmYuanNvbnBIbXI7XG5cdGN1cnJlbnRVcGRhdGVDaHVua3MgPSB1bmRlZmluZWQ7XG5cdGZ1bmN0aW9uIGdldEFmZmVjdGVkTW9kdWxlRWZmZWN0cyh1cGRhdGVNb2R1bGVJZCkge1xuXHRcdHZhciBvdXRkYXRlZE1vZHVsZXMgPSBbdXBkYXRlTW9kdWxlSWRdO1xuXHRcdHZhciBvdXRkYXRlZERlcGVuZGVuY2llcyA9IHt9O1xuXG5cdFx0dmFyIHF1ZXVlID0gb3V0ZGF0ZWRNb2R1bGVzLm1hcChmdW5jdGlvbiAoaWQpIHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGNoYWluOiBbaWRdLFxuXHRcdFx0XHRpZDogaWRcblx0XHRcdH07XG5cdFx0fSk7XG5cdFx0d2hpbGUgKHF1ZXVlLmxlbmd0aCA+IDApIHtcblx0XHRcdHZhciBxdWV1ZUl0ZW0gPSBxdWV1ZS5wb3AoKTtcblx0XHRcdHZhciBtb2R1bGVJZCA9IHF1ZXVlSXRlbS5pZDtcblx0XHRcdHZhciBjaGFpbiA9IHF1ZXVlSXRlbS5jaGFpbjtcblx0XHRcdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLmNbbW9kdWxlSWRdO1xuXHRcdFx0aWYgKFxuXHRcdFx0XHQhbW9kdWxlIHx8XG5cdFx0XHRcdChtb2R1bGUuaG90Ll9zZWxmQWNjZXB0ZWQgJiYgIW1vZHVsZS5ob3QuX3NlbGZJbnZhbGlkYXRlZClcblx0XHRcdClcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRpZiAobW9kdWxlLmhvdC5fc2VsZkRlY2xpbmVkKSB7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0dHlwZTogXCJzZWxmLWRlY2xpbmVkXCIsXG5cdFx0XHRcdFx0Y2hhaW46IGNoYWluLFxuXHRcdFx0XHRcdG1vZHVsZUlkOiBtb2R1bGVJZFxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0aWYgKG1vZHVsZS5ob3QuX21haW4pIHtcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHR0eXBlOiBcInVuYWNjZXB0ZWRcIixcblx0XHRcdFx0XHRjaGFpbjogY2hhaW4sXG5cdFx0XHRcdFx0bW9kdWxlSWQ6IG1vZHVsZUlkXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG1vZHVsZS5wYXJlbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHZhciBwYXJlbnRJZCA9IG1vZHVsZS5wYXJlbnRzW2ldO1xuXHRcdFx0XHR2YXIgcGFyZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXy5jW3BhcmVudElkXTtcblx0XHRcdFx0aWYgKCFwYXJlbnQpIGNvbnRpbnVlO1xuXHRcdFx0XHRpZiAocGFyZW50LmhvdC5fZGVjbGluZWREZXBlbmRlbmNpZXNbbW9kdWxlSWRdKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdHR5cGU6IFwiZGVjbGluZWRcIixcblx0XHRcdFx0XHRcdGNoYWluOiBjaGFpbi5jb25jYXQoW3BhcmVudElkXSksXG5cdFx0XHRcdFx0XHRtb2R1bGVJZDogbW9kdWxlSWQsXG5cdFx0XHRcdFx0XHRwYXJlbnRJZDogcGFyZW50SWRcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChvdXRkYXRlZE1vZHVsZXMuaW5kZXhPZihwYXJlbnRJZCkgIT09IC0xKSBjb250aW51ZTtcblx0XHRcdFx0aWYgKHBhcmVudC5ob3QuX2FjY2VwdGVkRGVwZW5kZW5jaWVzW21vZHVsZUlkXSkge1xuXHRcdFx0XHRcdGlmICghb3V0ZGF0ZWREZXBlbmRlbmNpZXNbcGFyZW50SWRdKVxuXHRcdFx0XHRcdFx0b3V0ZGF0ZWREZXBlbmRlbmNpZXNbcGFyZW50SWRdID0gW107XG5cdFx0XHRcdFx0YWRkQWxsVG9TZXQob3V0ZGF0ZWREZXBlbmRlbmNpZXNbcGFyZW50SWRdLCBbbW9kdWxlSWRdKTtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkZWxldGUgb3V0ZGF0ZWREZXBlbmRlbmNpZXNbcGFyZW50SWRdO1xuXHRcdFx0XHRvdXRkYXRlZE1vZHVsZXMucHVzaChwYXJlbnRJZCk7XG5cdFx0XHRcdHF1ZXVlLnB1c2goe1xuXHRcdFx0XHRcdGNoYWluOiBjaGFpbi5jb25jYXQoW3BhcmVudElkXSksXG5cdFx0XHRcdFx0aWQ6IHBhcmVudElkXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHR0eXBlOiBcImFjY2VwdGVkXCIsXG5cdFx0XHRtb2R1bGVJZDogdXBkYXRlTW9kdWxlSWQsXG5cdFx0XHRvdXRkYXRlZE1vZHVsZXM6IG91dGRhdGVkTW9kdWxlcyxcblx0XHRcdG91dGRhdGVkRGVwZW5kZW5jaWVzOiBvdXRkYXRlZERlcGVuZGVuY2llc1xuXHRcdH07XG5cdH1cblxuXHRmdW5jdGlvbiBhZGRBbGxUb1NldChhLCBiKSB7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IGJbaV07XG5cdFx0XHRpZiAoYS5pbmRleE9mKGl0ZW0pID09PSAtMSkgYS5wdXNoKGl0ZW0pO1xuXHRcdH1cblx0fVxuXG5cdC8vIGF0IGJlZ2luIGFsbCB1cGRhdGVzIG1vZHVsZXMgYXJlIG91dGRhdGVkXG5cdC8vIHRoZSBcIm91dGRhdGVkXCIgc3RhdHVzIGNhbiBwcm9wYWdhdGUgdG8gcGFyZW50cyBpZiB0aGV5IGRvbid0IGFjY2VwdCB0aGUgY2hpbGRyZW5cblx0dmFyIG91dGRhdGVkRGVwZW5kZW5jaWVzID0ge307XG5cdHZhciBvdXRkYXRlZE1vZHVsZXMgPSBbXTtcblx0dmFyIGFwcGxpZWRVcGRhdGUgPSB7fTtcblxuXHR2YXIgd2FyblVuZXhwZWN0ZWRSZXF1aXJlID0gZnVuY3Rpb24gd2FyblVuZXhwZWN0ZWRSZXF1aXJlKG1vZHVsZSkge1xuXHRcdGNvbnNvbGUud2Fybihcblx0XHRcdFwiW0hNUl0gdW5leHBlY3RlZCByZXF1aXJlKFwiICsgbW9kdWxlLmlkICsgXCIpIHRvIGRpc3Bvc2VkIG1vZHVsZVwiXG5cdFx0KTtcblx0fTtcblxuXHRmb3IgKHZhciBtb2R1bGVJZCBpbiBjdXJyZW50VXBkYXRlKSB7XG5cdFx0aWYgKF9fd2VicGFja19yZXF1aXJlX18ubyhjdXJyZW50VXBkYXRlLCBtb2R1bGVJZCkpIHtcblx0XHRcdHZhciBuZXdNb2R1bGVGYWN0b3J5ID0gY3VycmVudFVwZGF0ZVttb2R1bGVJZF07XG5cdFx0XHQvKiogQHR5cGUge1RPRE99ICovXG5cdFx0XHR2YXIgcmVzdWx0O1xuXHRcdFx0aWYgKG5ld01vZHVsZUZhY3RvcnkpIHtcblx0XHRcdFx0cmVzdWx0ID0gZ2V0QWZmZWN0ZWRNb2R1bGVFZmZlY3RzKG1vZHVsZUlkKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJlc3VsdCA9IHtcblx0XHRcdFx0XHR0eXBlOiBcImRpc3Bvc2VkXCIsXG5cdFx0XHRcdFx0bW9kdWxlSWQ6IG1vZHVsZUlkXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHQvKiogQHR5cGUge0Vycm9yfGZhbHNlfSAqL1xuXHRcdFx0dmFyIGFib3J0RXJyb3IgPSBmYWxzZTtcblx0XHRcdHZhciBkb0FwcGx5ID0gZmFsc2U7XG5cdFx0XHR2YXIgZG9EaXNwb3NlID0gZmFsc2U7XG5cdFx0XHR2YXIgY2hhaW5JbmZvID0gXCJcIjtcblx0XHRcdGlmIChyZXN1bHQuY2hhaW4pIHtcblx0XHRcdFx0Y2hhaW5JbmZvID0gXCJcXG5VcGRhdGUgcHJvcGFnYXRpb246IFwiICsgcmVzdWx0LmNoYWluLmpvaW4oXCIgLT4gXCIpO1xuXHRcdFx0fVxuXHRcdFx0c3dpdGNoIChyZXN1bHQudHlwZSkge1xuXHRcdFx0XHRjYXNlIFwic2VsZi1kZWNsaW5lZFwiOlxuXHRcdFx0XHRcdGlmIChvcHRpb25zLm9uRGVjbGluZWQpIG9wdGlvbnMub25EZWNsaW5lZChyZXN1bHQpO1xuXHRcdFx0XHRcdGlmICghb3B0aW9ucy5pZ25vcmVEZWNsaW5lZClcblx0XHRcdFx0XHRcdGFib3J0RXJyb3IgPSBuZXcgRXJyb3IoXG5cdFx0XHRcdFx0XHRcdFwiQWJvcnRlZCBiZWNhdXNlIG9mIHNlbGYgZGVjbGluZTogXCIgK1xuXHRcdFx0XHRcdFx0XHRcdHJlc3VsdC5tb2R1bGVJZCArXG5cdFx0XHRcdFx0XHRcdFx0Y2hhaW5JbmZvXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIFwiZGVjbGluZWRcIjpcblx0XHRcdFx0XHRpZiAob3B0aW9ucy5vbkRlY2xpbmVkKSBvcHRpb25zLm9uRGVjbGluZWQocmVzdWx0KTtcblx0XHRcdFx0XHRpZiAoIW9wdGlvbnMuaWdub3JlRGVjbGluZWQpXG5cdFx0XHRcdFx0XHRhYm9ydEVycm9yID0gbmV3IEVycm9yKFxuXHRcdFx0XHRcdFx0XHRcIkFib3J0ZWQgYmVjYXVzZSBvZiBkZWNsaW5lZCBkZXBlbmRlbmN5OiBcIiArXG5cdFx0XHRcdFx0XHRcdFx0cmVzdWx0Lm1vZHVsZUlkICtcblx0XHRcdFx0XHRcdFx0XHRcIiBpbiBcIiArXG5cdFx0XHRcdFx0XHRcdFx0cmVzdWx0LnBhcmVudElkICtcblx0XHRcdFx0XHRcdFx0XHRjaGFpbkluZm9cblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgXCJ1bmFjY2VwdGVkXCI6XG5cdFx0XHRcdFx0aWYgKG9wdGlvbnMub25VbmFjY2VwdGVkKSBvcHRpb25zLm9uVW5hY2NlcHRlZChyZXN1bHQpO1xuXHRcdFx0XHRcdGlmICghb3B0aW9ucy5pZ25vcmVVbmFjY2VwdGVkKVxuXHRcdFx0XHRcdFx0YWJvcnRFcnJvciA9IG5ldyBFcnJvcihcblx0XHRcdFx0XHRcdFx0XCJBYm9ydGVkIGJlY2F1c2UgXCIgKyBtb2R1bGVJZCArIFwiIGlzIG5vdCBhY2NlcHRlZFwiICsgY2hhaW5JbmZvXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIFwiYWNjZXB0ZWRcIjpcblx0XHRcdFx0XHRpZiAob3B0aW9ucy5vbkFjY2VwdGVkKSBvcHRpb25zLm9uQWNjZXB0ZWQocmVzdWx0KTtcblx0XHRcdFx0XHRkb0FwcGx5ID0gdHJ1ZTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcImRpc3Bvc2VkXCI6XG5cdFx0XHRcdFx0aWYgKG9wdGlvbnMub25EaXNwb3NlZCkgb3B0aW9ucy5vbkRpc3Bvc2VkKHJlc3VsdCk7XG5cdFx0XHRcdFx0ZG9EaXNwb3NlID0gdHJ1ZTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJVbmV4Y2VwdGlvbiB0eXBlIFwiICsgcmVzdWx0LnR5cGUpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGFib3J0RXJyb3IpIHtcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRlcnJvcjogYWJvcnRFcnJvclxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0aWYgKGRvQXBwbHkpIHtcblx0XHRcdFx0YXBwbGllZFVwZGF0ZVttb2R1bGVJZF0gPSBuZXdNb2R1bGVGYWN0b3J5O1xuXHRcdFx0XHRhZGRBbGxUb1NldChvdXRkYXRlZE1vZHVsZXMsIHJlc3VsdC5vdXRkYXRlZE1vZHVsZXMpO1xuXHRcdFx0XHRmb3IgKG1vZHVsZUlkIGluIHJlc3VsdC5vdXRkYXRlZERlcGVuZGVuY2llcykge1xuXHRcdFx0XHRcdGlmIChfX3dlYnBhY2tfcmVxdWlyZV9fLm8ocmVzdWx0Lm91dGRhdGVkRGVwZW5kZW5jaWVzLCBtb2R1bGVJZCkpIHtcblx0XHRcdFx0XHRcdGlmICghb3V0ZGF0ZWREZXBlbmRlbmNpZXNbbW9kdWxlSWRdKVxuXHRcdFx0XHRcdFx0XHRvdXRkYXRlZERlcGVuZGVuY2llc1ttb2R1bGVJZF0gPSBbXTtcblx0XHRcdFx0XHRcdGFkZEFsbFRvU2V0KFxuXHRcdFx0XHRcdFx0XHRvdXRkYXRlZERlcGVuZGVuY2llc1ttb2R1bGVJZF0sXG5cdFx0XHRcdFx0XHRcdHJlc3VsdC5vdXRkYXRlZERlcGVuZGVuY2llc1ttb2R1bGVJZF1cblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoZG9EaXNwb3NlKSB7XG5cdFx0XHRcdGFkZEFsbFRvU2V0KG91dGRhdGVkTW9kdWxlcywgW3Jlc3VsdC5tb2R1bGVJZF0pO1xuXHRcdFx0XHRhcHBsaWVkVXBkYXRlW21vZHVsZUlkXSA9IHdhcm5VbmV4cGVjdGVkUmVxdWlyZTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0Y3VycmVudFVwZGF0ZSA9IHVuZGVmaW5lZDtcblxuXHQvLyBTdG9yZSBzZWxmIGFjY2VwdGVkIG91dGRhdGVkIG1vZHVsZXMgdG8gcmVxdWlyZSB0aGVtIGxhdGVyIGJ5IHRoZSBtb2R1bGUgc3lzdGVtXG5cdHZhciBvdXRkYXRlZFNlbGZBY2NlcHRlZE1vZHVsZXMgPSBbXTtcblx0Zm9yICh2YXIgaiA9IDA7IGogPCBvdXRkYXRlZE1vZHVsZXMubGVuZ3RoOyBqKyspIHtcblx0XHR2YXIgb3V0ZGF0ZWRNb2R1bGVJZCA9IG91dGRhdGVkTW9kdWxlc1tqXTtcblx0XHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXy5jW291dGRhdGVkTW9kdWxlSWRdO1xuXHRcdGlmIChcblx0XHRcdG1vZHVsZSAmJlxuXHRcdFx0KG1vZHVsZS5ob3QuX3NlbGZBY2NlcHRlZCB8fCBtb2R1bGUuaG90Ll9tYWluKSAmJlxuXHRcdFx0Ly8gcmVtb3ZlZCBzZWxmLWFjY2VwdGVkIG1vZHVsZXMgc2hvdWxkIG5vdCBiZSByZXF1aXJlZFxuXHRcdFx0YXBwbGllZFVwZGF0ZVtvdXRkYXRlZE1vZHVsZUlkXSAhPT0gd2FyblVuZXhwZWN0ZWRSZXF1aXJlICYmXG5cdFx0XHQvLyB3aGVuIGNhbGxlZCBpbnZhbGlkYXRlIHNlbGYtYWNjZXB0aW5nIGlzIG5vdCBwb3NzaWJsZVxuXHRcdFx0IW1vZHVsZS5ob3QuX3NlbGZJbnZhbGlkYXRlZFxuXHRcdCkge1xuXHRcdFx0b3V0ZGF0ZWRTZWxmQWNjZXB0ZWRNb2R1bGVzLnB1c2goe1xuXHRcdFx0XHRtb2R1bGU6IG91dGRhdGVkTW9kdWxlSWQsXG5cdFx0XHRcdHJlcXVpcmU6IG1vZHVsZS5ob3QuX3JlcXVpcmVTZWxmLFxuXHRcdFx0XHRlcnJvckhhbmRsZXI6IG1vZHVsZS5ob3QuX3NlbGZBY2NlcHRlZFxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cblx0dmFyIG1vZHVsZU91dGRhdGVkRGVwZW5kZW5jaWVzO1xuXG5cdHJldHVybiB7XG5cdFx0ZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuXHRcdFx0Y3VycmVudFVwZGF0ZVJlbW92ZWRDaHVua3MuZm9yRWFjaChmdW5jdGlvbiAoY2h1bmtJZCkge1xuXHRcdFx0XHRkZWxldGUgaW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdO1xuXHRcdFx0fSk7XG5cdFx0XHRjdXJyZW50VXBkYXRlUmVtb3ZlZENodW5rcyA9IHVuZGVmaW5lZDtcblxuXHRcdFx0dmFyIGlkeDtcblx0XHRcdHZhciBxdWV1ZSA9IG91dGRhdGVkTW9kdWxlcy5zbGljZSgpO1xuXHRcdFx0d2hpbGUgKHF1ZXVlLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0dmFyIG1vZHVsZUlkID0gcXVldWUucG9wKCk7XG5cdFx0XHRcdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLmNbbW9kdWxlSWRdO1xuXHRcdFx0XHRpZiAoIW1vZHVsZSkgY29udGludWU7XG5cblx0XHRcdFx0dmFyIGRhdGEgPSB7fTtcblxuXHRcdFx0XHQvLyBDYWxsIGRpc3Bvc2UgaGFuZGxlcnNcblx0XHRcdFx0dmFyIGRpc3Bvc2VIYW5kbGVycyA9IG1vZHVsZS5ob3QuX2Rpc3Bvc2VIYW5kbGVycztcblx0XHRcdFx0Zm9yIChqID0gMDsgaiA8IGRpc3Bvc2VIYW5kbGVycy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRcdGRpc3Bvc2VIYW5kbGVyc1tqXS5jYWxsKG51bGwsIGRhdGEpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdF9fd2VicGFja19yZXF1aXJlX18uaG1yRFttb2R1bGVJZF0gPSBkYXRhO1xuXG5cdFx0XHRcdC8vIGRpc2FibGUgbW9kdWxlICh0aGlzIGRpc2FibGVzIHJlcXVpcmVzIGZyb20gdGhpcyBtb2R1bGUpXG5cdFx0XHRcdG1vZHVsZS5ob3QuYWN0aXZlID0gZmFsc2U7XG5cblx0XHRcdFx0Ly8gcmVtb3ZlIG1vZHVsZSBmcm9tIGNhY2hlXG5cdFx0XHRcdGRlbGV0ZSBfX3dlYnBhY2tfcmVxdWlyZV9fLmNbbW9kdWxlSWRdO1xuXG5cdFx0XHRcdC8vIHdoZW4gZGlzcG9zaW5nIHRoZXJlIGlzIG5vIG5lZWQgdG8gY2FsbCBkaXNwb3NlIGhhbmRsZXJcblx0XHRcdFx0ZGVsZXRlIG91dGRhdGVkRGVwZW5kZW5jaWVzW21vZHVsZUlkXTtcblxuXHRcdFx0XHQvLyByZW1vdmUgXCJwYXJlbnRzXCIgcmVmZXJlbmNlcyBmcm9tIGFsbCBjaGlsZHJlblxuXHRcdFx0XHRmb3IgKGogPSAwOyBqIDwgbW9kdWxlLmNoaWxkcmVuLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdFx0dmFyIGNoaWxkID0gX193ZWJwYWNrX3JlcXVpcmVfXy5jW21vZHVsZS5jaGlsZHJlbltqXV07XG5cdFx0XHRcdFx0aWYgKCFjaGlsZCkgY29udGludWU7XG5cdFx0XHRcdFx0aWR4ID0gY2hpbGQucGFyZW50cy5pbmRleE9mKG1vZHVsZUlkKTtcblx0XHRcdFx0XHRpZiAoaWR4ID49IDApIHtcblx0XHRcdFx0XHRcdGNoaWxkLnBhcmVudHMuc3BsaWNlKGlkeCwgMSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIHJlbW92ZSBvdXRkYXRlZCBkZXBlbmRlbmN5IGZyb20gbW9kdWxlIGNoaWxkcmVuXG5cdFx0XHR2YXIgZGVwZW5kZW5jeTtcblx0XHRcdGZvciAodmFyIG91dGRhdGVkTW9kdWxlSWQgaW4gb3V0ZGF0ZWREZXBlbmRlbmNpZXMpIHtcblx0XHRcdFx0aWYgKF9fd2VicGFja19yZXF1aXJlX18ubyhvdXRkYXRlZERlcGVuZGVuY2llcywgb3V0ZGF0ZWRNb2R1bGVJZCkpIHtcblx0XHRcdFx0XHRtb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLmNbb3V0ZGF0ZWRNb2R1bGVJZF07XG5cdFx0XHRcdFx0aWYgKG1vZHVsZSkge1xuXHRcdFx0XHRcdFx0bW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXMgPVxuXHRcdFx0XHRcdFx0XHRvdXRkYXRlZERlcGVuZGVuY2llc1tvdXRkYXRlZE1vZHVsZUlkXTtcblx0XHRcdFx0XHRcdGZvciAoaiA9IDA7IGogPCBtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llcy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRcdFx0XHRkZXBlbmRlbmN5ID0gbW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXNbal07XG5cdFx0XHRcdFx0XHRcdGlkeCA9IG1vZHVsZS5jaGlsZHJlbi5pbmRleE9mKGRlcGVuZGVuY3kpO1xuXHRcdFx0XHRcdFx0XHRpZiAoaWR4ID49IDApIG1vZHVsZS5jaGlsZHJlbi5zcGxpY2UoaWR4LCAxKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdGFwcGx5OiBmdW5jdGlvbiAocmVwb3J0RXJyb3IpIHtcblx0XHRcdC8vIGluc2VydCBuZXcgY29kZVxuXHRcdFx0Zm9yICh2YXIgdXBkYXRlTW9kdWxlSWQgaW4gYXBwbGllZFVwZGF0ZSkge1xuXHRcdFx0XHRpZiAoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGFwcGxpZWRVcGRhdGUsIHVwZGF0ZU1vZHVsZUlkKSkge1xuXHRcdFx0XHRcdF9fd2VicGFja19yZXF1aXJlX18ubVt1cGRhdGVNb2R1bGVJZF0gPSBhcHBsaWVkVXBkYXRlW3VwZGF0ZU1vZHVsZUlkXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBydW4gbmV3IHJ1bnRpbWUgbW9kdWxlc1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjdXJyZW50VXBkYXRlUnVudGltZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRjdXJyZW50VXBkYXRlUnVudGltZVtpXShfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gY2FsbCBhY2NlcHQgaGFuZGxlcnNcblx0XHRcdGZvciAodmFyIG91dGRhdGVkTW9kdWxlSWQgaW4gb3V0ZGF0ZWREZXBlbmRlbmNpZXMpIHtcblx0XHRcdFx0aWYgKF9fd2VicGFja19yZXF1aXJlX18ubyhvdXRkYXRlZERlcGVuZGVuY2llcywgb3V0ZGF0ZWRNb2R1bGVJZCkpIHtcblx0XHRcdFx0XHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXy5jW291dGRhdGVkTW9kdWxlSWRdO1xuXHRcdFx0XHRcdGlmIChtb2R1bGUpIHtcblx0XHRcdFx0XHRcdG1vZHVsZU91dGRhdGVkRGVwZW5kZW5jaWVzID1cblx0XHRcdFx0XHRcdFx0b3V0ZGF0ZWREZXBlbmRlbmNpZXNbb3V0ZGF0ZWRNb2R1bGVJZF07XG5cdFx0XHRcdFx0XHR2YXIgY2FsbGJhY2tzID0gW107XG5cdFx0XHRcdFx0XHR2YXIgZXJyb3JIYW5kbGVycyA9IFtdO1xuXHRcdFx0XHRcdFx0dmFyIGRlcGVuZGVuY2llc0ZvckNhbGxiYWNrcyA9IFtdO1xuXHRcdFx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llcy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRcdFx0XHR2YXIgZGVwZW5kZW5jeSA9IG1vZHVsZU91dGRhdGVkRGVwZW5kZW5jaWVzW2pdO1xuXHRcdFx0XHRcdFx0XHR2YXIgYWNjZXB0Q2FsbGJhY2sgPVxuXHRcdFx0XHRcdFx0XHRcdG1vZHVsZS5ob3QuX2FjY2VwdGVkRGVwZW5kZW5jaWVzW2RlcGVuZGVuY3ldO1xuXHRcdFx0XHRcdFx0XHR2YXIgZXJyb3JIYW5kbGVyID1cblx0XHRcdFx0XHRcdFx0XHRtb2R1bGUuaG90Ll9hY2NlcHRlZEVycm9ySGFuZGxlcnNbZGVwZW5kZW5jeV07XG5cdFx0XHRcdFx0XHRcdGlmIChhY2NlcHRDYWxsYmFjaykge1xuXHRcdFx0XHRcdFx0XHRcdGlmIChjYWxsYmFja3MuaW5kZXhPZihhY2NlcHRDYWxsYmFjaykgIT09IC0xKSBjb250aW51ZTtcblx0XHRcdFx0XHRcdFx0XHRjYWxsYmFja3MucHVzaChhY2NlcHRDYWxsYmFjayk7XG5cdFx0XHRcdFx0XHRcdFx0ZXJyb3JIYW5kbGVycy5wdXNoKGVycm9ySGFuZGxlcik7XG5cdFx0XHRcdFx0XHRcdFx0ZGVwZW5kZW5jaWVzRm9yQ2FsbGJhY2tzLnB1c2goZGVwZW5kZW5jeSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGZvciAodmFyIGsgPSAwOyBrIDwgY2FsbGJhY2tzLmxlbmd0aDsgaysrKSB7XG5cdFx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdFx0Y2FsbGJhY2tzW2tdLmNhbGwobnVsbCwgbW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXMpO1xuXHRcdFx0XHRcdFx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAodHlwZW9mIGVycm9ySGFuZGxlcnNba10gPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZXJyb3JIYW5kbGVyc1trXShlcnIsIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtb2R1bGVJZDogb3V0ZGF0ZWRNb2R1bGVJZCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkZXBlbmRlbmN5SWQ6IGRlcGVuZGVuY2llc0ZvckNhbGxiYWNrc1trXVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0XHRcdH0gY2F0Y2ggKGVycjIpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKG9wdGlvbnMub25FcnJvcmVkKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9ucy5vbkVycm9yZWQoe1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJhY2NlcHQtZXJyb3ItaGFuZGxlci1lcnJvcmVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtb2R1bGVJZDogb3V0ZGF0ZWRNb2R1bGVJZCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRlcGVuZGVuY3lJZDogZGVwZW5kZW5jaWVzRm9yQ2FsbGJhY2tzW2tdLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZXJyb3I6IGVycjIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvcmlnaW5hbEVycm9yOiBlcnJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIW9wdGlvbnMuaWdub3JlRXJyb3JlZCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlcG9ydEVycm9yKGVycjIpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlcG9ydEVycm9yKGVycik7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKG9wdGlvbnMub25FcnJvcmVkKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnMub25FcnJvcmVkKHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImFjY2VwdC1lcnJvcmVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bW9kdWxlSWQ6IG91dGRhdGVkTW9kdWxlSWQsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVwZW5kZW5jeUlkOiBkZXBlbmRlbmNpZXNGb3JDYWxsYmFja3Nba10sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZXJyb3I6IGVyclxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdGlmICghb3B0aW9ucy5pZ25vcmVFcnJvcmVkKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlcG9ydEVycm9yKGVycik7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIExvYWQgc2VsZiBhY2NlcHRlZCBtb2R1bGVzXG5cdFx0XHRmb3IgKHZhciBvID0gMDsgbyA8IG91dGRhdGVkU2VsZkFjY2VwdGVkTW9kdWxlcy5sZW5ndGg7IG8rKykge1xuXHRcdFx0XHR2YXIgaXRlbSA9IG91dGRhdGVkU2VsZkFjY2VwdGVkTW9kdWxlc1tvXTtcblx0XHRcdFx0dmFyIG1vZHVsZUlkID0gaXRlbS5tb2R1bGU7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0aXRlbS5yZXF1aXJlKG1vZHVsZUlkKTtcblx0XHRcdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRcdFx0aWYgKHR5cGVvZiBpdGVtLmVycm9ySGFuZGxlciA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRpdGVtLmVycm9ySGFuZGxlcihlcnIsIHtcblx0XHRcdFx0XHRcdFx0XHRtb2R1bGVJZDogbW9kdWxlSWQsXG5cdFx0XHRcdFx0XHRcdFx0bW9kdWxlOiBfX3dlYnBhY2tfcmVxdWlyZV9fLmNbbW9kdWxlSWRdXG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0fSBjYXRjaCAoZXJyMikge1xuXHRcdFx0XHRcdFx0XHRpZiAob3B0aW9ucy5vbkVycm9yZWQpIHtcblx0XHRcdFx0XHRcdFx0XHRvcHRpb25zLm9uRXJyb3JlZCh7XG5cdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInNlbGYtYWNjZXB0LWVycm9yLWhhbmRsZXItZXJyb3JlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0bW9kdWxlSWQ6IG1vZHVsZUlkLFxuXHRcdFx0XHRcdFx0XHRcdFx0ZXJyb3I6IGVycjIsXG5cdFx0XHRcdFx0XHRcdFx0XHRvcmlnaW5hbEVycm9yOiBlcnJcblx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZiAoIW9wdGlvbnMuaWdub3JlRXJyb3JlZCkge1xuXHRcdFx0XHRcdFx0XHRcdHJlcG9ydEVycm9yKGVycjIpO1xuXHRcdFx0XHRcdFx0XHRcdHJlcG9ydEVycm9yKGVycik7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0aWYgKG9wdGlvbnMub25FcnJvcmVkKSB7XG5cdFx0XHRcdFx0XHRcdG9wdGlvbnMub25FcnJvcmVkKHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInNlbGYtYWNjZXB0LWVycm9yZWRcIixcblx0XHRcdFx0XHRcdFx0XHRtb2R1bGVJZDogbW9kdWxlSWQsXG5cdFx0XHRcdFx0XHRcdFx0ZXJyb3I6IGVyclxuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICghb3B0aW9ucy5pZ25vcmVFcnJvcmVkKSB7XG5cdFx0XHRcdFx0XHRcdHJlcG9ydEVycm9yKGVycik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBvdXRkYXRlZE1vZHVsZXM7XG5cdFx0fVxuXHR9O1xufVxuX193ZWJwYWNrX3JlcXVpcmVfXy5obXJJLmpzb25wID0gZnVuY3Rpb24gKG1vZHVsZUlkLCBhcHBseUhhbmRsZXJzKSB7XG5cdGlmICghY3VycmVudFVwZGF0ZSkge1xuXHRcdGN1cnJlbnRVcGRhdGUgPSB7fTtcblx0XHRjdXJyZW50VXBkYXRlUnVudGltZSA9IFtdO1xuXHRcdGN1cnJlbnRVcGRhdGVSZW1vdmVkQ2h1bmtzID0gW107XG5cdFx0YXBwbHlIYW5kbGVycy5wdXNoKGFwcGx5SGFuZGxlcik7XG5cdH1cblx0aWYgKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oY3VycmVudFVwZGF0ZSwgbW9kdWxlSWQpKSB7XG5cdFx0Y3VycmVudFVwZGF0ZVttb2R1bGVJZF0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fLm1bbW9kdWxlSWRdO1xuXHR9XG59O1xuX193ZWJwYWNrX3JlcXVpcmVfXy5obXJDLmpzb25wID0gZnVuY3Rpb24gKFxuXHRjaHVua0lkcyxcblx0cmVtb3ZlZENodW5rcyxcblx0cmVtb3ZlZE1vZHVsZXMsXG5cdHByb21pc2VzLFxuXHRhcHBseUhhbmRsZXJzLFxuXHR1cGRhdGVkTW9kdWxlc0xpc3Rcbikge1xuXHRhcHBseUhhbmRsZXJzLnB1c2goYXBwbHlIYW5kbGVyKTtcblx0Y3VycmVudFVwZGF0ZUNodW5rcyA9IHt9O1xuXHRjdXJyZW50VXBkYXRlUmVtb3ZlZENodW5rcyA9IHJlbW92ZWRDaHVua3M7XG5cdGN1cnJlbnRVcGRhdGUgPSByZW1vdmVkTW9kdWxlcy5yZWR1Y2UoZnVuY3Rpb24gKG9iaiwga2V5KSB7XG5cdFx0b2JqW2tleV0gPSBmYWxzZTtcblx0XHRyZXR1cm4gb2JqO1xuXHR9LCB7fSk7XG5cdGN1cnJlbnRVcGRhdGVSdW50aW1lID0gW107XG5cdGNodW5rSWRzLmZvckVhY2goZnVuY3Rpb24gKGNodW5rSWQpIHtcblx0XHRpZiAoXG5cdFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8oaW5zdGFsbGVkQ2h1bmtzLCBjaHVua0lkKSAmJlxuXHRcdFx0aW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdICE9PSB1bmRlZmluZWRcblx0XHQpIHtcblx0XHRcdHByb21pc2VzLnB1c2gobG9hZFVwZGF0ZUNodW5rKGNodW5rSWQsIHVwZGF0ZWRNb2R1bGVzTGlzdCkpO1xuXHRcdFx0Y3VycmVudFVwZGF0ZUNodW5rc1tjaHVua0lkXSA9IHRydWU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGN1cnJlbnRVcGRhdGVDaHVua3NbY2h1bmtJZF0gPSBmYWxzZTtcblx0XHR9XG5cdH0pO1xuXHRpZiAoX193ZWJwYWNrX3JlcXVpcmVfXy5mKSB7XG5cdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5mLmpzb25wSG1yID0gZnVuY3Rpb24gKGNodW5rSWQsIHByb21pc2VzKSB7XG5cdFx0XHRpZiAoXG5cdFx0XHRcdGN1cnJlbnRVcGRhdGVDaHVua3MgJiZcblx0XHRcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vKGN1cnJlbnRVcGRhdGVDaHVua3MsIGNodW5rSWQpICYmXG5cdFx0XHRcdCFjdXJyZW50VXBkYXRlQ2h1bmtzW2NodW5rSWRdXG5cdFx0XHQpIHtcblx0XHRcdFx0cHJvbWlzZXMucHVzaChsb2FkVXBkYXRlQ2h1bmsoY2h1bmtJZCkpO1xuXHRcdFx0XHRjdXJyZW50VXBkYXRlQ2h1bmtzW2NodW5rSWRdID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9O1xuXHR9XG59O1xuXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmhtck0gPSAoKSA9PiB7XG5cdGlmICh0eXBlb2YgZmV0Y2ggPT09IFwidW5kZWZpbmVkXCIpIHRocm93IG5ldyBFcnJvcihcIk5vIGJyb3dzZXIgc3VwcG9ydDogbmVlZCBmZXRjaCBBUElcIik7XG5cdHJldHVybiBmZXRjaChfX3dlYnBhY2tfcmVxdWlyZV9fLnAgKyBfX3dlYnBhY2tfcmVxdWlyZV9fLmhtckYoKSkudGhlbigocmVzcG9uc2UpID0+IHtcblx0XHRpZihyZXNwb25zZS5zdGF0dXMgPT09IDQwNCkgcmV0dXJuOyAvLyBubyB1cGRhdGUgYXZhaWxhYmxlXG5cdFx0aWYoIXJlc3BvbnNlLm9rKSB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZmV0Y2ggdXBkYXRlIG1hbmlmZXN0IFwiICsgcmVzcG9uc2Uuc3RhdHVzVGV4dCk7XG5cdFx0cmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcblx0fSk7XG59O1xuXG4vLyBubyBvbiBjaHVua3MgbG9hZGVkXG5cbi8vIG5vIGpzb25wIGZ1bmN0aW9uIiwiX193ZWJwYWNrX3JlcXVpcmVfXy5uYyA9IHVuZGVmaW5lZDsiLCIiLCIvLyBtb2R1bGUgY2FjaGUgYXJlIHVzZWQgc28gZW50cnkgaW5saW5pbmcgaXMgZGlzYWJsZWRcbi8vIHN0YXJ0dXBcbi8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xudmFyIF9fd2VicGFja19leHBvcnRzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9hcHAvc3RhdGljL3BhZ2VzL2xheW91dC50c3hcIik7XG4iLCIiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=