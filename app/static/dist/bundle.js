/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@egjs/preact-flicking/dist/flicking.esm.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@egjs/preact-flicking/dist/flicking.esm.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ALIGN: () => (/* binding */ ALIGN),
/* harmony export */   AnchorPoint: () => (/* binding */ AnchorPoint),
/* harmony export */   AnimatingState: () => (/* binding */ AnimatingState),
/* harmony export */   AxesController: () => (/* binding */ AxesController),
/* harmony export */   BoundCameraMode: () => (/* binding */ BoundCameraMode),
/* harmony export */   CIRCULAR_FALLBACK: () => (/* binding */ CIRCULAR_FALLBACK),
/* harmony export */   CLASS: () => (/* binding */ CLASS),
/* harmony export */   Camera: () => (/* binding */ Camera),
/* harmony export */   CircularCameraMode: () => (/* binding */ CircularCameraMode),
/* harmony export */   Control: () => (/* binding */ Control),
/* harmony export */   DIRECTION: () => (/* binding */ DIRECTION),
/* harmony export */   DisabledState: () => (/* binding */ DisabledState),
/* harmony export */   DraggingState: () => (/* binding */ DraggingState),
/* harmony export */   ERROR_CODE: () => (/* binding */ CODE),
/* harmony export */   EVENTS: () => (/* binding */ EVENTS),
/* harmony export */   ExternalRenderer: () => (/* binding */ ExternalRenderer),
/* harmony export */   FlickingError: () => (/* binding */ FlickingError),
/* harmony export */   FreeControl: () => (/* binding */ FreeControl),
/* harmony export */   HoldingState: () => (/* binding */ HoldingState),
/* harmony export */   IdleState: () => (/* binding */ IdleState),
/* harmony export */   LinearCameraMode: () => (/* binding */ LinearCameraMode),
/* harmony export */   MOVE_TYPE: () => (/* binding */ MOVE_TYPE),
/* harmony export */   NormalRenderingStrategy: () => (/* binding */ NormalRenderingStrategy),
/* harmony export */   ORDER: () => (/* binding */ ORDER),
/* harmony export */   Panel: () => (/* binding */ Panel),
/* harmony export */   Renderer: () => (/* binding */ Renderer),
/* harmony export */   SnapControl: () => (/* binding */ SnapControl),
/* harmony export */   State: () => (/* binding */ State),
/* harmony export */   StateMachine: () => (/* binding */ StateMachine),
/* harmony export */   StrictControl: () => (/* binding */ StrictControl),
/* harmony export */   VanillaElementProvider: () => (/* binding */ VanillaElementProvider),
/* harmony export */   VanillaRenderer: () => (/* binding */ VanillaRenderer),
/* harmony export */   Viewport: () => (/* binding */ Viewport),
/* harmony export */   ViewportSlot: () => (/* binding */ ViewportSlot),
/* harmony export */   VirtualElementProvider: () => (/* binding */ VirtualElementProvider),
/* harmony export */   VirtualManager: () => (/* binding */ VirtualManager),
/* harmony export */   VirtualPanel: () => (/* binding */ VirtualPanel),
/* harmony export */   VirtualRenderingStrategy: () => (/* binding */ VirtualRenderingStrategy),
/* harmony export */   checkExistence: () => (/* binding */ checkExistence),
/* harmony export */   circulateIndex: () => (/* binding */ circulateIndex),
/* harmony export */   circulatePosition: () => (/* binding */ circulatePosition),
/* harmony export */   clamp: () => (/* binding */ clamp$1),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   find: () => (/* binding */ find$1),
/* harmony export */   findIndex: () => (/* binding */ findIndex),
/* harmony export */   findRight: () => (/* binding */ findRight),
/* harmony export */   getDefaultCameraTransform: () => (/* binding */ getDefaultCameraTransform),
/* harmony export */   getDirection: () => (/* binding */ getDirection$1),
/* harmony export */   getElement: () => (/* binding */ getElement),
/* harmony export */   getElementSize: () => (/* binding */ getElementSize),
/* harmony export */   getFlickingAttached: () => (/* binding */ getFlickingAttached),
/* harmony export */   getMinusCompensatedIndex: () => (/* binding */ getMinusCompensatedIndex),
/* harmony export */   getProgress: () => (/* binding */ getProgress),
/* harmony export */   getRenderingPanels: () => (/* binding */ getRenderingPanels),
/* harmony export */   getStyle: () => (/* binding */ getStyle),
/* harmony export */   includes: () => (/* binding */ includes),
/* harmony export */   isBetween: () => (/* binding */ isBetween),
/* harmony export */   isString: () => (/* binding */ isString),
/* harmony export */   merge: () => (/* binding */ merge),
/* harmony export */   parseAlign: () => (/* binding */ parseAlign$1),
/* harmony export */   parseArithmeticExpression: () => (/* binding */ parseArithmeticExpression),
/* harmony export */   parseArithmeticSize: () => (/* binding */ parseArithmeticSize),
/* harmony export */   parseBounce: () => (/* binding */ parseBounce),
/* harmony export */   parseCSSSizeValue: () => (/* binding */ parseCSSSizeValue),
/* harmony export */   parseElement: () => (/* binding */ parseElement),
/* harmony export */   parsePanelAlign: () => (/* binding */ parsePanelAlign),
/* harmony export */   range: () => (/* binding */ range),
/* harmony export */   setPrototypeOf: () => (/* binding */ setPrototypeOf),
/* harmony export */   setSize: () => (/* binding */ setSize),
/* harmony export */   sync: () => (/* binding */ sync),
/* harmony export */   toArray: () => (/* binding */ toArray$2),
/* harmony export */   withFlickingMethods: () => (/* binding */ withFlickingMethods)
/* harmony export */ });
/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.module.js");
/*
Copyright (c) 2021-present NAVER Corp.
name: @egjs/preact-flicking
license: MIT
author: NAVER Corp.
repository: https://github.com/naver/egjs-flicking/blob/master/packages/preact-flicking
version: 4.11.4
*/


var t,u,r,o=0,i=[],c=preact__WEBPACK_IMPORTED_MODULE_0__.options.__b,f=preact__WEBPACK_IMPORTED_MODULE_0__.options.__r,e=preact__WEBPACK_IMPORTED_MODULE_0__.options.diffed,a=preact__WEBPACK_IMPORTED_MODULE_0__.options.__c,v=preact__WEBPACK_IMPORTED_MODULE_0__.options.unmount;function m(t,r){preact__WEBPACK_IMPORTED_MODULE_0__.options.__h&&preact__WEBPACK_IMPORTED_MODULE_0__.options.__h(u,t,o||r),o=0;var i=u.__H||(u.__H={__:[],__h:[]});return t>=i.__.length&&i.__.push({}),i.__[t]}function l(n){return o=1,p(w,n)}function p(n,r,o){var i=m(t++,2);return i.t=n,i.__c||(i.__=[o?o(r):w(void 0,r),function(n){var t=i.t(i.__[0],n);i.__[0]!==t&&(i.__=[t,i.__[1]],i.__c.setState({}));}],i.__c=u),i.__}function y(r,o){var i=m(t++,3);!preact__WEBPACK_IMPORTED_MODULE_0__.options.__s&&k(i.__H,o)&&(i.__=r,i.__H=o,u.__H.__h.push(i));}function h(r,o){var i=m(t++,4);!preact__WEBPACK_IMPORTED_MODULE_0__.options.__s&&k(i.__H,o)&&(i.__=r,i.__H=o,u.__h.push(i));}function s(n){return o=5,d(function(){return {current:n}},[])}function _(n,t,u){o=6,h(function(){"function"==typeof n?n(t()):n&&(n.current=t());},null==u?u:u.concat(n));}function d(n,u){var r=m(t++,7);return k(r.__H,u)&&(r.__=n(),r.__H=u,r.__h=n),r.__}function A(n,t){return o=8,d(function(){return n},t)}function F(n){var r=u.context[n.__c],o=m(t++,9);return o.c=n,r?(null==o.__&&(o.__=!0,r.sub(u)),r.props.value):n.__}function T(t,u){preact__WEBPACK_IMPORTED_MODULE_0__.options.useDebugValue&&preact__WEBPACK_IMPORTED_MODULE_0__.options.useDebugValue(u?u(t):t);}function x(){var t;for(i.sort(function(n,t){return n.__v.__b-t.__v.__b});t=i.pop();)if(t.__P)try{t.__H.__h.forEach(g),t.__H.__h.forEach(j),t.__H.__h=[];}catch(u){t.__H.__h=[],preact__WEBPACK_IMPORTED_MODULE_0__.options.__e(u,t.__v);}}preact__WEBPACK_IMPORTED_MODULE_0__.options.__b=function(n){u=null,c&&c(n);},preact__WEBPACK_IMPORTED_MODULE_0__.options.__r=function(n){f&&f(n),t=0;var r=(u=n.__c).__H;r&&(r.__h.forEach(g),r.__h.forEach(j),r.__h=[]);},preact__WEBPACK_IMPORTED_MODULE_0__.options.diffed=function(t){e&&e(t);var o=t.__c;o&&o.__H&&o.__H.__h.length&&(1!==i.push(o)&&r===preact__WEBPACK_IMPORTED_MODULE_0__.options.requestAnimationFrame||((r=preact__WEBPACK_IMPORTED_MODULE_0__.options.requestAnimationFrame)||function(n){var t,u=function(){clearTimeout(r),b&&cancelAnimationFrame(t),setTimeout(n);},r=setTimeout(u,100);b&&(t=requestAnimationFrame(u));})(x)),u=null;},preact__WEBPACK_IMPORTED_MODULE_0__.options.__c=function(t,u){u.some(function(t){try{t.__h.forEach(g),t.__h=t.__h.filter(function(n){return !n.__||j(n)});}catch(r){u.some(function(n){n.__h&&(n.__h=[]);}),u=[],preact__WEBPACK_IMPORTED_MODULE_0__.options.__e(r,t.__v);}}),a&&a(t,u);},preact__WEBPACK_IMPORTED_MODULE_0__.options.unmount=function(t){v&&v(t);var u,r=t.__c;r&&r.__H&&(r.__H.__.forEach(function(n){try{g(n);}catch(n){u=n;}}),u&&preact__WEBPACK_IMPORTED_MODULE_0__.options.__e(u,r.__v));};var b="function"==typeof requestAnimationFrame;function g(n){var t=u,r=n.__c;"function"==typeof r&&(n.__c=void 0,r()),u=t;}function j(n){var t=u;n.__c=n.__(),u=t;}function k(n,t){return !n||n.length!==t.length||t.some(function(t,u){return t!==n[u]})}function w(n,t){return "function"==typeof t?t(n):t}

function S(n,t){for(var e in t)n[e]=t[e];return n}function C(n,t){for(var e in n)if("__source"!==e&&!(e in t))return !0;for(var r in t)if("__source"!==r&&n[r]!==t[r])return !0;return !1}function E(n){this.props=n;}function g$1(n,t){function e(n){var e=this.props.ref,r=e==n.ref;return !r&&e&&(e.call?e(null):e.current=null),t?!t(this.props,n)||!r:C(this.props,n)}function r(t){return this.shouldComponentUpdate=e,(0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(n,t)}return r.displayName="Memo("+(n.displayName||n.name)+")",r.prototype.isReactComponent=!0,r.__f=!0,r}(E.prototype=new preact__WEBPACK_IMPORTED_MODULE_0__.Component).isPureReactComponent=!0,E.prototype.shouldComponentUpdate=function(n,t){return C(this.props,n)||C(this.state,t)};var w$1=preact__WEBPACK_IMPORTED_MODULE_0__.options.__b;preact__WEBPACK_IMPORTED_MODULE_0__.options.__b=function(n){n.type&&n.type.__f&&n.ref&&(n.props.ref=n.ref,n.ref=null),w$1&&w$1(n);};var R="undefined"!=typeof Symbol&&Symbol.for&&Symbol.for("react.forward_ref")||3911;function x$1(n){function t(t,e){var r=S({},t);return delete r.ref,n(r,(e=t.ref||e)&&("object"!=typeof e||"current"in e)?e:null)}return t.$$typeof=R,t.render=t,t.prototype.isReactComponent=t.__f=!0,t.displayName="ForwardRef("+(n.displayName||n.name)+")",t}var N=function(n,t){return null==n?null:(0,preact__WEBPACK_IMPORTED_MODULE_0__.toChildArray)((0,preact__WEBPACK_IMPORTED_MODULE_0__.toChildArray)(n).map(t))},k$1={map:N,forEach:N,count:function(n){return n?(0,preact__WEBPACK_IMPORTED_MODULE_0__.toChildArray)(n).length:0},only:function(n){var t=(0,preact__WEBPACK_IMPORTED_MODULE_0__.toChildArray)(n);if(1!==t.length)throw "Children.only";return t[0]},toArray:preact__WEBPACK_IMPORTED_MODULE_0__.toChildArray},A$1=preact__WEBPACK_IMPORTED_MODULE_0__.options.__e;preact__WEBPACK_IMPORTED_MODULE_0__.options.__e=function(n,t,e){if(n.then)for(var r,u=t;u=u.__;)if((r=u.__c)&&r.__c)return null==t.__e&&(t.__e=e.__e,t.__k=e.__k),r.__c(n,t);A$1(n,t,e);};var O=preact__WEBPACK_IMPORTED_MODULE_0__.options.unmount;function L(){this.__u=0,this.t=null,this.__b=null;}function U(n){var t=n.__.__c;return t&&t.__e&&t.__e(n)}function F$1(n){var t,e,r;function u(u){if(t||(t=n()).then(function(n){e=n.default||n;},function(n){r=n;}),r)throw r;if(!e)throw t;return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(e,u)}return u.displayName="Lazy",u.__f=!0,u}function M(){this.u=null,this.o=null;}preact__WEBPACK_IMPORTED_MODULE_0__.options.unmount=function(n){var t=n.__c;t&&t.__R&&t.__R(),t&&!0===n.__h&&(n.type=null),O&&O(n);},(L.prototype=new preact__WEBPACK_IMPORTED_MODULE_0__.Component).__c=function(n,t){var e=t.__c,r=this;null==r.t&&(r.t=[]),r.t.push(e);var u=U(r.__v),o=!1,i=function(){o||(o=!0,e.__R=null,u?u(l):l());};e.__R=i;var l=function(){if(!--r.__u){if(r.state.__e){var n=r.state.__e;r.__v.__k[0]=function n(t,e,r){return t&&(t.__v=null,t.__k=t.__k&&t.__k.map(function(t){return n(t,e,r)}),t.__c&&t.__c.__P===e&&(t.__e&&r.insertBefore(t.__e,t.__d),t.__c.__e=!0,t.__c.__P=r)),t}(n,n.__c.__P,n.__c.__O);}var t;for(r.setState({__e:r.__b=null});t=r.t.pop();)t.forceUpdate();}},c=!0===t.__h;r.__u++||c||r.setState({__e:r.__b=r.__v.__k[0]}),n.then(i,i);},L.prototype.componentWillUnmount=function(){this.t=[];},L.prototype.render=function(n,t){if(this.__b){if(this.__v.__k){var e=document.createElement("div"),r=this.__v.__k[0].__c;this.__v.__k[0]=function n(t,e,r){return t&&(t.__c&&t.__c.__H&&(t.__c.__H.__.forEach(function(n){"function"==typeof n.__c&&n.__c();}),t.__c.__H=null),null!=(t=S({},t)).__c&&(t.__c.__P===r&&(t.__c.__P=e),t.__c=null),t.__k=t.__k&&t.__k.map(function(t){return n(t,e,r)})),t}(this.__b,e,r.__O=r.__P);}this.__b=null;}var u=t.__e&&(0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(preact__WEBPACK_IMPORTED_MODULE_0__.Fragment,null,n.fallback);return u&&(u.__h=null),[(0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(preact__WEBPACK_IMPORTED_MODULE_0__.Fragment,null,t.__e?null:n.children),u]};var T$1=function(n,t,e){if(++e[1]===e[0]&&n.o.delete(t),n.props.revealOrder&&("t"!==n.props.revealOrder[0]||!n.o.size))for(e=n.u;e;){for(;e.length>3;)e.pop()();if(e[1]<e[0])break;n.u=e=e[2];}};function D(n){return this.getChildContext=function(){return n.context},n.children}function I(n){var t=this,e=n.i;t.componentWillUnmount=function(){(0,preact__WEBPACK_IMPORTED_MODULE_0__.render)(null,t.l),t.l=null,t.i=null;},t.i&&t.i!==e&&t.componentWillUnmount(),n.__v?(t.l||(t.i=e,t.l={nodeType:1,parentNode:e,childNodes:[],appendChild:function(n){this.childNodes.push(n),t.i.appendChild(n);},insertBefore:function(n,e){this.childNodes.push(n),t.i.appendChild(n);},removeChild:function(n){this.childNodes.splice(this.childNodes.indexOf(n)>>>1,1),t.i.removeChild(n);}}),(0,preact__WEBPACK_IMPORTED_MODULE_0__.render)((0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(D,{context:t.context},n.__v),t.l)):t.l&&t.componentWillUnmount();}function W(n,t){return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(I,{__v:n,i:t})}(M.prototype=new preact__WEBPACK_IMPORTED_MODULE_0__.Component).__e=function(n){var t=this,e=U(t.__v),r=t.o.get(n);return r[0]++,function(u){var o=function(){t.props.revealOrder?(r.push(u),T$1(t,n,r)):u();};e?e(o):o();}},M.prototype.render=function(n){this.u=null,this.o=new Map;var t=(0,preact__WEBPACK_IMPORTED_MODULE_0__.toChildArray)(n.children);n.revealOrder&&"b"===n.revealOrder[0]&&t.reverse();for(var e=t.length;e--;)this.o.set(t[e],this.u=[1,0,this.u]);return n.children},M.prototype.componentDidUpdate=M.prototype.componentDidMount=function(){var n=this;this.o.forEach(function(t,e){T$1(n,e,t);});};var j$1="undefined"!=typeof Symbol&&Symbol.for&&Symbol.for("react.element")||60103,P=/^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|marker(?!H|W|U)|overline|paint|stop|strikethrough|stroke|text(?!L)|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/,V="undefined"!=typeof document,z=function(n){return ("undefined"!=typeof Symbol&&"symbol"==typeof Symbol()?/fil|che|rad/i:/fil|che|ra/i).test(n)};function B(n,t,e){return null==t.__k&&(t.textContent=""),(0,preact__WEBPACK_IMPORTED_MODULE_0__.render)(n,t),"function"==typeof e&&e(),n?n.__c:null}function $(n,t,e){return (0,preact__WEBPACK_IMPORTED_MODULE_0__.hydrate)(n,t),"function"==typeof e&&e(),n?n.__c:null}preact__WEBPACK_IMPORTED_MODULE_0__.Component.prototype.isReactComponent={},["componentWillMount","componentWillReceiveProps","componentWillUpdate"].forEach(function(n){Object.defineProperty(preact__WEBPACK_IMPORTED_MODULE_0__.Component.prototype,n,{configurable:!0,get:function(){return this["UNSAFE_"+n]},set:function(t){Object.defineProperty(this,n,{configurable:!0,writable:!0,value:t});}});});var H=preact__WEBPACK_IMPORTED_MODULE_0__.options.event;function Z(){}function Y(){return this.cancelBubble}function q(){return this.defaultPrevented}preact__WEBPACK_IMPORTED_MODULE_0__.options.event=function(n){return H&&(n=H(n)),n.persist=Z,n.isPropagationStopped=Y,n.isDefaultPrevented=q,n.nativeEvent=n};var G,J={configurable:!0,get:function(){return this.class}},K=preact__WEBPACK_IMPORTED_MODULE_0__.options.vnode;preact__WEBPACK_IMPORTED_MODULE_0__.options.vnode=function(n){var t=n.type,e=n.props,r=e;if("string"==typeof t){var u=-1===t.indexOf("-");for(var o in r={},e){var i=e[o];V&&"children"===o&&"noscript"===t||"value"===o&&"defaultValue"in e&&null==i||("defaultValue"===o&&"value"in e&&null==e.value?o="value":"download"===o&&!0===i?i="":/ondoubleclick/i.test(o)?o="ondblclick":/^onchange(textarea|input)/i.test(o+t)&&!z(e.type)?o="oninput":/^onfocus$/i.test(o)?o="onfocusin":/^onblur$/i.test(o)?o="onfocusout":/^on(Ani|Tra|Tou|BeforeInp)/.test(o)?o=o.toLowerCase():u&&P.test(o)?o=o.replace(/[A-Z0-9]/,"-$&").toLowerCase():null===i&&(i=void 0),r[o]=i);}"select"==t&&r.multiple&&Array.isArray(r.value)&&(r.value=(0,preact__WEBPACK_IMPORTED_MODULE_0__.toChildArray)(e.children).forEach(function(n){n.props.selected=-1!=r.value.indexOf(n.props.value);})),"select"==t&&null!=r.defaultValue&&(r.value=(0,preact__WEBPACK_IMPORTED_MODULE_0__.toChildArray)(e.children).forEach(function(n){n.props.selected=r.multiple?-1!=r.defaultValue.indexOf(n.props.value):r.defaultValue==n.props.value;})),n.props=r,e.class!=e.className&&(J.enumerable="className"in e,null!=e.className&&(r.class=e.className),Object.defineProperty(r,"className",J));}n.$$typeof=j$1,K&&K(n);};var Q=preact__WEBPACK_IMPORTED_MODULE_0__.options.__r;preact__WEBPACK_IMPORTED_MODULE_0__.options.__r=function(n){Q&&Q(n),G=n.__c;};var X={ReactCurrentDispatcher:{current:{readContext:function(n){return G.__n[n.__c].props.value}}}};function tn(n){return preact__WEBPACK_IMPORTED_MODULE_0__.createElement.bind(null,n)}function en(n){return !!n&&n.$$typeof===j$1}function rn(n){return en(n)?preact__WEBPACK_IMPORTED_MODULE_0__.cloneElement.apply(null,arguments):n}function un(n){return !!n.__k&&((0,preact__WEBPACK_IMPORTED_MODULE_0__.render)(null,n),!0)}function on(n){return n&&(n.base||1===n.nodeType&&n)||null}var ln=function(n,t){return n(t)},cn=function(n,t){return n(t)};var React__default = {useState:l,useReducer:p,useEffect:y,useLayoutEffect:h,useRef:s,useImperativeHandle:_,useMemo:d,useCallback:A,useContext:F,useDebugValue:T,version:"17.0.2",Children:k$1,render:B,hydrate:$,unmountComponentAtNode:un,createPortal:W,createElement:preact__WEBPACK_IMPORTED_MODULE_0__.createElement,createContext:preact__WEBPACK_IMPORTED_MODULE_0__.createContext,createFactory:tn,cloneElement:rn,createRef:preact__WEBPACK_IMPORTED_MODULE_0__.createRef,Fragment:preact__WEBPACK_IMPORTED_MODULE_0__.Fragment,isValidElement:en,findDOMNode:on,Component:preact__WEBPACK_IMPORTED_MODULE_0__.Component,PureComponent:E,memo:g$1,forwardRef:x$1,flushSync:cn,unstable_batchedUpdates:ln,StrictMode:preact__WEBPACK_IMPORTED_MODULE_0__.Fragment,Suspense:L,SuspenseList:M,lazy:F$1,__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED:X};

/*
Copyright (c) NAVER Corp.
name: @egjs/component
license: MIT
author: NAVER Corp.
repository: https://github.com/naver/egjs-component
version: 3.0.4
*/
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator,
    m = s && o[s],
    i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function () {
      if (o && i >= o.length) o = void 0;
      return {
        value: o && o[i++],
        done: !o
      };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o),
    r,
    ar = [],
    e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = {
      error: error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
  return ar;
}

/*
 * Copyright (c) 2015 NAVER Corp.
 * egjs projects are licensed under the MIT license
 */
var isUndefined = function (value) {
  return typeof value === "undefined";
};

// This class name is not matched to file name intentionally
/**
 * Event class to provide additional properties
 * @ko Component에서 추가적인 프로퍼티를 제공하는 이벤트 클래스
 */
var ComponentEvent = /*#__PURE__*/function () {
  /**
   * Create a new instance of ComponentEvent.
   * @ko ComponentEvent의 새로운 인스턴스를 생성한다.
   * @param eventType The name of the event.<ko>이벤트 이름.</ko>
   * @param props An object that contains additional event properties.<ko>추가적인 이벤트 프로퍼티 오브젝트.</ko>
   */
  function ComponentEvent(eventType, props) {
    var e_1, _a;
    this._canceled = false;
    if (props) {
      try {
        for (var _b = __values(Object.keys(props)), _c = _b.next(); !_c.done; _c = _b.next()) {
          var key = _c.value;
          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
          this[key] = props[key];
        }
      } catch (e_1_1) {
        e_1 = {
          error: e_1_1
        };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        } finally {
          if (e_1) throw e_1.error;
        }
      }
    }
    this.eventType = eventType;
  }
  /**
   * Stop the event. {@link ComponentEvent#isCanceled} will return `true` after.
   * @ko 이벤트를 중단한다. 이후 {@link ComponentEvent#isCanceled}가 `true`를 반환한다.
   */
  var __proto = ComponentEvent.prototype;
  __proto.stop = function () {
    this._canceled = true;
  };
  /**
   * Returns a boolean value that indicates whether {@link ComponentEvent#stop} is called before.
   * @ko {@link ComponentEvent#stop}이 호출되었는지 여부를 반환한다.
   * @return {boolean} A boolean value that indicates whether {@link ComponentEvent#stop} is called before.<ko>이전에 {@link ComponentEvent#stop}이 불려졌는지 여부를 반환한다.</ko>
   */
  __proto.isCanceled = function () {
    return this._canceled;
  };
  return ComponentEvent;
}();

/**
 * A class used to manage events in a component
 * @ko 컴포넌트의 이벤트을 관리할 수 있게 하는 클래스
 */
var Component = /*#__PURE__*/function () {
  /**
   * @support {"ie": "7+", "ch" : "latest", "ff" : "latest",  "sf" : "latest", "edge" : "latest", "ios" : "7+", "an" : "2.1+ (except 3.x)"}
   */
  function Component() {
    this._eventHandler = {};
  }
  /**
   * Trigger a custom event.
   * @ko 커스텀 이벤트를 발생시킨다
   * @param {string | ComponentEvent} event The name of the custom event to be triggered or an instance of the ComponentEvent<ko>발생할 커스텀 이벤트의 이름 또는 ComponentEvent의 인스턴스</ko>
   * @param {any[]} params Event data to be sent when triggering a custom event <ko>커스텀 이벤트가 발생할 때 전달할 데이터</ko>
   * @return An instance of the component itself<ko>컴포넌트 자신의 인스턴스</ko>
   * @example
   * ```ts
   * import Component, { ComponentEvent } from "@egjs/component";
   *
   * class Some extends Component<{
   *   beforeHi: ComponentEvent<{ foo: number; bar: string }>;
   *   hi: { foo: { a: number; b: boolean } };
   *   someEvent: (foo: number, bar: string) => void;
   *   someOtherEvent: void; // When there's no event argument
   * }> {
   *   some(){
   *     if(this.trigger("beforeHi")){ // When event call to stop return false.
   *       this.trigger("hi");// fire hi event.
   *     }
   *   }
   * }
   *
   * const some = new Some();
   * some.on("beforeHi", e => {
   *   if(condition){
   *     e.stop(); // When event call to stop, `hi` event not call.
   *   }
   *   // `currentTarget` is component instance.
   *   console.log(some === e.currentTarget); // true
   *
   *   typeof e.foo; // number
   *   typeof e.bar; // string
   * });
   * some.on("hi", e => {
   *   typeof e.foo.b; // boolean
   * });
   * // If you want to more know event design. You can see article.
   * // https://github.com/naver/egjs-component/wiki/How-to-make-Component-event-design%3F
   * ```
   */
  var __proto = Component.prototype;
  __proto.trigger = function (event) {
    var params = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      params[_i - 1] = arguments[_i];
    }
    var eventName = event instanceof ComponentEvent ? event.eventType : event;
    var handlers = __spread(this._eventHandler[eventName] || []);
    if (handlers.length <= 0) {
      return this;
    }
    if (event instanceof ComponentEvent) {
      event.currentTarget = this;
      handlers.forEach(function (handler) {
        handler(event);
      });
    } else {
      handlers.forEach(function (handler) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-call
        handler.apply(void 0, __spread(params));
      });
    }
    return this;
  };
  /**
   * Executed event just one time.
   * @ko 이벤트가 한번만 실행된다.
   * @param {string} eventName The name of the event to be attached or an event name - event handler mapped object.<ko>등록할 이벤트의 이름 또는 이벤트 이름-핸들러 오브젝트</ko>
   * @param {function} handlerToAttach The handler function of the event to be attached <ko>등록할 이벤트의 핸들러 함수</ko>
   * @return An instance of the component itself<ko>컴포넌트 자신의 인스턴스</ko>
   * @example
   * ```ts
   * import Component, { ComponentEvent } from "@egjs/component";
   *
   * class Some extends Component<{
   *   hi: ComponentEvent;
   * }> {
   *   hi() {
   *     alert("hi");
   *   }
   *   thing() {
   *     this.once("hi", this.hi);
   *   }
   * }
   *
   * var some = new Some();
   * some.thing();
   * some.trigger(new ComponentEvent("hi"));
   * // fire alert("hi");
   * some.trigger(new ComponentEvent("hi"));
   * // Nothing happens
   * ```
   */
  __proto.once = function (eventName, handlerToAttach) {
    var _this = this;
    if (typeof eventName === "object" && isUndefined(handlerToAttach)) {
      var eventHash = eventName;
      for (var key in eventHash) {
        this.once(key, eventHash[key]);
      }
      return this;
    } else if (typeof eventName === "string" && typeof handlerToAttach === "function") {
      var listener_1 = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        // eslint-disable-next-line @typescript-eslint/no-unsafe-call
        handlerToAttach.apply(void 0, __spread(args));
        _this.off(eventName, listener_1);
      };
      this.on(eventName, listener_1);
    }
    return this;
  };
  /**
   * Checks whether an event has been attached to a component.
   * @ko 컴포넌트에 이벤트가 등록됐는지 확인한다.
   * @param {string} eventName The name of the event to be attached <ko>등록 여부를 확인할 이벤트의 이름</ko>
   * @return {boolean} Indicates whether the event is attached. <ko>이벤트 등록 여부</ko>
   * @example
   * ```ts
   * import Component from "@egjs/component";
   *
   * class Some extends Component<{
   *   hi: void;
   * }> {
   *   some() {
   *     this.hasOn("hi");// check hi event.
   *   }
   * }
   * ```
   */
  __proto.hasOn = function (eventName) {
    return !!this._eventHandler[eventName];
  };
  /**
   * Attaches an event to a component.
   * @ko 컴포넌트에 이벤트를 등록한다.
   * @param {string} eventName The name of the event to be attached or an event name - event handler mapped object.<ko>등록할 이벤트의 이름 또는 이벤트 이름-핸들러 오브젝트</ko>
   * @param {function} handlerToAttach The handler function of the event to be attached <ko>등록할 이벤트의 핸들러 함수</ko>
   * @return An instance of a component itself<ko>컴포넌트 자신의 인스턴스</ko>
   * @example
   * ```ts
   * import Component, { ComponentEvent } from "@egjs/component";
   *
   * class Some extends Component<{
   *   hi: void;
   * }> {
   *   hi() {
   *     console.log("hi");
   *   }
   *   some() {
   *     this.on("hi",this.hi); //attach event
   *   }
   * }
   * ```
   */
  __proto.on = function (eventName, handlerToAttach) {
    if (typeof eventName === "object" && isUndefined(handlerToAttach)) {
      var eventHash = eventName;
      for (var name in eventHash) {
        this.on(name, eventHash[name]);
      }
      return this;
    } else if (typeof eventName === "string" && typeof handlerToAttach === "function") {
      var handlerList = this._eventHandler[eventName];
      if (isUndefined(handlerList)) {
        this._eventHandler[eventName] = [];
        handlerList = this._eventHandler[eventName];
      }
      handlerList.push(handlerToAttach);
    }
    return this;
  };
  /**
   * Detaches an event from the component.<br/>If the `eventName` is not given this will detach all event handlers attached.<br/>If the `handlerToDetach` is not given, this will detach all event handlers for `eventName`.
   * @ko 컴포넌트에 등록된 이벤트를 해제한다.<br/>`eventName`이 주어지지 않았을 경우 모든 이벤트 핸들러를 제거한다.<br/>`handlerToAttach`가 주어지지 않았을 경우 `eventName`에 해당하는 모든 이벤트 핸들러를 제거한다.
   * @param {string?} eventName The name of the event to be detached <ko>해제할 이벤트의 이름</ko>
   * @param {function?} handlerToDetach The handler function of the event to be detached <ko>해제할 이벤트의 핸들러 함수</ko>
   * @return An instance of a component itself <ko>컴포넌트 자신의 인스턴스</ko>
   * @example
   * ```ts
   * import Component, { ComponentEvent } from "@egjs/component";
   *
   * class Some extends Component<{
   *   hi: void;
   * }> {
   *   hi() {
   *     console.log("hi");
   *   }
   *   some() {
   *     this.off("hi",this.hi); //detach event
   *   }
   * }
   * ```
   */
  __proto.off = function (eventName, handlerToDetach) {
    var e_1, _a;
    // Detach all event handlers.
    if (isUndefined(eventName)) {
      this._eventHandler = {};
      return this;
    }
    // Detach all handlers for eventname or detach event handlers by object.
    if (isUndefined(handlerToDetach)) {
      if (typeof eventName === "string") {
        delete this._eventHandler[eventName];
        return this;
      } else {
        var eventHash = eventName;
        for (var name in eventHash) {
          this.off(name, eventHash[name]);
        }
        return this;
      }
    }
    // Detach single event handler
    var handlerList = this._eventHandler[eventName];
    if (handlerList) {
      var idx = 0;
      try {
        for (var handlerList_1 = __values(handlerList), handlerList_1_1 = handlerList_1.next(); !handlerList_1_1.done; handlerList_1_1 = handlerList_1.next()) {
          var handlerFunction = handlerList_1_1.value;
          if (handlerFunction === handlerToDetach) {
            handlerList.splice(idx, 1);
            if (handlerList.length <= 0) {
              delete this._eventHandler[eventName];
            }
            break;
          }
          idx++;
        }
      } catch (e_1_1) {
        e_1 = {
          error: e_1_1
        };
      } finally {
        try {
          if (handlerList_1_1 && !handlerList_1_1.done && (_a = handlerList_1.return)) _a.call(handlerList_1);
        } finally {
          if (e_1) throw e_1.error;
        }
      }
    }
    return this;
  };
  /**
   * Version info string
   * @ko 버전정보 문자열
   * @name VERSION
   * @static
   * @example
   * Component.VERSION;  // ex) 3.0.0
   * @memberof Component
   */
  Component.VERSION = "3.0.4";
  return Component;
}();

/*
 * Copyright (c) 2015 NAVER Corp.
 * egjs projects are licensed under the MIT license
 */
// eslint-disable-next-line @typescript-eslint/naming-convention, @typescript-eslint/no-unsafe-assignment
var ComponentEvent$1 = ComponentEvent;

/*
Copyright (c) 2019-present NAVER Corp.
name: @egjs/list-differ
license: MIT
author: NAVER Corp.
repository: https://github.com/naver/egjs-list-differ
version: 1.0.1
*/
/*
egjs-list-differ
Copyright (c) 2019-present NAVER Corp.
MIT license
*/
var PolyMap =
/*#__PURE__*/
function () {
  function PolyMap() {
    this.keys = [];
    this.values = [];
  }

  var __proto = PolyMap.prototype;

  __proto.get = function (key) {
    return this.values[this.keys.indexOf(key)];
  };

  __proto.set = function (key, value) {
    var keys = this.keys;
    var values = this.values;
    var prevIndex = keys.indexOf(key);
    var index = prevIndex === -1 ? keys.length : prevIndex;
    keys[index] = key;
    values[index] = value;
  };

  return PolyMap;
}();

/*
egjs-list-differ
Copyright (c) 2019-present NAVER Corp.
MIT license
*/
var HashMap =
/*#__PURE__*/
function () {
  function HashMap() {
    this.object = {};
  }

  var __proto = HashMap.prototype;

  __proto.get = function (key) {
    return this.object[key];
  };

  __proto.set = function (key, value) {
    this.object[key] = value;
  };

  return HashMap;
}();

/*
egjs-list-differ
Copyright (c) 2019-present NAVER Corp.
MIT license
*/
var SUPPORT_MAP = typeof Map === "function";

/*
egjs-list-differ
Copyright (c) 2019-present NAVER Corp.
MIT license
*/
var Link =
/*#__PURE__*/
function () {
  function Link() {}

  var __proto = Link.prototype;

  __proto.connect = function (prevLink, nextLink) {
    this.prev = prevLink;
    this.next = nextLink;
    prevLink && (prevLink.next = this);
    nextLink && (nextLink.prev = this);
  };

  __proto.disconnect = function () {
    // In double linked list, diconnect the interconnected relationship.
    var prevLink = this.prev;
    var nextLink = this.next;
    prevLink && (prevLink.next = nextLink);
    nextLink && (nextLink.prev = prevLink);
  };

  __proto.getIndex = function () {
    var link = this;
    var index = -1;

    while (link) {
      link = link.prev;
      ++index;
    }

    return index;
  };

  return Link;
}();

/*
egjs-list-differ
Copyright (c) 2019-present NAVER Corp.
MIT license
*/

function orderChanged(changed, fixed) {
  // It is roughly in the order of these examples.
  // 4, 6, 0, 2, 1, 3, 5, 7
  var fromLinks = []; // 0, 1, 2, 3, 4, 5, 6, 7

  var toLinks = [];
  changed.forEach(function (_a) {
    var from = _a[0],
        to = _a[1];
    var link = new Link();
    fromLinks[from] = link;
    toLinks[to] = link;
  }); // `fromLinks` are connected to each other by double linked list.

  fromLinks.forEach(function (link, i) {
    link.connect(fromLinks[i - 1]);
  });
  return changed.filter(function (_, i) {
    return !fixed[i];
  }).map(function (_a, i) {
    var from = _a[0],
        to = _a[1];

    if (from === to) {
      return [0, 0];
    }

    var fromLink = fromLinks[from];
    var toLink = toLinks[to - 1];
    var fromIndex = fromLink.getIndex(); // Disconnect the link connected to `fromLink`.

    fromLink.disconnect(); // Connect `fromLink` to the right of `toLink`.

    if (!toLink) {
      fromLink.connect(undefined, fromLinks[0]);
    } else {
      fromLink.connect(toLink, toLink.next);
    }

    var toIndex = fromLink.getIndex();
    return [fromIndex, toIndex];
  });
}

var Result =
/*#__PURE__*/
function () {
  function Result(prevList, list, added, removed, changed, maintained, changedBeforeAdded, fixed) {
    this.prevList = prevList;
    this.list = list;
    this.added = added;
    this.removed = removed;
    this.changed = changed;
    this.maintained = maintained;
    this.changedBeforeAdded = changedBeforeAdded;
    this.fixed = fixed;
  }

  var __proto = Result.prototype;
  Object.defineProperty(__proto, "ordered", {
    get: function () {
      if (!this.cacheOrdered) {
        this.caculateOrdered();
      }

      return this.cacheOrdered;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(__proto, "pureChanged", {
    get: function () {
      if (!this.cachePureChanged) {
        this.caculateOrdered();
      }

      return this.cachePureChanged;
    },
    enumerable: true,
    configurable: true
  });

  __proto.caculateOrdered = function () {
    var ordered = orderChanged(this.changedBeforeAdded, this.fixed);
    var changed = this.changed;
    var pureChanged = [];
    this.cacheOrdered = ordered.filter(function (_a, i) {
      var from = _a[0],
          to = _a[1];
      var _b = changed[i],
          fromBefore = _b[0],
          toBefore = _b[1];

      if (from !== to) {
        pureChanged.push([fromBefore, toBefore]);
        return true;
      }
    });
    this.cachePureChanged = pureChanged;
  };

  return Result;
}();

/**
 *
 * @memberof eg.ListDiffer
 * @static
 * @function
 * @param - Previous List <ko> 이전 목록 </ko>
 * @param - List to Update <ko> 업데이트 할 목록 </ko>
 * @param - This callback function returns the key of the item. <ko> 아이템의 키를 반환하는 콜백 함수입니다.</ko>
 * @return - Returns the diff between `prevList` and `list` <ko> `prevList`와 `list`의 다른 점을 반환한다.</ko>
 * @example
 * import { diff } from "@egjs/list-differ";
 * // script => eg.ListDiffer.diff
 * const result = diff([0, 1, 2, 3, 4, 5], [7, 8, 0, 4, 3, 6, 2, 1], e => e);
 * // List before update
 * // [1, 2, 3, 4, 5]
 * console.log(result.prevList);
 * // Updated list
 * // [4, 3, 6, 2, 1]
 * console.log(result.list);
 * // Index array of values added to `list`
 * // [0, 1, 5]
 * console.log(result.added);
 * // Index array of values removed in `prevList`
 * // [5]
 * console.log(result.removed);
 * // An array of index pairs of `prevList` and `list` with different indexes from `prevList` and `list`
 * // [[0, 2], [4, 3], [3, 4], [2, 6], [1, 7]]
 * console.log(result.changed);
 * // The subset of `changed` and an array of index pairs that moved data directly. Indicate an array of absolute index pairs of `ordered`.(Formatted by: Array<[index of prevList, index of list]>)
 * // [[4, 3], [3, 4], [2, 6]]
 * console.log(result.pureChanged);
 * // An array of index pairs to be `ordered` that can synchronize `list` before adding data. (Formatted by: Array<[prevIndex, nextIndex]>)
 * // [[4, 1], [4, 2], [4, 3]]
 * console.log(result.ordered);
 * // An array of index pairs of `prevList` and `list` that have not been added/removed so data is preserved
 * // [[0, 2], [4, 3], [3, 4], [2, 6], [1, 7]]
 * console.log(result.maintained);
 */

function diff(prevList, list, findKeyCallback) {
  var mapClass = SUPPORT_MAP ? Map : findKeyCallback ? HashMap : PolyMap;

  var callback = findKeyCallback || function (e) {
    return e;
  };

  var added = [];
  var removed = [];
  var maintained = [];
  var prevKeys = prevList.map(callback);
  var keys = list.map(callback);
  var prevKeyMap = new mapClass();
  var keyMap = new mapClass();
  var changedBeforeAdded = [];
  var fixed = [];
  var removedMap = {};
  var changed = [];
  var addedCount = 0;
  var removedCount = 0; // Add prevKeys and keys to the hashmap.

  prevKeys.forEach(function (key, prevListIndex) {
    prevKeyMap.set(key, prevListIndex);
  });
  keys.forEach(function (key, listIndex) {
    keyMap.set(key, listIndex);
  }); // Compare `prevKeys` and `keys` and add them to `removed` if they are not in `keys`.

  prevKeys.forEach(function (key, prevListIndex) {
    var listIndex = keyMap.get(key); // In prevList, but not in list, it is removed.

    if (typeof listIndex === "undefined") {
      ++removedCount;
      removed.push(prevListIndex);
    } else {
      removedMap[listIndex] = removedCount;
    }
  }); // Compare `prevKeys` and `keys` and add them to `added` if they are not in `prevKeys`.

  keys.forEach(function (key, listIndex) {
    var prevListIndex = prevKeyMap.get(key); // In list, but not in prevList, it is added.

    if (typeof prevListIndex === "undefined") {
      added.push(listIndex);
      ++addedCount;
    } else {
      maintained.push([prevListIndex, listIndex]);
      removedCount = removedMap[listIndex] || 0;
      changedBeforeAdded.push([prevListIndex - removedCount, listIndex - addedCount]);
      fixed.push(listIndex === prevListIndex);

      if (prevListIndex !== listIndex) {
        changed.push([prevListIndex, listIndex]);
      }
    }
  }); // Sort by ascending order of 'to(list's index).

  removed.reverse();
  return new Result(prevList, list, added, removed, changed, maintained, changedBeforeAdded, fixed);
}

/**
 * A module that checks diff when values are added, removed, or changed in an array.
 * @ko 배열 또는 오브젝트에서 값이 추가되거나 삭제되거나 순서가 변경사항을 체크하는 모듈입니다.
 * @memberof eg
 */

var ListDiffer =
/*#__PURE__*/
function () {
  /**
   * @param - Initializing Data Array. <ko> 초기 설정할 데이터 배열.</ko>
   * @param - This callback function returns the key of the item. <ko> 아이템의 키를 반환하는 콜백 함수입니다.</ko>
   * @example
   * import ListDiffer from "@egjs/list-differ";
   * // script => eg.ListDiffer
   * const differ = new ListDiffer([0, 1, 2, 3, 4, 5], e => e);
   * const result = differ.update([7, 8, 0, 4, 3, 6, 2, 1]);
   * // List before update
   * // [1, 2, 3, 4, 5]
   * console.log(result.prevList);
   * // Updated list
   * // [4, 3, 6, 2, 1]
   * console.log(result.list);
   * // Index array of values added to `list`.
   * // [0, 1, 5]
   * console.log(result.added);
   * // Index array of values removed in `prevList`.
   * // [5]
   * console.log(result.removed);
   * // An array of index pairs of `prevList` and `list` with different indexes from `prevList` and `list`.
   * // [[0, 2], [4, 3], [3, 4], [2, 6], [1, 7]]
   * console.log(result.changed);
   * // The subset of `changed` and an array of index pairs that moved data directly. Indicate an array of absolute index pairs of `ordered`.(Formatted by: Array<[index of prevList, index of list]>)
   * // [[4, 3], [3, 4], [2, 6]]
   * console.log(result.pureChanged);
   * // An array of index pairs to be `ordered` that can synchronize `list` before adding data. (Formatted by: Array<[prevIndex, nextIndex]>)
   * // [[4, 1], [4, 2], [4, 3]]
   * console.log(result.ordered);
   * // An array of index pairs of `prevList` and `list` that have not been added/removed so data is preserved.
   * // [[0, 2], [4, 3], [3, 4], [2, 6], [1, 7]]
   * console.log(result.maintained);
   */
  function ListDiffer(list, findKeyCallback) {
    if (list === void 0) {
      list = [];
    }

    this.findKeyCallback = findKeyCallback;
    this.list = [].slice.call(list);
  }
  /**
   * Update list.
   * @ko 리스트를 업데이트를 합니다.
   * @param - List to update <ko> 업데이트할 리스트 </ko>
   * @return - Returns the results of an update from `prevList` to `list`.<ko> `prevList`에서 `list`로 업데이트한 결과를 반환한다. </ko>
   */


  var __proto = ListDiffer.prototype;

  __proto.update = function (list) {
    var newData = [].slice.call(list);
    var result = diff(this.list, newData, this.findKeyCallback);
    this.list = newData;
    return result;
  };

  return ListDiffer;
}();

/*
Copyright (c) 2015 NAVER Corp.
name: @egjs/agent
license: MIT
author: NAVER Corp.
repository: git+https://github.com/naver/agent.git
version: 2.4.3
*/
function some(arr, callback) {
  var length = arr.length;

  for (var i = 0; i < length; ++i) {
    if (callback(arr[i], i)) {
      return true;
    }
  }

  return false;
}
function find(arr, callback) {
  var length = arr.length;

  for (var i = 0; i < length; ++i) {
    if (callback(arr[i], i)) {
      return arr[i];
    }
  }

  return null;
}
function getUserAgentString(agent) {
  var userAgent = agent;

  if (typeof userAgent === "undefined") {
    if (typeof navigator === "undefined" || !navigator) {
      return "";
    }

    userAgent = navigator.userAgent || "";
  }

  return userAgent.toLowerCase();
}
function execRegExp(pattern, text) {
  try {
    return new RegExp(pattern, "g").exec(text);
  } catch (e) {
    return null;
  }
}
function hasUserAgentData() {
  if (typeof navigator === "undefined" || !navigator || !navigator.userAgentData) {
    return false;
  }

  var userAgentData = navigator.userAgentData;
  var brands = userAgentData.brands || userAgentData.uaList;
  return !!(brands && brands.length);
}
function findVersion(versionTest, userAgent) {
  var result = execRegExp("(" + versionTest + ")((?:\\/|\\s|:)([0-9|\\.|_]+))", userAgent);
  return result ? result[3] : "";
}
function convertVersion(text) {
  return text.replace(/_/g, ".");
}
function findPreset(presets, userAgent) {
  var userPreset = null;
  var version = "-1";
  some(presets, function (preset) {
    var result = execRegExp("(" + preset.test + ")((?:\\/|\\s|:)([0-9|\\.|_]+))?", userAgent);

    if (!result || preset.brand) {
      return false;
    }

    userPreset = preset;
    version = result[3] || "-1";

    if (preset.versionAlias) {
      version = preset.versionAlias;
    } else if (preset.versionTest) {
      version = findVersion(preset.versionTest.toLowerCase(), userAgent) || version;
    }

    version = convertVersion(version);
    return true;
  });
  return {
    preset: userPreset,
    version: version
  };
}
function findPresetBrand(presets, brands) {
  var brandInfo = {
    brand: "",
    version: "-1"
  };
  some(presets, function (preset) {
    var result = findBrand(brands, preset);

    if (!result) {
      return false;
    }

    brandInfo.brand = preset.id;
    brandInfo.version = preset.versionAlias || result.version;
    return brandInfo.version !== "-1";
  });
  return brandInfo;
}
function findBrand(brands, preset) {
  return find(brands, function (_a) {
    var brand = _a.brand;
    return execRegExp("" + preset.test, brand.toLowerCase());
  });
}

var BROWSER_PRESETS = [{
  test: "phantomjs",
  id: "phantomjs"
}, {
  test: "whale",
  id: "whale"
}, {
  test: "edgios|edge|edg",
  id: "edge"
}, {
  test: "msie|trident|windows phone",
  id: "ie",
  versionTest: "iemobile|msie|rv"
}, {
  test: "miuibrowser",
  id: "miui browser"
}, {
  test: "samsungbrowser",
  id: "samsung internet"
}, {
  test: "samsung",
  id: "samsung internet",
  versionTest: "version"
}, {
  test: "chrome|crios",
  id: "chrome"
}, {
  test: "firefox|fxios",
  id: "firefox"
}, {
  test: "android",
  id: "android browser",
  versionTest: "version"
}, {
  test: "safari|iphone|ipad|ipod",
  id: "safari",
  versionTest: "version"
}]; // chromium's engine(blink) is based on applewebkit 537.36.

var CHROMIUM_PRESETS = [{
  test: "(?=.*applewebkit/(53[0-7]|5[0-2]|[0-4]))(?=.*\\schrome)",
  id: "chrome",
  versionTest: "chrome"
}, {
  test: "chromium",
  id: "chrome"
}, {
  test: "whale",
  id: "chrome",
  versionAlias: "-1",
  brand: true
}];
var WEBKIT_PRESETS = [{
  test: "applewebkit",
  id: "webkit",
  versionTest: "applewebkit|safari"
}];
var WEBVIEW_PRESETS = [{
  test: "(?=(iphone|ipad))(?!(.*version))",
  id: "webview"
}, {
  test: "(?=(android|iphone|ipad))(?=.*(naver|daum|; wv))",
  id: "webview"
}, {
  // test webview
  test: "webview",
  id: "webview"
}];
var OS_PRESETS = [{
  test: "windows phone",
  id: "windows phone"
}, {
  test: "windows 2000",
  id: "window",
  versionAlias: "5.0"
}, {
  test: "windows nt",
  id: "window"
}, {
  test: "win32|windows",
  id: "window"
}, {
  test: "iphone|ipad|ipod",
  id: "ios",
  versionTest: "iphone os|cpu os"
}, {
  test: "macos|macintel|mac os x",
  id: "mac"
}, {
  test: "android|linux armv81",
  id: "android"
}, {
  test: "tizen",
  id: "tizen"
}, {
  test: "webos|web0s",
  id: "webos"
}];

function isWebView(userAgent) {
  return !!findPreset(WEBVIEW_PRESETS, userAgent).preset;
}
function getLegacyAgent(userAgent) {
  var nextAgent = getUserAgentString(userAgent);
  var isMobile = !!/mobi/g.exec(nextAgent);
  var browser = {
    name: "unknown",
    version: "-1",
    majorVersion: -1,
    webview: isWebView(nextAgent),
    chromium: false,
    chromiumVersion: "-1",
    webkit: false,
    webkitVersion: "-1"
  };
  var os = {
    name: "unknown",
    version: "-1",
    majorVersion: -1
  };

  var _a = findPreset(BROWSER_PRESETS, nextAgent),
      browserPreset = _a.preset,
      browserVersion = _a.version;

  var _b = findPreset(OS_PRESETS, nextAgent),
      osPreset = _b.preset,
      osVersion = _b.version;

  var chromiumPreset = findPreset(CHROMIUM_PRESETS, nextAgent);
  browser.chromium = !!chromiumPreset.preset;
  browser.chromiumVersion = chromiumPreset.version;

  if (!browser.chromium) {
    var webkitPreset = findPreset(WEBKIT_PRESETS, nextAgent);
    browser.webkit = !!webkitPreset.preset;
    browser.webkitVersion = webkitPreset.version;
  }

  if (osPreset) {
    os.name = osPreset.id;
    os.version = osVersion;
    os.majorVersion = parseInt(osVersion, 10);
  }

  if (browserPreset) {
    browser.name = browserPreset.id;
    browser.version = browserVersion; // Early whale bugs

    if (browser.webview && os.name === "ios" && browser.name !== "safari") {
      browser.webview = false;
    }
  }

  browser.majorVersion = parseInt(browser.version, 10);
  return {
    browser: browser,
    os: os,
    isMobile: isMobile,
    isHints: false
  };
}

function getClientHintsAgent(osData) {
  var userAgentData = navigator.userAgentData;
  var brands = (userAgentData.uaList || userAgentData.brands).slice();
  var fullVersionList = osData && osData.fullVersionList;
  var isMobile = userAgentData.mobile || false;
  var firstBrand = brands[0];
  var platform = (osData && osData.platform || userAgentData.platform || navigator.platform).toLowerCase();
  var browser = {
    name: firstBrand.brand,
    version: firstBrand.version,
    majorVersion: -1,
    webkit: false,
    webkitVersion: "-1",
    chromium: false,
    chromiumVersion: "-1",
    webview: !!findPresetBrand(WEBVIEW_PRESETS, brands).brand || isWebView(getUserAgentString())
  };
  var os = {
    name: "unknown",
    version: "-1",
    majorVersion: -1
  };
  browser.webkit = !browser.chromium && some(WEBKIT_PRESETS, function (preset) {
    return findBrand(brands, preset);
  });
  var chromiumBrand = findPresetBrand(CHROMIUM_PRESETS, brands);
  browser.chromium = !!chromiumBrand.brand;
  browser.chromiumVersion = chromiumBrand.version;

  if (!browser.chromium) {
    var webkitBrand = findPresetBrand(WEBKIT_PRESETS, brands);
    browser.webkit = !!webkitBrand.brand;
    browser.webkitVersion = webkitBrand.version;
  }

  var platfomResult = find(OS_PRESETS, function (preset) {
    return new RegExp("" + preset.test, "g").exec(platform);
  });
  os.name = platfomResult ? platfomResult.id : "";

  if (osData) {
    os.version = osData.platformVersion;
  }

  if (fullVersionList && fullVersionList.length) {
    var browserBrandByFullVersionList = findPresetBrand(BROWSER_PRESETS, fullVersionList);
    browser.name = browserBrandByFullVersionList.brand || browser.name;
    browser.version = browserBrandByFullVersionList.version || browser.version;
  } else {
    var browserBrand = findPresetBrand(BROWSER_PRESETS, brands);
    browser.name = browserBrand.brand || browser.name;
    browser.version = browserBrand.brand && osData ? osData.uaFullVersion : browserBrand.version;
  }

  if (browser.webkit) {
    os.name = isMobile ? "ios" : "mac";
  }

  if (os.name === "ios" && browser.webview) {
    browser.version = "-1";
  }

  os.version = convertVersion(os.version);
  browser.version = convertVersion(browser.version);
  os.majorVersion = parseInt(os.version, 10);
  browser.majorVersion = parseInt(browser.version, 10);
  return {
    browser: browser,
    os: os,
    isMobile: isMobile,
    isHints: true
  };
}
/**
 * Extracts browser and operating system information from the user agent string.
 * @ko 유저 에이전트 문자열에서 브라우저와 운영체제 정보를 추출한다.
 * @function eg.agent#agent
 * @param - user agent string to parse <ko>파싱할 유저에이전트 문자열</ko>
 * @return - agent Info <ko> 에이전트 정보 </ko>
 * @example
import agent from "@egjs/agent";
// eg.agent();
const { os, browser, isMobile } = agent();
 */

function agent(userAgent) {
  if (typeof userAgent === "undefined" && hasUserAgentData()) {
    return getClientHintsAgent();
  } else {
    return getLegacyAgent(userAgent);
  }
}

/*
Copyright (c) 2022-present NAVER Corp.
name: @cfcs/core
license: MIT
author: NAVER Crop.
repository: https://github.com/naver/cfcs/tree/main/packages/core
version: 0.1.0
*/

/**
 * cfcs
 * Copyright (c) 2022-present NAVER Corp.
 * MIT license
 */

/**
 * @hidden
 */
function keys(obj) {
  return Object.keys(obj);
}

/**
 * cfcs
 * Copyright (c) 2022-present NAVER Corp.
 * MIT license
 */
var OBSERVERS_PATH = "__observers__";
var COMPUTED_PATH = "__computed__";
var CFCS_DETECTED_DEPENDENCIES_VERSION = 1;
var CFCS_DETECTED_DEPENDENCIES = "__CFCS_DETECTED_DEPENDENCIES__";

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

/* global Reflect, Promise */
var extendStatics = function (d, b) {
  extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
  };

  return extendStatics(d, b);
};

function __extends(d, b) {
  if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);

  function __() {
    this.constructor = d;
  }

  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

/**
 * cfcs
 * Copyright (c) 2022-present NAVER Corp.
 * MIT license
 */
function getDetectedStack() {
  // Version issues do not occur when you access the native object in the global.
  Object[CFCS_DETECTED_DEPENDENCIES] = Object[CFCS_DETECTED_DEPENDENCIES] || {};
  var versionList = Object[CFCS_DETECTED_DEPENDENCIES];
  versionList[CFCS_DETECTED_DEPENDENCIES_VERSION] = versionList[CFCS_DETECTED_DEPENDENCIES_VERSION] || [];
  return versionList[CFCS_DETECTED_DEPENDENCIES_VERSION];
}
function getCurrentDetected() {
  var stack = getDetectedStack();
  return stack[stack.length - 1];
}
function detectDependencies(host) {
  var stack = getDetectedStack();
  var observers = [];
  var detected = {
    host: host,
    observers: observers,
    push: function (observer) {
      if (host !== observer && observers.indexOf(observer) === -1) {
        observers.push(observer);
      }
    }
  };
  stack.push(detected);
  return detected;
}
function endDetectDependencies() {
  var stack = getDetectedStack();
  return stack.pop();
}

/**
 * cfcs
 * Copyright (c) 2022-present NAVER Corp.
 * MIT license
 */
/**
 * Creates a mutable ref object. You can access the `.current` value and detect the value change through `.subscribe`.
 * @category Reactive
 * @see observe
 */

var Observer =
/*#__PURE__*/
function () {
  /**
   *
   */
  function Observer(value) {
    this._emitter = new Component();
    this._current = value;
  }

  var __proto = Observer.prototype;
  Object.defineProperty(__proto, "current", {
    /**
     * return the current value.
     */
    get: function () {
      var currentDetected = getCurrentDetected();
      currentDetected === null || currentDetected === void 0 ? void 0 : currentDetected.push(this);
      return this._current;
    },
    set: function (value) {
      this._setCurrent(value);
    },
    enumerable: false,
    configurable: true
  });
  /**
   * When the current value changes, the callback function is called.
   */

  __proto.subscribe = function (callback) {
    this.current;

    this._emitter.on("update", callback);

    return this;
  };
  /**
   * Cancel the registered subscription through callback.
   */


  __proto.unsubscribe = function (callback) {
    this._emitter.off("update", callback);

    return this;
  };

  __proto._setCurrent = function (value) {
    var prevValue = this._current;
    var isUpdate = value !== prevValue;
    this._current = value;

    if (isUpdate) {
      this._emitter.trigger("update", value, prevValue);
    }
  };
  /**
   * @hidden
   */


  __proto.toString = function () {
    return "".concat(this.current);
  };
  /**
   * @hidden
   */


  __proto.valueOf = function () {
    return this.current;
  };

  return Observer;
}();

/**
 * @category Reactive
 * @hidden
 */

var ComputedObserver =
/*#__PURE__*/
function (_super) {
  __extends(ComputedObserver, _super);
  /**
   * @description Creates a new computed observer from the values of other observers.
   * It is read-only and if you change the value of the observer used inside the callback, its value will be automatically updated.
   * @param _computedCallback A function for observers to be computed.
   */


  function ComputedObserver(_computedCallback) {
    var _this = _super.call(this) || this;

    _this._computedCallback = _computedCallback;
    _this._registered = [];

    _this._onCheckUpdate = function () {
      _this._setCurrent(_this.current);
    };

    _this._current = _this.current;
    return _this;
  }

  var __proto = ComputedObserver.prototype;
  Object.defineProperty(__proto, "current", {
    get: function () {
      var _this = this;

      detectDependencies(this);

      var value = this._computedCallback();

      var results = endDetectDependencies();

      this._registered.forEach(function (observer) {
        observer.unsubscribe(_this._onCheckUpdate);
      });

      results.observers.forEach(function (observer) {
        observer.subscribe(_this._onCheckUpdate);
      });
      this._registered = results.observers;
      return value;
    },
    enumerable: false,
    configurable: true
  });
  return ComputedObserver;
}(Observer);

/**
 * cfcs
 * Copyright (c) 2022-present NAVER Corp.
 * MIT license
 */

function injectObserve(prototype, memberName, publicName) {
  if (publicName === void 0) {
    publicName = memberName;
  }

  var nextAttributes = {
    configurable: true,
    get: function () {
      return getObserver(this, publicName).current;
    },
    set: function (value) {
      getObserver(this, publicName, value).current = value;
    }
  };
  Object.defineProperty(prototype, memberName, nextAttributes);

  if (publicName !== memberName) {
    Object.defineProperty(prototype, publicName, {
      configurable: true,
      get: function () {
        return getObserver(this, publicName).current;
      }
    });
  }
}
/**
 * @description `Observe` is a property decorator and converts the property into a `reactive state`. You can detect its status through `.subscribe`.
 * @category Reactive-Decorator
 * @see ReactiveSubscribe
 * @example
* ```ts
import { ReactiveSubscribe, Observe } from "@cfcs/core";

@ReactiveSubscribe
class Component {
  // The public name and state name are the same.
  @Observe value1 = 1;
  // If you want to set public name and private properties separately
  @Observe("value2") _value2 = 1;

  constructor() {
    requestAnimationFrame(() => {
      this.value1 = 2;
    });
  }
}
interface C
```
 */


function Observe() {
  var args = [];

  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }

  if (args.length > 1) {
    return injectObserve(args[0], args[1]);
  }

  return function (prototype, memberName) {
    return injectObserve(prototype, memberName, args[0]);
  };
}

/**
 * cfcs
 * Copyright (c) 2022-present NAVER Corp.
 * MIT license
 */
/**
 * @hidden
 */

function injectReactiveSubscribe(object) {
  object["subscribe"] = function (name, callback) {
    this[name];
    getObserver(this, name).subscribe(callback);
  };

  object["unsubscribe"] = function (name, callback) {
    var _this = this;

    if (!name) {
      keys(getObservers(this)).forEach(function (observerName) {
        _this.unsubscribe(observerName);
      });
      return;
    }

    if (!(name in this)) {
      return;
    }

    getObserver(this, name).unsubscribe(callback);
  };
}
/**
 * @description `ReactiveSubscribe` is a class decorator and adds `.subscribe` and `.unsubscribe` methods.
 * @category Reactive-Decorator
 * @see Observe
 * @example
 * ```ts
import { ReactiveSubscribe, Observe } from "@cfcs/core";

@ReactiveSubscribe
class Component {
  @Observe value1 = 1;

  constructor() {
    requestAnimationFrame(() => {
      this.value1 = 2;
    });
  }
}

interface Component extends ReactiveSubscribe<{
  value1: number;
  value2: number;
}> {}

const component = new Component();

// 1
console.log(component.value1);

component.subscribe("value1", nextValue => {
  // When the change event occurs => (2, 2)
  console.log(nextValue, component.value2);
});
```
 */

function ReactiveSubscribe(Constructor) {
  var prototype = Constructor.prototype;
  injectReactiveSubscribe(prototype);
}
/**
 * @description Creates a mutable ref object. You can access the `.current` value and detect the value change through `.subscribe`.
 * @category Reactive
 * @example
 * ```ts
 * import { observe } from "@cfcs/core";
 *
 * const ob1 = observe(1);
 *
 * ob1.subscribe(nextValue => {
 *   console.log(nextValue);
 * });
 *
 * ob1.current = 2;
 * ```
 */

function observe(defaultValue) {
  return new Observer(defaultValue);
}
/**
 * @hidden
 */

function computed(computedCallback) {
  return new ComputedObserver(computedCallback);
}
/**
 * @hidden
 */

function defineObservers(instance) {
  var observers = {};
  Object.defineProperty(instance, OBSERVERS_PATH, {
    get: function () {
      return observers;
    }
  });
  return observers;
}
/**
 * @hidden
 */

function getObservers(instance, isComputed) {
  var _a, _b;

  if (!instance[OBSERVERS_PATH]) {
    defineObservers(instance);
  }

  var observers = instance[OBSERVERS_PATH];

  if (!isComputed) {
    var computedList = (_b = (_a = instance === null || instance === void 0 ? void 0 : instance.constructor) === null || _a === void 0 ? void 0 : _a.prototype) === null || _b === void 0 ? void 0 : _b[COMPUTED_PATH];

    if (computedList) {
      computedList.forEach(function (name) {
        if (!(name in observers) && name in instance) {
          instance[name];
        }
      });
    }
  }

  return observers;
}
/**
 * @hidden
 */

function getObserver(instance, name, defaultValue) {
  var observers = getObservers(instance);

  if (!observers[name]) {
    observers[name] = observe(defaultValue);
  }

  return observers[name];
}

/**
 * cfcs
 * Copyright (c) 2022-present NAVER Corp.
 * MIT license
 */
/**
 * @description `Computed` is a property decorator.
 * Changes in computed state values are also recognized according to changes in observers used within the getter function.
 * You can detect its status through `.subscribe`.
 * @hidden
 * @category Reactive-Decorator
 * @see ReactiveSubscribe
 * @example
 * ```ts
const ob1 = observe(0);
const ob2 = observe(1);

// When
@ReactiveSubscribe
class TestComputed {
  @Computed
  get ob3() {
    return ob1.current + ob2.current;
  }
}
const inst = new TestComputed();

inst.subscribe("ob3", ob3 => {
  console.log(ob3);
});

ob1.current = 1;
```
 */

function Computed(prototype, memberName, attributes) {
  var get = attributes.get;

  function getComputed() {
    var observers = getObservers(this, true);

    if (!(memberName in observers)) {
      observers[memberName] = computed(get.bind(this));
    }

    return getObserver(this, memberName).current;
  }

  var nextAttributes = {
    configurable: true,
    get: getComputed
  };
  prototype[COMPUTED_PATH] || (prototype[COMPUTED_PATH] = []);
  var computedList = prototype[COMPUTED_PATH];

  if (computedList.indexOf(memberName) === -1) {
    computedList.push(memberName);
  }

  Object.defineProperty(prototype, memberName, nextAttributes);
  return nextAttributes;
}

/*
Copyright (c) NAVER Corp.
name: @egjs/axes
license: MIT
author: NAVER Corp.
repository: https://github.com/naver/egjs-axes
version: 3.9.1
*/

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics$1 = function (d, b) {
  extendStatics$1 = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
  };
  return extendStatics$1(d, b);
};
function __extends$1(d, b) {
  extendStatics$1(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function () {
  __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __decorate(decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}

/*
 * Copyright (c) 2015 NAVER Corp.
 * egjs projects are licensed under the MIT license
 */
/* eslint-disable no-new-func, no-nested-ternary */
var win;
if (typeof window === "undefined") {
  // window is undefined in node.js
  win = {
    navigator: {
      userAgent: ""
    }
  };
} else {
  win = window;
}

/*
 * Copyright (c) 2015 NAVER Corp.
 * egjs projects are licensed under the MIT license
 */
var DIRECTION_NONE = 1;
var DIRECTION_LEFT = 2;
var DIRECTION_RIGHT = 4;
var DIRECTION_HORIZONTAL = 2 | 4;
var DIRECTION_UP = 8;
var DIRECTION_DOWN = 16;
var DIRECTION_VERTICAL = 8 | 16;
var DIRECTION_ALL = 2 | 4 | 8 | 16;
var MOUSE_LEFT = "left";
var MOUSE_RIGHT = "right";
var MOUSE_MIDDLE = "middle";
var MOUSE_BUTTON_CODE_MAP = {
  1: MOUSE_LEFT,
  2: MOUSE_MIDDLE,
  3: MOUSE_RIGHT
};
var ANY = "any";
var NONE = "none";
var SHIFT = "shift";
var CTRL = "ctrl";
var ALT = "alt";
var META = "meta";
var VELOCITY_INTERVAL = 16;
var IOS_EDGE_THRESHOLD = 30;
var IS_IOS_SAFARI = "ontouchstart" in win && agent().browser.name === "safari";
var TRANSFORM = function () {
  if (typeof document === "undefined") {
    return "";
  }
  var bodyStyle = (document.head || document.getElementsByTagName("head")[0]).style;
  var target = ["transform", "webkitTransform", "msTransform", "mozTransform"];
  for (var i = 0, len = target.length; i < len; i++) {
    if (target[i] in bodyStyle) {
      return target[i];
    }
  }
  return "";
}();
var PREVENT_DRAG_CSSPROPS = {
  "-webkit-user-select": "none",
  "-ms-user-select": "none",
  "-moz-user-select": "none",
  "user-select": "none",
  "-webkit-user-drag": "none"
};

var toArray = function (nodes) {
  // const el = Array.prototype.slice.call(nodes);
  // for IE8
  var el = [];
  for (var i = 0, len = nodes.length; i < len; i++) {
    el.push(nodes[i]);
  }
  return el;
};
var $$1 = function (param, multi) {
  if (multi === void 0) {
    multi = false;
  }
  var el;
  if (typeof param === "string") {
    // String (HTML, Selector)
    // check if string is HTML tag format
    var match = param.match(/^<([a-z]+)\s*([^>]*)>/);
    // creating element
    if (match) {
      // HTML
      var dummy = document.createElement("div");
      dummy.innerHTML = param;
      el = toArray(dummy.childNodes);
    } else {
      // Selector
      el = toArray(document.querySelectorAll(param));
    }
    if (!multi) {
      el = el.length >= 1 ? el[0] : undefined;
    }
  } else if (param === win) {
    // window
    el = param;
  } else if ("value" in param || "current" in param) {
    el = param.value || param.current;
  } else if (param.nodeName && (param.nodeType === 1 || param.nodeType === 9)) {
    // HTMLElement, Document
    el = param;
  } else if ("jQuery" in win && param instanceof jQuery || param.constructor.prototype.jquery) {
    // jQuery
    el = multi ? param.toArray() : param.get(0);
  } else if (Array.isArray(param)) {
    el = param.map(function (v) {
      return $$1(v);
    });
    if (!multi) {
      el = el.length >= 1 ? el[0] : undefined;
    }
  }
  return el;
};
var raf = win.requestAnimationFrame || win.webkitRequestAnimationFrame;
var caf = win.cancelAnimationFrame || win.webkitCancelAnimationFrame;
if (raf && !caf) {
  var keyInfo_1 = {};
  var oldraf_1 = raf;
  raf = function (callback) {
    var wrapCallback = function (timestamp) {
      if (keyInfo_1[key]) {
        callback(timestamp);
      }
    };
    var key = oldraf_1(wrapCallback);
    keyInfo_1[key] = true;
    return key;
  };
  caf = function (key) {
    delete keyInfo_1[key];
  };
} else if (!(raf && caf)) {
  raf = function (callback) {
    return win.setTimeout(function () {
      callback(win.performance && win.performance.now && win.performance.now() || new Date().getTime());
    }, 16);
  };
  caf = win.clearTimeout;
}
/**
 * A polyfill for the window.requestAnimationFrame() method.
 * @see  https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame
 * @private
 */
var requestAnimationFrame$1 = function (fp) {
  return raf(fp);
};
/**
 * A polyfill for the window.cancelAnimationFrame() method. It cancels an animation executed through a call to the requestAnimationFrame() method.
 * @param {Number} key −  The ID value returned through a call to the requestAnimationFrame() method. <ko>requestAnimationFrame() 메서드가 반환한 아이디 값</ko>
 * @see  https://developer.mozilla.org/en-US/docs/Web/API/Window/cancelAnimationFrame
 * @private
 */
var cancelAnimationFrame$1 = function (key) {
  caf(key);
};
var map = function (obj, callback) {
  var tranformed = {};
  for (var k in obj) {
    if (k) {
      tranformed[k] = callback(obj[k], k);
    }
  }
  return tranformed;
};
var filter = function (obj, callback) {
  var filtered = {};
  for (var k in obj) {
    if (k && callback(obj[k], k)) {
      filtered[k] = obj[k];
    }
  }
  return filtered;
};
var every = function (obj, callback) {
  for (var k in obj) {
    if (k && !callback(obj[k], k)) {
      return false;
    }
  }
  return true;
};
var equal = function (target, base) {
  return every(target, function (v, k) {
    return v === base[k];
  });
};
var roundNumFunc = {};
var roundNumber = function (num, roundUnit) {
  // Cache for performance
  if (!roundNumFunc[roundUnit]) {
    roundNumFunc[roundUnit] = getRoundFunc(roundUnit);
  }
  return roundNumFunc[roundUnit](num);
};
var roundNumbers = function (num, roundUnit) {
  if (!num || !roundUnit) {
    return num;
  }
  return map(num, function (value, key) {
    return roundNumber(value, typeof roundUnit === "number" ? roundUnit : roundUnit[key]);
  });
};
var getDecimalPlace = function (val) {
  if (!isFinite(val)) {
    return 0;
  }
  var v = "".concat(val);
  if (v.indexOf("e") >= 0) {
    // Exponential Format
    // 1e-10, 1e-12
    var p = 0;
    var e = 1;
    while (Math.round(val * e) / e !== val) {
      e *= 10;
      p++;
    }
    return p;
  }
  // In general, following has performance benefit.
  // https://jsperf.com/precision-calculation
  return v.indexOf(".") >= 0 ? v.length - v.indexOf(".") - 1 : 0;
};
var inversePow = function (n) {
  // replace Math.pow(10, -n) to solve floating point issue.
  // eg. Math.pow(10, -4) => 0.00009999999999999999
  return 1 / Math.pow(10, n);
};
var getRoundFunc = function (v) {
  var p = v < 1 ? Math.pow(10, getDecimalPlace(v)) : 1;
  return function (n) {
    if (v === 0) {
      return 0;
    }
    return Math.round(Math.round(n / v) * v * p) / p;
  };
};
var getAngle = function (posX, posY) {
  return Math.atan2(posY, posX) * 180 / Math.PI;
};
var isCssPropsFromAxes = function (originalCssProps) {
  var same = true;
  Object.keys(PREVENT_DRAG_CSSPROPS).forEach(function (prop) {
    if (!originalCssProps || originalCssProps[prop] !== PREVENT_DRAG_CSSPROPS[prop]) {
      same = false;
    }
  });
  return same;
};
var getDirection = function (useHorizontal, useVertical) {
  if (useHorizontal && useVertical) {
    return DIRECTION_ALL;
  } else if (useHorizontal) {
    return DIRECTION_HORIZONTAL;
  } else if (useVertical) {
    return DIRECTION_VERTICAL;
  } else {
    return DIRECTION_NONE;
  }
};
var useDirection = function (checkType, direction, userDirection) {
  if (userDirection) {
    return !!(direction === DIRECTION_ALL || direction & checkType && userDirection & checkType);
  } else {
    return !!(direction & checkType);
  }
};
var setCssProps = function (element, option, direction) {
  var _a;
  var touchActionMap = (_a = {}, _a[DIRECTION_NONE] = "auto", _a[DIRECTION_ALL] = "none", _a[DIRECTION_VERTICAL] = "pan-x", _a[DIRECTION_HORIZONTAL] = "pan-y", _a);
  var oldCssProps = {};
  if (element && element.style) {
    var touchAction = option.touchAction ? option.touchAction : touchActionMap[direction];
    var newCssProps_1 = __assign(__assign({}, PREVENT_DRAG_CSSPROPS), {
      "touch-action": element.style["touch-action"] === "none" ? "none" : touchAction
    });
    Object.keys(newCssProps_1).forEach(function (prop) {
      oldCssProps[prop] = element.style[prop];
    });
    // Old style props like user-select can be corrupted if you change the style directly in the logic above.
    Object.keys(newCssProps_1).forEach(function (prop) {
      element.style[prop] = newCssProps_1[prop];
    });
  }
  return oldCssProps;
};
var revertCssProps = function (element, originalCssProps) {
  if (element && element.style && originalCssProps) {
    Object.keys(originalCssProps).forEach(function (prop) {
      element.style[prop] = originalCssProps[prop];
    });
  }
  return;
};

var EventManager = /*#__PURE__*/function () {
  function EventManager(_axes) {
    this._axes = _axes;
    this.holdingCount = 0;
  }
  /**
   * This event is fired when a user holds an element on the screen of the device.
   * @ko 사용자가 기기의 화면에 손을 대고 있을 때 발생하는 이벤트
   * @event Axes#hold
   * @type {object}
   * @property {Object.<string, number>} pos coordinate <ko>좌표 정보</ko>
   * @property {Object} input The instance of inputType where the event occurred<ko>이벤트가 발생한 inputType 인스턴스</ko>
   * @property {Object} inputEvent The event object received from inputType <ko>inputType으로 부터 받은 이벤트 객체</ko>
   * @property {Boolean} isTrusted Returns true if an event was generated by the user action, or false if it was caused by a script or API call <ko>사용자의 액션에 의해 이벤트가 발생하였으면 true, 스크립트나 API호출에 의해 발생하였을 경우에는 false를 반환한다.</ko>
   *
   * @example
   * ```js
   * const axes = new eg.Axes({
   *   "x": {
   *      range: [0, 100]
   *   },
   *   "zoom": {
   *      range: [50, 30]
   *   }
   * }).on("hold", function(event) {
   *   // event.pos
   *   // event.input
   *   // event.inputEvent
   *   // isTrusted
   * });
   * ```
   */
  var __proto = EventManager.prototype;
  __proto.hold = function (pos, option) {
    var roundPos = this._getRoundPos(pos).roundPos;
    this._axes.trigger(new ComponentEvent$1("hold", {
      pos: roundPos,
      input: option.input || null,
      inputEvent: option.event || null,
      isTrusted: true
    }));
  };
  /**
   * Specifies the coordinates to move after the 'change' event. It works when the holding value of the change event is true.
   * @ko 'change' 이벤트 이후 이동할 좌표를 지정한다. change이벤트의 holding 값이 true일 경우에 동작한다
   * @param {Object.<string, number>} pos The coordinate to move to <ko>이동할 좌표</ko>
   * @example
   * ```js
   * const axes = new eg.Axes({
   *   "x": {
   *      range: [0, 100]
   *   },
   *   "zoom": {
   *      range: [50, 30]
   *   }
   * }).on("change", function(event) {
   *   event.holding && event.set({x: 10});
   * });
   * ```
   */
  /** Specifies the animation coordinates to move after the 'release' or 'animationStart' events.
   * @ko 'release' 또는 'animationStart' 이벤트 이후 이동할 좌표를 지정한다.
   * @param {Object.<string, number>} pos The coordinate to move to <ko>이동할 좌표</ko>
   * @param {Number} [duration=0] Duration of the animation (unit: ms) <ko>애니메이션 진행 시간(단위: ms)</ko>
   * @example
   * ```js
   * const axes = new eg.Axes({
   *   "x": {
   *      range: [0, 100]
   *   },
   *   "zoom": {
   *      range: [50, 30]
   *   }
   * }).on("animationStart", function(event) {
   *   event.setTo({x: 10}, 2000);
   * });
   * ```
   */
  /**
   * This event is fired when a user release an element on the screen of the device.
   * @ko 사용자가 기기의 화면에서 손을 뗐을 때 발생하는 이벤트
   * @event Axes#release
   * @type {object}
   * @property {Object.<string, number>} depaPos The coordinates when releasing an element<ko>손을 뗐을 때의 좌표 </ko>
   * @property {Object.<string, number>} destPos The coordinates to move to after releasing an element<ko>손을 뗀 뒤에 이동할 좌표</ko>
   * @property {Object.<string, number>} delta  The movement variation of coordinate <ko>좌표의 변화량</ko>
   * @property {Object.<string, number>} bounceRatio If the coordinates at the time of release are in the bounce area, the current bounce value divided by the maximum bounce value <ko>손을 뗐을 때의 좌표가 bounce 영역에 있는 경우 현재 bounce된 값을 최대 bounce 값으로 나눈 수치.</ko>
   * @property {Object} inputEvent The event object received from inputType <ko>inputType으로 부터 받은 이벤트 객체</ko>
   * @property {Object} input The instance of inputType where the event occurred<ko>이벤트가 발생한 inputType 인스턴스</ko>
   * @property {setTo} setTo Specifies the animation coordinates to move after the event <ko>이벤트 이후 이동할 애니메이션 좌표를 지정한다</ko>
   * @property {Boolean} isTrusted Returns true if an event was generated by the user action, or false if it was caused by a script or API call <ko>사용자의 액션에 의해 이벤트가 발생하였으면 true, 스크립트나 API호출에 의해 발생하였을 경우에는 false를 반환한다.</ko>
   *
   * @example
   * ```js
   * const axes = new eg.Axes({
   *   "x": {
   *      range: [0, 100]
   *   },
   *   "zoom": {
   *      range: [50, 30]
   *   }
   * }).on("release", function(event) {
   *   // event.depaPos
   *   // event.destPos
   *   // event.delta
   *   // event.input
   *   // event.inputEvent
   *   // event.setTo
   *   // event.isTrusted
   *
   *   // if you want to change the animation coordinates to move after the 'release' event.
   *   event.setTo({x: 10}, 2000);
   * });
   * ```
   */
  __proto.triggerRelease = function (param) {
    var _a = this._getRoundPos(param.destPos, param.depaPos),
      roundPos = _a.roundPos,
      roundDepa = _a.roundDepa;
    param.destPos = roundPos;
    param.depaPos = roundDepa;
    param.setTo = this._createUserControll(param.destPos, param.duration);
    this._axes.trigger(new ComponentEvent$1("release", __assign(__assign({}, param), {
      bounceRatio: this._getBounceRatio(roundPos)
    })));
  };
  /**
   * This event is fired when coordinate changes.
   * @ko 좌표가 변경됐을 때 발생하는 이벤트
   * @event Axes#change
   * @type {object}
   * @property {Object.<string, number>} pos  The coordinate <ko>좌표</ko>
   * @property {Object.<string, number>} delta  The movement variation of coordinate <ko>좌표의 변화량</ko>
   * @property {Object.<string, number>} bounceRatio If the current coordinates are in the bounce area, the current bounce value divided by the maximum bounce value <ko>현재 좌표가 bounce 영역에 있는 경우 현재 bounce된 값을 최대 bounce 값으로 나눈 수치.</ko>
   * @property {Boolean} holding Indicates whether a user holds an element on the screen of the device.<ko>사용자가 기기의 화면을 누르고 있는지 여부</ko>
   * @property {Object} input The instance of inputType where the event occurred. If the value is changed by animation, it returns 'null'.<ko>이벤트가 발생한 inputType 인스턴스. 애니메이션에 의해 값이 변경될 경우에는 'null'을 반환한다.</ko>
   * @property {Object} inputEvent The event object received from inputType. If the value is changed by animation, it returns 'null'.<ko>inputType으로 부터 받은 이벤트 객체. 애니메이션에 의해 값이 변경될 경우에는 'null'을 반환한다.</ko>
   * @property {set} set Specifies the coordinates to move after the event. It works when the holding value is true <ko>이벤트 이후 이동할 좌표를 지정한다. holding 값이 true일 경우에 동작한다.</ko>
   * @property {Boolean} isTrusted Returns true if an event was generated by the user action, or false if it was caused by a script or API call <ko>사용자의 액션에 의해 이벤트가 발생하였으면 true, 스크립트나 API호출에 의해 발생하였을 경우에는 false를 반환한다.</ko>
   *
   * @example
   * ```js
   * const axes = new eg.Axes({
   *   "x": {
   *      range: [0, 100]
   *   },
   *   "zoom": {
   *      range: [50, 30]
   *   }
   * }).on("change", function(event) {
   *   // event.pos
   *   // event.delta
   *   // event.input
   *   // event.inputEvent
   *   // event.holding
   *   // event.set
   *   // event.isTrusted
   *
   *   // if you want to change the coordinates to move after the 'change' event.
   *   // it works when the holding value of the change event is true.
   *   event.holding && event.set({x: 10});
   * });
   * ```
   */
  __proto.triggerChange = function (pos, depaPos, option, holding) {
    var _this = this;
    if (holding === void 0) {
      holding = false;
    }
    var animationManager = this.animationManager;
    var axisManager = animationManager.axisManager;
    var eventInfo = animationManager.getEventInfo();
    var _a = this._getRoundPos(pos, depaPos),
      roundPos = _a.roundPos,
      roundDepa = _a.roundDepa;
    var moveTo = axisManager.moveTo(roundPos, roundDepa);
    var inputEvent = (option === null || option === void 0 ? void 0 : option.event) || (eventInfo === null || eventInfo === void 0 ? void 0 : eventInfo.event) || null;
    var param = {
      pos: moveTo.pos,
      delta: moveTo.delta,
      bounceRatio: this._getBounceRatio(moveTo.pos),
      holding: holding,
      inputEvent: inputEvent,
      isTrusted: !!inputEvent,
      input: (option === null || option === void 0 ? void 0 : option.input) || (eventInfo === null || eventInfo === void 0 ? void 0 : eventInfo.input) || null,
      set: inputEvent ? this._createUserControll(moveTo.pos) : function () {} // eslint-disable-line @typescript-eslint/no-empty-function
    };

    var event = new ComponentEvent$1("change", param);
    this._axes.trigger(event);
    Object.keys(moveTo.pos).forEach(function (axis) {
      var p = moveTo.pos[axis];
      getObserver(_this._axes, axis, p).current = p;
    });
    if (inputEvent) {
      axisManager.set(param.set().destPos);
    }
    return !event.isCanceled();
  };
  /**
   * This event is fired when animation starts.
   * @ko 에니메이션이 시작할 때 발생한다.
   * @event Axes#animationStart
   * @type {object}
   * @property {Object.<string, number>} depaPos The coordinates when animation starts<ko>애니메이션이 시작 되었을 때의 좌표 </ko>
   * @property {Object.<string, number>} destPos The coordinates to move to. If you change this value, you can run the animation<ko>이동할 좌표. 이값을 변경하여 애니메이션을 동작시킬수 있다</ko>
   * @property {Object.<string, number>} delta  The movement variation of coordinate <ko>좌표의 변화량</ko>
   * @property {Number} duration Duration of the animation (unit: ms). If you change this value, you can control the animation duration time.<ko>애니메이션 진행 시간(단위: ms). 이값을 변경하여 애니메이션의 이동시간을 조절할 수 있다.</ko>
   * @property {Object} input The instance of inputType where the event occurred. If the value is changed by animation, it returns 'null'.<ko>이벤트가 발생한 inputType 인스턴스. 애니메이션에 의해 값이 변경될 경우에는 'null'을 반환한다.</ko>
   * @property {Object} inputEvent The event object received from inputType <ko>inputType으로 부터 받은 이벤트 객체</ko>
   * @property {setTo} setTo Specifies the animation coordinates to move after the event <ko>이벤트 이후 이동할 애니메이션 좌표를 지정한다</ko>
   * @property {Boolean} isTrusted Returns true if an event was generated by the user action, or false if it was caused by a script or API call <ko>사용자의 액션에 의해 이벤트가 발생하였으면 true, 스크립트나 API호출에 의해 발생하였을 경우에는 false를 반환한다.</ko>
   *
   * @example
   * ```js
   * const axes = new eg.Axes({
   *   "x": {
   *      range: [0, 100]
   *   },
   *   "zoom": {
   *      range: [50, 30]
   *   }
   * }).on("release", function(event) {
   *   // event.depaPos
   *   // event.destPos
   *   // event.delta
   *   // event.input
   *   // event.inputEvent
   *   // event.setTo
   *   // event.isTrusted
   *
   *   // if you want to change the animation coordinates to move after the 'animationStart' event.
   *   event.setTo({x: 10}, 2000);
   * });
   * ```
   */
  __proto.triggerAnimationStart = function (param) {
    var _a = this._getRoundPos(param.destPos, param.depaPos),
      roundPos = _a.roundPos,
      roundDepa = _a.roundDepa;
    param.destPos = roundPos;
    param.depaPos = roundDepa;
    param.setTo = this._createUserControll(param.destPos, param.duration);
    var event = new ComponentEvent$1("animationStart", param);
    this._axes.trigger(event);
    return !event.isCanceled();
  };
  /**
   * This event is fired when animation ends.
   * @ko 에니메이션이 끝났을 때 발생한다.
   * @event Axes#animationEnd
   * @type {object}
   * @property {Boolean} isTrusted Returns true if an event was generated by the user action, or false if it was caused by a script or API call <ko>사용자의 액션에 의해 이벤트가 발생하였으면 true, 스크립트나 API호출에 의해 발생하였을 경우에는 false를 반환한다.</ko>
   *
   * @example
   * ```js
   * const axes = new eg.Axes({
   *   "x": {
   *      range: [0, 100]
   *   },
   *   "zoom": {
   *      range: [50, 30]
   *   }
   * }).on("animationEnd", function(event) {
   *   // event.isTrusted
   * });
   * ```
   */
  __proto.triggerAnimationEnd = function (isTrusted) {
    if (isTrusted === void 0) {
      isTrusted = false;
    }
    this._axes.trigger(new ComponentEvent$1("animationEnd", {
      isTrusted: isTrusted
    }));
  };
  /**
   * This event is fired when all actions have been completed.
   * @ko 에니메이션이 끝났을 때 발생한다.
   * @event Axes#finish
   * @type {object}
   * @property {Boolean} isTrusted Returns true if an event was generated by the user action, or false if it was caused by a script or API call <ko>사용자의 액션에 의해 이벤트가 발생하였으면 true, 스크립트나 API호출에 의해 발생하였을 경우에는 false를 반환한다.</ko>
   *
   * @example
   * ```js
   * const axes = new eg.Axes({
   *   "x": {
   *      range: [0, 100]
   *   },
   *   "zoom": {
   *      range: [50, 30]
   *   }
   * }).on("finish", function(event) {
   *   // event.isTrusted
   * });
   * ```
   */
  __proto.triggerFinish = function (isTrusted) {
    if (isTrusted === void 0) {
      isTrusted = false;
    }
    this._axes.trigger(new ComponentEvent$1("finish", {
      isTrusted: isTrusted
    }));
  };
  __proto.setAnimationManager = function (animationManager) {
    this.animationManager = animationManager;
  };
  __proto.destroy = function () {
    this._axes.off();
  };
  __proto._createUserControll = function (pos, duration) {
    if (duration === void 0) {
      duration = 0;
    }
    // to controll
    var userControl = {
      destPos: __assign({}, pos),
      duration: duration
    };
    return function (toPos, userDuration) {
      if (toPos) {
        userControl.destPos = __assign({}, toPos);
      }
      if (userDuration !== undefined) {
        userControl.duration = userDuration;
      }
      return userControl;
    };
  };
  __proto._getRoundPos = function (pos, depaPos) {
    // round value if round exist
    var roundUnit = this._axes.options.round;
    // if (round == null) {
    //   return {pos, depaPos}; // undefined, undefined
    // }
    return {
      roundPos: roundNumbers(pos, roundUnit),
      roundDepa: roundNumbers(depaPos, roundUnit)
    };
  };
  __proto._getBounceRatio = function (pos) {
    return this._axes.axisManager.map(pos, function (v, opt) {
      if (v < opt.range[0] && opt.bounce[0] !== 0) {
        return (opt.range[0] - v) / opt.bounce[0];
      } else if (v > opt.range[1] && opt.bounce[1] !== 0) {
        return (v - opt.range[1]) / opt.bounce[1];
      } else {
        return 0;
      }
    });
  };
  __decorate([Observe], EventManager.prototype, "holdingCount", void 0);
  return EventManager;
}();

var InterruptManager = /*#__PURE__*/function () {
  function InterruptManager(_options) {
    this._options = _options;
    this._prevented = false; //  check whether the animation event was prevented
  }
  var __proto = InterruptManager.prototype;
  __proto.isInterrupting = function () {
    // when interruptable is 'true', return value is always 'true'.
    return this._options.interruptable || this._prevented;
  };
  __proto.isInterrupted = function () {
    return !this._options.interruptable && this._prevented;
  };
  __proto.setInterrupt = function (prevented) {
    if (!this._options.interruptable) {
      this._prevented = prevented;
    }
  };
  return InterruptManager;
}();

/*
 * Copyright (c) 2015 NAVER Corp.
 * egjs projects are licensed under the MIT license
 */
var getInsidePosition = function (destPos, range, circular, bounce) {
  var toDestPos = destPos;
  var targetRange = [circular[0] ? range[0] : bounce ? range[0] - bounce[0] : range[0], circular[1] ? range[1] : bounce ? range[1] + bounce[1] : range[1]];
  toDestPos = Math.max(targetRange[0], toDestPos);
  toDestPos = Math.min(targetRange[1], toDestPos);
  return toDestPos;
};
// determine outside
var isOutside = function (pos, range) {
  return pos < range[0] || pos > range[1];
};
// determine whether position has reached the maximum moveable area
var isEndofBounce = function (pos, range, bounce, circular) {
  return !circular[0] && pos === range[0] - bounce[0] || !circular[1] && pos === range[1] + bounce[1];
};
var getDuration = function (distance, deceleration) {
  var duration = Math.sqrt(distance / deceleration * 2);
  // when duration is under 100, then value is zero
  return duration < 100 ? 0 : duration;
};
var isCircularable = function (destPos, range, circular) {
  return circular[1] && destPos > range[1] || circular[0] && destPos < range[0];
};
var getCirculatedPos = function (pos, range, circular) {
  var toPos = pos;
  var min = range[0];
  var max = range[1];
  var length = max - min;
  if (circular[1] && pos > max) {
    // right
    toPos = (toPos - max) % length + min;
  }
  if (circular[0] && pos < min) {
    // left
    toPos = (toPos - min) % length + max;
  }
  return toPos;
};

var AxisManager = /*#__PURE__*/function () {
  function AxisManager(_axis) {
    var _this = this;
    this._axis = _axis;
    this._complementOptions();
    this._pos = Object.keys(this._axis).reduce(function (pos, v) {
      pos[v] = _this._axis[v].startPos;
      return pos;
    }, {});
  }
  var __proto = AxisManager.prototype;
  __proto.getDelta = function (depaPos, destPos) {
    var fullDepaPos = this.get(depaPos);
    return map(this.get(destPos), function (v, k) {
      return v - fullDepaPos[k];
    });
  };
  __proto.get = function (axes) {
    var _this = this;
    if (axes && Array.isArray(axes)) {
      return axes.reduce(function (acc, v) {
        if (v && v in _this._pos) {
          acc[v] = _this._pos[v];
        }
        return acc;
      }, {});
    } else {
      return __assign(__assign({}, this._pos), axes || {});
    }
  };
  __proto.moveTo = function (pos, depaPos) {
    if (depaPos === void 0) {
      depaPos = this._pos;
    }
    var delta = map(this._pos, function (v, key) {
      return key in pos && key in depaPos ? pos[key] - depaPos[key] : 0;
    });
    this.set(this.map(pos, function (v, opt) {
      return opt ? getCirculatedPos(v, opt.range, opt.circular) : 0;
    }));
    return {
      pos: __assign({}, this._pos),
      delta: delta
    };
  };
  __proto.set = function (pos) {
    for (var k in pos) {
      if (k && k in this._pos) {
        this._pos[k] = pos[k];
      }
    }
  };
  __proto.every = function (pos, callback) {
    var axisOptions = this._axis;
    return every(pos, function (value, key) {
      return callback(value, axisOptions[key], key);
    });
  };
  __proto.filter = function (pos, callback) {
    var axisOptions = this._axis;
    return filter(pos, function (value, key) {
      return callback(value, axisOptions[key], key);
    });
  };
  __proto.map = function (pos, callback) {
    var axisOptions = this._axis;
    return map(pos, function (value, key) {
      return callback(value, axisOptions[key], key);
    });
  };
  __proto.isOutside = function (axes) {
    return !this.every(axes ? this.get(axes) : this._pos, function (v, opt) {
      return !isOutside(v, opt.range);
    });
  };
  __proto.getAxisOptions = function (key) {
    return this._axis[key];
  };
  __proto.setAxis = function (axis) {
    var _this = this;
    Object.keys(axis).forEach(function (key) {
      if (!_this._axis[key]) {
        throw new Error("Axis ".concat(key, " does not exist in Axes instance"));
      }
      _this._axis[key] = __assign(__assign({}, _this._axis[key]), axis[key]);
    });
    this._complementOptions();
  };
  /**
   * set up 'css' expression
   * @private
   */
  __proto._complementOptions = function () {
    var _this = this;
    Object.keys(this._axis).forEach(function (axis) {
      _this._axis[axis] = __assign({
        range: [0, 100],
        startPos: _this._axis[axis].range[0],
        bounce: [0, 0],
        circular: [false, false]
      }, _this._axis[axis]);
      ["bounce", "circular"].forEach(function (v) {
        var axisOption = _this._axis;
        var key = axisOption[axis][v];
        if (/string|number|boolean/.test(typeof key)) {
          axisOption[axis][v] = [key, key];
        }
      });
    });
  };
  return AxisManager;
}();

var SUPPORT_TOUCH = ("ontouchstart" in win);
var SUPPORT_POINTER = ("PointerEvent" in win);
var SUPPORT_MSPOINTER = ("MSPointerEvent" in win);
var SUPPORT_POINTER_EVENTS = SUPPORT_POINTER || SUPPORT_MSPOINTER;
var isValidKey = function (event, inputKey) {
  if (!inputKey || inputKey.indexOf(ANY) > -1 || inputKey.indexOf(NONE) > -1 && !event.shiftKey && !event.ctrlKey && !event.altKey && !event.metaKey || inputKey.indexOf(SHIFT) > -1 && event.shiftKey || inputKey.indexOf(CTRL) > -1 && event.ctrlKey || inputKey.indexOf(ALT) > -1 && event.altKey || inputKey.indexOf(META) > -1 && event.metaKey) {
    return true;
  }
  return false;
};
var EventInput = /*#__PURE__*/function () {
  function EventInput() {
    var _this = this;
    this._stopContextMenu = function (event) {
      event.preventDefault();
      win.removeEventListener("contextmenu", _this._stopContextMenu);
    };
  }
  var __proto = EventInput.prototype;
  __proto.extendEvent = function (event) {
    var _a;
    var prevEvent = this.prevEvent;
    var center = this._getCenter(event);
    var movement = prevEvent ? this._getMovement(event) : {
      x: 0,
      y: 0
    };
    var scale = prevEvent ? this._getScale(event) : 1;
    var angle = prevEvent ? getAngle(center.x - prevEvent.center.x, center.y - prevEvent.center.y) : 0;
    var deltaX = prevEvent ? prevEvent.deltaX + movement.x : movement.x;
    var deltaY = prevEvent ? prevEvent.deltaY + movement.y : movement.y;
    var offsetX = movement.x;
    var offsetY = movement.y;
    var latestInterval = this._latestInterval;
    var timeStamp = Date.now();
    var deltaTime = latestInterval ? timeStamp - latestInterval.timestamp : 0;
    var velocityX = prevEvent ? prevEvent.velocityX : 0;
    var velocityY = prevEvent ? prevEvent.velocityY : 0;
    if (!latestInterval || deltaTime >= VELOCITY_INTERVAL) {
      if (latestInterval) {
        _a = [(deltaX - latestInterval.deltaX) / deltaTime, (deltaY - latestInterval.deltaY) / deltaTime], velocityX = _a[0], velocityY = _a[1];
      }
      this._latestInterval = {
        timestamp: timeStamp,
        deltaX: deltaX,
        deltaY: deltaY
      };
    }
    return {
      srcEvent: event,
      scale: scale,
      angle: angle,
      center: center,
      deltaX: deltaX,
      deltaY: deltaY,
      offsetX: offsetX,
      offsetY: offsetY,
      velocityX: velocityX,
      velocityY: velocityY,
      preventSystemEvent: true
    };
  };
  __proto._getDistance = function (start, end) {
    var x = end.clientX - start.clientX;
    var y = end.clientY - start.clientY;
    return Math.sqrt(x * x + y * y);
  };
  __proto._getButton = function (event) {
    var buttonCodeMap = {
      1: MOUSE_LEFT,
      2: MOUSE_RIGHT,
      4: MOUSE_MIDDLE
    };
    var button = this._isTouchEvent(event) ? MOUSE_LEFT : buttonCodeMap[event.buttons];
    return button ? button : null;
  };
  __proto._isTouchEvent = function (event) {
    return event.type && event.type.indexOf("touch") > -1;
  };
  __proto._isValidButton = function (button, inputButton) {
    return inputButton.indexOf(button) > -1;
  };
  __proto._isValidEvent = function (event, inputKey, inputButton) {
    return (!inputKey || isValidKey(event, inputKey)) && (!inputButton || this._isValidButton(this._getButton(event), inputButton));
  };
  __proto._preventMouseButton = function (event, button) {
    if (button === MOUSE_RIGHT) {
      win.addEventListener("contextmenu", this._stopContextMenu);
    } else if (button === MOUSE_MIDDLE) {
      event.preventDefault();
    }
  };
  return EventInput;
}();

var MouseEventInput = /*#__PURE__*/function (_super) {
  __extends$1(MouseEventInput, _super);
  function MouseEventInput() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.start = ["mousedown"];
    _this.move = ["mousemove"];
    _this.end = ["mouseup"];
    return _this;
  }
  var __proto = MouseEventInput.prototype;
  __proto.onEventStart = function (event, inputKey, inputButton) {
    var button = this._getButton(event);
    if (!this._isValidEvent(event, inputKey, inputButton)) {
      return null;
    }
    this._preventMouseButton(event, button);
    return this.extendEvent(event);
  };
  __proto.onEventMove = function (event, inputKey, inputButton) {
    if (!this._isValidEvent(event, inputKey, inputButton)) {
      return null;
    }
    return this.extendEvent(event);
  };
  __proto.onEventEnd = function () {
    return;
  };
  __proto.onRelease = function () {
    this.prevEvent = null;
    return;
  };
  __proto.getTouches = function (event, inputButton) {
    if (inputButton) {
      return this._isValidButton(MOUSE_BUTTON_CODE_MAP[event.which], inputButton) && this.end.indexOf(event.type) === -1 ? 1 : 0;
    }
    return 0;
  };
  __proto._getScale = function () {
    return 1;
  };
  __proto._getCenter = function (event) {
    return {
      x: event.clientX,
      y: event.clientY
    };
  };
  __proto._getMovement = function (event) {
    var prev = this.prevEvent.srcEvent;
    return {
      x: event.clientX - prev.clientX,
      y: event.clientY - prev.clientY
    };
  };
  return MouseEventInput;
}(EventInput);

var TouchEventInput = /*#__PURE__*/function (_super) {
  __extends$1(TouchEventInput, _super);
  function TouchEventInput() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.start = ["touchstart"];
    _this.move = ["touchmove"];
    _this.end = ["touchend", "touchcancel"];
    return _this;
  }
  var __proto = TouchEventInput.prototype;
  __proto.onEventStart = function (event, inputKey) {
    this._baseTouches = event.touches;
    if (!this._isValidEvent(event, inputKey)) {
      return null;
    }
    return this.extendEvent(event);
  };
  __proto.onEventMove = function (event, inputKey) {
    if (!this._isValidEvent(event, inputKey)) {
      return null;
    }
    return this.extendEvent(event);
  };
  __proto.onEventEnd = function (event) {
    this._baseTouches = event.touches;
    return;
  };
  __proto.onRelease = function () {
    this.prevEvent = null;
    this._baseTouches = null;
    return;
  };
  __proto.getTouches = function (event) {
    return event.touches.length;
  };
  __proto._getScale = function (event) {
    if (event.touches.length !== 2 || this._baseTouches.length < 2) {
      return null; // TODO: consider calculating non-pinch gesture scale
    }

    return this._getDistance(event.touches[0], event.touches[1]) / this._getDistance(this._baseTouches[0], this._baseTouches[1]);
  };
  __proto._getCenter = function (event) {
    return {
      x: event.touches[0].clientX,
      y: event.touches[0].clientY
    };
  };
  __proto._getMovement = function (event) {
    var prev = this.prevEvent.srcEvent;
    if (event.touches[0].identifier !== prev.touches[0].identifier) {
      return {
        x: 0,
        y: 0
      };
    }
    return {
      x: event.touches[0].clientX - prev.touches[0].clientX,
      y: event.touches[0].clientY - prev.touches[0].clientY
    };
  };
  return TouchEventInput;
}(EventInput);

var PointerEventInput = /*#__PURE__*/function (_super) {
  __extends$1(PointerEventInput, _super);
  function PointerEventInput() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.start = SUPPORT_POINTER ? ["pointerdown"] : ["MSPointerDown"];
    _this.move = SUPPORT_POINTER ? ["pointermove"] : ["MSPointerMove"];
    _this.end = SUPPORT_POINTER ? ["pointerup", "pointercancel"] : ["MSPointerUp", "MSPointerCancel"];
    // store first, recent inputs for each event id
    _this._firstInputs = [];
    _this._recentInputs = [];
    return _this;
  }
  var __proto = PointerEventInput.prototype;
  __proto.onEventStart = function (event, inputKey, inputButton) {
    var button = this._getButton(event);
    if (!this._isValidEvent(event, inputKey, inputButton)) {
      return null;
    }
    this._preventMouseButton(event, button);
    this._updatePointerEvent(event);
    return this.extendEvent(event);
  };
  __proto.onEventMove = function (event, inputKey, inputButton) {
    if (!this._isValidEvent(event, inputKey, inputButton)) {
      return null;
    }
    this._updatePointerEvent(event);
    return this.extendEvent(event);
  };
  __proto.onEventEnd = function (event) {
    this._removePointerEvent(event);
  };
  __proto.onRelease = function () {
    this.prevEvent = null;
    this._firstInputs = [];
    this._recentInputs = [];
    return;
  };
  __proto.getTouches = function () {
    return this._recentInputs.length;
  };
  __proto._getScale = function () {
    if (this._recentInputs.length !== 2) {
      return null; // TODO: consider calculating non-pinch gesture scale
    }

    return this._getDistance(this._recentInputs[0], this._recentInputs[1]) / this._getDistance(this._firstInputs[0], this._firstInputs[1]);
  };
  __proto._getCenter = function (event) {
    return {
      x: event.clientX,
      y: event.clientY
    };
  };
  __proto._getMovement = function (event) {
    var prev = this.prevEvent.srcEvent;
    if (event.pointerId !== prev.pointerId) {
      return {
        x: 0,
        y: 0
      };
    }
    return {
      x: event.clientX - prev.clientX,
      y: event.clientY - prev.clientY
    };
  };
  __proto._updatePointerEvent = function (event) {
    var _this = this;
    var addFlag = false;
    this._recentInputs.forEach(function (e, i) {
      if (e.pointerId === event.pointerId) {
        addFlag = true;
        _this._recentInputs[i] = event;
      }
    });
    if (!addFlag) {
      this._firstInputs.push(event);
      this._recentInputs.push(event);
    }
  };
  __proto._removePointerEvent = function (event) {
    this._firstInputs = this._firstInputs.filter(function (x) {
      return x.pointerId !== event.pointerId;
    });
    this._recentInputs = this._recentInputs.filter(function (x) {
      return x.pointerId !== event.pointerId;
    });
  };
  return PointerEventInput;
}(EventInput);

var TouchMouseEventInput = /*#__PURE__*/function (_super) {
  __extends$1(TouchMouseEventInput, _super);
  function TouchMouseEventInput() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.start = ["mousedown", "touchstart"];
    _this.move = ["mousemove", "touchmove"];
    _this.end = ["mouseup", "touchend", "touchcancel"];
    return _this;
  }
  var __proto = TouchMouseEventInput.prototype;
  __proto.onEventStart = function (event, inputKey, inputButton) {
    var button = this._getButton(event);
    if (this._isTouchEvent(event)) {
      this._baseTouches = event.touches;
    }
    if (!this._isValidEvent(event, inputKey, inputButton)) {
      return null;
    }
    this._preventMouseButton(event, button);
    return this.extendEvent(event);
  };
  __proto.onEventMove = function (event, inputKey, inputButton) {
    if (!this._isValidEvent(event, inputKey, inputButton)) {
      return null;
    }
    return this.extendEvent(event);
  };
  __proto.onEventEnd = function (event) {
    if (this._isTouchEvent(event)) {
      this._baseTouches = event.touches;
    }
    return;
  };
  __proto.onRelease = function () {
    this.prevEvent = null;
    this._baseTouches = null;
    return;
  };
  __proto.getTouches = function (event, inputButton) {
    if (this._isTouchEvent(event)) {
      return event.touches.length;
    } else {
      return this._isValidButton(MOUSE_BUTTON_CODE_MAP[event.which], inputButton) && this.end.indexOf(event.type) === -1 ? 1 : 0;
    }
  };
  __proto._getScale = function (event) {
    if (this._isTouchEvent(event)) {
      if (event.touches.length !== 2 || this._baseTouches.length < 2) {
        return 1; // TODO: consider calculating non-pinch gesture scale
      }

      return this._getDistance(event.touches[0], event.touches[1]) / this._getDistance(this._baseTouches[0], this._baseTouches[1]);
    }
    return this.prevEvent.scale;
  };
  __proto._getCenter = function (event) {
    if (this._isTouchEvent(event)) {
      return {
        x: event.touches[0].clientX,
        y: event.touches[0].clientY
      };
    }
    return {
      x: event.clientX,
      y: event.clientY
    };
  };
  __proto._getMovement = function (event) {
    var _this = this;
    var prev = this.prevEvent.srcEvent;
    var _a = [event, prev].map(function (e) {
        if (_this._isTouchEvent(e)) {
          return {
            id: e.touches[0].identifier,
            x: e.touches[0].clientX,
            y: e.touches[0].clientY
          };
        }
        return {
          id: null,
          x: e.clientX,
          y: e.clientY
        };
      }),
      nextSpot = _a[0],
      prevSpot = _a[1];
    return nextSpot.id === prevSpot.id ? {
      x: nextSpot.x - prevSpot.x,
      y: nextSpot.y - prevSpot.y
    } : {
      x: 0,
      y: 0
    };
  };
  return TouchMouseEventInput;
}(EventInput);

var toAxis = function (source, offset) {
  return offset.reduce(function (acc, v, i) {
    if (source[i]) {
      acc[source[i]] = v;
    }
    return acc;
  }, {});
};
var convertInputType = function (inputType) {
  if (inputType === void 0) {
    inputType = [];
  }
  var hasTouch = false;
  var hasMouse = false;
  var hasPointer = false;
  inputType.forEach(function (v) {
    switch (v) {
      case "mouse":
        hasMouse = true;
        break;
      case "touch":
        hasTouch = SUPPORT_TOUCH;
        break;
      case "pointer":
        hasPointer = SUPPORT_POINTER_EVENTS;
      // no default
    }
  });

  if (hasPointer) {
    return new PointerEventInput();
  } else if (hasTouch && hasMouse) {
    return new TouchMouseEventInput();
  } else if (hasTouch) {
    return new TouchEventInput();
  } else if (hasMouse) {
    return new MouseEventInput();
  }
  return null;
};
function getAddEventOptions(eventName) {
  // The passive default value of the touch event is true.
  // If not a touch event, return false to support ie11
  return eventName.indexOf("touch") > -1 ? {
    passive: false
  } : false;
}

var InputObserver = /*#__PURE__*/function () {
  function InputObserver(_a) {
    var options = _a.options,
      interruptManager = _a.interruptManager,
      eventManager = _a.eventManager,
      axisManager = _a.axisManager,
      animationManager = _a.animationManager;
    this._isOutside = false;
    this._moveDistance = null;
    this._isStopped = false;
    this.options = options;
    this._interruptManager = interruptManager;
    this._eventManager = eventManager;
    this._axisManager = axisManager;
    this._animationManager = animationManager;
  }
  var __proto = InputObserver.prototype;
  __proto.get = function (input) {
    return this._axisManager.get(input.axes);
  };
  __proto.hold = function (input, event) {
    if (this._interruptManager.isInterrupted() || !input.axes.length) {
      return;
    }
    var changeOption = {
      input: input,
      event: event
    };
    this._isStopped = false;
    this._interruptManager.setInterrupt(true);
    this._animationManager.stopAnimation(changeOption);
    ++this._eventManager.holdingCount;
    if (!this._moveDistance) {
      this._eventManager.hold(this._axisManager.get(), changeOption);
    }
    this._isOutside = this._axisManager.isOutside(input.axes);
    this._moveDistance = this._axisManager.get(input.axes);
  };
  __proto.change = function (input, event, offset, useAnimation) {
    if (this._isStopped || !this._interruptManager.isInterrupting() || this._axisManager.every(offset, function (v) {
      return v === 0;
    })) {
      return;
    }
    var nativeEvent = event.srcEvent ? event.srcEvent : event;
    if (nativeEvent.__childrenAxesAlreadyChanged) {
      return;
    }
    var depaPos = this._moveDistance || this._axisManager.get(input.axes);
    var destPos;
    // for outside logic
    destPos = map(depaPos, function (v, k) {
      return v + (offset[k] || 0);
    });
    if (this._moveDistance) {
      this._moveDistance = this._axisManager.map(destPos, function (v, _a) {
        var circular = _a.circular,
          range = _a.range;
        return circular && (circular[0] || circular[1]) ? getCirculatedPos(v, range, circular) : v;
      });
    }
    // from outside to inside
    if (this._isOutside && this._axisManager.every(depaPos, function (v, opt) {
      return !isOutside(v, opt.range);
    })) {
      this._isOutside = false;
    }
    depaPos = this._atOutside(depaPos);
    destPos = this._atOutside(destPos);
    if (!this.options.nested || !this._isEndofAxis(offset, depaPos, destPos)) {
      nativeEvent.__childrenAxesAlreadyChanged = true;
    }
    var changeOption = {
      input: input,
      event: event
    };
    if (useAnimation) {
      var duration = this._animationManager.getDuration(destPos, depaPos);
      this._animationManager.animateTo(destPos, duration, changeOption);
    } else {
      var isCanceled = !this._eventManager.triggerChange(destPos, depaPos, changeOption, true);
      if (isCanceled) {
        this._isStopped = true;
        this._moveDistance = null;
        this._animationManager.finish(false);
      }
    }
  };
  __proto.release = function (input, event, velocity, inputDuration) {
    if (this._isStopped || !this._interruptManager.isInterrupting() || !this._moveDistance) {
      return;
    }
    var nativeEvent = event.srcEvent ? event.srcEvent : event;
    if (nativeEvent.__childrenAxesAlreadyReleased) {
      velocity = velocity.map(function () {
        return 0;
      });
    }
    var pos = this._axisManager.get(input.axes);
    var depaPos = this._axisManager.get();
    var displacement = this._animationManager.getDisplacement(velocity);
    var offset = toAxis(input.axes, displacement);
    var destPos = this._axisManager.get(this._axisManager.map(offset, function (v, opt, k) {
      if (opt.circular && (opt.circular[0] || opt.circular[1])) {
        return pos[k] + v;
      } else {
        return getInsidePosition(pos[k] + v, opt.range, opt.circular, opt.bounce);
      }
    }));
    nativeEvent.__childrenAxesAlreadyReleased = true;
    var duration = this._animationManager.getDuration(destPos, pos, inputDuration);
    if (duration === 0) {
      destPos = __assign({}, depaPos);
    }
    // prepare params
    var param = {
      depaPos: depaPos,
      destPos: destPos,
      duration: duration,
      delta: this._axisManager.getDelta(depaPos, destPos),
      inputEvent: event,
      input: input,
      isTrusted: true
    };
    --this._eventManager.holdingCount;
    this._eventManager.triggerRelease(param);
    if (this._eventManager.holdingCount === 0) {
      this._moveDistance = null;
    }
    // to contol
    var userWish = this._animationManager.getUserControl(param);
    var isEqual = equal(userWish.destPos, depaPos);
    var changeOption = {
      input: input,
      event: event
    };
    if (isEqual || userWish.duration === 0) {
      if (!isEqual) {
        this._eventManager.triggerChange(userWish.destPos, depaPos, changeOption, true);
      }
      this._interruptManager.setInterrupt(false);
      if (this._axisManager.isOutside()) {
        this._animationManager.restore(changeOption);
      } else {
        this._eventManager.triggerFinish(true);
      }
    } else {
      this._animationManager.animateTo(userWish.destPos, userWish.duration, changeOption);
    }
  };
  // when move pointer is held in outside
  __proto._atOutside = function (pos) {
    var _this = this;
    if (this._isOutside) {
      return this._axisManager.map(pos, function (v, opt) {
        var tn = opt.range[0] - opt.bounce[0];
        var tx = opt.range[1] + opt.bounce[1];
        return v > tx ? tx : v < tn ? tn : v;
      });
    } else {
      return this._axisManager.map(pos, function (v, opt) {
        var min = opt.range[0];
        var max = opt.range[1];
        var out = opt.bounce;
        var circular = opt.circular;
        if (circular[0] && v < min || circular[1] && v > max) {
          return v;
        } else if (v < min) {
          // left
          return min - _this._animationManager.interpolate(min - v, out[0]);
        } else if (v > max) {
          // right
          return max + _this._animationManager.interpolate(v - max, out[1]);
        }
        return v;
      });
    }
  };
  __proto._isEndofAxis = function (offset, depaPos, destPos) {
    return this._axisManager.every(depaPos, function (value, option, key) {
      return offset[key] === 0 || depaPos[key] === destPos[key] && isEndofBounce(value, option.range, option.bounce, option.circular);
    });
  };
  return InputObserver;
}();

var clamp = function (value, min, max) {
  return Math.max(Math.min(value, max), min);
};
var AnimationManager = /*#__PURE__*/function () {
  function AnimationManager(_a) {
    var options = _a.options,
      interruptManager = _a.interruptManager,
      eventManager = _a.eventManager,
      axisManager = _a.axisManager;
    this._options = options;
    this.interruptManager = interruptManager;
    this.eventManager = eventManager;
    this.axisManager = axisManager;
    this.animationEnd = this.animationEnd.bind(this);
  }
  var __proto = AnimationManager.prototype;
  __proto.getDuration = function (depaPos, destPos, wishDuration) {
    var _this = this;
    var duration;
    if (typeof wishDuration !== "undefined") {
      duration = wishDuration;
    } else {
      var durations_1 = map(destPos, function (v, k) {
        return getDuration(Math.abs(v - depaPos[k]), _this._options.deceleration);
      });
      duration = Object.keys(durations_1).reduce(function (max, v) {
        return Math.max(max, durations_1[v]);
      }, -Infinity);
    }
    return clamp(duration, this._options.minimumDuration, this._options.maximumDuration);
  };
  __proto.getDisplacement = function (velocity) {
    var totalVelocity = Math.pow(velocity.reduce(function (total, v) {
      return total + v * v;
    }, 0), 1 / velocity.length);
    var duration = Math.abs(totalVelocity / -this._options.deceleration);
    return velocity.map(function (v) {
      return v / 2 * duration;
    });
  };
  __proto.stopAnimation = function (option) {
    if (this._animateParam) {
      var orgPos_1 = this.axisManager.get();
      var pos = this.axisManager.map(orgPos_1, function (v, opt) {
        return getCirculatedPos(v, opt.range, opt.circular);
      });
      if (!every(pos, function (v, k) {
        return orgPos_1[k] === v;
      })) {
        this.eventManager.triggerChange(pos, orgPos_1, option, !!option);
      }
      this._animateParam = null;
      if (this._raf) {
        cancelAnimationFrame$1(this._raf);
      }
      this._raf = null;
      this.eventManager.triggerAnimationEnd(!!(option === null || option === void 0 ? void 0 : option.event));
    }
  };
  __proto.getEventInfo = function () {
    if (this._animateParam && this._animateParam.input && this._animateParam.inputEvent) {
      return {
        input: this._animateParam.input,
        event: this._animateParam.inputEvent
      };
    } else {
      return null;
    }
  };
  __proto.restore = function (option) {
    var pos = this.axisManager.get();
    var destPos = this.axisManager.map(pos, function (v, opt) {
      return Math.min(opt.range[1], Math.max(opt.range[0], v));
    });
    this.stopAnimation();
    this.animateTo(destPos, this.getDuration(pos, destPos), option);
  };
  __proto.animationEnd = function () {
    var beforeParam = this.getEventInfo();
    this._animateParam = null;
    // for Circular
    var circularTargets = this.axisManager.filter(this.axisManager.get(), function (v, opt) {
      return isCircularable(v, opt.range, opt.circular);
    });
    if (Object.keys(circularTargets).length > 0) {
      this.setTo(this.axisManager.map(circularTargets, function (v, opt) {
        return getCirculatedPos(v, opt.range, opt.circular);
      }));
    }
    this.interruptManager.setInterrupt(false);
    this.eventManager.triggerAnimationEnd(!!beforeParam);
    if (this.axisManager.isOutside()) {
      this.restore(beforeParam);
    } else {
      this.finish(!!beforeParam);
    }
  };
  __proto.finish = function (isTrusted) {
    this._animateParam = null;
    this.interruptManager.setInterrupt(false);
    this.eventManager.triggerFinish(isTrusted);
  };
  __proto.getUserControl = function (param) {
    var userWish = param.setTo();
    userWish.destPos = this.axisManager.get(userWish.destPos);
    userWish.duration = clamp(userWish.duration, this._options.minimumDuration, this._options.maximumDuration);
    return userWish;
  };
  __proto.animateTo = function (destPos, duration, option) {
    var _this = this;
    this.stopAnimation();
    var param = this._createAnimationParam(destPos, duration, option);
    var depaPos = __assign({}, param.depaPos);
    var retTrigger = this.eventManager.triggerAnimationStart(param);
    // to control
    var userWish = this.getUserControl(param);
    // You can't stop the 'animationStart' event when 'circular' is true.
    if (!retTrigger && this.axisManager.every(userWish.destPos, function (v, opt) {
      return isCircularable(v, opt.range, opt.circular);
    })) {
      console.warn("You can't stop the 'animation' event when 'circular' is true.");
    }
    if (retTrigger && !equal(userWish.destPos, depaPos)) {
      var inputEvent = (option === null || option === void 0 ? void 0 : option.event) || null;
      this._animateLoop({
        depaPos: depaPos,
        destPos: userWish.destPos,
        duration: userWish.duration,
        delta: this.axisManager.getDelta(depaPos, userWish.destPos),
        isTrusted: !!inputEvent,
        inputEvent: inputEvent,
        input: (option === null || option === void 0 ? void 0 : option.input) || null
      }, function () {
        return _this.animationEnd();
      });
    }
  };
  __proto.setTo = function (pos, duration) {
    if (duration === void 0) {
      duration = 0;
    }
    var axes = Object.keys(pos);
    var orgPos = this.axisManager.get(axes);
    if (equal(pos, orgPos)) {
      return this;
    }
    this.interruptManager.setInterrupt(true);
    var movedPos = filter(pos, function (v, k) {
      return orgPos[k] !== v;
    });
    if (!Object.keys(movedPos).length) {
      return this;
    }
    movedPos = this.axisManager.map(movedPos, function (v, opt) {
      var range = opt.range,
        circular = opt.circular;
      if (circular && (circular[0] || circular[1])) {
        return v;
      } else {
        return getInsidePosition(v, range, circular);
      }
    });
    if (equal(movedPos, orgPos)) {
      return this;
    }
    if (duration > 0) {
      this.animateTo(movedPos, duration);
    } else {
      this.stopAnimation();
      this.eventManager.triggerChange(movedPos);
      this.finish(false);
    }
    return this;
  };
  __proto.setBy = function (pos, duration) {
    if (duration === void 0) {
      duration = 0;
    }
    return this.setTo(map(this.axisManager.get(Object.keys(pos)), function (v, k) {
      return v + pos[k];
    }), duration);
  };
  __proto.setOptions = function (options) {
    this._options = __assign(__assign({}, this._options), options);
  };
  __proto._createAnimationParam = function (pos, duration, option) {
    var depaPos = this.axisManager.get();
    var destPos = pos;
    var inputEvent = (option === null || option === void 0 ? void 0 : option.event) || null;
    return {
      depaPos: depaPos,
      destPos: destPos,
      duration: clamp(duration, this._options.minimumDuration, this._options.maximumDuration),
      delta: this.axisManager.getDelta(depaPos, destPos),
      inputEvent: inputEvent,
      input: (option === null || option === void 0 ? void 0 : option.input) || null,
      isTrusted: !!inputEvent,
      done: this.animationEnd
    };
  };
  __proto._animateLoop = function (param, complete) {
    var _this = this;
    if (param.duration) {
      this._animateParam = __assign(__assign({}, param), {
        startTime: new Date().getTime()
      });
      var originalIntendedPos_1 = map(param.destPos, function (v) {
        return v;
      });
      var state_1 = this._initState(this._animateParam);
      var loop_1 = function () {
        _this._raf = null;
        var animateParam = _this._animateParam;
        var nextState = _this._getNextState(state_1);
        var isCanceled = !_this.eventManager.triggerChange(nextState.pos, state_1.pos);
        state_1 = nextState;
        if (nextState.finished) {
          animateParam.destPos = _this._getFinalPos(animateParam.destPos, originalIntendedPos_1);
          if (!equal(animateParam.destPos, _this.axisManager.get(Object.keys(animateParam.destPos)))) {
            _this.eventManager.triggerChange(animateParam.destPos, nextState.pos);
          }
          complete();
          return;
        } else if (isCanceled) {
          _this.finish(false);
        } else {
          _this._raf = requestAnimationFrame$1(loop_1);
        }
      };
      loop_1();
    } else {
      this.eventManager.triggerChange(param.destPos);
      complete();
    }
  };
  /**
   * Get estimated final value.
   *
   * If destPos is within the 'error range' of the original intended position, the initial intended position is returned.
   *   - eg. original intended pos: 100, destPos: 100.0000000004 ==> return 100;
   * If dest Pos is outside the 'range of error' compared to the originally intended pos, it is returned rounded based on the originally intended pos.
   *   - eg. original intended pos: 100.123 destPos: 50.12345 => return 50.123
   * @param originalIntendedPos
   * @param destPos
   */
  __proto._getFinalPos = function (destPos, originalIntendedPos) {
    var _this = this;
    // compare destPos and originalIntendedPos
    // eslint-disable-next-line @typescript-eslint/naming-convention
    var ERROR_LIMIT = 0.000001;
    var finalPos = map(destPos, function (value, key) {
      if (value >= originalIntendedPos[key] - ERROR_LIMIT && value <= originalIntendedPos[key] + ERROR_LIMIT) {
        // In error range, return original intended
        return originalIntendedPos[key];
      } else {
        // Out of error range, return rounded pos.
        var roundUnit = _this._getRoundUnit(value, key);
        var result = roundNumber(value, roundUnit);
        return result;
      }
    });
    return finalPos;
  };
  __proto._getRoundUnit = function (val, key) {
    var roundUnit = this._options.round; // manual mode
    var minRoundUnit = null; // auto mode
    // auto mode
    if (!roundUnit) {
      // Get minimum round unit
      var options = this.axisManager.getAxisOptions(key);
      minRoundUnit = inversePow(Math.max(getDecimalPlace(options.range[0]), getDecimalPlace(options.range[1]), getDecimalPlace(val)));
    }
    return minRoundUnit || roundUnit;
  };
  return AnimationManager;
}();

var EasingManager = /*#__PURE__*/function (_super) {
  __extends$1(EasingManager, _super);
  function EasingManager() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._useDuration = true;
    return _this;
  }
  var __proto = EasingManager.prototype;
  __proto.interpolate = function (displacement, threshold) {
    var initSlope = this._easing(0.00001) / 0.00001;
    return this._easing(displacement / (threshold * initSlope)) * threshold;
  };
  __proto.updateAnimation = function (options) {
    var _a;
    var animateParam = this._animateParam;
    if (!animateParam) {
      return;
    }
    var diffTime = new Date().getTime() - animateParam.startTime;
    var pos = (options === null || options === void 0 ? void 0 : options.destPos) || animateParam.destPos;
    var duration = (_a = options === null || options === void 0 ? void 0 : options.duration) !== null && _a !== void 0 ? _a : animateParam.duration;
    if ((options === null || options === void 0 ? void 0 : options.restart) || duration <= diffTime) {
      this.setTo(pos, duration - diffTime);
      return;
    }
    if (options === null || options === void 0 ? void 0 : options.destPos) {
      var currentPos = this.axisManager.get();
      // When destination is changed, new delta should be calculated as remaining percent.
      // For example, moving x:0, y:0 to x:200, y:200 and it has current easing percent of 92%. coordinate is x:184 and y:184
      // If destination changes to x:300, y:300. xdelta:200, ydelta:200 changes to xdelta:116, ydelta:116 and use remaining easingPer as 100%, not 8% as previous.
      // Therefore, original easingPer by time is kept. And divided by (1 - self._initialEasingPer) which means new total easing percent. Like calculating 8% as 100%.
      this._initialEasingPer = this._prevEasingPer;
      animateParam.delta = this.axisManager.getDelta(currentPos, pos);
      animateParam.destPos = pos;
    }
    if (options === null || options === void 0 ? void 0 : options.duration) {
      var ratio = (diffTime + this._durationOffset) / animateParam.duration;
      // Use durationOffset for keeping animation ratio after duration is changed.
      // newRatio = (diffTime + newDurationOffset) / newDuration = oldRatio
      // newDurationOffset = oldRatio * newDuration - diffTime
      this._durationOffset = ratio * duration - diffTime;
      animateParam.duration = duration;
    }
  };
  __proto._initState = function (info) {
    this._initialEasingPer = 0;
    this._prevEasingPer = 0;
    this._durationOffset = 0;
    return {
      pos: info.depaPos,
      easingPer: 0,
      finished: false
    };
  };
  __proto._getNextState = function (prevState) {
    var _this = this;
    var animateParam = this._animateParam;
    var prevPos = prevState.pos;
    var destPos = animateParam.destPos;
    var directions = map(prevPos, function (value, key) {
      return value <= destPos[key] ? 1 : -1;
    });
    var diffTime = new Date().getTime() - animateParam.startTime;
    var ratio = (diffTime + this._durationOffset) / animateParam.duration;
    var easingPer = this._easing(ratio);
    var toPos = this.axisManager.map(prevPos, function (pos, options, key) {
      var nextPos = ratio >= 1 ? destPos[key] : pos + animateParam.delta[key] * (easingPer - _this._prevEasingPer) / (1 - _this._initialEasingPer);
      // Subtract distance from distance already moved.
      // Recalculate the remaining distance.
      // Fix the bouncing phenomenon by changing the range.
      var circulatedPos = getCirculatedPos(nextPos, options.range, options.circular);
      if (nextPos !== circulatedPos) {
        // circular
        var rangeOffset = directions[key] * (options.range[1] - options.range[0]);
        destPos[key] -= rangeOffset;
        prevPos[key] -= rangeOffset;
      }
      return circulatedPos;
    });
    this._prevEasingPer = easingPer;
    return {
      pos: toPos,
      easingPer: easingPer,
      finished: easingPer >= 1
    };
  };
  __proto._easing = function (p) {
    return p > 1 ? 1 : this._options.easing(p);
  };
  return EasingManager;
}(AnimationManager);

/**
 * @typedef {Object} AxisOption The Axis information. The key of the axis specifies the name to use as the logical virtual coordinate system.
 * @ko 축 정보. 축의 키는 논리적인 가상 좌표계로 사용할 이름을 지정한다.
 * @param {Number[]} [range] The range of coordinate <ko>좌표 범위</ko>
 * @param {Number} [range[0]=0] The coordinate of the minimum <ko>최소 좌표</ko>
 * @param {Number} [range[1]=0] The coordinate of the maximum <ko>최대 좌표</ko>
 * @param {Number} [startPos=range[0]] The coordinates to be moved when creating an instance <ko>인스턴스 생성시 이동할 좌표</ko>
 * @param {Number[]} [bounce] The size of bouncing area. The coordinates can exceed the coordinate area as much as the bouncing area based on user action. If the coordinates does not exceed the bouncing area when an element is dragged, the coordinates where bouncing effects are applied are retuned back into the coordinate area<ko>바운스 영역의 크기. 사용자의 동작에 따라 좌표가 좌표 영역을 넘어 바운스 영역의 크기만큼 더 이동할 수 있다. 사용자가 끌어다 놓는 동작을 했을 때 좌표가 바운스 영역에 있으면, 바운스 효과가 적용된 좌표가 다시 좌표 영역 안으로 들어온다</ko>
 * @param {Number} [bounce[0]=0] The size of coordinate of the minimum area <ko>최소 좌표 바운스 영역의 크기</ko>
 * @param {Number} [bounce[1]=0] The size of coordinate of the maximum area <ko>최대 좌표 바운스 영역의 크기</ko>
 * @param {Boolean[]} [circular] Indicates whether a circular element is available. If it is set to "true" and an element is dragged outside the coordinate area, the element will appear on the other side.<ko>순환 여부. 'true'로 설정한 방향의 좌표 영역 밖으로 엘리먼트가 이동하면 반대 방향에서 엘리먼트가 나타난다</ko>
 * @param {Boolean} [circular[0]=false] Indicates whether to circulate to the coordinate of the minimum <ko>최소 좌표 방향의 순환 여부</ko>
 * @param {Boolean} [circular[1]=false] Indicates whether to circulate to the coordinate of the maximum <ko>최대 좌표 방향의 순환 여부</ko>
 **/
/**
 * @typedef {Object} AxesOption The option object of the eg.Axes module
 * @ko eg.Axes 모듈의 옵션 객체
 * @param {Function} [easing=easing.easeOutCubic] The easing function to apply to an animation <ko>애니메이션에 적용할 easing 함수</ko>
 * @param {Number} [maximumDuration=Infinity] Maximum duration of the animation <ko>가속도에 의해 애니메이션이 동작할 때의 최대 좌표 이동 시간</ko>
 * @param {Number} [minimumDuration=0] Minimum duration of the animation <ko>가속도에 의해 애니메이션이 동작할 때의 최소 좌표 이동 시간</ko>
 * @param {Number} [deceleration=0.0006] Deceleration of the animation where acceleration is manually enabled by user. A higher value indicates shorter running time. <ko>사용자의 동작으로 가속도가 적용된 애니메이션의 감속도. 값이 높을수록 애니메이션 실행 시간이 짧아진다</ko>
 * @param {Boolean} [interruptable=true] Indicates whether an animation is interruptible.
 * - true: It can be paused or stopped by user action or the API.
 * - false: It cannot be paused or stopped by user action or the API while it is running.
 * <ko>진행 중인 애니메이션 중지 가능 여부.
 * - true: 사용자의 동작이나 API로 애니메이션을 중지할 수 있다.
 * - false: 애니메이션이 진행 중일 때는 사용자의 동작이나 API가 적용되지 않는다</ko>
 * @param {Number} [round=null] Rounding unit. For example, 0.1 rounds to 0.1 decimal point(6.1234 => 6.1), 5 rounds to 5 (93 => 95)
 * [Details](https://github.com/naver/egjs-axes/wiki/round-option)<ko>반올림 단위. 예를 들어 0.1 은 소숫점 0.1 까지 반올림(6.1234 => 6.1), 5 는 5 단위로 반올림(93 => 95).
 * [상세내용](https://github.com/naver/egjs-axes/wiki/round-option)</ko>
 * @param {Boolean} [nested=false] Whether the event propagates to other instances when the coordinates reach the end of the movable area <ko>좌표가 이동 가능한 영역의 끝까지 도달했을 때 다른 인스턴스들로의 이벤트 전파 여부</ko>
 **/
/**
 * A module used to change the information of user action entered by various input devices such as touch screen or mouse into the logical virtual coordinates. You can easily create a UI that responds to user actions.
 * @ko 터치 입력 장치나 마우스와 같은 다양한 입력 장치를 통해 전달 받은 사용자의 동작을 논리적인 가상 좌표로 변경하는 모듈이다. 사용자 동작에 반응하는 UI를 손쉽게 만들수 있다.
 * @extends eg.Component
 *
 * @param {Object.<string, AxisOption>} axis Axis information managed by eg.Axes. The key of the axis specifies the name to use as the logical virtual coordinate system.  <ko>eg.Axes가 관리하는 축 정보. 축의 키는 논리적인 가상 좌표계로 사용할 이름을 지정한다.</ko>
 * @param {AxesOption} [options={}] The option object of the eg.Axes module<ko>eg.Axes 모듈의 옵션 객체</ko>
 * @param {Object.<string, number>} [startPos={}] The coordinates to be moved when creating an instance. It is applied with higher priority than startPos of axisOption.<ko>인스턴스 생성시 이동할 좌표, axisOption의 startPos보다 높은 우선순위로 적용된다.</ko>
 *
 * @support {"ie": "10+", "ch" : "latest", "ff" : "latest",  "sf" : "latest", "edge" : "latest", "ios" : "7+", "an" : "2.3+ (except 3.x)"}
 * @example
 * ```js
 * // 1. Initialize eg.Axes
 * const axes = new eg.Axes({
 *  something1: {
 *    range: [0, 150],
 *    bounce: 50
 *  },
 *  something2: {
 *    range: [0, 200],
 *    bounce: 100
 *  },
 *  somethingN: {
 *    range: [1, 10],
 *  }
 * }, {
 *  deceleration : 0.0024
 * });
 *
 * // 2. attach event handler
 * axes.on({
 *  "hold" : function(evt) {
 *  },
 *  "release" : function(evt) {
 *  },
 *  "animationStart" : function(evt) {
 *  },
 *  "animationEnd" : function(evt) {
 *  },
 *  "change" : function(evt) {
 *  }
 * });
 *
 * // 3. Initialize inputTypes
 * const panInputArea = new eg.Axes.PanInput("#area", {
 *  scale: [0.5, 1]
 * });
 * const panInputHmove = new eg.Axes.PanInput("#hmove");
 * const panInputVmove = new eg.Axes.PanInput("#vmove");
 * const pinchInputArea = new eg.Axes.PinchInput("#area", {
 *  scale: 1.5
 * });
 *
 * // 4. Connect eg.Axes and InputTypes
 * // [PanInput] When the mouse or touchscreen is down and moved.
 * // Connect the 'something2' axis to the mouse or touchscreen x position and
 * // connect the 'somethingN' axis to the mouse or touchscreen y position.
 * axes.connect(["something2", "somethingN"], panInputArea); // or axes.connect("something2 somethingN", panInputArea);
 *
 * // Connect only one 'something1' axis to the mouse or touchscreen x position.
 * axes.connect(["something1"], panInputHmove); // or axes.connect("something1", panInputHmove);
 *
 * // Connect only one 'something2' axis to the mouse or touchscreen y position.
 * axes.connect(["", "something2"], panInputVmove); // or axes.connect(" something2", panInputVmove);
 *
 * // [PinchInput] Connect 'something2' axis when two pointers are moving toward (zoom-in) or away from each other (zoom-out).
 * axes.connect("something2", pinchInputArea);
 * ```
 */
var Axes = /*#__PURE__*/function (_super) {
  __extends$1(Axes, _super);
  /**
   *
   */
  function Axes(axis, options, startPos) {
    if (axis === void 0) {
      axis = {};
    }
    if (options === void 0) {
      options = {};
    }
    if (startPos === void 0) {
      startPos = {};
    }
    var _this = _super.call(this) || this;
    _this.axis = axis;
    _this._inputs = [];
    _this.options = __assign({
      easing: function (x) {
        return 1 - Math.pow(1 - x, 3);
      },
      interruptable: true,
      maximumDuration: Infinity,
      minimumDuration: 0,
      deceleration: 0.0006,
      round: null,
      nested: false
    }, options);
    Object.keys(startPos).forEach(function (key) {
      _this.axis[key].startPos = startPos[key];
    });
    _this.interruptManager = new InterruptManager(_this.options);
    _this.axisManager = new AxisManager(_this.axis);
    _this.eventManager = new EventManager(_this);
    _this.animationManager = new EasingManager(_this);
    _this.inputObserver = new InputObserver(_this);
    _this.eventManager.setAnimationManager(_this.animationManager);
    _this.eventManager.triggerChange(_this.axisManager.get());
    return _this;
  }
  var __proto = Axes.prototype;
  Object.defineProperty(__proto, "holding", {
    /**
     * @name Axes#holding
     * @desc Returns true if at least one input is in progress.
     * @ko 입력이 하나 이상 진행 중인지 여부를 반환한다.
     *
     * @readonly
     * @type {boolean}
     * @example
     * ```js
     * const axes = new eg.Axes({
     *  x: {
     *    range: [0, 100],
     *  },
     * });
     *
     * axes.holding
     * ```
     */
    get: function () {
      return this.eventManager.holdingCount > 0;
    },
    enumerable: false,
    configurable: true
  });
  /**
   * Connect the axis of eg.Axes to the inputType.
   * @ko eg.Axes의 축과 inputType을 연결한다
   * @param {(String[]|String)} axes The name of the axis to associate with inputType <ko>inputType과 연결할 축의 이름</ko>
   * @param {Object} inputType The inputType instance to associate with the axis of eg.Axes <ko>eg.Axes의 축과 연결할 inputType 인스턴스</ko>
   * @return {eg.Axes} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>
   * @example
   * ```js
   * const axes = new eg.Axes({
   *   "x": {
   *      range: [0, 100]
   *   },
   *   "xOther": {
   *      range: [-100, 100]
   *   }
   * });
   *
   * axes.connect("x", new eg.Axes.PanInput("#area1"))
   *    .connect("x xOther", new eg.Axes.PanInput("#area2"))
   *    .connect(" xOther", new eg.Axes.PanInput("#area3"))
   *    .connect(["x"], new eg.Axes.PanInput("#area4"))
   *    .connect(["xOther", "x"], new eg.Axes.PanInput("#area5"))
   *    .connect(["", "xOther"], new eg.Axes.PanInput("#area6"));
   * ```
   */
  __proto.connect = function (axes, inputType) {
    var mapped;
    if (typeof axes === "string") {
      mapped = axes.split(" ");
    } else {
      mapped = axes.concat();
    }
    // check same instance
    if (~this._inputs.indexOf(inputType)) {
      this.disconnect(inputType);
    }
    inputType.mapAxes(mapped);
    inputType.connect(this.inputObserver);
    this._inputs.push(inputType);
    return this;
  };
  /**
   * Disconnect the axis of eg.Axes from the inputType.
   * @ko eg.Axes의 축과 inputType의 연결을 끊는다.
   * @param {Object} [inputType] An inputType instance associated with the axis of eg.Axes <ko>eg.Axes의 축과 연결한 inputType 인스턴스</ko>
   * @return {eg.Axes} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>
   * @example
   * ```js
   * const axes = new eg.Axes({
   *   "x": {
   *      range: [0, 100]
   *   },
   *   "xOther": {
   *      range: [-100, 100]
   *   }
   * });
   *
   * const input1 = new eg.Axes.PanInput("#area1");
   * const input2 = new eg.Axes.PanInput("#area2");
   * const input3 = new eg.Axes.PanInput("#area3");
   *
   * axes.connect("x", input1);
   *    .connect("x xOther", input2)
   *    .connect(["xOther", "x"], input3);
   *
   * axes.disconnect(input1); // disconnects input1
   * axes.disconnect(); // disconnects all of them
   * ```
   */
  __proto.disconnect = function (inputType) {
    if (inputType) {
      var index = this._inputs.indexOf(inputType);
      if (index >= 0) {
        this._inputs[index].disconnect();
        this._inputs.splice(index, 1);
      }
    } else {
      this._inputs.forEach(function (v) {
        return v.disconnect();
      });
      this._inputs = [];
    }
    return this;
  };
  /**
   * Returns the current position of the coordinates.
   * @ko 좌표의 현재 위치를 반환한다
   * @param {Object} [axes] The names of the axis <ko>축 이름들</ko>
   * @return {Object.<string, number>} Axis coordinate information <ko>축 좌표 정보</ko>
   * @example
   * ```js
   * const axes = new eg.Axes({
   *   "x": {
   *      range: [0, 100]
   *   },
   *   "xOther": {
   *      range: [-100, 100]
   *   },
   *    "zoom": {
   *      range: [50, 30]
   *   }
   * });
   *
   * axes.get(); // {"x": 0, "xOther": -100, "zoom": 50}
   * axes.get(["x", "zoom"]); // {"x": 0, "zoom": 50}
   * ```
   */
  __proto.get = function (axes) {
    return this.axisManager.get(axes);
  };
  /**
   * Moves an axis to specific coordinates.
   * @ko 좌표를 이동한다.
   * @param {Object.<string, number>} pos The coordinate to move to <ko>이동할 좌표</ko>
   * @param {Number} [duration=0] Duration of the animation (unit: ms) <ko>애니메이션 진행 시간(단위: ms)</ko>
   * @return {eg.Axes} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>
   * @example
   * ```js
   * const axes = new eg.Axes({
   *   "x": {
   *      range: [0, 100]
   *   },
   *   "xOther": {
   *      range: [-100, 100]
   *   },
   *    "zoom": {
   *      range: [50, 30]
   *   }
   * });
   *
   * axes.setTo({"x": 30, "zoom": 60});
   * axes.get(); // {"x": 30, "xOther": -100, "zoom": 60}
   *
   * axes.setTo({"x": 100, "xOther": 60}, 1000); // animatation
   *
   * // after 1000 ms
   * axes.get(); // {"x": 100, "xOther": 60, "zoom": 60}
   * ```
   */
  __proto.setTo = function (pos, duration) {
    if (duration === void 0) {
      duration = 0;
    }
    this.animationManager.setTo(pos, duration);
    return this;
  };
  /**
   * Moves an axis from the current coordinates to specific coordinates.
   * @ko 현재 좌표를 기준으로 좌표를 이동한다.
   * @param {Object.<string, number>} pos The coordinate to move to <ko>이동할 좌표</ko>
   * @param {Number} [duration=0] Duration of the animation (unit: ms) <ko>애니메이션 진행 시간(단위: ms)</ko>
   * @return {eg.Axes} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>
   * @example
   * ```js
   * const axes = new eg.Axes({
   *   "x": {
   *      range: [0, 100]
   *   },
   *   "xOther": {
   *      range: [-100, 100]
   *   },
   *    "zoom": {
   *      range: [50, 30]
   *   }
   * });
   *
   * axes.setBy({"x": 30, "zoom": 10});
   * axes.get(); // {"x": 30, "xOther": -100, "zoom": 60}
   *
   * axes.setBy({"x": 70, "xOther": 60}, 1000); // animatation
   *
   * // after 1000 ms
   * axes.get(); // {"x": 100, "xOther": -40, "zoom": 60}
   * ```
   */
  __proto.setBy = function (pos, duration) {
    if (duration === void 0) {
      duration = 0;
    }
    this.animationManager.setBy(pos, duration);
    return this;
  };
  /**
   * Change the options of Axes instance.
   * @ko 인스턴스의 옵션을 변경한다.
   * @param {AxesOption} options Axes options to change <ko>변경할 옵션 목록</ko>
   * @return {eg.Axes} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>
   * @example
   * ```js
   * const axes = new eg.Axes({
   *   "x": {
   *      range: [0, 100]
   *   },
   * }, {
   *   round: 10,
   * });
   *
   * axes.setTo({"x": 48});
   * axes.get(); // {"x": 50}
   *
   * axes.setOptions({
   *   round: 1,
   * });
   *
   * axes.setTo({"x": 48});
   * axes.get(); // {"x": 48}
   * ```
   */
  __proto.setOptions = function (options) {
    this.options = __assign(__assign({}, this.options), options);
    this.animationManager.setOptions(options);
    return this;
  };
  /**
   * Change the information of an existing axis.
   * @ko 존재하는 축의 정보를 변경한다.
   * @param {Object.<string, AxisOption>} axis Axis options to change <ko>변경할 축의 정보</ko>
   * @return {eg.Axes} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>
   * @example
   * ```js
   * const axes = new eg.Axes({
   *   "x": {
   *      range: [0, 100]
   *   },
   * });
   *
   * axes.setTo({"x": 150});
   * axes.get(); // {"x": 100}
   *
   * axes.setAxis({
   *   "x": {
   *      range: [0, 200]
   *   },
   * });
   *
   * axes.setTo({"x": 150});
   * axes.get(); // {"x": 150}
   * ```
   */
  __proto.setAxis = function (axis) {
    this.axisManager.setAxis(axis);
    return this;
  };
  /**
   * Stop an animation in progress.
   * @ko 재생 중인 애니메이션을 정지한다.
   * @return {eg.Axes} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>
   * @example
   * ```js
   * const axes = new eg.Axes({
   *   "x": {
   *      range: [0, 100]
   *   },
   * });
   *
   * axes.setTo({"x": 10}, 1000); // start animatation
   *
   * // after 500 ms
   * axes.stopAnimation(); // stop animation during movement.
   * ```
   */
  __proto.stopAnimation = function () {
    this.animationManager.stopAnimation();
    this.animationManager.finish(false);
    return this;
  };
  /**
   * Change the destination of an animation in progress.
   * @ko 재생 중인 애니메이션의 목적지와 진행 시간을 변경한다.
   * @param {UpdateAnimationOption} pos The coordinate to move to <ko>이동할 좌표</ko>
   * @return {eg.Axes} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>
   * @example
   * ```js
   * const axes = new eg.Axes({
   *   "x": {
   *      range: [0, 200]
   *   },
   *   "y": {
   *      range: [0, 200]
   *   }
   * });
   *
   * axes.setTo({"x": 50, "y": 50}, 1000); // trigger animation by setTo
   *
   * // after 500 ms
   * axes.updateAnimation({destPos: {"x": 100, "y": 100}}); // animation will end after 500 ms, at {"x": 100, "y": 100}
   *
   * // after 500 ms
   * axes.setTo({"x": 50, "y": 50}, 1000); // trigger animation by setTo
   *
   * // after 700 ms
   * axes.updateAnimation({destPos: {"x": 100, "y": 100}, duration: 1500, restart: true}); // this works same as axes.setTo({"x": 100, "y": 100}, 800) since restart is true.
   * ```
   */
  __proto.updateAnimation = function (options) {
    this.animationManager.updateAnimation(options);
    return this;
  };
  /**
   * Returns whether there is a coordinate in the bounce area of ​​the target axis.
   * @ko 대상 축 중 bounce영역에 좌표가 존재하는지를 반환한다
   * @param {Object} [axes] The names of the axis <ko>축 이름들</ko>
   * @return {Boolen} Whether the bounce area exists. <ko>bounce 영역 존재 여부</ko>
   * @example
   * ```js
   * const axes = new eg.Axes({
   *   "x": {
   *      range: [0, 100]
   *   },
   *   "xOther": {
   *      range: [-100, 100]
   *   },
   *    "zoom": {
   *      range: [50, 30]
   *   }
   * });
   *
   * axes.isBounceArea(["x"]);
   * axes.isBounceArea(["x", "zoom"]);
   * axes.isBounceArea();
   * ```
   */
  __proto.isBounceArea = function (axes) {
    return this.axisManager.isOutside(axes);
  };
  /**
   * Destroys properties, and events used in a module and disconnect all connections to inputTypes.
   * @ko 모듈에 사용한 속성, 이벤트를 해제한다. 모든 inputType과의 연결을 끊는다.
   */
  __proto.destroy = function () {
    this.disconnect();
    this.eventManager.destroy();
  };
  /**
   * @name VERSION
   * @desc Version info string
   * @ko 버전정보 문자열
   *
   * @constant
   * @type {String}
   * @example
   * ```js
   * eg.Axes.VERSION;  // ex) 3.3.3
   * ```
   */
  Axes.VERSION = "3.9.1";
  /* eslint-enable */
  /**
   * @name TRANSFORM
   * @desc Returns the transform attribute with CSS vendor prefixes.
   * @ko CSS vendor prefixes를 붙인 transform 속성을 반환한다.
   *
   * @constant
   * @type {String}
   * @example
   * ```js
   * eg.Axes.TRANSFORM; // "transform" or "webkitTransform"
   * ```
   */
  Axes.TRANSFORM = TRANSFORM;
  /**
   * @name DIRECTION_NONE
   * @constant
   * @type {Number}
   */
  Axes.DIRECTION_NONE = DIRECTION_NONE;
  /**
   * @name DIRECTION_LEFT
   * @constant
   * @type {Number}
   */
  Axes.DIRECTION_LEFT = DIRECTION_LEFT;
  /**
   * @name DIRECTION_RIGHT
   * @constant
   * @type {Number}
   */
  Axes.DIRECTION_RIGHT = DIRECTION_RIGHT;
  /**
   * @name DIRECTION_UP
   * @constant
   * @type {Number}
   */
  Axes.DIRECTION_UP = DIRECTION_UP;
  /**
   * @name DIRECTION_DOWN
   * @constant
   * @type {Number}
   */
  Axes.DIRECTION_DOWN = DIRECTION_DOWN;
  /**
   * @name DIRECTION_HORIZONTAL
   * @constant
   * @type {Number}
   */
  Axes.DIRECTION_HORIZONTAL = DIRECTION_HORIZONTAL;
  /**
   * @name DIRECTION_VERTICAL
   * @constant
   * @type {Number}
   */
  Axes.DIRECTION_VERTICAL = DIRECTION_VERTICAL;
  /**
   * @name DIRECTION_ALL
   * @constant
   * @type {Number}
   */
  Axes.DIRECTION_ALL = DIRECTION_ALL;
  __decorate([Computed], Axes.prototype, "holding", null);
  Axes = __decorate([ReactiveSubscribe], Axes);
  return Axes;
}(Component);

/*
 * Copyright (c) 2015 NAVER Corp.
 * egjs projects are licensed under the MIT license
 */
// get user's direction
var getDirectionByAngle = function (angle, thresholdAngle) {
  if (thresholdAngle < 0 || thresholdAngle > 90) {
    return DIRECTION_NONE;
  }
  var toAngle = Math.abs(angle);
  return toAngle > thresholdAngle && toAngle < 180 - thresholdAngle ? DIRECTION_VERTICAL : DIRECTION_HORIZONTAL;
};
/**
 * @typedef {Object} PanInputOption The option object of the eg.Axes.PanInput module.
 * @ko eg.Axes.PanInput 모듈의 옵션 객체
 * @param {String[]} [inputType=["touch", "mouse", "pointer"]] Types of input devices
 * - touch: Touch screen
 * - mouse: Mouse
 * - pointer: Mouse and touch <ko>입력 장치 종류
 * - touch: 터치 입력 장치
 * - mouse: 마우스
 * - pointer: 마우스 및 터치</ko>
 * @param {String[]} [inputKey=["any"]] List of key combinations to allow input
 * - any: any key
 * - shift: shift key
 * - ctrl: ctrl key and pinch gesture on the trackpad
 * - alt: alt key
 * - meta: meta key
 * - none: none of these keys are pressed <ko>입력을 허용할 키 조합 목록
 * - any: 아무 키
 * - shift: shift 키
 * - ctrl: ctrl 키 및 트랙패드의 pinch 제스쳐
 * - alt: alt 키
 * - meta: meta 키
 * - none: 아무 키도 눌리지 않은 상태 </ko>
 * @param {String[]} [inputButton=["left"]] List of buttons to allow input
 * - left: Left mouse button and normal touch
 * - middle: Mouse wheel press
 * - right: Right mouse button <ko>입력을 허용할 버튼 목록
 * - left: 마우스 왼쪽 버튼
 * - middle: 마우스 휠 눌림
 * - right: 마우스 오른쪽 버튼 </ko>
 * @param {Number[]} [scale] Coordinate scale that a user can move<ko>사용자의 동작으로 이동하는 좌표의 배율</ko>
 * @param {Number} [scale[0]=1] horizontal axis scale <ko>수평축 배율</ko>
 * @param {Number} [scale[1]=1] vertical axis scale <ko>수직축 배율</ko>
 * @param {Number} [thresholdAngle=45] The threshold value that determines whether user action is horizontal or vertical (0~90) <ko>사용자의 동작이 가로 방향인지 세로 방향인지 판단하는 기준 각도(0~90)</ko>
 * @param {Number} [threshold=0] Minimal pan distance required before recognizing <ko>사용자의 Pan 동작을 인식하기 위해산 최소한의 거리</ko>
 * @param {Boolean} [preventClickOnDrag=false] Whether to cancel the {@link https://developer.mozilla.org/en/docs/Web/API/Element/click_event click} event when the user finishes dragging more than 1 pixel <ko>사용자가 1픽셀 이상 드래그를 마쳤을 때 {@link https://developer.mozilla.org/ko/docs/Web/API/Element/click_event click} 이벤트 취소 여부</ko>
 * @param {Boolean} [preventDefaultOnDrag=false] Whether to use the {@link https://developer.mozilla.org/ko/docs/Web/API/Event/preventDefault preventDefault} when the user starts dragging <ko>사용자가 드래그를 시작할 때 {@link https://developer.mozilla.org/ko/docs/Web/API/Event/preventDefault preventDefault} 실행 여부</ko>
 * @param {Number} [iOSEdgeSwipeThreshold=30] Area (px) that can go to the next page when swiping the right edge in iOS safari <ko>iOS Safari에서 오른쪽 엣지를 스와이프 하는 경우 다음 페이지로 넘어갈 수 있는 영역(px)</ko>
 * @param {String} [touchAction=null] Value that overrides the element's "touch-action" css property. If set to null, it is automatically set to prevent scrolling in the direction of the connected axis. <ko>엘리먼트의 "touch-action" CSS 속성을 덮어쓰는 값. 만약 null로 설정된 경우, 연결된 축 방향으로의 스크롤을 방지하게끔 자동으로 설정된다.</ko>
 **/
/**
 * A module that passes the amount of change to eg.Axes when the mouse or touchscreen is down and moved. use less than two axes.
 * @ko 마우스나 터치 스크린을 누르고 움직일때의 변화량을 eg.Axes에 전달하는 모듈. 두개 이하의 축을 사용한다.
 *
 * @example
 * ```js
 * const pan = new eg.Axes.PanInput("#area", {
 *     inputType: ["touch"],
 *     scale: [1, 1.3],
 * });
 *
 * // Connect the 'something2' axis to the mouse or touchscreen x position when the mouse or touchscreen is down and moved.
 * // Connect the 'somethingN' axis to the mouse or touchscreen y position when the mouse or touchscreen is down and moved.
 * axes.connect(["something2", "somethingN"], pan); // or axes.connect("something2 somethingN", pan);
 *
 * // Connect only one 'something1' axis to the mouse or touchscreen x position when the mouse or touchscreen is down and moved.
 * axes.connect(["something1"], pan); // or axes.connect("something1", pan);
 *
 * // Connect only one 'something2' axis to the mouse or touchscreen y position when the mouse or touchscreen is down and moved.
 * axes.connect(["", "something2"], pan); // or axes.connect(" something2", pan);
 * ```
 * @param {String|HTMLElement|Ref<HTMLElement>|jQuery} element An element to use the eg.Axes.PanInput module <ko>eg.Axes.PanInput 모듈을 사용할 엘리먼트</ko>
 * @param {PanInputOption} [options={}] The option object of the eg.Axes.PanInput module<ko>eg.Axes.PanInput 모듈의 옵션 객체</ko>
 */
var PanInput = /*#__PURE__*/function () {
  /**
   *
   */
  function PanInput(el, options) {
    var _this = this;
    this.axes = [];
    this.element = null;
    this._enabled = false;
    this._activeEvent = null;
    this._atRightEdge = false;
    this._rightEdgeTimer = 0;
    this._dragged = false;
    this._isOverThreshold = false;
    this._preventClickWhenDragged = function (e) {
      if (_this._dragged) {
        e.preventDefault();
        e.stopPropagation();
      }
      _this._dragged = false;
    };
    this._voidFunction = function () {};
    this.element = $$1(el);
    this.options = __assign({
      inputType: ["touch", "mouse", "pointer"],
      inputKey: [ANY],
      inputButton: [MOUSE_LEFT],
      scale: [1, 1],
      thresholdAngle: 45,
      threshold: 0,
      preventClickOnDrag: false,
      preventDefaultOnDrag: false,
      iOSEdgeSwipeThreshold: IOS_EDGE_THRESHOLD,
      releaseOnScroll: false,
      touchAction: null
    }, options);
    this._onPanstart = this._onPanstart.bind(this);
    this._onPanmove = this._onPanmove.bind(this);
    this._onPanend = this._onPanend.bind(this);
  }
  var __proto = PanInput.prototype;
  __proto.mapAxes = function (axes) {
    this._direction = getDirection(!!axes[0], !!axes[1]);
    this.axes = axes;
  };
  __proto.connect = function (observer) {
    if (this._activeEvent) {
      this._detachElementEvent();
      this._detachWindowEvent(this._activeEvent);
    }
    this._attachElementEvent(observer);
    return this;
  };
  __proto.disconnect = function () {
    this._detachElementEvent();
    this._detachWindowEvent(this._activeEvent);
    this._direction = DIRECTION_NONE;
    return this;
  };
  /**
   * Destroys elements, properties, and events used in a module.
   * @ko 모듈에 사용한 엘리먼트와 속성, 이벤트를 해제한다.
   */
  __proto.destroy = function () {
    this.disconnect();
    this.element = null;
  };
  /**
   * Enables input devices
   * @ko 입력 장치를 사용할 수 있게 한다
   * @return {PanInput} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>
   */
  __proto.enable = function () {
    if (!this._enabled) {
      this._enabled = true;
      this._originalCssProps = setCssProps(this.element, this.options, this._direction);
    }
    return this;
  };
  /**
   * Disables input devices
   * @ko 입력 장치를 사용할 수 없게 한다.
   * @return {PanInput} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>
   */
  __proto.disable = function () {
    if (this._enabled) {
      this._enabled = false;
      if (!isCssPropsFromAxes(this._originalCssProps)) {
        revertCssProps(this.element, this._originalCssProps);
      }
    }
    return this;
  };
  /**
   * Returns whether to use an input device
   * @ko 입력 장치 사용 여부를 반환한다.
   * @return {Boolean} Whether to use an input device <ko>입력장치 사용여부</ko>
   */
  __proto.isEnabled = function () {
    return this._enabled;
  };
  /**
   * Releases current user input.
   * @ko 사용자의 입력을 강제로 중단시킨다.
   * @return {PanInput} An instance of a module itself <ko>모듈 자신의 인스턴스</ko>
   */
  __proto.release = function () {
    var activeEvent = this._activeEvent;
    var prevEvent = activeEvent.prevEvent;
    activeEvent.onRelease();
    this._observer.release(this, prevEvent, [0, 0]);
    this._detachWindowEvent(activeEvent);
    return this;
  };
  __proto._onPanstart = function (event) {
    var _a = this.options,
      inputKey = _a.inputKey,
      inputButton = _a.inputButton,
      preventDefaultOnDrag = _a.preventDefaultOnDrag;
    var activeEvent = this._activeEvent;
    var panEvent = activeEvent.onEventStart(event, inputKey, inputButton);
    if (!panEvent || !this._enabled || activeEvent.getTouches(event, inputButton) > 1) {
      return;
    }
    if (panEvent.srcEvent.cancelable !== false) {
      var edgeThreshold = this.options.iOSEdgeSwipeThreshold;
      this._dragged = false;
      this._isOverThreshold = false;
      this._observer.hold(this, panEvent);
      this._atRightEdge = IS_IOS_SAFARI && panEvent.center.x > window.innerWidth - edgeThreshold;
      this._attachWindowEvent(activeEvent);
      preventDefaultOnDrag && panEvent.srcEvent.type !== "touchstart" && panEvent.srcEvent.preventDefault();
      activeEvent.prevEvent = panEvent;
    }
  };
  __proto._onPanmove = function (event) {
    var _this = this;
    var _a = this.options,
      iOSEdgeSwipeThreshold = _a.iOSEdgeSwipeThreshold,
      preventClickOnDrag = _a.preventClickOnDrag,
      releaseOnScroll = _a.releaseOnScroll,
      inputKey = _a.inputKey,
      inputButton = _a.inputButton,
      threshold = _a.threshold,
      thresholdAngle = _a.thresholdAngle;
    var activeEvent = this._activeEvent;
    var panEvent = activeEvent.onEventMove(event, inputKey, inputButton);
    var touches = activeEvent.getTouches(event, inputButton);
    if (touches === 0 || releaseOnScroll && panEvent && !panEvent.srcEvent.cancelable) {
      this._onPanend(event);
      return;
    }
    if (!panEvent || !this._enabled || touches > 1) {
      return;
    }
    var userDirection = getDirectionByAngle(panEvent.angle, thresholdAngle);
    var useHorizontal = useDirection(DIRECTION_HORIZONTAL, this._direction, userDirection);
    var useVertical = useDirection(DIRECTION_VERTICAL, this._direction, userDirection);
    if (activeEvent.prevEvent && IS_IOS_SAFARI) {
      var swipeLeftToRight = panEvent.center.x < 0;
      if (swipeLeftToRight) {
        // iOS swipe left => right
        this.release();
        return;
      } else if (this._atRightEdge) {
        clearTimeout(this._rightEdgeTimer);
        // - is right to left
        var swipeRightToLeft = panEvent.deltaX < -iOSEdgeSwipeThreshold;
        if (swipeRightToLeft) {
          this._atRightEdge = false;
        } else {
          // iOS swipe right => left
          this._rightEdgeTimer = window.setTimeout(function () {
            return _this.release();
          }, 100);
        }
      }
    }
    var distance = this._getDistance([panEvent.deltaX, panEvent.deltaY], [useHorizontal, useVertical]);
    var offset = this._getOffset([panEvent.offsetX, panEvent.offsetY], [useHorizontal, useVertical]);
    var prevent = offset.some(function (v) {
      return v !== 0;
    });
    if (prevent) {
      if (panEvent.srcEvent.cancelable !== false) {
        panEvent.srcEvent.preventDefault();
      }
      panEvent.srcEvent.stopPropagation();
    }
    panEvent.preventSystemEvent = prevent;
    if (prevent && (this._isOverThreshold || distance >= threshold)) {
      this._dragged = preventClickOnDrag;
      this._isOverThreshold = true;
      this._observer.change(this, panEvent, toAxis(this.axes, offset));
    }
    activeEvent.prevEvent = panEvent;
  };
  __proto._onPanend = function (event) {
    var inputButton = this.options.inputButton;
    var activeEvent = this._activeEvent;
    activeEvent.onEventEnd(event);
    if (!this._enabled || activeEvent.getTouches(event, inputButton) !== 0) {
      return;
    }
    this._detachWindowEvent(activeEvent);
    clearTimeout(this._rightEdgeTimer);
    var prevEvent = activeEvent.prevEvent;
    var velocity = this._isOverThreshold ? this._getOffset([Math.abs(prevEvent.velocityX) * (prevEvent.offsetX < 0 ? -1 : 1), Math.abs(prevEvent.velocityY) * (prevEvent.offsetY < 0 ? -1 : 1)], [useDirection(DIRECTION_HORIZONTAL, this._direction), useDirection(DIRECTION_VERTICAL, this._direction)]) : [0, 0];
    activeEvent.onRelease();
    this._observer.release(this, prevEvent, velocity);
  };
  __proto._attachWindowEvent = function (activeEvent) {
    var _this = this;
    activeEvent === null || activeEvent === void 0 ? void 0 : activeEvent.move.forEach(function (event) {
      window.addEventListener(event, _this._onPanmove, getAddEventOptions(event));
    });
    activeEvent === null || activeEvent === void 0 ? void 0 : activeEvent.end.forEach(function (event) {
      window.addEventListener(event, _this._onPanend, getAddEventOptions(event));
    });
  };
  __proto._detachWindowEvent = function (activeEvent) {
    var _this = this;
    activeEvent === null || activeEvent === void 0 ? void 0 : activeEvent.move.forEach(function (event) {
      window.removeEventListener(event, _this._onPanmove);
    });
    activeEvent === null || activeEvent === void 0 ? void 0 : activeEvent.end.forEach(function (event) {
      window.removeEventListener(event, _this._onPanend);
    });
  };
  __proto._getOffset = function (properties, direction) {
    var scale = this.options.scale;
    return [direction[0] ? properties[0] * scale[0] : 0, direction[1] ? properties[1] * scale[1] : 0];
  };
  __proto._getDistance = function (delta, direction) {
    return Math.sqrt(Number(direction[0]) * Math.pow(delta[0], 2) + Number(direction[1]) * Math.pow(delta[1], 2));
  };
  __proto._attachElementEvent = function (observer) {
    var _this = this;
    var activeEvent = convertInputType(this.options.inputType);
    var element = this.element;
    if (!activeEvent) {
      return;
    }
    if (!element) {
      throw new Error("Element to connect input does not exist.");
    }
    this._observer = observer;
    this.enable();
    this._activeEvent = activeEvent;
    element.addEventListener("click", this._preventClickWhenDragged, true);
    activeEvent.start.forEach(function (event) {
      element.addEventListener(event, _this._onPanstart);
    });
    // adding event listener to element prevents invalid behavior in iOS Safari
    activeEvent.move.forEach(function (event) {
      element.addEventListener(event, _this._voidFunction);
    });
  };
  __proto._detachElementEvent = function () {
    var _this = this;
    var activeEvent = this._activeEvent;
    var element = this.element;
    if (element) {
      element.removeEventListener("click", this._preventClickWhenDragged, true);
      activeEvent === null || activeEvent === void 0 ? void 0 : activeEvent.start.forEach(function (event) {
        element.removeEventListener(event, _this._onPanstart);
      });
      activeEvent === null || activeEvent === void 0 ? void 0 : activeEvent.move.forEach(function (event) {
        element.removeEventListener(event, _this._voidFunction);
      });
    }
    this.disable();
    this._observer = null;
  };
  return PanInput;
}();

/*
Copyright (c) 2020-present NAVER Corp.
name: @egjs/imready
license: MIT
author: NAVER Corp.
repository: https://github.com/naver/egjs-imready
version: 1.3.1
*/

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

/* global Reflect, Promise */
var extendStatics$2 = function (d, b) {
  extendStatics$2 = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
  };

  return extendStatics$2(d, b);
};

function __extends$2(d, b) {
  extendStatics$2(d, b);

  function __() {
    this.constructor = d;
  }

  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign$1 = function () {
  __assign$1 = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign$1.apply(this, arguments);
};
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;

  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];

  return r;
}

/*
egjs-imready
Copyright (c) 2020-present NAVER Corp.
MIT license
*/
var isWindow = typeof window !== "undefined";
var ua = isWindow ? window.navigator.userAgent : "";
var SUPPORT_COMPUTEDSTYLE = isWindow ? !!("getComputedStyle" in window) : false;
var IS_IE = /MSIE|Trident|Windows Phone|Edge/.test(ua);
var SUPPORT_ADDEVENTLISTENER = isWindow ? !!("addEventListener" in document) : false;
var WIDTH = "width";
var HEIGHT = "height";

function getAttribute(el, name) {
  return el.getAttribute(name) || "";
}
function toArray$1(arr) {
  return [].slice.call(arr);
}
function hasSizeAttribute(target, prefix) {
  if (prefix === void 0) {
    prefix = "data-";
  }

  return !!target.getAttribute(prefix + "width");
}
function hasLoadingAttribute(target, prefix) {
  if (prefix === void 0) {
    prefix = "data-";
  }

  return "loading" in target && target.getAttribute("loading") === "lazy" || !!target.getAttribute(prefix + "lazy");
}
function hasSkipAttribute(target, prefix) {
  if (prefix === void 0) {
    prefix = "data-";
  }

  return !!target.getAttribute(prefix + "skip");
}
function addEvent(element, type, handler) {
  if (SUPPORT_ADDEVENTLISTENER) {
    element.addEventListener(type, handler, false);
  } else if (element.attachEvent) {
    element.attachEvent("on" + type, handler);
  } else {
    element["on" + type] = handler;
  }
}
function removeEvent(element, type, handler) {
  if (element.removeEventListener) {
    element.removeEventListener(type, handler, false);
  } else if (element.detachEvent) {
    element.detachEvent("on" + type, handler);
  } else {
    element["on" + type] = null;
  }
}
function innerWidth(el) {
  return getSize(el, "Width");
}
function innerHeight(el) {
  return getSize(el, "Height");
}
function getStyles(el) {
  return (SUPPORT_COMPUTEDSTYLE ? window.getComputedStyle(el) : el.currentStyle) || {};
}

function getSize(el, name) {
  var size = el["client" + name] || el["offset" + name];
  return parseFloat(size || getStyles(el)[name.toLowerCase()]) || 0;
}

function getContentElements(element, tags, prefix) {
  var skipElements = toArray$1(element.querySelectorAll(__spreadArrays(["[" + prefix + "skip] [" + prefix + "width]"], tags.map(function (tag) {
    return ["[" + prefix + "skip] " + tag, tag + "[" + prefix + "skip]", "[" + prefix + "width] " + tag].join(", ");
  })).join(", ")));
  return toArray$1(element.querySelectorAll("[" + prefix + "width], " + tags.join(", "))).filter(function (el) {
    return skipElements.indexOf(el) === -1;
  });
}

/*
egjs-imready
Copyright (c) 2020-present NAVER Corp.
MIT license
*/
var elements = [];
function addAutoSizer(element, prefix) {
  !elements.length && addEvent(window, "resize", resizeAllAutoSizers);
  element.__PREFIX__ = prefix;
  elements.push(element);
  resize(element);
}
function removeAutoSizer(element, prefix) {
  var index = elements.indexOf(element);

  if (index < 0) {
    return;
  }

  var fixed = getAttribute(element, prefix + "fixed");
  delete element.__PREFIX__;
  element.style[fixed === HEIGHT ? WIDTH : HEIGHT] = "";
  elements.splice(index, 1);
  !elements.length && removeEvent(window, "resize", resizeAllAutoSizers);
}

function resize(element, prefix) {
  if (prefix === void 0) {
    prefix = "data-";
  }

  var elementPrefix = element.__PREFIX__ || prefix;
  var dataWidth = parseInt(getAttribute(element, "" + elementPrefix + WIDTH), 10) || 0;
  var dataHeight = parseInt(getAttribute(element, "" + elementPrefix + HEIGHT), 10) || 0;
  var fixed = getAttribute(element, elementPrefix + "fixed");

  if (fixed === HEIGHT) {
    var size = innerHeight(element) || dataHeight;
    element.style[WIDTH] = dataWidth / dataHeight * size + "px";
  } else {
    var size = innerWidth(element) || dataWidth;
    element.style[HEIGHT] = dataHeight / dataWidth * size + "px";
  }
}

function resizeAllAutoSizers() {
  elements.forEach(function (element) {
    resize(element);
  });
}

var Loader =
/*#__PURE__*/
function (_super) {
  __extends$2(Loader, _super);

  function Loader(element, options) {
    if (options === void 0) {
      options = {};
    }

    var _this = _super.call(this) || this;

    _this.isReady = false;
    _this.isPreReady = false;
    _this.hasDataSize = false;
    _this.hasLoading = false;
    _this.isSkip = false;

    _this.onCheck = function (e) {
      _this.clear();

      if (e && e.type === "error") {
        _this.onError(_this.element);
      }

      if (_this.hasLoading && _this.checkElement()) {
        // I'm not ready
        return;
      } // I'm pre-ready and ready!


      var withPreReady = !_this.hasDataSize && !_this.hasLoading;

      _this.onReady(withPreReady);
    };

    _this.options = __assign$1({
      prefix: "data-"
    }, options);
    _this.element = element;
    var prefix = _this.options.prefix;
    _this.hasDataSize = hasSizeAttribute(element, prefix);
    _this.isSkip = hasSkipAttribute(element, prefix);
    _this.hasLoading = hasLoadingAttribute(element, prefix);
    return _this;
  }

  var __proto = Loader.prototype;

  __proto.check = function () {
    if (this.isSkip || !this.checkElement()) {
      // I'm Ready
      this.onAlreadyReady(true);
      return false;
    }

    if (this.hasDataSize) {
      addAutoSizer(this.element, this.options.prefix);
    }

    if (this.hasDataSize || this.hasLoading) {
      // I'm Pre Ready
      this.onAlreadyPreReady();
    } // Wati Pre Ready, Ready


    return true;
  };

  __proto.addEvents = function () {
    var _this = this;

    var element = this.element;
    this.constructor.EVENTS.forEach(function (name) {
      addEvent(element, name, _this.onCheck);
    });
  };

  __proto.clear = function () {
    var _this = this;

    var element = this.element;
    this.constructor.EVENTS.forEach(function (name) {
      removeEvent(element, name, _this.onCheck);
    });
    this.removeAutoSizer();
  };

  __proto.destroy = function () {
    this.clear();
    this.off();
  };

  __proto.removeAutoSizer = function () {
    if (this.hasDataSize) {
      // I'm already ready.
      var prefix = this.options.prefix;
      removeAutoSizer(this.element, prefix);
    }
  };

  __proto.onError = function (target) {
    this.trigger("error", {
      element: this.element,
      target: target
    });
  };

  __proto.onPreReady = function () {
    if (this.isPreReady) {
      return;
    }

    this.isPreReady = true;
    this.trigger("preReady", {
      element: this.element,
      hasLoading: this.hasLoading,
      isSkip: this.isSkip
    });
  };

  __proto.onReady = function (withPreReady) {
    if (this.isReady) {
      return;
    }

    withPreReady = !this.isPreReady && withPreReady;

    if (withPreReady) {
      this.isPreReady = true;
    }

    this.removeAutoSizer();
    this.isReady = true;
    this.trigger("ready", {
      element: this.element,
      withPreReady: withPreReady,
      hasLoading: this.hasLoading,
      isSkip: this.isSkip
    });
  };

  __proto.onAlreadyError = function (target) {
    var _this = this;

    setTimeout(function () {
      _this.onError(target);
    });
  };

  __proto.onAlreadyPreReady = function () {
    var _this = this;

    setTimeout(function () {
      _this.onPreReady();
    });
  };

  __proto.onAlreadyReady = function (withPreReady) {
    var _this = this;

    setTimeout(function () {
      _this.onReady(withPreReady);
    });
  };

  Loader.EVENTS = [];
  return Loader;
}(Component);

var ElementLoader =
/*#__PURE__*/
function (_super) {
  __extends$2(ElementLoader, _super);

  function ElementLoader() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  var __proto = ElementLoader.prototype;

  __proto.setHasLoading = function (hasLoading) {
    this.hasLoading = hasLoading;
  };

  __proto.check = function () {
    if (this.isSkip) {
      // I'm Ready
      this.onAlreadyReady(true);
      return false;
    }

    if (this.hasDataSize) {
      addAutoSizer(this.element, this.options.prefix);
      this.onAlreadyPreReady();
    } else {
      // has not data size
      this.trigger("requestChildren");
    }

    return true;
  };

  __proto.checkElement = function () {
    return true;
  };

  __proto.destroy = function () {
    this.clear();
    this.trigger("requestDestroy");
    this.off();
  };

  __proto.onAlreadyPreReady = function () {
    // has data size
    _super.prototype.onAlreadyPreReady.call(this);

    this.trigger("reqeustReadyChildren");
  };

  ElementLoader.EVENTS = [];
  return ElementLoader;
}(Loader);

/**
 * @alias eg.ImReady
 * @extends eg.Component
 */

var ImReadyManager =
/*#__PURE__*/
function (_super) {
  __extends$2(ImReadyManager, _super);
  /**
   * @param - ImReady's options
   */


  function ImReadyManager(options) {
    if (options === void 0) {
      options = {};
    }

    var _this = _super.call(this) || this;

    _this.readyCount = 0;
    _this.preReadyCount = 0;
    _this.totalCount = 0;
    _this.totalErrorCount = 0;
    _this.isPreReadyOver = true;
    _this.elementInfos = [];
    _this.options = __assign$1({
      loaders: {},
      prefix: "data-"
    }, options);
    return _this;
  }
  /**
   * Checks whether elements are in the ready state.
   * @ko 엘리먼트가 준비 상태인지 체크한다.
   * @elements - Elements to check ready status. <ko> 준비 상태를 체크할 엘리먼트들.</ko>
   * @example
     * ```html
     * <div>
     *    <img src="./1.jpg" data-width="1280" data-height="853" style="width:100%"/>
     *    <img src="./2.jpg" data-width="1280" data-height="853"/>
     *    <img src="ERR" data-width="1280" data-height="853"/>
     * </div>
     * ```
     * ## Javascript
     * ```js
     * import ImReady from "@egjs/imready";
     *
     * const im = new ImReady(); // umd: eg.ImReady
     * im.check(document.querySelectorAll("img")).on({
     *   preReadyElement: e => {
     *     // 1, 3
     *     // 2, 3
     *     // 3, 3
     *     console.log(e.preReadyCount, e.totalCount),
     *   },
     * });
     * ```
   */


  var __proto = ImReadyManager.prototype;

  __proto.check = function (elements) {
    var _this = this;

    var prefix = this.options.prefix;
    this.clear();
    this.elementInfos = toArray$1(elements).map(function (element, index) {
      var loader = _this.getLoader(element, {
        prefix: prefix
      });

      loader.check();
      loader.on("error", function (e) {
        _this.onError(index, e.target);
      }).on("preReady", function (e) {
        var info = _this.elementInfos[index];
        info.hasLoading = e.hasLoading;
        info.isSkip = e.isSkip;

        var isPreReady = _this.checkPreReady(index);

        _this.onPreReadyElement(index);

        isPreReady && _this.onPreReady();
      }).on("ready", function (_a) {
        var withPreReady = _a.withPreReady,
            hasLoading = _a.hasLoading,
            isSkip = _a.isSkip;
        var info = _this.elementInfos[index];
        info.hasLoading = hasLoading;
        info.isSkip = isSkip;

        var isPreReady = withPreReady && _this.checkPreReady(index);

        var isReady = _this.checkReady(index); // Pre-ready and ready occur simultaneously


        withPreReady && _this.onPreReadyElement(index);

        _this.onReadyElement(index);

        isPreReady && _this.onPreReady();
        isReady && _this.onReady();
      });
      return {
        loader: loader,
        element: element,
        hasLoading: false,
        hasError: false,
        isPreReady: false,
        isReady: false,
        isSkip: false
      };
    });
    var length = this.elementInfos.length;
    this.totalCount = length;

    if (!length) {
      setTimeout(function () {
        _this.onPreReady();

        _this.onReady();
      });
    }

    return this;
  };
  /**
   * Gets the total count of elements to be checked.
   * @ko 체크하는 element의 총 개수를 가져온다.
   */


  __proto.getTotalCount = function () {
    return this.totalCount;
  };
  /**
   * Whether the elements are all pre-ready. (all sizes are known)
   * @ko 엘리먼트들이 모두 사전 준비가 됐는지 (사이즈를 전부 알 수 있는지) 여부.
   */


  __proto.isPreReady = function () {
    return this.elementInfos.every(function (info) {
      return info.isPreReady;
    });
  };
  /**
   * Whether the elements are all ready.
   * @ko 엘리먼트들이 모두 준비가 됐는지 여부.
   */


  __proto.isReady = function () {
    return this.elementInfos.every(function (info) {
      return info.isReady;
    });
  };
  /**
   * Whether an error has occurred in the elements in the current state.
   * @ko 현재 상태에서 엘리먼트들이 에러가 발생했는지 여부.
   */


  __proto.hasError = function () {
    return this.totalErrorCount > 0;
  };
  /**
   * Clears events of elements being checked.
   * @ko 체크 중인 엘리먼트들의 이벤트를 해제 한다.
   */


  __proto.clear = function () {
    this.isPreReadyOver = false;
    this.totalCount = 0;
    this.preReadyCount = 0;
    this.readyCount = 0;
    this.totalErrorCount = 0;
    this.elementInfos.forEach(function (info) {
      if (info.loader) {
        info.loader.destroy();
      }
    });
    this.elementInfos = [];
  };
  /**
   * Destory all events.
   * @ko 모든 이벤트를 해제 한다.
   */


  __proto.destroy = function () {
    this.clear();
    this.off();
  };

  __proto.getLoader = function (element, options) {
    var _this = this;

    var tagName = element.tagName.toLowerCase();
    var loaders = this.options.loaders;
    var prefix = options.prefix;
    var tags = Object.keys(loaders);

    if (loaders[tagName]) {
      return new loaders[tagName](element, options);
    }

    var loader = new ElementLoader(element, options);
    var children = toArray$1(element.querySelectorAll(tags.join(", ")));
    loader.setHasLoading(children.some(function (el) {
      return hasLoadingAttribute(el, prefix);
    }));
    var withPreReady = false;
    var childrenImReady = this.clone().on("error", function (e) {
      loader.onError(e.target);
    }).on("ready", function () {
      loader.onReady(withPreReady);
    });
    loader.on("requestChildren", function () {
      // has not data size
      var contentElements = getContentElements(element, tags, _this.options.prefix);
      childrenImReady.check(contentElements).on("preReady", function (e) {
        withPreReady = e.isReady;

        if (!withPreReady) {
          loader.onPreReady();
        }
      });
    }).on("reqeustReadyChildren", function () {
      // has data size
      // loader call preReady
      // check only video, image elements
      childrenImReady.check(children);
    }).on("requestDestroy", function () {
      childrenImReady.destroy();
    });
    return loader;
  };

  __proto.clone = function () {
    return new ImReadyManager(__assign$1({}, this.options));
  };

  __proto.checkPreReady = function (index) {
    this.elementInfos[index].isPreReady = true;
    ++this.preReadyCount;

    if (this.preReadyCount < this.totalCount) {
      return false;
    }

    return true;
  };

  __proto.checkReady = function (index) {
    this.elementInfos[index].isReady = true;
    ++this.readyCount;

    if (this.readyCount < this.totalCount) {
      return false;
    }

    return true;
  };

  __proto.onError = function (index, target) {
    var info = this.elementInfos[index];
    info.hasError = true;
    /**
     * An event occurs if the image, video fails to load.
     * @ko 이미지, 비디오가 로딩에 실패하면 이벤트가 발생한다.
     * @event eg.ImReady#error
     * @param {eg.ImReady.OnError} e - The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>
     * @example
     * ```html
     * <div>
     *    <img src="./1.jpg" data-width="1280" data-height="853" style="width:100%"/>
     *    <img src="./2.jpg"/>
     *    <img src="ERR"/>
     * </div>
     * ```
     * ## Javascript
     * ```js
     * import ImReady from "@egjs/imready";
     *
     * const im = new ImReady(); // umd: eg.ImReady
     * im.check([document.querySelector("div")]).on({
     *   error: e => {
     *     // <div>...</div>, 0, <img src="ERR"/>
     *     console.log(e.element, e.index, e.target),
     *   },
     * });
     * ```
     */

    this.trigger(new ComponentEvent$1("error", {
      element: info.element,
      index: index,
      target: target,
      errorCount: this.getErrorCount(),
      totalErrorCount: ++this.totalErrorCount
    }));
  };

  __proto.onPreReadyElement = function (index) {
    var info = this.elementInfos[index];
    /**
     * An event occurs when the element is pre-ready (when the loading attribute is applied or the size is known)
     * @ko 해당 엘리먼트가 사전 준비되었을 때(loading 속성이 적용되었거나 사이즈를 알 수 있을 때) 이벤트가 발생한다.
     * @event eg.ImReady#preReadyElement
     * @param {eg.ImReady.OnPreReadyElement} e - The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>
     * @example
     * ```html
     * <div>
     *    <img src="./1.jpg" data-width="1280" data-height="853" style="width:100%"/>
     *    <img src="./2.jpg" data-width="1280" data-height="853"/>
     *    <img src="ERR" data-width="1280" data-height="853"/>
     * </div>
     * ```
     * ## Javascript
     * ```js
     * import ImReady from "@egjs/imready";
     *
     * const im = new ImReady(); // umd: eg.ImReady
     * im.check(document.querySelectorAll("img")).on({
     *   preReadyElement: e => {
     *     // 1, 3
     *     // 2, 3
     *     // 3, 3
     *     console.log(e.preReadyCount, e.totalCount),
     *   },
     * });
     * ```
     */

    this.trigger(new ComponentEvent$1("preReadyElement", {
      element: info.element,
      index: index,
      preReadyCount: this.preReadyCount,
      readyCount: this.readyCount,
      totalCount: this.totalCount,
      isPreReady: this.isPreReady(),
      isReady: this.isReady(),
      hasLoading: info.hasLoading,
      isSkip: info.isSkip
    }));
  };

  __proto.onPreReady = function () {
    this.isPreReadyOver = true;
    /**
     * An event occurs when all element are pre-ready (When all elements have the loading attribute applied or the size is known)
     * @ko 모든 엘리먼트들이 사전 준비된 경우 (모든 엘리먼트들이 loading 속성이 적용되었거나 사이즈를 알 수 있는 경우) 이벤트가 발생한다.
     * @event eg.ImReady#preReady
     * @param {eg.ImReady.OnPreReady} e - The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>
     * @example
     * ```html
     * <div>
     *    <img src="./1.jpg" data-width="1280" data-height="853" style="width:100%"/>
     *    <img src="./2.jpg" data-width="1280" data-height="853"/>
     *    <img src="ERR" data-width="1280" data-height="853"/>
     * </div>
     * ```
     * ## Javascript
     * ```js
     * import ImReady from "@egjs/imready";
     *
     * const im = new ImReady(); // umd: eg.ImReady
     * im.check(document.querySelectorAll("img")).on({
     *   preReady: e => {
     *     // 0, 3
     *     console.log(e.readyCount, e.totalCount),
     *   },
     * });
     * ```
     */

    this.trigger(new ComponentEvent$1("preReady", {
      readyCount: this.readyCount,
      totalCount: this.totalCount,
      isReady: this.isReady(),
      hasLoading: this.hasLoading()
    }));
  };

  __proto.onReadyElement = function (index) {
    var info = this.elementInfos[index];
    /**
     * An event occurs when the element is ready
     * @ko 해당 엘리먼트가 준비가 되었을 때 이벤트가 발생한다.
     * @event eg.ImReady#readyElement
     * @param {eg.ImReady.OnReadyElement} e - The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>
     * @example
     * ```html
     * <div>
     *    <img src="./1.jpg" data-width="1280" data-height="853" style="width:100%"/>
     *    <img src="./2.jpg" data-width="1280" data-height="853"/>
     *    <img src="ERR" data-width="1280" data-height="853"/>
     * </div>
     * ```
     * ## Javascript
     * ```js
     * import ImReady from "@egjs/imready";
     *
     * const im = new ImReady(); // umd: eg.ImReady
     * im.check(document.querySelectorAll("img")).on({
     *   readyElement: e => {
     *     // 1, 0, false, 3
     *     // 2, 1, false, 3
     *     // 3, 2, true, 3
     *     console.log(e.readyCount, e.index, e.hasError, e.totalCount),
     *   },
     * });
     * ```
     */

    this.trigger(new ComponentEvent$1("readyElement", {
      index: index,
      element: info.element,
      hasError: info.hasError,
      errorCount: this.getErrorCount(),
      totalErrorCount: this.totalErrorCount,
      preReadyCount: this.preReadyCount,
      readyCount: this.readyCount,
      totalCount: this.totalCount,
      isPreReady: this.isPreReady(),
      isReady: this.isReady(),
      hasLoading: info.hasLoading,
      isPreReadyOver: this.isPreReadyOver,
      isSkip: info.isSkip
    }));
  };

  __proto.onReady = function () {
    /**
     * An event occurs when all element are ready
     * @ko 모든 엘리먼트들이 준비된 경우 이벤트가 발생한다.
     * @event eg.ImReady#ready
     * @param {eg.ImReady.OnReady} e - The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>
     * @example
     * ```html
     * <div>
     *    <img src="./1.jpg" data-width="1280" data-height="853" style="width:100%"/>
     *    <img src="./2.jpg" data-width="1280" data-height="853"/>
     *    <img src="ERR" data-width="1280" data-height="853"/>
     * </div>
     * ```
     * ## Javascript
     * ```js
     * import ImReady from "@egjs/imready";
     *
     * const im = new ImReady(); // umd: eg.ImReady
     * im.check(document.querySelectorAll("img")).on({
     *   preReady: e => {
     *     // 0, 3
     *     console.log(e.readyCount, e.totalCount),
     *   },
     *   ready: e => {
     *     // 1, 3
     *     console.log(e.errorCount, e.totalCount),
     *   },
     * });
     * ```
     */
    this.trigger(new ComponentEvent$1("ready", {
      errorCount: this.getErrorCount(),
      totalErrorCount: this.totalErrorCount,
      totalCount: this.totalCount
    }));
  };

  __proto.getErrorCount = function () {
    return this.elementInfos.filter(function (info) {
      return info.hasError;
    }).length;
  };

  __proto.hasLoading = function () {
    return this.elementInfos.some(function (info) {
      return info.hasLoading;
    });
  };

  return ImReadyManager;
}(Component);

var ImageLoader =
/*#__PURE__*/
function (_super) {
  __extends$2(ImageLoader, _super);

  function ImageLoader() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  var __proto = ImageLoader.prototype;

  __proto.checkElement = function () {
    var element = this.element;
    var src = element.getAttribute("src");

    if (element.complete) {
      if (src) {
        // complete
        if (!element.naturalWidth) {
          this.onAlreadyError(element);
        }

        return false;
      } else {
        // Using an external lazy loading module
        this.onAlreadyPreReady();
      }
    }

    this.addEvents();
    IS_IE && element.setAttribute("src", src);
    return true;
  };

  ImageLoader.EVENTS = ["load", "error"];
  return ImageLoader;
}(Loader);

var VideoLoader =
/*#__PURE__*/
function (_super) {
  __extends$2(VideoLoader, _super);

  function VideoLoader() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  var __proto = VideoLoader.prototype;

  __proto.checkElement = function () {
    var element = this.element; // HAVE_NOTHING: 0, no information whether or not the audio/video is ready
    // HAVE_METADATA: 1, HAVE_METADATA - metadata for the audio/video is ready
    // HAVE_CURRENT_DATA: 2, data for the current playback position is available, but not enough data to play next frame/millisecond
    // HAVE_FUTURE_DATA: 3, data for the current and at least the next frame is available
    // HAVE_ENOUGH_DATA: 4, enough data available to start playing

    if (element.readyState >= 1) {
      return false;
    }

    if (element.error) {
      this.onAlreadyError(element);
      return false;
    }

    this.addEvents();
    return true;
  };

  VideoLoader.EVENTS = ["loadedmetadata", "error"];
  return VideoLoader;
}(Loader);

var ImReady =
/*#__PURE__*/
function (_super) {
  __extends$2(ImReady, _super);

  function ImReady(options) {
    if (options === void 0) {
      options = {};
    }

    return _super.call(this, __assign$1({
      loaders: {
        img: ImageLoader,
        video: VideoLoader
      }
    }, options)) || this;
  }

  return ImReady;
}(ImReadyManager);

/*
Copyright (c) 2015-present NAVER Corp.
name: @egjs/flicking
license: MIT
author: NAVER Corp.
repository: https://github.com/naver/egjs-flicking
version: 4.11.4
*/

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol */

var extendStatics$3 = function (d, b) {
  extendStatics$3 = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
  };
  return extendStatics$3(d, b);
};
function __extends$3(d, b) {
  if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics$3(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign$2 = function () {
  __assign$2 = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign$2.apply(this, arguments);
};
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = {
      label: 0,
      sent: function () {
        if (t[0] & 1) throw t[1];
        return t[1];
      },
      trys: [],
      ops: []
    },
    f,
    y,
    t,
    g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;
  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return {
            value: op[1],
            done: false
          };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
}
function __values$1(o) {
  var s = typeof Symbol === "function" && Symbol.iterator,
    m = s && o[s],
    i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function () {
      if (o && i >= o.length) o = void 0;
      return {
        value: o && o[i++],
        done: !o
      };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read$1(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o),
    r,
    ar = [],
    e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = {
      error: error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
}

/** @deprecated */
function __spread$1() {
  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read$1(arguments[i]));
  return ar;
}
typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

/*
 * Copyright (c) 2015 NAVER Corp.
 * egjs projects are licensed under the MIT license
 */
/* eslint-disable @typescript-eslint/restrict-template-expressions */
/**
 * Error codes of {@link FlickingError}. Below are the conditions where each error code occurs.
 * @ko {@link FlickingError}의 에러 코드. 아래는 각각의 에러 코드가 발생하는 조건입니다.
 * @name ERROR_CODE
 * @constant
 * @type object
 * @property {number} WRONG_TYPE Parameter type is wrong<ko>패러미터의 타입이 잘못되었을 경우</ko>
 * @property {number} ELEMENT_NOT_FOUND Element is not found inside page with the given CSS selector<ko>주어진 CSS selector로 페이지 내에서 해당 엘리먼트를 찾지 못했을 경우</ko>
 * @property {number} VAL_MUST_NOT_NULL Expected non-null value, but given `null` or `undefined`<ko>값을 기대했으나, `null`이나 `undefined`를 받은 경우</ko>
 * @property {number} NOT_ATTACHED_TO_FLICKING When Flicking's component is not initialized (i.e. {@link Flicking#init} is not called)<ko>Flicking 내부 컴포넌트가 초기화되지 않은 경우 ({@link Flicking#init}이 호출되지 않은 경우)</ko>
 * @property {number} WRONG_OPTION One of the options is wrong<ko>옵션들 중 잘못된 값이 있을 때</ko>
 * @property {number} INDEX_OUT_OF_RANGE When the given index is out of possible range<ko>인덱스가 주어진 범위를 벗어난 경우</ko>
 * @property {number} POSITION_NOT_REACHABLE When {@link Control#moveToPosition}'s position parameter is out of possible range.<ko>{@link Control#moveToPosition}의 `position` 패러미터가 도달 가능한 범위를 벗어난 경우</ko>
 * @property {number} TRANSFORM_NOT_SUPPORTED CSS `transform` property is not available(<=IE8) <ko>CSS `transform` 속성을 사용할 수 없는 경우(<=IE8)</ko>
 * @property {number} STOP_CALLED_BY_USER When the event's `stop()` is called by user.<ko>사용자에 의해 이벤트의 `stop()`이 호출된 경우</ko>
 * @property {number} ANIMATION_INTERRUPTED When the animation is interrupted by user.<ko>사용자에 의해 애니메이션이 중단된 경우</ko>
 * @property {number} ANIMATION_ALREADY_PLAYING When the animation is already playing.<ko>현재 애니메이션이 이미 진행중인 경우</ko>
 * @property {number} NOT_ALLOWED_IN_FRAMEWORK When the non-allowed method is called from frameworks (React, Angular, Vue...)
 * <ko>프레임워크(React, Angular, Vue ...)에서 사용 불가능한 메소드를 호출했을 경우</ko>
 * @property {number} NOT_INITIALIZED When the {@link Flicking#init} is not called before but is needed<ko>{@link Flicking#init}의 호출이 필요하나, 아직 호출되지 않았을 경우</ko>
 * @property {number} NO_ACTIVE When there're no active panel that flicking has selected. This may be due to the absence of any panels<ko>현재 Flicking이 선택한 패널이 없을 경우. 일반적으로 패널이 하나도 없는 경우에 발생할 수 있습니다</ko>
 * @property {number} NOT_ALLOWED_IN_VIRTUAL When the non-allowed method is called while the virtual option is enabled<ko>virtual 옵션이 활성화된 상태에서 사용 불가능한 메소드가 호출되었을 경우</ko>
 */
var CODE = {
  WRONG_TYPE: 0,
  ELEMENT_NOT_FOUND: 1,
  VAL_MUST_NOT_NULL: 2,
  NOT_ATTACHED_TO_FLICKING: 3,
  WRONG_OPTION: 4,
  INDEX_OUT_OF_RANGE: 5,
  POSITION_NOT_REACHABLE: 6,
  TRANSFORM_NOT_SUPPORTED: 7,
  STOP_CALLED_BY_USER: 8,
  ANIMATION_INTERRUPTED: 9,
  ANIMATION_ALREADY_PLAYING: 10,
  NOT_ALLOWED_IN_FRAMEWORK: 11,
  NOT_INITIALIZED: 12,
  NO_ACTIVE: 13,
  NOT_ALLOWED_IN_VIRTUAL: 14
};
var MESSAGE = {
  WRONG_TYPE: function (wrongVal, correctTypes) {
    return wrongVal + "(" + typeof wrongVal + ") is not a " + correctTypes.map(function (type) {
      return "\"" + type + "\"";
    }).join(" or ") + ".";
  },
  ELEMENT_NOT_FOUND: function (selector) {
    return "Element with selector \"" + selector + "\" not found.";
  },
  VAL_MUST_NOT_NULL: function (val, name) {
    return name + " should be provided. Given: " + val;
  },
  NOT_ATTACHED_TO_FLICKING: "This module is not attached to the Flicking instance. \"init()\" should be called first.",
  WRONG_OPTION: function (optionName, val) {
    return "Option \"" + optionName + "\" is not in correct format, given: " + val;
  },
  INDEX_OUT_OF_RANGE: function (val, min, max) {
    return "Index \"" + val + "\" is out of range: should be between " + min + " and " + max + ".";
  },
  POSITION_NOT_REACHABLE: function (position) {
    return "Position \"" + position + "\" is not reachable.";
  },
  TRANSFORM_NOT_SUPPORTED: "Browser does not support CSS transform.",
  STOP_CALLED_BY_USER: "Event stop() is called by user.",
  ANIMATION_INTERRUPTED: "Animation is interrupted by user input.",
  ANIMATION_ALREADY_PLAYING: "Animation is already playing.",
  NOT_ALLOWED_IN_FRAMEWORK: "This behavior is not allowed in the frameworks like React, Vue, or Angular.",
  NOT_INITIALIZED: "Flicking is not initialized yet, call init() first.",
  NO_ACTIVE: "There's no active panel that Flicking has selected. This may be due to the absence of any panels.",
  NOT_ALLOWED_IN_VIRTUAL: "This behavior is not allowed when the virtual option is enabled"
};

/*
 * Copyright (c) 2015 NAVER Corp.
 * egjs projects are licensed under the MIT license
 */
/**
 * Event type object with event name strings of {@link Flicking}
 * @ko {@link Flicking}의 이벤트 이름 문자열들을 담은 객체
 * @type {object}
 * @property {"holdStart"} HOLD_START holdStart event<ko>holdStart 이벤트</ko>
 * @property {"holdEnd"} HOLD_END holdEnd event<ko>holdEnd 이벤트</ko>
 * @property {"moveStart"} MOVE_START moveStart event<ko>moveStart 이벤트</ko>
 * @property {"move"} MOVE move event<ko>move 이벤트</ko>
 * @property {"moveEnd"} MOVE_END moveEnd event<ko>moveEnd 이벤트</ko>
 * @property {"willChange"} WILL_CHANGE willChange event<ko>willChange 이벤트</ko>
 * @property {"changed"} CHANGED changed event<ko>changed 이벤트</ko>
 * @property {"willRestore"} WILL_RESTORE willRestore event<ko>willRestore 이벤트</ko>
 * @property {"restored"} RESTORED restored event<ko>restored 이벤트</ko>
 * @property {"select"} SELECT select event<ko>select 이벤트</ko>
 * @property {"needPanel"} NEED_PANEL needPanel event<ko>needPanel 이벤트</ko>
 * @property {"panelChange"} PANEL_CHANGE panelChange event<ko>panelChange 이벤트</ko>
 * @example
 * ```ts
 * import { EVENTS } from "@egjs/flicking";
 * EVENTS.MOVE_START; // "moveStart"
 * ```
 */
var EVENTS = {
  READY: "ready",
  BEFORE_RESIZE: "beforeResize",
  AFTER_RESIZE: "afterResize",
  HOLD_START: "holdStart",
  HOLD_END: "holdEnd",
  MOVE_START: "moveStart",
  MOVE: "move",
  MOVE_END: "moveEnd",
  WILL_CHANGE: "willChange",
  CHANGED: "changed",
  WILL_RESTORE: "willRestore",
  RESTORED: "restored",
  SELECT: "select",
  NEED_PANEL: "needPanel",
  VISIBLE_CHANGE: "visibleChange",
  REACH_EDGE: "reachEdge",
  PANEL_CHANGE: "panelChange"
};
/**
 * An object with all possible predefined literal string for the {@link Flicking#align align} option
 * @ko {@link Flicking#align align} 옵션에 사용되는 미리 정의된 리터럴 상수들을 담고 있는 객체
 * @type {object}
 * @property {"prev"} PREV left/top align<ko>좌/상 정렬</ko>
 * @property {"center"} CENTER center align<ko>중앙 정렬</ko>
 * @property {"next"} NEXT right/bottom align<ko>우/하 정렬</ko>
 */
var ALIGN = {
  PREV: "prev",
  CENTER: "center",
  NEXT: "next"
};
/**
 * An object of directions
 * @ko 방향을 나타내는 값들을 담고 있는 객체
 * @type {object}
 * @property {"PREV"} PREV "left" when {@link Flicking#horizontal horizontal} is true, and "top" when {@link Flicking#horizontal horizontal} is false
 * <ko>{@link Flicking#horizontal horizontal}가 `true`일 경우 왼쪽, {@link Flicking#horizontal horizontal}가 `false`일 경우 위쪽을 의미합니다</ko>
 * @property {"NEXT"} NEXT "right" when {@link Flicking#horizontal horizontal} is true, and "bottom" when {@link Flicking#horizontal horizontal} is false
 * <ko>{@link Flicking#horizontal horizontal}가 `true`일 경우 오른쪽, {@link Flicking#horizontal horizontal}가 `false`일 경우 아래쪽을 의미합니다</ko>
 * @property {null} NONE This value usually means it's the same position<ko>주로 제자리인 경우를 의미합니다</ko>
 */
var DIRECTION = {
  PREV: "PREV",
  NEXT: "NEXT",
  NONE: null
};
/**
 * An object with all possible {@link Flicking#moveType moveType}s
 * @ko Flicking이 제공하는 {@link Flicking#moveType moveType}들을 담고 있는 객체
 * @type {object}
 * @property {"snap"} SNAP Flicking's {@link Flicking#moveType moveType} that enables {@link SnapControl} as a Flicking's {@link Flicking#control control}
 * <ko>Flicking의 {@link Flicking#control control}을 {@link SnapControl}로 설정하게 하는 {@link Flicking#moveType moveType}</ko>
 * @property {"freeScroll"} FREE_SCROLL Flicking's {@link Flicking#moveType moveType} that enables {@link FreeControl} as a Flicking's {@link Flicking#control control}
 * <ko>Flicking의 {@link Flicking#control control}을 {@link FreeControl}로 설정하게 하는 {@link Flicking#moveType moveType}</ko>
 * @property {"strict"} STRICT Flicking's {@link Flicking#moveType moveType} that enables {@link StrictControl} as a Flicking's {@link Flicking#control control}
 * <ko>Flicking의 {@link Flicking#control control}을 {@link StrictControl}로 설정하게 하는 {@link Flicking#moveType moveType}</ko>
 */
var MOVE_TYPE = {
  SNAP: "snap",
  FREE_SCROLL: "freeScroll",
  STRICT: "strict"
};
var CLASS = {
  VERTICAL: "vertical",
  HIDDEN: "flicking-hidden",
  DEFAULT_VIRTUAL: "flicking-panel"
};
/**
 * An object with all possible {@link Flicking#circularFallback circularFallback}s
 * @ko Flicking의 {@link Flicking#circularFallback circularFallback}에 설정 가능한 값들을 담고 있는 객체
 * @type {object}
 * @property {string} LINEAR "linear"
 * @property {string} BOUND "bound"
 */
var CIRCULAR_FALLBACK = {
  LINEAR: "linear",
  BOUND: "bound"
};
/**
 * An object for identifying {@link https://developer.mozilla.org/en-US/docs/Web/CSS/direction direction} CSS property applied to the camera element(`.flicking-camera`)
 * @ko 카메라 엘리먼트(`.flicking-camera`)에 적용된 {@link https://developer.mozilla.org/en-US/docs/Web/CSS/direction direction} CSS 속성을 구분하기 위한 객체
 * @type {object}
 * @property {string} LTR "ltr"
 * @property {string} RTL "rtl"
 */
var ORDER = {
  LTR: "ltr",
  RTL: "rtl"
};

// eslint-disable-next-line @typescript-eslint/ban-types
var merge = function (target) {
  var sources = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    sources[_i - 1] = arguments[_i];
  }
  sources.forEach(function (source) {
    Object.keys(source).forEach(function (key) {
      target[key] = source[key];
    });
  });
  return target;
};
var getElement = function (el, parent) {
  var targetEl = null;
  if (isString(el)) {
    var parentEl = parent ? parent : document;
    var queryResult = parentEl.querySelector(el);
    if (!queryResult) {
      throw new FlickingError(MESSAGE.ELEMENT_NOT_FOUND(el), CODE.ELEMENT_NOT_FOUND);
    }
    targetEl = queryResult;
  } else if (el && el.nodeType === Node.ELEMENT_NODE) {
    targetEl = el;
  }
  if (!targetEl) {
    throw new FlickingError(MESSAGE.WRONG_TYPE(el, ["HTMLElement", "string"]), CODE.WRONG_TYPE);
  }
  return targetEl;
};
var checkExistence = function (value, nameOnErrMsg) {
  if (value == null) {
    throw new FlickingError(MESSAGE.VAL_MUST_NOT_NULL(value, nameOnErrMsg), CODE.VAL_MUST_NOT_NULL);
  }
};
var clamp$1 = function (x, min, max) {
  return Math.max(Math.min(x, max), min);
};
var getFlickingAttached = function (val) {
  if (!val) {
    throw new FlickingError(MESSAGE.NOT_ATTACHED_TO_FLICKING, CODE.NOT_ATTACHED_TO_FLICKING);
  }
  return val;
};
var toArray$2 = function (iterable) {
  return [].slice.call(iterable);
};
var parseAlign$1 = function (align, size) {
  var alignPoint;
  if (isString(align)) {
    switch (align) {
      case ALIGN.PREV:
        alignPoint = 0;
        break;
      case ALIGN.CENTER:
        alignPoint = 0.5 * size;
        break;
      case ALIGN.NEXT:
        alignPoint = size;
        break;
      default:
        alignPoint = parseArithmeticSize(align, size);
        if (alignPoint == null) {
          throw new FlickingError(MESSAGE.WRONG_OPTION("align", align), CODE.WRONG_OPTION);
        }
    }
  } else {
    alignPoint = align;
  }
  return alignPoint;
};
var parseBounce = function (bounce, size) {
  var parsedBounce;
  if (Array.isArray(bounce)) {
    parsedBounce = bounce.map(function (val) {
      return parseArithmeticSize(val, size);
    });
  } else {
    var parsedVal = parseArithmeticSize(bounce, size);
    parsedBounce = [parsedVal, parsedVal];
  }
  return parsedBounce.map(function (val) {
    if (val == null) {
      throw new FlickingError(MESSAGE.WRONG_OPTION("bounce", bounce), CODE.WRONG_OPTION);
    }
    return val;
  });
};
var parseArithmeticSize = function (cssValue, base) {
  var parsed = parseArithmeticExpression(cssValue);
  if (parsed == null) return null;
  return parsed.percentage * base + parsed.absolute;
};
var parseArithmeticExpression = function (cssValue) {
  var cssRegex = /(?:(\+|\-)\s*)?(\d+(?:\.\d+)?(%|px)?)/g;
  if (typeof cssValue === "number") {
    return {
      percentage: 0,
      absolute: cssValue
    };
  }
  var parsed = {
    percentage: 0,
    absolute: 0
  };
  var idx = 0;
  var matchResult = cssRegex.exec(cssValue);
  while (matchResult != null) {
    var sign = matchResult[1];
    var value = matchResult[2];
    var unit = matchResult[3];
    var parsedValue = parseFloat(value);
    if (idx <= 0) {
      sign = sign || "+";
    }
    // Return default value for values not in good form
    if (!sign) {
      return null;
    }
    var signMultiplier = sign === "+" ? 1 : -1;
    if (unit === "%") {
      parsed.percentage += signMultiplier * (parsedValue / 100);
    } else {
      parsed.absolute += signMultiplier * parsedValue;
    }
    // Match next occurrence
    ++idx;
    matchResult = cssRegex.exec(cssValue);
  }
  // None-matched
  if (idx === 0) {
    return null;
  }
  return parsed;
};
var parseCSSSizeValue = function (val) {
  return isString(val) ? val : val + "px";
};
var parsePanelAlign = function (align) {
  return typeof align === "object" ? align.panel : align;
};
var getDirection$1 = function (start, end) {
  if (start === end) return DIRECTION.NONE;
  return start < end ? DIRECTION.NEXT : DIRECTION.PREV;
};
var parseElement = function (element) {
  if (!Array.isArray(element)) {
    element = [element];
  }
  var elements = [];
  element.forEach(function (el) {
    if (isString(el)) {
      var tempDiv = document.createElement("div");
      tempDiv.innerHTML = el;
      elements.push.apply(elements, __spread$1(toArray$2(tempDiv.children)));
      while (tempDiv.firstChild) {
        tempDiv.removeChild(tempDiv.firstChild);
      }
    } else if (el && el.nodeType === Node.ELEMENT_NODE) {
      elements.push(el);
    } else {
      throw new FlickingError(MESSAGE.WRONG_TYPE(el, ["HTMLElement", "string"]), CODE.WRONG_TYPE);
    }
  });
  return elements;
};
var getMinusCompensatedIndex = function (idx, max) {
  return idx < 0 ? clamp$1(idx + max, 0, max) : clamp$1(idx, 0, max);
};
var includes = function (array, target) {
  var e_1, _a;
  try {
    for (var array_1 = __values$1(array), array_1_1 = array_1.next(); !array_1_1.done; array_1_1 = array_1.next()) {
      var val = array_1_1.value;
      if (val === target) return true;
    }
  } catch (e_1_1) {
    e_1 = {
      error: e_1_1
    };
  } finally {
    try {
      if (array_1_1 && !array_1_1.done && (_a = array_1.return)) _a.call(array_1);
    } finally {
      if (e_1) throw e_1.error;
    }
  }
  return false;
};
var isString = function (val) {
  return typeof val === "string";
};
var circulatePosition = function (pos, min, max) {
  var size = max - min;
  if (pos < min) {
    var offset = (min - pos) % size;
    pos = max - offset;
  } else if (pos > max) {
    var offset = (pos - max) % size;
    pos = min + offset;
  }
  return pos;
};
var find$1 = function (array, checker) {
  var e_2, _a;
  try {
    for (var array_2 = __values$1(array), array_2_1 = array_2.next(); !array_2_1.done; array_2_1 = array_2.next()) {
      var val = array_2_1.value;
      if (checker(val)) {
        return val;
      }
    }
  } catch (e_2_1) {
    e_2 = {
      error: e_2_1
    };
  } finally {
    try {
      if (array_2_1 && !array_2_1.done && (_a = array_2.return)) _a.call(array_2);
    } finally {
      if (e_2) throw e_2.error;
    }
  }
  return null;
};
var findRight = function (array, checker) {
  for (var idx = array.length - 1; idx >= 0; idx--) {
    var val = array[idx];
    if (checker(val)) {
      return val;
    }
  }
  return null;
};
var findIndex = function (array, checker) {
  for (var idx = 0; idx < array.length; idx++) {
    if (checker(array[idx])) {
      return idx;
    }
  }
  return -1;
};
var getProgress = function (pos, prev, next) {
  return (pos - prev) / (next - prev);
};
// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
var getStyle = function (el) {
  return window.getComputedStyle(el) || el.currentStyle;
};
var setSize = function (el, _a) {
  var width = _a.width,
    height = _a.height;
  if (width != null) {
    if (isString(width)) {
      el.style.width = width;
    } else {
      el.style.width = width + "px";
    }
  }
  if (height != null) {
    if (isString(height)) {
      el.style.height = height;
    } else {
      el.style.height = height + "px";
    }
  }
};
var isBetween = function (val, min, max) {
  return val >= min && val <= max;
};
var circulateIndex = function (index, max) {
  if (index >= max) {
    return index % max;
  } else if (index < 0) {
    return getMinusCompensatedIndex((index + 1) % max - 1, max);
  } else {
    return index;
  }
};
var range = function (end) {
  var arr = new Array(end);
  for (var i = 0; i < end; i++) {
    arr[i] = i;
  }
  return arr;
};
var getElementSize = function (_a) {
  var el = _a.el,
    horizontal = _a.horizontal,
    useFractionalSize = _a.useFractionalSize,
    useOffset = _a.useOffset,
    style = _a.style;
  var size = 0;
  if (useFractionalSize) {
    var baseSize = parseFloat(horizontal ? style.width : style.height) || 0;
    var isBorderBoxSizing = style.boxSizing === "border-box";
    var border = horizontal ? parseFloat(style.borderLeftWidth || "0") + parseFloat(style.borderRightWidth || "0") : parseFloat(style.borderTopWidth || "0") + parseFloat(style.borderBottomWidth || "0");
    if (isBorderBoxSizing) {
      size = useOffset ? baseSize : baseSize - border;
    } else {
      var padding = horizontal ? parseFloat(style.paddingLeft || "0") + parseFloat(style.paddingRight || "0") : parseFloat(style.paddingTop || "0") + parseFloat(style.paddingBottom || "0");
      size = useOffset ? baseSize + padding + border : baseSize + padding;
    }
  } else {
    var sizeStr = horizontal ? "Width" : "Height";
    size = useOffset ? el["offset" + sizeStr] : el["client" + sizeStr];
  }
  return Math.max(size, 0);
};
var setPrototypeOf = Object.setPrototypeOf || function (obj, proto) {
  obj.__proto__ = proto;
  return obj;
};

/*
 * Copyright (c) 2015 NAVER Corp.
 * egjs projects are licensed under the MIT license
 */
/**
 * Special type of known error that {@link Flicking} throws.
 * @ko Flicking 내부에서 알려진 오류 발생시 throw되는 에러
 * @property {number} code Error code<ko>에러 코드</ko>
 * @property {string} message Error message<ko>에러 메시지</ko>
 * @see {@link ERROR_CODE ERROR_CODE}
 * @example
 * ```ts
 * import Flicking, { FlickingError, ERROR_CODES } from "@egjs/flicking";
 * try {
 *   const flicking = new Flicking(".flicking-viewport")
 * } catch (e) {
 *   if (e instanceof FlickingError && e.code === ERROR_CODES.ELEMENT_NOT_FOUND) {
 *     console.error("Element not found")
 *   }
 * }
 * ```
 */
var FlickingError = /*#__PURE__*/function (_super) {
  __extends$3(FlickingError, _super);
  /**
   * @param message Error message<ko>에러 메시지</ko>
   * @param code Error code<ko>에러 코드</ko>
   */
  function FlickingError(message, code) {
    var _this = _super.call(this, message) || this;
    setPrototypeOf(_this, FlickingError.prototype);
    _this.name = "FlickingError";
    _this.code = code;
    return _this;
  }
  return FlickingError;
}(Error);

/**
 * A component that manages viewport size
 * @ko 뷰포트 크기 정보를 담당하는 컴포넌트
 */
var Viewport = /*#__PURE__*/function () {
  /**
   * @param el A viewport element<ko>뷰포트 엘리먼트</ko>
   */
  function Viewport(flicking, el) {
    this._flicking = flicking;
    this._el = el;
    this._width = 0;
    this._height = 0;
    this._padding = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    };
    this._isBorderBoxSizing = false;
  }
  var __proto = Viewport.prototype;
  Object.defineProperty(__proto, "element", {
    /**
     * A viewport(root) element
     * @ko 뷰포트(root) 엘리먼트
     * @type {HTMLElement}
     * @readonly
     */
    get: function () {
      return this._el;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "width", {
    /**
     * Viewport width, without paddings
     * @ko 뷰포트 너비
     * @type {number}
     * @readonly
     */
    get: function () {
      return this._width - this._padding.left - this._padding.right;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "height", {
    /**
     * Viewport height, without paddings
     * @ko 뷰포트 높이
     * @type {number}
     * @readonly
     */
    get: function () {
      return this._height - this._padding.top - this._padding.bottom;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "padding", {
    /**
     * Viewport paddings
     * @ko 뷰포트 CSS padding 값
     * @type {object}
     * @property {number} left CSS `padding-left`
     * @property {number} right CSS `padding-right`
     * @property {number} top CSS `padding-top`
     * @property {number} bottom CSS `padding-bottom`
     * @readonly
     */
    get: function () {
      return this._padding;
    },
    enumerable: false,
    configurable: true
  });
  /**
   * Change viewport's size.
   * This will change the actual size of `.flicking-viewport` element by changing its CSS width/height property
   * @ko 뷰포트 크기를 변경합니다.
   * `.flicking-viewport` 엘리먼트에 해당 크기의 CSS width/height를 적용합니다
   * @param {object} [size] New viewport size<ko>새 뷰포트 크기</ko>
   * @param {number|string} [size.width] CSS string or number(in px)<ko>CSS 문자열 또는 숫자(px)</ko>
   * @param {number|string} [size.height] CSS string or number(in px)<ko>CSS 문자열 또는 숫자(px)</ko>
   */
  __proto.setSize = function (_a) {
    var width = _a.width,
      height = _a.height;
    var el = this._el;
    var padding = this._padding;
    var isBorderBoxSizing = this._isBorderBoxSizing;
    if (width != null) {
      if (isString(width)) {
        el.style.width = width;
      } else {
        var newWidth = isBorderBoxSizing ? width + padding.left + padding.right : width;
        el.style.width = newWidth + "px";
      }
    }
    if (height != null) {
      if (isString(height)) {
        el.style.height = height;
      } else {
        var newHeight = isBorderBoxSizing ? height + padding.top + padding.bottom : height;
        el.style.height = newHeight + "px";
      }
    }
    this.resize();
  };
  /**
   * Update width/height to the current viewport element's size
   * @ko 현재 뷰포트 엘리먼트의 크기로 너비/높이를 업데이트합니다
   */
  __proto.resize = function () {
    var el = this._el;
    var elStyle = getStyle(el);
    var useFractionalSize = this._flicking.useFractionalSize;
    this._width = getElementSize({
      el: el,
      horizontal: true,
      useFractionalSize: useFractionalSize,
      useOffset: false,
      style: elStyle
    });
    this._height = getElementSize({
      el: el,
      horizontal: false,
      useFractionalSize: useFractionalSize,
      useOffset: false,
      style: elStyle
    });
    this._padding = {
      left: elStyle.paddingLeft ? parseFloat(elStyle.paddingLeft) : 0,
      right: elStyle.paddingRight ? parseFloat(elStyle.paddingRight) : 0,
      top: elStyle.paddingTop ? parseFloat(elStyle.paddingTop) : 0,
      bottom: elStyle.paddingBottom ? parseFloat(elStyle.paddingBottom) : 0
    };
    this._isBorderBoxSizing = elStyle.boxSizing === "border-box";
  };
  return Viewport;
}();

var AutoResizer = /*#__PURE__*/function () {
  function AutoResizer(flicking) {
    var _this = this;
    this._onResize = function () {
      var flicking = _this._flicking;
      var resizeDebounce = flicking.resizeDebounce;
      var maxResizeDebounce = flicking.maxResizeDebounce;
      if (resizeDebounce <= 0) {
        void flicking.resize();
      } else {
        if (_this._maxResizeDebounceTimer <= 0) {
          if (maxResizeDebounce > 0 && maxResizeDebounce >= resizeDebounce) {
            _this._maxResizeDebounceTimer = window.setTimeout(_this._doScheduledResize, maxResizeDebounce);
          }
        }
        if (_this._resizeTimer > 0) {
          clearTimeout(_this._resizeTimer);
          _this._resizeTimer = 0;
        }
        _this._resizeTimer = window.setTimeout(_this._doScheduledResize, resizeDebounce);
      }
    };
    this._doScheduledResize = function () {
      clearTimeout(_this._resizeTimer);
      clearTimeout(_this._maxResizeDebounceTimer);
      _this._maxResizeDebounceTimer = -1;
      _this._resizeTimer = -1;
      void _this._flicking.resize();
    };
    // eslint-disable-next-line @typescript-eslint/member-ordering
    this._skipFirstResize = function () {
      var isFirstResize = true;
      return function () {
        if (isFirstResize) {
          isFirstResize = false;
          return;
        }
        _this._onResize();
      };
    }();
    this._flicking = flicking;
    this._enabled = false;
    this._resizeObserver = null;
    this._resizeTimer = -1;
    this._maxResizeDebounceTimer = -1;
  }
  var __proto = AutoResizer.prototype;
  Object.defineProperty(__proto, "enabled", {
    get: function () {
      return this._enabled;
    },
    enumerable: false,
    configurable: true
  });
  __proto.enable = function () {
    var flicking = this._flicking;
    var viewport = flicking.viewport;
    if (this._enabled) {
      this.disable();
    }
    if (flicking.useResizeObserver && !!window.ResizeObserver) {
      var viewportSizeNot0 = viewport.width !== 0 || viewport.height !== 0;
      var resizeObserver = viewportSizeNot0 ? new ResizeObserver(this._skipFirstResize) : new ResizeObserver(this._onResize);
      resizeObserver.observe(flicking.viewport.element);
      this._resizeObserver = resizeObserver;
    } else {
      window.addEventListener("resize", this._onResize);
    }
    this._enabled = true;
    return this;
  };
  __proto.disable = function () {
    if (!this._enabled) return this;
    var resizeObserver = this._resizeObserver;
    if (resizeObserver) {
      resizeObserver.disconnect();
      this._resizeObserver = null;
    } else {
      window.removeEventListener("resize", this._onResize);
    }
    this._enabled = false;
    return this;
  };
  return AutoResizer;
}();

/**
 * @internal
 */
var VanillaElementProvider = /*#__PURE__*/function () {
  function VanillaElementProvider(element) {
    this._element = element;
    this._rendered = true;
  }
  var __proto = VanillaElementProvider.prototype;
  Object.defineProperty(__proto, "element", {
    get: function () {
      return this._element;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "rendered", {
    get: function () {
      return this._rendered;
    },
    enumerable: false,
    configurable: true
  });
  __proto.show = function (flicking) {
    var el = this.element;
    var cameraEl = flicking.camera.element;
    if (el.parentElement !== cameraEl) {
      cameraEl.appendChild(el);
      this._rendered = true;
    }
  };
  __proto.hide = function (flicking) {
    var el = this.element;
    var cameraEl = flicking.camera.element;
    if (el.parentElement === cameraEl) {
      cameraEl.removeChild(el);
      this._rendered = false;
    }
  };
  return VanillaElementProvider;
}();

/*
 * Copyright (c) 2015 NAVER Corp.
 * egjs projects are licensed under the MIT license
 */
/**
 * @internal
 */
var VirtualElementProvider = /*#__PURE__*/function () {
  function VirtualElementProvider(flicking) {
    this._flicking = flicking;
  }
  var __proto = VirtualElementProvider.prototype;
  Object.defineProperty(__proto, "element", {
    get: function () {
      return this._virtualElement.nativeElement;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "rendered", {
    get: function () {
      return this._virtualElement.visible;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "_virtualElement", {
    get: function () {
      var flicking = this._flicking;
      var elIndex = this._panel.elementIndex;
      var virtualElements = flicking.virtual.elements;
      return virtualElements[elIndex];
    },
    enumerable: false,
    configurable: true
  });
  __proto.init = function (panel) {
    this._panel = panel;
  };
  __proto.show = function () {
    // DO_NOTHING
    // Actual element visibility is controlled by VirtualManager
  };
  __proto.hide = function () {
    // DO_NOTHING
    // Actual element visibility is controlled by VirtualManager
  };
  return VirtualElementProvider;
}();

/**
 * A manager class to add / remove virtual panels
 */
var VirtualManager = /*#__PURE__*/function () {
  function VirtualManager(flicking, options) {
    var _a, _b, _c, _d;
    this._flicking = flicking;
    this._renderPanel = (_a = options === null || options === void 0 ? void 0 : options.renderPanel) !== null && _a !== void 0 ? _a : function () {
      return "";
    };
    this._initialPanelCount = (_b = options === null || options === void 0 ? void 0 : options.initialPanelCount) !== null && _b !== void 0 ? _b : -1;
    this._cache = (_c = options === null || options === void 0 ? void 0 : options.cache) !== null && _c !== void 0 ? _c : false;
    this._panelClass = (_d = options === null || options === void 0 ? void 0 : options.panelClass) !== null && _d !== void 0 ? _d : CLASS.DEFAULT_VIRTUAL;
    this._elements = [];
  }
  var __proto = VirtualManager.prototype;
  Object.defineProperty(__proto, "elements", {
    get: function () {
      return this._elements;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "renderPanel", {
    // Options
    /**
     * A rendering function for the panel element's innerHTML
     * @ko 패널 엘리먼트의 innerHTML을 렌더링하는 함수
     * @type {function}
     * @param {VirtualPanel} panel Instance of the panel<ko>패널 인스턴스</ko>
     * @param {number} index Index of the panel<ko>패널 인덱스</ko>
     * @default "() => {}"
     */
    get: function () {
      return this._renderPanel;
    },
    set: function (val) {
      this._renderPanel = val;
      this._flicking.renderer.panels.forEach(function (panel) {
        return panel.uncacheRenderResult();
      });
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "initialPanelCount", {
    /**
     * Initial panel count to render
     * @ko 최초로 렌더링할 패널의 개수
     * @readonly
     * @type {number}
     * @default -1
     */
    get: function () {
      return this._initialPanelCount;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "cache", {
    /**
     * Whether to cache rendered panel's innerHTML
     * @ko 렌더링된 패널의 innerHTML 정보를 캐시할지 여부
     * @type {boolean}
     * @default false
     */
    get: function () {
      return this._cache;
    },
    set: function (val) {
      this._cache = val;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "panelClass", {
    /**
     * The class name that will be applied to rendered panel elements
     * @ko 렌더링되는 패널 엘리먼트에 적용될 클래스 이름
     * @type {string}
     * @default "flicking-panel"
     */
    get: function () {
      return this._panelClass;
    },
    set: function (val) {
      this._panelClass = val;
    },
    enumerable: false,
    configurable: true
  });
  __proto.init = function () {
    var flicking = this._flicking;
    if (!flicking.virtualEnabled) return;
    if (!flicking.externalRenderer && !flicking.renderExternal) {
      this._initVirtualElements();
    }
    var virtualElements = flicking.camera.children;
    this._elements = virtualElements.map(function (el) {
      return {
        nativeElement: el,
        visible: true
      };
    });
  };
  __proto.show = function (index) {
    var el = this._elements[index];
    var nativeEl = el.nativeElement;
    el.visible = true;
    if (nativeEl.style.display) {
      nativeEl.style.display = "";
    }
  };
  __proto.hide = function (index) {
    var el = this._elements[index];
    var nativeEl = el.nativeElement;
    el.visible = false;
    nativeEl.style.display = "none";
  };
  /**
   * Add new virtual panels at the end of the list
   * @ko 새로운 가상 패널들을 리스트의 끝에 추가합니다
   * @param {number} count The number of panels to add<ko>추가할 패널의 개수</ko>
   * @returns {Array<VirtualPanel>} The new panels added<ko>새롭게 추가된 패널들</ko>
   */
  __proto.append = function (count) {
    if (count === void 0) {
      count = 1;
    }
    var flicking = this._flicking;
    return this.insert(flicking.panels.length, count);
  };
  /**
   * Add new virtual panels at the start of the list
   * @ko 새로운 가상 패널들을 리스트의 시작에 추가합니다
   * @param {number} count The number of panels to add<ko>추가할 패널의 개수</ko>
   * @returns {Array<VirtualPanel>} The new panels added<ko>새롭게 추가된 패널들</ko>
   */
  __proto.prepend = function (count) {
    if (count === void 0) {
      count = 1;
    }
    return this.insert(0, count);
  };
  /**
   * Add new virtual panels at the given index
   * @ko 새로운 가상 패널들을 주어진 인덱스에 추가합니다
   * @param {number} count The number of panels to add<ko>추가할 패널의 개수</ko>
   * @returns {Array<VirtualPanel>} The new panels added<ko>새롭게 추가된 패널들</ko>
   */
  __proto.insert = function (index, count) {
    if (count === void 0) {
      count = 1;
    }
    if (count <= 0) return [];
    var flicking = this._flicking;
    return flicking.renderer.batchInsert({
      index: index,
      elements: range(count),
      hasDOMInElements: false
    });
  };
  /**
   * Remove panels at the given index
   * @ko 주어진 인덱스에서 패널들을 삭제합니다
   * @param {number} count The number of panels to remove<ko>삭제할 패널의 개수</ko>
   * @returns {Array<VirtualPanel>} The panels removed<ko>삭제된 패널들</ko>
   */
  __proto.remove = function (index, count) {
    if (count <= 0) return [];
    var flicking = this._flicking;
    return flicking.renderer.batchRemove({
      index: index,
      deleteCount: count,
      hasDOMInElements: false
    });
  };
  __proto._initVirtualElements = function () {
    var _this = this;
    var flicking = this._flicking;
    var cameraElement = flicking.camera.element;
    var panelsPerView = flicking.panelsPerView;
    var fragment = document.createDocumentFragment();
    var newElements = range(panelsPerView + 1).map(function (idx) {
      var panelEl = document.createElement("div");
      panelEl.className = _this._panelClass;
      panelEl.dataset.elementIndex = idx.toString();
      return panelEl;
    });
    newElements.forEach(function (el) {
      fragment.appendChild(el);
    });
    cameraElement.appendChild(fragment);
  };
  return VirtualManager;
}();

/**
 * All possible @egjs/axes event keys
 * @internal
 */
var EVENT = {
  HOLD: "hold",
  CHANGE: "change",
  RELEASE: "release",
  ANIMATION_END: "animationEnd",
  FINISH: "finish"
};
/**
 * An Axis key that Flicking uses
 * @internal
 */
var POSITION_KEY = "flick";

var STATE_TYPE;
(function (STATE_TYPE) {
  STATE_TYPE[STATE_TYPE["IDLE"] = 0] = "IDLE";
  STATE_TYPE[STATE_TYPE["HOLDING"] = 1] = "HOLDING";
  STATE_TYPE[STATE_TYPE["DRAGGING"] = 2] = "DRAGGING";
  STATE_TYPE[STATE_TYPE["ANIMATING"] = 3] = "ANIMATING";
  STATE_TYPE[STATE_TYPE["DISABLED"] = 4] = "DISABLED";
})(STATE_TYPE || (STATE_TYPE = {}));
/**
 * A component that shows the current status of the user input or the animation
 * @ko 현재 사용자 입력 또는 애니메이션 상태를 나타내는 컴포넌트
 * @internal
 */
var State = /*#__PURE__*/function () {
  function State() {
    this._delta = 0;
    this._targetPanel = null;
  }
  var __proto = State.prototype;
  Object.defineProperty(__proto, "delta", {
    /**
     * A sum of delta values of change events from the last hold event of Axes
     * @ko 이전 hold이벤트부터 change에 의해 발생한 이동 delta값의 합산
     * @type {number}
     * @readonly
     */
    get: function () {
      return this._delta;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "targetPanel", {
    /**
     * A panel to set as {@link Control#activePanel} after the animation is finished
     * @ko 애니메이션 종료시 {@link Control#activePanel}로 설정할 패널
     * @type {number}
     * @readonly
     */
    get: function () {
      return this._targetPanel;
    },
    set: function (val) {
      this._targetPanel = val;
    },
    enumerable: false,
    configurable: true
  });
  /**
   * An callback which is called when state has changed to this state
   * @ko 현재 상태로 돌입했을때 호출되는 콜백 함수
   * @param {State} prevState An previous state<ko>이전 상태값</ko>
   * @return {void}
   */
  __proto.onEnter = function (prevState) {
    this._delta = prevState._delta;
    this._targetPanel = prevState._targetPanel;
  };
  /**
   * An event handler for Axes's {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:hold hold} event
   * @ko Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:hold hold} 이벤트 핸들러
   * @param {object} [ctx] Event context<ko>이벤트 콘텍스트</ko>
   * @param {Flicking} [ctx.flicking] An instance of Flicking<ko>Flicking 인스턴스</ko>
   * @param {object} [ctx.axesEvent] A {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:hold hold} event of Axes
   * <ko>Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:hold hold} 이벤트</ko>
   * @param {function} [ctx.transitTo] A function for changing current state to other state<ko>다른 상태로 변경하기 위한 함수</ko>
   * @return {void}
   */
  __proto.onHold = function (ctx) {
    // DO NOTHING
  };
  /**
   * An event handler for Axes's {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:change change} event
   * @ko Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:change change} 이벤트 핸들러
   * @param {object} [ctx] Event context<ko>이벤트 콘텍스트</ko>
   * @param {Flicking} [ctx.flicking] An instance of Flicking<ko>Flicking 인스턴스</ko>
   * @param {object} [ctx.axesEvent] A {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:change change} event of Axes
   * <ko>Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:change change} 이벤트</ko>
   * @param {function} [ctx.transitTo] A function for changing current state to other state<ko>다른 상태로 변경하기 위한 함수</ko>
   * @return {void}
   */
  __proto.onChange = function (ctx) {
    // DO NOTHING
  };
  /**
   * An event handler for Axes's {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} event
   * @ko Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} 이벤트 핸들러
   * @param {object} [ctx] Event context<ko>이벤트 콘텍스트</ko>
   * @param {Flicking} [ctx.flicking] An instance of Flicking<ko>Flicking 인스턴스</ko>
   * @param {object} [ctx.axesEvent] A {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} event of Axes
   * <ko>Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} 이벤트</ko>
   * @param {function} [ctx.transitTo] A function for changing current state to other state<ko>다른 상태로 변경하기 위한 함수</ko>
   * @return {void}
   */
  __proto.onRelease = function (ctx) {
    // DO NOTHING
  };
  /**
   * An event handler for Axes's {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:animationEnd animationEnd} event
   * @ko Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:animationEnd animationEnd} 이벤트 핸들러
   * @param {object} [ctx] Event context<ko>이벤트 콘텍스트</ko>
   * @param {Flicking} [ctx.flicking] An instance of Flicking<ko>Flicking 인스턴스</ko>
   * @param {object} [ctx.axesEvent] A {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:animationEnd animationEnd} event of Axes
   * <ko>Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:animationEnd animationEnd} 이벤트</ko>
   * @param {function} [ctx.transitTo] A function for changing current state to other state<ko>다른 상태로 변경하기 위한 함수</ko>
   * @return {void}
   */
  __proto.onAnimationEnd = function (ctx) {
    // DO NOTHING
  };
  /**
   * An event handler for Axes's {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:finish finish} event
   * @ko Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:finish finish} 이벤트 핸들러
   * @param {object} [ctx] Event context<ko>이벤트 콘텍스트</ko>
   * @param {Flicking} [ctx.flicking] An instance of Flicking<ko>Flicking 인스턴스</ko>
   * @param {object} [ctx.axesEvent] A {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:finish finish} event of Axes<ko>Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:finish finish} 이벤트</ko>
   * @param {function} [ctx.transitTo] A function for changing current state to other state<ko>다른 상태로 변경하기 위한 함수</ko>
   * @return {void}
   */
  __proto.onFinish = function (ctx) {
    // DO NOTHING
  };
  __proto._moveToChangedPosition = function (ctx) {
    var flicking = ctx.flicking,
      axesEvent = ctx.axesEvent,
      transitTo = ctx.transitTo;
    var delta = axesEvent.delta[POSITION_KEY];
    if (!delta) {
      return;
    }
    this._delta += delta;
    var camera = flicking.camera;
    var prevPosition = camera.position;
    var position = axesEvent.pos[POSITION_KEY];
    var newPosition = flicking.circularEnabled ? circulatePosition(position, camera.range.min, camera.range.max) : position;
    camera.lookAt(newPosition);
    var moveEvent = new ComponentEvent$1(EVENTS.MOVE, {
      isTrusted: axesEvent.isTrusted,
      holding: this.holding,
      direction: getDirection$1(0, axesEvent.delta[POSITION_KEY]),
      axesEvent: axesEvent
    });
    flicking.trigger(moveEvent);
    if (moveEvent.isCanceled()) {
      // Return to previous position
      camera.lookAt(prevPosition);
      transitTo(STATE_TYPE.DISABLED);
    }
  };
  return State;
}();

/**
 * A default state when there's no user input and no animation's playing
 * @ko 사용자의 입력이 없고, 애니메이션이 동작하고있지 않은 기본 상태
 * @internal
 */
var IdleState = /*#__PURE__*/function (_super) {
  __extends$3(IdleState, _super);
  function IdleState() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    /**
     * Whether user is clicking or touching
     * @ko 현재 사용자가 클릭/터치중인지 여부
     * @type {false}
     * @readonly
     */
    _this.holding = false;
    /**
     * Whether Flicking's animating
     * @ko 현재 애니메이션 동작 여부
     * @type {false}
     * @readonly
     */
    _this.animating = false;
    return _this;
  }
  var __proto = IdleState.prototype;
  __proto.onEnter = function () {
    this._delta = 0;
    this._targetPanel = null;
  };
  __proto.onHold = function (ctx) {
    // Shouldn't do any action until any panels on flicking area
    var flicking = ctx.flicking,
      axesEvent = ctx.axesEvent,
      transitTo = ctx.transitTo;
    if (flicking.renderer.panelCount <= 0) {
      transitTo(STATE_TYPE.DISABLED);
      return;
    }
    var holdStartEvent = new ComponentEvent$1(EVENTS.HOLD_START, {
      axesEvent: axesEvent
    });
    flicking.trigger(holdStartEvent);
    if (holdStartEvent.isCanceled()) {
      transitTo(STATE_TYPE.DISABLED);
    } else {
      transitTo(STATE_TYPE.HOLDING);
    }
  };
  // By methods call
  __proto.onChange = function (ctx) {
    var flicking = ctx.flicking,
      axesEvent = ctx.axesEvent,
      transitTo = ctx.transitTo;
    var controller = flicking.control.controller;
    var animatingContext = controller.animatingContext;
    var moveStartEvent = new ComponentEvent$1(EVENTS.MOVE_START, {
      isTrusted: axesEvent.isTrusted,
      holding: this.holding,
      direction: getDirection$1(animatingContext.start, animatingContext.end),
      axesEvent: axesEvent
    });
    flicking.trigger(moveStartEvent);
    if (moveStartEvent.isCanceled()) {
      transitTo(STATE_TYPE.DISABLED);
    } else {
      // Trigger AnimatingState's onChange, to trigger "move" event immediately
      transitTo(STATE_TYPE.ANIMATING).onChange(ctx);
    }
  };
  return IdleState;
}(State);

/**
 * A state that activates when user's holding the Flicking area, but not moved a single pixel yet
 * @ko 사용자의 입력이 시작되었으나, 아직 움직이지는 않은 상태
 * @internal
 */
var HoldingState = /*#__PURE__*/function (_super) {
  __extends$3(HoldingState, _super);
  function HoldingState() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    /**
     * Whether user is clicking or touching
     * @ko 현재 사용자가 클릭/터치중인지 여부
     * @type {true}
     * @readonly
     */
    _this.holding = true;
    /**
     * Whether Flicking's animating
     * @ko 현재 애니메이션 동작 여부
     * @type {false}
     * @readonly
     */
    _this.animating = false;
    _this._releaseEvent = null;
    return _this;
  }
  var __proto = HoldingState.prototype;
  __proto.onChange = function (ctx) {
    var flicking = ctx.flicking,
      axesEvent = ctx.axesEvent,
      transitTo = ctx.transitTo;
    var inputEvent = axesEvent.inputEvent;
    var offset = flicking.horizontal ? inputEvent.offsetX : inputEvent.offsetY;
    var moveStartEvent = new ComponentEvent$1(EVENTS.MOVE_START, {
      isTrusted: axesEvent.isTrusted,
      holding: this.holding,
      direction: getDirection$1(0, -offset),
      axesEvent: axesEvent
    });
    flicking.trigger(moveStartEvent);
    if (moveStartEvent.isCanceled()) {
      transitTo(STATE_TYPE.DISABLED);
    } else {
      // Trigger DraggingState's onChange, to trigger "move" event immediately
      transitTo(STATE_TYPE.DRAGGING).onChange(ctx);
    }
  };
  __proto.onRelease = function (ctx) {
    var flicking = ctx.flicking,
      axesEvent = ctx.axesEvent,
      transitTo = ctx.transitTo;
    flicking.trigger(new ComponentEvent$1(EVENTS.HOLD_END, {
      axesEvent: axesEvent
    }));
    if (axesEvent.delta.flick !== 0) {
      // Sometimes "release" event on axes triggered before "change" event
      // Especially if user flicked panel fast in really short amount of time
      // if delta is not zero, that means above case happened.
      // Event flow should be HOLD_START -> MOVE_START -> MOVE -> HOLD_END
      // At least one move event should be included between holdStart and holdEnd
      axesEvent.setTo({
        flick: flicking.camera.position
      }, 0);
      transitTo(STATE_TYPE.IDLE);
      return;
    }
    // Can't handle select event here,
    // As "finish" axes event happens
    this._releaseEvent = axesEvent;
  };
  __proto.onFinish = function (ctx) {
    var e_1, _a;
    var flicking = ctx.flicking,
      transitTo = ctx.transitTo;
    // Should transite to IDLE state before select event
    // As user expects hold is already finished
    transitTo(STATE_TYPE.IDLE);
    if (!this._releaseEvent) {
      return;
    }
    // Handle release event here
    // To prevent finish event called twice
    var releaseEvent = this._releaseEvent;
    // Static click
    /* eslint-disable @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access */
    var srcEvent = releaseEvent.inputEvent.srcEvent;
    var clickedElement;
    if (srcEvent.type === "touchend") {
      var touchEvent = srcEvent;
      var touch = touchEvent.changedTouches[0];
      clickedElement = document.elementFromPoint(touch.clientX, touch.clientY);
    } else {
      clickedElement = srcEvent.target;
    }
    /* eslint-enable */
    var panels = flicking.renderer.panels;
    var clickedPanel = null;
    try {
      for (var panels_1 = __values$1(panels), panels_1_1 = panels_1.next(); !panels_1_1.done; panels_1_1 = panels_1.next()) {
        var panel = panels_1_1.value;
        if (panel.contains(clickedElement)) {
          clickedPanel = panel;
          break;
        }
      }
    } catch (e_1_1) {
      e_1 = {
        error: e_1_1
      };
    } finally {
      try {
        if (panels_1_1 && !panels_1_1.done && (_a = panels_1.return)) _a.call(panels_1);
      } finally {
        if (e_1) throw e_1.error;
      }
    }
    if (clickedPanel) {
      var cameraPosition = flicking.camera.position;
      var clickedPanelPosition = clickedPanel.position;
      flicking.trigger(new ComponentEvent$1(EVENTS.SELECT, {
        index: clickedPanel.index,
        panel: clickedPanel,
        // Direction to the clicked panel
        direction: getDirection$1(cameraPosition, clickedPanelPosition)
      }));
    }
  };
  return HoldingState;
}(State);

/**
 * A state that activates when user's dragging the Flicking area
 * @ko 사용자가 드래깅중인 상태
 * @internal
 */
var DraggingState = /*#__PURE__*/function (_super) {
  __extends$3(DraggingState, _super);
  function DraggingState() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    /**
     * Whether user is clicking or touching
     * @ko 현재 사용자가 클릭/터치중인지 여부
     * @type {true}
     * @readonly
     */
    _this.holding = true;
    /**
     * Whether Flicking's animating
     * @ko 현재 애니메이션 동작 여부
     * @type {true}
     * @readonly
     */
    _this.animating = true;
    return _this;
  }
  var __proto = DraggingState.prototype;
  __proto.onChange = function (ctx) {
    this._moveToChangedPosition(ctx);
  };
  __proto.onRelease = function (ctx) {
    var _a;
    var flicking = ctx.flicking,
      axesEvent = ctx.axesEvent,
      transitTo = ctx.transitTo;
    // Update last position to cope with Axes's animating behavior
    // Axes uses start position when animation start
    flicking.trigger(new ComponentEvent$1(EVENTS.HOLD_END, {
      axesEvent: axesEvent
    }));
    if (flicking.renderer.panelCount <= 0) {
      // There're no panels
      transitTo(STATE_TYPE.IDLE);
      return;
    }
    transitTo(STATE_TYPE.ANIMATING);
    var control = flicking.control;
    var position = axesEvent.destPos[POSITION_KEY];
    var duration = Math.max(axesEvent.duration, flicking.duration);
    try {
      void control.moveToPosition(position, duration, axesEvent);
    } catch (err) {
      transitTo(STATE_TYPE.IDLE);
      axesEvent.setTo((_a = {}, _a[POSITION_KEY] = flicking.camera.position, _a), 0);
    }
  };
  return DraggingState;
}(State);

/**
 * A state that activates when Flicking's animating by user input or method call
 * @ko 사용자 입력이나 메소드 호출에 의해 Flicking의 애니메이션이 동작중인 상태
 * @internal
 */
var AnimatingState = /*#__PURE__*/function (_super) {
  __extends$3(AnimatingState, _super);
  function AnimatingState() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    /**
     * Whether user is clicking or touching
     * @ko 현재 사용자가 클릭/터치중인지 여부
     * @type {false}
     * @readonly
     */
    _this.holding = false;
    /**
     * Whether Flicking's animating
     * @ko 현재 애니메이션 동작 여부
     * @type {true}
     * @readonly
     */
    _this.animating = true;
    return _this;
  }
  var __proto = AnimatingState.prototype;
  __proto.onHold = function (ctx) {
    var flicking = ctx.flicking,
      axesEvent = ctx.axesEvent,
      transitTo = ctx.transitTo;
    var targetPanel = this._targetPanel;
    var control = flicking.control;
    this._delta = 0;
    flicking.control.updateInput();
    if (flicking.changeOnHold && targetPanel) {
      control.setActive(targetPanel, control.activePanel, axesEvent.isTrusted);
    }
    var holdStartEvent = new ComponentEvent$1(EVENTS.HOLD_START, {
      axesEvent: axesEvent
    });
    flicking.trigger(holdStartEvent);
    if (holdStartEvent.isCanceled()) {
      transitTo(STATE_TYPE.DISABLED);
    } else {
      transitTo(STATE_TYPE.DRAGGING);
    }
  };
  __proto.onChange = function (ctx) {
    this._moveToChangedPosition(ctx);
  };
  __proto.onFinish = function (ctx) {
    var flicking = ctx.flicking,
      axesEvent = ctx.axesEvent,
      transitTo = ctx.transitTo;
    var control = flicking.control;
    var controller = control.controller;
    var animatingContext = controller.animatingContext;
    transitTo(STATE_TYPE.IDLE);
    flicking.trigger(new ComponentEvent$1(EVENTS.MOVE_END, {
      isTrusted: axesEvent.isTrusted,
      direction: getDirection$1(animatingContext.start, animatingContext.end),
      axesEvent: axesEvent
    }));
    var targetPanel = this._targetPanel;
    if (targetPanel) {
      control.setActive(targetPanel, control.activePanel, axesEvent.isTrusted);
    }
  };
  return AnimatingState;
}(State);

/**
 * A state that activates when Flicking is stopped by event's `stop` method
 * @ko 이벤트의 `stop`호출에 의해 Flicking이 정지된 상태
 * @internal
 */
var DisabledState = /*#__PURE__*/function (_super) {
  __extends$3(DisabledState, _super);
  function DisabledState() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    /**
     * Whether user is clicking or touching
     * @ko 현재 사용자가 클릭/터치중인지 여부
     * @type {false}
     * @readonly
     */
    _this.holding = false;
    /**
     * Whether Flicking's animating
     * @ko 현재 애니메이션 동작 여부
     * @type {true}
     * @readonly
     */
    _this.animating = true;
    return _this;
  }
  var __proto = DisabledState.prototype;
  __proto.onAnimationEnd = function (ctx) {
    var transitTo = ctx.transitTo;
    transitTo(STATE_TYPE.IDLE);
  };
  __proto.onChange = function (ctx) {
    var axesEvent = ctx.axesEvent,
      transitTo = ctx.transitTo;
    // Can stop Axes's change event
    axesEvent.stop();
    transitTo(STATE_TYPE.IDLE);
  };
  __proto.onRelease = function (ctx) {
    var axesEvent = ctx.axesEvent,
      transitTo = ctx.transitTo;
    // This is needed when stopped hold start event
    if (axesEvent.delta.flick === 0) {
      transitTo(STATE_TYPE.IDLE);
    }
  };
  return DisabledState;
}(State);

/**
 * @internal
 */
var StateMachine = /*#__PURE__*/function () {
  function StateMachine() {
    var _this = this;
    this.transitTo = function (nextStateType) {
      var nextState;
      switch (nextStateType) {
        case STATE_TYPE.IDLE:
          nextState = new IdleState();
          break;
        case STATE_TYPE.HOLDING:
          nextState = new HoldingState();
          break;
        case STATE_TYPE.DRAGGING:
          nextState = new DraggingState();
          break;
        case STATE_TYPE.ANIMATING:
          nextState = new AnimatingState();
          break;
        case STATE_TYPE.DISABLED:
          nextState = new DisabledState();
          break;
      }
      nextState.onEnter(_this._state);
      _this._state = nextState;
      return _this._state;
    };
    this._state = new IdleState();
  }
  var __proto = StateMachine.prototype;
  Object.defineProperty(__proto, "state", {
    get: function () {
      return this._state;
    },
    enumerable: false,
    configurable: true
  });
  __proto.fire = function (eventType, externalCtx) {
    var currentState = this._state;
    var ctx = __assign$2(__assign$2({}, externalCtx), {
      transitTo: this.transitTo
    });
    switch (eventType) {
      case EVENT.HOLD:
        currentState.onHold(ctx);
        break;
      case EVENT.CHANGE:
        currentState.onChange(ctx);
        break;
      case EVENT.RELEASE:
        currentState.onRelease(ctx);
        break;
      case EVENT.ANIMATION_END:
        currentState.onAnimationEnd(ctx);
        break;
      case EVENT.FINISH:
        currentState.onFinish(ctx);
        break;
    }
  };
  return StateMachine;
}();

/**
 * A controller that handles the {@link https://naver.github.io/egjs-axes/ @egjs/axes} events
 * @ko {@link https://naver.github.io/egjs-axes/ @egjs/axes}의 이벤트를 처리하는 컨트롤러 컴포넌트
 * @internal
 */
var AxesController = /*#__PURE__*/function () {
  /** */
  function AxesController() {
    var _this = this;
    this._onAxesHold = function () {
      _this._dragged = false;
    };
    this._onAxesChange = function () {
      var _a;
      _this._dragged = !!((_a = _this._panInput) === null || _a === void 0 ? void 0 : _a.isEnabled());
    };
    this._preventClickWhenDragged = function (e) {
      if (_this._dragged) {
        e.preventDefault();
        e.stopPropagation();
      }
      _this._dragged = false;
    };
    this._resetInternalValues();
    this._stateMachine = new StateMachine();
  }
  var __proto = AxesController.prototype;
  Object.defineProperty(__proto, "axes", {
    /**
     * An {@link https://naver.github.io/egjs-axes/docs/api/Axes Axes} instance
     * @ko {@link https://naver.github.io/egjs-axes/docs/api/Axes Axes}의 인스턴스
     * @type {Axes | null}
     * @see https://naver.github.io/egjs-axes/docs/api/Axes
     * @readonly
     */
    get: function () {
      return this._axes;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "panInput", {
    /**
     * An {@link https://naver.github.io/egjs-axes/docs/api/PanInput PanInput} instance
     * @ko {@link https://naver.github.io/egjs-axes/docs/api/PanInput PanInput}의 인스턴스
     * @type {PanInput | null}
     * @see https://naver.github.io/egjs-axes/docs/api/PanInput
     * @readonly
     */
    get: function () {
      return this._panInput;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "stateMachine", {
    /**
     * @internal
     */
    get: function () {
      return this._stateMachine;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "state", {
    /**
     * A activated {@link State} that shows the current status of the user input or the animation
     * @ko 현재 활성화된 {@link State} 인스턴스로 사용자 입력 또는 애니메이션 상태를 나타냅니다
     * @type {State}
     */
    get: function () {
      return this._stateMachine.state;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "animatingContext", {
    /**
     * A context of the current animation playing
     * @ko 현재 재생중인 애니메이션 정보
     * @type {object}
     * @property {number} start A start position of the animation<ko>애니메이션 시작 지점</ko>
     * @property {number} end A end position of the animation<ko>애니메이션 끝 지점</ko>
     * @property {number} offset camera offset<ko>카메라 오프셋</ko>
     * @readonly
     */
    get: function () {
      return this._animatingContext;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "controlParams", {
    /**
     * A current control parameters of the Axes instance
     * @ko 활성화된 현재 Axes 패러미터들
     * @type {ControlParams}
     */
    get: function () {
      var axes = this._axes;
      if (!axes) {
        return {
          range: {
            min: 0,
            max: 0
          },
          position: 0,
          circular: false
        };
      }
      var axis = axes.axis[POSITION_KEY];
      return {
        range: {
          min: axis.range[0],
          max: axis.range[1]
        },
        circular: axis.circular[0],
        position: this.position
      };
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "enabled", {
    /**
     * A Boolean indicating whether the user input is enabled
     * @ko 현재 사용자 입력이 활성화되었는지를 나타내는 값
     * @type {boolean}
     * @readonly
     */
    get: function () {
      var _a, _b;
      return (_b = (_a = this._panInput) === null || _a === void 0 ? void 0 : _a.isEnabled()) !== null && _b !== void 0 ? _b : false;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "position", {
    /**
     * Current position value in {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html Axes} instance
     * @ko {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html Axes} 인스턴스 내부의 현재 좌표 값
     * @type {number}
     * @readonly
     */
    get: function () {
      var _a, _b;
      return (_b = (_a = this._axes) === null || _a === void 0 ? void 0 : _a.get([POSITION_KEY])[POSITION_KEY]) !== null && _b !== void 0 ? _b : 0;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "range", {
    /**
     * Current range value in {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html Axes} instance
     * @ko {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html Axes} 인스턴스 내부의 현재 이동 범위 값
     * @type {number[]}
     * @readonly
     */
    get: function () {
      var _a, _b;
      return (_b = (_a = this._axes) === null || _a === void 0 ? void 0 : _a.axis[POSITION_KEY].range) !== null && _b !== void 0 ? _b : [0, 0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "bounce", {
    /**
     * Actual bounce size(px)
     * @ko 적용된 bounce 크기(px 단위)
     * @type {number[]}
     * @readonly
     */
    get: function () {
      var _a;
      return (_a = this._axes) === null || _a === void 0 ? void 0 : _a.axis[POSITION_KEY].bounce;
    },
    enumerable: false,
    configurable: true
  });
  /**
   * Initialize AxesController
   * @ko AxesController를 초기화합니다
   * @param {Flicking} flicking An instance of Flicking
   * @chainable
   * @return {this}
   */
  __proto.init = function (flicking) {
    var _a;
    var _this = this;
    this._flicking = flicking;
    this._axes = new Axes((_a = {}, _a[POSITION_KEY] = {
      range: [0, 0],
      circular: false,
      bounce: [0, 0]
    }, _a), {
      deceleration: flicking.deceleration,
      interruptable: flicking.interruptable,
      nested: flicking.nested,
      easing: flicking.easing
    });
    this._panInput = new PanInput(flicking.viewport.element, {
      inputType: flicking.inputType,
      threshold: 1,
      iOSEdgeSwipeThreshold: flicking.iOSEdgeSwipeThreshold,
      preventDefaultOnDrag: flicking.preventDefaultOnDrag,
      scale: flicking.horizontal ? [flicking.camera.panelOrder === ORDER.RTL ? 1 : -1, 0] : [0, -1],
      releaseOnScroll: true
    });
    var axes = this._axes;
    axes.connect(flicking.horizontal ? [POSITION_KEY, ""] : ["", POSITION_KEY], this._panInput);
    var _loop_1 = function (key) {
      var eventType = EVENT[key];
      axes.on(eventType, function (e) {
        _this._stateMachine.fire(eventType, {
          flicking: flicking,
          axesEvent: e
        });
      });
    };
    for (var key in EVENT) {
      _loop_1(key);
    }
    return this;
  };
  /**
   * Destroy AxesController and return to initial state
   * @ko AxesController를 초기 상태로 되돌립니다
   * @return {void}
   */
  __proto.destroy = function () {
    var _a;
    if (this._axes) {
      this.removePreventClickHandler();
      this._axes.destroy();
    }
    (_a = this._panInput) === null || _a === void 0 ? void 0 : _a.destroy();
    this._resetInternalValues();
  };
  /**
   * Enable input from the user (mouse/touch)
   * @ko 사용자의 입력(마우스/터치)를 활성화합니다
   * @chainable
   * @return {this}
   */
  __proto.enable = function () {
    var _a;
    (_a = this._panInput) === null || _a === void 0 ? void 0 : _a.enable();
    return this;
  };
  /**
   * Disable input from the user (mouse/touch)
   * @ko 사용자의 입력(마우스/터치)를 막습니다
   * @chainable
   * @return {this}
   */
  __proto.disable = function () {
    var _a;
    (_a = this._panInput) === null || _a === void 0 ? void 0 : _a.disable();
    return this;
  };
  /**
   * Releases ongoing user input (mouse/touch)
   * @ko 사용자의 현재 입력(마우스/터치)를 중단시킵니다
   * @chainable
   * @return {this}
   */
  __proto.release = function () {
    var _a;
    (_a = this._panInput) === null || _a === void 0 ? void 0 : _a.release();
    return this;
  };
  /**
   * Change the destination and duration of the animation currently playing
   * @ko 재생 중인 애니메이션의 목적지와 재생 시간을 변경합니다
   * @param {number} position A position to move<ko>이동할 좌표</ko>
   * @param {number} duration Duration of the animation (unit: ms)<ko>애니메이션 진행 시간 (단위: ms)</ko>
   * @chainable
   * @return {this}
   */
  __proto.updateAnimation = function (position, duration) {
    var _a;
    var _b;
    this._animatingContext = __assign$2(__assign$2({}, this._animatingContext), {
      end: position
    });
    (_b = this._axes) === null || _b === void 0 ? void 0 : _b.updateAnimation({
      destPos: (_a = {}, _a[POSITION_KEY] = position, _a),
      duration: duration
    });
    return this;
  };
  /**
   * Stops the animation currently playing
   * @ko 재생 중인 애니메이션을 중단시킵니다
   * @chainable
   * @return {this}
   */
  __proto.stopAnimation = function () {
    var _a;
    (_a = this._axes) === null || _a === void 0 ? void 0 : _a.stopAnimation();
    return this;
  };
  /**
   * Update {@link https://naver.github.io/egjs-axes/ @egjs/axes}'s state
   * @ko {@link https://naver.github.io/egjs-axes/ @egjs/axes}의 상태를 갱신합니다
   * @chainable
   * @throws {FlickingError}
   * {@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} When {@link AxesController#init init} is not called before
   * <ko>{@link AxesController#init init}이 이전에 호출되지 않은 경우</ko>
   * @return {this}
   */
  __proto.update = function (controlParams) {
    var _a;
    var flicking = getFlickingAttached(this._flicking);
    var camera = flicking.camera;
    var axes = this._axes;
    var axis = axes.axis[POSITION_KEY];
    axis.circular = [controlParams.circular, controlParams.circular];
    axis.range = [controlParams.range.min, controlParams.range.max];
    axis.bounce = parseBounce(flicking.bounce, camera.size);
    axes.axisManager.set((_a = {}, _a[POSITION_KEY] = controlParams.position, _a));
    return this;
  };
  /**
   * Attach a handler to the camera element to prevent click events during animation
   * @ko 카메라 엘리먼트에 애니메이션 도중에 클릭 이벤트를 방지하는 핸들러를 부착합니다
   * @return {this}
   */
  __proto.addPreventClickHandler = function () {
    var flicking = getFlickingAttached(this._flicking);
    var axes = this._axes;
    var cameraEl = flicking.camera.element;
    axes.on(EVENT.HOLD, this._onAxesHold);
    axes.on(EVENT.CHANGE, this._onAxesChange);
    cameraEl.addEventListener("click", this._preventClickWhenDragged, true);
    return this;
  };
  /**
   * Detach a handler to the camera element to prevent click events during animation
   * @ko 카메라 엘리먼트에 애니메이션 도중에 클릭 이벤트를 방지하는 핸들러를 탈착합니다
   * @return {this}
   */
  __proto.removePreventClickHandler = function () {
    var flicking = getFlickingAttached(this._flicking);
    var axes = this._axes;
    var cameraEl = flicking.camera.element;
    axes.off(EVENT.HOLD, this._onAxesHold);
    axes.off(EVENT.CHANGE, this._onAxesChange);
    cameraEl.removeEventListener("click", this._preventClickWhenDragged, true);
    return this;
  };
  /**
   * Run Axes's {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#setTo setTo} using the given position
   * @ko Axes의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#setTo setTo} 메소드를 주어진 좌표를 이용하여 수행합니다
   * @param {number} position A position to move<ko>이동할 좌표</ko>
   * @param {number} duration Duration of the animation (unit: ms)<ko>애니메이션 진행 시간 (단위: ms)</ko>
   * @param {number} [axesEvent] If provided, it'll use its {@link https://naver#github#io/egjs-axes/release/latest/doc/eg#Axes#html#setTo setTo} method instead<ko>이 값이 주어졌을 경우, 해당 이벤트의 {@link https://naver#github#io/egjs-axes/release/latest/doc/eg#Axes#html#setTo setTo} 메소드를 대신해서 사용합니다.</ko>
   * @throws {FlickingError}
   * |code|condition|
   * |---|---|
   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|When {@link Control#init init} is not called before|
   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|When the animation is interrupted by user input|
   * <ko>
   *
   * |code|condition|
   * |---|---|
   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|{@link Control#init init}이 이전에 호출되지 않은 경우|
   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|사용자 입력에 의해 애니메이션이 중단된 경우|
   *
   * </ko>
   * @return {Promise<void>} A Promise which will be resolved after reaching the target position<ko>해당 좌표 도달시에 resolve되는 Promise</ko>
   */
  __proto.animateTo = function (position, duration, axesEvent) {
    var _this = this;
    var _a;
    var axes = this._axes;
    var state = this._stateMachine.state;
    if (!axes) {
      return Promise.reject(new FlickingError(MESSAGE.NOT_ATTACHED_TO_FLICKING, CODE.NOT_ATTACHED_TO_FLICKING));
    }
    var startPos = axes.get([POSITION_KEY])[POSITION_KEY];
    if (startPos === position) {
      var flicking = getFlickingAttached(this._flicking);
      flicking.camera.lookAt(position);
      if (state.targetPanel) {
        flicking.control.setActive(state.targetPanel, flicking.control.activePanel, (_a = axesEvent === null || axesEvent === void 0 ? void 0 : axesEvent.isTrusted) !== null && _a !== void 0 ? _a : false);
      }
      return Promise.resolve();
    }
    this._animatingContext = {
      start: startPos,
      end: position,
      offset: 0
    };
    var animate = function () {
      var _a, _b;
      var resetContext = function () {
        _this._animatingContext = {
          start: 0,
          end: 0,
          offset: 0
        };
      };
      axes.once(EVENT.FINISH, resetContext);
      if (axesEvent) {
        axesEvent.setTo((_a = {}, _a[POSITION_KEY] = position, _a), duration);
      } else {
        axes.setTo((_b = {}, _b[POSITION_KEY] = position, _b), duration);
      }
    };
    return new Promise(function (resolve, reject) {
      var animationFinishHandler = function () {
        axes.off(EVENT.HOLD, interruptionHandler);
        resolve();
      };
      var interruptionHandler = function () {
        axes.off(EVENT.FINISH, animationFinishHandler);
        reject(new FlickingError(MESSAGE.ANIMATION_INTERRUPTED, CODE.ANIMATION_INTERRUPTED));
      };
      axes.once(EVENT.FINISH, animationFinishHandler);
      axes.once(EVENT.HOLD, interruptionHandler);
      animate();
    });
  };
  __proto.updateDirection = function () {
    var flicking = getFlickingAttached(this._flicking);
    var axes = this._axes;
    var panInput = this._panInput;
    axes.disconnect(panInput);
    axes.connect(flicking.horizontal ? [POSITION_KEY, ""] : ["", POSITION_KEY], panInput);
    panInput.options.scale = flicking.horizontal ? [flicking.camera.panelOrder === ORDER.RTL ? 1 : -1, 0] : [0, -1];
  };
  __proto._resetInternalValues = function () {
    this._flicking = null;
    this._axes = null;
    this._panInput = null;
    this._animatingContext = {
      start: 0,
      end: 0,
      offset: 0
    };
    this._dragged = false;
  };
  return AxesController;
}();

/**
 * A component that manages inputs and animation of Flicking
 * @ko Flicking의 입력 장치 & 애니메이션을 담당하는 컴포넌트
 */
var Control = /*#__PURE__*/function () {
  /** */
  function Control() {
    this._flicking = null;
    this._controller = new AxesController();
    this._activePanel = null;
  }
  var __proto = Control.prototype;
  Object.defineProperty(__proto, "controller", {
    /**
     * A controller that handles the {@link https://naver.github.io/egjs-axes/ @egjs/axes} events
     * @ko {@link https://naver.github.io/egjs-axes/ @egjs/axes}의 이벤트를 처리하는 컨트롤러 컴포넌트
     * @type {AxesController}
     * @readonly
     */
    get: function () {
      return this._controller;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "activeIndex", {
    /**
     * Index number of the {@link Flicking#currentPanel currentPanel}
     * @ko {@link Flicking#currentPanel currentPanel}의 인덱스 번호
     * @type {number}
     * @default 0
     * @readonly
     */
    get: function () {
      var _a, _b;
      return (_b = (_a = this._activePanel) === null || _a === void 0 ? void 0 : _a.index) !== null && _b !== void 0 ? _b : -1;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "activePanel", {
    /**
     * An active panel
     * @ko 현재 선택된 패널
     * @type {Panel | null}
     * @readonly
     */
    get: function () {
      return this._activePanel;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "animating", {
    /**
     * Whether Flicking's animating
     * @ko 현재 애니메이션 동작 여부
     * @type {boolean}
     * @readonly
     */
    get: function () {
      return this._controller.state.animating;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "holding", {
    /**
     * Whether user is clicking or touching
     * @ko 현재 사용자가 클릭/터치중인지 여부
     * @type {boolean}
     * @readonly
     */
    get: function () {
      return this._controller.state.holding;
    },
    enumerable: false,
    configurable: true
  });
  /**
   * Initialize Control
   * @ko Control을 초기화합니다
   * @param {Flicking} flicking An instance of {@link Flicking}<ko>Flicking의 인스턴스</ko>
   * @chainable
   * @return {this}
   */
  __proto.init = function (flicking) {
    this._flicking = flicking;
    this._controller.init(flicking);
    return this;
  };
  /**
   * Destroy Control and return to initial state
   * @ko Control을 초기 상태로 되돌립니다
   * @return {void}
   */
  __proto.destroy = function () {
    this._controller.destroy();
    this._flicking = null;
    this._activePanel = null;
  };
  /**
   * Enable input from the user (mouse/touch)
   * @ko 사용자의 입력(마우스/터치)를 활성화합니다
   * @chainable
   * @return {this}
   */
  __proto.enable = function () {
    this._controller.enable();
    return this;
  };
  /**
   * Disable input from the user (mouse/touch)
   * @ko 사용자의 입력(마우스/터치)를 막습니다
   * @chainable
   * @return {this}
   */
  __proto.disable = function () {
    this._controller.disable();
    return this;
  };
  /**
   * Releases ongoing user input (mouse/touch)
   * @ko 사용자의 현재 입력(마우스/터치)를 중단시킵니다
   * @chainable
   * @return {this}
   */
  __proto.release = function () {
    this._controller.release();
    return this;
  };
  /**
   * Change the destination and duration of the animation currently playing
   * @ko 재생 중인 애니메이션의 목적지와 재생 시간을 변경합니다
   * @param {Panel} panel The target panel to move<ko>이동할 패널</ko>
   * @param {number} duration Duration of the animation (unit: ms)<ko>애니메이션 진행 시간 (단위: ms)</ko>
   * @param {DIRECTION} direction Direction to move, only available in the {@link Flicking#circular circular} mode<ko>이동할 방향. {@link Flicking#circular circular} 옵션 활성화시에만 사용 가능합니다</ko>
   * @chainable
   * @throws {FlickingError}
   * {@link ERROR_CODE POSITION_NOT_REACHABLE} When the given panel is already removed or not in the Camera's {@link Camera#range range}
   * <ko>{@link ERROR_CODE POSITION_NOT_REACHABLE} 주어진 패널이 제거되었거나, Camera의 {@link Camera#range range} 밖에 있을 경우</ko>
   * @return {this}
   */
  __proto.updateAnimation = function (panel, duration, direction) {
    var state = this._controller.state;
    var position = this._getPosition(panel, direction !== null && direction !== void 0 ? direction : DIRECTION.NONE);
    state.targetPanel = panel;
    this._controller.updateAnimation(position, duration);
    return this;
  };
  /**
   * Stops the animation currently playing
   * @ko 재생 중인 애니메이션을 중단시킵니다
   * @chainable
   * @return {this}
   */
  __proto.stopAnimation = function () {
    var state = this._controller.state;
    state.targetPanel = null;
    this._controller.stopAnimation();
    return this;
  };
  /**
   * Update position after resizing
   * @ko resize 이후에 position을 업데이트합니다
   * @param {number} progressInPanel Previous camera's progress in active panel before resize<ko>Resize 이전 현재 선택된 패널 내에서의 카메라 progress 값</ko>
   * @throws {FlickingError}
   * {@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} When {@link Camera#init init} is not called before
   * <ko>{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} {@link Camera#init init}이 이전에 호출되지 않은 경우</ko>
   * @chainable
   * @return {Promise<void>}
   */
  __proto.updatePosition = function (progressInPanel) {
    var flicking = getFlickingAttached(this._flicking);
    var camera = flicking.camera;
    var activePanel = this._activePanel;
    if (activePanel) {
      camera.lookAt(camera.clampToReachablePosition(activePanel.position));
    }
  };
  /**
   * Update {@link Control#controller controller}'s state
   * @ko {@link Control#controller controller}의 내부 상태를 갱신합니다
   * @chainable
   * @return {this}
   */
  __proto.updateInput = function () {
    var flicking = getFlickingAttached(this._flicking);
    var camera = flicking.camera;
    this._controller.update(camera.controlParams);
    return this;
  };
  /**
   * Reset {@link Control#activePanel activePanel} to `null`
   * @ko {@link Control#activePanel activePanel}을 `null`로 초기화합니다
   * @chainable
   * @return {this}
   */
  __proto.resetActive = function () {
    this._activePanel = null;
    return this;
  };
  /**
   * Move {@link Camera} to the given panel
   * @ko {@link Camera}를 해당 패널 위로 이동합니다
   * @param {Panel} panel The target panel to move<ko>이동할 패널</ko>
   * @param {object} options An options object<ko>옵션 오브젝트</ko>
   * @param {number} duration Duration of the animation (unit: ms)<ko>애니메이션 진행 시간 (단위: ms)</ko>
   * @param {object} [axesEvent] {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} event of {@link https://naver.github.io/egjs-axes/ Axes}
   * <ko>{@link https://naver.github.io/egjs-axes/ Axes}의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} 이벤트</ko>
   * @param {DIRECTION} [direction=DIRECTION.NONE] Direction to move, only available in the {@link Flicking#circular circular} mode<ko>이동할 방향. {@link Flicking#circular circular} 옵션 활성화시에만 사용 가능합니다</ko>
   * @fires Flicking#moveStart
   * @fires Flicking#move
   * @fires Flicking#moveEnd
   * @fires Flicking#willChange
   * @fires Flicking#changed
   * @fires Flicking#willRestore
   * @fires Flicking#restored
   * @fires Flicking#needPanel
   * @fires Flicking#visibleChange
   * @fires Flicking#reachEdge
   * @throws {FlickingError}
   * |code|condition|
   * |---|---|
   * |{@link ERROR_CODE POSITION_NOT_REACHABLE}|When the given panel is already removed or not in the Camera's {@link Camera#range range}|
   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|When {@link Control#init init} is not called before|
   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|When the animation is interrupted by user input|
   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|When the animation is interrupted by user input|
   * <ko>
   *
   * |code|condition|
   * |---|---|
   * |{@link ERROR_CODE POSITION_NOT_REACHABLE}|주어진 패널이 제거되었거나, Camera의 {@link Camera#range range} 밖에 있을 경우|
   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|{@link Control#init init}이 이전에 호출되지 않은 경우|
   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|사용자 입력에 의해 애니메이션이 중단된 경우|
   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|발생된 이벤트들 중 하나라도 `stop()`이 호출된 경우|
   *
   * </ko>
   * @return {Promise<void>} A Promise which will be resolved after reaching the target panel<ko>해당 패널 도달시에 resolve되는 Promise</ko>
   */
  __proto.moveToPanel = function (panel, _a) {
    var duration = _a.duration,
      _b = _a.direction,
      direction = _b === void 0 ? DIRECTION.NONE : _b,
      axesEvent = _a.axesEvent;
    return __awaiter(this, void 0, void 0, function () {
      var position;
      return __generator(this, function (_c) {
        position = this._getPosition(panel, direction);
        this._triggerIndexChangeEvent(panel, panel.position, axesEvent, direction);
        return [2 /*return*/, this._animateToPosition({
          position: position,
          duration: duration,
          newActivePanel: panel,
          axesEvent: axesEvent
        })];
      });
    });
  };
  /**
   * @internal
   */
  __proto.setActive = function (newActivePanel, prevActivePanel, isTrusted) {
    var _a;
    var flicking = getFlickingAttached(this._flicking);
    this._activePanel = newActivePanel;
    this._nextPanel = null;
    flicking.camera.updateAdaptiveHeight();
    if (newActivePanel !== prevActivePanel) {
      flicking.trigger(new ComponentEvent$1(EVENTS.CHANGED, {
        index: newActivePanel.index,
        panel: newActivePanel,
        prevIndex: (_a = prevActivePanel === null || prevActivePanel === void 0 ? void 0 : prevActivePanel.index) !== null && _a !== void 0 ? _a : -1,
        prevPanel: prevActivePanel,
        isTrusted: isTrusted,
        direction: prevActivePanel ? getDirection$1(prevActivePanel.position, newActivePanel.position) : DIRECTION.NONE
      }));
    } else {
      flicking.trigger(new ComponentEvent$1(EVENTS.RESTORED, {
        isTrusted: isTrusted
      }));
    }
  };
  /**
   * @internal
   */
  __proto.copy = function (control) {
    this._flicking = control._flicking;
    this._activePanel = control._activePanel;
    this._controller = control._controller;
  };
  __proto._triggerIndexChangeEvent = function (panel, position, axesEvent, direction) {
    var _a;
    var flicking = getFlickingAttached(this._flicking);
    var triggeringEvent = panel !== this._activePanel ? EVENTS.WILL_CHANGE : EVENTS.WILL_RESTORE;
    var camera = flicking.camera;
    var activePanel = this._activePanel;
    var event = new ComponentEvent$1(triggeringEvent, {
      index: panel.index,
      panel: panel,
      isTrusted: (axesEvent === null || axesEvent === void 0 ? void 0 : axesEvent.isTrusted) || false,
      direction: direction !== null && direction !== void 0 ? direction : getDirection$1((_a = activePanel === null || activePanel === void 0 ? void 0 : activePanel.position) !== null && _a !== void 0 ? _a : camera.position, position)
    });
    this._nextPanel = panel;
    flicking.trigger(event);
    if (event.isCanceled()) {
      throw new FlickingError(MESSAGE.STOP_CALLED_BY_USER, CODE.STOP_CALLED_BY_USER);
    }
  };
  __proto._animateToPosition = function (_a) {
    var position = _a.position,
      duration = _a.duration,
      newActivePanel = _a.newActivePanel,
      axesEvent = _a.axesEvent;
    return __awaiter(this, void 0, void 0, function () {
      var flicking, animate, state;
      var _this = this;
      return __generator(this, function (_b) {
        flicking = getFlickingAttached(this._flicking);
        animate = function () {
          return _this._controller.animateTo(position, duration, axesEvent);
        };
        state = this._controller.state;
        state.targetPanel = newActivePanel;
        if (duration <= 0) {
          return [2 /*return*/, animate()];
        } else {
          return [2 /*return*/, animate().then(function () {
            return __awaiter(_this, void 0, void 0, function () {
              return __generator(this, function (_a) {
                switch (_a.label) {
                  case 0:
                    return [4 /*yield*/, flicking.renderer.render()];
                  case 1:
                    _a.sent();
                    return [2 /*return*/];
                }
              });
            });
          }).catch(function (err) {
            if (axesEvent && err instanceof FlickingError && err.code === CODE.ANIMATION_INTERRUPTED) return;
            throw err;
          })];
        }
      });
    });
  };

  __proto._getPosition = function (panel, direction) {
    if (direction === void 0) {
      direction = DIRECTION.NONE;
    }
    var flicking = getFlickingAttached(this._flicking);
    var camera = flicking.camera;
    var position = panel.position;
    var nearestAnchor = camera.findNearestAnchor(position);
    if (panel.removed || !nearestAnchor) {
      throw new FlickingError(MESSAGE.POSITION_NOT_REACHABLE(panel.position), CODE.POSITION_NOT_REACHABLE);
    }
    if (!camera.canReach(panel)) {
      // Override position & panel if that panel is not reachable
      position = nearestAnchor.position;
      panel = nearestAnchor.panel;
    } else if (flicking.circularEnabled) {
      // Circular mode is enabled, find nearest distance to panel
      var camPos_1 = this._controller.position; // Actual position of the Axes
      var camRangeDiff = camera.rangeDiff;
      var possiblePositions = [position, position + camRangeDiff, position - camRangeDiff].filter(function (pos) {
        if (direction === DIRECTION.NONE) return true;
        return direction === DIRECTION.PREV ? pos <= camPos_1 : pos >= camPos_1;
      });
      position = possiblePositions.reduce(function (nearestPosition, pos) {
        if (Math.abs(camPos_1 - pos) < Math.abs(camPos_1 - nearestPosition)) {
          return pos;
        } else {
          return nearestPosition;
        }
      }, Infinity);
    }
    return position;
  };
  return Control;
}();

/**
 * A data component that has actual position where the camera should be stopped at
 * @ko 카메라가 정지해야하는 실제 위치를 담고 있는 데이터 컴포넌트
 */
var AnchorPoint = /*#__PURE__*/function () {
  /**
   * @param {object} options An options object<ko>옵션 객체</ko>
   * @param {number} [options.index] Index of AnchorPoint<ko>AnchorPoint의 인덱스</ko>
   * @param {number} [options.position] Position of AnchorPoint<ko>AnchorPoint의 좌표</ko>
   * @param {Panel} [options.panel] A {@link Panel} instance AnchorPoint is referencing to<ko>AnchorPoint가 참조하고 있는 {@link Panel}</ko>
   */
  function AnchorPoint(_a) {
    var index = _a.index,
      position = _a.position,
      panel = _a.panel;
    this._index = index;
    this._pos = position;
    this._panel = panel;
  }
  var __proto = AnchorPoint.prototype;
  Object.defineProperty(__proto, "index", {
    /**
     * Index of AnchorPoint
     * @ko AnchorPoint의 인덱스
     * @type {number}
     * @readonly
     */
    get: function () {
      return this._index;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "position", {
    /**
     * Position of AnchorPoint
     * @ko AnchorPoint의 좌표
     * @type {number}
     * @readonly
     */
    get: function () {
      return this._pos;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "panel", {
    /**
     * A {@link Panel} instance AnchorPoint is referencing to
     * @ko AnchorPoint가 참조하고 있는 {@link Panel}
     * @type {Panel}
     * @readonly
     */
    get: function () {
      return this._panel;
    },
    enumerable: false,
    configurable: true
  });
  return AnchorPoint;
}();

/**
 * A {@link Control} that uses a release momentum to choose destination panel
 * @ko 입력을 중단한 시점의 가속도에 영향받아 도달할 패널을 계산하는 이동 방식을 사용하는 {@link Control}
 */
var SnapControl = /*#__PURE__*/function (_super) {
  __extends$3(SnapControl, _super);
  /** */
  function SnapControl(_a) {
    var _b = (_a === void 0 ? {} : _a).count,
      count = _b === void 0 ? Infinity : _b;
    var _this = _super.call(this) || this;
    _this._count = count;
    return _this;
  }
  var __proto = SnapControl.prototype;
  Object.defineProperty(__proto, "count", {
    /**
     * Maximum number of panels can go after release
     * @ko 입력 중단 이후 통과하여 이동할 수 있는 패널의 최대 갯수
     * @type {number}
     * @default Infinity
     */
    get: function () {
      return this._count;
    },
    set: function (val) {
      this._count = val;
    },
    enumerable: false,
    configurable: true
  });
  /**
   * Move {@link Camera} to the given position
   * @ko {@link Camera}를 주어진 좌표로 이동합니다
   * @param {number} position The target position to move<ko>이동할 좌표</ko>
   * @param {number} duration Duration of the panel movement animation (unit: ms).<ko>패널 이동 애니메이션 진행 시간 (단위: ms)</ko>
   * @param {object} [axesEvent] {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} event of {@link https://naver.github.io/egjs-axes/ Axes}
   * <ko>{@link https://naver.github.io/egjs-axes/ Axes}의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} 이벤트</ko>
   * @fires Flicking#moveStart
   * @fires Flicking#move
   * @fires Flicking#moveEnd
   * @fires Flicking#willChange
   * @fires Flicking#changed
   * @fires Flicking#willRestore
   * @fires Flicking#restored
   * @fires Flicking#needPanel
   * @fires Flicking#visibleChange
   * @fires Flicking#reachEdge
   * @throws {FlickingError}
   * |code|condition|
   * |---|---|
   * |{@link ERROR_CODE POSITION_NOT_REACHABLE}|When the given panel is already removed or not in the Camera's {@link Camera#range range}|
   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|When {@link Control#init init} is not called before|
   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|When the animation is interrupted by user input|
   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|When the animation is interrupted by user input|
   * <ko>
   *
   * |code|condition|
   * |---|---|
   * |{@link ERROR_CODE POSITION_NOT_REACHABLE}|주어진 패널이 제거되었거나, Camera의 {@link Camera#range range} 밖에 있을 경우|
   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|{@link Control#init init}이 이전에 호출되지 않은 경우|
   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|사용자 입력에 의해 애니메이션이 중단된 경우|
   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|발생된 이벤트들 중 하나라도 `stop()`이 호출된 경우|
   *
   * </ko>
   * @return {Promise<void>} A Promise which will be resolved after reaching the target position<ko>해당 좌표 도달시에 resolve되는 Promise</ko>
   */
  __proto.moveToPosition = function (position, duration, axesEvent) {
    var flicking = getFlickingAttached(this._flicking);
    var camera = flicking.camera;
    var activeAnchor = camera.findActiveAnchor();
    var anchorAtCamera = camera.findNearestAnchor(camera.position);
    var state = this._controller.state;
    if (!activeAnchor || !anchorAtCamera) {
      return Promise.reject(new FlickingError(MESSAGE.POSITION_NOT_REACHABLE(position), CODE.POSITION_NOT_REACHABLE));
    }
    var snapThreshold = this._calcSnapThreshold(flicking.threshold, position, activeAnchor);
    var posDelta = flicking.animating ? state.delta : position - camera.position;
    var absPosDelta = Math.abs(posDelta);
    var snapDelta = axesEvent && axesEvent.delta[POSITION_KEY] !== 0 ? Math.abs(axesEvent.delta[POSITION_KEY]) : absPosDelta;
    var targetAnchor;
    if (snapDelta >= snapThreshold && snapDelta > 0) {
      // Move to anchor at position
      targetAnchor = this._findSnappedAnchor(position, anchorAtCamera);
    } else if (absPosDelta >= flicking.threshold && absPosDelta > 0) {
      // Move to the adjacent panel
      targetAnchor = this._findAdjacentAnchor(position, posDelta, anchorAtCamera);
    } else {
      // Fallback to nearest panel from current camera
      return this.moveToPanel(anchorAtCamera.panel, {
        duration: duration,
        axesEvent: axesEvent
      });
    }
    this._triggerIndexChangeEvent(targetAnchor.panel, position, axesEvent);
    return this._animateToPosition({
      position: camera.clampToReachablePosition(targetAnchor.position),
      duration: duration,
      newActivePanel: targetAnchor.panel,
      axesEvent: axesEvent
    });
  };
  __proto._findSnappedAnchor = function (position, anchorAtCamera) {
    var flicking = getFlickingAttached(this._flicking);
    var camera = flicking.camera;
    var count = this._count;
    var currentPos = camera.position;
    var clampedPosition = camera.clampToReachablePosition(position);
    var anchorAtPosition = camera.findAnchorIncludePosition(clampedPosition);
    if (!anchorAtCamera || !anchorAtPosition) {
      throw new FlickingError(MESSAGE.POSITION_NOT_REACHABLE(position), CODE.POSITION_NOT_REACHABLE);
    }
    if (!isFinite(count)) {
      return anchorAtPosition;
    }
    var panelCount = flicking.panelCount;
    var anchors = camera.anchorPoints;
    var loopCount = Math.sign(position - currentPos) * Math.floor(Math.abs(position - currentPos) / camera.rangeDiff);
    if (position > currentPos && anchorAtPosition.index < anchorAtCamera.index || anchorAtPosition.position > anchorAtCamera.position && anchorAtPosition.index === anchorAtCamera.index) {
      loopCount += 1;
    } else if (position < currentPos && anchorAtPosition.index > anchorAtCamera.index || anchorAtPosition.position < anchorAtCamera.position && anchorAtPosition.index === anchorAtCamera.index) {
      loopCount -= 1;
    }
    var circularIndexOffset = loopCount * panelCount;
    var anchorAtPositionIndex = anchorAtPosition.index + circularIndexOffset;
    if (Math.abs(anchorAtPositionIndex - anchorAtCamera.index) <= count) {
      var anchor = anchors[anchorAtPosition.index];
      return new AnchorPoint({
        index: anchor.index,
        position: anchor.position + loopCount * camera.rangeDiff,
        panel: anchor.panel
      });
    }
    if (flicking.circularEnabled) {
      var targetAnchor = anchors[circulateIndex(anchorAtCamera.index + Math.sign(position - currentPos) * count, panelCount)];
      var loop = Math.floor(count / panelCount);
      if (position > currentPos && targetAnchor.index < anchorAtCamera.index) {
        loop += 1;
      } else if (position < currentPos && targetAnchor.index > anchorAtCamera.index) {
        loop -= 1;
      }
      return new AnchorPoint({
        index: targetAnchor.index,
        position: targetAnchor.position + loop * camera.rangeDiff,
        panel: targetAnchor.panel
      });
    } else {
      return anchors[clamp$1(anchorAtCamera.index + Math.sign(position - currentPos) * count, 0, anchors.length - 1)];
    }
  };
  __proto._findAdjacentAnchor = function (position, posDelta, anchorAtCamera) {
    var _a;
    var flicking = getFlickingAttached(this._flicking);
    var camera = flicking.camera;
    if (camera.circularEnabled) {
      var anchorIncludePosition = camera.findAnchorIncludePosition(position);
      if (anchorIncludePosition && anchorIncludePosition.position !== anchorAtCamera.position) {
        return anchorIncludePosition;
      }
    }
    var adjacentAnchor = (_a = posDelta > 0 ? camera.getNextAnchor(anchorAtCamera) : camera.getPrevAnchor(anchorAtCamera)) !== null && _a !== void 0 ? _a : anchorAtCamera;
    return adjacentAnchor;
  };
  __proto._calcSnapThreshold = function (threshold, position, activeAnchor) {
    var isNextDirection = position > activeAnchor.position;
    var panel = activeAnchor.panel;
    var panelSize = panel.size;
    var alignPos = panel.alignPosition;
    // Minimum distance needed to decide prev/next panel as nearest
    /*
     * |  Prev  |     Next     |
     * |<------>|<------------>|
     * [        |<-Anchor      ]
     */
    return Math.max(threshold, isNextDirection ? panelSize - alignPos + panel.margin.next : alignPos + panel.margin.prev);
  };
  return SnapControl;
}(Control);

/**
 * A {@link Control} that can be scrolled freely without alignment
 * @ko 패널이 정해진 지점에 정렬되지 않고, 자유롭게 스크롤할 수 있는 이동 방식을 사용하는 {@link Control}
 */
var FreeControl = /*#__PURE__*/function (_super) {
  __extends$3(FreeControl, _super);
  /** */
  function FreeControl(_a) {
    var _b = (_a === void 0 ? {} : _a).stopAtEdge,
      stopAtEdge = _b === void 0 ? true : _b;
    var _this = _super.call(this) || this;
    _this._stopAtEdge = stopAtEdge;
    return _this;
  }
  var __proto = FreeControl.prototype;
  Object.defineProperty(__proto, "stopAtEdge", {
    /**
     * Make scroll animation to stop at the start/end of the scroll area, not going out the bounce area
     * @ko 스크롤 애니메이션을 스크롤 영역의 시작과 끝부분에서 멈추도록 하여, 바운스 영역을 넘어가지 않도록 합니다
     * @type {boolean}
     * @default true
     */
    get: function () {
      return this._stopAtEdge;
    },
    set: function (val) {
      this._stopAtEdge = val;
    },
    enumerable: false,
    configurable: true
  });
  /**
   * Update position after resizing
   * @ko resize 이후에 position을 업데이트합니다
   * @param {number} progressInPanel Previous camera's progress in active panel before resize<ko>Resize 이전 현재 선택된 패널 내에서의 카메라 progress 값</ko>
   * @throws {FlickingError}
   * {@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} When {@link Camera#init init} is not called before
   * <ko>{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} {@link Camera#init init}이 이전에 호출되지 않은 경우</ko>
   * @chainable
   * @return {Promise<void>}
   */
  __proto.updatePosition = function (progressInPanel) {
    var flicking = getFlickingAttached(this._flicking);
    var camera = flicking.camera;
    var activePanel = this._activePanel;
    if (activePanel) {
      var panelRange = activePanel.range;
      var newPosition = panelRange.min + (panelRange.max - panelRange.min) * progressInPanel;
      camera.lookAt(camera.clampToReachablePosition(newPosition));
    }
  };
  /**
   * Move {@link Camera} to the given position
   * @ko {@link Camera}를 주어진 좌표로 이동합니다
   * @param {number} position The target position to move<ko>이동할 좌표</ko>
   * @param {number} duration Duration of the panel movement animation (unit: ms).<ko>패널 이동 애니메이션 진행 시간 (단위: ms)</ko>
   * @param {object} [axesEvent] {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} event of {@link https://naver.github.io/egjs-axes/ Axes}
   * <ko>{@link https://naver.github.io/egjs-axes/ Axes}의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} 이벤트</ko>
   * @fires Flicking#moveStart
   * @fires Flicking#move
   * @fires Flicking#moveEnd
   * @fires Flicking#willChange
   * @fires Flicking#changed
   * @fires Flicking#willRestore
   * @fires Flicking#restored
   * @fires Flicking#needPanel
   * @fires Flicking#visibleChange
   * @fires Flicking#reachEdge
   * @throws {FlickingError}
   * |code|condition|
   * |---|---|
   * |{@link ERROR_CODE POSITION_NOT_REACHABLE}|When the given panel is already removed or not in the Camera's {@link Camera#range range}|
   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|When {@link Control#init init} is not called before|
   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|When the animation is interrupted by user input|
   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|When the animation is interrupted by user input|
   * <ko>
   *
   * |code|condition|
   * |---|---|
   * |{@link ERROR_CODE POSITION_NOT_REACHABLE}|주어진 패널이 제거되었거나, Camera의 {@link Camera#range range} 밖에 있을 경우|
   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|{@link Control#init init}이 이전에 호출되지 않은 경우|
   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|사용자 입력에 의해 애니메이션이 중단된 경우|
   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|발생된 이벤트들 중 하나라도 `stop()`이 호출된 경우|
   *
   * </ko>
   * @return {Promise<void>} A Promise which will be resolved after reaching the target position<ko>해당 좌표 도달시에 resolve되는 Promise</ko>
   */
  __proto.moveToPosition = function (position, duration, axesEvent) {
    var flicking = getFlickingAttached(this._flicking);
    var camera = flicking.camera;
    var targetPos = camera.clampToReachablePosition(position);
    var anchorAtPosition = camera.findAnchorIncludePosition(targetPos);
    if (!anchorAtPosition) {
      return Promise.reject(new FlickingError(MESSAGE.POSITION_NOT_REACHABLE(position), CODE.POSITION_NOT_REACHABLE));
    }
    var targetPanel = anchorAtPosition.panel;
    // Trigger only change event
    if (targetPanel !== this._activePanel) {
      this._triggerIndexChangeEvent(targetPanel, position, axesEvent);
    }
    return this._animateToPosition({
      position: this._stopAtEdge ? targetPos : position,
      duration: duration,
      newActivePanel: targetPanel,
      axesEvent: axesEvent
    });
  };
  return FreeControl;
}(Control);

/**
 * A {@link Control} that allow you to select the maximum number of panels to move at a time
 * @ko 한번에 최대로 이동할 패널의 개수를 선택 가능한 {@link Control}
 */
var StrictControl = /*#__PURE__*/function (_super) {
  __extends$3(StrictControl, _super);
  /** */
  function StrictControl(_a) {
    var _b = (_a === void 0 ? {} : _a).count,
      count = _b === void 0 ? 1 : _b;
    var _this = _super.call(this) || this;
    _this.setActive = function (newActivePanel, prevActivePanel, isTrusted) {
      _super.prototype.setActive.call(_this, newActivePanel, prevActivePanel, isTrusted);
      _this.updateInput();
    };
    _this._count = count;
    _this._resetIndexRange();
    return _this;
  }
  var __proto = StrictControl.prototype;
  Object.defineProperty(__proto, "count", {
    /**
     * Maximum number of panels that can be moved at a time
     * @ko 최대로 움직일 수 있는 패널의 개수
     * @type {number}
     * @default 1
     */
    get: function () {
      return this._count;
    },
    set: function (val) {
      this._count = val;
    },
    enumerable: false,
    configurable: true
  });
  /**
   * Destroy Control and return to initial state
   * @ko Control을 초기 상태로 되돌립니다
   * @return {void}
   */
  __proto.destroy = function () {
    _super.prototype.destroy.call(this);
    this._resetIndexRange();
  };
  /**
   * Update {@link Control#controller controller}'s state
   * @ko {@link Control#controller controller}의 내부 상태를 갱신합니다
   * @chainable
   * @return {this}
   */
  __proto.updateInput = function () {
    var _a;
    var flicking = getFlickingAttached(this._flicking);
    var camera = flicking.camera;
    var renderer = flicking.renderer;
    var controller = this._controller;
    var controlParams = camera.controlParams;
    var count = this._count;
    var activePanel = controller.state.animating ? (_a = camera.findNearestAnchor(camera.position)) === null || _a === void 0 ? void 0 : _a.panel : this._activePanel;
    if (!activePanel) {
      controller.update(controlParams);
      this._resetIndexRange();
      return this;
    }
    var cameraRange = controlParams.range;
    var currentPos = activePanel.position;
    var currentIndex = activePanel.index;
    var panelCount = renderer.panelCount;
    var prevPanelIndex = currentIndex - count;
    var nextPanelIndex = currentIndex + count;
    if (prevPanelIndex < 0) {
      prevPanelIndex = flicking.circularEnabled ? getMinusCompensatedIndex((prevPanelIndex + 1) % panelCount - 1, panelCount) : clamp$1(prevPanelIndex, 0, panelCount - 1);
    }
    if (nextPanelIndex >= panelCount) {
      nextPanelIndex = flicking.circularEnabled ? nextPanelIndex % panelCount : clamp$1(nextPanelIndex, 0, panelCount - 1);
    }
    var prevPanel = renderer.panels[prevPanelIndex];
    var nextPanel = renderer.panels[nextPanelIndex];
    var prevPos = Math.max(prevPanel.position, cameraRange.min);
    var nextPos = Math.min(nextPanel.position, cameraRange.max);
    if (prevPos > currentPos) {
      prevPos -= camera.rangeDiff;
    }
    if (nextPos < currentPos) {
      nextPos += camera.rangeDiff;
    }
    controlParams.range = {
      min: prevPos,
      max: nextPos
    };
    if (controlParams.circular) {
      if (controlParams.position < prevPos) {
        controlParams.position += camera.rangeDiff;
      }
      if (controlParams.position > nextPos) {
        controlParams.position -= camera.rangeDiff;
      }
    }
    controlParams.circular = false;
    controller.update(controlParams);
    this._indexRange = {
      min: prevPanel.index,
      max: nextPanel.index
    };
    return this;
  };
  __proto.moveToPanel = function (panel, options) {
    return __awaiter(this, void 0, void 0, function () {
      var flicking, camera, controller;
      return __generator(this, function (_a) {
        flicking = getFlickingAttached(this._flicking);
        camera = flicking.camera;
        controller = this._controller;
        controller.update(camera.controlParams);
        return [2 /*return*/, _super.prototype.moveToPanel.call(this, panel, options)];
      });
    });
  };
  /**
   * Move {@link Camera} to the given position
   * @ko {@link Camera}를 주어진 좌표로 이동합니다
   * @param {number} position The target position to move<ko>이동할 좌표</ko>
   * @param {number} duration Duration of the panel movement animation (unit: ms).<ko>패널 이동 애니메이션 진행 시간 (단위: ms)</ko>
   * @param {object} [axesEvent] {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} event of {@link https://naver.github.io/egjs-axes/ Axes}
   * <ko>{@link https://naver.github.io/egjs-axes/ Axes}의 {@link https://naver.github.io/egjs-axes/release/latest/doc/eg.Axes.html#event:release release} 이벤트</ko>
   * @fires Flicking#moveStart
   * @fires Flicking#move
   * @fires Flicking#moveEnd
   * @fires Flicking#willChange
   * @fires Flicking#changed
   * @fires Flicking#willRestore
   * @fires Flicking#restored
   * @fires Flicking#needPanel
   * @fires Flicking#visibleChange
   * @fires Flicking#reachEdge
   * @throws {FlickingError}
   * |code|condition|
   * |---|---|
   * |{@link ERROR_CODE POSITION_NOT_REACHABLE}|When the given panel is already removed or not in the Camera's {@link Camera#range range}|
   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|When {@link Control#init init} is not called before|
   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|When the animation is interrupted by user input|
   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|When the animation is interrupted by user input|
   * <ko>
   *
   * |code|condition|
   * |---|---|
   * |{@link ERROR_CODE POSITION_NOT_REACHABLE}|주어진 패널이 제거되었거나, Camera의 {@link Camera#range range} 밖에 있을 경우|
   * |{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING}|{@link Control#init init}이 이전에 호출되지 않은 경우|
   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|사용자 입력에 의해 애니메이션이 중단된 경우|
   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|발생된 이벤트들 중 하나라도 `stop()`이 호출된 경우|
   *
   * </ko>
   * @return {Promise<void>} A Promise which will be resolved after reaching the target position<ko>해당 좌표 도달시에 resolve되는 Promise</ko>
   */
  __proto.moveToPosition = function (position, duration, axesEvent) {
    var _a;
    var flicking = getFlickingAttached(this._flicking);
    var camera = flicking.camera;
    var currentPanel = (_a = this._nextPanel) !== null && _a !== void 0 ? _a : this._activePanel;
    var axesRange = this._controller.range;
    var indexRange = this._indexRange;
    var cameraRange = camera.range;
    var state = this._controller.state;
    var clampedPosition = clamp$1(camera.clampToReachablePosition(position), axesRange[0], axesRange[1]);
    var anchorAtPosition = camera.findAnchorIncludePosition(clampedPosition);
    if (!anchorAtPosition || !currentPanel) {
      return Promise.reject(new FlickingError(MESSAGE.POSITION_NOT_REACHABLE(position), CODE.POSITION_NOT_REACHABLE));
    }
    var prevPos = currentPanel.position;
    var posDelta = flicking.animating ? state.delta : position - camera.position;
    var isOverThreshold = Math.abs(posDelta) >= flicking.threshold;
    var adjacentAnchor = position > prevPos ? camera.getNextAnchor(anchorAtPosition) : camera.getPrevAnchor(anchorAtPosition);
    var targetPos;
    var targetPanel;
    var anchors = camera.anchorPoints;
    var firstAnchor = anchors[0];
    var lastAnchor = anchors[anchors.length - 1];
    var shouldBounceToFirst = position <= cameraRange.min && isBetween(firstAnchor.panel.index, indexRange.min, indexRange.max);
    var shouldBounceToLast = position >= cameraRange.max && isBetween(lastAnchor.panel.index, indexRange.min, indexRange.max);
    var isAdjacent = adjacentAnchor && (indexRange.min <= indexRange.max ? isBetween(adjacentAnchor.index, indexRange.min, indexRange.max) : adjacentAnchor.index >= indexRange.min || adjacentAnchor.index <= indexRange.max);
    if (shouldBounceToFirst || shouldBounceToLast) {
      // In bounce area
      var targetAnchor = position < cameraRange.min ? firstAnchor : lastAnchor;
      targetPanel = targetAnchor.panel;
      targetPos = targetAnchor.position;
    } else if (isOverThreshold && anchorAtPosition.position !== currentPanel.position) {
      // Move to anchor at position
      targetPanel = anchorAtPosition.panel;
      targetPos = anchorAtPosition.position;
    } else if (isOverThreshold && isAdjacent) {
      // Move to adjacent anchor
      targetPanel = adjacentAnchor.panel;
      targetPos = adjacentAnchor.position;
    } else {
      // Fallback to nearest panel from current camera
      var anchorAtCamera = camera.findNearestAnchor(camera.position);
      if (!anchorAtCamera) {
        return Promise.reject(new FlickingError(MESSAGE.POSITION_NOT_REACHABLE(position), CODE.POSITION_NOT_REACHABLE));
      }
      return this.moveToPanel(anchorAtCamera.panel, {
        duration: duration,
        axesEvent: axesEvent
      });
    }
    this._triggerIndexChangeEvent(targetPanel, position, axesEvent);
    return this._animateToPosition({
      position: targetPos,
      duration: duration,
      newActivePanel: targetPanel,
      axesEvent: axesEvent
    });
  };
  __proto._resetIndexRange = function () {
    this._indexRange = {
      min: 0,
      max: 0
    };
  };
  return StrictControl;
}(Control);

/**
 * A mode of camera
 */
var CameraMode = /*#__PURE__*/function () {
  /** */
  function CameraMode(flicking) {
    this._flicking = flicking;
  }
  var __proto = CameraMode.prototype;
  __proto.getAnchors = function () {
    var panels = this._flicking.renderer.panels;
    return panels.map(function (panel, index) {
      return new AnchorPoint({
        index: index,
        position: panel.position,
        panel: panel
      });
    });
  };
  __proto.findAnchorIncludePosition = function (position) {
    var anchors = this._flicking.camera.anchorPoints;
    var anchorsIncludingPosition = anchors.filter(function (anchor) {
      return anchor.panel.includePosition(position, true);
    });
    return anchorsIncludingPosition.reduce(function (nearest, anchor) {
      if (!nearest) return anchor;
      return Math.abs(nearest.position - position) < Math.abs(anchor.position - position) ? nearest : anchor;
    }, null);
  };
  __proto.findNearestAnchor = function (position) {
    var anchors = this._flicking.camera.anchorPoints;
    if (anchors.length <= 0) return null;
    var prevDist = Infinity;
    for (var anchorIdx = 0; anchorIdx < anchors.length; anchorIdx++) {
      var anchor = anchors[anchorIdx];
      var dist = Math.abs(anchor.position - position);
      if (dist > prevDist) {
        // Return previous anchor
        return anchors[anchorIdx - 1];
      }
      prevDist = dist;
    }
    // Return last anchor
    return anchors[anchors.length - 1];
  };
  __proto.clampToReachablePosition = function (position) {
    var camera = this._flicking.camera;
    var range = camera.range;
    return clamp$1(position, range.min, range.max);
  };
  __proto.getCircularOffset = function () {
    return 0;
  };
  __proto.canReach = function (panel) {
    var camera = this._flicking.camera;
    var range = camera.range;
    if (panel.removed) return false;
    var panelPos = panel.position;
    return panelPos >= range.min && panelPos <= range.max;
  };
  __proto.canSee = function (panel) {
    var camera = this._flicking.camera;
    var visibleRange = camera.visibleRange;
    // Should not include margin, as we don't declare what the margin is visible as what the panel is visible.
    return panel.isVisibleOnRange(visibleRange.min, visibleRange.max);
  };
  return CameraMode;
}();

var LinearCameraMode = /*#__PURE__*/function (_super) {
  __extends$3(LinearCameraMode, _super);
  function LinearCameraMode() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  var __proto = LinearCameraMode.prototype;
  __proto.checkAvailability = function () {
    // It's always available
    return true;
  };
  __proto.getRange = function () {
    var _a, _b;
    var renderer = this._flicking.renderer;
    var firstPanel = renderer.getPanel(0);
    var lastPanel = renderer.getPanel(renderer.panelCount - 1);
    return {
      min: (_a = firstPanel === null || firstPanel === void 0 ? void 0 : firstPanel.position) !== null && _a !== void 0 ? _a : 0,
      max: (_b = lastPanel === null || lastPanel === void 0 ? void 0 : lastPanel.position) !== null && _b !== void 0 ? _b : 0
    };
  };
  return LinearCameraMode;
}(CameraMode);

/**
 * A {@link Camera} mode that connects the last panel and the first panel, enabling continuous loop
 * @ko 첫번째 패널과 마지막 패널이 이어진 상태로, 무한히 회전할 수 있는 종류의 {@link Camera} 모드
 */
var CircularCameraMode = /*#__PURE__*/function (_super) {
  __extends$3(CircularCameraMode, _super);
  function CircularCameraMode() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  var __proto = CircularCameraMode.prototype;
  __proto.checkAvailability = function () {
    var flicking = this._flicking;
    var renderer = flicking.renderer;
    var panels = renderer.panels;
    if (panels.length <= 0) {
      return false;
    }
    var firstPanel = panels[0];
    var lastPanel = panels[panels.length - 1];
    var firstPanelPrev = firstPanel.range.min - firstPanel.margin.prev;
    var lastPanelNext = lastPanel.range.max + lastPanel.margin.next;
    var visibleSize = flicking.camera.size;
    var panelSizeSum = lastPanelNext - firstPanelPrev;
    var canSetCircularMode = panels.every(function (panel) {
      return panelSizeSum - panel.size >= visibleSize;
    });
    return canSetCircularMode;
  };
  __proto.getRange = function () {
    var flicking = this._flicking;
    var panels = flicking.renderer.panels;
    if (panels.length <= 0) {
      return {
        min: 0,
        max: 0
      };
    }
    var firstPanel = panels[0];
    var lastPanel = panels[panels.length - 1];
    var firstPanelPrev = firstPanel.range.min - firstPanel.margin.prev;
    var lastPanelNext = lastPanel.range.max + lastPanel.margin.next;
    return {
      min: firstPanelPrev,
      max: lastPanelNext
    };
  };
  __proto.getAnchors = function () {
    var flicking = this._flicking;
    var panels = flicking.renderer.panels;
    return panels.map(function (panel, index) {
      return new AnchorPoint({
        index: index,
        position: panel.position,
        panel: panel
      });
    });
  };
  __proto.findNearestAnchor = function (position) {
    var camera = this._flicking.camera;
    var anchors = camera.anchorPoints;
    if (anchors.length <= 0) return null;
    var camRange = camera.range;
    var minDist = Infinity;
    var minDistIndex = -1;
    for (var anchorIdx = 0; anchorIdx < anchors.length; anchorIdx++) {
      var anchor = anchors[anchorIdx];
      var dist = Math.min(Math.abs(anchor.position - position), Math.abs(anchor.position - camRange.min + camRange.max - position), Math.abs(position - camRange.min + camRange.max - anchor.position));
      if (dist < minDist) {
        minDist = dist;
        minDistIndex = anchorIdx;
      }
    }
    // Return last anchor
    return anchors[minDistIndex];
  };
  __proto.findAnchorIncludePosition = function (position) {
    var camera = this._flicking.camera;
    var range = camera.range;
    var anchors = camera.anchorPoints;
    var rangeDiff = camera.rangeDiff;
    var anchorCount = anchors.length;
    var positionInRange = circulatePosition(position, range.min, range.max);
    var anchorInRange = _super.prototype.findAnchorIncludePosition.call(this, positionInRange);
    if (anchorCount > 0 && (position === range.min || position === range.max)) {
      var possibleAnchors = [anchorInRange, new AnchorPoint({
        index: 0,
        position: anchors[0].position + rangeDiff,
        panel: anchors[0].panel
      }), new AnchorPoint({
        index: anchorCount - 1,
        position: anchors[anchorCount - 1].position - rangeDiff,
        panel: anchors[anchorCount - 1].panel
      })].filter(function (anchor) {
        return !!anchor;
      });
      anchorInRange = possibleAnchors.reduce(function (nearest, anchor) {
        if (!nearest) return anchor;
        return Math.abs(nearest.position - position) < Math.abs(anchor.position - position) ? nearest : anchor;
      }, null);
    }
    if (!anchorInRange) return null;
    if (position < range.min) {
      var loopCount = -Math.floor((range.min - position) / rangeDiff) - 1;
      return new AnchorPoint({
        index: anchorInRange.index,
        position: anchorInRange.position + rangeDiff * loopCount,
        panel: anchorInRange.panel
      });
    } else if (position > range.max) {
      var loopCount = Math.floor((position - range.max) / rangeDiff) + 1;
      return new AnchorPoint({
        index: anchorInRange.index,
        position: anchorInRange.position + rangeDiff * loopCount,
        panel: anchorInRange.panel
      });
    }
    return anchorInRange;
  };
  __proto.getCircularOffset = function () {
    var flicking = this._flicking;
    var camera = flicking.camera;
    if (!camera.circularEnabled) return 0;
    var toggled = flicking.panels.filter(function (panel) {
      return panel.toggled;
    });
    var toggledPrev = toggled.filter(function (panel) {
      return panel.toggleDirection === DIRECTION.PREV;
    });
    var toggledNext = toggled.filter(function (panel) {
      return panel.toggleDirection === DIRECTION.NEXT;
    });
    return this._calcPanelAreaSum(toggledPrev) - this._calcPanelAreaSum(toggledNext);
  };
  __proto.clampToReachablePosition = function (position) {
    // Basically all position is reachable for circular camera
    return position;
  };
  __proto.canReach = function (panel) {
    if (panel.removed) return false;
    // Always reachable on circular mode
    return true;
  };
  __proto.canSee = function (panel) {
    var camera = this._flicking.camera;
    var range = camera.range;
    var rangeDiff = camera.rangeDiff;
    var visibleRange = camera.visibleRange;
    var visibleInCurrentRange = _super.prototype.canSee.call(this, panel);
    // Check looped visible area for circular case
    if (visibleRange.min < range.min) {
      return visibleInCurrentRange || panel.isVisibleOnRange(visibleRange.min + rangeDiff, visibleRange.max + rangeDiff);
    } else if (visibleRange.max > range.max) {
      return visibleInCurrentRange || panel.isVisibleOnRange(visibleRange.min - rangeDiff, visibleRange.max - rangeDiff);
    }
    return visibleInCurrentRange;
  };
  __proto._calcPanelAreaSum = function (panels) {
    return panels.reduce(function (sum, panel) {
      return sum + panel.sizeIncludingMargin;
    }, 0);
  };
  return CircularCameraMode;
}(CameraMode);

var BoundCameraMode = /*#__PURE__*/function (_super) {
  __extends$3(BoundCameraMode, _super);
  function BoundCameraMode() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  var __proto = BoundCameraMode.prototype;
  __proto.checkAvailability = function () {
    var flicking = this._flicking;
    var renderer = flicking.renderer;
    var firstPanel = renderer.getPanel(0);
    var lastPanel = renderer.getPanel(renderer.panelCount - 1);
    if (!firstPanel || !lastPanel) {
      return false;
    }
    var viewportSize = flicking.camera.size;
    var firstPanelPrev = firstPanel.range.min;
    var lastPanelNext = lastPanel.range.max;
    var panelAreaSize = lastPanelNext - firstPanelPrev;
    var isBiggerThanViewport = viewportSize < panelAreaSize;
    return isBiggerThanViewport;
  };
  __proto.getRange = function () {
    var flicking = this._flicking;
    var renderer = flicking.renderer;
    var alignPos = flicking.camera.alignPosition;
    var firstPanel = renderer.getPanel(0);
    var lastPanel = renderer.getPanel(renderer.panelCount - 1);
    if (!firstPanel || !lastPanel) {
      return {
        min: 0,
        max: 0
      };
    }
    var viewportSize = flicking.camera.size;
    var firstPanelPrev = firstPanel.range.min;
    var lastPanelNext = lastPanel.range.max;
    var panelAreaSize = lastPanelNext - firstPanelPrev;
    var isBiggerThanViewport = viewportSize < panelAreaSize;
    var firstPos = firstPanelPrev + alignPos;
    var lastPos = lastPanelNext - viewportSize + alignPos;
    if (isBiggerThanViewport) {
      return {
        min: firstPos,
        max: lastPos
      };
    } else {
      var align = flicking.camera.align;
      var alignVal = typeof align === "object" ? align.camera : align;
      var pos = firstPos + parseAlign$1(alignVal, lastPos - firstPos);
      return {
        min: pos,
        max: pos
      };
    }
  };
  __proto.getAnchors = function () {
    var flicking = this._flicking;
    var camera = flicking.camera;
    var panels = flicking.renderer.panels;
    if (panels.length <= 0) {
      return [];
    }
    var range = flicking.camera.range;
    var reachablePanels = panels.filter(function (panel) {
      return camera.canReach(panel);
    });
    if (reachablePanels.length > 0) {
      var shouldPrependBoundAnchor = reachablePanels[0].position !== range.min;
      var shouldAppendBoundAnchor = reachablePanels[reachablePanels.length - 1].position !== range.max;
      var indexOffset_1 = shouldPrependBoundAnchor ? 1 : 0;
      var newAnchors = reachablePanels.map(function (panel, idx) {
        return new AnchorPoint({
          index: idx + indexOffset_1,
          position: panel.position,
          panel: panel
        });
      });
      if (shouldPrependBoundAnchor) {
        newAnchors.splice(0, 0, new AnchorPoint({
          index: 0,
          position: range.min,
          panel: panels[reachablePanels[0].index - 1]
        }));
      }
      if (shouldAppendBoundAnchor) {
        newAnchors.push(new AnchorPoint({
          index: newAnchors.length,
          position: range.max,
          panel: panels[reachablePanels[reachablePanels.length - 1].index + 1]
        }));
      }
      return newAnchors;
    } else if (range.min !== range.max) {
      // There're more than 2 panels
      var nearestPanelAtMin = this._findNearestPanel(range.min, panels);
      var panelAtMin = nearestPanelAtMin.index === panels.length - 1 ? nearestPanelAtMin.prev() : nearestPanelAtMin;
      var panelAtMax = panelAtMin.next();
      return [new AnchorPoint({
        index: 0,
        position: range.min,
        panel: panelAtMin
      }), new AnchorPoint({
        index: 1,
        position: range.max,
        panel: panelAtMax
      })];
    } else {
      return [new AnchorPoint({
        index: 0,
        position: range.min,
        panel: this._findNearestPanel(range.min, panels)
      })];
    }
  };
  __proto.findAnchorIncludePosition = function (position) {
    var camera = this._flicking.camera;
    var range = camera.range;
    var anchors = camera.anchorPoints;
    if (anchors.length <= 0) return null;
    if (position <= range.min) {
      return anchors[0];
    } else if (position >= range.max) {
      return anchors[anchors.length - 1];
    } else {
      return _super.prototype.findAnchorIncludePosition.call(this, position);
    }
  };
  __proto._findNearestPanel = function (pos, panels) {
    var prevDist = Infinity;
    for (var panelIdx = 0; panelIdx < panels.length; panelIdx++) {
      var panel = panels[panelIdx];
      var dist = Math.abs(panel.position - pos);
      if (dist > prevDist) {
        // Return previous anchor
        return panels[panelIdx - 1];
      }
      prevDist = dist;
    }
    // Return last anchor
    return panels[panels.length - 1];
  };
  return BoundCameraMode;
}(CameraMode);

/**
 * A component that manages actual movement inside the viewport
 * @ko 뷰포트 내에서의 실제 움직임을 담당하는 컴포넌트
 */
var Camera = /*#__PURE__*/function () {
  /** */
  function Camera(flicking, _a) {
    var _this = this;
    var _b = (_a === void 0 ? {} : _a).align,
      align = _b === void 0 ? ALIGN.CENTER : _b;
    this._checkTranslateSupport = function () {
      var e_1, _a;
      var transforms = ["webkitTransform", "msTransform", "MozTransform", "OTransform", "transform"];
      var supportedStyle = document.documentElement.style;
      var transformName = "";
      try {
        for (var transforms_1 = __values$1(transforms), transforms_1_1 = transforms_1.next(); !transforms_1_1.done; transforms_1_1 = transforms_1.next()) {
          var prefixedTransform = transforms_1_1.value;
          if (prefixedTransform in supportedStyle) {
            transformName = prefixedTransform;
          }
        }
      } catch (e_1_1) {
        e_1 = {
          error: e_1_1
        };
      } finally {
        try {
          if (transforms_1_1 && !transforms_1_1.done && (_a = transforms_1.return)) _a.call(transforms_1);
        } finally {
          if (e_1) throw e_1.error;
        }
      }
      if (!transformName) {
        throw new FlickingError(MESSAGE.TRANSFORM_NOT_SUPPORTED, CODE.TRANSFORM_NOT_SUPPORTED);
      }
      _this._transform = transformName;
    };
    this._flicking = flicking;
    this._resetInternalValues();
    // Options
    this._align = align;
  }
  var __proto = Camera.prototype;
  Object.defineProperty(__proto, "element", {
    // Internal states getter
    /**
     * The camera element(`.flicking-camera`)
     * @ko 카메라 엘리먼트(`.flicking-camera`)
     * @type {HTMLElement}
     * @readonly
     */
    get: function () {
      return this._el;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "children", {
    /**
     * An array of the child elements of the camera element(`.flicking-camera`)
     * @ko 카메라 엘리먼트(`.flicking-camera`)의 자식 엘리먼트 배열
     * @type {HTMLElement[]}
     * @readonly
     */
    get: function () {
      return toArray$2(this._el.children);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "position", {
    /**
     * Current position of the camera
     * @ko Camera의 현재 좌표
     * @type {number}
     * @readonly
     */
    get: function () {
      return this._position;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "alignPosition", {
    /**
     * Align position inside the viewport where {@link Panel}'s {@link Panel#alignPosition alignPosition} should be located at
     * @ko 패널의 정렬 기준 위치. 뷰포트 내에서 {@link Panel}의 {@link Panel#alignPosition alignPosition}이 위치해야 하는 곳입니다
     * @type {number}
     * @readonly
     */
    get: function () {
      return this._alignPos;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "offset", {
    /**
     * Position offset, used for the {@link Flicking#renderOnlyVisible renderOnlyVisible} option
     * @ko Camera의 좌표 오프셋. {@link Flicking#renderOnlyVisible renderOnlyVisible} 옵션을 위해 사용됩니다.
     * @type {number}
     * @default 0
     * @readonly
     */
    get: function () {
      return this._offset - this._circularOffset;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "circularEnabled", {
    /**
     * Whether the `circular` option is enabled.
     * The {@link Flicking#circular circular} option can't be enabled when sum of the panel sizes are too small.
     * @ko {@link Flicking#circular circular} 옵션이 활성화되었는지 여부를 나타내는 멤버 변수.
     * {@link Flicking#circular circular} 옵션은 패널의 크기의 합이 충분하지 않을 경우 비활성화됩니다.
     * @type {boolean}
     * @default false
     * @readonly
     */
    get: function () {
      return this._circularEnabled;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "mode", {
    /**
     * A current camera mode
     * @type {CameraMode}
     * @readonly
     */
    get: function () {
      return this._mode;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "range", {
    /**
     * A range that Camera's {@link Camera#position position} can reach
     * @ko Camera의 {@link Camera#position position}이 도달 가능한 범위
     * @type {object}
     * @property {number} min A minimum position<ko>최소 위치</ko>
     * @property {number} max A maximum position<ko>최대 위치</ko>
     * @readonly
     */
    get: function () {
      return this._range;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "rangeDiff", {
    /**
     * A difference between Camera's minimum and maximum position that can reach
     * @ko Camera가 도달 가능한 최소/최대 좌표의 차이
     * @type {number}
     * @readonly
     */
    get: function () {
      return this._range.max - this._range.min;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "visiblePanels", {
    /**
     * An array of visible panels from the current position
     * @ko 현재 보이는 패널들의 배열
     * @type {Panel[]}
     * @readonly
     */
    get: function () {
      return this._visiblePanels;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "visibleRange", {
    /**
     * A range of the visible area from the current position
     * @ko 현재 위치에서 보이는 범위
     * @type {object}
     * @property {number} min A minimum position<ko>최소 위치</ko>
     * @property {number} min A maximum position<ko>최대 위치</ko>
     * @readonly
     */
    get: function () {
      return {
        min: this._position - this._alignPos,
        max: this._position - this._alignPos + this.size
      };
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "anchorPoints", {
    /**
     * An array of {@link AnchorPoint}s that Camera can be stopped at
     * @ko 카메라가 도달 가능한 {@link AnchorPoint}의 목록
     * @type {AnchorPoint[]}
     * @readonly
     */
    get: function () {
      return this._anchors;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "controlParams", {
    /**
     * A current parameters of the Camera for updating {@link AxesController}
     * @ko {@link AxesController}를 업데이트하기 위한 현재 Camera 패러미터들
     * @type {ControlParams}
     * @readonly
     */
    get: function () {
      return {
        range: this._range,
        position: this._position,
        circular: this._circularEnabled
      };
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "atEdge", {
    /**
     * A Boolean value indicating whether Camera's over the minimum or maximum position reachable
     * @ko 현재 카메라가 도달 가능한 범위의 최소 혹은 최대점을 넘어섰는지를 나타냅니다
     * @type {boolean}
     * @readonly
     */
    get: function () {
      return this._position <= this._range.min || this._position >= this._range.max;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "size", {
    /**
     * Return the size of the viewport
     * @ko 뷰포트 크기를 반환합니다
     * @type {number}
     * @readonly
     */
    get: function () {
      var flicking = this._flicking;
      return flicking ? flicking.horizontal ? flicking.viewport.width : flicking.viewport.height : 0;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "progress", {
    /**
     * Return the camera's position progress from the first panel to last panel
     * Range is from 0 to last panel's index
     * @ko 첫번째 패널로부터 마지막 패널까지의 카메라 위치의 진행도를 반환합니다
     * 범위는 0부터 마지막 패널의 인덱스까지입니다
     * @type {number}
     * @readonly
     */
    get: function () {
      var flicking = this._flicking;
      var position = this._position + this._offset;
      var nearestAnchor = this.findNearestAnchor(this._position);
      if (!flicking || !nearestAnchor) {
        return NaN;
      }
      var nearestPanel = nearestAnchor.panel;
      var panelPos = nearestPanel.position + nearestPanel.offset;
      var bounceSize = flicking.control.controller.bounce;
      var _a = this.range,
        prevRange = _a.min,
        nextRange = _a.max;
      var rangeDiff = this.rangeDiff;
      if (position === panelPos) {
        return nearestPanel.index;
      }
      if (position < panelPos) {
        var prevPanel = nearestPanel.prev();
        var prevPosition = prevPanel ? prevPanel.position + prevPanel.offset : prevRange - bounceSize[0];
        // Looped
        if (prevPosition > panelPos) {
          prevPosition -= rangeDiff;
        }
        return nearestPanel.index - 1 + getProgress(position, prevPosition, panelPos);
      } else {
        var nextPanel = nearestPanel.next();
        var nextPosition = nextPanel ? nextPanel.position + nextPanel.offset : nextRange + bounceSize[1];
        // Looped
        if (nextPosition < panelPos) {
          nextPosition += rangeDiff;
        }
        return nearestPanel.index + getProgress(position, panelPos, nextPosition);
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "panelOrder", {
    /**
     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/direction direction} CSS property applied to the camera element(`.flicking-camera`)
     * @ko 카메라 엘리먼트(`.flicking-camera`)에 적용된 {@link https://developer.mozilla.org/en-US/docs/Web/CSS/direction direction} CSS 속성
     * @type {string}
     * @readonly
     */
    get: function () {
      return this._panelOrder;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "align", {
    // Options Getter
    /**
     * A value indicating where the {@link Camera#alignPosition alignPosition} should be located at inside the viewport element
     * @ko {@link Camera#alignPosition alignPosition}이 뷰포트 엘리먼트 내의 어디에 위치해야 하는지를 나타내는 값
     * @type {ALIGN | string | number}
     */
    get: function () {
      return this._align;
    },
    // Options Setter
    set: function (val) {
      this._align = val;
    },
    enumerable: false,
    configurable: true
  });
  /**
   * Initialize Camera
   * @ko Camera를 초기화합니다
   * @throws {FlickingError}
   * {@link ERROR_CODE VAL_MUST_NOT_NULL} If the camera element(`.flicking-camera`) does not exist inside viewport element
   * <ko>{@link ERROR_CODE VAL_MUST_NOT_NULL} 뷰포트 엘리먼트 내부에 카메라 엘리먼트(`.flicking-camera`)가 존재하지 않을 경우</ko>
   * @return {this}
   */
  __proto.init = function () {
    var viewportEl = this._flicking.viewport.element;
    checkExistence(viewportEl.firstElementChild, "First element child of the viewport element");
    this._el = viewportEl.firstElementChild;
    this._checkTranslateSupport();
    this._updateMode();
    this.updatePanelOrder();
    return this;
  };
  /**
   * Destroy Camera and return to initial state
   * @ko Camera를 초기 상태로 되돌립니다
   * @return {void}
   */
  __proto.destroy = function () {
    this._resetInternalValues();
    return this;
  };
  /**
   * Move to the given position and apply CSS transform
   * @ko 해당 좌표로 이동하고, CSS transform을 적용합니다
   * @param {number} pos A new position<ko>움직일 위치</ko>
   * @throws {FlickingError}
   * {@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} When {@link Camera#init init} is not called before
   * <ko>{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} {@link Camera#init init}이 이전에 호출되지 않은 경우</ko>
   * @return {this}
   */
  __proto.lookAt = function (pos) {
    var _this = this;
    var flicking = getFlickingAttached(this._flicking);
    var prevPos = this._position;
    this._position = pos;
    var toggled = this._togglePanels(prevPos, pos);
    this._refreshVisiblePanels();
    this._checkNeedPanel();
    this._checkReachEnd(prevPos, pos);
    if (toggled) {
      void flicking.renderer.render().then(function () {
        _this.updateOffset();
      });
    } else {
      this.applyTransform();
    }
  };
  /**
   * Return a previous {@link AnchorPoint} of given {@link AnchorPoint}
   * If it does not exist, return `null` instead
   * @ko 주어진 {@link AnchorPoint}의 이전 {@link AnchorPoint}를 반환합니다
   * 존재하지 않을 경우 `null`을 반환합니다
   * @param {AnchorPoint} anchor A reference {@link AnchorPoint}<ko>기준 {@link AnchorPoint}</ko>
   * @return {AnchorPoint | null} The previous {@link AnchorPoint}<ko>이전 {@link AnchorPoint}</ko>
   */
  __proto.getPrevAnchor = function (anchor) {
    if (!this._circularEnabled || anchor.index !== 0) {
      return this._anchors[anchor.index - 1] || null;
    } else {
      var anchors = this._anchors;
      var rangeDiff = this.rangeDiff;
      var lastAnchor = anchors[anchors.length - 1];
      return new AnchorPoint({
        index: lastAnchor.index,
        position: lastAnchor.position - rangeDiff,
        panel: lastAnchor.panel
      });
    }
  };
  /**
   * Return a next {@link AnchorPoint} of given {@link AnchorPoint}
   * If it does not exist, return `null` instead
   * @ko 주어진 {@link AnchorPoint}의 다음 {@link AnchorPoint}를 반환합니다
   * 존재하지 않을 경우 `null`을 반환합니다
   * @param {AnchorPoint} anchor A reference {@link AnchorPoint}<ko>기준 {@link AnchorPoint}</ko>
   * @return {AnchorPoint | null} The next {@link AnchorPoint}<ko>다음 {@link AnchorPoint}</ko>
   */
  __proto.getNextAnchor = function (anchor) {
    var anchors = this._anchors;
    if (!this._circularEnabled || anchor.index !== anchors.length - 1) {
      return anchors[anchor.index + 1] || null;
    } else {
      var rangeDiff = this.rangeDiff;
      var firstAnchor = anchors[0];
      return new AnchorPoint({
        index: firstAnchor.index,
        position: firstAnchor.position + rangeDiff,
        panel: firstAnchor.panel
      });
    }
  };
  /**
   * Return the camera's position progress in the panel below
   * Value is from 0 to 1 when the camera's inside panel
   * Value can be lower than 0 or bigger than 1 when it's in the margin area
   * @ko 현재 카메라 아래 패널에서의 위치 진행도를 반환합니다
   * 반환값은 카메라가 패널 내부에 있을 경우 0부터 1까지의 값을 갖습니다
   * 패널의 margin 영역에 있을 경우 0보다 작거나 1보다 큰 값을 반환할 수 있습니다
   */
  __proto.getProgressInPanel = function (panel) {
    var panelRange = panel.range;
    return (this._position - panelRange.min) / (panelRange.max - panelRange.min);
  };
  /**
   * Return {@link AnchorPoint} that includes given position
   * If there's no {@link AnchorPoint} that includes the given position, return `null` instead
   * @ko 주어진 좌표를 포함하는 {@link AnchorPoint}를 반환합니다
   * 주어진 좌표를 포함하는 {@link AnchorPoint}가 없을 경우 `null`을 반환합니다
   * @param {number} position A position to check<ko>확인할 좌표</ko>
   * @return {AnchorPoint | null} The {@link AnchorPoint} that includes the given position<ko>해당 좌표를 포함하는 {@link AnchorPoint}</ko>
   */
  __proto.findAnchorIncludePosition = function (position) {
    return this._mode.findAnchorIncludePosition(position);
  };
  /**
   * Return {@link AnchorPoint} nearest to given position
   * If there're no {@link AnchorPoint}s, return `null` instead
   * @ko 해당 좌표에서 가장 가까운 {@link AnchorPoint}를 반환합니다
   * {@link AnchorPoint}가 하나도 없을 경우 `null`을 반환합니다
   * @param {number} position A position to check<ko>확인할 좌표</ko>
   * @return {AnchorPoint | null} The {@link AnchorPoint} nearest to the given position<ko>해당 좌표에 가장 인접한 {@link AnchorPoint}</ko>
   */
  __proto.findNearestAnchor = function (position) {
    return this._mode.findNearestAnchor(position);
  };
  /**
   * Return {@link AnchorPoint} that matches {@link Flicking#currentPanel}
   * @ko 현재 {@link Flicking#currentPanel}에 해당하는 {@link AnchorPoint}를 반환합니다
   * @return {AnchorPoint | null}
   */
  __proto.findActiveAnchor = function () {
    var _a;
    var flicking = getFlickingAttached(this._flicking);
    var activePanel = flicking.control.activePanel;
    if (!activePanel) return null;
    return (_a = find$1(this._anchors, function (anchor) {
      return anchor.panel.index === activePanel.index;
    })) !== null && _a !== void 0 ? _a : this.findNearestAnchor(activePanel.position);
  };
  /**
   * Clamp the given position between camera's range
   * @ko 주어진 좌표를 Camera가 도달 가능한 범위 사이의 값으로 만듭니다
   * @param {number} position A position to clamp<ko>범위를 제한할 좌표</ko>
   * @return {number} A clamped position<ko>범위 제한된 좌표</ko>
   */
  __proto.clampToReachablePosition = function (position) {
    return this._mode.clampToReachablePosition(position);
  };
  /**
   * Check whether the given panel is inside of the Camera's range
   * @ko 해당 {@link Panel}이 Camera가 도달 가능한 범위 내에 있는지를 반환합니다
   * @param panel An instance of {@link Panel} to check<ko>확인할 {@link Panel}의 인스턴스</ko>
   * @return {boolean} Whether the panel's inside Camera's range<ko>도달 가능한 범위 내에 해당 패널이 존재하는지 여부</ko>
   */
  __proto.canReach = function (panel) {
    return this._mode.canReach(panel);
  };
  /**
   * Check whether the given panel element is visible at the current position
   * @ko 현재 좌표에서 해당 패널 엘리먼트를 볼 수 있는지 여부를 반환합니다
   * @param panel An instance of {@link Panel} to check<ko>확인할 {@link Panel}의 인스턴스</ko>
   * @return Whether the panel element is visible at the current position<ko>현재 위치에서 해당 패널 엘리먼트가 보이는지 여부</ko>
   */
  __proto.canSee = function (panel) {
    return this._mode.canSee(panel);
  };
  /**
   * Update {@link Camera#range range} of Camera
   * @ko Camera의 {@link Camera#range range}를 업데이트합니다
   * @method
   * @abstract
   * @memberof Camera
   * @instance
   * @name updateRange
   * @chainable
   * @throws {FlickingError}
   * {@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} When {@link Camera#init init} is not called before
   * <ko>{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} {@link Camera#init init}이 이전에 호출되지 않은 경우</ko>
   * @return {this}
   */
  __proto.updateRange = function () {
    var flicking = getFlickingAttached(this._flicking);
    var renderer = flicking.renderer;
    var panels = renderer.panels;
    this._updateMode();
    this._range = this._mode.getRange();
    panels.forEach(function (panel) {
      return panel.updateCircularToggleDirection();
    });
    return this;
  };
  /**
   * Update Camera's {@link Camera#alignPosition alignPosition}
   * @ko Camera의 {@link Camera#alignPosition alignPosition}을 업데이트합니다
   * @chainable
   * @return {this}
   */
  __proto.updateAlignPos = function () {
    var align = this._align;
    var alignVal = typeof align === "object" ? align.camera : align;
    this._alignPos = parseAlign$1(alignVal, this.size);
    return this;
  };
  /**
   * Update Camera's {@link Camera#anchorPoints anchorPoints}
   * @ko Camera의 {@link Camera#anchorPoints anchorPoints}를 업데이트합니다
   * @throws {FlickingError}
   * {@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} When {@link Camera#init init} is not called before
   * <ko>{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} {@link Camera#init init}이 이전에 호출되지 않은 경우</ko>
   * @chainable
   * @return {this}
   */
  __proto.updateAnchors = function () {
    this._anchors = this._mode.getAnchors();
    return this;
  };
  /**
   * Update Viewport's height to active panel's height
   * @ko 현재 선택된 패널의 높이와 동일하도록 뷰포트의 높이를 업데이트합니다
   * @throws {FlickingError}
   * {@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} When {@link Camera#init init} is not called before
   * <ko>{@link ERROR_CODE NOT_ATTACHED_TO_FLICKING} {@link Camera#init init}이 이전에 호출되지 않은 경우</ko>
   * @chainable
   * @return {this}
   */
  __proto.updateAdaptiveHeight = function () {
    var flicking = getFlickingAttached(this._flicking);
    var activePanel = flicking.control.activePanel;
    if (!flicking.horizontal || !flicking.adaptive || !activePanel) return;
    flicking.viewport.setSize({
      height: activePanel.height
    });
  };
  /**
   * Update current offset of the camera
   * @ko 현재 카메라의 오프셋을 업데이트합니다
   * @chainable
   * @return {this}
   */
  __proto.updateOffset = function () {
    var flicking = getFlickingAttached(this._flicking);
    var position = this._position;
    var unRenderedPanels = flicking.panels.filter(function (panel) {
      return !panel.rendered;
    });
    this._offset = unRenderedPanels.filter(function (panel) {
      return panel.position + panel.offset < position;
    }).reduce(function (offset, panel) {
      return offset + panel.sizeIncludingMargin;
    }, 0);
    this._circularOffset = this._mode.getCircularOffset();
    this.applyTransform();
    return this;
  };
  /**
   * Update direction to match the {@link https://developer.mozilla.org/en-US/docs/Web/CSS/direction direction} CSS property applied to the camera element
   * @ko 카메라 엘리먼트에 적용된 {@link https://developer.mozilla.org/en-US/docs/Web/CSS/direction direction} CSS 속성에 맞게 방향을 업데이트합니다
   * @return {this}
   */
  __proto.updatePanelOrder = function () {
    var flicking = getFlickingAttached(this._flicking);
    if (!flicking.horizontal) return this;
    var el = this._el;
    var direction = getStyle(el).direction;
    if (direction !== this._panelOrder) {
      this._panelOrder = direction === ORDER.RTL ? ORDER.RTL : ORDER.LTR;
      if (flicking.initialized) {
        flicking.control.controller.updateDirection();
      }
    }
    return this;
  };
  /**
   * Reset the history of {@link Flicking#event:needPanel needPanel} events so it can be triggered again
   * @ko 발생한 {@link Flicking#event:needPanel needPanel} 이벤트들을 초기화하여 다시 발생할 수 있도록 합니다
   * @chainable
   * @return {this}
   */
  __proto.resetNeedPanelHistory = function () {
    this._needPanelTriggered = {
      prev: false,
      next: false
    };
    return this;
  };
  /**
   * Apply "transform" style with the current position to camera element
   * @ko 현재 위치를 기준으로한 transform 스타일을 카메라 엘리먼트에 적용합니다.
   * @return {this}
   */
  __proto.applyTransform = function () {
    var el = this._el;
    var flicking = getFlickingAttached(this._flicking);
    var renderer = flicking.renderer;
    if (renderer.rendering || !flicking.initialized) return this;
    var actualPosition = this._position - this._alignPos - this._offset + this._circularOffset;
    el.style[this._transform] = flicking.horizontal ? "translate(" + (this._panelOrder === ORDER.RTL ? actualPosition : -actualPosition) + "px)" : "translate(0, " + -actualPosition + "px)";
    return this;
  };
  __proto._resetInternalValues = function () {
    this._position = 0;
    this._alignPos = 0;
    this._offset = 0;
    this._circularOffset = 0;
    this._circularEnabled = false;
    this._range = {
      min: 0,
      max: 0
    };
    this._visiblePanels = [];
    this._anchors = [];
    this._needPanelTriggered = {
      prev: false,
      next: false
    };
  };
  __proto._refreshVisiblePanels = function () {
    var _this = this;
    var flicking = getFlickingAttached(this._flicking);
    var panels = flicking.renderer.panels;
    var newVisiblePanels = panels.filter(function (panel) {
      return _this.canSee(panel);
    });
    var prevVisiblePanels = this._visiblePanels;
    this._visiblePanels = newVisiblePanels;
    var added = newVisiblePanels.filter(function (panel) {
      return !includes(prevVisiblePanels, panel);
    });
    var removed = prevVisiblePanels.filter(function (panel) {
      return !includes(newVisiblePanels, panel);
    });
    if (added.length > 0 || removed.length > 0) {
      void flicking.renderer.render().then(function () {
        flicking.trigger(new ComponentEvent$1(EVENTS.VISIBLE_CHANGE, {
          added: added,
          removed: removed,
          visiblePanels: newVisiblePanels
        }));
      });
    }
  };
  __proto._checkNeedPanel = function () {
    var needPanelTriggered = this._needPanelTriggered;
    if (needPanelTriggered.prev && needPanelTriggered.next) return;
    var flicking = getFlickingAttached(this._flicking);
    var panels = flicking.renderer.panels;
    if (panels.length <= 0) {
      if (!needPanelTriggered.prev) {
        flicking.trigger(new ComponentEvent$1(EVENTS.NEED_PANEL, {
          direction: DIRECTION.PREV
        }));
        needPanelTriggered.prev = true;
      }
      if (!needPanelTriggered.next) {
        flicking.trigger(new ComponentEvent$1(EVENTS.NEED_PANEL, {
          direction: DIRECTION.NEXT
        }));
        needPanelTriggered.next = true;
      }
      return;
    }
    var cameraPosition = this._position;
    var cameraSize = this.size;
    var cameraRange = this._range;
    var needPanelThreshold = flicking.needPanelThreshold;
    var cameraPrev = cameraPosition - this._alignPos;
    var cameraNext = cameraPrev + cameraSize;
    var firstPanel = panels[0];
    var lastPanel = panels[panels.length - 1];
    if (!needPanelTriggered.prev) {
      var firstPanelPrev = firstPanel.range.min;
      if (cameraPrev <= firstPanelPrev + needPanelThreshold || cameraPosition <= cameraRange.min + needPanelThreshold) {
        flicking.trigger(new ComponentEvent$1(EVENTS.NEED_PANEL, {
          direction: DIRECTION.PREV
        }));
        needPanelTriggered.prev = true;
      }
    }
    if (!needPanelTriggered.next) {
      var lastPanelNext = lastPanel.range.max;
      if (cameraNext >= lastPanelNext - needPanelThreshold || cameraPosition >= cameraRange.max - needPanelThreshold) {
        flicking.trigger(new ComponentEvent$1(EVENTS.NEED_PANEL, {
          direction: DIRECTION.NEXT
        }));
        needPanelTriggered.next = true;
      }
    }
  };
  __proto._checkReachEnd = function (prevPos, newPos) {
    var flicking = getFlickingAttached(this._flicking);
    var range = this._range;
    var wasBetweenRange = prevPos > range.min && prevPos < range.max;
    var isBetweenRange = newPos > range.min && newPos < range.max;
    if (!wasBetweenRange || isBetweenRange) return;
    var direction = newPos <= range.min ? DIRECTION.PREV : DIRECTION.NEXT;
    flicking.trigger(new ComponentEvent$1(EVENTS.REACH_EDGE, {
      direction: direction
    }));
  };
  __proto._updateMode = function () {
    var flicking = getFlickingAttached(this._flicking);
    if (flicking.circular) {
      var circularMode = new CircularCameraMode(flicking);
      var canSetCircularMode = circularMode.checkAvailability();
      if (canSetCircularMode) {
        this._mode = circularMode;
      } else {
        var fallbackMode = flicking.circularFallback;
        this._mode = fallbackMode === CIRCULAR_FALLBACK.BOUND ? new BoundCameraMode(flicking) : new LinearCameraMode(flicking);
      }
      this._circularEnabled = canSetCircularMode;
    } else {
      this._mode = flicking.bound ? new BoundCameraMode(flicking) : new LinearCameraMode(flicking);
      this._circularEnabled = false;
    }
  };
  __proto._togglePanels = function (prevPos, pos) {
    if (pos === prevPos) return false;
    var flicking = getFlickingAttached(this._flicking);
    var panels = flicking.renderer.panels;
    var toggled = panels.map(function (panel) {
      return panel.toggle(prevPos, pos);
    });
    return toggled.some(function (isToggled) {
      return isToggled;
    });
  };
  return Camera;
}();

/**
 * A component that manages {@link Panel} and its elements
 * @ko {@link Panel}과 그 엘리먼트들을 관리하는 컴포넌트
 */
var Renderer = /*#__PURE__*/function () {
  /**
   * @param {object} options An options object<ko>옵션 오브젝트</ko>
   * @param {Constants.ALIGN | string | number} [options.align="center"] An {@link Flicking#align align} value that will be applied to all panels<ko>전체 패널에 적용될 {@link Flicking#align align} 값</ko>
   * @param {object} [options.strategy] An instance of RenderingStrategy(internal module)<ko>RenderingStrategy의 인스턴스(내부 모듈)</ko>
   */
  function Renderer(_a) {
    var _b = _a.align,
      align = _b === void 0 ? ALIGN.CENTER : _b,
      strategy = _a.strategy;
    this._flicking = null;
    this._panels = [];
    this._rendering = false;
    // Bind options
    this._align = align;
    this._strategy = strategy;
  }
  var __proto = Renderer.prototype;
  Object.defineProperty(__proto, "panels", {
    // Internal states Getter
    /**
     * Array of panels
     * @ko 전체 패널들의 배열
     * @type {Panel[]}
     * @readonly
     * @see Panel
     */
    get: function () {
      return this._panels;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "rendering", {
    /**
     * A boolean value indicating whether rendering is in progress
     * @ko 현재 렌더링이 시작되어 끝나기 전까지의 상태인지의 여부
     * @type {boolean}
     * @readonly
     * @internal
     */
    get: function () {
      return this._rendering;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "panelCount", {
    /**
     * Count of panels
     * @ko 전체 패널의 개수
     * @type {number}
     * @readonly
     */
    get: function () {
      return this._panels.length;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "strategy", {
    /**
     * @internal
     */
    get: function () {
      return this._strategy;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "align", {
    // Options Getter
    /**
     * A {@link Panel}'s {@link Panel#align align} value that applied to all panels
     * @ko {@link Panel}에 공통적으로 적용할 {@link Panel#align align} 값
     * @type {Constants.ALIGN | string | number}
     */
    get: function () {
      return this._align;
    },
    // Options Setter
    set: function (val) {
      this._align = val;
      var panelAlign = parsePanelAlign(val);
      this._panels.forEach(function (panel) {
        panel.align = panelAlign;
      });
    },
    enumerable: false,
    configurable: true
  });
  /**
   * Initialize Renderer
   * @ko Renderer를 초기화합니다
   * @param {Flicking} flicking An instance of {@link Flicking}<ko>Flicking의 인스턴스</ko>
   * @chainable
   * @return {this}
   */
  __proto.init = function (flicking) {
    this._flicking = flicking;
    this._collectPanels();
    return this;
  };
  /**
   * Destroy Renderer and return to initial state
   * @ko Renderer를 초기 상태로 되돌립니다
   * @return {void}
   */
  __proto.destroy = function () {
    this._flicking = null;
    this._panels = [];
  };
  /**
   * Return the {@link Panel} at the given index. `null` if it doesn't exists.
   * @ko 주어진 인덱스에 해당하는 {@link Panel}을 반환합니다. 주어진 인덱스에 해당하는 패널이 존재하지 않을 경우 `null`을 반환합니다.
   * @return {Panel | null} Panel at the given index<ko>주어진 인덱스에 해당하는 패널</ko>
   * @see Panel
   */
  __proto.getPanel = function (index) {
    return this._panels[index] || null;
  };
  __proto.forceRenderAllPanels = function () {
    this._panels.forEach(function (panel) {
      return panel.markForShow();
    });
    return Promise.resolve();
  };
  /**
   * Update all panel sizes
   * @ko 모든 패널의 크기를 업데이트합니다
   * @chainable
   * @return {this}
   */
  __proto.updatePanelSize = function () {
    var flicking = getFlickingAttached(this._flicking);
    var panels = this._panels;
    if (panels.length <= 0) return this;
    if (flicking.panelsPerView > 0) {
      var firstPanel = panels[0];
      firstPanel.resize();
      this._updatePanelSizeByGrid(firstPanel, panels);
    } else {
      flicking.panels.forEach(function (panel) {
        return panel.resize();
      });
    }
    return this;
  };
  /**
   * Insert new panels at given index
   * This will increase index of panels after by the number of panels added
   * @ko 주어진 인덱스에 새로운 패널들을 추가합니다
   * 해당 인덱스보다 같거나 큰 인덱스를 가진 기존 패널들은 추가한 패널의 개수만큼 인덱스가 증가합니다.
   * @param {Array<object>} items An array of items to insert<ko>추가할 아이템들의 배열</ko>
   * @param {number} [items.index] Index to insert new panels at<ko>새로 패널들을 추가할 인덱스</ko>
   * @param {any[]} [items.elements] An array of element or framework component with element in it<ko>엘리먼트의 배열 혹은 프레임워크에서 엘리먼트를 포함한 컴포넌트들의 배열</ko>
   * @param {boolean} [items.hasDOMInElements] Whether it contains actual DOM elements. If set to true, renderer will add them to the camera element<ko>내부에 실제 DOM 엘리먼트들을 포함하고 있는지 여부. true로 설정할 경우, 렌더러는 해당 엘리먼트들을 카메라 엘리먼트 내부에 추가합니다</ko>
   * @return {Panel[]} An array of prepended panels<ko>추가된 패널들의 배열</ko>
   */
  __proto.batchInsert = function () {
    var items = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      items[_i] = arguments[_i];
    }
    var allPanelsInserted = this.batchInsertDefer.apply(this, __spread$1(items));
    if (allPanelsInserted.length <= 0) return [];
    this.updateAfterPanelChange(allPanelsInserted, []);
    return allPanelsInserted;
  };
  /**
   * Defers update
   * camera position & others will be updated after calling updateAfterPanelChange
   * @internal
   */
  __proto.batchInsertDefer = function () {
    var _this = this;
    var items = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      items[_i] = arguments[_i];
    }
    var panels = this._panels;
    var flicking = getFlickingAttached(this._flicking);
    var prevFirstPanel = panels[0];
    var align = parsePanelAlign(this._align);
    var allPanelsInserted = items.reduce(function (addedPanels, item) {
      var _a;
      var insertingIdx = getMinusCompensatedIndex(item.index, panels.length);
      var panelsPushed = panels.slice(insertingIdx);
      var panelsInserted = item.elements.map(function (el, idx) {
        return _this._createPanel(el, {
          index: insertingIdx + idx,
          align: align,
          flicking: flicking
        });
      });
      panels.splice.apply(panels, __spread$1([insertingIdx, 0], panelsInserted));
      if (item.hasDOMInElements) {
        // Insert the actual elements as camera element's children
        _this._insertPanelElements(panelsInserted, (_a = panelsPushed[0]) !== null && _a !== void 0 ? _a : null);
      }
      // Resize the newly added panels
      if (flicking.panelsPerView > 0) {
        var firstPanel = prevFirstPanel || panelsInserted[0].resize();
        _this._updatePanelSizeByGrid(firstPanel, panelsInserted);
      } else {
        panelsInserted.forEach(function (panel) {
          return panel.resize();
        });
      }
      // Update panel indexes & positions
      panelsPushed.forEach(function (panel) {
        panel.increaseIndex(panelsInserted.length);
        panel.updatePosition();
      });
      return __spread$1(addedPanels, panelsInserted);
    }, []);
    return allPanelsInserted;
  };
  /**
   * Remove the panel at the given index
   * This will decrease index of panels after by the number of panels removed
   * @ko 주어진 인덱스의 패널을 제거합니다
   * 해당 인덱스보다 큰 인덱스를 가진 기존 패널들은 제거한 패널의 개수만큼 인덱스가 감소합니다
   * @param {Array<object>} items An array of items to remove<ko>제거할 아이템들의 배열</ko>
   * @param {number} [items.index] Index of panel to remove<ko>제거할 패널의 인덱스</ko>
   * @param {number} [items.deleteCount=1] Number of panels to remove from index<ko>`index` 이후로 제거할 패널의 개수</ko>
   * @param {boolean} [items.hasDOMInElements=1] Whether it contains actual DOM elements. If set to true, renderer will remove them from the camera element<ko>내부에 실제 DOM 엘리먼트들을 포함하고 있는지 여부. true로 설정할 경우, 렌더러는 해당 엘리먼트들을 카메라 엘리먼트 내부에서 제거합니다</ko>
   * @return An array of removed panels<ko>제거된 패널들의 배열</ko>
   */
  __proto.batchRemove = function () {
    var items = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      items[_i] = arguments[_i];
    }
    var allPanelsRemoved = this.batchRemoveDefer.apply(this, __spread$1(items));
    if (allPanelsRemoved.length <= 0) return [];
    this.updateAfterPanelChange([], allPanelsRemoved);
    return allPanelsRemoved;
  };
  /**
   * Defers update
   * camera position & others will be updated after calling updateAfterPanelChange
   * @internal
   */
  __proto.batchRemoveDefer = function () {
    var _this = this;
    var items = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      items[_i] = arguments[_i];
    }
    var panels = this._panels;
    var flicking = getFlickingAttached(this._flicking);
    var control = flicking.control;
    var activePanel = control.activePanel;
    var allPanelsRemoved = items.reduce(function (removed, item) {
      var index = item.index,
        deleteCount = item.deleteCount;
      var removingIdx = getMinusCompensatedIndex(index, panels.length);
      var panelsPulled = panels.slice(removingIdx + deleteCount);
      var panelsRemoved = panels.splice(removingIdx, deleteCount);
      if (panelsRemoved.length <= 0) return [];
      // Update panel indexes & positions
      panelsPulled.forEach(function (panel) {
        panel.decreaseIndex(panelsRemoved.length);
        panel.updatePosition();
      });
      if (item.hasDOMInElements) {
        _this._removePanelElements(panelsRemoved);
      }
      // Remove panel elements
      panelsRemoved.forEach(function (panel) {
        return panel.destroy();
      });
      if (includes(panelsRemoved, activePanel)) {
        control.resetActive();
      }
      return __spread$1(removed, panelsRemoved);
    }, []);
    return allPanelsRemoved;
  };
  /**
   * @internal
   */
  __proto.updateAfterPanelChange = function (panelsAdded, panelsRemoved) {
    var _a;
    var flicking = getFlickingAttached(this._flicking);
    var camera = flicking.camera,
      control = flicking.control;
    var panels = this._panels;
    var activePanel = control.activePanel;
    // Update camera & control
    this._updateCameraAndControl();
    void this.render();
    if (!flicking.animating) {
      if (!activePanel || activePanel.removed) {
        if (panels.length <= 0) {
          // All panels removed
          camera.lookAt(0);
        } else {
          var targetIndex = (_a = activePanel === null || activePanel === void 0 ? void 0 : activePanel.index) !== null && _a !== void 0 ? _a : 0;
          if (targetIndex > panels.length - 1) {
            targetIndex = panels.length - 1;
          }
          void control.moveToPanel(panels[targetIndex], {
            duration: 0
          }).catch(function () {
            return void 0;
          });
        }
      } else {
        void control.moveToPanel(activePanel, {
          duration: 0
        }).catch(function () {
          return void 0;
        });
      }
    }
    flicking.camera.updateOffset();
    if (panelsAdded.length > 0 || panelsRemoved.length > 0) {
      flicking.trigger(new ComponentEvent$1(EVENTS.PANEL_CHANGE, {
        added: panelsAdded,
        removed: panelsRemoved
      }));
      this.checkPanelContentsReady(__spread$1(panelsAdded, panelsRemoved));
    }
  };
  /**
   * @internal
   */
  __proto.checkPanelContentsReady = function (checkingPanels) {
    var _this = this;
    var flicking = getFlickingAttached(this._flicking);
    var resizeOnContentsReady = flicking.resizeOnContentsReady;
    var panels = this._panels;
    if (!resizeOnContentsReady || flicking.virtualEnabled) return;
    var hasContents = function (panel) {
      return panel.element && !!panel.element.querySelector("img, video");
    };
    checkingPanels = checkingPanels.filter(function (panel) {
      return hasContents(panel);
    });
    if (checkingPanels.length <= 0) return;
    var contentsReadyChecker = new ImReady();
    checkingPanels.forEach(function (panel) {
      panel.loading = true;
    });
    contentsReadyChecker.on("readyElement", function (e) {
      if (!_this._flicking) {
        // Renderer's destroy() is called before
        contentsReadyChecker.destroy();
        return;
      }
      var panel = checkingPanels[e.index];
      var camera = flicking.camera;
      var control = flicking.control;
      var prevProgressInPanel = control.activePanel ? camera.getProgressInPanel(control.activePanel) : 0;
      panel.loading = false;
      panel.resize();
      panels.slice(panel.index + 1).forEach(function (panelBehind) {
        return panelBehind.updatePosition();
      });
      if (!flicking.initialized) return;
      camera.updateRange();
      camera.updateOffset();
      camera.updateAnchors();
      if (control.animating) ; else {
        control.updatePosition(prevProgressInPanel);
        control.updateInput();
      }
    });
    contentsReadyChecker.on("preReady", function (e) {
      if (_this._flicking) {
        void _this.render();
      }
      if (e.readyCount === e.totalCount) {
        contentsReadyChecker.destroy();
      }
    });
    contentsReadyChecker.on("ready", function () {
      if (_this._flicking) {
        void _this.render();
      }
      contentsReadyChecker.destroy();
    });
    contentsReadyChecker.check(checkingPanels.map(function (panel) {
      return panel.element;
    }));
  };
  __proto._updateCameraAndControl = function () {
    var flicking = getFlickingAttached(this._flicking);
    var camera = flicking.camera,
      control = flicking.control;
    camera.updateRange();
    camera.updateOffset();
    camera.updateAnchors();
    camera.resetNeedPanelHistory();
    control.updateInput();
  };
  __proto._showOnlyVisiblePanels = function (flicking) {
    var panels = flicking.renderer.panels;
    var camera = flicking.camera;
    var visibleIndexes = camera.visiblePanels.reduce(function (visibles, panel) {
      visibles[panel.index] = true;
      return visibles;
    }, {});
    panels.forEach(function (panel) {
      if (panel.index in visibleIndexes || panel.loading) {
        panel.markForShow();
      } else if (!flicking.holding) {
        // During the input sequence,
        // Do not remove panel elements as it won't trigger touchend event.
        panel.markForHide();
      }
    });
  };
  __proto._updatePanelSizeByGrid = function (referencePanel, panels) {
    var flicking = getFlickingAttached(this._flicking);
    var panelsPerView = flicking.panelsPerView;
    if (panelsPerView <= 0) {
      throw new FlickingError(MESSAGE.WRONG_OPTION("panelsPerView", panelsPerView), CODE.WRONG_OPTION);
    }
    if (panels.length <= 0) return;
    var viewportSize = flicking.camera.size;
    var gap = referencePanel.margin.prev + referencePanel.margin.next;
    var panelSize = (viewportSize - gap * (panelsPerView - 1)) / panelsPerView;
    var panelSizeObj = flicking.horizontal ? {
      width: panelSize
    } : {
      height: panelSize
    };
    var firstPanelSizeObj = __assign$2({
      size: panelSize,
      margin: referencePanel.margin
    }, !flicking.horizontal && {
      height: referencePanel.height
    });
    if (!flicking.noPanelStyleOverride) {
      this._strategy.updatePanelSizes(flicking, panelSizeObj);
    }
    flicking.panels.forEach(function (panel) {
      return panel.resize(firstPanelSizeObj);
    });
  };
  __proto._removeAllChildsFromCamera = function () {
    var flicking = getFlickingAttached(this._flicking);
    var cameraElement = flicking.camera.element;
    // Remove other elements
    while (cameraElement.firstChild) {
      cameraElement.removeChild(cameraElement.firstChild);
    }
  };
  __proto._insertPanelElements = function (panels, nextSibling) {
    if (nextSibling === void 0) {
      nextSibling = null;
    }
    var flicking = getFlickingAttached(this._flicking);
    var camera = flicking.camera;
    var cameraElement = camera.element;
    var nextSiblingElement = (nextSibling === null || nextSibling === void 0 ? void 0 : nextSibling.element) || null;
    var fragment = document.createDocumentFragment();
    panels.forEach(function (panel) {
      return fragment.appendChild(panel.element);
    });
    cameraElement.insertBefore(fragment, nextSiblingElement);
  };
  __proto._removePanelElements = function (panels) {
    var flicking = getFlickingAttached(this._flicking);
    var cameraElement = flicking.camera.element;
    panels.forEach(function (panel) {
      cameraElement.removeChild(panel.element);
    });
  };
  __proto._afterRender = function () {
    var flicking = getFlickingAttached(this._flicking);
    flicking.camera.applyTransform();
  };
  return Renderer;
}();

/**
 *
 */
var VanillaRenderer = /*#__PURE__*/function (_super) {
  __extends$3(VanillaRenderer, _super);
  function VanillaRenderer() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  // eslint-disable-next-line @typescript-eslint/require-await
  var __proto = VanillaRenderer.prototype;
  __proto.render = function () {
    return __awaiter(this, void 0, void 0, function () {
      var flicking, strategy;
      return __generator(this, function (_a) {
        flicking = getFlickingAttached(this._flicking);
        strategy = this._strategy;
        strategy.updateRenderingPanels(flicking);
        strategy.renderPanels(flicking);
        this._resetPanelElementOrder();
        this._afterRender();
        return [2 /*return*/];
      });
    });
  };

  __proto._collectPanels = function () {
    var flicking = getFlickingAttached(this._flicking);
    var camera = flicking.camera;
    this._removeAllTextNodes();
    this._panels = this._strategy.collectPanels(flicking, camera.children);
  };
  __proto._createPanel = function (el, options) {
    return this._strategy.createPanel(el, options);
  };
  __proto._resetPanelElementOrder = function () {
    var flicking = getFlickingAttached(this._flicking);
    var cameraEl = flicking.camera.element;
    // We're using reversed panels here as last panel should be the last element of camera element
    var reversedElements = this._strategy.getRenderingElementsByOrder(flicking).reverse();
    reversedElements.forEach(function (el, idx) {
      var nextEl = reversedElements[idx - 1] ? reversedElements[idx - 1] : null;
      if (el.nextElementSibling !== nextEl) {
        cameraEl.insertBefore(el, nextEl);
      }
    });
  };
  __proto._removeAllTextNodes = function () {
    var flicking = getFlickingAttached(this._flicking);
    var cameraElement = flicking.camera.element;
    // Remove all text nodes in the camera element
    toArray$2(cameraElement.childNodes).forEach(function (node) {
      if (node.nodeType === Node.TEXT_NODE) {
        cameraElement.removeChild(node);
      }
    });
  };
  return VanillaRenderer;
}(Renderer);

/**
 * @internal
 */
var ExternalRenderer = /*#__PURE__*/function (_super) {
  __extends$3(ExternalRenderer, _super);
  function ExternalRenderer() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  /* eslint-disable @typescript-eslint/no-unused-vars */
  var __proto = ExternalRenderer.prototype;
  __proto._removePanelElements = function (panels) {
    // DO NOTHING, overrided to prevent an unexpected error
  };
  __proto._removeAllChildsFromCamera = function () {
    // DO NOTHING, overrided to prevent an unexpected error
  };
  return ExternalRenderer;
}(Renderer);

/**
 * A slide data component that holds information of a single HTMLElement
 * @ko 슬라이드 데이터 컴포넌트로, 단일 HTMLElement의 정보를 갖고 있습니다
 */
var Panel = /*#__PURE__*/function () {
  /**
   * @param {object} options An options object<ko>옵션 오브젝트</ko>
   * @param {number} [options.index] An initial index of the panel<ko>패널의 초기 인덱스</ko>
   * @param {Constants.ALIGN | string | number} [options.align] An initial {@link Flicking#align align} value of the panel<ko>패널의 초기 {@link Flicking#align align}값</ko>
   * @param {Flicking} [options.flicking] A Flicking instance panel's referencing<ko>패널이 참조하는 {@link Flicking} 인스턴스</ko>
   * @param {Flicking} [options.elementProvider] A provider instance that redirects elements<ko>실제 엘리먼트를 반환하는 엘리먼트 공급자의 인스턴스</ko>
   */
  function Panel(_a) {
    var index = _a.index,
      align = _a.align,
      flicking = _a.flicking,
      elementProvider = _a.elementProvider;
    this._index = index;
    this._flicking = flicking;
    this._elProvider = elementProvider;
    this._align = align;
    this._removed = false;
    this._rendered = true;
    this._loading = false;
    this._resetInternalStates();
  }
  var __proto = Panel.prototype;
  Object.defineProperty(__proto, "element", {
    // Internal States Getter
    /**
     * `HTMLElement` that panel's referencing
     * @ko 패널이 참조하고 있는 `HTMLElement`
     * @type {HTMLElement}
     * @readonly
     */
    get: function () {
      return this._elProvider.element;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "elementProvider", {
    /**
     * @internal
     * @readonly
     */
    get: function () {
      return this._elProvider;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "index", {
    /**
     * Index of the panel
     * @ko 패널의 인덱스
     * @type {number}
     * @readonly
     */
    get: function () {
      return this._index;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "position", {
    /**
     * Position of the panel, including {@link Panel#alignPosition alignPosition}
     * @ko 패널의 현재 좌표, {@link Panel#alignPosition alignPosition}을 포함하고 있습니다
     * @type {number}
     * @readonly
     */
    get: function () {
      return this._pos + this._alignPos;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "size", {
    /**
     * Cached size of the panel element
     * This is equal to {@link Panel#element element}'s `offsetWidth` if {@link Flicking#horizontal horizontal} is `true`, and `offsetHeight` else
     * @ko 패널 엘리먼트의 캐시된 크기
     * 이 값은 {@link Flicking#horizontal horizontal}이 `true`일 경우 {@link Panel#element element}의 `offsetWidth`와 동일하고, `false`일 경우 `offsetHeight`와 동일합니다
     * @type {number}
     * @readonly
     */
    get: function () {
      return this._size;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "sizeIncludingMargin", {
    /**
     * Panel's size including CSS `margin`
     * This value includes {@link Panel#element element}'s margin left/right if {@link Flicking#horizontal horizontal} is `true`, and margin top/bottom else
     * @ko CSS `margin`을 포함한 패널의 크기
     * 이 값은 {@link Flicking#horizontal horizontal}이 `true`일 경우 margin left/right을 포함하고, `false`일 경우 margin top/bottom을 포함합니다
     * @type {number}
     * @readonly
     */
    get: function () {
      return this._size + this._margin.prev + this._margin.next;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "height", {
    /**
     * Height of the panel element
     * @ko 패널 엘리먼트의 높이
     * @type {number}
     * @readonly
     */
    get: function () {
      return this._height;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "margin", {
    /**
     * Cached CSS `margin` value of the panel element
     * @ko 패널 엘리먼트의 CSS `margin` 값
     * @type {object}
     * @property {number} prev CSS `margin-left` when the {@link Flicking#horizontal horizontal} is `true`, and `margin-top` else
     * <ko>{@link Flicking#horizontal horizontal}이 `true`일 경우 `margin-left`, `false`일 경우 `margin-top`에 해당하는 값</ko>
     * @property {number} next CSS `margin-right` when the {@link Flicking#horizontal horizontal} is `true`, and `margin-bottom` else
     * <ko>{@link Flicking#horizontal horizontal}이 `true`일 경우 `margin-right`, `false`일 경우 `margin-bottom`에 해당하는 값</ko>
     * @readonly
     */
    get: function () {
      return this._margin;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "alignPosition", {
    /**
     * Align position inside the panel where {@link Camera}'s {@link Camera#alignPosition alignPosition} inside viewport should be located at
     * @ko 패널의 정렬 기준 위치. {@link Camera}의 뷰포트 내에서의 {@link Camera#alignPosition alignPosition}이 위치해야 하는 곳입니다
     * @type {number}
     * @readonly
     */
    get: function () {
      return this._alignPos;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "removed", {
    /**
     * A value indicating whether the panel's {@link Flicking#remove remove}d
     * @ko 패널이 {@link Flicking#remove remove}되었는지 여부를 나타내는 값
     * @type {boolean}
     * @readonly
     */
    get: function () {
      return this._removed;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "rendered", {
    /**
     * A value indicating whether the panel's element is being rendered on the screen
     * @ko 패널의 엘리먼트가 화면상에 렌더링되고있는지 여부를 나타내는 값
     * @type {boolean}
     * @readonly
     */
    get: function () {
      return this._rendered;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "loading", {
    /**
     * A value indicating whether the panel's image/video is not loaded and waiting for resize
     * @ko 패널 내부의 이미지/비디오가 아직 로드되지 않아 {@link Panel#resize resize}될 것인지를 나타내는 값
     * @type {boolean}
     * @readonly
     */
    get: function () {
      return this._loading;
    },
    set: function (val) {
      this._loading = val;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "range", {
    /**
     * Panel element's range of the bounding box
     * @ko 패널 엘리먼트의 Bounding box 범위
     * @type {object}
     * @property {number} [min] Bounding box's left({@link Flicking#horizontal horizontal}: true) / top({@link Flicking#horizontal horizontal}: false)
     * @property {number} [max] Bounding box's right({@link Flicking#horizontal horizontal}: true) / bottom({@link Flicking#horizontal horizontal}: false)
     * @readonly
     */
    get: function () {
      return {
        min: this._pos,
        max: this._pos + this._size
      };
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "toggled", {
    /**
     * A value indicating whether the panel's position is toggled by circular behavior
     * @ko 패널의 위치가 circular 동작에 의해 토글되었는지 여부를 나타내는 값
     * @type {boolean}
     * @readonly
     */
    get: function () {
      return this._toggled;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "toggleDirection", {
    /**
     * A direction where the panel's position is toggled
     * @ko 패널의 위치가 circular 동작에 의해 토글되는 방향
     * @type {DIRECTION}
     * @readonly
     */
    get: function () {
      return this._toggleDirection;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "offset", {
    /**
     * Actual position offset determined by {@link Panel#order}
     * @ko {@link Panel#order}에 의한 실제 위치 변경값
     * @type {number}
     * @readonly
     */
    get: function () {
      var toggleDirection = this._toggleDirection;
      var cameraRangeDiff = this._flicking.camera.rangeDiff;
      return toggleDirection === DIRECTION.NONE || !this._toggled ? 0 : toggleDirection === DIRECTION.PREV ? -cameraRangeDiff : cameraRangeDiff;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "progress", {
    /**
     * Progress of movement between previous or next panel relative to current panel
     * @ko 이 패널로부터 이전/다음 패널으로의 이동 진행률
     * @type {number}
     * @readonly
     */
    get: function () {
      var flicking = this._flicking;
      return this.index - flicking.camera.progress;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "outsetProgress", {
    /**
     * Progress of movement between points that panel is completely invisible outside of viewport(prev direction: -1, selected point: 0, next direction: 1)
     * @ko 현재 패널이 뷰포트 영역 밖으로 완전히 사라지는 지점을 기준으로 하는 진행도(prev방향: -1, 선택 지점: 0, next방향: 1)
     * @type {number}
     * @readonly
     */
    get: function () {
      var position = this.position + this.offset;
      var alignPosition = this._alignPos;
      var camera = this._flicking.camera;
      var camPos = camera.position;
      if (camPos === position) {
        return 0;
      }
      if (camPos < position) {
        var disappearPosNext = position + (camera.size - camera.alignPosition) + alignPosition;
        return -getProgress(camPos, position, disappearPosNext);
      } else {
        var disappearPosPrev = position - (camera.alignPosition + this._size - alignPosition);
        return 1 - getProgress(camPos, disappearPosPrev, position);
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "visibleRatio", {
    /**
     * Percentage of area where panel is visible in the viewport
     * @ko 뷰포트 안에서 패널이 보이는 영역의 비율
     * @type {number}
     * @readonly
     */
    get: function () {
      var range = this.range;
      var size = this._size;
      var offset = this.offset;
      var visibleRange = this._flicking.camera.visibleRange;
      var checkingRange = {
        min: range.min + offset,
        max: range.max + offset
      };
      if (checkingRange.max <= visibleRange.min || checkingRange.min >= visibleRange.max) {
        return 0;
      }
      var visibleSize = size;
      if (visibleRange.min > checkingRange.min) {
        visibleSize -= visibleRange.min - checkingRange.min;
      }
      if (visibleRange.max < checkingRange.max) {
        visibleSize -= checkingRange.max - visibleRange.max;
      }
      return visibleSize / size;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "align", {
    // Options Getter
    /**
     * A value indicating where the {@link Panel#alignPosition alignPosition} should be located at inside the panel element
     * @ko {@link Panel#alignPosition alignPosition}이 패널 내의 어디에 위치해야 하는지를 나타내는 값
     * @type {Constants.ALIGN | string | number}
     */
    get: function () {
      return this._align;
    },
    // Options Setter
    set: function (val) {
      this._align = val;
      this._updateAlignPos();
    },
    enumerable: false,
    configurable: true
  });
  /**
   * Mark panel element to be appended on the camera element
   * @internal
   */
  __proto.markForShow = function () {
    this._rendered = true;
    this._elProvider.show(this._flicking);
  };
  /**
   * Mark panel element to be removed from the camera element
   * @internal
   */
  __proto.markForHide = function () {
    this._rendered = false;
    this._elProvider.hide(this._flicking);
  };
  /**
   * Update size of the panel
   * @ko 패널의 크기를 갱신합니다
   * @param {object} cached Predefined cached size of the panel<ko>사전에 캐시된 패널의 크기 정보</ko>
   * @chainable
   * @return {this}
   */
  __proto.resize = function (cached) {
    var _a;
    var el = this.element;
    var flicking = this._flicking;
    var horizontal = flicking.horizontal,
      useFractionalSize = flicking.useFractionalSize;
    if (cached) {
      this._size = cached.size;
      this._margin = __assign$2({}, cached.margin);
      this._height = (_a = cached.height) !== null && _a !== void 0 ? _a : getElementSize({
        el: el,
        horizontal: false,
        useFractionalSize: useFractionalSize,
        useOffset: true,
        style: getStyle(el)
      });
    } else {
      var elStyle = getStyle(el);
      this._size = getElementSize({
        el: el,
        horizontal: horizontal,
        useFractionalSize: useFractionalSize,
        useOffset: true,
        style: elStyle
      });
      this._margin = horizontal ? {
        prev: parseFloat(elStyle.marginLeft || "0"),
        next: parseFloat(elStyle.marginRight || "0")
      } : {
        prev: parseFloat(elStyle.marginTop || "0"),
        next: parseFloat(elStyle.marginBottom || "0")
      };
      this._height = horizontal ? getElementSize({
        el: el,
        horizontal: false,
        useFractionalSize: useFractionalSize,
        useOffset: true,
        style: elStyle
      }) : this._size;
    }
    this.updatePosition();
    this._updateAlignPos();
    return this;
  };
  /**
   * Change panel's size. This will change the actual size of the panel element by changing its CSS width/height property
   * @ko 패널 크기를 변경합니다. 패널 엘리먼트에 해당 크기의 CSS width/height를 적용합니다
   * @param {object} [size] New panel size<ko>새 패널 크기</ko>
   * @param {number|string} [size.width] CSS string or number(in px)<ko>CSS 문자열 또는 숫자(px)</ko>
   * @param {number|string} [size.height] CSS string or number(in px)<ko>CSS 문자열 또는 숫자(px)</ko>
   * @chainable
   * @return {this}
   */
  __proto.setSize = function (size) {
    setSize(this.element, size);
    return this;
  };
  /**
   * Check whether the given element is inside of this panel's {@link Panel#element element}
   * @ko 해당 엘리먼트가 이 패널의 {@link Panel#element element} 내에 포함되어 있는지를 반환합니다
   * @param {HTMLElement} element The HTMLElement to check<ko>확인하고자 하는 HTMLElement</ko>
   * @return {boolean} A Boolean value indicating the element is inside of this panel {@link Panel#element element}<ko>패널의 {@link Panel#element element}내에 해당 엘리먼트 포함 여부</ko>
   */
  __proto.contains = function (element) {
    var _a;
    return !!((_a = this.element) === null || _a === void 0 ? void 0 : _a.contains(element));
  };
  /**
   * Reset internal state and set {@link Panel#removed removed} to `true`
   * @ko 내부 상태를 초기화하고 {@link Panel#removed removed}를 `true`로 설정합니다.
   * @return {void}
   */
  __proto.destroy = function () {
    this._resetInternalStates();
    this._removed = true;
  };
  /**
   * Check whether the given position is inside of this panel's {@link Panel#range range}
   * @ko 주어진 좌표가 현재 패널의 {@link Panel#range range}내에 속해있는지를 반환합니다.
   * @param {number} pos A position to check<ko>확인하고자 하는 좌표</ko>
   * @param {boolean} [includeMargin=false] Include {@link Panel#margin margin} to the range<ko>패널 영역에 {@link Panel#margin margin}값을 포함시킵니다</ko>
   * @return {boolean} A Boolean value indicating whether the given position is included in the panel range<ko>해당 좌표가 패널 영역 내에 속해있는지 여부</ko>
   */
  __proto.includePosition = function (pos, includeMargin) {
    if (includeMargin === void 0) {
      includeMargin = false;
    }
    return this.includeRange(pos, pos, includeMargin);
  };
  /**
   * Check whether the given range is fully included in this panel's area (inclusive)
   * @ko 주어진 범위가 이 패널 내부에 완전히 포함되는지를 반환합니다
   * @param {number} min Minimum value of the range to check<ko>확인하고자 하는 최소 범위</ko>
   * @param {number} max Maximum value of the range to check<ko>확인하고자 하는 최대 범위</ko>
   * @param {boolean} [includeMargin=false] Include {@link Panel#margin margin} to the range<ko>패널 영역에 {@link Panel#margin margin}값을 포함시킵니다</ko>
   * @returns {boolean} A Boolean value indicating whether the given range is fully included in the panel range<ko>해당 범위가 패널 영역 내에 완전히 속해있는지 여부</ko>
   */
  __proto.includeRange = function (min, max, includeMargin) {
    if (includeMargin === void 0) {
      includeMargin = false;
    }
    var margin = this._margin;
    var panelRange = this.range;
    if (includeMargin) {
      panelRange.min -= margin.prev;
      panelRange.max += margin.next;
    }
    return max >= panelRange.min && min <= panelRange.max;
  };
  /**
   * Check whether the panel is visble in the given range (exclusive)
   * @ko 주어진 범위 내에서 이 패널의 일부가 보여지는지를 반환합니다
   * @param {number} min Minimum value of the range to check<ko>확인하고자 하는 최소 범위</ko>
   * @param {number} max Maximum value of the range to check<ko>확인하고자 하는 최대 범위</ko>
   * @returns {boolean} A Boolean value indicating whether the panel is visible<ko>해당 범위 내에서 패널을 볼 수 있는지 여부</ko>
   */
  __proto.isVisibleOnRange = function (min, max) {
    var panelRange = this.range;
    return max > panelRange.min && min < panelRange.max;
  };
  /**
   * Move {@link Camera} to this panel
   * @ko {@link Camera}를 이 패널로 이동합니다
   * @param {number} [duration] Duration of the animation (unit: ms)<ko>애니메이션 진행 시간 (단위: ms)</ko>
   * @returns {Promise<void>} A Promise which will be resolved after reaching the panel<ko>패널 도달시에 resolve되는 Promise</ko>
   */
  __proto.focus = function (duration) {
    return this._flicking.moveTo(this._index, duration);
  };
  /**
   * Get previous(`index - 1`) panel. When the previous panel does not exist, this will return `null` instead
   * If the {@link Flicking#circularEnabled circular} is enabled, this will return the last panel if called from the first panel
   * @ko 이전(`index - 1`) 패널을 반환합니다. 이전 패널이 없을 경우 `null`을 반환합니다
   * {@link Flicking#circularEnabled circular} 모드가 활성화되었을 때 첫번째 패널에서 이 메소드를 호출할 경우 마지막 패널을 반환합니다
   * @returns {Panel | null} The previous panel<ko>이전 패널</ko>
   */
  __proto.prev = function () {
    var index = this._index;
    var flicking = this._flicking;
    var renderer = flicking.renderer;
    var panelCount = renderer.panelCount;
    if (panelCount === 1) return null;
    return flicking.circularEnabled ? renderer.getPanel(index === 0 ? panelCount - 1 : index - 1) : renderer.getPanel(index - 1);
  };
  /**
   * Get next(`index + 1`) panel. When the next panel does not exist, this will return `null` instead
   * If the {@link Flicking#circularEnabled circular} is enabled, this will return the first panel if called from the last panel
   * @ko 다음(`index + 1`) 패널을 반환합니다. 다음 패널이 없을 경우 `null`을 반환합니다
   * {@link Flicking#circularEnabled circular} 모드가 활성화되었을 때 마지막 패널에서 이 메소드를 호출할 경우 첫번째 패널을 반환합니다
   * @returns {Panel | null} The previous panel<ko>다음 패널</ko>
   */
  __proto.next = function () {
    var index = this._index;
    var flicking = this._flicking;
    var renderer = flicking.renderer;
    var panelCount = renderer.panelCount;
    if (panelCount === 1) return null;
    return flicking.circularEnabled ? renderer.getPanel(index === panelCount - 1 ? 0 : index + 1) : renderer.getPanel(index + 1);
  };
  /**
   * Increase panel's index by the given value
   * @ko 패널의 인덱스를 주어진 값만큼 증가시킵니다
   * @internal
   * @chainable
   * @param val An integer greater than or equal to 0<ko>0보다 같거나 큰 정수</ko>
   * @returns {this}
   */
  __proto.increaseIndex = function (val) {
    this._index += Math.max(val, 0);
    return this;
  };
  /**
   * Decrease panel's index by the given value
   * @ko 패널의 인덱스를 주어진 값만큼 감소시킵니다
   * @internal
   * @chainable
   * @param val An integer greater than or equal to 0<ko>0보다 같거나 큰 정수</ko>
   * @returns {this}
   */
  __proto.decreaseIndex = function (val) {
    this._index -= Math.max(val, 0);
    return this;
  };
  /**
   * @internal
   */
  __proto.updatePosition = function () {
    var prevPanel = this._flicking.renderer.panels[this._index - 1];
    this._pos = prevPanel ? prevPanel.range.max + prevPanel.margin.next + this._margin.prev : this._margin.prev;
    return this;
  };
  /**
   * @internal
   * @return {boolean} toggled
   */
  __proto.toggle = function (prevPos, newPos) {
    var toggleDirection = this._toggleDirection;
    var togglePosition = this._togglePosition;
    if (toggleDirection === DIRECTION.NONE || newPos === prevPos) return false;
    var prevToggled = this._toggled;
    if (newPos > prevPos) {
      if (togglePosition >= prevPos && togglePosition <= newPos) {
        this._toggled = toggleDirection === DIRECTION.NEXT;
      }
    } else {
      if (togglePosition <= prevPos && togglePosition >= newPos) {
        this._toggled = toggleDirection !== DIRECTION.NEXT;
      }
    }
    return prevToggled !== this._toggled;
  };
  /**
   * @internal
   */
  __proto.updateCircularToggleDirection = function () {
    var flicking = this._flicking;
    if (!flicking.circularEnabled) {
      this._toggleDirection = DIRECTION.NONE;
      this._togglePosition = 0;
      this._toggled = false;
      return this;
    }
    var camera = flicking.camera;
    var camRange = camera.range;
    var camAlignPosition = camera.alignPosition;
    var camVisibleRange = camera.visibleRange;
    var camVisibleSize = camVisibleRange.max - camVisibleRange.min;
    var minimumVisible = camRange.min - camAlignPosition;
    var maximumVisible = camRange.max - camAlignPosition + camVisibleSize;
    var shouldBeVisibleAtMin = this.includeRange(maximumVisible - camVisibleSize, maximumVisible, false);
    var shouldBeVisibleAtMax = this.includeRange(minimumVisible, minimumVisible + camVisibleSize, false);
    this._toggled = false;
    if (shouldBeVisibleAtMin) {
      this._toggleDirection = DIRECTION.PREV;
      this._togglePosition = this.range.max + camRange.min - camRange.max + camAlignPosition;
      this.toggle(Infinity, camera.position);
    } else if (shouldBeVisibleAtMax) {
      this._toggleDirection = DIRECTION.NEXT;
      this._togglePosition = this.range.min + camRange.max - camVisibleSize + camAlignPosition;
      this.toggle(-Infinity, camera.position);
    } else {
      this._toggleDirection = DIRECTION.NONE;
      this._togglePosition = 0;
    }
    return this;
  };
  __proto._updateAlignPos = function () {
    this._alignPos = parseAlign$1(this._align, this._size);
  };
  __proto._resetInternalStates = function () {
    this._size = 0;
    this._pos = 0;
    this._margin = {
      prev: 0,
      next: 0
    };
    this._height = 0;
    this._alignPos = 0;
    this._toggled = false;
    this._togglePosition = 0;
    this._toggleDirection = DIRECTION.NONE;
  };
  return Panel;
}();

var NormalRenderingStrategy = /*#__PURE__*/function () {
  function NormalRenderingStrategy(_a) {
    var providerCtor = _a.providerCtor;
    this._providerCtor = providerCtor;
  }
  var __proto = NormalRenderingStrategy.prototype;
  __proto.renderPanels = function () {
    // DO_NOTHING
  };
  __proto.getRenderingIndexesByOrder = function (flicking) {
    var renderedPanels = flicking.renderer.panels.filter(function (panel) {
      return panel.rendered;
    });
    var toggledPrev = renderedPanels.filter(function (panel) {
      return panel.toggled && panel.toggleDirection === DIRECTION.PREV;
    });
    var toggledNext = renderedPanels.filter(function (panel) {
      return panel.toggled && panel.toggleDirection === DIRECTION.NEXT;
    });
    var notToggled = renderedPanels.filter(function (panel) {
      return !panel.toggled;
    });
    return __spread$1(toggledPrev, notToggled, toggledNext).map(function (panel) {
      return panel.index;
    });
  };
  __proto.getRenderingElementsByOrder = function (flicking) {
    var panels = flicking.panels;
    return this.getRenderingIndexesByOrder(flicking).map(function (index) {
      return panels[index].element;
    });
  };
  __proto.updateRenderingPanels = function (flicking) {
    if (flicking.renderOnlyVisible) {
      this._showOnlyVisiblePanels(flicking);
    } else {
      flicking.panels.forEach(function (panel) {
        return panel.markForShow();
      });
    }
  };
  __proto.collectPanels = function (flicking, elements) {
    var _this = this;
    var align = parsePanelAlign(flicking.renderer.align);
    return elements.map(function (el, index) {
      return new Panel({
        index: index,
        elementProvider: new _this._providerCtor(el),
        align: align,
        flicking: flicking
      });
    });
  };
  __proto.createPanel = function (element, options) {
    return new Panel(__assign$2(__assign$2({}, options), {
      elementProvider: new this._providerCtor(element)
    }));
  };
  __proto.updatePanelSizes = function (flicking, size) {
    flicking.panels.forEach(function (panel) {
      return panel.setSize(size);
    });
  };
  __proto._showOnlyVisiblePanels = function (flicking) {
    var panels = flicking.renderer.panels;
    var camera = flicking.camera;
    var visibleIndexes = camera.visiblePanels.reduce(function (visibles, panel) {
      visibles[panel.index] = true;
      return visibles;
    }, {});
    panels.forEach(function (panel) {
      if (panel.index in visibleIndexes || panel.loading) {
        panel.markForShow();
      } else if (!flicking.holding) {
        // During the input sequence,
        // Do not remove panel elements as it won't trigger touchend event.
        panel.markForHide();
      }
    });
    camera.updateOffset();
  };
  return NormalRenderingStrategy;
}();

/**
 * An slide data component that holds information of a single HTMLElement
 * @ko 슬라이드 데이터 컴포넌트로, 단일 HTMLElement의 정보를 갖고 있습니다
 */
var VirtualPanel = /*#__PURE__*/function (_super) {
  __extends$3(VirtualPanel, _super);
  /**
   * @param {object} options An options object<ko>옵션 오브젝트</ko>
   * @param {number} [options.index] An initial index of the panel<ko>패널의 초기 인덱스</ko>
   * @param {Constants.ALIGN | string | number} [options.align] An initial {@link Flicking#align align} value of the panel<ko>패널의 초기 {@link Flicking#align align}값</ko>
   * @param {Flicking} [options.flicking] A Flicking instance panel's referencing<ko>패널이 참조하는 {@link Flicking} 인스턴스</ko>
   */
  function VirtualPanel(options) {
    var _this = _super.call(this, options) || this;
    options.elementProvider.init(_this);
    _this._elProvider = options.elementProvider;
    _this._cachedInnerHTML = null;
    return _this;
  }
  var __proto = VirtualPanel.prototype;
  Object.defineProperty(__proto, "element", {
    /**
     * `HTMLElement` that panel's referencing
     * @ko 패널이 참조하고 있는 `HTMLElement`
     * @type {HTMLElement}
     * @readonly
     */
    get: function () {
      return this._elProvider.element;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "cachedInnerHTML", {
    /**
     * Cached innerHTML by the previous render function
     * @ko 이전 렌더링에서 캐시된 innerHTML 정보
     * @type {string|null}
     * @readonly
     */
    get: function () {
      return this._cachedInnerHTML;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "elementIndex", {
    /**
     * An number for indexing which element it will be rendered on
     * @ko 몇 번째 엘리먼트에 렌더링될 것인지를 나타내는 숫자
     * @type {number}
     * @readonly
     */
    get: function () {
      var flicking = this._flicking;
      var virtualElCount = flicking.panelsPerView + 1;
      var panelCount = flicking.panelCount;
      var index = this._index;
      if (this._toggled) {
        // To prevent element duplication
        index = this._toggleDirection === DIRECTION.NEXT ? index + panelCount : index - panelCount;
      }
      return circulateIndex(index, virtualElCount);
    },
    enumerable: false,
    configurable: true
  });
  __proto.cacheRenderResult = function (result) {
    this._cachedInnerHTML = result;
  };
  __proto.uncacheRenderResult = function () {
    this._cachedInnerHTML = null;
  };
  __proto.render = function () {
    var flicking = this._flicking;
    var _a = flicking.virtual,
      renderPanel = _a.renderPanel,
      cache = _a.cache;
    var element = this._elProvider.element;
    var newInnerHTML = this._cachedInnerHTML || renderPanel(this, this._index);
    if (newInnerHTML === element.innerHTML) return;
    element.innerHTML = newInnerHTML;
    if (cache) {
      this.cacheRenderResult(newInnerHTML);
    }
  };
  __proto.increaseIndex = function (val) {
    this.uncacheRenderResult();
    return _super.prototype.increaseIndex.call(this, val);
  };
  __proto.decreaseIndex = function (val) {
    this.uncacheRenderResult();
    return _super.prototype.decreaseIndex.call(this, val);
  };
  return VirtualPanel;
}(Panel);

var VirtualRenderingStrategy = /*#__PURE__*/function () {
  function VirtualRenderingStrategy() {}
  var __proto = VirtualRenderingStrategy.prototype;
  __proto.renderPanels = function (flicking) {
    var virtualManager = flicking.virtual;
    var visiblePanels = flicking.visiblePanels;
    var invisibleIndexes = range(flicking.panelsPerView + 1);
    visiblePanels.forEach(function (panel) {
      var elementIndex = panel.elementIndex;
      panel.render();
      virtualManager.show(elementIndex);
      invisibleIndexes[elementIndex] = -1;
    });
    invisibleIndexes.filter(function (val) {
      return val >= 0;
    }).forEach(function (idx) {
      virtualManager.hide(idx);
    });
  };
  __proto.getRenderingIndexesByOrder = function (flicking) {
    var virtualManager = flicking.virtual;
    var visiblePanels = __spread$1(flicking.visiblePanels).filter(function (panel) {
      return panel.rendered;
    }).sort(function (panel1, panel2) {
      return panel1.position + panel1.offset - (panel2.position + panel2.offset);
    });
    if (visiblePanels.length <= 0) return virtualManager.elements.map(function (_, idx) {
      return idx;
    });
    var visibleIndexes = visiblePanels.map(function (panel) {
      return panel.elementIndex;
    });
    var invisibleIndexes = virtualManager.elements.map(function (el, idx) {
      return __assign$2(__assign$2({}, el), {
        idx: idx
      });
    }).filter(function (el) {
      return !el.visible;
    }).map(function (el) {
      return el.idx;
    });
    return __spread$1(visibleIndexes, invisibleIndexes);
  };
  __proto.getRenderingElementsByOrder = function (flicking) {
    var virtualManager = flicking.virtual;
    var elements = virtualManager.elements;
    return this.getRenderingIndexesByOrder(flicking).map(function (index) {
      return elements[index].nativeElement;
    });
  };
  __proto.updateRenderingPanels = function (flicking) {
    var panels = flicking.renderer.panels;
    var camera = flicking.camera;
    var visibleIndexes = camera.visiblePanels.reduce(function (visibles, panel) {
      visibles[panel.index] = true;
      return visibles;
    }, {});
    panels.forEach(function (panel) {
      if (panel.index in visibleIndexes || panel.loading) {
        panel.markForShow();
      } else {
        panel.markForHide();
      }
    });
    camera.updateOffset();
  };
  __proto.collectPanels = function (flicking) {
    var align = parsePanelAlign(flicking.renderer.align);
    return range(flicking.virtual.initialPanelCount).map(function (index) {
      return new VirtualPanel({
        index: index,
        elementProvider: new VirtualElementProvider(flicking),
        align: align,
        flicking: flicking
      });
    });
  };
  __proto.createPanel = function (_el, options) {
    return new VirtualPanel(__assign$2(__assign$2({}, options), {
      elementProvider: new VirtualElementProvider(options.flicking)
    }));
  };
  __proto.updatePanelSizes = function (flicking, size) {
    flicking.virtual.elements.forEach(function (el) {
      setSize(el.nativeElement, size);
    });
    flicking.panels.forEach(function (panel) {
      return panel.setSize(size);
    });
  };
  return VirtualRenderingStrategy;
}();

/**
 * @extends Component
 * @support {"ie": "9+(with polyfill)", "ch" : "latest", "ff" : "latest",  "sf" : "latest", "edge" : "latest", "ios" : "7+", "an" : "4.X+"}
 * @requires {@link https://github.com/naver/egjs-component|@egjs/component}
 * @requires {@link https://github.com/naver/egjs-axes|@egjs/axes}
 */
var Flicking = /*#__PURE__*/function (_super) {
  __extends$3(Flicking, _super);
  /**
   * @param root A root HTMLElement to initialize Flicking on it. When it's a typeof `string`, it should be a css selector string
   * <ko>Flicking을 초기화할 HTMLElement로, `string` 타입으로 지정시 css 선택자 문자열을 지정해야 합니다.</ko>
   * @param {object} [options={}] An options object for Flicking.<ko>Flicking에 적용할 옵션 오브젝트</ko>
   * @throws {FlickingError}
   * |code|condition|
   * |---|---|
   * |{@link ERROR_CODE WRONG_TYPE}|When the root is not either string or HTMLElement|
   * |{@link ERROR_CODE ELEMENT_NOT_FOUND}|When the element with given CSS selector does not exist|
   * <ko>
   *
   * |code|조건|
   * |---|---|
   * |{@link ERROR_CODE WRONG_TYPE}|루트 엘리먼트가 string이나 HTMLElement가 아닐 경우|
   * |{@link ERROR_CODE ELEMENT_NOT_FOUND}|주어진 CSS selector로 엘리먼트를 찾지 못했을 경우|
   *
   * </ko>
   * @example
   * ```ts
   * import Flicking from "@egjs/flicking";
   *
   * // Creating new instance of Flicking with HTMLElement
   * const flicking = new Flicking(document.querySelector(".flicking-viewport"), { circular: true });
   *
   * // Creating new instance of Flicking with CSS selector
   * const flicking2 = new Flicking(".flicking-viewport", { circular: true });
   * ```
   */
  function Flicking(root, _a) {
    var _b = _a === void 0 ? {} : _a,
      _c = _b.align,
      align = _c === void 0 ? ALIGN.CENTER : _c,
      _d = _b.defaultIndex,
      defaultIndex = _d === void 0 ? 0 : _d,
      _e = _b.horizontal,
      horizontal = _e === void 0 ? true : _e,
      _f = _b.circular,
      circular = _f === void 0 ? false : _f,
      _g = _b.circularFallback,
      circularFallback = _g === void 0 ? CIRCULAR_FALLBACK.LINEAR : _g,
      _h = _b.bound,
      bound = _h === void 0 ? false : _h,
      _j = _b.adaptive,
      adaptive = _j === void 0 ? false : _j,
      _k = _b.panelsPerView,
      panelsPerView = _k === void 0 ? -1 : _k,
      _l = _b.noPanelStyleOverride,
      noPanelStyleOverride = _l === void 0 ? false : _l,
      _m = _b.resizeOnContentsReady,
      resizeOnContentsReady = _m === void 0 ? false : _m,
      _o = _b.nested,
      nested = _o === void 0 ? false : _o,
      _p = _b.needPanelThreshold,
      needPanelThreshold = _p === void 0 ? 0 : _p,
      _q = _b.preventEventsBeforeInit,
      preventEventsBeforeInit = _q === void 0 ? true : _q,
      _r = _b.deceleration,
      deceleration = _r === void 0 ? 0.0075 : _r,
      _s = _b.duration,
      duration = _s === void 0 ? 500 : _s,
      _t = _b.easing,
      easing = _t === void 0 ? function (x) {
        return 1 - Math.pow(1 - x, 3);
      } : _t,
      _u = _b.inputType,
      inputType = _u === void 0 ? ["mouse", "touch"] : _u,
      _v = _b.moveType,
      moveType = _v === void 0 ? "snap" : _v,
      _w = _b.threshold,
      threshold = _w === void 0 ? 40 : _w,
      _x = _b.interruptable,
      interruptable = _x === void 0 ? true : _x,
      _y = _b.bounce,
      bounce = _y === void 0 ? "20%" : _y,
      _z = _b.iOSEdgeSwipeThreshold,
      iOSEdgeSwipeThreshold = _z === void 0 ? 30 : _z,
      _0 = _b.preventClickOnDrag,
      preventClickOnDrag = _0 === void 0 ? true : _0,
      _1 = _b.preventDefaultOnDrag,
      preventDefaultOnDrag = _1 === void 0 ? false : _1,
      _2 = _b.disableOnInit,
      disableOnInit = _2 === void 0 ? false : _2,
      _3 = _b.changeOnHold,
      changeOnHold = _3 === void 0 ? false : _3,
      _4 = _b.renderOnlyVisible,
      renderOnlyVisible = _4 === void 0 ? false : _4,
      _5 = _b.virtual,
      virtual = _5 === void 0 ? null : _5,
      _6 = _b.autoInit,
      autoInit = _6 === void 0 ? true : _6,
      _7 = _b.autoResize,
      autoResize = _7 === void 0 ? true : _7,
      _8 = _b.useResizeObserver,
      useResizeObserver = _8 === void 0 ? true : _8,
      _9 = _b.resizeDebounce,
      resizeDebounce = _9 === void 0 ? 0 : _9,
      _10 = _b.maxResizeDebounce,
      maxResizeDebounce = _10 === void 0 ? 100 : _10,
      _11 = _b.useFractionalSize,
      useFractionalSize = _11 === void 0 ? false : _11,
      _12 = _b.externalRenderer,
      externalRenderer = _12 === void 0 ? null : _12,
      _13 = _b.renderExternal,
      renderExternal = _13 === void 0 ? null : _13;
    var _this = _super.call(this) || this;
    // Internal states
    _this._initialized = false;
    _this._plugins = [];
    // Bind options
    _this._align = align;
    _this._defaultIndex = defaultIndex;
    _this._horizontal = horizontal;
    _this._circular = circular;
    _this._circularFallback = circularFallback;
    _this._bound = bound;
    _this._adaptive = adaptive;
    _this._panelsPerView = panelsPerView;
    _this._noPanelStyleOverride = noPanelStyleOverride;
    _this._resizeOnContentsReady = resizeOnContentsReady;
    _this._nested = nested;
    _this._virtual = virtual;
    _this._needPanelThreshold = needPanelThreshold;
    _this._preventEventsBeforeInit = preventEventsBeforeInit;
    _this._deceleration = deceleration;
    _this._duration = duration;
    _this._easing = easing;
    _this._inputType = inputType;
    _this._moveType = moveType;
    _this._threshold = threshold;
    _this._interruptable = interruptable;
    _this._bounce = bounce;
    _this._iOSEdgeSwipeThreshold = iOSEdgeSwipeThreshold;
    _this._preventClickOnDrag = preventClickOnDrag;
    _this._preventDefaultOnDrag = preventDefaultOnDrag;
    _this._disableOnInit = disableOnInit;
    _this._changeOnHold = changeOnHold;
    _this._renderOnlyVisible = renderOnlyVisible;
    _this._autoInit = autoInit;
    _this._autoResize = autoResize;
    _this._useResizeObserver = useResizeObserver;
    _this._resizeDebounce = resizeDebounce;
    _this._maxResizeDebounce = maxResizeDebounce;
    _this._useFractionalSize = useFractionalSize;
    _this._externalRenderer = externalRenderer;
    _this._renderExternal = renderExternal;
    // Create core components
    _this._viewport = new Viewport(_this, getElement(root));
    _this._autoResizer = new AutoResizer(_this);
    _this._renderer = _this._createRenderer();
    _this._camera = _this._createCamera();
    _this._control = _this._createControl();
    _this._virtualManager = new VirtualManager(_this, virtual);
    if (_this._autoInit) {
      void _this.init();
    }
    return _this;
  }
  var __proto = Flicking.prototype;
  Object.defineProperty(__proto, "control", {
    // Components
    /**
     * {@link Control} instance of the Flicking
     * @ko 현재 Flicking에 활성화된 {@link Control} 인스턴스
     * @type {Control}
     * @default SnapControl
     * @readonly
     * @see Control
     * @see SnapControl
     * @see FreeControl
     */
    get: function () {
      return this._control;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "camera", {
    /**
     * {@link Camera} instance of the Flicking
     * @ko 현재 Flicking에 활성화된 {@link Camera} 인스턴스
     * @type {Camera}
     * @default LinearCamera
     * @readonly
     * @see Camera
     * @see LinearCamera
     * @see BoundCamera
     * @see CircularCamera
     */
    get: function () {
      return this._camera;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "renderer", {
    /**
     * {@link Renderer} instance of the Flicking
     * @ko 현재 Flicking에 활성화된 {@link Renderer} 인스턴스
     * @type {Renderer}
     * @default VanillaRenderer
     * @readonly
     * @see Renderer
     * @see VanillaRenderer
     * @see ExternalRenderer
     */
    get: function () {
      return this._renderer;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "viewport", {
    /**
     * A component that manages viewport size
     * @ko 뷰포트 크기 정보를 담당하는 컴포넌트
     * @type {Viewport}
     * @readonly
     * @see Viewport
     */
    get: function () {
      return this._viewport;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "initialized", {
    // Internal States
    /**
     * Whether Flicking's {@link Flicking#init init()} is called.
     * This is `true` when {@link Flicking#init init()} is called, and is `false` after calling {@link Flicking#destroy destroy()}.
     * @ko Flicking의 {@link Flicking#init init()}이 호출되었는지를 나타내는 멤버 변수.
     * 이 값은 {@link Flicking#init init()}이 호출되었으면 `true`로 변하고, {@link Flicking#destroy destroy()}호출 이후에 다시 `false`로 변경됩니다.
     * @type {boolean}
     * @default false
     * @readonly
     */
    get: function () {
      return this._initialized;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "circularEnabled", {
    /**
     * Whether the `circular` option is enabled.
     * The {@link Flicking#circular circular} option can't be enabled when sum of the panel sizes are too small.
     * @ko {@link Flicking#circular circular} 옵션이 활성화되었는지 여부를 나타내는 멤버 변수.
     * {@link Flicking#circular circular} 옵션은 패널의 크기의 합이 충분하지 않을 경우 비활성화됩니다.
     * @type {boolean}
     * @default false
     * @readonly
     */
    get: function () {
      return this._camera.circularEnabled;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "virtualEnabled", {
    /**
     * Whether the `virtual` option is enabled.
     * The {@link Flicking#virtual virtual} option can't be enabled when  {@link Flicking#panelsPerView panelsPerView} is less or equal than zero.
     * @ko {@link Flicking#virtual virtual} 옵션이 활성화되었는지 여부를 나타내는 멤버 변수.
     * {@link Flicking#virtual virtual} 옵션은 {@link Flicking#panelsPerView panelsPerView} 옵션의 값이 0보다 같거나 작으면 비활성화됩니다.
     * @type {boolean}
     * @default false
     * @readonly
     */
    get: function () {
      return this._panelsPerView > 0 && this._virtual != null;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "index", {
    /**
     * Index number of the {@link Flicking#currentPanel currentPanel}
     * @ko {@link Flicking#currentPanel currentPanel}의 인덱스 번호
     * @type {number}
     * @default 0
     * @readonly
     */
    get: function () {
      return this._control.activeIndex;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "element", {
    /**
     * The root(`.flicking-viewport`) element
     * @ko root(`.flicking-viewport`) 엘리먼트
     * @type {HTMLElement}
     * @readonly
     */
    get: function () {
      return this._viewport.element;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "currentPanel", {
    /**
     * Currently active panel
     * @ko 현재 선택된 패널
     * @type {Panel}
     * @readonly
     * @see Panel
     */
    get: function () {
      return this._control.activePanel;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "panels", {
    /**
     * Array of panels
     * @ko 전체 패널들의 배열
     * @type {Panel[]}
     * @readonly
     * @see Panel
     */
    get: function () {
      return this._renderer.panels;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "panelCount", {
    /**
     * Count of panels
     * @ko 전체 패널의 개수
     * @type {number}
     * @readonly
     */
    get: function () {
      return this._renderer.panelCount;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "visiblePanels", {
    /**
     * Array of panels that is visible at the current position
     * @ko 현재 보이는 패널의 배열
     * @type {Panel[]}
     * @readonly
     * @see Panel
     */
    get: function () {
      return this._camera.visiblePanels;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "animating", {
    /**
     * Whether Flicking's animating
     * @ko 현재 애니메이션 동작 여부
     * @type {boolean}
     * @readonly
     */
    get: function () {
      return this._control.animating;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "holding", {
    /**
     * Whether user is clicking or touching
     * @ko 현재 사용자가 클릭/터치중인지 여부
     * @type {boolean}
     * @readonly
     */
    get: function () {
      return this._control.holding;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "activePlugins", {
    /**
     * A current list of activated plugins
     * @ko 현재 활성화된 플러그인 목록
     * @type {Plugin[]}
     * @readonly
     */
    get: function () {
      return this._plugins;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "align", {
    // Options Getter
    // UI / LAYOUT
    /**
     * Align position of the panels within viewport. You can set different values each for the panel and camera
     * @ko 뷰포트 내에서 패널 정렬방식을 설정하는 옵션. 카메라와 패널 개별로 옵션을 설정할 수도 있습니다
     * @type {ALIGN | string | number | { panel: string | number, camera: string | number }}
     * @property {ALIGN | string | number} panel The align value for each {@link Panel}s<ko>개개의 {@link Panel}에 적용할 값</ko>
     * @property {ALIGN | string | number} camera The align value for {@link Camera}<ko>{@link Camera}에 적용할 값</ko>
     * @default "center"
     * @see {@link https://naver.github.io/egjs-flicking/Options#align align ( Options )}
     * @example
     * ```ts
     * const possibleOptions = [
     *   // Literal strings
     *   "prev", "center", "next",
     *   // % values, applied to both panel & camera
     *   "0%", "25%", "42%",
     *   // px values, arithmetic calculation with (+/-) is also allowed.
     *   "0px", "100px", "50% - 25px",
     *   // numbers, same to number + px ("0px", "100px")
     *   0, 100, 1000,
     *   // Setting a different value for panel & camera
     *   { panel: "10%", camera: "25%" }
     * ];
     *
     * possibleOptions.forEach(align => {
     *   new Flicking("#el", { align });
     * });
     * ```
     */
    get: function () {
      return this._align;
    },
    // Options Setter
    // UI / LAYOUT
    set: function (val) {
      this._align = val;
      this._renderer.align = val;
      this._camera.align = val;
      void this.resize();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "defaultIndex", {
    /**
     * Index of the panel to move when Flicking's {@link Flicking#init init()} is called. A zero-based integer
     * @ko Flicking의 {@link Flicking#init init()}이 호출될 때 이동할 디폴트 패널의 인덱스로, 0부터 시작하는 정수입니다
     * @type {number}
     * @default 0
     * @see {@link https://naver.github.io/egjs-flicking/Options#defaultindex defaultIndex ( Options )}
     */
    get: function () {
      return this._defaultIndex;
    },
    set: function (val) {
      this._defaultIndex = val;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "horizontal", {
    /**
     * Direction of panel movement (true: horizontal, false: vertical)
     * @ko 패널 이동 방향 (true: 가로방향, false: 세로방향)
     * @type {boolean}
     * @default true
     * @see {@link https://naver.github.io/egjs-flicking/Options#horizontal horizontal ( Options )}
     */
    get: function () {
      return this._horizontal;
    },
    set: function (val) {
      this._horizontal = val;
      this._control.controller.updateDirection();
      void this.resize();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "circular", {
    /**
     * Enables circular(continuous loop) mode, which connects first/last panel for continuous scrolling.
     * @ko 순환 모드를 활성화합니다. 순환 모드에서는 양 끝의 패널이 서로 연결되어 끊김없는 스크롤이 가능합니다.
     * @type {boolean}
     * @default false
     * @see {@link https://naver.github.io/egjs-flicking/Options#circular circular ( Options )}
     */
    get: function () {
      return this._circular;
    },
    set: function (val) {
      this._circular = val;
      void this.resize();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "circularFallback", {
    /**
     * Set panel control mode for the case when circular cannot be enabled.
     * "linear" will set the view's range from the top of the first panel to the top of the last panel.
     * "bound" will prevent the view from going out of the first/last panel, so it won't show empty spaces before/after the first/last panel.
     * @ko 순환 모드 사용 불가능시 사용할 패널 조작 범위 설정 방식을 변경합니다.
     * "linear" 사용시 시점이 첫번째 엘리먼트 위에서부터 마지막 엘리먼트 위까지 움직일 수 있도록 설정합니다.
     * "bound" 사용시 시점이 첫번째 엘리먼트와 마지막 엘리먼트의 끝과 끝 사이에서 움직일 수 있도록 설정합니다.
     * @see CIRCULAR_FALLBACK
     * @type {string}
     * @default "linear"
     * @see {@link https://naver.github.io/egjs-flicking/Options#circularfallback circularFallback ( Options )}
     */
    get: function () {
      return this._circularFallback;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "bound", {
    /**
     * Prevent the view(camera element) from going out of the first/last panel, so it won't show empty spaces before/after the first/last panel
     * Only can be enabled when `circular=false`
     * @ko 뷰(카메라 엘리먼트)가 첫번째와 마지막 패널 밖으로 넘어가지 못하게 하여, 첫번째/마지막 패널 전/후의 빈 공간을 보이지 않도록 하는 옵션입니다
     * `circular=false`인 경우에만 사용할 수 있습니다
     * @type {boolean}
     * @default false
     * @see {@link https://naver.github.io/egjs-flicking/Options#bound bound ( Options )}
     */
    get: function () {
      return this._bound;
    },
    set: function (val) {
      this._bound = val;
      void this.resize();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "adaptive", {
    /**
     * Update height of the viewport element after movement same to the height of the panel below. This can be only enabled when `horizontal=true`
     * @ko 이동한 후 뷰포트 엘리먼트의 크기를 현재 패널의 높이와 동일하게 설정합니다. `horizontal=true`인 경우에만 사용할 수 있습니다.
     * @type {boolean}
     * @default false
     * @see {@link https://naver.github.io/egjs-flicking/Options#adaptive adaptive ( Options )}
     */
    get: function () {
      return this._adaptive;
    },
    set: function (val) {
      this._adaptive = val;
      void this.resize();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "panelsPerView", {
    /**
     * A visible number of panels on viewport. Enabling this option will automatically resize panel size
     * @ko 한 화면에 보이는 패널의 개수. 이 옵션을 활성화할 경우 패널의 크기를 강제로 재조정합니다
     * @type {number}
     * @default -1
     * @see {@link https://naver.github.io/egjs-flicking/Options#panelsperview panelsPerView ( Options )}
     */
    get: function () {
      return this._panelsPerView;
    },
    set: function (val) {
      this._panelsPerView = val;
      void this.resize();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "noPanelStyleOverride", {
    /**
     * Enabling this option will not change `width/height` style of the panels if {@link Flicking#panelsPerView} is enabled.
     * This behavior can be useful in terms of performance when you're manually managing all panel sizes
     * @ko 이 옵션을 활성화할 경우, {@link Flicking#panelsPerView} 옵션이 활성화되었을 때 패널의 `width/height` 스타일을 변경하지 않도록 설정합니다.
     * 모든 패널들의 크기를 직접 관리하고 있을 경우, 이 옵션을 활성화하면 성능면에서 유리할 수 있습니다
     * @type {boolean}
     * @default false
     */
    get: function () {
      return this._noPanelStyleOverride;
    },
    set: function (val) {
      this._noPanelStyleOverride = val;
      void this.resize();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "resizeOnContentsReady", {
    /**
     * Enabling this option will automatically call {@link Flicking#resize} when all image/video inside panels are loaded.
     * This can be useful when you have contents inside Flicking that changes its size when it's loaded
     * @ko 이 옵션을 활성화할 경우, Flicking 패널 내부의 이미지/비디오들이 로드되었을 때 자동으로 {@link Flicking#resize}를 호출합니다.
     * 이 동작은 Flicking 내부에 로드 전/후로 크기가 변하는 콘텐츠를 포함하고 있을 때 유용하게 사용하실 수 있습니다.
     * @type {boolean}
     * @default false
     * @see {@link https://naver.github.io/egjs-flicking/Options#resizeOnContentsReady resizeOnContentsReady ( Options )}
     */
    get: function () {
      return this._resizeOnContentsReady;
    },
    set: function (val) {
      this._resizeOnContentsReady = val;
      if (val) {
        this._renderer.checkPanelContentsReady(this._renderer.panels);
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "nested", {
    /**
     * If you enable this option on child Flicking when the Flicking is placed inside the Flicking, the parent Flicking will move in the same direction after the child Flicking reaches the first/last panel.
     * If the parent Flicking and child Flicking have different horizontal option, you do not need to set this option.
     * @ko Flicking 내부에 Flicking이 배치될 때 하위 Flicking에서 이 옵션을 활성화하면 하위 Flicking이 첫/마지막 패널에 도달한 뒤부터 같은 방향으로 상위 Flicking이 움직입니다.
     * 만약 상위 Flicking과 하위 Flicking이 서로 다른 horizontal 옵션을 가지고 있다면 이 옵션을 설정할 필요가 없습니다.
     * @type {boolean}
     * @default false
     * @see {@link https://naver.github.io/egjs-flicking/Options#nested nested ( Options )}
     */
    get: function () {
      return this._nested;
    },
    set: function (val) {
      this._nested = val;
      var axes = this._control.controller.axes;
      if (axes) {
        axes.options.nested = val;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "needPanelThreshold", {
    // EVENTS
    /**
     * A Threshold from viewport edge before triggering `needPanel` event
     * @ko `needPanel`이벤트가 발생하기 위한 뷰포트 끝으로부터의 최대 거리
     * @type {number}
     * @default 0
     * @see {@link https://naver.github.io/egjs-flicking/Options#needpanelthreshold needPanelThreshold ( Options )}
     */
    get: function () {
      return this._needPanelThreshold;
    },
    // EVENTS
    set: function (val) {
      this._needPanelThreshold = val;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "preventEventsBeforeInit", {
    /**
     * When enabled, events are not triggered before `ready` when initializing
     * @ko 활성화할 경우 초기화시 `ready` 이벤트 이전의 이벤트가 발생하지 않습니다.
     * @type {boolean}
     * @default true
     * @see {@link https://naver.github.io/egjs-flicking/Options#preventeventsbeforeinit preventEventsBeforeInit ( Options )}
     */
    get: function () {
      return this._preventEventsBeforeInit;
    },
    set: function (val) {
      this._preventEventsBeforeInit = val;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "deceleration", {
    // ANIMATION
    /**
     * Deceleration value for panel movement animation which is triggered by user input. A higher value means a shorter animation time
     * @ko 사용자의 동작으로 가속도가 적용된 패널 이동 애니메이션의 감속도. 값이 높을수록 애니메이션 실행 시간이 짧아집니다
     * @type {number}
     * @default 0.0075
     * @see {@link https://naver.github.io/egjs-flicking/Options#deceleration deceleration ( Options )}
     */
    get: function () {
      return this._deceleration;
    },
    // ANIMATION
    set: function (val) {
      this._deceleration = val;
      var axes = this._control.controller.axes;
      if (axes) {
        axes.options.deceleration = val;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "easing", {
    /**
     * An easing function applied to the panel movement animation. Default value is `easeOutCubic`
     * @ko 패널 이동 애니메이션에 적용할 easing 함수. 기본값은 `easeOutCubic`이다
     * @type {function}
     * @default x => 1 - Math.pow(1 - x, 3)
     * @see Easing Functions Cheat Sheet {@link http://easings.net/} <ko>이징 함수 Cheat Sheet {@link http://easings.net/}</ko>
     * @see {@link https://naver.github.io/egjs-flicking/Options#easing Easing ( Options )}
     */
    get: function () {
      return this._easing;
    },
    set: function (val) {
      this._easing = val;
      var axes = this._control.controller.axes;
      if (axes) {
        axes.options.easing = val;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "duration", {
    /**
     * Default duration of the animation (ms)
     * @ko 디폴트 애니메이션 재생 시간 (ms)
     * @type {number}
     * @default 500
     * @see {@link https://naver.github.io/egjs-flicking/Options#duration duration ( Options )}
     */
    get: function () {
      return this._duration;
    },
    set: function (val) {
      this._duration = val;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "inputType", {
    // INPUT
    /**
     * Types of input devices to enable
     * @ko 활성화할 입력 장치 종류
     * @type {string[]}
     * @default ["touch", "mouse"]
     * @see {@link https://naver.github.io/egjs-axes/Options#paninput-options Possible values (PanInputOption#inputType)}
     * <ko>{@link https://naver.github.io/egjs-axes/Options#paninput-options 가능한 값들 (PanInputOption#inputType)}</ko>
     * @see {@link https://naver.github.io/egjs-flicking/Options#inputtype inputType ( Options )}
     */
    get: function () {
      return this._inputType;
    },
    // INPUT
    set: function (val) {
      this._inputType = val;
      var panInput = this._control.controller.panInput;
      if (panInput) {
        panInput.options.inputType = val;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "moveType", {
    /**
     * Movement style by user input. This will change instance type of {@link Flicking#control}
     * You can use the values of the constant {@link MOVE_TYPE}
     * @ko 사용자 입력에 의한 이동 방식. 이 값에 따라 {@link Flicking#control}의 인스턴스 타입이 결정됩니다
     * 상수 {@link MOVE_TYPE}에 정의된 값들을 이용할 수 있습니다
     * @type {MOVE_TYPE | Pair<string, object>}
     * @default "snap"
     * @see {@link https://naver.github.io/egjs-flicking/Options#movetype moveType ( Options )}
     * @example
     * |moveType|control|options|
     * |:---:|:---:|:---:|
     * |"snap"|{@link SnapControl}||
     * |"freeScroll"|{@link FreeControl}|{@link FreeControlOptions}|
     *
     * ```ts
     * import Flicking, { MOVE_TYPE } from "@egjs/flicking";
     *
     * const flicking = new Flicking({
     *   moveType: MOVE_TYPE.SNAP
     * });
     * ```
     *
     * ```ts
     * const flicking = new Flicking({
     *   // If you want more specific settings for the moveType
     *   // [moveType, options for that moveType]
     *   // In this case, it's ["freeScroll", FreeControlOptions]
     *   moveType: [MOVE_TYPE.FREE_SCROLL, { stopAtEdge: true }]
     * });
     * ```
     */
    get: function () {
      return this._moveType;
    },
    set: function (val) {
      this._moveType = val;
      var prevControl = this._control;
      var newControl = this._createControl();
      var activePanel = prevControl.activePanel;
      newControl.copy(prevControl);
      var prevProgressInPanel = activePanel ? this._camera.getProgressInPanel(activePanel) : 0;
      this._control = newControl;
      this._control.updatePosition(prevProgressInPanel);
      this._control.updateInput();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "threshold", {
    /**
     * Movement threshold to change panel (unit: px). It should be dragged above the threshold to change the current panel.
     * @ko 패널 변경을 위한 이동 임계값 (단위: px). 주어진 값 이상으로 스크롤해야만 패널 변경이 가능하다.
     * @type {number}
     * @default 40
     * @see {@link https://naver.github.io/egjs-flicking/Options#threshold Threshold ( Options )}
     */
    get: function () {
      return this._threshold;
    },
    set: function (val) {
      this._threshold = val;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "interruptable", {
    /**
     * Set animation to be interruptable by click/touch.
     * @ko 사용자의 클릭/터치로 인해 애니메이션을 도중에 멈출 수 있도록 설정합니다.
     * @type {boolean}
     * @default true
     * @see {@link https://naver.github.io/egjs-flicking/Options#interruptable Interruptable ( Options )}
     */
    get: function () {
      return this._interruptable;
    },
    set: function (val) {
      this._interruptable = val;
      var axes = this._control.controller.axes;
      if (axes) {
        axes.options.interruptable = val;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "bounce", {
    /**
     * The size value of the bounce area. Only can be enabled when `circular=false`.
     * You can set different bounce value for prev/next direction by using array.
     * `number` for px value, and `string` for px, and % value relative to viewport size.
     * You have to call {@link Control#updateInput} after changing this to take effect.
     * @ko Flicking이 최대 영역을 넘어서 갈 수 있는 최대 크기. `circular=false`인 경우에만 사용할 수 있습니다.
     * 배열을 통해 prev/next 방향에 대해 서로 다른 바운스 값을 지정할 수 있습니다.
     * `number`를 통해 px값을, `stirng`을 통해 px 혹은 뷰포트 크기 대비 %값을 사용할 수 있습니다.
     * 이 값을 변경시 {@link Control#updateInput}를 호출해야 합니다.
     * @type {string | number | Array<string | number>}
     * @default "20%"
     * @see {@link https://naver.github.io/egjs-flicking/Options#bounce bounce ( Options )}
     * @example
     * ```ts
     * const possibleOptions = [
     *   // % values, relative to viewport element(".flicking-viewport")'s size
     *   "0%", "25%", "42%",
     *   // px values, arithmetic calculation with (+/-) is also allowed.
     *   "0px", "100px", "50% - 25px",
     *   // numbers, same to number + px ("0px", "100px")
     *   0, 100, 1000
     * ];
     * ```
     *
     * @example
     * ```ts
     * const flicking = new Flicking("#el", { bounce: "20%" });
     *
     * flicking.bounce = "100%";
     * flicking.control.updateInput(); // Call this to update!
     * ```
     */
    get: function () {
      return this._bounce;
    },
    set: function (val) {
      this._bounce = val;
      this._control.updateInput();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "iOSEdgeSwipeThreshold", {
    /**
     * Size of the area from the right edge in iOS safari (in px) which enables swipe-back or swipe-forward
     * @ko iOS Safari에서 swipe를 통한 뒤로가기/앞으로가기를 활성화하는 오른쪽 끝으로부터의 영역의 크기 (px)
     * @type {number}
     * @default 30
     * @see {@link https://naver.github.io/egjs-flicking/Options#iosedgeswipethreshold iOSEdgeSwipeThreshold ( Options )}
     */
    get: function () {
      return this._iOSEdgeSwipeThreshold;
    },
    set: function (val) {
      this._iOSEdgeSwipeThreshold = val;
      var panInput = this._control.controller.panInput;
      if (panInput) {
        panInput.options.iOSEdgeSwipeThreshold = val;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "preventClickOnDrag", {
    /**
     * Automatically prevent `click` event if the user has dragged at least a single pixel on the viewport element
     * @ko 사용자가 뷰포트 영역을 1픽셀이라도 드래그했을 경우 자동으로 {@link https://developer.mozilla.org/ko/docs/Web/API/Element/click_event click} 이벤트를 취소합니다
     * @type {boolean}
     * @default true
     * @see {@link https://naver.github.io/egjs-flicking/Options#preventclickondrag preventClickOnDrag ( Options )}
     */
    get: function () {
      return this._preventClickOnDrag;
    },
    set: function (val) {
      var prevVal = this._preventClickOnDrag;
      if (val === prevVal) return;
      var controller = this._control.controller;
      if (val) {
        controller.addPreventClickHandler();
      } else {
        controller.removePreventClickHandler();
      }
      this._preventClickOnDrag = val;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "preventDefaultOnDrag", {
    /**
     * Whether to use the {@link https://developer.mozilla.org/ko/docs/Web/API/Event/preventDefault preventDefault} when the user starts dragging
     * @ko 사용자가 드래그를 시작할 때 {@link https://developer.mozilla.org/ko/docs/Web/API/Event/preventDefault preventDefault} 실행 여부
     * @type {boolean}
     * @default false
     * @see {@link https://naver.github.io/egjs-flicking/Options#preventDefaultOnDrag preventDefaultOnDrag ( Options )}
     */
    get: function () {
      return this._preventDefaultOnDrag;
    },
    set: function (val) {
      this._preventDefaultOnDrag = val;
      var panInput = this._control.controller.panInput;
      if (panInput) {
        panInput.options.preventDefaultOnDrag = val;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "disableOnInit", {
    /**
     * Automatically call {@link Flicking#disableInput disableInput()} on initialization
     * @ko Flicking init시에 {@link Flicking#disableInput disableInput()}을 바로 호출합니다
     * @type {boolean}
     * @default false
     * @see {@link https://naver.github.io/egjs-flicking/Options#disableoninit disableOnInit ( Options )}
     */
    get: function () {
      return this._disableOnInit;
    },
    set: function (val) {
      this._disableOnInit = val;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "changeOnHold", {
    /**
     * Change active panel index on mouse/touch hold while animating.
     * `index` of the `willChange`/`willRestore` event will be used as new index.
     * @ko 애니메이션 도중 마우스/터치 입력시 현재 활성화된 패널의 인덱스를 변경합니다.
     * `willChange`/`willRestore` 이벤트의 `index`값이 새로운 인덱스로 사용될 것입니다.
     * @type {boolean}
     * @default false
     * @see {@link https://naver.github.io/egjs-flicking/Options#changeonhold changeOnHold ( Options )}
     */
    get: function () {
      return this._changeOnHold;
    },
    set: function (val) {
      this._changeOnHold = val;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "renderOnlyVisible", {
    // PERFORMANCE
    /**
     * Whether to render visible panels only. This can dramatically increase performance when there're many panels
     * @ko 보이는 패널만 렌더링할지 여부를 설정합니다. 패널이 많을 경우에 퍼포먼스를 크게 향상시킬 수 있습니다
     * @type {boolean}
     * @default false
     * @see {@link https://naver.github.io/egjs-flicking/Options#renderonlyvisible renderOnlyVisible ( Options )}
     */
    get: function () {
      return this._renderOnlyVisible;
    },
    // PERFORMANCE
    set: function (val) {
      this._renderOnlyVisible = val;
      void this._renderer.render();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "virtual", {
    /**
     * By enabling this option, it will reduce memory consumption by restricting the number of DOM elements to `panelsPerView + 1`
     * Must be used with `panelsPerview`.
     * After Flicking's initialized, this property can be used to add/remove the panel count.
     * @ko 이 옵션을 활성화할 경우 패널 엘리먼트의 개수를 `panelsPerView + 1` 개로 고정함으로써, 메모리 사용량을 줄일 수 있습니다.
     * `panelsPerView` 옵션과 함께 사용되어야만 합니다.
     * Flicking 초기화 이후에, 이 프로퍼티는 렌더링하는 패널의 개수를 추가/제거하기 위해 사용될 수 있습니다.
     * @type {VirtualManager}
     * @property {function} renderPanel A rendering function for the panel element's innerHTML<ko>패널 엘리먼트의 innerHTML을 렌더링하는 함수</ko>
     * @property {number} initialPanelCount Initial panel count to render<ko>최초로 렌더링할 패널의 개수</ko>
     * @property {boolean} [cache=false] Whether to cache rendered panel's innerHTML<ko>렌더링된 패널의 innerHTML 정보를 캐시할지 여부</ko>
     * @property {string} [panelClass="flicking-panel"] The class name that will be applied to rendered panel elements<ko>렌더링되는 패널 엘리먼트에 적용될 클래스 이름</ko>
     * @see {@link https://naver.github.io/egjs-flicking/Options#virtual virtual ( Options )}
     * @example
     * ```ts
     * import Flicking, { VirtualPanel } from "@egjs/flicking";
     *
     * const flicking = new Flicking("#some_el", {
     *   panelsPerView: 3,
     *   virtual: {
     *     renderPanel: (panel: VirtualPanel, index: number) => `Panel ${index}`,
     *     initialPanelCount: 100
     *   }
     * });
     *
     * // Add 100 virtual panels (at the end)
     * flicking.virtual.append(100);
     *
     * // Remove 100 virtual panels from 0 to 100
     * flicking.virtual.remove(0, 100);
     * ```
     */
    get: function () {
      return this._virtualManager;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "autoInit", {
    // OTHERS
    /**
     * Call {@link Flicking#init init()} automatically when creating Flicking's instance
     * @ko Flicking 인스턴스를 생성할 때 자동으로 {@link Flicking#init init()}를 호출합니다
     * @type {boolean}
     * @default true
     * @see {@link https://naver.github.io/egjs-flicking/Options#autoinit autoInit ( Options )}
     * @readonly
     */
    get: function () {
      return this._autoInit;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "autoResize", {
    /**
     * Whether to automatically call {@link Flicking#resize resize()} when the viewport element(.flicking-viewport)'s size is changed
     * @ko 뷰포트 엘리먼트(.flicking-viewport)의 크기 변경시 {@link Flicking#resize resize()} 메소드를 자동으로 호출할지 여부를 설정합니다
     * @type {boolean}
     * @default true
     */
    get: function () {
      return this._autoResize;
    },
    // OTHERS
    set: function (val) {
      this._autoResize = val;
      if (val) {
        this._autoResizer.enable();
      } else {
        this._autoResizer.disable();
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "useResizeObserver", {
    /**
     * Whether to listen {@link https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver ResizeObserver}'s event instead of Window's {@link https://developer.mozilla.org/ko/docs/Web/API/Window/resize_event resize} event when using the `autoResize` option
     * @ko autoResize 옵션 사용시 {@link https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver ResizeObserver}의 이벤트를 Window객체의 {@link https://developer.mozilla.org/ko/docs/Web/API/Window/resize_event resize} 이벤트 대신 수신할지 여부를 설정합니다
     * @type {boolean}
     * @default true
     * @see {@link https://naver.github.io/egjs-flicking/Options#useresizeobserver useResizeObserver ( Options )}
     */
    get: function () {
      return this._useResizeObserver;
    },
    set: function (val) {
      this._useResizeObserver = val;
      if (this._autoResize) {
        this._autoResizer.enable();
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "resizeDebounce", {
    /**
     * Delays size recalculation from `autoResize` by the given time in milisecond.
     * If the size is changed again while being delayed, it cancels the previous one and delays from the beginning again.
     * This can increase performance by preventing `resize` being called too often.
     * @ko `autoResize` 설정시에 호출되는 크기 재계산을 주어진 시간(단위: ms)만큼 지연시킵니다.
     * 지연시키는 도중 크기가 다시 변경되었을 경우, 이전 것을 취소하고 주어진 시간만큼 다시 지연시킵니다.
     * 이를 통해 `resize`가 너무 많이 호출되는 것을 방지하여 성능을 향상시킬 수 있습니다.
     * @type {number}
     * @default 0
     * @see {@link https://naver.github.io/egjs-flicking/Options#resizedebounce resizeDebounce ( Options )}
     */
    get: function () {
      return this._resizeDebounce;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "maxResizeDebounce", {
    /**
     * The maximum time for size recalculation delay when using `resizeDebounce`, in milisecond.
     * This guarantees that size recalculation is performed at least once every (n)ms.
     * @ko `resizeDebounce` 사용시에 크기 재계산이 지연되는 최대 시간을 지정합니다. (단위: ms)
     * 이를 통해, 적어도 (n)ms에 한번은 크기 재계산을 수행하는 것을 보장할 수 있습니다.
     * @type {number}
     * @default 100
     * @see {@link https://naver.github.io/egjs-flicking/Options#maxresizedebounce maxResizeDebounce ( Options )}
     */
    get: function () {
      return this._maxResizeDebounce;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "useFractionalSize", {
    /**
     * By enabling this, Flicking will calculate all internal size with CSS width computed with getComputedStyle.
     * This can prevent 1px offset issue in some cases where panel size has the fractional part.
     * All sizes will have the original size before CSS {@link https://developer.mozilla.org/en-US/docs/Web/CSS/transform transform} is applied on the element.
     * @ko 이 옵션을 활성화할 경우, Flicking은 내부의 모든 크기를 {@link https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect getBoundingClientRect}를 이용하여 계산합니다.
     * 이를 통해, 패널 크기에 소수점을 포함할 경우에 발생할 수 있는 일부 1px 오프셋 이슈를 해결 가능합니다.
     * 모든 크기는 CSS {@link https://developer.mozilla.org/en-US/docs/Web/CSS/transform transform}이 엘리먼트에 적용되기 이전의 크기를 사용할 것입니다.
     * @type {boolean}
     * @default false
     * @see {@link https://naver.github.io/egjs-flicking/Options#usefractionalsize useFractionalSize ( Options )}
     */
    get: function () {
      return this._useFractionalSize;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "externalRenderer", {
    /**
     * This is an option for the frameworks(React, Vue, Angular, ...). Don't set it as it's automatically managed by Flicking.
     * @ko 프레임워크(React, Vue, Angular, ...)에서만 사용하는 옵션으로, 자동으로 설정되므로 따로 사용하실 필요 없습니다!
     * @default null
     * @internal
     * @readonly
     */
    get: function () {
      return this._externalRenderer;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "renderExternal", {
    /**
     * This is an option for the frameworks(React, Vue, Angular, ...). Don't set it as it's automatically managed by Flicking.
     * @ko 프레임워크(React, Vue, Angular, ...)에서만 사용하는 옵션으로, 자동으로 설정되므로 따로 사용하실 필요 없습니다!
     * @default null
     * @internal
     * @readonly
     * @deprecated
     */
    get: function () {
      return this._renderExternal;
    },
    enumerable: false,
    configurable: true
  });
  /**
   * Initialize Flicking and move to the default index
   * This is automatically called on Flicking's constructor when `autoInit` is true(default)
   * @ko Flicking을 초기화하고, 디폴트 인덱스로 이동합니다
   * 이 메소드는 `autoInit` 옵션이 true(default)일 경우 Flicking이 생성될 때 자동으로 호출됩니다
   * @fires Flicking#ready
   * @return {Promise<void>}
   */
  __proto.init = function () {
    var _this = this;
    if (this._initialized) return Promise.resolve();
    var camera = this._camera;
    var renderer = this._renderer;
    var control = this._control;
    var virtualManager = this._virtualManager;
    var originalTrigger = this.trigger;
    var preventEventsBeforeInit = this._preventEventsBeforeInit;
    camera.init();
    virtualManager.init();
    renderer.init(this);
    control.init(this);
    if (preventEventsBeforeInit) {
      this.trigger = function () {
        return _this;
      };
    }
    this._initialResize();
    // Look at initial panel
    this._moveToInitialPanel();
    if (this._autoResize) {
      this._autoResizer.enable();
    }
    if (this._preventClickOnDrag) {
      control.controller.addPreventClickHandler();
    }
    if (this._disableOnInit) {
      this.disableInput();
    }
    renderer.checkPanelContentsReady(renderer.panels);
    this._initialized = true;
    return renderer.render().then(function () {
      // Done initializing & emit ready event
      _this._plugins.forEach(function (plugin) {
        return plugin.init(_this);
      });
      if (preventEventsBeforeInit) {
        _this.trigger = originalTrigger;
      }
      _this.trigger(new ComponentEvent$1(EVENTS.READY));
    });
  };
  /**
   * Destroy Flicking and remove all event handlers
   * @ko Flicking과 하위 컴포넌트들을 초기 상태로 되돌리고, 부착된 모든 이벤트 핸들러를 제거합니다
   * @return {void}
   */
  __proto.destroy = function () {
    this.off();
    this._autoResizer.disable();
    this._control.destroy();
    this._camera.destroy();
    this._renderer.destroy();
    this._plugins.forEach(function (plugin) {
      return plugin.destroy();
    });
    this._initialized = false;
  };
  /**
   * Move to the previous panel (current index - 1)
   * @ko 이전 패널로 이동합니다 (현재 인덱스 - 1)
   * @param {number} [duration={@link Flicking#duration options.duration}] Duration of the panel movement animation (unit: ms)<ko>패널 이동 애니메이션 진행 시간 (단위: ms)</ko>
   * @async
   * @fires Flicking#moveStart
   * @fires Flicking#move
   * @fires Flicking#moveEnd
   * @fires Flicking#willChange
   * @fires Flicking#changed
   * @fires Flicking#willRestore
   * @fires Flicking#restored
   * @fires Flicking#needPanel
   * @fires Flicking#visibleChange
   * @fires Flicking#reachEdge
   * @throws {FlickingError}
   * |code|condition|
   * |---|---|
   * |{@link ERROR_CODE INDEX_OUT_OF_RANGE}|When the previous panel does not exist|
   * |{@link ERROR_CODE ANIMATION_ALREADY_PLAYING}|When the animation is already playing|
   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|When the animation is interrupted by user input|
   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|When the any of the event's `stop()` is called|
   * <ko>
   *
   * |code|condition|
   * |---|---|
   * |{@link ERROR_CODE INDEX_OUT_OF_RANGE}|이전 패널이 존재하지 않을 경우|
   * |{@link ERROR_CODE ANIMATION_ALREADY_PLAYING}|애니메이션이 이미 진행중인 경우|
   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|사용자 입력에 의해 애니메이션이 중단된 경우|
   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|발생된 이벤트들 중 하나라도 `stop()`이 호출된 경우|
   * </ko>
   * @return {Promise<void>} A Promise which will be resolved after reaching the previous panel<ko>이전 패널 도달시에 resolve되는 Promise</ko>
   */
  __proto.prev = function (duration) {
    var _a, _b, _c;
    if (duration === void 0) {
      duration = this._duration;
    }
    return this.moveTo((_c = (_b = (_a = this._control.activePanel) === null || _a === void 0 ? void 0 : _a.prev()) === null || _b === void 0 ? void 0 : _b.index) !== null && _c !== void 0 ? _c : -1, duration, DIRECTION.PREV);
  };
  /**
   * Move to the next panel (current index + 1)
   * @ko 다음 패널로 이동합니다 (현재 인덱스 + 1)
   * @param {number} [duration={@link Flicking#duration options.duration}] Duration of the panel movement animation (unit: ms).<ko>패널 이동 애니메이션 진행 시간 (단위: ms)</ko>
   * @async
   * @fires Flicking#moveStart
   * @fires Flicking#move
   * @fires Flicking#moveEnd
   * @fires Flicking#willChange
   * @fires Flicking#changed
   * @fires Flicking#willRestore
   * @fires Flicking#restored
   * @fires Flicking#needPanel
   * @fires Flicking#visibleChange
   * @fires Flicking#reachEdge
   * @throws {FlickingError}
   * |code|condition|
   * |---|---|
   * |{@link ERROR_CODE INDEX_OUT_OF_RANGE}|When the next panel does not exist|
   * |{@link ERROR_CODE ANIMATION_ALREADY_PLAYING}|When the animation is already playing|
   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|When the animation is interrupted by user input|
   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|When the any of the event's `stop()` is called|
   * <ko>
   *
   * |code|condition|
   * |---|---|
   * |{@link ERROR_CODE INDEX_OUT_OF_RANGE}|다음 패널이 존재하지 않을 경우|
   * |{@link ERROR_CODE ANIMATION_ALREADY_PLAYING}|애니메이션이 이미 진행중인 경우|
   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|사용자 입력에 의해 애니메이션이 중단된 경우|
   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|발생된 이벤트들 중 하나라도 `stop()`이 호출된 경우|
   *
   * </ko>
   * @return {Promise<void>} A Promise which will be resolved after reaching the next panel<ko>다음 패널 도달시에 resolve되는 Promise</ko>
   */
  __proto.next = function (duration) {
    var _a, _b, _c;
    if (duration === void 0) {
      duration = this._duration;
    }
    return this.moveTo((_c = (_b = (_a = this._control.activePanel) === null || _a === void 0 ? void 0 : _a.next()) === null || _b === void 0 ? void 0 : _b.index) !== null && _c !== void 0 ? _c : this._renderer.panelCount, duration, DIRECTION.NEXT);
  };
  /**
   * Move to the panel with given index
   * @ko 주어진 인덱스에 해당하는 패널로 이동합니다
   * @param {number} index The index of the panel to move<ko>이동할 패널의 인덱스</ko>
   * @param {number} [duration={@link Flicking#duration options.duration}] Duration of the animation (unit: ms)<ko>애니메이션 진행 시간 (단위: ms)</ko>
   * @param {DIRECTION} [direction=DIRECTION.NONE] Direction to move, only available in the {@link Flicking#circular circular} mode<ko>이동할 방향. {@link Flicking#circular circular} 옵션 활성화시에만 사용 가능합니다</ko>
   * @async
   * @fires Flicking#moveStart
   * @fires Flicking#move
   * @fires Flicking#moveEnd
   * @fires Flicking#willChange
   * @fires Flicking#changed
   * @fires Flicking#willRestore
   * @fires Flicking#restored
   * @fires Flicking#needPanel
   * @fires Flicking#visibleChange
   * @fires Flicking#reachEdge
   * @throws {FlickingError}
   * |code|condition|
   * |---|---|
   * |{@link ERROR_CODE INDEX_OUT_OF_RANGE}|When the root is not either string or HTMLElement|
   * |{@link ERROR_CODE ANIMATION_ALREADY_PLAYING}|When the animation is already playing|
   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|When the animation is interrupted by user input|
   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|When the any of the event's `stop()` is called|
   * <ko>
   *
   * |code|condition|
   * |---|---|
   * |{@link ERROR_CODE INDEX_OUT_OF_RANGE}|해당 인덱스를 가진 패널이 존재하지 않을 경우|
   * |{@link ERROR_CODE ANIMATION_ALREADY_PLAYING}|애니메이션이 이미 진행중인 경우|
   * |{@link ERROR_CODE ANIMATION_INTERRUPTED}|사용자 입력에 의해 애니메이션이 중단된 경우|
   * |{@link ERROR_CODE STOP_CALLED_BY_USER}|발생된 이벤트들 중 하나라도 `stop()`이 호출된 경우|
   *
   * </ko>
   * @return {Promise<void>} A Promise which will be resolved after reaching the target panel<ko>해당 패널 도달시에 resolve되는 Promise</ko>
   */
  __proto.moveTo = function (index, duration, direction) {
    if (duration === void 0) {
      duration = this._duration;
    }
    if (direction === void 0) {
      direction = DIRECTION.NONE;
    }
    var renderer = this._renderer;
    var panelCount = renderer.panelCount;
    var panel = renderer.getPanel(index);
    if (!panel) {
      return Promise.reject(new FlickingError(MESSAGE.INDEX_OUT_OF_RANGE(index, 0, panelCount - 1), CODE.INDEX_OUT_OF_RANGE));
    }
    if (this._control.animating) {
      return Promise.reject(new FlickingError(MESSAGE.ANIMATION_ALREADY_PLAYING, CODE.ANIMATION_ALREADY_PLAYING));
    }
    if (this._control.holding) {
      this._control.controller.release();
    }
    return this._control.moveToPanel(panel, {
      duration: duration,
      direction: direction
    });
  };
  /**
   * Change the destination and duration of the animation currently playing
   * @ko 재생 중인 애니메이션의 목적지와 재생 시간을 변경합니다
   * @param {number} index The index of the panel to move<ko>이동할 패널의 인덱스</ko>
   * @param {number} duration Duration of the animation (unit: ms)<ko>애니메이션 진행 시간 (단위: ms)</ko>
   * @param {DIRECTION} direction Direction to move, only available in the {@link Flicking#circular circular} mode<ko>이동할 방향. {@link Flicking#circular circular} 옵션 활성화시에만 사용 가능합니다</ko>
   * @throws {FlickingError}
   * {@link ERROR_CODE INDEX_OUT_OF_RANGE} When the root is not either string or HTMLElement
   * <ko>{@link ERROR_CODE INDEX_OUT_OF_RANGE} 해당 인덱스를 가진 패널이 존재하지 않을 경우</ko>
   * @return {void}
   */
  __proto.updateAnimation = function (index, duration, direction) {
    if (!this._control.animating) {
      return;
    }
    var renderer = this._renderer;
    var panelCount = renderer.panelCount;
    var panel = renderer.getPanel(index);
    if (!panel) {
      throw new FlickingError(MESSAGE.INDEX_OUT_OF_RANGE(index, 0, panelCount - 1), CODE.INDEX_OUT_OF_RANGE);
    }
    this._control.updateAnimation(panel, duration, direction);
  };
  /**
   * Stops the animation currently playing
   * @ko 재생 중인 애니메이션을 중단시킵니다
   * @fires Flicking#moveEnd
   * @return {void}
   */
  __proto.stopAnimation = function () {
    if (!this._control.animating) {
      return;
    }
    this._control.stopAnimation();
  };
  /**
   * Return the {@link Panel} at the given index. `null` if it doesn't exists.
   * @ko 주어진 인덱스에 해당하는 {@link Panel}을 반환합니다. 주어진 인덱스에 해당하는 패널이 존재하지 않을 경우 `null`을 반환합니다.
   * @return {Panel | null} Panel at the given index<ko>주어진 인덱스에 해당하는 패널</ko>
   * @see Panel
   * @example
   * ```ts
   * const panel = flicking.getPanel(0);
   * // Which is a shorthand to...
   * const samePanel = flicking.panels[0];
   * ```
   */
  __proto.getPanel = function (index) {
    return this._renderer.getPanel(index);
  };
  /**
   * Enable input from the user (mouse/touch)
   * @ko 사용자의 입력(마우스/터치)를 활성화합니다
   * @return {this}
   */
  __proto.enableInput = function () {
    this._control.enable();
    return this;
  };
  /**
   * Disable input from the user (mouse/touch)
   * @ko 사용자의 입력(마우스/터치)를 막습니다
   * @return {this}
   */
  __proto.disableInput = function () {
    this._control.disable();
    return this;
  };
  /**
   * Get current flicking status. You can restore current state by giving returned value to {@link Flicking#setStatus setStatus()}
   * @ko 현재 상태를 반환합니다. 반환받은 값을 {@link Flicking#setStatus setStatus()} 메소드의 인자로 지정하면 현재 상태를 복원할 수 있습니다
   * @param {object} options Status retrieving options<ko>Status 반환 옵션</ko>
   * @param {boolean} [options.index=true] Include current panel index to the returning status. Camera will automatically move to the given index when the {@link Flicking#setStatus setStatus} is called<ko>현재 패널 인덱스를 반환값에 포함시킵니다. {@link Flicking#setStatus setStatus} 호출시 자동으로 해당 인덱스로 카메라를 움직입니다</ko>
   * @param {boolean} [options.position=true] Include camera position to the returning status. This works only when the {@link Flicking#moveType moveType} is `freeScroll`<ko>카메라의 현재 위치를 반환값에 포함시킵니다. 이 옵션은 {@link Flicking#moveType moveType}이 `freeScroll`일 경우에만 동작합니다</ko>
   * @param {boolean} [options.includePanelHTML=false] Include panel's `outerHTML` to the returning status<ko>패널의 `outerHTML`을 반환값에 포함시킵니다</ko>
   * @param {boolean} [options.visiblePanelsOnly=false] Include only {@link Flicking#visiblePanel visiblePanel}'s HTML. This option is available only when the `includePanelHTML` is true
   * <ko>현재 보이는 패널({@link Flicking#visiblePanel visiblePanel})의 HTML만 반환합니다. `includePanelHTML`이 `true`일 경우에만 동작합니다.</ko>
   * @return {Status} An object with current status value information<ko>현재 상태값 정보를 가진 객체.</ko>
   */
  __proto.getStatus = function (_a) {
    var _b, _c;
    var _d = _a === void 0 ? {} : _a,
      _e = _d.index,
      index = _e === void 0 ? true : _e,
      _f = _d.position,
      position = _f === void 0 ? true : _f,
      _g = _d.includePanelHTML,
      includePanelHTML = _g === void 0 ? false : _g,
      _h = _d.visiblePanelsOnly,
      visiblePanelsOnly = _h === void 0 ? false : _h;
    var camera = this._camera;
    var panels = visiblePanelsOnly ? this.visiblePanels : this.panels;
    var status = {
      panels: panels.map(function (panel) {
        var panelInfo = {
          index: panel.index
        };
        if (includePanelHTML) {
          panelInfo.html = panel.element.outerHTML;
        }
        return panelInfo;
      })
    };
    if (index) {
      status.index = this.index;
    }
    if (position) {
      var nearestAnchor = camera.findNearestAnchor(camera.position);
      if (nearestAnchor) {
        status.position = {
          panel: nearestAnchor.panel.index,
          progressInPanel: camera.getProgressInPanel(nearestAnchor.panel)
        };
      }
    }
    if (visiblePanelsOnly) {
      var visiblePanels = this.visiblePanels;
      status.visibleOffset = (_c = (_b = visiblePanels[0]) === null || _b === void 0 ? void 0 : _b.index) !== null && _c !== void 0 ? _c : 0;
    }
    return status;
  };
  /**
   * Restore to the state of the given {@link Status}
   * @ko 주어진 {@link Status}의 상태로 복원합니다
   * @param {Partial<Status>} status Status value to be restored. You should use the return value of the {@link Flicking#getStatus getStatus()} method<ko>복원할 상태 값. {@link Flicking#getStatus getStatus()} 메서드의 반환값을 지정하면 됩니다</ko>
   * @return {void}
   */
  __proto.setStatus = function (status) {
    var _a;
    if (!this._initialized) {
      throw new FlickingError(MESSAGE.NOT_INITIALIZED, CODE.NOT_INITIALIZED);
    }
    var index = status.index,
      position = status.position,
      visibleOffset = status.visibleOffset,
      panels = status.panels;
    var renderer = this._renderer;
    var control = this._control;
    // Can't add/remove panels on external rendering
    if (((_a = panels[0]) === null || _a === void 0 ? void 0 : _a.html) && !this._renderExternal) {
      renderer.batchRemove({
        index: 0,
        deleteCount: this.panels.length,
        hasDOMInElements: true
      });
      renderer.batchInsert({
        index: 0,
        elements: parseElement(panels.map(function (panel) {
          return panel.html;
        })),
        hasDOMInElements: true
      });
    }
    if (index != null) {
      var panelIndex = visibleOffset ? index - visibleOffset : index;
      void this.moveTo(panelIndex, 0).catch(function () {
        return void 0;
      });
    }
    if (position && this._moveType === MOVE_TYPE.FREE_SCROLL) {
      var panel = position.panel,
        progressInPanel = position.progressInPanel;
      var panelIndex = visibleOffset ? panel - visibleOffset : panel;
      var panelRange = renderer.panels[panelIndex].range;
      var newCameraPos = panelRange.min + (panelRange.max - panelRange.min) * progressInPanel;
      void control.moveToPosition(newCameraPos, 0).catch(function () {
        return void 0;
      });
    }
  };
  /**
   * Add plugins that can have different effects on Flicking
   * @ko 플리킹에 다양한 효과를 부여할 수 있는 플러그인을 추가합니다
   * @param {...Plugin} plugins The plugin(s) to add<ko>추가할 플러그인(들)</ko>
   * @return {this}
   * @see https://github.com/naver/egjs-flicking-plugins
   */
  __proto.addPlugins = function () {
    var _a;
    var _this = this;
    var plugins = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      plugins[_i] = arguments[_i];
    }
    if (this._initialized) {
      plugins.forEach(function (item) {
        return item.init(_this);
      });
    }
    (_a = this._plugins).push.apply(_a, __spread$1(plugins));
    return this;
  };
  /**
   * Remove plugins from Flicking.
   * @ko 플리킹으로부터 플러그인들을 제거합니다.
   * @param {...Plugin} plugin The plugin(s) to remove.<ko>제거 플러그인(들).</ko>
   * @return {this}
   * @see https://github.com/naver/egjs-flicking-plugins
   */
  __proto.removePlugins = function () {
    var _this = this;
    var plugins = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      plugins[_i] = arguments[_i];
    }
    plugins.forEach(function (item) {
      var foundIndex = findIndex(_this._plugins, function (val) {
        return val === item;
      });
      if (foundIndex >= 0) {
        item.destroy();
        _this._plugins.splice(foundIndex, 1);
      }
    });
    return this;
  };
  /**
   * Update viewport/panel sizes
   * @ko 패널 및 뷰포트의 크기를 갱신합니다
   * @method
   * @fires Flicking#beforeResize
   * @fires Flicking#afterResize
   * @return {this}
   */
  __proto.resize = function () {
    return __awaiter(this, void 0, void 0, function () {
      var viewport, renderer, camera, control, activePanel, prevWidth, prevHeight, prevProgressInPanel, newWidth, newHeight, sizeChanged;
      return __generator(this, function (_a) {
        switch (_a.label) {
          case 0:
            viewport = this._viewport;
            renderer = this._renderer;
            camera = this._camera;
            control = this._control;
            activePanel = control.activePanel;
            prevWidth = viewport.width;
            prevHeight = viewport.height;
            prevProgressInPanel = activePanel ? camera.getProgressInPanel(activePanel) : 0;
            this.trigger(new ComponentEvent$1(EVENTS.BEFORE_RESIZE, {
              width: prevWidth,
              height: prevHeight,
              element: viewport.element
            }));
            viewport.resize();
            return [4 /*yield*/, renderer.forceRenderAllPanels()];
          case 1:
            _a.sent(); // Render all panel elements, to update sizes
            if (!this._initialized) {
              return [2 /*return*/];
            }

            renderer.updatePanelSize();
            camera.updateAlignPos();
            camera.updateRange();
            camera.updateAnchors();
            camera.updateAdaptiveHeight();
            camera.updatePanelOrder();
            camera.updateOffset();
            return [4 /*yield*/, renderer.render()];
          case 2:
            _a.sent();
            if (!this._initialized) {
              return [2 /*return*/];
            }

            if (control.animating) ; else {
              control.updatePosition(prevProgressInPanel);
              control.updateInput();
            }
            newWidth = viewport.width;
            newHeight = viewport.height;
            sizeChanged = newWidth !== prevWidth || newHeight !== prevHeight;
            this.trigger(new ComponentEvent$1(EVENTS.AFTER_RESIZE, {
              width: viewport.width,
              height: viewport.height,
              prev: {
                width: prevWidth,
                height: prevHeight
              },
              sizeChanged: sizeChanged,
              element: viewport.element
            }));
            return [2 /*return*/];
        }
      });
    });
  };
  /**
   * Add new panels after the last panel
   * @ko 패널 목록의 제일 끝에 새로운 패널들을 추가합니다
   * @param {ElementLike | ElementLike[]} element A new HTMLElement, a outerHTML of element, or an array of both
   * <ko>새로운 HTMLElement, 혹은 엘리먼트의 outerHTML, 혹은 그것들의 배열</ko>
   * @return {Panel[]} An array of appended panels<ko>추가된 패널들의 배열</ko>
   * @see Panel
   * @see ElementLike
   * @throws {FlickingError} {@link ERROR_CODE ERROR_CODE.NOT_ALLOWED_IN_FRAMEWORK} if called on frameworks (React, Angular, Vue...)
   * @example
   * ```ts
   * const flicking = new Flicking("#flick");
   * // These are possible parameters
   * flicking.append(document.createElement("div"));
   * flicking.append("\<div\>Panel\</div\>");
   * flicking.append(["\<div\>Panel\</div\>", document.createElement("div")]);
   * // Even this is possible
   * flicking.append("\<div\>Panel 1\</div\>\<div\>Panel 2\</div\>");
   * ```
   */
  __proto.append = function (element) {
    return this.insert(this._renderer.panelCount, element);
  };
  /**
   * Add new panels before the first panel
   * This will increase index of panels after by the number of panels added
   * @ko 패널 목록의 제일 앞(index 0)에 새로운 패널들을 추가합니다
   * 추가한 패널의 개수만큼 기존 패널들의 인덱스가 증가합니다.
   * @param {ElementLike | ElementLike[]} element A new HTMLElement, a outerHTML of element, or an array of both
   * <ko>새로운 HTMLElement, 혹은 엘리먼트의 outerHTML, 혹은 그것들의 배열</ko>
   * @return {Panel[]} An array of prepended panels<ko>추가된 패널들의 배열</ko>
   * @see Panel
   * @see ElementLike
   * @throws {FlickingError} {@link ERROR_CODE ERROR_CODE.NOT_ALLOWED_IN_FRAMEWORK} if called on frameworks (React, Angular, Vue...)
   * @example
   * ```ts
   * const flicking = new eg.Flicking("#flick");
   * flicking.prepend(document.createElement("div"));
   * flicking.prepend("\<div\>Panel\</div\>");
   * flicking.prepend(["\<div\>Panel\</div\>", document.createElement("div")]);
   * // Even this is possible
   * flicking.prepend("\<div\>Panel 1\</div\>\<div\>Panel 2\</div\>");
   * ```
   */
  __proto.prepend = function (element) {
    return this.insert(0, element);
  };
  /**
   * Insert new panels at given index
   * This will increase index of panels after by the number of panels added
   * @ko 주어진 인덱스에 새로운 패널들을 추가합니다
   * 해당 인덱스보다 같거나 큰 인덱스를 가진 기존 패널들은 추가한 패널의 개수만큼 인덱스가 증가합니다.
   * @param {number} index Index to insert new panels at<ko>새로 패널들을 추가할 인덱스</ko>
   * @param {ElementLike | ElementLike[]} element A new HTMLElement, a outerHTML of element, or an array of both
   * <ko>새로운 HTMLElement, 혹은 엘리먼트의 outerHTML, 혹은 그것들의 배열</ko>
   * @return {Panel[]} An array of prepended panels<ko>추가된 패널들의 배열</ko>
   * @throws {FlickingError} {@link ERROR_CODE ERROR_CODE.NOT_ALLOWED_IN_FRAMEWORK} if called on frameworks (React, Angular, Vue...)
   * @example
   * ```ts
   * const flicking = new eg.Flicking("#flick");
   * flicking.insert(0, document.createElement("div"));
   * flicking.insert(2, "\<div\>Panel\</div\>");
   * flicking.insert(1, ["\<div\>Panel\</div\>", document.createElement("div")]);
   * // Even this is possible
   * flicking.insert(3, "\<div\>Panel 1\</div\>\<div\>Panel 2\</div\>");
   * ```
   */
  __proto.insert = function (index, element) {
    if (this._renderExternal) {
      throw new FlickingError(MESSAGE.NOT_ALLOWED_IN_FRAMEWORK, CODE.NOT_ALLOWED_IN_FRAMEWORK);
    }
    return this._renderer.batchInsert({
      index: index,
      elements: parseElement(element),
      hasDOMInElements: true
    });
  };
  /**
   * Remove the panel at the given index
   * This will decrease index of panels after by the number of panels removed
   * @ko 주어진 인덱스의 패널을 제거합니다
   * 해당 인덱스보다 큰 인덱스를 가진 기존 패널들은 제거한 패널의 개수만큼 인덱스가 감소합니다
   * @param {number} index Index of panel to remove<ko>제거할 패널의 인덱스</ko>
   * @param {number} [deleteCount=1] Number of panels to remove from index<ko>`index` 이후로 제거할 패널의 개수</ko>
   * @return {Panel[]} An array of removed panels<ko>제거된 패널들의 배열</ko>
   */
  __proto.remove = function (index, deleteCount) {
    if (deleteCount === void 0) {
      deleteCount = 1;
    }
    if (this._renderExternal) {
      throw new FlickingError(MESSAGE.NOT_ALLOWED_IN_FRAMEWORK, CODE.NOT_ALLOWED_IN_FRAMEWORK);
    }
    return this._renderer.batchRemove({
      index: index,
      deleteCount: deleteCount,
      hasDOMInElements: true
    });
  };
  __proto._createControl = function () {
    var _a;
    var moveType = this._moveType;
    var moveTypes = Object.keys(MOVE_TYPE).map(function (key) {
      return MOVE_TYPE[key];
    });
    var moveTypeStr = Array.isArray(moveType) ? moveType[0] : moveType;
    var moveTypeOptions = Array.isArray(moveType) ? (_a = moveType[1]) !== null && _a !== void 0 ? _a : {} : {};
    if (!includes(moveTypes, moveTypeStr)) {
      throw new FlickingError(MESSAGE.WRONG_OPTION("moveType", JSON.stringify(moveType)), CODE.WRONG_OPTION);
    }
    switch (moveTypeStr) {
      case MOVE_TYPE.SNAP:
        return new SnapControl(moveTypeOptions);
      case MOVE_TYPE.FREE_SCROLL:
        return new FreeControl(moveTypeOptions);
      case MOVE_TYPE.STRICT:
        return new StrictControl(moveTypeOptions);
    }
  };
  __proto._createCamera = function () {
    if (this._circular && this._bound) {
      // eslint-disable-next-line no-console
      console.warn("\"circular\" and \"bound\" option cannot be used together, ignoring bound.");
    }
    return new Camera(this, {
      align: this._align
    });
  };
  __proto._createRenderer = function () {
    var externalRenderer = this._externalRenderer;
    if (this._virtual && this._panelsPerView <= 0) {
      // eslint-disable-next-line no-console
      console.warn("\"virtual\" and \"panelsPerView\" option should be used together, ignoring virtual.");
    }
    return externalRenderer ? externalRenderer : this._renderExternal ? this._createExternalRenderer() : this._createVanillaRenderer();
  };
  __proto._createExternalRenderer = function () {
    var _a = this._renderExternal,
      renderer = _a.renderer,
      rendererOptions = _a.rendererOptions;
    return new renderer(__assign$2({
      align: this._align
    }, rendererOptions));
  };
  __proto._createVanillaRenderer = function () {
    var virtual = this.virtualEnabled;
    return new VanillaRenderer({
      align: this._align,
      strategy: virtual ? new VirtualRenderingStrategy() : new NormalRenderingStrategy({
        providerCtor: VanillaElementProvider
      })
    });
  };
  __proto._moveToInitialPanel = function () {
    var renderer = this._renderer;
    var control = this._control;
    var camera = this._camera;
    var defaultPanel = renderer.getPanel(this._defaultIndex) || renderer.getPanel(0);
    if (!defaultPanel) return;
    var nearestAnchor = camera.findNearestAnchor(defaultPanel.position);
    var initialPanel = nearestAnchor && defaultPanel.index !== nearestAnchor.panel.index ? nearestAnchor.panel : defaultPanel;
    control.setActive(initialPanel, null, false);
    if (!nearestAnchor) {
      throw new FlickingError(MESSAGE.POSITION_NOT_REACHABLE(initialPanel.position), CODE.POSITION_NOT_REACHABLE);
    }
    var position = initialPanel.position;
    if (!camera.canReach(initialPanel)) {
      position = nearestAnchor.position;
    }
    camera.lookAt(position);
    control.updateInput();
    camera.updateOffset();
  };
  __proto._initialResize = function () {
    var viewport = this._viewport;
    var renderer = this._renderer;
    var camera = this._camera;
    var control = this._control;
    this.trigger(new ComponentEvent$1(EVENTS.BEFORE_RESIZE, {
      width: 0,
      height: 0,
      element: viewport.element
    }));
    viewport.resize();
    renderer.updatePanelSize();
    camera.updateAlignPos();
    camera.updateRange();
    camera.updateAnchors();
    camera.updateOffset();
    control.updateInput();
    var newWidth = viewport.width;
    var newHeight = viewport.height;
    var sizeChanged = newWidth !== 0 || newHeight !== 0;
    this.trigger(new ComponentEvent$1(EVENTS.AFTER_RESIZE, {
      width: viewport.width,
      height: viewport.height,
      prev: {
        width: 0,
        height: 0
      },
      sizeChanged: sizeChanged,
      element: viewport.element
    }));
  };
  /**
   * Version info string
   * @ko 버전정보 문자열
   * @type {string}
   * @readonly
   * @example
   * ```ts
   * Flicking.VERSION;  // ex) 4.0.0
   * ```
   */
  Flicking.VERSION = "4.11.4";
  return Flicking;
}(Component);

/**
 * Decorator that makes the method of flicking available in the framework.
 * @ko 프레임워크에서 플리킹의 메소드를 사용할 수 있게 하는 데코레이터.
 * @memberof eg.Flicking
 * @private
 * @example
 * ```js
 * import Flicking, { withFlickingMethods } from "@egjs/flicking";
 *
 * class Flicking extends React.Component<Partial<FlickingProps & FlickingOptions>> {
 *   &#64;withFlickingMethods
 *   private flicking: Flicking;
 * }
 * ```
 */
var withFlickingMethods = function (prototype, flickingName) {
  [Component.prototype, Flicking.prototype].forEach(function (proto) {
    Object.getOwnPropertyNames(proto).filter(function (name) {
      return !prototype[name] && name.indexOf("_") !== 0 && name !== "constructor";
    }).forEach(function (name) {
      var descriptor = Object.getOwnPropertyDescriptor(proto, name);
      if (descriptor.value) {
        // Public Function
        Object.defineProperty(prototype, name, {
          value: function () {
            var _a;
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            return (_a = descriptor.value).call.apply(_a, __spread$1([this[flickingName]], args));
          }
        });
      } else {
        var getterDescriptor = {};
        if (descriptor.get) {
          getterDescriptor.get = function () {
            var _a;
            var flicking = this[flickingName];
            return flicking && ((_a = descriptor.get) === null || _a === void 0 ? void 0 : _a.call(flicking));
          };
        }
        if (descriptor.set) {
          getterDescriptor.set = function () {
            var _a;
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            return (_a = descriptor.set) === null || _a === void 0 ? void 0 : _a.call.apply(_a, __spread$1([this[flickingName]], args));
          };
        }
        Object.defineProperty(prototype, name, getterDescriptor);
      }
    });
  });
};

var sync = (function (flicking, diffResult, rendered) {
  var renderer = flicking.renderer;
  var panels = renderer.panels;
  var prevList = __spread$1(diffResult.prevList);
  var added = [];
  var removed = [];
  if (diffResult.removed.length > 0) {
    var endIdx_1 = -1;
    var prevIdx_1 = -1;
    diffResult.removed.forEach(function (removedIdx) {
      if (endIdx_1 < 0) {
        endIdx_1 = removedIdx;
      }
      if (prevIdx_1 >= 0 && removedIdx !== prevIdx_1 - 1) {
        removed.push.apply(removed, __spread$1(batchRemove(renderer, prevIdx_1, endIdx_1 + 1)));
        endIdx_1 = removedIdx;
        prevIdx_1 = removedIdx;
      } else {
        prevIdx_1 = removedIdx;
      }
      prevList.splice(removedIdx, 1);
    });
    removed.push.apply(removed, __spread$1(batchRemove(renderer, prevIdx_1, endIdx_1 + 1)));
  }
  diffResult.ordered.forEach(function (_a) {
    var _b = __read$1(_a, 2),
      from = _b[0],
      to = _b[1];
    var prevPanel = panels.splice(from, 1)[0];
    panels.splice(to, 0, prevPanel);
  });
  if (diffResult.ordered.length > 0) {
    panels.forEach(function (panel, idx) {
      var indexDiff = idx - panel.index;
      if (indexDiff > 0) {
        panel.increaseIndex(indexDiff);
      } else {
        panel.decreaseIndex(-indexDiff);
      }
    });
    panels.sort(function (panel1, panel2) {
      return panel1.index - panel2.index;
    });
    panels.forEach(function (panel) {
      panel.updatePosition();
    });
  }
  if (diffResult.added.length > 0) {
    var startIdx_1 = -1;
    var prevIdx_2 = -1;
    var addedElements_1 = rendered.slice(prevList.length);
    diffResult.added.forEach(function (addedIdx, idx) {
      if (startIdx_1 < 0) {
        startIdx_1 = idx;
      }
      if (prevIdx_2 >= 0 && addedIdx !== prevIdx_2 + 1) {
        added.push.apply(added, __spread$1(batchInsert(renderer, diffResult, addedElements_1, startIdx_1, idx + 1)));
        startIdx_1 = -1;
        prevIdx_2 = -1;
      } else {
        prevIdx_2 = addedIdx;
      }
    });
    if (startIdx_1 >= 0) {
      added.push.apply(added, __spread$1(batchInsert(renderer, diffResult, addedElements_1, startIdx_1)));
    }
  }
  if (diffResult.added.length > 0 || diffResult.removed.length > 0) {
    renderer.updateAfterPanelChange(added, removed);
  }
});
var batchInsert = function (renderer, diffResult, addedElements, startIdx, endIdx) {
  return renderer.batchInsertDefer.apply(renderer, __spread$1(diffResult.added.slice(startIdx, endIdx).map(function (index, elIdx) {
    return {
      index: index,
      elements: [addedElements[elIdx]],
      hasDOMInElements: false
    };
  })));
};
var batchRemove = function (renderer, startIdx, endIdx) {
  var removed = renderer.panels.slice(startIdx, endIdx);
  return renderer.batchRemoveDefer({
    index: startIdx,
    deleteCount: removed.length,
    hasDOMInElements: false
  });
};

var getRenderingPanels = (function (flicking, diffResult) {
  var removedPanels = diffResult.removed.reduce(function (map, idx) {
    map[idx] = true;
    return map;
  }, {});
  var maintainedMap = diffResult.maintained.reduce(function (map, _a) {
    var _b = __read$1(_a, 2),
      prev = _b[0],
      current = _b[1];
    map[prev] = current;
    return map;
  }, {});
  return __spread$1(flicking.panels.filter(function (panel) {
    return !removedPanels[panel.index];
  })
  // Sort panels by position
  .sort(function (panel1, panel2) {
    return panel1.position + panel1.offset - (panel2.position + panel2.offset);
  }).map(function (panel) {
    return diffResult.list[maintainedMap[panel.index]];
  }), diffResult.added.map(function (idx) {
    return diffResult.list[idx];
  }));
});

var getDefaultCameraTransform = (function (align, horizontal, firstPanelSize) {
  if (align === void 0) {
    align = ALIGN.CENTER;
  }
  if (horizontal === void 0) {
    horizontal = true;
  }
  var cameraAlign = getCameraAlign(align);
  var panelAlign = getPanelAlign(align);
  if (panelAlign == null) return "";
  var camPosition = "calc(" + cameraAlign + " - (" + (firstPanelSize || "0px") + " * " + panelAlign.percentage + ") - " + panelAlign.absolute + "px)";
  return horizontal ? "translate(" + camPosition + ")" : "translate(0, " + camPosition + ")";
});
var getCameraAlign = function (align) {
  var alignVal = typeof align === "object" ? align.camera : align;
  return parseAlign(alignVal);
};
var getPanelAlign = function (align) {
  var alignVal = typeof align === "object" ? align.panel : align;
  return parseArithmeticExpression(parseAlign(alignVal));
};
var parseAlign = function (alignVal) {
  if (typeof alignVal === "number") {
    return alignVal + "px";
  }
  switch (alignVal) {
    case ALIGN.CENTER:
      return "50%";
    case ALIGN.NEXT:
      return "100%";
    case ALIGN.PREV:
      return "0%";
    default:
      return alignVal;
  }
};

/*
Copyright (c) 2015-present NAVER Corp.
name: @egjs/react-flicking
license: MIT
author: NAVER Corp.
repository: https://github.com/naver/egjs-flicking/tree/master/packages/react-flicking
version: 4.11.4
*/

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics$4 = function (d, b) {
  extendStatics$4 = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
  };
  return extendStatics$4(d, b);
};
function __extends$4(d, b) {
  if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics$4(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign$3 = function () {
  __assign$3 = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign$3.apply(this, arguments);
};
function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
}
function __decorate$1(decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __awaiter$1(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator$1(thisArg, body) {
  var _ = {
      label: 0,
      sent: function () {
        if (t[0] & 1) throw t[1];
        return t[1];
      },
      trys: [],
      ops: []
    },
    f,
    y,
    t,
    g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;
  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return {
            value: op[1],
            done: false
          };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}

var DEFAULT_PROPS = {
  viewportTag: "div",
  cameraTag: "div",
  cameraClass: "",
  renderOnSameKey: false,
  plugins: [],
  useFindDOMNode: false,
  hideBeforeInit: false,
  onReady: function (e) {},
  onBeforeResize: function (e) {},
  onAfterResize: function (e) {},
  onHoldStart: function (e) {},
  onHoldEnd: function (e) {},
  onMoveStart: function (e) {},
  onMove: function (e) {},
  onMoveEnd: function (e) {},
  onWillChange: function (e) {},
  onChanged: function (e) {},
  onWillRestore: function (e) {},
  onRestored: function (e) {},
  onSelect: function (e) {},
  onNeedPanel: function (e) {},
  onVisibleChange: function (e) {},
  onReachEdge: function (e) {},
  onPanelChange: function (e) {}
};

var ReactRenderer = /*#__PURE__*/function (_super) {
  __extends$4(ReactRenderer, _super);
  function ReactRenderer(options) {
    var _this = _super.call(this, options) || this;
    _this._reactFlicking = options.reactFlicking;
    return _this;
  }
  // eslint-disable-next-line @typescript-eslint/require-await
  var __proto = ReactRenderer.prototype;
  __proto.render = function () {
    return __awaiter$1(this, void 0, void 0, function () {
      var flicking, reactFlicking, strategy;
      var _this = this;
      return __generator$1(this, function (_a) {
        flicking = getFlickingAttached(this._flicking);
        reactFlicking = this._reactFlicking;
        strategy = this._strategy;
        this._rendering = true;
        strategy.updateRenderingPanels(flicking);
        strategy.renderPanels(flicking);
        return [2 /*return*/, new Promise(function (resolve) {
          reactFlicking.renderEmitter.once("render", function () {
            _this._rendering = false;
            _this._afterRender();
            resolve();
          });
          reactFlicking.forceUpdate();
        })];
      });
    });
  };
  __proto.forceRenderAllPanels = function () {
    return __awaiter$1(this, void 0, void 0, function () {
      var reactFlicking;
      var _this = this;
      return __generator$1(this, function (_a) {
        switch (_a.label) {
          case 0:
            reactFlicking = this._reactFlicking;
            this._rendering = true;
            return [4 /*yield*/, _super.prototype.forceRenderAllPanels.call(this)];
          case 1:
            _a.sent();
            return [2 /*return*/, new Promise(function (resolve) {
              reactFlicking.renderEmitter.once("render", function () {
                _this._rendering = false;
                resolve();
              });
              reactFlicking.forceUpdate();
            })];
        }
      });
    });
  };
  __proto.destroy = function () {
    _super.prototype.destroy.call(this);
    this._reactFlicking.renderEmitter.off("render");
  };
  __proto._collectPanels = function () {
    var flicking = getFlickingAttached(this._flicking);
    var reactFlicking = this._reactFlicking;
    var reactPanels = reactFlicking.reactPanels;
    this._panels = this._strategy.collectPanels(flicking, reactPanels);
  };
  __proto._createPanel = function (externalComponent, options) {
    return this._strategy.createPanel(externalComponent, options);
  };
  return ReactRenderer;
}(ExternalRenderer);

var StrictPanel = /*#__PURE__*/function (_super) {
  __extends$4(StrictPanel, _super);
  function StrictPanel() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._hide = false;
    _this._elRef = (0,preact__WEBPACK_IMPORTED_MODULE_0__.createRef)();
    return _this;
  }
  var __proto = StrictPanel.prototype;
  Object.defineProperty(__proto, "nativeElement", {
    get: function () {
      return this._elRef.current;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "rendered", {
    get: function () {
      return !this._hide;
    },
    enumerable: false,
    configurable: true
  });
  __proto.render = function () {
    return this._hide ? (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(preact__WEBPACK_IMPORTED_MODULE_0__.Fragment, null) : this._getElement();
  };
  __proto.show = function () {
    this._hide = false;
  };
  __proto.hide = function () {
    this._hide = true;
  };
  __proto._getElement = function () {
    return rn(k$1.only(this.props.children), {
      ref: this._elRef
    });
  };
  return StrictPanel;
}(preact__WEBPACK_IMPORTED_MODULE_0__.Component);

var NonStrictPanel = /*#__PURE__*/function (_super) {
  __extends$4(NonStrictPanel, _super);
  function NonStrictPanel() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._hide = false;
    return _this;
  }
  var __proto = NonStrictPanel.prototype;
  Object.defineProperty(__proto, "nativeElement", {
    get: function () {
      return on(this);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "rendered", {
    get: function () {
      return !this._hide;
    },
    enumerable: false,
    configurable: true
  });
  __proto.render = function () {
    return this._hide ? (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(preact__WEBPACK_IMPORTED_MODULE_0__.Fragment, null) : this.props.children;
  };
  __proto.show = function () {
    this._hide = false;
  };
  __proto.hide = function () {
    this._hide = true;
  };
  return NonStrictPanel;
}(preact__WEBPACK_IMPORTED_MODULE_0__.Component);

/*
 * Copyright (c) 2015 NAVER Corp.
 * egjs projects are licensed under the MIT license
 */
var ViewportSlot = React__default.memo(function (props) {
  return React__default.createElement(React__default.Fragment, null, props.children);
});

var ReactElementProvider = /*#__PURE__*/function () {
  function ReactElementProvider(el) {
    this._el = el;
  }
  var __proto = ReactElementProvider.prototype;
  Object.defineProperty(__proto, "element", {
    get: function () {
      return this._el.nativeElement;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "rendered", {
    get: function () {
      return this._el.rendered;
    },
    enumerable: false,
    configurable: true
  });
  __proto.show = function () {
    this._el.show();
  };
  __proto.hide = function () {
    this._el.hide();
  };
  return ReactElementProvider;
}();

var Flicking$1 = /*#__PURE__*/function (_super) {
  __extends$4(Flicking$1, _super);
  function Flicking$1(props) {
    var _this = _super.call(this, props) || this;
    _this._panels = [];
    _this._renderEmitter = new Component();
    var children = _this._getChildren();
    _this._panels = _this._createPanelRefs(props, children);
    _this._prevChildren = children;
    return _this;
  }
  var __proto = Flicking$1.prototype;
  Object.defineProperty(__proto, "reactPanels", {
    get: function () {
      return this._panels.map(function (panel) {
        return panel.current;
      });
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(__proto, "renderEmitter", {
    get: function () {
      return this._renderEmitter;
    },
    enumerable: false,
    configurable: true
  });
  __proto.componentDidMount = function () {
    var props = this.props;
    var rendererOptions = {
      reactFlicking: this,
      align: props.align,
      strategy: props.virtual && props.panelsPerView > 0 ? new VirtualRenderingStrategy() : new NormalRenderingStrategy({
        providerCtor: ReactElementProvider
      })
    };
    var flicking = new Flicking(this._viewportElement, __assign$3(__assign$3({}, props), {
      externalRenderer: new ReactRenderer(rendererOptions)
    }));
    this._vanillaFlicking = flicking;
    var children = this._getChildren();
    this._jsxDiffer = new ListDiffer(children, function (panel) {
      return panel.key;
    });
    this._pluginsDiffer = new ListDiffer();
    this._prevChildren = children;
    this._bindEvents();
    this._checkPlugins();
    if (props.status) {
      flicking.setStatus(props.status);
    }
  };
  __proto.componentWillUnmount = function () {
    var _a;
    (_a = this._vanillaFlicking) === null || _a === void 0 ? void 0 : _a.destroy();
  };
  __proto.shouldComponentUpdate = function (nextProps) {
    var vanillaFlicking = this._vanillaFlicking;
    var prevProps = this.props;
    if (!vanillaFlicking || !vanillaFlicking.initialized) return false;
    var children = nextProps.children,
      restProps = __rest(nextProps, ["children"]);
    for (var key in restProps) {
      if (prevProps[key] !== nextProps[key]) {
        return true;
      }
    }
    var prevChildren = this._prevChildren;
    var nextChildren = this._getChildren(children);
    if (nextProps.renderOnSameKey || !this._hasSameChildren(prevChildren, nextChildren)) return true;
    return false;
  };
  __proto.beforeRender = function () {
    var vanillaFlicking = this._vanillaFlicking;
    var props = this.props;
    var prevChildren = this._prevChildren;
    // Ignore updates before init, they will be updated after "ready" event's force update
    // Also, prevent updates when another update is already queued.
    // This usually happens when render() called twice without calling componentDidMount, like in the case of React.StrictMode.
    if (!vanillaFlicking || !vanillaFlicking.initialized || this._diffResult) return;
    var nextChildren = this._getChildren(props.children);
    if (props.renderOnSameKey || !this._hasSameChildren(prevChildren, nextChildren)) {
      this._panels = this._createPanelRefs(props, nextChildren);
      this._diffResult = this._jsxDiffer.update(nextChildren);
      this._prevChildren = nextChildren;
    }
  };
  __proto.componentDidUpdate = function () {
    var flicking = this._vanillaFlicking;
    var renderEmitter = this._renderEmitter;
    var diffResult = this._diffResult;
    this._checkPlugins();
    renderEmitter.trigger("render");
    flicking.camera.updateOffset();
    // Omit 'virtual', as it can't have any setter
    var _a = this.props;
      _a.virtual;
      var props = __rest(_a, ["virtual"]);
    for (var key in props) {
      if (key in flicking && flicking[key] !== props[key]) {
        flicking[key] = props[key];
      }
    }
    if (!diffResult || !flicking.initialized) return;
    sync(flicking, diffResult, this.reactPanels);
    this._diffResult = null;
  };
  __proto.render = function () {
    var _this = this;
    var _a, _b;
    var props = this.props;
    var Viewport = props.viewportTag;
    var Camera = props.cameraTag;
    var attributes = {};
    var flicking = this._vanillaFlicking;
    this.beforeRender();
    for (var name in props) {
      if (!(name in DEFAULT_PROPS) && !(name in Flicking.prototype)) {
        attributes[name] = props[name];
      }
    }
    var initialized = flicking && flicking.initialized;
    var viewportClasses = ["flicking-viewport"];
    var cameraClasses = ["flicking-camera"];
    var isHorizontal = flicking ? flicking.horizontal : (_a = props.horizontal) !== null && _a !== void 0 ? _a : true;
    if (!isHorizontal) {
      viewportClasses.push("vertical");
    }
    if (props.hideBeforeInit && !initialized) {
      viewportClasses.push("flicking-hidden");
    }
    if (attributes.className) {
      viewportClasses.push(attributes.className);
    }
    if (props.cameraClass) {
      cameraClasses.push(props.cameraClass);
    }
    var cameraProps = !initialized && props.firstPanelSize ? {
      style: {
        transform: getDefaultCameraTransform(this.props.align, this.props.horizontal, this.props.firstPanelSize)
      }
    } : {};
    var panels = !!props.virtual && ((_b = props.panelsPerView) !== null && _b !== void 0 ? _b : -1) > 0 ? this._getVirtualPanels() : this._getPanels();
    return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(Viewport, __assign$3({}, attributes, {
      className: viewportClasses.join(" "),
      ref: function (e) {
        e && (_this._viewportElement = e);
      }
    }), (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(Camera, __assign$3({
      className: cameraClasses.join(" ")
    }, cameraProps), panels), this._getViewportSlot());
  };
  __proto._createPanelRefs = function (props, children) {
    var _a;
    var panelsPerView = (_a = props.panelsPerView) !== null && _a !== void 0 ? _a : -1;
    return panelsPerView > 0 && !!props.virtual ? range(panelsPerView + 1).map(function () {
      return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createRef)();
    }) : children.map(function () {
      return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createRef)();
    });
  };
  __proto._bindEvents = function () {
    var _this = this;
    var flicking = this._vanillaFlicking;
    Object.keys(EVENTS).forEach(function (eventKey) {
      var eventName = EVENTS[eventKey];
      var propName = "on".concat(eventName.charAt(0).toUpperCase() + eventName.slice(1));
      flicking.on(eventName, function (e) {
        e.currentTarget = _this;
        var evtHandler = _this.props[propName];
        evtHandler(e);
      });
    });
    flicking.once(EVENTS.READY, function () {
      _this.forceUpdate();
    });
  };
  __proto._checkPlugins = function () {
    var flicking = this._vanillaFlicking;
    var _a = this._pluginsDiffer.update(this.props.plugins),
      list = _a.list,
      added = _a.added,
      removed = _a.removed,
      prevList = _a.prevList;
    flicking.addPlugins.apply(flicking, added.map(function (index) {
      return list[index];
    }));
    flicking.removePlugins.apply(flicking, removed.map(function (index) {
      return prevList[index];
    }));
  };
  __proto._hasSameChildren = function (prevChildren, nextChildren) {
    if (prevChildren.length !== nextChildren.length || prevChildren.length === 0) return false;
    var same = prevChildren.every(function (child, idx) {
      var nextChild = nextChildren[idx];
      if (child.key && nextChild.key) {
        return child.key === nextChild.key;
      } else {
        return child === nextChild;
      }
    });
    return same;
  };
  __proto._getChildren = function (children) {
    var _this = this;
    if (children === void 0) {
      children = this.props.children;
    }
    return k$1.toArray(children).filter(function (child) {
      return child.type !== ViewportSlot;
    }).reduce(function (all, child) {
      return __spreadArray(__spreadArray([], all, true), _this._unpackFragment(child), true);
    }, []);
  };
  __proto._getViewportSlot = function () {
    return k$1.toArray(this.props.children).filter(function (child) {
      return child.type === ViewportSlot;
    });
  };
  __proto._unpackFragment = function (child) {
    var _this = this;
    return this._isFragment(child) ? k$1.toArray(child.props.children).reduce(function (allChilds, fragChild) {
      return __spreadArray(__spreadArray([], allChilds, true), _this._unpackFragment(fragChild), true);
    }, []) : [child];
  };
  __proto._getVirtualPanels = function () {
    var _this = this;
    var _a = this.props.virtual.panelClass,
      panelClass = _a === void 0 ? "flicking-panel" : _a;
    var panelsPerView = this.props.panelsPerView;
    var flicking = this._vanillaFlicking;
    var initialized = flicking && flicking.initialized;
    var renderingIndexes = initialized ? flicking.renderer.strategy.getRenderingIndexesByOrder(flicking) : range(panelsPerView + 1);
    var firstPanel = flicking && flicking.panels[0];
    var size = firstPanel ? flicking.horizontal ? {
      width: firstPanel.size
    } : {
      height: firstPanel.size
    } : {};
    return renderingIndexes.map(function (idx) {
      return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)("div", {
        key: idx,
        "data-element-index": idx,
        ref: _this._panels[idx],
        className: panelClass,
        style: size
      });
    });
  };
  __proto._getPanels = function () {
    var _this = this;
    var origChildren = this._getChildren();
    var vanillaFlicking = this._vanillaFlicking;
    var diffResult = this._diffResult;
    var children = vanillaFlicking && vanillaFlicking.initialized ? diffResult ? getRenderingPanels(vanillaFlicking, diffResult) : getRenderingPanels(vanillaFlicking, diff(origChildren, origChildren)) : origChildren;
    return this.props.useFindDOMNode ? children.map(function (child, idx) {
      return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(NonStrictPanel, {
        key: child.key,
        ref: _this._panels[idx]
      }, child);
    }) : children.map(function (child, idx) {
      return (0,preact__WEBPACK_IMPORTED_MODULE_0__.createElement)(StrictPanel, {
        key: child.key,
        ref: _this._panels[idx]
      }, child);
    });
  };
  __proto._isFragment = function (child) {
    if (child.type) {
      return child.type === preact__WEBPACK_IMPORTED_MODULE_0__.Fragment;
    }
    return child === preact__WEBPACK_IMPORTED_MODULE_0__.Fragment;
  };
  Flicking$1.defaultProps = DEFAULT_PROPS;
  __decorate$1([withFlickingMethods], Flicking$1.prototype, "_vanillaFlicking", void 0);
  return Flicking$1;
}(preact__WEBPACK_IMPORTED_MODULE_0__.Component);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Flicking$1);



/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js!./app/static/pages/globals.css":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js!./app/static/pages/globals.css ***!
  \**********************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../node_modules/css-loader/dist/runtime/getUrl.js */ "./node_modules/css-loader/dist/runtime/getUrl.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__);
// Imports



var ___CSS_LOADER_URL_IMPORT_0___ = new URL(/* asset import */ __webpack_require__(/*! ../assets/mobile/icon-hamburger.svg */ "./app/static/assets/mobile/icon-hamburger.svg"), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_1___ = new URL(/* asset import */ __webpack_require__(/*! ../assets/mobile/icon-cross.svg */ "./app/static/assets/mobile/icon-cross.svg"), __webpack_require__.b);
var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
var ___CSS_LOADER_URL_REPLACEMENT_0___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_0___);
var ___CSS_LOADER_URL_REPLACEMENT_1___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_1___);
// Module
___CSS_LOADER_EXPORT___.push([module.id, `/*
! tailwindcss v3.4.7 | MIT License | https://tailwindcss.com
*//*
1. Prevent padding and border from affecting element width. (https://github.com/mozdevs/cssremedy/issues/4)
2. Allow adding a border to an element by just adding a border-width. (https://github.com/tailwindcss/tailwindcss/pull/116)
*/

*,
::before,
::after {
  box-sizing: border-box; /* 1 */
  border-width: 0; /* 2 */
  border-style: solid; /* 2 */
  border-color: #e5e7eb; /* 2 */
}

::before,
::after {
  --tw-content: '';
}

/*
1. Use a consistent sensible line-height in all browsers.
2. Prevent adjustments of font size after orientation changes in iOS.
3. Use a more readable tab size.
4. Use the user's configured \`sans\` font-family by default.
5. Use the user's configured \`sans\` font-feature-settings by default.
6. Use the user's configured \`sans\` font-variation-settings by default.
7. Disable tap highlights on iOS
*/

html,
:host {
  line-height: 1.5; /* 1 */
  -webkit-text-size-adjust: 100%; /* 2 */
  -moz-tab-size: 4; /* 3 */
  -o-tab-size: 4;
     tab-size: 4; /* 3 */
  font-family: ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji"; /* 4 */
  font-feature-settings: normal; /* 5 */
  font-variation-settings: normal; /* 6 */
  -webkit-tap-highlight-color: transparent; /* 7 */
}

/*
1. Remove the margin in all browsers.
2. Inherit line-height from \`html\` so users can set them as a class directly on the \`html\` element.
*/

body {
  margin: 0; /* 1 */
  line-height: inherit; /* 2 */
}

/*
1. Add the correct height in Firefox.
2. Correct the inheritance of border color in Firefox. (https://bugzilla.mozilla.org/show_bug.cgi?id=190655)
3. Ensure horizontal rules are visible by default.
*/

hr {
  height: 0; /* 1 */
  color: inherit; /* 2 */
  border-top-width: 1px; /* 3 */
}

/*
Add the correct text decoration in Chrome, Edge, and Safari.
*/

abbr:where([title]) {
  -webkit-text-decoration: underline dotted;
          text-decoration: underline dotted;
}

/*
Remove the default font size and weight for headings.
*/

h1,
h2,
h3,
h4,
h5,
h6 {
  font-size: inherit;
  font-weight: inherit;
}

/*
Reset links to optimize for opt-in styling instead of opt-out.
*/

a {
  color: inherit;
  text-decoration: inherit;
}

/*
Add the correct font weight in Edge and Safari.
*/

b,
strong {
  font-weight: bolder;
}

/*
1. Use the user's configured \`mono\` font-family by default.
2. Use the user's configured \`mono\` font-feature-settings by default.
3. Use the user's configured \`mono\` font-variation-settings by default.
4. Correct the odd \`em\` font sizing in all browsers.
*/

code,
kbd,
samp,
pre {
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; /* 1 */
  font-feature-settings: normal; /* 2 */
  font-variation-settings: normal; /* 3 */
  font-size: 1em; /* 4 */
}

/*
Add the correct font size in all browsers.
*/

small {
  font-size: 80%;
}

/*
Prevent \`sub\` and \`sup\` elements from affecting the line height in all browsers.
*/

sub,
sup {
  font-size: 75%;
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}

sub {
  bottom: -0.25em;
}

sup {
  top: -0.5em;
}

/*
1. Remove text indentation from table contents in Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=999088, https://bugs.webkit.org/show_bug.cgi?id=201297)
2. Correct table border color inheritance in all Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=935729, https://bugs.webkit.org/show_bug.cgi?id=195016)
3. Remove gaps between table borders by default.
*/

table {
  text-indent: 0; /* 1 */
  border-color: inherit; /* 2 */
  border-collapse: collapse; /* 3 */
}

/*
1. Change the font styles in all browsers.
2. Remove the margin in Firefox and Safari.
3. Remove default padding in all browsers.
*/

button,
input,
optgroup,
select,
textarea {
  font-family: inherit; /* 1 */
  font-feature-settings: inherit; /* 1 */
  font-variation-settings: inherit; /* 1 */
  font-size: 100%; /* 1 */
  font-weight: inherit; /* 1 */
  line-height: inherit; /* 1 */
  letter-spacing: inherit; /* 1 */
  color: inherit; /* 1 */
  margin: 0; /* 2 */
  padding: 0; /* 3 */
}

/*
Remove the inheritance of text transform in Edge and Firefox.
*/

button,
select {
  text-transform: none;
}

/*
1. Correct the inability to style clickable types in iOS and Safari.
2. Remove default button styles.
*/

button,
input:where([type='button']),
input:where([type='reset']),
input:where([type='submit']) {
  -webkit-appearance: button; /* 1 */
  background-color: transparent; /* 2 */
  background-image: none; /* 2 */
}

/*
Use the modern Firefox focus style for all focusable elements.
*/

:-moz-focusring {
  outline: auto;
}

/*
Remove the additional \`:invalid\` styles in Firefox. (https://github.com/mozilla/gecko-dev/blob/2f9eacd9d3d995c937b4251a5557d95d494c9be1/layout/style/res/forms.css#L728-L737)
*/

:-moz-ui-invalid {
  box-shadow: none;
}

/*
Add the correct vertical alignment in Chrome and Firefox.
*/

progress {
  vertical-align: baseline;
}

/*
Correct the cursor style of increment and decrement buttons in Safari.
*/

::-webkit-inner-spin-button,
::-webkit-outer-spin-button {
  height: auto;
}

/*
1. Correct the odd appearance in Chrome and Safari.
2. Correct the outline style in Safari.
*/

[type='search'] {
  -webkit-appearance: textfield; /* 1 */
  outline-offset: -2px; /* 2 */
}

/*
Remove the inner padding in Chrome and Safari on macOS.
*/

::-webkit-search-decoration {
  -webkit-appearance: none;
}

/*
1. Correct the inability to style clickable types in iOS and Safari.
2. Change font properties to \`inherit\` in Safari.
*/

::-webkit-file-upload-button {
  -webkit-appearance: button; /* 1 */
  font: inherit; /* 2 */
}

/*
Add the correct display in Chrome and Safari.
*/

summary {
  display: list-item;
}

/*
Removes the default spacing and border for appropriate elements.
*/

blockquote,
dl,
dd,
h1,
h2,
h3,
h4,
h5,
h6,
hr,
figure,
p,
pre {
  margin: 0;
}

fieldset {
  margin: 0;
  padding: 0;
}

legend {
  padding: 0;
}

ol,
ul,
menu {
  list-style: none;
  margin: 0;
  padding: 0;
}

/*
Reset default styling for dialogs.
*/
dialog {
  padding: 0;
}

/*
Prevent resizing textareas horizontally by default.
*/

textarea {
  resize: vertical;
}

/*
1. Reset the default placeholder opacity in Firefox. (https://github.com/tailwindlabs/tailwindcss/issues/3300)
2. Set the default placeholder color to the user's configured gray 400 color.
*/

input::-moz-placeholder, textarea::-moz-placeholder {
  opacity: 1; /* 1 */
  color: #9ca3af; /* 2 */
}

input::placeholder,
textarea::placeholder {
  opacity: 1; /* 1 */
  color: #9ca3af; /* 2 */
}

/*
Set the default cursor for buttons.
*/

button,
[role="button"] {
  cursor: pointer;
}

/*
Make sure disabled buttons don't get the pointer cursor.
*/
:disabled {
  cursor: default;
}

/*
1. Make replaced elements \`display: block\` by default. (https://github.com/mozdevs/cssremedy/issues/14)
2. Add \`vertical-align: middle\` to align replaced elements more sensibly by default. (https://github.com/jensimmons/cssremedy/issues/14#issuecomment-634934210)
   This can trigger a poorly considered lint error in some tools but is included by design.
*/

img,
svg,
video,
canvas,
audio,
iframe,
embed,
object {
  display: block; /* 1 */
  vertical-align: middle; /* 2 */
}

/*
Constrain images and videos to the parent width and preserve their intrinsic aspect ratio. (https://github.com/mozdevs/cssremedy/issues/14)
*/

img,
video {
  max-width: 100%;
  height: auto;
}

/* Make elements with the HTML hidden attribute stay hidden by default */
[hidden] {
  display: none;
}

*, ::before, ::after {
  --tw-border-spacing-x: 0;
  --tw-border-spacing-y: 0;
  --tw-translate-x: 0;
  --tw-translate-y: 0;
  --tw-rotate: 0;
  --tw-skew-x: 0;
  --tw-skew-y: 0;
  --tw-scale-x: 1;
  --tw-scale-y: 1;
  --tw-pan-x:  ;
  --tw-pan-y:  ;
  --tw-pinch-zoom:  ;
  --tw-scroll-snap-strictness: proximity;
  --tw-gradient-from-position:  ;
  --tw-gradient-via-position:  ;
  --tw-gradient-to-position:  ;
  --tw-ordinal:  ;
  --tw-slashed-zero:  ;
  --tw-numeric-figure:  ;
  --tw-numeric-spacing:  ;
  --tw-numeric-fraction:  ;
  --tw-ring-inset:  ;
  --tw-ring-offset-width: 0px;
  --tw-ring-offset-color: #fff;
  --tw-ring-color: rgb(59 130 246 / 0.5);
  --tw-ring-offset-shadow: 0 0 #0000;
  --tw-ring-shadow: 0 0 #0000;
  --tw-shadow: 0 0 #0000;
  --tw-shadow-colored: 0 0 #0000;
  --tw-blur:  ;
  --tw-brightness:  ;
  --tw-contrast:  ;
  --tw-grayscale:  ;
  --tw-hue-rotate:  ;
  --tw-invert:  ;
  --tw-saturate:  ;
  --tw-sepia:  ;
  --tw-drop-shadow:  ;
  --tw-backdrop-blur:  ;
  --tw-backdrop-brightness:  ;
  --tw-backdrop-contrast:  ;
  --tw-backdrop-grayscale:  ;
  --tw-backdrop-hue-rotate:  ;
  --tw-backdrop-invert:  ;
  --tw-backdrop-opacity:  ;
  --tw-backdrop-saturate:  ;
  --tw-backdrop-sepia:  ;
  --tw-contain-size:  ;
  --tw-contain-layout:  ;
  --tw-contain-paint:  ;
  --tw-contain-style:  ;
}

::backdrop {
  --tw-border-spacing-x: 0;
  --tw-border-spacing-y: 0;
  --tw-translate-x: 0;
  --tw-translate-y: 0;
  --tw-rotate: 0;
  --tw-skew-x: 0;
  --tw-skew-y: 0;
  --tw-scale-x: 1;
  --tw-scale-y: 1;
  --tw-pan-x:  ;
  --tw-pan-y:  ;
  --tw-pinch-zoom:  ;
  --tw-scroll-snap-strictness: proximity;
  --tw-gradient-from-position:  ;
  --tw-gradient-via-position:  ;
  --tw-gradient-to-position:  ;
  --tw-ordinal:  ;
  --tw-slashed-zero:  ;
  --tw-numeric-figure:  ;
  --tw-numeric-spacing:  ;
  --tw-numeric-fraction:  ;
  --tw-ring-inset:  ;
  --tw-ring-offset-width: 0px;
  --tw-ring-offset-color: #fff;
  --tw-ring-color: rgb(59 130 246 / 0.5);
  --tw-ring-offset-shadow: 0 0 #0000;
  --tw-ring-shadow: 0 0 #0000;
  --tw-shadow: 0 0 #0000;
  --tw-shadow-colored: 0 0 #0000;
  --tw-blur:  ;
  --tw-brightness:  ;
  --tw-contrast:  ;
  --tw-grayscale:  ;
  --tw-hue-rotate:  ;
  --tw-invert:  ;
  --tw-saturate:  ;
  --tw-sepia:  ;
  --tw-drop-shadow:  ;
  --tw-backdrop-blur:  ;
  --tw-backdrop-brightness:  ;
  --tw-backdrop-contrast:  ;
  --tw-backdrop-grayscale:  ;
  --tw-backdrop-hue-rotate:  ;
  --tw-backdrop-invert:  ;
  --tw-backdrop-opacity:  ;
  --tw-backdrop-saturate:  ;
  --tw-backdrop-sepia:  ;
  --tw-contain-size:  ;
  --tw-contain-layout:  ;
  --tw-contain-paint:  ;
  --tw-contain-style:  ;
}
.pointer-events-none {
  pointer-events: none;
}
.visible {
  visibility: visible;
}
.invisible {
  visibility: hidden;
}
.collapse {
  visibility: collapse;
}
.static {
  position: static;
}
.\\!fixed {
  position: fixed !important;
}
.fixed {
  position: fixed;
}
.absolute {
  position: absolute;
}
.relative {
  position: relative;
}
.bottom-\\[68px\\] {
  bottom: 68px;
}
.left-0 {
  left: 0px;
}
.left-\\[-31px\\] {
  left: -31px;
}
.right-0 {
  right: 0px;
}
.right-\\[-31px\\] {
  right: -31px;
}
.right-\\[154px\\] {
  right: 154px;
}
.right-\\[24px\\] {
  right: 24px;
}
.right-\\[26px\\] {
  right: 26px;
}
.top-0 {
  top: 0px;
}
.top-\\[110px\\] {
  top: 110px;
}
.top-\\[126px\\] {
  top: 126px;
}
.top-\\[220px\\] {
  top: 220px;
}
.top-\\[-15px\\] {
  top: -15px;
}
.-z-0 {
  z-index: 0;
}
.z-0 {
  z-index: 0;
}
.z-40 {
  z-index: 40;
}
.z-\\[1\\] {
  z-index: 1;
}
.z-\\[2\\] {
  z-index: 2;
}
.mx-auto {
  margin-left: auto;
  margin-right: auto;
}
.mb-\\[101px\\] {
  margin-bottom: 101px;
}
.mb-auto {
  margin-bottom: auto;
}
.ml-\\[59px\\] {
  margin-left: 59px;
}
.mt-0 {
  margin-top: 0px;
}
.mt-\\[-120px\\] {
  margin-top: -120px;
}
.mt-\\[120px\\] {
  margin-top: 120px;
}
.mt-\\[44px\\] {
  margin-top: 44px;
}
.mt-\\[70px\\] {
  margin-top: 70px;
}
.mt-\\[77px\\] {
  margin-top: 77px;
}
.mt-\\[56px\\] {
  margin-top: 56px;
}
.mb-\\[96px\\] {
  margin-bottom: 96px;
}
.mb-0 {
  margin-bottom: 0px;
}
.block {
  display: block;
}
.flex {
  display: flex;
}
.table {
  display: table;
}
.grid {
  display: grid;
}
.contents {
  display: contents;
}
.hidden {
  display: none;
}
.size-\\[40px\\] {
  width: 40px;
  height: 40px;
}
.size-full {
  width: 100%;
  height: 100%;
}
.h-\\[110px\\] {
  height: 110px;
}
.h-\\[18px\\] {
  height: 18px;
}
.h-\\[200px\\] {
  height: 200px;
}
.h-\\[20px\\] {
  height: 20px;
}
.h-\\[233px\\] {
  height: 233px;
}
.h-\\[28px\\] {
  height: 28px;
}
.h-\\[292px\\] {
  height: 292px;
}
.h-\\[352px\\] {
  height: 352px;
}
.h-\\[472px\\] {
  height: 472px;
}
.h-\\[538px\\] {
  height: 538px;
}
.h-\\[648px\\] {
  height: 648px;
}
.h-\\[64px\\] {
  height: 64px;
}
.h-\\[658px\\] {
  height: 658px;
}
.h-\\[72px\\] {
  height: 72px;
}
.h-\\[797px\\] {
  height: 797px;
}
.h-fit {
  height: -moz-fit-content;
  height: fit-content;
}
.h-full {
  height: 100%;
}
.h-\\[606px\\] {
  height: 606px;
}
.h-\\[608px\\] {
  height: 608px;
}
.min-h-\\[472px\\] {
  min-height: 472px;
}
.min-h-dvh {
  min-height: 100dvh;
}
.min-h-screen {
  min-height: 100vh;
}
.w-1 {
  width: 0.25rem;
}
.w-1\\/2 {
  width: 50%;
}
.w-3 {
  width: 0.75rem;
}
.w-3\\/5 {
  width: 60%;
}
.w-\\[1400px\\] {
  width: 1400px;
}
.w-\\[177px\\] {
  width: 177px;
}
.w-\\[199px\\] {
  width: 199px;
}
.w-\\[20px\\] {
  width: 20px;
}
.w-\\[24px\\] {
  width: 24px;
}
.w-\\[355px\\] {
  width: 355px;
}
.w-\\[390px\\] {
  width: 390px;
}
.w-\\[62px\\] {
  width: 62px;
}
.w-\\[735px\\] {
  width: 735px;
}
.w-fit {
  width: -moz-fit-content;
  width: fit-content;
}
.w-full {
  width: 100%;
}
.min-w-\\[147px\\] {
  min-width: 147px;
}
.max-w-\\[1342px\\] {
  max-width: 1342px;
}
.max-w-\\[1440px\\] {
  max-width: 1440px;
}
.max-w-\\[190px\\] {
  max-width: 190px;
}
.max-w-\\[250px\\] {
  max-width: 250px;
}
.max-w-\\[252px\\] {
  max-width: 252px;
}
.max-w-\\[281px\\] {
  max-width: 281px;
}
.max-w-\\[398px\\] {
  max-width: 398px;
}
.max-w-\\[438px\\] {
  max-width: 438px;
}
.max-w-\\[730px\\] {
  max-width: 730px;
}
.max-w-\\[735px\\] {
  max-width: 735px;
}
.max-w-\\[calc\\(1275px\\+39px\\)\\] {
  max-width: calc(1275px + 39px);
}
.max-w-full {
  max-width: 100%;
}
.flex-shrink {
  flex-shrink: 1;
}
.border-collapse {
  border-collapse: collapse;
}
.translate-x-\\[150\\%\\] {
  --tw-translate-x: 150%;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.translate-y-\\[0px\\] {
  --tw-translate-y: 0px;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.scale-105 {
  --tw-scale-x: 1.05;
  --tw-scale-y: 1.05;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.transform {
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.resize {
  resize: both;
}
.flex-row {
  flex-direction: row;
}
.flex-col {
  flex-direction: column;
}
.flex-col-reverse {
  flex-direction: column-reverse;
}
.items-start {
  align-items: flex-start;
}
.items-center {
  align-items: center;
}
.justify-start {
  justify-content: flex-start;
}
.justify-end {
  justify-content: flex-end;
}
.justify-center {
  justify-content: center;
}
.justify-between {
  justify-content: space-between;
}
.gap-\\[16px\\] {
  gap: 16px;
}
.gap-\\[24px\\] {
  gap: 24px;
}
.gap-\\[28px\\] {
  gap: 28px;
}
.gap-\\[32px\\] {
  gap: 32px;
}
.gap-\\[39px\\] {
  gap: 39px;
}
.gap-\\[40px\\] {
  gap: 40px;
}
.gap-\\[48px\\] {
  gap: 48px;
}
.gap-\\[51px\\] {
  gap: 51px;
}
.gap-\\[15px\\] {
  gap: 15px;
}
.gap-\\[20px\\] {
  gap: 20px;
}
.self-auto {
  align-self: auto;
}
.self-start {
  align-self: flex-start;
}
.self-end {
  align-self: flex-end;
}
.overflow-x-clip {
  overflow-x: clip;
}
.rounded {
  border-radius: 0.25rem;
}
.border {
  border-width: 1px;
}
.bg-\\[\\#191921\\] {
  --tw-bg-opacity: 1;
  background-color: rgb(25 25 33 / var(--tw-bg-opacity));
}
.bg-\\[\\#F94F4F\\] {
  --tw-bg-opacity: 1;
  background-color: rgb(249 79 79 / var(--tw-bg-opacity));
}
.bg-black {
  --tw-bg-opacity: 1;
  background-color: rgb(0 0 0 / var(--tw-bg-opacity));
}
.stroke-\\[\\#F94F4F\\] {
  stroke: #F94F4F;
}
.stroke-\\[\\#FF9393\\] {
  stroke: #FF9393;
}
.object-contain {
  -o-object-fit: contain;
     object-fit: contain;
}
.object-cover {
  -o-object-fit: cover;
     object-fit: cover;
}
.object-fill {
  -o-object-fit: fill;
     object-fit: fill;
}
.object-scale-down {
  -o-object-fit: scale-down;
     object-fit: scale-down;
}
.object-\\[100\\%_0\\%\\] {
  -o-object-position: 100% 0%;
     object-position: 100% 0%;
}
.object-center {
  -o-object-position: center;
     object-position: center;
}
.object-right {
  -o-object-position: right;
     object-position: right;
}
.object-\\[75\\%\\] {
  -o-object-position: 75%;
     object-position: 75%;
}
.object-\\[7\\%\\] {
  -o-object-position: 7%;
     object-position: 7%;
}
.object-\\[length\\:50\\%\\] {
  -o-object-position: 50%;
     object-position: 50%;
}
.object-\\[length\\:30\\%\\] {
  -o-object-position: 30%;
     object-position: 30%;
}
.object-\\[length\\:30\\%_30\\%\\] {
  -o-object-position: 30% 30%;
     object-position: 30% 30%;
}
.object-top {
  -o-object-position: top;
     object-position: top;
}
.object-bottom {
  -o-object-position: bottom;
     object-position: bottom;
}
.px-0 {
  padding-left: 0px;
  padding-right: 0px;
}
.px-\\[24px\\] {
  padding-left: 24px;
  padding-right: 24px;
}
.px-\\[40px\\] {
  padding-left: 40px;
  padding-right: 40px;
}
.px-\\[24\\] {
  padding-left: 24;
  padding-right: 24;
}
.py-\\[72px\\] {
  padding-top: 72px;
  padding-bottom: 72px;
}
.py-0 {
  padding-top: 0px;
  padding-bottom: 0px;
}
.pl-0 {
  padding-left: 0px;
}
.pl-\\[33px\\] {
  padding-left: 33px;
}
.pl-\\[39px\\] {
  padding-left: 39px;
}
.pl-\\[40px\\] {
  padding-left: 40px;
}
.pl-\\[69px\\] {
  padding-left: 69px;
}
.pr-0 {
  padding-right: 0px;
}
.pr-\\[40px\\] {
  padding-right: 40px;
}
.pt-\\[32px\\] {
  padding-top: 32px;
}
.text-center {
  text-align: center;
}
.text-start {
  text-align: start;
}
.text-end {
  text-align: end;
}
.font-commissioner {
  font-family: "Commissioner", sans-serif;
}
.text-\\[15px\\] {
  font-size: 15px;
}
.text-\\[16px\\] {
  font-size: 16px;
}
.text-\\[18px\\] {
  font-size: 18px;
}
.text-\\[20px\\] {
  font-size: 20px;
}
.text-\\[32px\\] {
  font-size: 32px;
}
.text-\\[40px\\] {
  font-size: 40px;
}
.text-\\[80px\\] {
  font-size: 80px;
}
.font-extrabold {
  font-weight: 800;
}
.leading-\\[25px\\] {
  line-height: 25px;
}
.leading-\\[32px\\] {
  line-height: 32px;
}
.leading-\\[40px\\] {
  line-height: 40px;
}
.leading-\\[88px\\] {
  line-height: 88px;
}
.text-\\[\\#F94F4F\\] {
  --tw-text-opacity: 1;
  color: rgb(249 79 79 / var(--tw-text-opacity));
}
.text-white {
  --tw-text-opacity: 1;
  color: rgb(255 255 255 / var(--tw-text-opacity));
}
.text-white\\/25 {
  color: rgb(255 255 255 / 0.25);
}
.underline {
  text-decoration-line: underline;
}
.overline {
  text-decoration-line: overline;
}
.underline-offset-\\[12px\\] {
  text-underline-offset: 12px;
}
.opacity-0 {
  opacity: 0;
}
.outline {
  outline-style: solid;
}
.filter {
  filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow);
}
.transition {
  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, -webkit-backdrop-filter;
  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter;
  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter, -webkit-backdrop-filter;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 150ms;
}
.transition-all {
  transition-property: all;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 150ms;
}

h1 {
  font-size: 40px;
  font-weight: 800;
  line-height: 40px;
}

@media (min-width: 768px) {

  h1 {
    font-size: 56px;
    line-height: 56px;
  }
}

@media (min-width: 1280px) {

  h1 {
    font-size: 80px;
    line-height: 88px;
  }
}

h2 {
  font-size: 32px;
  font-weight: 800;
  line-height: 40px;
}

@media (min-width: 1280px) {

  h2 {
    font-size: 56px;
    line-height: 64px;
  }
}

h3 {
  font-size: 20px;
  font-weight: 800;
  line-height: 32px;
}

p {
  font-size: 15px;
  line-height: 25px;
}

@media (min-width: 1280px) {

  p {
    font-size: 18px;
    line-height: 32px;
  }
}

a {
  font-size: 15px;
}

@media (min-width: 1280px) {

  a {
    font-size: 16px;
  }
}

.previous,
.next {
  stroke: #F94F4F;
  transition-property: all;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 150ms;
}
.previous:hover,
.next:hover {
  stroke: #FF9393;
}

.panel {
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 24px;
}

.image-container:hover {
  cursor: grab;
}

.image-container:active {
  cursor: grabbing;
}

.image-container {
  position: relative;
}

.carouselImage {
  pointer-events: none;
  height: 472px;
  width: 100%;
  -o-object-fit: cover;
     object-fit: cover;
  -o-object-position: right;
     object-position: right;
}

@media (min-width: 1280px) {

  .carouselImage {
    height: 100%;
  }
}

.animationElement {
  transition-property: transform;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 150ms;
}

.animationElement.animateTransition {
  --tw-translate-y: 0px;
  --tw-scale-x: 1.05;
  --tw-scale-y: 1.05;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}

.animationElement {
  transition-duration: 500ms;
}

.image-container::after {
  height: 200px;
  width: 100%;
  content: '';
  position: absolute;
  bottom: 0;
  left: 0;
  background: linear-gradient(to bottom, rgba(0, 0, 0, 0) 0%, rgba(0, 0, 0, 0.5) 100%);
  pointer-events: none;
}

#mobileNav {
  height: 18px;
  width: 24px;
  background-image: url(${___CSS_LOADER_URL_REPLACEMENT_0___});
}

#mask {
  pointer-events: none;
}

#mobileNav.open {
  height: 20px;
  width: 20px;
  background-image: url(${___CSS_LOADER_URL_REPLACEMENT_1___});
}

body:has(#mobileNav.open) #mobileMenu {
  --tw-translate-x: 0px;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}

#mobileMenu {
  transition: all 0.5s ease 0s;
  display: flex;
  --tw-translate-x: 150%;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}

@media (min-width: 768px) {

  #mobileMenu {
    display: none;
  }
}

@media (max-width: 768px) {
  body:has(#mobileMenu.open) #mobileMenuList {
    pointer-events: auto;
  }

  body:has(#mobileNav.open) #mask {
    pointer-events: auto;
  }

  body:has(#mobileNav.open) {
    display: flex;
    min-height: 100vh;
    overflow: hidden;
  }
}

.hover\\:cursor-grab:hover {
  cursor: grab;
}

.hover\\:bg-\\[\\#434356\\]:hover {
  --tw-bg-opacity: 1;
  background-color: rgb(67 67 86 / var(--tw-bg-opacity));
}

.hover\\:bg-\\[\\#FF9393\\]:hover {
  --tw-bg-opacity: 1;
  background-color: rgb(255 147 147 / var(--tw-bg-opacity));
}

.hover\\:font-bold:hover {
  font-weight: 700;
}

.hover\\:text-\\[\\#FF9393\\]:hover {
  --tw-text-opacity: 1;
  color: rgb(255 147 147 / var(--tw-text-opacity));
}

@media (min-width: 768px) {

  .md\\:absolute {
    position: absolute;
  }

  .md\\:relative {
    position: relative;
  }

  .md\\:left-\\[-31px\\] {
    left: -31px;
  }

  .md\\:top-\\[220px\\] {
    top: 220px;
  }

  .md\\:mt-\\[77px\\] {
    margin-top: 77px;
  }

  .md\\:mt-\\[-120px\\] {
    margin-top: -120px;
  }

  .md\\:mb-0 {
    margin-bottom: 0px;
  }

  .md\\:flex {
    display: flex;
  }

  .md\\:hidden {
    display: none;
  }

  .md\\:h-\\[178px\\] {
    height: 178px;
  }

  .md\\:h-\\[606px\\] {
    height: 606px;
  }

  .md\\:h-\\[608px\\] {
    height: 608px;
  }

  .md\\:h-\\[658px\\] {
    height: 658px;
  }

  .md\\:h-\\[648px\\] {
    height: 648px;
  }

  .md\\:h-\\[538px\\] {
    height: 538px;
  }

  .md\\:min-h-screen {
    min-height: 100vh;
  }

  .md\\:w-fit {
    width: -moz-fit-content;
    width: fit-content;
  }

  .md\\:w-\\[735px\\] {
    width: 735px;
  }

  .md\\:w-full {
    width: 100%;
  }

  .md\\:w-\\[390px\\] {
    width: 390px;
  }

  .md\\:max-w-\\[398px\\] {
    max-width: 398px;
  }

  .md\\:max-w-\\[281px\\] {
    max-width: 281px;
  }

  .md\\:max-w-\\[250px\\] {
    max-width: 250px;
  }

  .md\\:flex-row {
    flex-direction: row;
  }

  .md\\:items-start {
    align-items: flex-start;
  }

  .md\\:justify-end {
    justify-content: flex-end;
  }

  .md\\:gap-\\[39px\\] {
    gap: 39px;
  }

  .md\\:gap-\\[48px\\] {
    gap: 48px;
  }

  .md\\:self-end {
    align-self: flex-end;
  }

  .md\\:object-\\[100\\%_0\\%\\] {
    -o-object-position: 100% 0%;
       object-position: 100% 0%;
  }

  .md\\:px-0 {
    padding-left: 0px;
    padding-right: 0px;
  }

  .md\\:py-0 {
    padding-top: 0px;
    padding-bottom: 0px;
  }

  .md\\:pl-\\[39px\\] {
    padding-left: 39px;
  }

  .md\\:pl-\\[69px\\] {
    padding-left: 69px;
  }

  .md\\:pr-\\[40px\\] {
    padding-right: 40px;
  }

  .md\\:text-start {
    text-align: start;
  }

  .md\\:text-\\[56px\\] {
    font-size: 56px;
  }

  .md\\:leading-\\[56px\\] {
    line-height: 56px;
  }

  .md\\:opacity-0 {
    opacity: 0;
  }
}

@media (min-width: 1024px) {

  .lg\\:mt-0 {
    margin-top: 0px;
  }

  .lg\\:mt-\\[-200px\\] {
    margin-top: -200px;
  }

  .lg\\:h-\\[560px\\] {
    height: 560px;
  }

  .lg\\:h-\\[750px\\] {
    height: 750px;
  }

  .lg\\:h-\\[658px\\] {
    height: 658px;
  }

  .lg\\:w-\\[530px\\] {
    width: 530px;
  }

  .lg\\:w-\\[735px\\] {
    width: 735px;
  }

  .lg\\:max-w-\\[530px\\] {
    max-width: 530px;
  }

  .lg\\:max-w-full {
    max-width: 100%;
  }

  .lg\\:gap-\\[50px\\] {
    gap: 50px;
  }

  .lg\\:object-cover {
    -o-object-fit: cover;
       object-fit: cover;
  }

  .lg\\:object-\\[100\\%_0\\%\\] {
    -o-object-position: 100% 0%;
       object-position: 100% 0%;
  }

  .lg\\:px-0 {
    padding-left: 0px;
    padding-right: 0px;
  }

  .lg\\:pl-\\[90px\\] {
    padding-left: 90px;
  }

  .lg\\:pr-\\[20px\\] {
    padding-right: 20px;
  }

  .lg\\:pr-\\[60px\\] {
    padding-right: 60px;
  }
}

@media (min-width: 1280px) {

  .xl\\:left-\\[-67px\\] {
    left: -67px;
  }

  .xl\\:right-\\[-67px\\] {
    right: -67px;
  }

  .xl\\:top-\\[186px\\] {
    top: 186px;
  }

  .xl\\:top-\\[234px\\] {
    top: 234px;
  }

  .xl\\:mb-\\[115px\\] {
    margin-bottom: 115px;
  }

  .xl\\:ml-\\[-67px\\] {
    margin-left: -67px;
  }

  .xl\\:ml-\\[98px\\] {
    margin-left: 98px;
  }

  .xl\\:mr-\\[-160px\\] {
    margin-right: -160px;
  }

  .xl\\:mt-\\[112px\\] {
    margin-top: 112px;
  }

  .xl\\:mt-\\[120px\\] {
    margin-top: 120px;
  }

  .xl\\:mt-\\[200px\\] {
    margin-top: 200px;
  }

  .xl\\:block {
    display: block;
  }

  .xl\\:h-\\[1100px\\] {
    height: 1100px;
  }

  .xl\\:h-\\[528px\\] {
    height: 528px;
  }

  .xl\\:h-\\[60px\\] {
    height: 60px;
  }

  .xl\\:h-\\[61px\\] {
    height: 61px;
  }

  .xl\\:h-\\[728px\\] {
    height: 728px;
  }

  .xl\\:h-\\[784px\\] {
    height: 784px;
  }

  .xl\\:h-\\[800px\\] {
    height: 800px;
  }

  .xl\\:h-\\[984px\\] {
    height: 984px;
  }

  .xl\\:h-\\[658px\\] {
    height: 658px;
  }

  .xl\\:min-h-\\[728px\\] {
    min-height: 728px;
  }

  .xl\\:w-\\[134px\\] {
    width: 134px;
  }

  .xl\\:w-\\[135px\\] {
    width: 135px;
  }

  .xl\\:w-\\[445px\\] {
    width: 445px;
  }

  .xl\\:w-\\[504px\\] {
    width: 504px;
  }

  .xl\\:w-\\[705px\\] {
    width: 705px;
  }

  .xl\\:w-\\[895px\\] {
    width: 895px;
  }

  .xl\\:w-fit {
    width: -moz-fit-content;
    width: fit-content;
  }

  .xl\\:w-\\[735px\\] {
    width: 735px;
  }

  .xl\\:min-w-\\[199px\\] {
    min-width: 199px;
  }

  .xl\\:max-w-\\[225px\\] {
    max-width: 225px;
  }

  .xl\\:max-w-\\[47vw\\] {
    max-width: 47vw;
  }

  .xl\\:max-w-\\[540px\\] {
    max-width: 540px;
  }

  .xl\\:max-w-\\[635px\\] {
    max-width: 635px;
  }

  .xl\\:max-w-\\[680\\] {
    max-width: 680;
  }

  .xl\\:max-w-full {
    max-width: 100%;
  }

  .xl\\:max-w-\\[73\\] {
    max-width: 73;
  }

  .xl\\:max-w-\\[680px\\] {
    max-width: 680px;
  }

  .xl\\:justify-end {
    justify-content: flex-end;
  }

  .xl\\:gap-\\[43px\\] {
    gap: 43px;
  }

  .xl\\:gap-\\[48px\\] {
    gap: 48px;
  }

  .xl\\:gap-\\[56px\\] {
    gap: 56px;
  }

  .xl\\:object-cover {
    -o-object-fit: cover;
       object-fit: cover;
  }

  .xl\\:object-center {
    -o-object-position: center;
       object-position: center;
  }

  .xl\\:px-0 {
    padding-left: 0px;
    padding-right: 0px;
  }

  .xl\\:pl-0 {
    padding-left: 0px;
  }

  .xl\\:pl-\\[154px\\] {
    padding-left: 154px;
  }

  .xl\\:pl-\\[39px\\] {
    padding-left: 39px;
  }

  .xl\\:pl-\\[69px\\] {
    padding-left: 69px;
  }

  .xl\\:pr-0 {
    padding-right: 0px;
  }

  .xl\\:pr-\\[106px\\] {
    padding-right: 106px;
  }

  .xl\\:text-\\[16px\\] {
    font-size: 16px;
  }

  .xl\\:text-\\[18px\\] {
    font-size: 18px;
  }

  .xl\\:text-\\[56px\\] {
    font-size: 56px;
  }

  .xl\\:text-\\[80px\\] {
    font-size: 80px;
  }

  .xl\\:leading-\\[32px\\] {
    line-height: 32px;
  }

  .xl\\:leading-\\[64px\\] {
    line-height: 64px;
  }

  .xl\\:leading-\\[88px\\] {
    line-height: 88px;
  }
}

@media (min-width: 1500px) {

  .screen1500\\:max-w-\\[705px\\] {
    max-width: 705px;
  }
}
`, "",{"version":3,"sources":["webpack://./app/static/pages/globals.css"],"names":[],"mappings":"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AAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA,iBAAmB;EAAnB;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA,WAAmB;EAAnB;AAAmB;AAAnB;EAAA,WAAmB;EAAnB;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA,wBAAmB;EAAnB;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;A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","sourcesContent":["@tailwind base;\r\n@tailwind components;\r\n@tailwind utilities;\r\n\r\nh1 {\r\n  @apply text-[40px] font-extrabold leading-[40px] md:text-[56px] md:leading-[56px] xl:text-[80px] xl:leading-[88px];\r\n}\r\n\r\nh2 {\r\n  @apply text-[32px] font-extrabold leading-[40px] xl:text-[56px] xl:leading-[64px];\r\n}\r\n\r\nh3 {\r\n  @apply text-[20px] font-extrabold leading-[32px];\r\n}\r\n\r\np {\r\n  @apply text-[15px] leading-[25px] xl:text-[18px] xl:leading-[32px];\r\n}\r\n\r\na {\r\n  @apply text-[15px] xl:text-[16px];\r\n}\r\n\r\n.previous,\r\n.next {\r\n  @apply stroke-[#F94F4F] transition-all;\r\n}\r\n.previous:hover,\r\n.next:hover {\r\n  @apply stroke-[#FF9393];\r\n}\r\n\r\n.panel {\r\n  width: 100%;\r\n  height: 100%;\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n  font-size: 24px;\r\n}\r\n\r\n.image-container {\r\n  @apply hover:cursor-grab active:cursor-grabbing;\r\n  position: relative;\r\n}\r\n\r\n.carouselImage {\r\n  @apply pointer-events-none h-[472px] w-full object-cover object-right xl:h-full;\r\n}\r\n\r\n.animationElement {\r\n  @apply transition-transform;\r\n}\r\n\r\n.animationElement.animateTransition {\r\n  @apply translate-y-[0px] scale-105 transform;\r\n}\r\n\r\n.animationElement {\r\n  @apply duration-500;\r\n}\r\n\r\n.image-container::after {\r\n  @apply h-[200px] w-full;\r\n  content: '';\r\n  position: absolute;\r\n  bottom: 0;\r\n  left: 0;\r\n  background: linear-gradient(to bottom, rgba(0, 0, 0, 0) 0%, rgba(0, 0, 0, 0.5) 100%);\r\n  pointer-events: none;\r\n}\r\n\r\n#mobileNav {\r\n  @apply h-[18px] w-[24px];\r\n  background-image: url('../assets/mobile/icon-hamburger.svg');\r\n}\r\n\r\n#mask {\r\n  @apply pointer-events-none;\r\n}\r\n\r\n#mobileNav.open {\r\n  @apply h-[20px] w-[20px];\r\n  background-image: url('../assets/mobile/icon-cross.svg');\r\n}\r\n\r\nbody:has(#mobileNav.open) #mobileMenu {\r\n  @apply translate-x-0;\r\n}\r\n\r\n#mobileMenu {\r\n  transition: all 0.5s ease 0s;\r\n  @apply flex translate-x-[150%] md:hidden;\r\n}\r\n\r\n@media (max-width: 768px) {\r\n  body:has(#mobileMenu.open) #mobileMenuList {\r\n    @apply pointer-events-auto;\r\n  }\r\n\r\n  body:has(#mobileNav.open) #mask {\r\n    @apply pointer-events-auto;\r\n  }\r\n\r\n  body:has(#mobileNav.open) {\r\n    @apply flex min-h-screen overflow-hidden;\r\n  }\r\n}\r\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js!./node_modules/@egjs/preact-flicking/dist/flicking.css":
/*!**********************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js!./node_modules/@egjs/preact-flicking/dist/flicking.css ***!
  \**********************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `.flicking-viewport {
  position: relative;
  overflow: hidden;
}

.flicking-viewport.vertical {
  display: inline-flex;
}

.flicking-viewport.vertical > .flicking-camera {
  display: inline-flex;
  flex-direction: column;
}

.flicking-viewport.flicking-hidden > .flicking-camera > * {
  visibility: hidden;
}

.flicking-camera {
  width: 100%;
  height: 100%;
  display: flex;
  position: relative;
  flex-direction: row;
  z-index: 1;
  will-change: transform;
}

.flicking-camera > * {
  flex-shrink: 0;
}
`, "",{"version":3,"sources":["webpack://./node_modules/@egjs/preact-flicking/dist/flicking.css"],"names":[],"mappings":"AAAA;EACE,kBAAkB;EAClB,gBAAgB;AAClB;;AAEA;EAGE,oBAAoB;AACtB;;AAEA;EAGE,oBAAoB;EAIZ,sBAAsB;AAChC;;AAEA;EACE,kBAAkB;AACpB;;AAEA;EACE,WAAW;EACX,YAAY;EAGZ,aAAa;EACb,kBAAkB;EAIV,mBAAmB;EAC3B,UAAU;EACV,sBAAsB;AACxB;;AAEA;EAEM,cAAc;AACpB","sourcesContent":[".flicking-viewport {\n  position: relative;\n  overflow: hidden;\n}\n\n.flicking-viewport.vertical {\n  display: -webkit-inline-box;\n  display: -ms-inline-flexbox;\n  display: inline-flex;\n}\n\n.flicking-viewport.vertical > .flicking-camera {\n  display: -webkit-inline-box;\n  display: -ms-inline-flexbox;\n  display: inline-flex;\n  -webkit-box-orient: vertical;\n  -webkit-box-direction: normal;\n      -ms-flex-direction: column;\n          flex-direction: column;\n}\n\n.flicking-viewport.flicking-hidden > .flicking-camera > * {\n  visibility: hidden;\n}\n\n.flicking-camera {\n  width: 100%;\n  height: 100%;\n  display: -webkit-box;\n  display: -ms-flexbox;\n  display: flex;\n  position: relative;\n  -webkit-box-orient: horizontal;\n  -webkit-box-direction: normal;\n      -ms-flex-direction: row;\n          flex-direction: row;\n  z-index: 1;\n  will-change: transform;\n}\n\n.flicking-camera > * {\n  -ms-flex-negative: 0;\n      flex-shrink: 0;\n}\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {



/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
module.exports = function (cssWithMappingToString) {
  var list = [];

  // return the list of modules as css string
  list.toString = function toString() {
    return this.map(function (item) {
      var content = "";
      var needLayer = typeof item[5] !== "undefined";
      if (item[4]) {
        content += "@supports (".concat(item[4], ") {");
      }
      if (item[2]) {
        content += "@media ".concat(item[2], " {");
      }
      if (needLayer) {
        content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");
      }
      content += cssWithMappingToString(item);
      if (needLayer) {
        content += "}";
      }
      if (item[2]) {
        content += "}";
      }
      if (item[4]) {
        content += "}";
      }
      return content;
    }).join("");
  };

  // import a list of modules into the list
  list.i = function i(modules, media, dedupe, supports, layer) {
    if (typeof modules === "string") {
      modules = [[null, modules, undefined]];
    }
    var alreadyImportedModules = {};
    if (dedupe) {
      for (var k = 0; k < this.length; k++) {
        var id = this[k][0];
        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }
    for (var _k = 0; _k < modules.length; _k++) {
      var item = [].concat(modules[_k]);
      if (dedupe && alreadyImportedModules[item[0]]) {
        continue;
      }
      if (typeof layer !== "undefined") {
        if (typeof item[5] === "undefined") {
          item[5] = layer;
        } else {
          item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");
          item[5] = layer;
        }
      }
      if (media) {
        if (!item[2]) {
          item[2] = media;
        } else {
          item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");
          item[2] = media;
        }
      }
      if (supports) {
        if (!item[4]) {
          item[4] = "".concat(supports);
        } else {
          item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");
          item[4] = supports;
        }
      }
      list.push(item);
    }
  };
  return list;
};

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/getUrl.js":
/*!********************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/getUrl.js ***!
  \********************************************************/
/***/ ((module) => {



module.exports = function (url, options) {
  if (!options) {
    options = {};
  }
  if (!url) {
    return url;
  }
  url = String(url.__esModule ? url.default : url);

  // If url is already wrapped in quotes, remove them
  if (/^['"].*['"]$/.test(url)) {
    url = url.slice(1, -1);
  }
  if (options.hash) {
    url += options.hash;
  }

  // Should url be wrapped?
  // See https://drafts.csswg.org/css-values-3/#urls
  if (/["'() \t\n]|(%20)/.test(url) || options.needQuotes) {
    return "\"".concat(url.replace(/"/g, '\\"').replace(/\n/g, "\\n"), "\"");
  }
  return url;
};

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/sourceMaps.js":
/*!************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/sourceMaps.js ***!
  \************************************************************/
/***/ ((module) => {



module.exports = function (item) {
  var content = item[1];
  var cssMapping = item[3];
  if (!cssMapping) {
    return content;
  }
  if (typeof btoa === "function") {
    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));
    var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
    var sourceMapping = "/*# ".concat(data, " */");
    return [content].concat([sourceMapping]).join("\n");
  }
  return [content].join("\n");
};

/***/ }),

/***/ "./node_modules/preact/dist/preact.module.js":
/*!***************************************************!*\
  !*** ./node_modules/preact/dist/preact.module.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Component: () => (/* binding */ b),
/* harmony export */   Fragment: () => (/* binding */ k),
/* harmony export */   cloneElement: () => (/* binding */ E),
/* harmony export */   createContext: () => (/* binding */ G),
/* harmony export */   createElement: () => (/* binding */ _),
/* harmony export */   createRef: () => (/* binding */ m),
/* harmony export */   h: () => (/* binding */ _),
/* harmony export */   hydrate: () => (/* binding */ D),
/* harmony export */   isValidElement: () => (/* binding */ t),
/* harmony export */   options: () => (/* binding */ l),
/* harmony export */   render: () => (/* binding */ B),
/* harmony export */   toChildArray: () => (/* binding */ H)
/* harmony export */ });
var n,l,u,t,i,o,r,f,e,c,s,a,h={},p=[],v=/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i,y=Array.isArray;function d(n,l){for(var u in l)n[u]=l[u];return n}function w(n){var l=n.parentNode;l&&l.removeChild(n)}function _(l,u,t){var i,o,r,f={};for(r in u)"key"==r?i=u[r]:"ref"==r?o=u[r]:f[r]=u[r];if(arguments.length>2&&(f.children=arguments.length>3?n.call(arguments,2):t),"function"==typeof l&&null!=l.defaultProps)for(r in l.defaultProps)void 0===f[r]&&(f[r]=l.defaultProps[r]);return g(l,f,i,o,null)}function g(n,t,i,o,r){var f={type:n,props:t,key:i,ref:o,__k:null,__:null,__b:0,__e:null,__d:void 0,__c:null,constructor:void 0,__v:null==r?++u:r,__i:-1,__u:0};return null==r&&null!=l.vnode&&l.vnode(f),f}function m(){return{current:null}}function k(n){return n.children}function b(n,l){this.props=n,this.context=l}function x(n,l){if(null==l)return n.__?x(n.__,n.__i+1):null;for(var u;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e)return u.__e;return"function"==typeof n.type?x(n):null}function C(n){var l,u;if(null!=(n=n.__)&&null!=n.__c){for(n.__e=n.__c.base=null,l=0;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e){n.__e=n.__c.base=u.__e;break}return C(n)}}function M(n){(!n.__d&&(n.__d=!0)&&i.push(n)&&!P.__r++||o!==l.debounceRendering)&&((o=l.debounceRendering)||r)(P)}function P(){var n,u,t,o,r,e,c,s;for(i.sort(f);n=i.shift();)n.__d&&(u=i.length,o=void 0,e=(r=(t=n).__v).__e,c=[],s=[],t.__P&&((o=d({},r)).__v=r.__v+1,l.vnode&&l.vnode(o),O(t.__P,o,r,t.__n,t.__P.namespaceURI,32&r.__u?[e]:null,c,null==e?x(r):e,!!(32&r.__u),s),o.__v=r.__v,o.__.__k[o.__i]=o,j(c,o,s),o.__e!=e&&C(o)),i.length>u&&i.sort(f));P.__r=0}function S(n,l,u,t,i,o,r,f,e,c,s){var a,v,y,d,w,_=t&&t.__k||p,g=l.length;for(u.__d=e,$(u,l,_),e=u.__d,a=0;a<g;a++)null!=(y=u.__k[a])&&"boolean"!=typeof y&&"function"!=typeof y&&(v=-1===y.__i?h:_[y.__i]||h,y.__i=a,O(n,y,v,i,o,r,f,e,c,s),d=y.__e,y.ref&&v.ref!=y.ref&&(v.ref&&N(v.ref,null,y),s.push(y.ref,y.__c||d,y)),null==w&&null!=d&&(w=d),65536&y.__u||v.__k===y.__k?e=I(y,e,n):"function"==typeof y.type&&void 0!==y.__d?e=y.__d:d&&(e=d.nextSibling),y.__d=void 0,y.__u&=-196609);u.__d=e,u.__e=w}function $(n,l,u){var t,i,o,r,f,e=l.length,c=u.length,s=c,a=0;for(n.__k=[],t=0;t<e;t++)r=t+a,null!=(i=n.__k[t]=null==(i=l[t])||"boolean"==typeof i||"function"==typeof i?null:"string"==typeof i||"number"==typeof i||"bigint"==typeof i||i.constructor==String?g(null,i,null,null,null):y(i)?g(k,{children:i},null,null,null):void 0===i.constructor&&i.__b>0?g(i.type,i.props,i.key,i.ref?i.ref:null,i.__v):i)?(i.__=n,i.__b=n.__b+1,f=L(i,u,r,s),i.__i=f,o=null,-1!==f&&(s--,(o=u[f])&&(o.__u|=131072)),null==o||null===o.__v?(-1==f&&a--,"function"!=typeof i.type&&(i.__u|=65536)):f!==r&&(f==r-1?a=f-r:f==r+1?a++:f>r?s>e-r?a+=f-r:a--:f<r&&a++,f!==t+a&&(i.__u|=65536))):(o=u[r])&&null==o.key&&o.__e&&0==(131072&o.__u)&&(o.__e==n.__d&&(n.__d=x(o)),V(o,o,!1),u[r]=null,s--);if(s)for(t=0;t<c;t++)null!=(o=u[t])&&0==(131072&o.__u)&&(o.__e==n.__d&&(n.__d=x(o)),V(o,o))}function I(n,l,u){var t,i;if("function"==typeof n.type){for(t=n.__k,i=0;t&&i<t.length;i++)t[i]&&(t[i].__=n,l=I(t[i],l,u));return l}n.__e!=l&&(l&&n.type&&!u.contains(l)&&(l=x(n)),u.insertBefore(n.__e,l||null),l=n.__e);do{l=l&&l.nextSibling}while(null!=l&&8===l.nodeType);return l}function H(n,l){return l=l||[],null==n||"boolean"==typeof n||(y(n)?n.some(function(n){H(n,l)}):l.push(n)),l}function L(n,l,u,t){var i=n.key,o=n.type,r=u-1,f=u+1,e=l[u];if(null===e||e&&i==e.key&&o===e.type&&0==(131072&e.__u))return u;if(t>(null!=e&&0==(131072&e.__u)?1:0))for(;r>=0||f<l.length;){if(r>=0){if((e=l[r])&&0==(131072&e.__u)&&i==e.key&&o===e.type)return r;r--}if(f<l.length){if((e=l[f])&&0==(131072&e.__u)&&i==e.key&&o===e.type)return f;f++}}return-1}function T(n,l,u){"-"===l[0]?n.setProperty(l,null==u?"":u):n[l]=null==u?"":"number"!=typeof u||v.test(l)?u:u+"px"}function A(n,l,u,t,i){var o;n:if("style"===l)if("string"==typeof u)n.style.cssText=u;else{if("string"==typeof t&&(n.style.cssText=t=""),t)for(l in t)u&&l in u||T(n.style,l,"");if(u)for(l in u)t&&u[l]===t[l]||T(n.style,l,u[l])}else if("o"===l[0]&&"n"===l[1])o=l!==(l=l.replace(/(PointerCapture)$|Capture$/i,"$1")),l=l.toLowerCase()in n||"onFocusOut"===l||"onFocusIn"===l?l.toLowerCase().slice(2):l.slice(2),n.l||(n.l={}),n.l[l+o]=u,u?t?u.u=t.u:(u.u=e,n.addEventListener(l,o?s:c,o)):n.removeEventListener(l,o?s:c,o);else{if("http://www.w3.org/2000/svg"==i)l=l.replace(/xlink(H|:h)/,"h").replace(/sName$/,"s");else if("width"!=l&&"height"!=l&&"href"!=l&&"list"!=l&&"form"!=l&&"tabIndex"!=l&&"download"!=l&&"rowSpan"!=l&&"colSpan"!=l&&"role"!=l&&"popover"!=l&&l in n)try{n[l]=null==u?"":u;break n}catch(n){}"function"==typeof u||(null==u||!1===u&&"-"!==l[4]?n.removeAttribute(l):n.setAttribute(l,"popover"==l&&1==u?"":u))}}function F(n){return function(u){if(this.l){var t=this.l[u.type+n];if(null==u.t)u.t=e++;else if(u.t<t.u)return;return t(l.event?l.event(u):u)}}}function O(n,u,t,i,o,r,f,e,c,s){var a,h,p,v,w,_,g,m,x,C,M,P,$,I,H,L,T=u.type;if(void 0!==u.constructor)return null;128&t.__u&&(c=!!(32&t.__u),r=[e=u.__e=t.__e]),(a=l.__b)&&a(u);n:if("function"==typeof T)try{if(m=u.props,x="prototype"in T&&T.prototype.render,C=(a=T.contextType)&&i[a.__c],M=a?C?C.props.value:a.__:i,t.__c?g=(h=u.__c=t.__c).__=h.__E:(x?u.__c=h=new T(m,M):(u.__c=h=new b(m,M),h.constructor=T,h.render=q),C&&C.sub(h),h.props=m,h.state||(h.state={}),h.context=M,h.__n=i,p=h.__d=!0,h.__h=[],h._sb=[]),x&&null==h.__s&&(h.__s=h.state),x&&null!=T.getDerivedStateFromProps&&(h.__s==h.state&&(h.__s=d({},h.__s)),d(h.__s,T.getDerivedStateFromProps(m,h.__s))),v=h.props,w=h.state,h.__v=u,p)x&&null==T.getDerivedStateFromProps&&null!=h.componentWillMount&&h.componentWillMount(),x&&null!=h.componentDidMount&&h.__h.push(h.componentDidMount);else{if(x&&null==T.getDerivedStateFromProps&&m!==v&&null!=h.componentWillReceiveProps&&h.componentWillReceiveProps(m,M),!h.__e&&(null!=h.shouldComponentUpdate&&!1===h.shouldComponentUpdate(m,h.__s,M)||u.__v===t.__v)){for(u.__v!==t.__v&&(h.props=m,h.state=h.__s,h.__d=!1),u.__e=t.__e,u.__k=t.__k,u.__k.forEach(function(n){n&&(n.__=u)}),P=0;P<h._sb.length;P++)h.__h.push(h._sb[P]);h._sb=[],h.__h.length&&f.push(h);break n}null!=h.componentWillUpdate&&h.componentWillUpdate(m,h.__s,M),x&&null!=h.componentDidUpdate&&h.__h.push(function(){h.componentDidUpdate(v,w,_)})}if(h.context=M,h.props=m,h.__P=n,h.__e=!1,$=l.__r,I=0,x){for(h.state=h.__s,h.__d=!1,$&&$(u),a=h.render(h.props,h.state,h.context),H=0;H<h._sb.length;H++)h.__h.push(h._sb[H]);h._sb=[]}else do{h.__d=!1,$&&$(u),a=h.render(h.props,h.state,h.context),h.state=h.__s}while(h.__d&&++I<25);h.state=h.__s,null!=h.getChildContext&&(i=d(d({},i),h.getChildContext())),x&&!p&&null!=h.getSnapshotBeforeUpdate&&(_=h.getSnapshotBeforeUpdate(v,w)),S(n,y(L=null!=a&&a.type===k&&null==a.key?a.props.children:a)?L:[L],u,t,i,o,r,f,e,c,s),h.base=u.__e,u.__u&=-161,h.__h.length&&f.push(h),g&&(h.__E=h.__=null)}catch(n){if(u.__v=null,c||null!=r){for(u.__u|=c?160:32;e&&8===e.nodeType&&e.nextSibling;)e=e.nextSibling;r[r.indexOf(e)]=null,u.__e=e}else u.__e=t.__e,u.__k=t.__k;l.__e(n,u,t)}else null==r&&u.__v===t.__v?(u.__k=t.__k,u.__e=t.__e):u.__e=z(t.__e,u,t,i,o,r,f,c,s);(a=l.diffed)&&a(u)}function j(n,u,t){u.__d=void 0;for(var i=0;i<t.length;i++)N(t[i],t[++i],t[++i]);l.__c&&l.__c(u,n),n.some(function(u){try{n=u.__h,u.__h=[],n.some(function(n){n.call(u)})}catch(n){l.__e(n,u.__v)}})}function z(l,u,t,i,o,r,f,e,c){var s,a,p,v,d,_,g,m=t.props,k=u.props,b=u.type;if("svg"===b?o="http://www.w3.org/2000/svg":"math"===b?o="http://www.w3.org/1998/Math/MathML":o||(o="http://www.w3.org/1999/xhtml"),null!=r)for(s=0;s<r.length;s++)if((d=r[s])&&"setAttribute"in d==!!b&&(b?d.localName===b:3===d.nodeType)){l=d,r[s]=null;break}if(null==l){if(null===b)return document.createTextNode(k);l=document.createElementNS(o,b,k.is&&k),r=null,e=!1}if(null===b)m===k||e&&l.data===k||(l.data=k);else{if(r=r&&n.call(l.childNodes),m=t.props||h,!e&&null!=r)for(m={},s=0;s<l.attributes.length;s++)m[(d=l.attributes[s]).name]=d.value;for(s in m)if(d=m[s],"children"==s);else if("dangerouslySetInnerHTML"==s)p=d;else if("key"!==s&&!(s in k)){if("value"==s&&"defaultValue"in k||"checked"==s&&"defaultChecked"in k)continue;A(l,s,null,d,o)}for(s in k)d=k[s],"children"==s?v=d:"dangerouslySetInnerHTML"==s?a=d:"value"==s?_=d:"checked"==s?g=d:"key"===s||e&&"function"!=typeof d||m[s]===d||A(l,s,d,m[s],o);if(a)e||p&&(a.__html===p.__html||a.__html===l.innerHTML)||(l.innerHTML=a.__html),u.__k=[];else if(p&&(l.innerHTML=""),S(l,y(v)?v:[v],u,t,i,"foreignObject"===b?"http://www.w3.org/1999/xhtml":o,r,f,r?r[0]:t.__k&&x(t,0),e,c),null!=r)for(s=r.length;s--;)null!=r[s]&&w(r[s]);e||(s="value",void 0!==_&&(_!==l[s]||"progress"===b&&!_||"option"===b&&_!==m[s])&&A(l,s,_,m[s],o),s="checked",void 0!==g&&g!==l[s]&&A(l,s,g,m[s],o))}return l}function N(n,u,t){try{if("function"==typeof n){var i="function"==typeof n.__u;i&&n.__u(),i&&null==u||(n.__u=n(u))}else n.current=u}catch(n){l.__e(n,t)}}function V(n,u,t){var i,o;if(l.unmount&&l.unmount(n),(i=n.ref)&&(i.current&&i.current!==n.__e||N(i,null,u)),null!=(i=n.__c)){if(i.componentWillUnmount)try{i.componentWillUnmount()}catch(n){l.__e(n,u)}i.base=i.__P=null}if(i=n.__k)for(o=0;o<i.length;o++)i[o]&&V(i[o],u,t||"function"!=typeof n.type);t||null==n.__e||w(n.__e),n.__c=n.__=n.__e=n.__d=void 0}function q(n,l,u){return this.constructor(n,u)}function B(u,t,i){var o,r,f,e;l.__&&l.__(u,t),r=(o="function"==typeof i)?null:i&&i.__k||t.__k,f=[],e=[],O(t,u=(!o&&i||t).__k=_(k,null,[u]),r||h,h,t.namespaceURI,!o&&i?[i]:r?null:t.firstChild?n.call(t.childNodes):null,f,!o&&i?i:r?r.__e:t.firstChild,o,e),j(f,u,e)}function D(n,l){B(n,l,D)}function E(l,u,t){var i,o,r,f,e=d({},l.props);for(r in l.type&&l.type.defaultProps&&(f=l.type.defaultProps),u)"key"==r?i=u[r]:"ref"==r?o=u[r]:e[r]=void 0===u[r]&&void 0!==f?f[r]:u[r];return arguments.length>2&&(e.children=arguments.length>3?n.call(arguments,2):t),g(l.type,e,i||l.key,o||l.ref,null)}function G(n,l){var u={__c:l="__cC"+a++,__:n,Consumer:function(n,l){return n.children(l)},Provider:function(n){var u,t;return this.getChildContext||(u=[],(t={})[l]=this,this.getChildContext=function(){return t},this.componentWillUnmount=function(){u=null},this.shouldComponentUpdate=function(n){this.props.value!==n.value&&u.some(function(n){n.__e=!0,M(n)})},this.sub=function(n){u.push(n);var l=n.componentWillUnmount;n.componentWillUnmount=function(){u&&u.splice(u.indexOf(n),1),l&&l.call(n)}}),n.children}};return u.Provider.__=u.Consumer.contextType=u}n=p.slice,l={__e:function(n,l,u,t){for(var i,o,r;l=l.__;)if((i=l.__c)&&!i.__)try{if((o=i.constructor)&&null!=o.getDerivedStateFromError&&(i.setState(o.getDerivedStateFromError(n)),r=i.__d),null!=i.componentDidCatch&&(i.componentDidCatch(n,t||{}),r=i.__d),r)return i.__E=i}catch(l){n=l}throw n}},u=0,t=function(n){return null!=n&&null==n.constructor},b.prototype.setState=function(n,l){var u;u=null!=this.__s&&this.__s!==this.state?this.__s:this.__s=d({},this.state),"function"==typeof n&&(n=n(d({},u),this.props)),n&&d(u,n),null!=n&&this.__v&&(l&&this._sb.push(l),M(this))},b.prototype.forceUpdate=function(n){this.__v&&(this.__e=!0,n&&this.__h.push(n),M(this))},b.prototype.render=k,i=[],r="function"==typeof Promise?Promise.prototype.then.bind(Promise.resolve()):setTimeout,f=function(n,l){return n.__v.__b-l.__v.__b},P.__r=0,e=0,c=F(!1),s=F(!0),a=0;
//# sourceMappingURL=preact.module.js.map


/***/ }),

/***/ "./node_modules/preact/hooks/dist/hooks.module.js":
/*!********************************************************!*\
  !*** ./node_modules/preact/hooks/dist/hooks.module.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   useCallback: () => (/* binding */ q),
/* harmony export */   useContext: () => (/* binding */ x),
/* harmony export */   useDebugValue: () => (/* binding */ P),
/* harmony export */   useEffect: () => (/* binding */ y),
/* harmony export */   useErrorBoundary: () => (/* binding */ b),
/* harmony export */   useId: () => (/* binding */ g),
/* harmony export */   useImperativeHandle: () => (/* binding */ F),
/* harmony export */   useLayoutEffect: () => (/* binding */ _),
/* harmony export */   useMemo: () => (/* binding */ T),
/* harmony export */   useReducer: () => (/* binding */ p),
/* harmony export */   useRef: () => (/* binding */ A),
/* harmony export */   useState: () => (/* binding */ h)
/* harmony export */ });
/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.module.js");
var t,r,u,i,o=0,f=[],c=preact__WEBPACK_IMPORTED_MODULE_0__.options,e=c.__b,a=c.__r,v=c.diffed,l=c.__c,m=c.unmount,s=c.__;function d(n,t){c.__h&&c.__h(r,n,o||t),o=0;var u=r.__H||(r.__H={__:[],__h:[]});return n>=u.__.length&&u.__.push({}),u.__[n]}function h(n){return o=1,p(D,n)}function p(n,u,i){var o=d(t++,2);if(o.t=n,!o.__c&&(o.__=[i?i(u):D(void 0,u),function(n){var t=o.__N?o.__N[0]:o.__[0],r=o.t(t,n);t!==r&&(o.__N=[r,o.__[1]],o.__c.setState({}))}],o.__c=r,!r.u)){var f=function(n,t,r){if(!o.__c.__H)return!0;var u=o.__c.__H.__.filter(function(n){return!!n.__c});if(u.every(function(n){return!n.__N}))return!c||c.call(this,n,t,r);var i=!1;return u.forEach(function(n){if(n.__N){var t=n.__[0];n.__=n.__N,n.__N=void 0,t!==n.__[0]&&(i=!0)}}),!(!i&&o.__c.props===n)&&(!c||c.call(this,n,t,r))};r.u=!0;var c=r.shouldComponentUpdate,e=r.componentWillUpdate;r.componentWillUpdate=function(n,t,r){if(this.__e){var u=c;c=void 0,f(n,t,r),c=u}e&&e.call(this,n,t,r)},r.shouldComponentUpdate=f}return o.__N||o.__}function y(n,u){var i=d(t++,3);!c.__s&&C(i.__H,u)&&(i.__=n,i.i=u,r.__H.__h.push(i))}function _(n,u){var i=d(t++,4);!c.__s&&C(i.__H,u)&&(i.__=n,i.i=u,r.__h.push(i))}function A(n){return o=5,T(function(){return{current:n}},[])}function F(n,t,r){o=6,_(function(){return"function"==typeof n?(n(t()),function(){return n(null)}):n?(n.current=t(),function(){return n.current=null}):void 0},null==r?r:r.concat(n))}function T(n,r){var u=d(t++,7);return C(u.__H,r)&&(u.__=n(),u.__H=r,u.__h=n),u.__}function q(n,t){return o=8,T(function(){return n},t)}function x(n){var u=r.context[n.__c],i=d(t++,9);return i.c=n,u?(null==i.__&&(i.__=!0,u.sub(r)),u.props.value):n.__}function P(n,t){c.useDebugValue&&c.useDebugValue(t?t(n):n)}function b(n){var u=d(t++,10),i=h();return u.__=n,r.componentDidCatch||(r.componentDidCatch=function(n,t){u.__&&u.__(n,t),i[1](n)}),[i[0],function(){i[1](void 0)}]}function g(){var n=d(t++,11);if(!n.__){for(var u=r.__v;null!==u&&!u.__m&&null!==u.__;)u=u.__;var i=u.__m||(u.__m=[0,0]);n.__="P"+i[0]+"-"+i[1]++}return n.__}function j(){for(var n;n=f.shift();)if(n.__P&&n.__H)try{n.__H.__h.forEach(z),n.__H.__h.forEach(B),n.__H.__h=[]}catch(t){n.__H.__h=[],c.__e(t,n.__v)}}c.__b=function(n){r=null,e&&e(n)},c.__=function(n,t){n&&t.__k&&t.__k.__m&&(n.__m=t.__k.__m),s&&s(n,t)},c.__r=function(n){a&&a(n),t=0;var i=(r=n.__c).__H;i&&(u===r?(i.__h=[],r.__h=[],i.__.forEach(function(n){n.__N&&(n.__=n.__N),n.i=n.__N=void 0})):(i.__h.forEach(z),i.__h.forEach(B),i.__h=[],t=0)),u=r},c.diffed=function(n){v&&v(n);var t=n.__c;t&&t.__H&&(t.__H.__h.length&&(1!==f.push(t)&&i===c.requestAnimationFrame||((i=c.requestAnimationFrame)||w)(j)),t.__H.__.forEach(function(n){n.i&&(n.__H=n.i),n.i=void 0})),u=r=null},c.__c=function(n,t){t.some(function(n){try{n.__h.forEach(z),n.__h=n.__h.filter(function(n){return!n.__||B(n)})}catch(r){t.some(function(n){n.__h&&(n.__h=[])}),t=[],c.__e(r,n.__v)}}),l&&l(n,t)},c.unmount=function(n){m&&m(n);var t,r=n.__c;r&&r.__H&&(r.__H.__.forEach(function(n){try{z(n)}catch(n){t=n}}),r.__H=void 0,t&&c.__e(t,r.__v))};var k="function"==typeof requestAnimationFrame;function w(n){var t,r=function(){clearTimeout(u),k&&cancelAnimationFrame(t),setTimeout(n)},u=setTimeout(r,100);k&&(t=requestAnimationFrame(r))}function z(n){var t=r,u=n.__c;"function"==typeof u&&(n.__c=void 0,u()),r=t}function B(n){var t=r;n.__c=n.__(),r=t}function C(n,t){return!n||n.length!==t.length||t.some(function(t,r){return t!==n[r]})}function D(n,t){return"function"==typeof t?t(n):t}
//# sourceMappingURL=hooks.module.js.map


/***/ }),

/***/ "./node_modules/preact/jsx-runtime/dist/jsxRuntime.module.js":
/*!*******************************************************************!*\
  !*** ./node_modules/preact/jsx-runtime/dist/jsxRuntime.module.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Fragment: () => (/* reexport safe */ preact__WEBPACK_IMPORTED_MODULE_0__.Fragment),
/* harmony export */   jsx: () => (/* binding */ u),
/* harmony export */   jsxAttr: () => (/* binding */ l),
/* harmony export */   jsxDEV: () => (/* binding */ u),
/* harmony export */   jsxEscape: () => (/* binding */ _),
/* harmony export */   jsxTemplate: () => (/* binding */ a),
/* harmony export */   jsxs: () => (/* binding */ u)
/* harmony export */ });
/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.module.js");
var t=/["&<]/;function n(r){if(0===r.length||!1===t.test(r))return r;for(var e=0,n=0,o="",f="";n<r.length;n++){switch(r.charCodeAt(n)){case 34:f="&quot;";break;case 38:f="&amp;";break;case 60:f="&lt;";break;default:continue}n!==e&&(o+=r.slice(e,n)),o+=f,e=n+1}return n!==e&&(o+=r.slice(e,n)),o}var o=/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i,f=0,i=Array.isArray;function u(e,t,n,o,i,u){t||(t={});var a,c,p=t;if("ref"in p)for(c in p={},t)"ref"==c?a=t[c]:p[c]=t[c];var l={type:e,props:p,key:n,ref:a,__k:null,__:null,__b:0,__e:null,__d:void 0,__c:null,constructor:void 0,__v:--f,__i:-1,__u:0,__source:i,__self:u};if("function"==typeof e&&(a=e.defaultProps))for(c in a)void 0===p[c]&&(p[c]=a[c]);return preact__WEBPACK_IMPORTED_MODULE_0__.options.vnode&&preact__WEBPACK_IMPORTED_MODULE_0__.options.vnode(l),l}function a(r){var t=u(preact__WEBPACK_IMPORTED_MODULE_0__.Fragment,{tpl:r,exprs:[].slice.call(arguments,1)});return t.key=t.__v,t}var c={},p=/[A-Z]/g;function l(e,t){if(preact__WEBPACK_IMPORTED_MODULE_0__.options.attr){var f=preact__WEBPACK_IMPORTED_MODULE_0__.options.attr(e,t);if("string"==typeof f)return f}if("ref"===e||"key"===e)return"";if("style"===e&&"object"==typeof t){var i="";for(var u in t){var a=t[u];if(null!=a&&""!==a){var l="-"==u[0]?u:c[u]||(c[u]=u.replace(p,"-$&").toLowerCase()),_=";";"number"!=typeof a||l.startsWith("--")||o.test(l)||(_="px;"),i=i+l+":"+a+_}}return e+'="'+i+'"'}return null==t||!1===t||"function"==typeof t||"object"==typeof t?"":!0===t?e:e+'="'+n(t)+'"'}function _(r){if(null==r||"boolean"==typeof r||"function"==typeof r)return null;if("object"==typeof r){if(void 0===r.constructor)return r;if(i(r)){for(var e=0;e<r.length;e++)r[e]=_(r[e]);return r}}return n(""+r)}
//# sourceMappingURL=jsxRuntime.module.js.map


/***/ }),

/***/ "./app/static/pages/globals.css":
/*!**************************************!*\
  !*** ./app/static/pages/globals.css ***!
  \**************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_globals_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../../node_modules/css-loader/dist/cjs.js!../../../node_modules/postcss-loader/dist/cjs.js!./globals.css */ "./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js!./app/static/pages/globals.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());

      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
    
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_globals_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);


if (true) {
  if (!_node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_globals_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals || module.hot.invalidate) {
    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {
  if (!a && b || a && !b) {
    return false;
  }
  var p;
  for (p in a) {
    if (isNamedExport && p === "default") {
      // eslint-disable-next-line no-continue
      continue;
    }
    if (a[p] !== b[p]) {
      return false;
    }
  }
  for (p in b) {
    if (isNamedExport && p === "default") {
      // eslint-disable-next-line no-continue
      continue;
    }
    if (!a[p]) {
      return false;
    }
  }
  return true;
};
    var isNamedExport = !_node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_globals_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals;
    var oldLocals = isNamedExport ? _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_globals_css__WEBPACK_IMPORTED_MODULE_6__ : _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_globals_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals;

    module.hot.accept(
      /*! !!../../../node_modules/css-loader/dist/cjs.js!../../../node_modules/postcss-loader/dist/cjs.js!./globals.css */ "./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js!./app/static/pages/globals.css",
      __WEBPACK_OUTDATED_DEPENDENCIES__ => { /* harmony import */ _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_globals_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../../node_modules/css-loader/dist/cjs.js!../../../node_modules/postcss-loader/dist/cjs.js!./globals.css */ "./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js!./app/static/pages/globals.css");
(function () {
        if (!isEqualLocals(oldLocals, isNamedExport ? _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_globals_css__WEBPACK_IMPORTED_MODULE_6__ : _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_globals_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals, isNamedExport)) {
                module.hot.invalidate();

                return;
              }

              oldLocals = isNamedExport ? _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_globals_css__WEBPACK_IMPORTED_MODULE_6__ : _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_globals_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals;

              update(_node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_globals_css__WEBPACK_IMPORTED_MODULE_6__["default"]);
      })(__WEBPACK_OUTDATED_DEPENDENCIES__); }
    )
  }

  module.hot.dispose(function() {
    update();
  });
}



       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_globals_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_globals_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_globals_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./node_modules/@egjs/preact-flicking/dist/flicking.css":
/*!**************************************************************!*\
  !*** ./node_modules/@egjs/preact-flicking/dist/flicking.css ***!
  \**************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../../style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../../style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../../style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../../style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../../style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _css_loader_dist_cjs_js_postcss_loader_dist_cjs_js_flicking_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../../css-loader/dist/cjs.js!../../../postcss-loader/dist/cjs.js!./flicking.css */ "./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js!./node_modules/@egjs/preact-flicking/dist/flicking.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());

      options.insert = _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
    
options.domAPI = (_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_css_loader_dist_cjs_js_postcss_loader_dist_cjs_js_flicking_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);


if (true) {
  if (!_css_loader_dist_cjs_js_postcss_loader_dist_cjs_js_flicking_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals || module.hot.invalidate) {
    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {
  if (!a && b || a && !b) {
    return false;
  }
  var p;
  for (p in a) {
    if (isNamedExport && p === "default") {
      // eslint-disable-next-line no-continue
      continue;
    }
    if (a[p] !== b[p]) {
      return false;
    }
  }
  for (p in b) {
    if (isNamedExport && p === "default") {
      // eslint-disable-next-line no-continue
      continue;
    }
    if (!a[p]) {
      return false;
    }
  }
  return true;
};
    var isNamedExport = !_css_loader_dist_cjs_js_postcss_loader_dist_cjs_js_flicking_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals;
    var oldLocals = isNamedExport ? _css_loader_dist_cjs_js_postcss_loader_dist_cjs_js_flicking_css__WEBPACK_IMPORTED_MODULE_6__ : _css_loader_dist_cjs_js_postcss_loader_dist_cjs_js_flicking_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals;

    module.hot.accept(
      /*! !!../../../css-loader/dist/cjs.js!../../../postcss-loader/dist/cjs.js!./flicking.css */ "./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js!./node_modules/@egjs/preact-flicking/dist/flicking.css",
      __WEBPACK_OUTDATED_DEPENDENCIES__ => { /* harmony import */ _css_loader_dist_cjs_js_postcss_loader_dist_cjs_js_flicking_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../../css-loader/dist/cjs.js!../../../postcss-loader/dist/cjs.js!./flicking.css */ "./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js!./node_modules/@egjs/preact-flicking/dist/flicking.css");
(function () {
        if (!isEqualLocals(oldLocals, isNamedExport ? _css_loader_dist_cjs_js_postcss_loader_dist_cjs_js_flicking_css__WEBPACK_IMPORTED_MODULE_6__ : _css_loader_dist_cjs_js_postcss_loader_dist_cjs_js_flicking_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals, isNamedExport)) {
                module.hot.invalidate();

                return;
              }

              oldLocals = isNamedExport ? _css_loader_dist_cjs_js_postcss_loader_dist_cjs_js_flicking_css__WEBPACK_IMPORTED_MODULE_6__ : _css_loader_dist_cjs_js_postcss_loader_dist_cjs_js_flicking_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals;

              update(_css_loader_dist_cjs_js_postcss_loader_dist_cjs_js_flicking_css__WEBPACK_IMPORTED_MODULE_6__["default"]);
      })(__WEBPACK_OUTDATED_DEPENDENCIES__); }
    )
  }

  module.hot.dispose(function() {
    update();
  });
}



       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_css_loader_dist_cjs_js_postcss_loader_dist_cjs_js_flicking_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _css_loader_dist_cjs_js_postcss_loader_dist_cjs_js_flicking_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _css_loader_dist_cjs_js_postcss_loader_dist_cjs_js_flicking_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {



var stylesInDOM = [];
function getIndexByIdentifier(identifier) {
  var result = -1;
  for (var i = 0; i < stylesInDOM.length; i++) {
    if (stylesInDOM[i].identifier === identifier) {
      result = i;
      break;
    }
  }
  return result;
}
function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];
  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var indexByIdentifier = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3],
      supports: item[4],
      layer: item[5]
    };
    if (indexByIdentifier !== -1) {
      stylesInDOM[indexByIdentifier].references++;
      stylesInDOM[indexByIdentifier].updater(obj);
    } else {
      var updater = addElementStyle(obj, options);
      options.byIndex = i;
      stylesInDOM.splice(i, 0, {
        identifier: identifier,
        updater: updater,
        references: 1
      });
    }
    identifiers.push(identifier);
  }
  return identifiers;
}
function addElementStyle(obj, options) {
  var api = options.domAPI(options);
  api.update(obj);
  var updater = function updater(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {
        return;
      }
      api.update(obj = newObj);
    } else {
      api.remove();
    }
  };
  return updater;
}
module.exports = function (list, options) {
  options = options || {};
  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];
    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDOM[index].references--;
    }
    var newLastIdentifiers = modulesToDom(newList, options);
    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];
      var _index = getIndexByIdentifier(_identifier);
      if (stylesInDOM[_index].references === 0) {
        stylesInDOM[_index].updater();
        stylesInDOM.splice(_index, 1);
      }
    }
    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {



var memo = {};

/* istanbul ignore next  */
function getTarget(target) {
  if (typeof memo[target] === "undefined") {
    var styleTarget = document.querySelector(target);

    // Special case to return head of iframe instead of iframe itself
    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
      try {
        // This will throw an exception if access to iframe is blocked
        // due to cross-origin restrictions
        styleTarget = styleTarget.contentDocument.head;
      } catch (e) {
        // istanbul ignore next
        styleTarget = null;
      }
    }
    memo[target] = styleTarget;
  }
  return memo[target];
}

/* istanbul ignore next  */
function insertBySelector(insert, style) {
  var target = getTarget(insert);
  if (!target) {
    throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
  }
  target.appendChild(style);
}
module.exports = insertBySelector;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {



/* istanbul ignore next  */
function insertStyleElement(options) {
  var element = document.createElement("style");
  options.setAttributes(element, options.attributes);
  options.insert(element, options.options);
  return element;
}
module.exports = insertStyleElement;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



/* istanbul ignore next  */
function setAttributesWithoutAttributes(styleElement) {
  var nonce =  true ? __webpack_require__.nc : 0;
  if (nonce) {
    styleElement.setAttribute("nonce", nonce);
  }
}
module.exports = setAttributesWithoutAttributes;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {



/* istanbul ignore next  */
function apply(styleElement, options, obj) {
  var css = "";
  if (obj.supports) {
    css += "@supports (".concat(obj.supports, ") {");
  }
  if (obj.media) {
    css += "@media ".concat(obj.media, " {");
  }
  var needLayer = typeof obj.layer !== "undefined";
  if (needLayer) {
    css += "@layer".concat(obj.layer.length > 0 ? " ".concat(obj.layer) : "", " {");
  }
  css += obj.css;
  if (needLayer) {
    css += "}";
  }
  if (obj.media) {
    css += "}";
  }
  if (obj.supports) {
    css += "}";
  }
  var sourceMap = obj.sourceMap;
  if (sourceMap && typeof btoa !== "undefined") {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  }

  // For old IE
  /* istanbul ignore if  */
  options.styleTagTransform(css, styleElement, options.options);
}
function removeStyleElement(styleElement) {
  // istanbul ignore if
  if (styleElement.parentNode === null) {
    return false;
  }
  styleElement.parentNode.removeChild(styleElement);
}

/* istanbul ignore next  */
function domAPI(options) {
  if (typeof document === "undefined") {
    return {
      update: function update() {},
      remove: function remove() {}
    };
  }
  var styleElement = options.insertStyleElement(options);
  return {
    update: function update(obj) {
      apply(styleElement, options, obj);
    },
    remove: function remove() {
      removeStyleElement(styleElement);
    }
  };
}
module.exports = domAPI;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {



/* istanbul ignore next  */
function styleTagTransform(css, styleElement) {
  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css;
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild);
    }
    styleElement.appendChild(document.createTextNode(css));
  }
}
module.exports = styleTagTransform;

/***/ }),

/***/ "./app/static/pages/components/Block1.tsx":
/*!************************************************!*\
  !*** ./app/static/pages/components/Block1.tsx ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = Block1;
var jsx_runtime_1 = __webpack_require__(/*! preact/jsx-runtime */ "./node_modules/preact/jsx-runtime/dist/jsxRuntime.module.js");
var preact_router_1 = __webpack_require__(/*! preact-router */ "./node_modules/preact-router/dist/preact-router.mjs");
var image_hero_jpg_1 = __importDefault(__webpack_require__(/*! ../../assets/desktop/image-hero.jpg */ "./app/static/assets/desktop/image-hero.jpg"));
var image_hero_jpg_2 = __importDefault(__webpack_require__(/*! ../../assets/tablet/image-hero.jpg */ "./app/static/assets/tablet/image-hero.jpg"));
var image_hero_jpg_3 = __importDefault(__webpack_require__(/*! ../../assets/mobile/image-hero.jpg */ "./app/static/assets/mobile/image-hero.jpg"));
var items = {
    title: 'Branding & website design agency',
    description: 'We specialize in visual storytelling by creating cohesive brand and website design solutions for small businesses, giving lasting impressions to audiences in a digital world.',
    button: 'Learn More',
};
var linkItems = {
    title: 'Learn More',
    href: '#',
};
function Block1() {
    return ((0, jsx_runtime_1.jsxs)("div", { className: "relative mb-[96px] flex w-full max-w-[calc(1275px+39px)] flex-col-reverse items-center justify-between md:mb-0 md:h-[606px] md:flex-row md:items-start md:self-end md:pl-[39px] xl:h-[800px]", children: [(0, jsx_runtime_1.jsxs)("div", { className: "relative z-[1] mt-[56px] flex w-fit max-w-[730px] flex-col items-center gap-[40px] px-[24px] md:mt-[77px] md:w-full md:items-start md:gap-[48px] md:px-0 xl:mt-[112px]", children: [(0, jsx_runtime_1.jsxs)("section", { className: "flex flex-col gap-[20px] md:gap-[39px]", children: [(0, jsx_runtime_1.jsx)("h1", { className: "w-full md:max-w-[398px] xl:max-w-[680px]", children: items.title }), (0, jsx_runtime_1.jsx)("p", { className: "w-full md:max-w-[398px] xl:max-w-[540px]", children: items.description })] }), (0, jsx_runtime_1.jsx)(preact_router_1.Link, { className: "flex h-[72px] w-[177px] items-center justify-center self-start bg-[#F94F4F] text-[18px] font-extrabold text-white transition hover:bg-[#FF9393]", href: linkItems.href, children: linkItems.title })] }), (0, jsx_runtime_1.jsxs)("picture", { className: "right-0 w-full md:absolute md:h-[608px] md:w-fit xl:h-[800px]", children: [(0, jsx_runtime_1.jsx)("source", { media: "(max-width: 768px)", srcSet: image_hero_jpg_3.default }), (0, jsx_runtime_1.jsx)("source", { media: "(max-width: 1024px)", srcSet: image_hero_jpg_2.default }), (0, jsx_runtime_1.jsx)("img", { className: "md:object-fit size-full object-cover md:h-[606px] xl:h-[800px]", src: image_hero_jpg_1.default, alt: "men working on computers" })] })] }));
}


/***/ }),

/***/ "./app/static/pages/components/Block2.tsx":
/*!************************************************!*\
  !*** ./app/static/pages/components/Block2.tsx ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = Block2;
var jsx_runtime_1 = __webpack_require__(/*! preact/jsx-runtime */ "./node_modules/preact/jsx-runtime/dist/jsxRuntime.module.js");
var preact_router_1 = __webpack_require__(/*! preact-router */ "./node_modules/preact-router/dist/preact-router.mjs");
var image_strategic_jpg_1 = __importDefault(__webpack_require__(/*! ../../assets/desktop/image-strategic.jpg */ "./app/static/assets/desktop/image-strategic.jpg"));
var image_strategic_jpg_2 = __importDefault(__webpack_require__(/*! ../../assets/mobile/image-strategic.jpg */ "./app/static/assets/mobile/image-strategic.jpg"));
var bg_pattern_wave_red_svg_1 = __importDefault(__webpack_require__(/*! ../../assets/desktop/bg-pattern-wave-red.svg */ "./app/static/assets/desktop/bg-pattern-wave-red.svg"));
var items = {
    title: 'Design is strategic.',
    description: '“A well-crafted design strategy consistently produces desired outcomes and brand awareness. We are firm believers that success lies in creative collaboration with our clients.”',
    linkTitle: 'Schedule a Call',
};
function Block2() {
    return ((0, jsx_runtime_1.jsxs)("div", { className: "relative flex w-full flex-col md:h-[648px] md:flex-row  md:justify-end lg:h-[750px] xl:h-[984px]", children: [(0, jsx_runtime_1.jsxs)("picture", { children: [(0, jsx_runtime_1.jsx)("source", { media: "(max-width: 768px)", srcSet: image_strategic_jpg_2.default }), (0, jsx_runtime_1.jsx)("img", { className: "left-0 object-cover md:absolute md:h-[658px] md:w-[735px] md:object-[100%_0%] xl:h-[984px] xl:object-center", height: 984, width: 735, src: image_strategic_jpg_1.default, alt: "strategic" })] }), (0, jsx_runtime_1.jsx)("div", { className: "relative flex items-center bg-[#191921] py-[72px] md:h-[538px] md:w-[390px] md:py-0 md:pl-[69px] md:pr-[40px] lg:h-[560px] lg:w-[530px] lg:pl-[90px] lg:pr-[60px] xl:h-[784px] xl:w-[705px] xl:pl-[154px] xl:pr-[106px]", children: (0, jsx_runtime_1.jsxs)("div", { className: "flex flex-col gap-[48px] px-[24px] md:px-0", children: [(0, jsx_runtime_1.jsx)("img", { className: "absolute top-[-15px] h-[28px] w-[62px] md:left-[-31px] md:top-[220px] xl:left-[-67px] xl:top-[234px] xl:h-[61px] xl:w-[135px]", width: 135, height: 61, src: bg_pattern_wave_red_svg_1.default, alt: "pattern" }), (0, jsx_runtime_1.jsxs)("section", { className: "flex flex-col gap-[32px] md:max-w-[281px] lg:max-w-full xl:gap-[43px]", children: [(0, jsx_runtime_1.jsxs)("h2", { className: "text-white md:max-w-[250px] lg:max-w-full", children: [(0, jsx_runtime_1.jsx)("span", { className: "text-[#F94F4F]", children: items.title.split(' ')[0] }), " ".concat(items.title.split(' ').slice(1).join(' '))] }), (0, jsx_runtime_1.jsx)("p", { className: "text-white", children: items.description })] }), (0, jsx_runtime_1.jsx)(preact_router_1.Link, { className: "font-extrabold text-[#F94F4F] underline underline-offset-[12px] transition hover:text-[#FF9393]", href: "#", children: items.linkTitle })] }) })] }));
}


/***/ }),

/***/ "./app/static/pages/components/Block3.tsx":
/*!************************************************!*\
  !*** ./app/static/pages/components/Block3.tsx ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = Block3;
var jsx_runtime_1 = __webpack_require__(/*! preact/jsx-runtime */ "./node_modules/preact/jsx-runtime/dist/jsxRuntime.module.js");
var title = 'Our approach for creating a winning brand';
var items = [
    {
        title: 'Brand Strategy',
        description: 'Brand strategy is critical for long-term success. Outshining competitors and capturing the target audience are key.',
    },
    {
        title: 'Brand Design',
        description: 'Keeping the brand design unique and meaningful helps in communicating the brand’s timeless value effectively.',
    },
    {
        title: 'Web Design',
        description: 'A beautifully crafted website is the best tool for brand awareness, and ultimately results in increased revenues. ',
    },
];
function Block3() {
    return ((0, jsx_runtime_1.jsxs)("div", { className: "flex w-full justify-between xl:justify-end xl:pl-[39px]", children: [(0, jsx_runtime_1.jsx)("div", { className: "relative z-[2] flex  w-full justify-center px-[24px] lg:px-0 xl:mr-[-160px] xl:w-fit", children: (0, jsx_runtime_1.jsx)("h2", { className: "z-[2] mt-[120px] h-fit w-full max-w-[281px] lg:mt-0 xl:mt-[200px] xl:max-w-[540px] xl:pl-0", children: title }) }), (0, jsx_runtime_1.jsx)("div", { className: "z-[1] flex h-[797px] w-[1400px] items-center justify-center bg-[#F94F4F] md:mt-[-120px] lg:mt-[-200px] xl:h-[1100px] xl:w-[895px] xl:justify-end xl:pr-[106px]", children: (0, jsx_runtime_1.jsx)("ul", { className: "flex flex-col gap-[40px] xl:gap-[56px]", children: items.map(function (item, index) { return ((0, jsx_runtime_1.jsxs)("li", { className: "flex h-[200px] w-[355px] flex-col gap-[24px] xl:w-[504px]", children: [(0, jsx_runtime_1.jsx)("span", { className: "absolute text-[80px] font-extrabold leading-[88px] text-white/25", children: (index + 1).toLocaleString('en-US', {
                                    minimumIntegerDigits: 2,
                                    useGrouping: false,
                                }) }), (0, jsx_runtime_1.jsxs)("section", { className: "ml-[59px] mt-[44px] flex flex-col gap-[24px]", children: [(0, jsx_runtime_1.jsx)("h3", { className: "text-white", children: item.title }), (0, jsx_runtime_1.jsx)("p", { className: "text-white", children: item.description })] })] }, item)); }) }) })] }));
}


/***/ }),

/***/ "./app/static/pages/components/Block4.tsx":
/*!************************************************!*\
  !*** ./app/static/pages/components/Block4.tsx ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = Block4;
var jsx_runtime_1 = __webpack_require__(/*! preact/jsx-runtime */ "./node_modules/preact/jsx-runtime/dist/jsxRuntime.module.js");
var image_slide_1_jpg_1 = __importDefault(__webpack_require__(/*! ../../assets/desktop/image-slide-1.jpg */ "./app/static/assets/desktop/image-slide-1.jpg"));
var image_slide_2_jpg_1 = __importDefault(__webpack_require__(/*! ../../assets/desktop/image-slide-2.jpg */ "./app/static/assets/desktop/image-slide-2.jpg"));
var image_slide_3_jpg_1 = __importDefault(__webpack_require__(/*! ../../assets/desktop/image-slide-3.jpg */ "./app/static/assets/desktop/image-slide-3.jpg"));
var bg_pattern_wavy_white_svg_1 = __importDefault(__webpack_require__(/*! ../../assets/desktop/bg-pattern-wavy-white.svg */ "./app/static/assets/desktop/bg-pattern-wavy-white.svg"));
var hooks_1 = __webpack_require__(/*! preact/hooks */ "./node_modules/preact/hooks/dist/hooks.module.js");
var preact_flicking_1 = __importDefault(__webpack_require__(/*! @egjs/preact-flicking */ "./node_modules/@egjs/preact-flicking/dist/flicking.esm.js"));
__webpack_require__(/*! @egjs/preact-flicking/dist/flicking.css */ "./node_modules/@egjs/preact-flicking/dist/flicking.css");
var TitleKey;
(function (TitleKey) {
    TitleKey[TitleKey["guidelines"] = 0] = "guidelines";
    TitleKey[TitleKey["merchandise"] = 1] = "merchandise";
    TitleKey[TitleKey["design"] = 2] = "design";
})(TitleKey || (TitleKey = {}));
var title = (_a = {},
    _a[TitleKey.guidelines] = {
        mainTitle: 'Brand naming & guidelines',
        title: 'Lean Product Roadmap',
        description: '2019 Project',
    },
    _a[TitleKey.merchandise] = {
        mainTitle: 'Brand identity & merchandise',
        title: 'New Majestic Hotel',
        description: '2018 Project',
    },
    _a[TitleKey.design] = {
        mainTitle: 'Brand identity & web design',
        title: 'Crypto Dashboard',
        description: '2016 Project',
    },
    _a);
var titlesButtons = {
    previous: 'previous slide',
    next: 'next slide',
};
function Block4() {
    var flicking = (0, hooks_1.useRef)();
    var mainTitleRef = (0, hooks_1.useRef)(null);
    var sectionRef = (0, hooks_1.useRef)(null);
    var _a = (0, hooks_1.useState)(TitleKey.guidelines), currentSlide = _a[0], setCurrentSlide = _a[1];
    var _b = (0, hooks_1.useState)(false), isPlaying = _b[0], setIsPlaying = _b[1];
    return ((0, jsx_runtime_1.jsxs)("div", { className: "relative flex min-h-[472px] w-full justify-start xl:min-h-[728px]", children: [(0, jsx_runtime_1.jsxs)("div", { className: "relative z-[1] flex h-[352px] w-1/2 max-w-[735px] items-center justify-center bg-[#191921] pl-[40px] xl:h-[528px]", children: [(0, jsx_runtime_1.jsx)("img", { alt: "pattern", className: "absolute right-[-31px] top-[126px] z-[2] h-[28px] w-[62px] xl:right-[-67px] xl:top-[186px] xl:h-[60px] xl:w-[134px]", src: bg_pattern_wavy_white_svg_1.default, width: 134, height: 60 }), (0, jsx_runtime_1.jsxs)("div", { className: "flex h-[233px] w-[390px] flex-col justify-center gap-[51px] xl:w-[445px]", children: [(0, jsx_runtime_1.jsx)("h2", { ref: mainTitleRef, className: "animationElement max-w-[281px] text-white xl:max-w-full", children: title[currentSlide].mainTitle }), (0, jsx_runtime_1.jsxs)("div", { className: "flex gap-[16px]", children: [(0, jsx_runtime_1.jsx)("button", { disabled: isPlaying, onClick: function () {
                                            var _a;
                                            void ((_a = flicking.current) === null || _a === void 0 ? void 0 : _a.prev());
                                        }, title: "previous slide", type: "button", className: "previous relative z-40 size-[40px]", children: (0, jsx_runtime_1.jsxs)("svg", { width: "40", height: "40", xmlns: "http://www.w3.org/2000/svg", children: [(0, jsx_runtime_1.jsx)("title", { children: titlesButtons.previous }), (0, jsx_runtime_1.jsxs)("g", { transform: "matrix(-1 0 0 1 40 0)", fill: "none", fillRule: "evenodd", children: [(0, jsx_runtime_1.jsx)("circle", { cx: "20", cy: "20", r: "19.5" }), (0, jsx_runtime_1.jsx)("path", { strokeWidth: "2", d: "M17.5 15l5 5-5 5" })] })] }) }), (0, jsx_runtime_1.jsx)("button", { disabled: isPlaying, onClick: function () {
                                            var _a;
                                            void ((_a = flicking.current) === null || _a === void 0 ? void 0 : _a.next());
                                        }, title: "next slide", type: "button", className: "previous relative z-40 size-[40px]", children: (0, jsx_runtime_1.jsxs)("svg", { width: "40", height: "40", xmlns: "http://www.w3.org/2000/svg", children: [(0, jsx_runtime_1.jsx)("title", { children: titlesButtons.next }), (0, jsx_runtime_1.jsxs)("g", { fill: "none", fillRule: "evenodd", children: [(0, jsx_runtime_1.jsx)("circle", { cx: "20", cy: "20", r: "19.5" }), (0, jsx_runtime_1.jsx)("path", { strokeWidth: "2", d: "M17.5 15l5 5-5 5" })] })] }) })] })] })] }), (0, jsx_runtime_1.jsxs)("div", { className: "absolute right-0 z-0 w-3/5 xl:h-[728px] xl:w-[895px] ", children: [(0, jsx_runtime_1.jsxs)(preact_flicking_1.default, { onMoveStart: function () {
                            var _a, _b;
                            setIsPlaying(true);
                            (_a = mainTitleRef.current) === null || _a === void 0 ? void 0 : _a.classList.add('animateTransition');
                            (_b = sectionRef.current) === null || _b === void 0 ? void 0 : _b.classList.add('animateTransition');
                        }, onMoveEnd: function () {
                            var _a, _b;
                            setIsPlaying(false);
                            (_a = mainTitleRef.current) === null || _a === void 0 ? void 0 : _a.classList.remove('animateTransition');
                            (_b = sectionRef.current) === null || _b === void 0 ? void 0 : _b.classList.remove('animateTransition');
                        }, ref: flicking, circular: true, onChanged: function (e) {
                            setCurrentSlide(e.index);
                        }, children: [(0, jsx_runtime_1.jsx)("div", { className: "panel image-container", children: (0, jsx_runtime_1.jsx)("img", { className: "carouselImage", src: image_slide_1_jpg_1.default, alt: "Slide 1" }) }, TitleKey.guidelines), (0, jsx_runtime_1.jsx)("div", { className: "panel image-container", children: (0, jsx_runtime_1.jsx)("img", { className: "carouselImage", src: image_slide_2_jpg_1.default, alt: "Slide 2" }) }, TitleKey.merchandise), (0, jsx_runtime_1.jsx)("div", { className: "panel image-container", children: (0, jsx_runtime_1.jsx)("img", { className: "carouselImage", src: image_slide_3_jpg_1.default, alt: "Slide 3" }) }, TitleKey.design)] }), (0, jsx_runtime_1.jsx)("div", { className: "absolute bottom-[68px] right-[154px] z-[1]", children: (0, jsx_runtime_1.jsxs)("section", { ref: sectionRef, className: "animationElement flex flex-col text-end", children: [(0, jsx_runtime_1.jsx)("h3", { className: "text-white", children: title[currentSlide].title }), (0, jsx_runtime_1.jsx)("p", { className: "text-white", children: title[currentSlide].description })] }) })] })] }));
}


/***/ }),

/***/ "./app/static/pages/components/Footer.tsx":
/*!************************************************!*\
  !*** ./app/static/pages/components/Footer.tsx ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = Footer;
var jsx_runtime_1 = __webpack_require__(/*! preact/jsx-runtime */ "./node_modules/preact/jsx-runtime/dist/jsxRuntime.module.js");
var bg_pattern_wave_red_svg_1 = __importDefault(__webpack_require__(/*! ../../assets/desktop/bg-pattern-wave-red.svg */ "./app/static/assets/desktop/bg-pattern-wave-red.svg"));
var items = {
    title: 'Let’s build something great together.',
    buttonDescription: 'Schedule a Call',
};
function Footer() {
    return ((0, jsx_runtime_1.jsxs)("footer", { className: "mx-auto mb-[101px] mt-[70px] flex w-full max-w-[1342px] items-center px-[40px] xl:mb-[115px] xl:ml-[-67px] xl:mt-[120px] xl:px-0", children: [(0, jsx_runtime_1.jsx)("img", { className: "hidden xl:block", alt: "pattern", src: bg_pattern_wave_red_svg_1.default, width: 134, height: 60 }), (0, jsx_runtime_1.jsxs)("div", { className: "flex w-full items-center justify-between xl:ml-[98px]", children: [(0, jsx_runtime_1.jsx)("h2", { className: "max-w-[398px] xl:max-w-[635px]", children: items.title }), (0, jsx_runtime_1.jsx)("button", { type: "button", className: "h-[64px] w-[199px] bg-[#F94F4F] text-[16px] font-extrabold text-white transition hover:bg-[#FF9393]", children: items.buttonDescription })] })] }));
}


/***/ }),

/***/ "./app/static/pages/components/Navbar.tsx":
/*!************************************************!*\
  !*** ./app/static/pages/components/Navbar.tsx ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = Navbar;
var jsx_runtime_1 = __webpack_require__(/*! preact/jsx-runtime */ "./node_modules/preact/jsx-runtime/dist/jsxRuntime.module.js");
var hooks_1 = __webpack_require__(/*! preact/hooks */ "./node_modules/preact/hooks/dist/hooks.module.js");
var logo_svg_1 = __importDefault(__webpack_require__(/*! ../../assets/desktop/logo.svg */ "./app/static/assets/desktop/logo.svg"));
var preact_router_1 = __webpack_require__(/*! preact-router */ "./node_modules/preact-router/dist/preact-router.mjs");
var items = [
    {
        title: 'About',
        href: '#',
    },
    {
        title: 'Service',
        href: '#',
    },
    {
        title: 'Projects',
        href: '#',
    },
];
var buttonTitle = 'Schedule a Call';
function Navbar() {
    var menuButtonRef = (0, hooks_1.useRef)(null);
    function handleOpen() {
        if (menuButtonRef.current) {
            menuButtonRef.current.classList.toggle('open');
        }
    }
    return ((0, jsx_runtime_1.jsxs)("nav", { className: "relative z-[2] flex h-[110px] w-full max-w-[calc(1275px+39px)] items-center justify-between self-end overflow-x-clip pl-[39px] md:h-[178px]", children: [(0, jsx_runtime_1.jsx)("div", { id: "mask", className: "fixed left-0 top-0 z-[1] flex size-full" }), (0, jsx_runtime_1.jsxs)("div", { id: "mobileMenu", className: "absolute right-[26px] top-[110px] z-40 flex h-[292px] w-full max-w-[252px] flex-col items-center gap-[24px] bg-black pt-[32px]", children: [(0, jsx_runtime_1.jsx)("ul", { className: " relative z-40 flex flex-col items-center gap-[24px]", children: items.map(function (item) { return ((0, jsx_runtime_1.jsx)("li", { className: "relative z-40", children: (0, jsx_runtime_1.jsx)(preact_router_1.Link, { className: " relative z-40 text-[18px] leading-[32px] text-white transition-all", href: item.href, children: item.title }) }, item.title)); }) }), (0, jsx_runtime_1.jsx)("button", { type: "button", className: "relative z-40 h-[64px] w-[199px] bg-[#F94F4F] text-[16px] font-extrabold text-white", children: buttonTitle })] }), (0, jsx_runtime_1.jsx)("img", { className: "relative -z-0 flex", src: logo_svg_1.default, alt: "logo" }), (0, jsx_runtime_1.jsxs)("div", { className: "hidden size-full max-w-[438px] items-center gap-[28px] bg-[#F94F4F] pl-[33px] pr-[40px] md:flex lg:max-w-[530px] lg:gap-[50px] lg:pr-[20px] xl:max-w-[47vw] xl:gap-[48px] xl:pl-[69px] xl:pr-0 screen1500:max-w-[705px]", children: [(0, jsx_runtime_1.jsx)("ul", { className: "flex w-full max-w-[190px] justify-between xl:max-w-[225px]", children: items.map(function (item) { return ((0, jsx_runtime_1.jsx)("li", { children: (0, jsx_runtime_1.jsx)(preact_router_1.Link, { className: " leading-[32px] text-white transition-all hover:font-bold", href: item.href, children: item.title }) }, item.title)); }) }), (0, jsx_runtime_1.jsx)("button", { type: "button", className: "h-[64px] min-w-[147px] bg-[#191921] text-[16px] font-extrabold text-white transition hover:bg-[#434356] xl:min-w-[199px]", children: buttonTitle })] }), (0, jsx_runtime_1.jsx)("button", { ref: menuButtonRef, onClick: function () {
                    handleOpen();
                }, id: "mobileNav", title: "mobile navigation", type: "button", className: "absolute right-[24px] z-[2] md:opacity-0" })] }));
}


/***/ }),

/***/ "./app/static/pages/layout.tsx":
/*!*************************************!*\
  !*** ./app/static/pages/layout.tsx ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var jsx_runtime_1 = __webpack_require__(/*! preact/jsx-runtime */ "./node_modules/preact/jsx-runtime/dist/jsxRuntime.module.js");
var preact_1 = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.module.js");
// import DataContext from './_lib/DataContext'; // placeholder
var Navbar_1 = __importDefault(__webpack_require__(/*! ./components/Navbar */ "./app/static/pages/components/Navbar.tsx"));
var page_1 = __importDefault(__webpack_require__(/*! ./page */ "./app/static/pages/page.tsx"));
var Footer_1 = __importDefault(__webpack_require__(/*! ./components/Footer */ "./app/static/pages/components/Footer.tsx"));
__webpack_require__(/*! ./globals.css */ "./app/static/pages/globals.css");
document.body.className =
    'min-h-dvh mx-auto md:min-h-screen max-w-[1440px] flex flex-col items-center font-commissioner justify-space-between';
function App() {
    return ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsx)(Navbar_1.default, {}), (0, jsx_runtime_1.jsx)("main", { className: "mx-auto mb-auto flex w-full flex-col items-center overflow-x-clip", children: (0, jsx_runtime_1.jsx)(page_1.default, {}) }), (0, jsx_runtime_1.jsx)(Footer_1.default, {})] }));
}
function Body() {
    return (0, jsx_runtime_1.jsx)(App, {});
}
(0, preact_1.render)((0, jsx_runtime_1.jsx)(Body, {}), document.body);


/***/ }),

/***/ "./app/static/pages/page.tsx":
/*!***********************************!*\
  !*** ./app/static/pages/page.tsx ***!
  \***********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var jsx_runtime_1 = __webpack_require__(/*! preact/jsx-runtime */ "./node_modules/preact/jsx-runtime/dist/jsxRuntime.module.js");
var Block1_1 = __importDefault(__webpack_require__(/*! ./components/Block1 */ "./app/static/pages/components/Block1.tsx"));
var Block2_1 = __importDefault(__webpack_require__(/*! ./components/Block2 */ "./app/static/pages/components/Block2.tsx"));
var Block3_1 = __importDefault(__webpack_require__(/*! ./components/Block3 */ "./app/static/pages/components/Block3.tsx"));
var Block4_1 = __importDefault(__webpack_require__(/*! ./components/Block4 */ "./app/static/pages/components/Block4.tsx"));
var Home = function () {
    return ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsx)(Block1_1.default, {}), (0, jsx_runtime_1.jsx)(Block2_1.default, {}), (0, jsx_runtime_1.jsx)(Block3_1.default, {}), (0, jsx_runtime_1.jsx)(Block4_1.default, {})] }));
};
exports["default"] = Home;


/***/ }),

/***/ "./app/static/assets/desktop/bg-pattern-wave-red.svg":
/*!***********************************************************!*\
  !*** ./app/static/assets/desktop/bg-pattern-wave-red.svg ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "images/8c3a13227cedc28ff49f.svg";

/***/ }),

/***/ "./app/static/assets/desktop/bg-pattern-wavy-white.svg":
/*!*************************************************************!*\
  !*** ./app/static/assets/desktop/bg-pattern-wavy-white.svg ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "images/549bc30aec22dc2bfd51.svg";

/***/ }),

/***/ "./app/static/assets/desktop/image-hero.jpg":
/*!**************************************************!*\
  !*** ./app/static/assets/desktop/image-hero.jpg ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "images/68589f1496e97e711702.jpg";

/***/ }),

/***/ "./app/static/assets/desktop/image-slide-1.jpg":
/*!*****************************************************!*\
  !*** ./app/static/assets/desktop/image-slide-1.jpg ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "images/61ea577f93a852703ca3.jpg";

/***/ }),

/***/ "./app/static/assets/desktop/image-slide-2.jpg":
/*!*****************************************************!*\
  !*** ./app/static/assets/desktop/image-slide-2.jpg ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "images/c02dc940dc3a5899ab81.jpg";

/***/ }),

/***/ "./app/static/assets/desktop/image-slide-3.jpg":
/*!*****************************************************!*\
  !*** ./app/static/assets/desktop/image-slide-3.jpg ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "images/e232c4ceebf129242018.jpg";

/***/ }),

/***/ "./app/static/assets/desktop/image-strategic.jpg":
/*!*******************************************************!*\
  !*** ./app/static/assets/desktop/image-strategic.jpg ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "images/1da0fbce3beeacea8ba8.jpg";

/***/ }),

/***/ "./app/static/assets/desktop/logo.svg":
/*!********************************************!*\
  !*** ./app/static/assets/desktop/logo.svg ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "images/bd6256eaed9209fe195a.svg";

/***/ }),

/***/ "./app/static/assets/mobile/icon-cross.svg":
/*!*************************************************!*\
  !*** ./app/static/assets/mobile/icon-cross.svg ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "images/7f0676df78e74b2858bc.svg";

/***/ }),

/***/ "./app/static/assets/mobile/icon-hamburger.svg":
/*!*****************************************************!*\
  !*** ./app/static/assets/mobile/icon-hamburger.svg ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "images/e7bdcc70ff60955e5c36.svg";

/***/ }),

/***/ "./app/static/assets/mobile/image-hero.jpg":
/*!*************************************************!*\
  !*** ./app/static/assets/mobile/image-hero.jpg ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "images/71252dd8e56f810bab8b.jpg";

/***/ }),

/***/ "./app/static/assets/mobile/image-strategic.jpg":
/*!******************************************************!*\
  !*** ./app/static/assets/mobile/image-strategic.jpg ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "images/56c30bc37cbe9047a5f6.jpg";

/***/ }),

/***/ "./app/static/assets/tablet/image-hero.jpg":
/*!*************************************************!*\
  !*** ./app/static/assets/tablet/image-hero.jpg ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "images/d854e8adff55c325467b.jpg";

/***/ }),

/***/ "./node_modules/preact-router/dist/preact-router.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/preact-router/dist/preact-router.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Link: () => (/* binding */ E),
/* harmony export */   Route: () => (/* binding */ L),
/* harmony export */   Router: () => (/* binding */ D),
/* harmony export */   "default": () => (/* binding */ D),
/* harmony export */   exec: () => (/* binding */ s),
/* harmony export */   getCurrentUrl: () => (/* binding */ R),
/* harmony export */   route: () => (/* binding */ $),
/* harmony export */   useRouter: () => (/* binding */ C)
/* harmony export */ });
/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.module.js");
/* harmony import */ var preact_hooks__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! preact/hooks */ "./node_modules/preact/hooks/dist/hooks.module.js");
var a={};function c(n,t){for(var r in t)n[r]=t[r];return n}function s(n,t,r){var i,o=/(?:\?([^#]*))?(#.*)?$/,e=n.match(o),u={};if(e&&e[1])for(var f=e[1].split("&"),c=0;c<f.length;c++){var s=f[c].split("=");u[decodeURIComponent(s[0])]=decodeURIComponent(s.slice(1).join("="))}n=d(n.replace(o,"")),t=d(t||"");for(var h=Math.max(n.length,t.length),v=0;v<h;v++)if(t[v]&&":"===t[v].charAt(0)){var l=t[v].replace(/(^:|[+*?]+$)/g,""),p=(t[v].match(/[+*?]+$/)||a)[0]||"",m=~p.indexOf("+"),y=~p.indexOf("*"),U=n[v]||"";if(!U&&!y&&(p.indexOf("?")<0||m)){i=!1;break}if(u[l]=decodeURIComponent(U),m||y){u[l]=n.slice(v).map(decodeURIComponent).join("/");break}}else if(t[v]!==n[v]){i=!1;break}return(!0===r.default||!1!==i)&&u}function h(n,t){return n.rank<t.rank?1:n.rank>t.rank?-1:n.index-t.index}function v(n,t){return n.index=t,n.rank=function(n){return n.props.default?0:d(n.props.path).map(l).join("")}(n),n.props}function d(n){return n.replace(/(^\/+|\/+$)/g,"").split("/")}function l(n){return":"==n.charAt(0)?1+"*+?".indexOf(n.charAt(n.length-1))||4:5}var p={},m=[],y=[],U=null,g={url:R()},k=(0,preact__WEBPACK_IMPORTED_MODULE_0__.createContext)(g);function C(){var n=(0,preact_hooks__WEBPACK_IMPORTED_MODULE_1__.useContext)(k);if(n===g){var t=(0,preact_hooks__WEBPACK_IMPORTED_MODULE_1__.useState)()[1];(0,preact_hooks__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function(){return y.push(t),function(){return y.splice(y.indexOf(t),1)}},[])}return[n,$]}function R(){var n;return""+((n=U&&U.location?U.location:U&&U.getCurrentLocation?U.getCurrentLocation():"undefined"!=typeof location?location:p).pathname||"")+(n.search||"")}function $(n,t){return void 0===t&&(t=!1),"string"!=typeof n&&n.url&&(t=n.replace,n=n.url),function(n){for(var t=m.length;t--;)if(m[t].canRoute(n))return!0;return!1}(n)&&function(n,t){void 0===t&&(t="push"),U&&U[t]?U[t](n):"undefined"!=typeof history&&history[t+"State"]&&history[t+"State"](null,null,n)}(n,t?"replace":"push"),I(n)}function I(n){for(var t=!1,r=0;r<m.length;r++)m[r].routeTo(n)&&(t=!0);return t}function M(n){if(n&&n.getAttribute){var t=n.getAttribute("href"),r=n.getAttribute("target");if(t&&t.match(/^\//g)&&(!r||r.match(/^_?self$/i)))return $(t)}}function b(n){return n.stopImmediatePropagation&&n.stopImmediatePropagation(),n.stopPropagation&&n.stopPropagation(),n.preventDefault(),!1}function W(n){if(!(n.ctrlKey||n.metaKey||n.altKey||n.shiftKey||n.button)){var t=n.target;do{if("a"===t.localName&&t.getAttribute("href")){if(t.hasAttribute("data-native")||t.hasAttribute("native"))return;if(M(t))return b(n)}}while(t=t.parentNode)}}var w=!1;function D(n){n.history&&(U=n.history),this.state={url:n.url||R()}}c(D.prototype=new preact__WEBPACK_IMPORTED_MODULE_0__.Component,{shouldComponentUpdate:function(n){return!0!==n.static||n.url!==this.props.url||n.onChange!==this.props.onChange},canRoute:function(n){var t=(0,preact__WEBPACK_IMPORTED_MODULE_0__.toChildArray)(this.props.children);return void 0!==this.g(t,n)},routeTo:function(n){this.setState({url:n});var t=this.canRoute(n);return this.p||this.forceUpdate(),t},componentWillMount:function(){this.p=!0},componentDidMount:function(){var n=this;w||(w=!0,U||addEventListener("popstate",function(){I(R())}),addEventListener("click",W)),m.push(this),U&&(this.u=U.listen(function(t){var r=t.location||t;n.routeTo(""+(r.pathname||"")+(r.search||""))})),this.p=!1},componentWillUnmount:function(){"function"==typeof this.u&&this.u(),m.splice(m.indexOf(this),1)},componentWillUpdate:function(){this.p=!0},componentDidUpdate:function(){this.p=!1},g:function(n,t){n=n.filter(v).sort(h);for(var r=0;r<n.length;r++){var i=n[r],o=s(t,i.props.path,i.props);if(o)return[i,o]}},render:function(n,t){var e,u,f=n.onChange,a=t.url,s=this.c,h=this.g((0,preact__WEBPACK_IMPORTED_MODULE_0__.toChildArray)(n.children),a);if(h&&(u=(0,preact__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(h[0],c(c({url:a,matches:e=h[1]},e),{key:void 0,ref:void 0}))),a!==(s&&s.url)){c(g,s=this.c={url:a,previous:s&&s.url,current:u,path:u?u.props.path:null,matches:e}),s.router=this,s.active=u?[u]:[];for(var v=y.length;v--;)y[v]({});"function"==typeof f&&f(s)}return (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(k.Provider,{value:s},u)}});var E=function(n){return (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)("a",c({onClick:W},n))},L=function(n){return (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(n.component,n)};
//# sourceMappingURL=preact-router.module.js.map


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			if (cachedModule.error !== undefined) throw cachedModule.error;
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		try {
/******/ 			var execOptions = { id: moduleId, module: module, factory: __webpack_modules__[moduleId], require: __webpack_require__ };
/******/ 			__webpack_require__.i.forEach(function(handler) { handler(execOptions); });
/******/ 			module = execOptions.module;
/******/ 			execOptions.factory.call(module.exports, module, module.exports, execOptions.require);
/******/ 		} catch(e) {
/******/ 			module.error = e;
/******/ 			throw e;
/******/ 		}
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = __webpack_module_cache__;
/******/ 	
/******/ 	// expose the module execution interceptor
/******/ 	__webpack_require__.i = [];
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript update chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference all chunks
/******/ 		__webpack_require__.hu = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + "." + __webpack_require__.h() + ".hot-update.js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get update manifest filename */
/******/ 	(() => {
/******/ 		__webpack_require__.hmrF = () => ("main." + __webpack_require__.h() + ".hot-update.json");
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/getFullHash */
/******/ 	(() => {
/******/ 		__webpack_require__.h = () => ("8f097a1541f904531b28")
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/load script */
/******/ 	(() => {
/******/ 		var inProgress = {};
/******/ 		var dataWebpackPrefix = "flask-preact-typescript-tailwind-template:";
/******/ 		// loadScript function to load a script via script tag
/******/ 		__webpack_require__.l = (url, done, key, chunkId) => {
/******/ 			if(inProgress[url]) { inProgress[url].push(done); return; }
/******/ 			var script, needAttach;
/******/ 			if(key !== undefined) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				for(var i = 0; i < scripts.length; i++) {
/******/ 					var s = scripts[i];
/******/ 					if(s.getAttribute("src") == url || s.getAttribute("data-webpack") == dataWebpackPrefix + key) { script = s; break; }
/******/ 				}
/******/ 			}
/******/ 			if(!script) {
/******/ 				needAttach = true;
/******/ 				script = document.createElement('script');
/******/ 		
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.setAttribute("data-webpack", dataWebpackPrefix + key);
/******/ 		
/******/ 				script.src = url;
/******/ 			}
/******/ 			inProgress[url] = [done];
/******/ 			var onScriptComplete = (prev, event) => {
/******/ 				// avoid mem leaks in IE.
/******/ 				script.onerror = script.onload = null;
/******/ 				clearTimeout(timeout);
/******/ 				var doneFns = inProgress[url];
/******/ 				delete inProgress[url];
/******/ 				script.parentNode && script.parentNode.removeChild(script);
/******/ 				doneFns && doneFns.forEach((fn) => (fn(event)));
/******/ 				if(prev) return prev(event);
/******/ 			}
/******/ 			var timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);
/******/ 			script.onerror = onScriptComplete.bind(null, script.onerror);
/******/ 			script.onload = onScriptComplete.bind(null, script.onload);
/******/ 			needAttach && document.head.appendChild(script);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hot module replacement */
/******/ 	(() => {
/******/ 		var currentModuleData = {};
/******/ 		var installedModules = __webpack_require__.c;
/******/ 		
/******/ 		// module and require creation
/******/ 		var currentChildModule;
/******/ 		var currentParents = [];
/******/ 		
/******/ 		// status
/******/ 		var registeredStatusHandlers = [];
/******/ 		var currentStatus = "idle";
/******/ 		
/******/ 		// while downloading
/******/ 		var blockingPromises = 0;
/******/ 		var blockingPromisesWaiting = [];
/******/ 		
/******/ 		// The update info
/******/ 		var currentUpdateApplyHandlers;
/******/ 		var queuedInvalidatedModules;
/******/ 		
/******/ 		__webpack_require__.hmrD = currentModuleData;
/******/ 		
/******/ 		__webpack_require__.i.push(function (options) {
/******/ 			var module = options.module;
/******/ 			var require = createRequire(options.require, options.id);
/******/ 			module.hot = createModuleHotObject(options.id, module);
/******/ 			module.parents = currentParents;
/******/ 			module.children = [];
/******/ 			currentParents = [];
/******/ 			options.require = require;
/******/ 		});
/******/ 		
/******/ 		__webpack_require__.hmrC = {};
/******/ 		__webpack_require__.hmrI = {};
/******/ 		
/******/ 		function createRequire(require, moduleId) {
/******/ 			var me = installedModules[moduleId];
/******/ 			if (!me) return require;
/******/ 			var fn = function (request) {
/******/ 				if (me.hot.active) {
/******/ 					if (installedModules[request]) {
/******/ 						var parents = installedModules[request].parents;
/******/ 						if (parents.indexOf(moduleId) === -1) {
/******/ 							parents.push(moduleId);
/******/ 						}
/******/ 					} else {
/******/ 						currentParents = [moduleId];
/******/ 						currentChildModule = request;
/******/ 					}
/******/ 					if (me.children.indexOf(request) === -1) {
/******/ 						me.children.push(request);
/******/ 					}
/******/ 				} else {
/******/ 					console.warn(
/******/ 						"[HMR] unexpected require(" +
/******/ 							request +
/******/ 							") from disposed module " +
/******/ 							moduleId
/******/ 					);
/******/ 					currentParents = [];
/******/ 				}
/******/ 				return require(request);
/******/ 			};
/******/ 			var createPropertyDescriptor = function (name) {
/******/ 				return {
/******/ 					configurable: true,
/******/ 					enumerable: true,
/******/ 					get: function () {
/******/ 						return require[name];
/******/ 					},
/******/ 					set: function (value) {
/******/ 						require[name] = value;
/******/ 					}
/******/ 				};
/******/ 			};
/******/ 			for (var name in require) {
/******/ 				if (Object.prototype.hasOwnProperty.call(require, name) && name !== "e") {
/******/ 					Object.defineProperty(fn, name, createPropertyDescriptor(name));
/******/ 				}
/******/ 			}
/******/ 			fn.e = function (chunkId, fetchPriority) {
/******/ 				return trackBlockingPromise(require.e(chunkId, fetchPriority));
/******/ 			};
/******/ 			return fn;
/******/ 		}
/******/ 		
/******/ 		function createModuleHotObject(moduleId, me) {
/******/ 			var _main = currentChildModule !== moduleId;
/******/ 			var hot = {
/******/ 				// private stuff
/******/ 				_acceptedDependencies: {},
/******/ 				_acceptedErrorHandlers: {},
/******/ 				_declinedDependencies: {},
/******/ 				_selfAccepted: false,
/******/ 				_selfDeclined: false,
/******/ 				_selfInvalidated: false,
/******/ 				_disposeHandlers: [],
/******/ 				_main: _main,
/******/ 				_requireSelf: function () {
/******/ 					currentParents = me.parents.slice();
/******/ 					currentChildModule = _main ? undefined : moduleId;
/******/ 					__webpack_require__(moduleId);
/******/ 				},
/******/ 		
/******/ 				// Module API
/******/ 				active: true,
/******/ 				accept: function (dep, callback, errorHandler) {
/******/ 					if (dep === undefined) hot._selfAccepted = true;
/******/ 					else if (typeof dep === "function") hot._selfAccepted = dep;
/******/ 					else if (typeof dep === "object" && dep !== null) {
/******/ 						for (var i = 0; i < dep.length; i++) {
/******/ 							hot._acceptedDependencies[dep[i]] = callback || function () {};
/******/ 							hot._acceptedErrorHandlers[dep[i]] = errorHandler;
/******/ 						}
/******/ 					} else {
/******/ 						hot._acceptedDependencies[dep] = callback || function () {};
/******/ 						hot._acceptedErrorHandlers[dep] = errorHandler;
/******/ 					}
/******/ 				},
/******/ 				decline: function (dep) {
/******/ 					if (dep === undefined) hot._selfDeclined = true;
/******/ 					else if (typeof dep === "object" && dep !== null)
/******/ 						for (var i = 0; i < dep.length; i++)
/******/ 							hot._declinedDependencies[dep[i]] = true;
/******/ 					else hot._declinedDependencies[dep] = true;
/******/ 				},
/******/ 				dispose: function (callback) {
/******/ 					hot._disposeHandlers.push(callback);
/******/ 				},
/******/ 				addDisposeHandler: function (callback) {
/******/ 					hot._disposeHandlers.push(callback);
/******/ 				},
/******/ 				removeDisposeHandler: function (callback) {
/******/ 					var idx = hot._disposeHandlers.indexOf(callback);
/******/ 					if (idx >= 0) hot._disposeHandlers.splice(idx, 1);
/******/ 				},
/******/ 				invalidate: function () {
/******/ 					this._selfInvalidated = true;
/******/ 					switch (currentStatus) {
/******/ 						case "idle":
/******/ 							currentUpdateApplyHandlers = [];
/******/ 							Object.keys(__webpack_require__.hmrI).forEach(function (key) {
/******/ 								__webpack_require__.hmrI[key](
/******/ 									moduleId,
/******/ 									currentUpdateApplyHandlers
/******/ 								);
/******/ 							});
/******/ 							setStatus("ready");
/******/ 							break;
/******/ 						case "ready":
/******/ 							Object.keys(__webpack_require__.hmrI).forEach(function (key) {
/******/ 								__webpack_require__.hmrI[key](
/******/ 									moduleId,
/******/ 									currentUpdateApplyHandlers
/******/ 								);
/******/ 							});
/******/ 							break;
/******/ 						case "prepare":
/******/ 						case "check":
/******/ 						case "dispose":
/******/ 						case "apply":
/******/ 							(queuedInvalidatedModules = queuedInvalidatedModules || []).push(
/******/ 								moduleId
/******/ 							);
/******/ 							break;
/******/ 						default:
/******/ 							// ignore requests in error states
/******/ 							break;
/******/ 					}
/******/ 				},
/******/ 		
/******/ 				// Management API
/******/ 				check: hotCheck,
/******/ 				apply: hotApply,
/******/ 				status: function (l) {
/******/ 					if (!l) return currentStatus;
/******/ 					registeredStatusHandlers.push(l);
/******/ 				},
/******/ 				addStatusHandler: function (l) {
/******/ 					registeredStatusHandlers.push(l);
/******/ 				},
/******/ 				removeStatusHandler: function (l) {
/******/ 					var idx = registeredStatusHandlers.indexOf(l);
/******/ 					if (idx >= 0) registeredStatusHandlers.splice(idx, 1);
/******/ 				},
/******/ 		
/******/ 				//inherit from previous dispose call
/******/ 				data: currentModuleData[moduleId]
/******/ 			};
/******/ 			currentChildModule = undefined;
/******/ 			return hot;
/******/ 		}
/******/ 		
/******/ 		function setStatus(newStatus) {
/******/ 			currentStatus = newStatus;
/******/ 			var results = [];
/******/ 		
/******/ 			for (var i = 0; i < registeredStatusHandlers.length; i++)
/******/ 				results[i] = registeredStatusHandlers[i].call(null, newStatus);
/******/ 		
/******/ 			return Promise.all(results).then(function () {});
/******/ 		}
/******/ 		
/******/ 		function unblock() {
/******/ 			if (--blockingPromises === 0) {
/******/ 				setStatus("ready").then(function () {
/******/ 					if (blockingPromises === 0) {
/******/ 						var list = blockingPromisesWaiting;
/******/ 						blockingPromisesWaiting = [];
/******/ 						for (var i = 0; i < list.length; i++) {
/******/ 							list[i]();
/******/ 						}
/******/ 					}
/******/ 				});
/******/ 			}
/******/ 		}
/******/ 		
/******/ 		function trackBlockingPromise(promise) {
/******/ 			switch (currentStatus) {
/******/ 				case "ready":
/******/ 					setStatus("prepare");
/******/ 				/* fallthrough */
/******/ 				case "prepare":
/******/ 					blockingPromises++;
/******/ 					promise.then(unblock, unblock);
/******/ 					return promise;
/******/ 				default:
/******/ 					return promise;
/******/ 			}
/******/ 		}
/******/ 		
/******/ 		function waitForBlockingPromises(fn) {
/******/ 			if (blockingPromises === 0) return fn();
/******/ 			return new Promise(function (resolve) {
/******/ 				blockingPromisesWaiting.push(function () {
/******/ 					resolve(fn());
/******/ 				});
/******/ 			});
/******/ 		}
/******/ 		
/******/ 		function hotCheck(applyOnUpdate) {
/******/ 			if (currentStatus !== "idle") {
/******/ 				throw new Error("check() is only allowed in idle status");
/******/ 			}
/******/ 			return setStatus("check")
/******/ 				.then(__webpack_require__.hmrM)
/******/ 				.then(function (update) {
/******/ 					if (!update) {
/******/ 						return setStatus(applyInvalidatedModules() ? "ready" : "idle").then(
/******/ 							function () {
/******/ 								return null;
/******/ 							}
/******/ 						);
/******/ 					}
/******/ 		
/******/ 					return setStatus("prepare").then(function () {
/******/ 						var updatedModules = [];
/******/ 						currentUpdateApplyHandlers = [];
/******/ 		
/******/ 						return Promise.all(
/******/ 							Object.keys(__webpack_require__.hmrC).reduce(function (
/******/ 								promises,
/******/ 								key
/******/ 							) {
/******/ 								__webpack_require__.hmrC[key](
/******/ 									update.c,
/******/ 									update.r,
/******/ 									update.m,
/******/ 									promises,
/******/ 									currentUpdateApplyHandlers,
/******/ 									updatedModules
/******/ 								);
/******/ 								return promises;
/******/ 							}, [])
/******/ 						).then(function () {
/******/ 							return waitForBlockingPromises(function () {
/******/ 								if (applyOnUpdate) {
/******/ 									return internalApply(applyOnUpdate);
/******/ 								} else {
/******/ 									return setStatus("ready").then(function () {
/******/ 										return updatedModules;
/******/ 									});
/******/ 								}
/******/ 							});
/******/ 						});
/******/ 					});
/******/ 				});
/******/ 		}
/******/ 		
/******/ 		function hotApply(options) {
/******/ 			if (currentStatus !== "ready") {
/******/ 				return Promise.resolve().then(function () {
/******/ 					throw new Error(
/******/ 						"apply() is only allowed in ready status (state: " +
/******/ 							currentStatus +
/******/ 							")"
/******/ 					);
/******/ 				});
/******/ 			}
/******/ 			return internalApply(options);
/******/ 		}
/******/ 		
/******/ 		function internalApply(options) {
/******/ 			options = options || {};
/******/ 		
/******/ 			applyInvalidatedModules();
/******/ 		
/******/ 			var results = currentUpdateApplyHandlers.map(function (handler) {
/******/ 				return handler(options);
/******/ 			});
/******/ 			currentUpdateApplyHandlers = undefined;
/******/ 		
/******/ 			var errors = results
/******/ 				.map(function (r) {
/******/ 					return r.error;
/******/ 				})
/******/ 				.filter(Boolean);
/******/ 		
/******/ 			if (errors.length > 0) {
/******/ 				return setStatus("abort").then(function () {
/******/ 					throw errors[0];
/******/ 				});
/******/ 			}
/******/ 		
/******/ 			// Now in "dispose" phase
/******/ 			var disposePromise = setStatus("dispose");
/******/ 		
/******/ 			results.forEach(function (result) {
/******/ 				if (result.dispose) result.dispose();
/******/ 			});
/******/ 		
/******/ 			// Now in "apply" phase
/******/ 			var applyPromise = setStatus("apply");
/******/ 		
/******/ 			var error;
/******/ 			var reportError = function (err) {
/******/ 				if (!error) error = err;
/******/ 			};
/******/ 		
/******/ 			var outdatedModules = [];
/******/ 			results.forEach(function (result) {
/******/ 				if (result.apply) {
/******/ 					var modules = result.apply(reportError);
/******/ 					if (modules) {
/******/ 						for (var i = 0; i < modules.length; i++) {
/******/ 							outdatedModules.push(modules[i]);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 			});
/******/ 		
/******/ 			return Promise.all([disposePromise, applyPromise]).then(function () {
/******/ 				// handle errors in accept handlers and self accepted module load
/******/ 				if (error) {
/******/ 					return setStatus("fail").then(function () {
/******/ 						throw error;
/******/ 					});
/******/ 				}
/******/ 		
/******/ 				if (queuedInvalidatedModules) {
/******/ 					return internalApply(options).then(function (list) {
/******/ 						outdatedModules.forEach(function (moduleId) {
/******/ 							if (list.indexOf(moduleId) < 0) list.push(moduleId);
/******/ 						});
/******/ 						return list;
/******/ 					});
/******/ 				}
/******/ 		
/******/ 				return setStatus("idle").then(function () {
/******/ 					return outdatedModules;
/******/ 				});
/******/ 			});
/******/ 		}
/******/ 		
/******/ 		function applyInvalidatedModules() {
/******/ 			if (queuedInvalidatedModules) {
/******/ 				if (!currentUpdateApplyHandlers) currentUpdateApplyHandlers = [];
/******/ 				Object.keys(__webpack_require__.hmrI).forEach(function (key) {
/******/ 					queuedInvalidatedModules.forEach(function (moduleId) {
/******/ 						__webpack_require__.hmrI[key](
/******/ 							moduleId,
/******/ 							currentUpdateApplyHandlers
/******/ 						);
/******/ 					});
/******/ 				});
/******/ 				queuedInvalidatedModules = undefined;
/******/ 				return true;
/******/ 			}
/******/ 		}
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src;
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) {
/******/ 					var i = scripts.length - 1;
/******/ 					while (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		__webpack_require__.b = document.baseURI || self.location.href;
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = __webpack_require__.hmrS_jsonp = __webpack_require__.hmrS_jsonp || {
/******/ 			"main": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		var currentUpdatedModulesList;
/******/ 		var waitingUpdateResolves = {};
/******/ 		function loadUpdateChunk(chunkId, updatedModulesList) {
/******/ 			currentUpdatedModulesList = updatedModulesList;
/******/ 			return new Promise((resolve, reject) => {
/******/ 				waitingUpdateResolves[chunkId] = resolve;
/******/ 				// start update chunk loading
/******/ 				var url = __webpack_require__.p + __webpack_require__.hu(chunkId);
/******/ 				// create error before stack unwound to get useful stacktrace later
/******/ 				var error = new Error();
/******/ 				var loadingEnded = (event) => {
/******/ 					if(waitingUpdateResolves[chunkId]) {
/******/ 						waitingUpdateResolves[chunkId] = undefined
/******/ 						var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 						var realSrc = event && event.target && event.target.src;
/******/ 						error.message = 'Loading hot update chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 						error.name = 'ChunkLoadError';
/******/ 						error.type = errorType;
/******/ 						error.request = realSrc;
/******/ 						reject(error);
/******/ 					}
/******/ 				};
/******/ 				__webpack_require__.l(url, loadingEnded);
/******/ 			});
/******/ 		}
/******/ 		
/******/ 		self["webpackHotUpdateflask_preact_typescript_tailwind_template"] = (chunkId, moreModules, runtime) => {
/******/ 			for(var moduleId in moreModules) {
/******/ 				if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 					currentUpdate[moduleId] = moreModules[moduleId];
/******/ 					if(currentUpdatedModulesList) currentUpdatedModulesList.push(moduleId);
/******/ 				}
/******/ 			}
/******/ 			if(runtime) currentUpdateRuntime.push(runtime);
/******/ 			if(waitingUpdateResolves[chunkId]) {
/******/ 				waitingUpdateResolves[chunkId]();
/******/ 				waitingUpdateResolves[chunkId] = undefined;
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		var currentUpdateChunks;
/******/ 		var currentUpdate;
/******/ 		var currentUpdateRemovedChunks;
/******/ 		var currentUpdateRuntime;
/******/ 		function applyHandler(options) {
/******/ 			if (__webpack_require__.f) delete __webpack_require__.f.jsonpHmr;
/******/ 			currentUpdateChunks = undefined;
/******/ 			function getAffectedModuleEffects(updateModuleId) {
/******/ 				var outdatedModules = [updateModuleId];
/******/ 				var outdatedDependencies = {};
/******/ 		
/******/ 				var queue = outdatedModules.map(function (id) {
/******/ 					return {
/******/ 						chain: [id],
/******/ 						id: id
/******/ 					};
/******/ 				});
/******/ 				while (queue.length > 0) {
/******/ 					var queueItem = queue.pop();
/******/ 					var moduleId = queueItem.id;
/******/ 					var chain = queueItem.chain;
/******/ 					var module = __webpack_require__.c[moduleId];
/******/ 					if (
/******/ 						!module ||
/******/ 						(module.hot._selfAccepted && !module.hot._selfInvalidated)
/******/ 					)
/******/ 						continue;
/******/ 					if (module.hot._selfDeclined) {
/******/ 						return {
/******/ 							type: "self-declined",
/******/ 							chain: chain,
/******/ 							moduleId: moduleId
/******/ 						};
/******/ 					}
/******/ 					if (module.hot._main) {
/******/ 						return {
/******/ 							type: "unaccepted",
/******/ 							chain: chain,
/******/ 							moduleId: moduleId
/******/ 						};
/******/ 					}
/******/ 					for (var i = 0; i < module.parents.length; i++) {
/******/ 						var parentId = module.parents[i];
/******/ 						var parent = __webpack_require__.c[parentId];
/******/ 						if (!parent) continue;
/******/ 						if (parent.hot._declinedDependencies[moduleId]) {
/******/ 							return {
/******/ 								type: "declined",
/******/ 								chain: chain.concat([parentId]),
/******/ 								moduleId: moduleId,
/******/ 								parentId: parentId
/******/ 							};
/******/ 						}
/******/ 						if (outdatedModules.indexOf(parentId) !== -1) continue;
/******/ 						if (parent.hot._acceptedDependencies[moduleId]) {
/******/ 							if (!outdatedDependencies[parentId])
/******/ 								outdatedDependencies[parentId] = [];
/******/ 							addAllToSet(outdatedDependencies[parentId], [moduleId]);
/******/ 							continue;
/******/ 						}
/******/ 						delete outdatedDependencies[parentId];
/******/ 						outdatedModules.push(parentId);
/******/ 						queue.push({
/******/ 							chain: chain.concat([parentId]),
/******/ 							id: parentId
/******/ 						});
/******/ 					}
/******/ 				}
/******/ 		
/******/ 				return {
/******/ 					type: "accepted",
/******/ 					moduleId: updateModuleId,
/******/ 					outdatedModules: outdatedModules,
/******/ 					outdatedDependencies: outdatedDependencies
/******/ 				};
/******/ 			}
/******/ 		
/******/ 			function addAllToSet(a, b) {
/******/ 				for (var i = 0; i < b.length; i++) {
/******/ 					var item = b[i];
/******/ 					if (a.indexOf(item) === -1) a.push(item);
/******/ 				}
/******/ 			}
/******/ 		
/******/ 			// at begin all updates modules are outdated
/******/ 			// the "outdated" status can propagate to parents if they don't accept the children
/******/ 			var outdatedDependencies = {};
/******/ 			var outdatedModules = [];
/******/ 			var appliedUpdate = {};
/******/ 		
/******/ 			var warnUnexpectedRequire = function warnUnexpectedRequire(module) {
/******/ 				console.warn(
/******/ 					"[HMR] unexpected require(" + module.id + ") to disposed module"
/******/ 				);
/******/ 			};
/******/ 		
/******/ 			for (var moduleId in currentUpdate) {
/******/ 				if (__webpack_require__.o(currentUpdate, moduleId)) {
/******/ 					var newModuleFactory = currentUpdate[moduleId];
/******/ 					/** @type {TODO} */
/******/ 					var result;
/******/ 					if (newModuleFactory) {
/******/ 						result = getAffectedModuleEffects(moduleId);
/******/ 					} else {
/******/ 						result = {
/******/ 							type: "disposed",
/******/ 							moduleId: moduleId
/******/ 						};
/******/ 					}
/******/ 					/** @type {Error|false} */
/******/ 					var abortError = false;
/******/ 					var doApply = false;
/******/ 					var doDispose = false;
/******/ 					var chainInfo = "";
/******/ 					if (result.chain) {
/******/ 						chainInfo = "\nUpdate propagation: " + result.chain.join(" -> ");
/******/ 					}
/******/ 					switch (result.type) {
/******/ 						case "self-declined":
/******/ 							if (options.onDeclined) options.onDeclined(result);
/******/ 							if (!options.ignoreDeclined)
/******/ 								abortError = new Error(
/******/ 									"Aborted because of self decline: " +
/******/ 										result.moduleId +
/******/ 										chainInfo
/******/ 								);
/******/ 							break;
/******/ 						case "declined":
/******/ 							if (options.onDeclined) options.onDeclined(result);
/******/ 							if (!options.ignoreDeclined)
/******/ 								abortError = new Error(
/******/ 									"Aborted because of declined dependency: " +
/******/ 										result.moduleId +
/******/ 										" in " +
/******/ 										result.parentId +
/******/ 										chainInfo
/******/ 								);
/******/ 							break;
/******/ 						case "unaccepted":
/******/ 							if (options.onUnaccepted) options.onUnaccepted(result);
/******/ 							if (!options.ignoreUnaccepted)
/******/ 								abortError = new Error(
/******/ 									"Aborted because " + moduleId + " is not accepted" + chainInfo
/******/ 								);
/******/ 							break;
/******/ 						case "accepted":
/******/ 							if (options.onAccepted) options.onAccepted(result);
/******/ 							doApply = true;
/******/ 							break;
/******/ 						case "disposed":
/******/ 							if (options.onDisposed) options.onDisposed(result);
/******/ 							doDispose = true;
/******/ 							break;
/******/ 						default:
/******/ 							throw new Error("Unexception type " + result.type);
/******/ 					}
/******/ 					if (abortError) {
/******/ 						return {
/******/ 							error: abortError
/******/ 						};
/******/ 					}
/******/ 					if (doApply) {
/******/ 						appliedUpdate[moduleId] = newModuleFactory;
/******/ 						addAllToSet(outdatedModules, result.outdatedModules);
/******/ 						for (moduleId in result.outdatedDependencies) {
/******/ 							if (__webpack_require__.o(result.outdatedDependencies, moduleId)) {
/******/ 								if (!outdatedDependencies[moduleId])
/******/ 									outdatedDependencies[moduleId] = [];
/******/ 								addAllToSet(
/******/ 									outdatedDependencies[moduleId],
/******/ 									result.outdatedDependencies[moduleId]
/******/ 								);
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 					if (doDispose) {
/******/ 						addAllToSet(outdatedModules, [result.moduleId]);
/******/ 						appliedUpdate[moduleId] = warnUnexpectedRequire;
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 			currentUpdate = undefined;
/******/ 		
/******/ 			// Store self accepted outdated modules to require them later by the module system
/******/ 			var outdatedSelfAcceptedModules = [];
/******/ 			for (var j = 0; j < outdatedModules.length; j++) {
/******/ 				var outdatedModuleId = outdatedModules[j];
/******/ 				var module = __webpack_require__.c[outdatedModuleId];
/******/ 				if (
/******/ 					module &&
/******/ 					(module.hot._selfAccepted || module.hot._main) &&
/******/ 					// removed self-accepted modules should not be required
/******/ 					appliedUpdate[outdatedModuleId] !== warnUnexpectedRequire &&
/******/ 					// when called invalidate self-accepting is not possible
/******/ 					!module.hot._selfInvalidated
/******/ 				) {
/******/ 					outdatedSelfAcceptedModules.push({
/******/ 						module: outdatedModuleId,
/******/ 						require: module.hot._requireSelf,
/******/ 						errorHandler: module.hot._selfAccepted
/******/ 					});
/******/ 				}
/******/ 			}
/******/ 		
/******/ 			var moduleOutdatedDependencies;
/******/ 		
/******/ 			return {
/******/ 				dispose: function () {
/******/ 					currentUpdateRemovedChunks.forEach(function (chunkId) {
/******/ 						delete installedChunks[chunkId];
/******/ 					});
/******/ 					currentUpdateRemovedChunks = undefined;
/******/ 		
/******/ 					var idx;
/******/ 					var queue = outdatedModules.slice();
/******/ 					while (queue.length > 0) {
/******/ 						var moduleId = queue.pop();
/******/ 						var module = __webpack_require__.c[moduleId];
/******/ 						if (!module) continue;
/******/ 		
/******/ 						var data = {};
/******/ 		
/******/ 						// Call dispose handlers
/******/ 						var disposeHandlers = module.hot._disposeHandlers;
/******/ 						for (j = 0; j < disposeHandlers.length; j++) {
/******/ 							disposeHandlers[j].call(null, data);
/******/ 						}
/******/ 						__webpack_require__.hmrD[moduleId] = data;
/******/ 		
/******/ 						// disable module (this disables requires from this module)
/******/ 						module.hot.active = false;
/******/ 		
/******/ 						// remove module from cache
/******/ 						delete __webpack_require__.c[moduleId];
/******/ 		
/******/ 						// when disposing there is no need to call dispose handler
/******/ 						delete outdatedDependencies[moduleId];
/******/ 		
/******/ 						// remove "parents" references from all children
/******/ 						for (j = 0; j < module.children.length; j++) {
/******/ 							var child = __webpack_require__.c[module.children[j]];
/******/ 							if (!child) continue;
/******/ 							idx = child.parents.indexOf(moduleId);
/******/ 							if (idx >= 0) {
/******/ 								child.parents.splice(idx, 1);
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					// remove outdated dependency from module children
/******/ 					var dependency;
/******/ 					for (var outdatedModuleId in outdatedDependencies) {
/******/ 						if (__webpack_require__.o(outdatedDependencies, outdatedModuleId)) {
/******/ 							module = __webpack_require__.c[outdatedModuleId];
/******/ 							if (module) {
/******/ 								moduleOutdatedDependencies =
/******/ 									outdatedDependencies[outdatedModuleId];
/******/ 								for (j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 									dependency = moduleOutdatedDependencies[j];
/******/ 									idx = module.children.indexOf(dependency);
/******/ 									if (idx >= 0) module.children.splice(idx, 1);
/******/ 								}
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 				},
/******/ 				apply: function (reportError) {
/******/ 					// insert new code
/******/ 					for (var updateModuleId in appliedUpdate) {
/******/ 						if (__webpack_require__.o(appliedUpdate, updateModuleId)) {
/******/ 							__webpack_require__.m[updateModuleId] = appliedUpdate[updateModuleId];
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					// run new runtime modules
/******/ 					for (var i = 0; i < currentUpdateRuntime.length; i++) {
/******/ 						currentUpdateRuntime[i](__webpack_require__);
/******/ 					}
/******/ 		
/******/ 					// call accept handlers
/******/ 					for (var outdatedModuleId in outdatedDependencies) {
/******/ 						if (__webpack_require__.o(outdatedDependencies, outdatedModuleId)) {
/******/ 							var module = __webpack_require__.c[outdatedModuleId];
/******/ 							if (module) {
/******/ 								moduleOutdatedDependencies =
/******/ 									outdatedDependencies[outdatedModuleId];
/******/ 								var callbacks = [];
/******/ 								var errorHandlers = [];
/******/ 								var dependenciesForCallbacks = [];
/******/ 								for (var j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 									var dependency = moduleOutdatedDependencies[j];
/******/ 									var acceptCallback =
/******/ 										module.hot._acceptedDependencies[dependency];
/******/ 									var errorHandler =
/******/ 										module.hot._acceptedErrorHandlers[dependency];
/******/ 									if (acceptCallback) {
/******/ 										if (callbacks.indexOf(acceptCallback) !== -1) continue;
/******/ 										callbacks.push(acceptCallback);
/******/ 										errorHandlers.push(errorHandler);
/******/ 										dependenciesForCallbacks.push(dependency);
/******/ 									}
/******/ 								}
/******/ 								for (var k = 0; k < callbacks.length; k++) {
/******/ 									try {
/******/ 										callbacks[k].call(null, moduleOutdatedDependencies);
/******/ 									} catch (err) {
/******/ 										if (typeof errorHandlers[k] === "function") {
/******/ 											try {
/******/ 												errorHandlers[k](err, {
/******/ 													moduleId: outdatedModuleId,
/******/ 													dependencyId: dependenciesForCallbacks[k]
/******/ 												});
/******/ 											} catch (err2) {
/******/ 												if (options.onErrored) {
/******/ 													options.onErrored({
/******/ 														type: "accept-error-handler-errored",
/******/ 														moduleId: outdatedModuleId,
/******/ 														dependencyId: dependenciesForCallbacks[k],
/******/ 														error: err2,
/******/ 														originalError: err
/******/ 													});
/******/ 												}
/******/ 												if (!options.ignoreErrored) {
/******/ 													reportError(err2);
/******/ 													reportError(err);
/******/ 												}
/******/ 											}
/******/ 										} else {
/******/ 											if (options.onErrored) {
/******/ 												options.onErrored({
/******/ 													type: "accept-errored",
/******/ 													moduleId: outdatedModuleId,
/******/ 													dependencyId: dependenciesForCallbacks[k],
/******/ 													error: err
/******/ 												});
/******/ 											}
/******/ 											if (!options.ignoreErrored) {
/******/ 												reportError(err);
/******/ 											}
/******/ 										}
/******/ 									}
/******/ 								}
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					// Load self accepted modules
/******/ 					for (var o = 0; o < outdatedSelfAcceptedModules.length; o++) {
/******/ 						var item = outdatedSelfAcceptedModules[o];
/******/ 						var moduleId = item.module;
/******/ 						try {
/******/ 							item.require(moduleId);
/******/ 						} catch (err) {
/******/ 							if (typeof item.errorHandler === "function") {
/******/ 								try {
/******/ 									item.errorHandler(err, {
/******/ 										moduleId: moduleId,
/******/ 										module: __webpack_require__.c[moduleId]
/******/ 									});
/******/ 								} catch (err2) {
/******/ 									if (options.onErrored) {
/******/ 										options.onErrored({
/******/ 											type: "self-accept-error-handler-errored",
/******/ 											moduleId: moduleId,
/******/ 											error: err2,
/******/ 											originalError: err
/******/ 										});
/******/ 									}
/******/ 									if (!options.ignoreErrored) {
/******/ 										reportError(err2);
/******/ 										reportError(err);
/******/ 									}
/******/ 								}
/******/ 							} else {
/******/ 								if (options.onErrored) {
/******/ 									options.onErrored({
/******/ 										type: "self-accept-errored",
/******/ 										moduleId: moduleId,
/******/ 										error: err
/******/ 									});
/******/ 								}
/******/ 								if (!options.ignoreErrored) {
/******/ 									reportError(err);
/******/ 								}
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					return outdatedModules;
/******/ 				}
/******/ 			};
/******/ 		}
/******/ 		__webpack_require__.hmrI.jsonp = function (moduleId, applyHandlers) {
/******/ 			if (!currentUpdate) {
/******/ 				currentUpdate = {};
/******/ 				currentUpdateRuntime = [];
/******/ 				currentUpdateRemovedChunks = [];
/******/ 				applyHandlers.push(applyHandler);
/******/ 			}
/******/ 			if (!__webpack_require__.o(currentUpdate, moduleId)) {
/******/ 				currentUpdate[moduleId] = __webpack_require__.m[moduleId];
/******/ 			}
/******/ 		};
/******/ 		__webpack_require__.hmrC.jsonp = function (
/******/ 			chunkIds,
/******/ 			removedChunks,
/******/ 			removedModules,
/******/ 			promises,
/******/ 			applyHandlers,
/******/ 			updatedModulesList
/******/ 		) {
/******/ 			applyHandlers.push(applyHandler);
/******/ 			currentUpdateChunks = {};
/******/ 			currentUpdateRemovedChunks = removedChunks;
/******/ 			currentUpdate = removedModules.reduce(function (obj, key) {
/******/ 				obj[key] = false;
/******/ 				return obj;
/******/ 			}, {});
/******/ 			currentUpdateRuntime = [];
/******/ 			chunkIds.forEach(function (chunkId) {
/******/ 				if (
/******/ 					__webpack_require__.o(installedChunks, chunkId) &&
/******/ 					installedChunks[chunkId] !== undefined
/******/ 				) {
/******/ 					promises.push(loadUpdateChunk(chunkId, updatedModulesList));
/******/ 					currentUpdateChunks[chunkId] = true;
/******/ 				} else {
/******/ 					currentUpdateChunks[chunkId] = false;
/******/ 				}
/******/ 			});
/******/ 			if (__webpack_require__.f) {
/******/ 				__webpack_require__.f.jsonpHmr = function (chunkId, promises) {
/******/ 					if (
/******/ 						currentUpdateChunks &&
/******/ 						__webpack_require__.o(currentUpdateChunks, chunkId) &&
/******/ 						!currentUpdateChunks[chunkId]
/******/ 					) {
/******/ 						promises.push(loadUpdateChunk(chunkId));
/******/ 						currentUpdateChunks[chunkId] = true;
/******/ 					}
/******/ 				};
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.hmrM = () => {
/******/ 			if (typeof fetch === "undefined") throw new Error("No browser support: need fetch API");
/******/ 			return fetch(__webpack_require__.p + __webpack_require__.hmrF()).then((response) => {
/******/ 				if(response.status === 404) return; // no update available
/******/ 				if(!response.ok) throw new Error("Failed to fetch update manifest " + response.statusText);
/******/ 				return response.json();
/******/ 			});
/******/ 		};
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// no jsonp function
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// module cache are used so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	var __webpack_exports__ = __webpack_require__("./app/static/pages/layout.tsx");
/******/ 	
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxHQUFHOztBQUVOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUNBQXlDOztBQUV6QywyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRyxHQUFHOztBQUVOO0FBQ0EscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUcsR0FBRzs7QUFFTjtBQUNBLDZDQUE2Qzs7QUFFN0M7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxHQUFHOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDLEdBQUc7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QscURBQXFEO0FBQ3JEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0NBQXNDOztBQUV0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHdCQUF3QjtBQUNoQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw2QkFBNkI7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQSxtQkFBbUIsdUJBQXVCO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDZCQUE2Qjs7QUFFdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxPQUFPO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpSUFBaUkseUNBQXlDLFFBQVE7QUFDbEw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFNBQVM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0MsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsSUFBSTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsT0FBTztBQUNwRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFFBQVE7O0FBRXhELHVDQUF1QyxRQUFRLHNEQUFzRCxRQUFROztBQUU3RztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7OztBQUdSOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsUUFBUTtBQUNSO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsK0NBQStDOzs7QUFHL0M7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkM7QUFDM0M7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw4QkFBOEI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHVCQUF1QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDJCQUEyQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxPQUFPO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNB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Q2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxrQkFBa0I7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSxrQ0FBa0MscURBQXFEO0FBQ3ZGLFFBQVEsb0RBQW9EO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDREQUE0RDtBQUN2RSxZQUFZLDJEQUEyRDtBQUN2RSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxXQUFXLG9FQUFvRTtBQUMvRSxZQUFZLG1FQUFtRTtBQUMvRSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQyxvQkFBb0IsYUFBYTtBQUNqQyxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Qsa0JBQWtCLFFBQVE7QUFDMUIsa0JBQWtCLFFBQVE7QUFDMUIsa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGtDQUFrQyw4RUFBOEU7QUFDaEgsWUFBWSw4RUFBOEU7QUFDMUYsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsK0JBQStCLDhFQUE4RTtBQUM3RyxZQUFZLDhFQUE4RTtBQUMxRixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBLEtBQUs7QUFDTDtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG9EQUFvRDtBQUNqRSxVQUFVLG9EQUFvRDtBQUM5RDtBQUNBLGNBQWM7QUFDZCxNQUFNLDJDQUEyQyxNQUFNLGdDQUFnQztBQUN2RixVQUFVLCtCQUErQjtBQUN6QyxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHFGQUFxRjtBQUN0RyxnQkFBZ0IscUZBQXFGO0FBQ3JHLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRLHdDQUF3QyxxRkFBcUYseUNBQXlDLHFGQUFxRjtBQUNoUixjQUFjO0FBQ2Q7QUFDQTtBQUNBLE9BQU8sMENBQTBDLE9BQU8seUJBQXlCO0FBQ2pGLE9BQU8sdUNBQXVDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTywwQ0FBMEMsRUFBRSx3QkFBd0I7QUFDM0UsT0FBTyx1Q0FBdUM7QUFDOUM7QUFDQTtBQUNBLGNBQWMsZUFBZTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQyxRQUFRO0FBQ1IsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHFEQUFxRDtBQUMzRixZQUFZLG9EQUFvRDtBQUNoRSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLFlBQVkseUNBQXlDO0FBQ3JELGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVUseUJBQXlCLGVBQWU7QUFDL0Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLFFBQVE7QUFDckIsYUFBYSxXQUFXLG9EQUFvRCxrQ0FBa0MsaUJBQWlCLGtDQUFrQztBQUNqSztBQUNBLGNBQWM7QUFDZCxNQUFNLHlDQUF5QyxnRUFBZ0U7QUFDL0csVUFBVSx5Q0FBeUMseUJBQXlCLDBCQUEwQjtBQUN0RyxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWM7QUFDZCxNQUFNLDJDQUEyQyxNQUFNLHdCQUF3QjtBQUMvRSxVQUFVLDRDQUE0Qyx1QkFBdUI7QUFDN0U7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG9DQUFvQztBQUNqRCxVQUFVLG9DQUFvQztBQUM5QztBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx1Q0FBdUM7QUFDbkQsVUFBVSxzQ0FBc0M7QUFDaEQ7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFVBQVUsYUFBYTtBQUN2QixhQUFhLE9BQU87QUFDcEIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVEsYUFBYSwrRkFBK0YsVUFBVTtBQUMzSSxVQUFVLDhDQUE4QyxHQUFHLCtGQUErRjtBQUMxSixhQUFhLFdBQVcscUVBQXFFLGtDQUFrQyxpQkFBaUIsa0NBQWtDO0FBQ2xMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxPQUFPLHdDQUF3QyxpRUFBaUUseUJBQXlCO0FBQ3pJLE9BQU8sMENBQTBDLE9BQU8seUJBQXlCO0FBQ2pGLE9BQU8sdUNBQXVDO0FBQzlDLE9BQU8scUNBQXFDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyx3Q0FBd0MsMEJBQTBCLDBCQUEwQjtBQUNuRyxPQUFPLDBDQUEwQyxFQUFFLHdCQUF3QjtBQUMzRSxPQUFPLHVDQUF1QztBQUM5QyxPQUFPLHFDQUFxQztBQUM1QztBQUNBO0FBQ0EsY0FBYyxlQUFlO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLE9BQU8sbUJBQW1CLGFBQWEsZ0VBQWdFLFlBQVk7QUFDaEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLFVBQVUsYUFBYTtBQUN2QixpQ0FBaUM7QUFDakMsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0EsTUFBTSxlQUFlO0FBQ3JCLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLFdBQVcsY0FBYztBQUN6QixVQUFVLGFBQWE7QUFDdkIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVEsYUFBYSwrRkFBK0YsVUFBVTtBQUMzSSxVQUFVLDhDQUE4QyxHQUFHLCtGQUErRjtBQUMxSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsT0FBTyx3Q0FBd0MsaUVBQWlFLHlCQUF5QjtBQUN6SSxPQUFPLDBDQUEwQyxPQUFPLHlCQUF5QjtBQUNqRixPQUFPLHVDQUF1QztBQUM5QyxPQUFPLHFDQUFxQztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sd0NBQXdDLDBCQUEwQiwwQkFBMEI7QUFDbkcsT0FBTywwQ0FBMEMsRUFBRSx3QkFBd0I7QUFDM0UsT0FBTyx1Q0FBdUM7QUFDOUMsT0FBTyxxQ0FBcUM7QUFDNUM7QUFDQTtBQUNBLGNBQWMsZUFBZTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0EsTUFBTSxlQUFlO0FBQ3JCLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYztBQUNkLE1BQU0sMkNBQTJDLE1BQU0sd0JBQXdCO0FBQy9FLFVBQVUsNENBQTRDLHVCQUF1QjtBQUM3RTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsVUFBVSxhQUFhO0FBQ3ZCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRLGFBQWEsK0ZBQStGLFVBQVU7QUFDM0ksVUFBVSw4Q0FBOEMsR0FBRywrRkFBK0Y7QUFDMUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLE9BQU8sd0NBQXdDLGlFQUFpRSx5QkFBeUI7QUFDekksT0FBTywwQ0FBMEMsT0FBTyx5QkFBeUI7QUFDakYsT0FBTyx1Q0FBdUM7QUFDOUMsT0FBTyxxQ0FBcUM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLHdDQUF3QywwQkFBMEIsMEJBQTBCO0FBQ25HLE9BQU8sMENBQTBDLEVBQUUsd0JBQXdCO0FBQzNFLE9BQU8sdUNBQXVDO0FBQzlDLE9BQU8scUNBQXFDO0FBQzVDO0FBQ0E7QUFDQSxjQUFjLGVBQWU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSxNQUFNLGVBQWU7QUFDckIsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxvQ0FBb0M7QUFDakQsVUFBVSxvQ0FBb0M7QUFDOUM7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFVBQVUsYUFBYTtBQUN2QixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUSxhQUFhLCtGQUErRixVQUFVO0FBQzNJLFVBQVUsOENBQThDLEdBQUcsK0ZBQStGO0FBQzFKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxPQUFPLHdDQUF3QyxpRUFBaUUseUJBQXlCO0FBQ3pJLE9BQU8sMENBQTBDLE9BQU8seUJBQXlCO0FBQ2pGLE9BQU8sdUNBQXVDO0FBQzlDLE9BQU8scUNBQXFDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyx3Q0FBd0MsMEJBQTBCLDBCQUEwQjtBQUNuRyxPQUFPLDBDQUEwQyxFQUFFLHdCQUF3QjtBQUMzRSxPQUFPLHVDQUF1QztBQUM5QyxPQUFPLHFDQUFxQztBQUM1QztBQUNBO0FBQ0EsY0FBYyxlQUFlO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDRCQUE0QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSxNQUFNLGNBQWM7QUFDcEIsa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsNEJBQTRCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwwQkFBMEI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7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LEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssSUFBSTtBQUNUO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxJQUFJO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxJQUFJO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxJQUFJO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxPQUFPO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEhBQTRILGNBQWM7QUFDMUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlJQUFpSSx5Q0FBeUMsUUFBUTtBQUNsTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLE9BQU87QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQixpQ0FBaUM7QUFDakMsZ0NBQWdDO0FBQ2hDLDhCQUE4QjtBQUM5Qiw0QkFBNEI7QUFDNUIsOEJBQThCO0FBQzlCLHlCQUF5QjtBQUN6Qiw0QkFBNEI7QUFDNUIsK0JBQStCO0FBQy9CLDRCQUE0QjtBQUM1QixnQ0FBZ0M7QUFDaEMsNkJBQTZCO0FBQzdCLDJCQUEyQjtBQUMzQiw4QkFBOEI7QUFDOUIsa0NBQWtDO0FBQ2xDLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLGFBQWE7QUFDYjtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlEQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esd0JBQXdCLHFEQUFhLENBQUMsNENBQVE7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUMsQ0FBQyw2Q0FBVzs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSx3QkFBd0IscURBQWEsQ0FBQyw0Q0FBUTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxDQUFDLDZDQUFXOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLCtFQUErRTtBQUMvRTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLFdBQVcscURBQWEsd0JBQXdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxHQUFHLHFEQUFhO0FBQ3JCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGlEQUFTO0FBQ3RCLEtBQUs7QUFDTCxhQUFhLGlEQUFTO0FBQ3RCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7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RUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixtQ0FBbUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG1DQUFtQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sZ0dBQWdHLFlBQVksTUFBTSxPQUFPLHFCQUFxQixvQkFBb0IscUJBQXFCLHFCQUFxQixNQUFNLE1BQU0sV0FBVyxNQUFNLFlBQVksTUFBTSxNQUFNLHFCQUFxQixxQkFBcUIscUJBQXFCLFVBQVUsb0JBQW9CLHFCQUFxQixxQkFBcUIscUJBQXFCLHFCQUFxQixNQUFNLE9BQU8sTUFBTSxLQUFLLG9CQUFvQixxQkFBcUIsTUFBTSxRQUFRLE1BQU0sS0FBSyxvQkFBb0Isb0JBQW9CLHFCQUFxQixNQUFNLE1BQU0sTUFBTSxLQUFLLFdBQVcsV0FBVyxNQUFNLE1BQU0sTUFBTSxVQUFVLFdBQVcsV0FBVyxNQUFNLE1BQU0sTUFBTSxLQUFLLFVBQVUsV0FBVyxNQUFNLE1BQU0sTUFBTSxNQUFNLFdBQVcsTUFBTSxTQUFTLE1BQU0sUUFBUSxxQkFBcUIscUJBQXFCLHFCQUFxQixvQkFBb0IsTUFBTSxNQUFNLE1BQU0sS0FBSyxVQUFVLE1BQU0sTUFBTSxNQUFNLE1BQU0sVUFBVSxVQUFVLFdBQVcsV0FBVyxNQUFNLEtBQUssVUFBVSxNQUFNLEtBQUssVUFBVSxNQUFNLFFBQVEsTUFBTSxLQUFLLG9CQUFvQixxQkFBcUIscUJBQXFCLE1BQU0sUUFBUSxNQUFNLFNBQVMscUJBQXFCLHFCQUFxQixxQkFBcUIsb0JBQW9CLHFCQUFxQixxQkFBcUIscUJBQXFCLG9CQUFvQixvQkFBb0Isb0JBQW9CLE1BQU0sTUFBTSxNQUFNLE1BQU0sV0FBVyxNQUFNLE9BQU8sTUFBTSxRQUFRLHFCQUFxQixxQkFBcUIscUJBQXFCLE1BQU0sTUFBTSxNQUFNLEtBQUssVUFBVSxNQUFNLE1BQU0sTUFBTSxLQUFLLFdBQVcsTUFBTSxNQUFNLE1BQU0sS0FBSyxXQUFXLE1BQU0sTUFBTSxNQUFNLE1BQU0sVUFBVSxNQUFNLE9BQU8sTUFBTSxLQUFLLHFCQUFxQixxQkFBcUIsTUFBTSxNQUFNLE1BQU0sS0FBSyxXQUFXLE1BQU0sT0FBTyxNQUFNLEtBQUsscUJBQXFCLG9CQUFvQixNQUFNLE1BQU0sTUFBTSxLQUFLLFdBQVcsTUFBTSxNQUFNLE1BQU0saUJBQWlCLFVBQVUsTUFBTSxLQUFLLFVBQVUsVUFBVSxNQUFNLEtBQUssVUFBVSxNQUFNLE9BQU8sV0FBVyxVQUFVLFVBQVUsTUFBTSxNQUFNLEtBQUssS0FBSyxVQUFVLE1BQU0sTUFBTSxNQUFNLEtBQUssV0FBVyxNQUFNLE9BQU8sTUFBTSxLQUFLLG9CQUFvQixvQkFBb0IsTUFBTSxNQUFNLG9CQUFvQixvQkFBb0IsTUFBTSxNQUFNLE1BQU0sTUFBTSxVQUFVLE1BQU0sTUFBTSxLQUFLLEtBQUssVUFBVSxNQUFNLFFBQVEsTUFBTSxZQUFZLG9CQUFvQixxQkFBcUIsTUFBTSxNQUFNLE1BQU0sTUFBTSxVQUFVLFVBQVUsTUFBTSxXQUFXLEtBQUssVUFBVSxNQUFNLEtBQUssV0FBVyxXQUFXLFdBQVcsV0FBVyxVQUFVLFVBQVUsVUFBVSxVQUFVLFVBQVUsVUFBVSxVQUFVLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxVQUFVLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFVBQVUsV0FBVyxXQUFXLFdBQVcsV0FBVyxVQUFVLFdBQVcsVUFBVSxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLEtBQUssTUFBTSxLQUFLLFdBQVcsV0FBVyxXQUFXLFdBQVcsVUFBVSxVQUFVLFVBQVUsVUFBVSxVQUFVLFVBQVUsVUFBVSxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsVUFBVSxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxVQUFVLFdBQVcsV0FBVyxXQUFXLFdBQVcsVUFBVSxXQUFXLFVBQVUsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxLQUFLLEtBQUssS0FBSyxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLFdBQVcsTUFBTSxNQUFNLE1BQU0sV0FBVyxNQUFNLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksYUFBYSxNQUFNLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLFlBQVksYUFBYSxhQUFhLGFBQWEsTUFBTSxNQUFNLE1BQU0sWUFBWSxhQUFhLE1BQU0sT0FBTyxNQUFNLFdBQVcsYUFBYSxNQUFNLE9BQU8sT0FBTyxLQUFLLFdBQVcsTUFBTSxNQUFNLE1BQU0sT0FBTyxLQUFLLFdBQVcsTUFBTSxNQUFNLE1BQU0sTUFBTSxXQUFXLGFBQWEsTUFBTSxPQUFPLE9BQU8sS0FBSyxXQUFXLE1BQU0sTUFBTSxNQUFNLE1BQU0sV0FBVyxhQUFhLE1BQU0sT0FBTyxNQUFNLFdBQVcsTUFBTSxPQUFPLE9BQU8sS0FBSyxXQUFXLE1BQU0sTUFBTSxNQUFNLE1BQU0sS0FBSyxPQUFPLE9BQU8sS0FBSyxLQUFLLE1BQU0sTUFBTSxPQUFPLFdBQVcsYUFBYSxhQUFhLE1BQU0sTUFBTSxPQUFPLEtBQUssT0FBTyxNQUFNLFVBQVUsVUFBVSxVQUFVLFlBQVksYUFBYSxXQUFXLE9BQU8sS0FBSyxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxZQUFZLE9BQU8sS0FBSyxZQUFZLFlBQVksWUFBWSxhQUFhLGFBQWEsYUFBYSxNQUFNLE9BQU8sT0FBTyxLQUFLLEtBQUssTUFBTSxNQUFNLE1BQU0sWUFBWSxhQUFhLE1BQU0sT0FBTyxNQUFNLFlBQVksYUFBYSxhQUFhLE1BQU0sT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLFdBQVcsWUFBWSxXQUFXLFlBQVksV0FBVyxVQUFVLFlBQVksTUFBTSxPQUFPLE1BQU0sV0FBVyxZQUFZLE1BQU0sT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLFdBQVcsWUFBWSxNQUFNLE9BQU8sTUFBTSxZQUFZLE1BQU0sT0FBTyxNQUFNLFlBQVksWUFBWSxhQUFhLGFBQWEsT0FBTyxNQUFNLEtBQUssS0FBSyxNQUFNLE1BQU0sTUFBTSxLQUFLLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLFdBQVcsYUFBYSxNQUFNLE1BQU0sT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLFlBQVksTUFBTSxPQUFPLE1BQU0sWUFBWSxNQUFNLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxZQUFZLE1BQU0sT0FBTyxPQUFPLEtBQUssS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sWUFBWSxNQUFNLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxZQUFZLE1BQU0sT0FBTyxNQUFNLFlBQVksTUFBTSxPQUFPLE1BQU0sWUFBWSxNQUFNLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE9BQU8sTUFBTSxLQUFLLE1BQU0sTUFBTSxPQUFPLEtBQUssS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sWUFBWSxNQUFNLE9BQU8sTUFBTSxZQUFZLE1BQU0sT0FBTyxNQUFNLFlBQVksTUFBTSxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxPQUFPLE1BQU0sS0FBSyxNQUFNLE1BQU0sT0FBTyxLQUFLLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssT0FBTyxNQUFNLEtBQUss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LEVBQUU7O1dBRUY7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLElBQUk7V0FDSjs7V0FFQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLEtBQUs7V0FDTDtXQUNBLElBQUk7V0FDSjs7V0FFQTtXQUNBO1dBQ0EsR0FBRztXQUNILEVBQUU7V0FDRjs7V0FFQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxJQUFJO1dBQ0osR0FBRztXQUNIO1dBQ0E7V0FDQTtXQUNBOzs7OztXQ25ZQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTs7Ozs7V0NsQkE7O1dBRUE7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBOztXQUVBOztXQUVBOztXQUVBOztXQUVBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxFQUFFO1dBQ0Y7O1dBRUE7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7O1dBRUE7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7O1dBRUE7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLEdBQUc7V0FDSDtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxtQkFBbUIsMkJBQTJCO1dBQzlDO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dB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Q0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxFQUFFLElBQUk7V0FDTjtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsSUFBSTtXQUNKO1dBQ0E7V0FDQSxFQUFFO1dBQ0Y7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7O1dBRUE7V0FDQTtXQUNBO1dBQ0Esc0NBQXNDO1dBQ3RDO1dBQ0E7V0FDQSxFQUFFO1dBQ0Y7O1dBRUE7O1dBRUE7Ozs7O1dDOWZBOzs7OztVRUFBO1VBQ0E7VUFDQTtVQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZmxhc2stcHJlYWN0LXR5cGVzY3JpcHQtdGFpbHdpbmQtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQGVnanMvcHJlYWN0LWZsaWNraW5nL2Rpc3QvZmxpY2tpbmcuZXNtLmpzIiwid2VicGFjazovL2ZsYXNrLXByZWFjdC10eXBlc2NyaXB0LXRhaWx3aW5kLXRlbXBsYXRlLy4vYXBwL3N0YXRpYy9wYWdlcy9nbG9iYWxzLmNzcyIsIndlYnBhY2s6Ly9mbGFzay1wcmVhY3QtdHlwZXNjcmlwdC10YWlsd2luZC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9AZWdqcy9wcmVhY3QtZmxpY2tpbmcvZGlzdC9mbGlja2luZy5jc3MiLCJ3ZWJwYWNrOi8vZmxhc2stcHJlYWN0LXR5cGVzY3JpcHQtdGFpbHdpbmQtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzIiwid2VicGFjazovL2ZsYXNrLXByZWFjdC10eXBlc2NyaXB0LXRhaWx3aW5kLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2dldFVybC5qcyIsIndlYnBhY2s6Ly9mbGFzay1wcmVhY3QtdHlwZXNjcmlwdC10YWlsd2luZC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9zb3VyY2VNYXBzLmpzIiwid2VicGFjazovL2ZsYXNrLXByZWFjdC10eXBlc2NyaXB0LXRhaWx3aW5kLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ByZWFjdC9kaXN0L3ByZWFjdC5tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vZmxhc2stcHJlYWN0LXR5cGVzY3JpcHQtdGFpbHdpbmQtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvcHJlYWN0L2hvb2tzL2Rpc3QvaG9va3MubW9kdWxlLmpzIiwid2VicGFjazovL2ZsYXNrLXByZWFjdC10eXBlc2NyaXB0LXRhaWx3aW5kLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ByZWFjdC9qc3gtcnVudGltZS9kaXN0L2pzeFJ1bnRpbWUubW9kdWxlLmpzIiwid2VicGFjazovL2ZsYXNrLXByZWFjdC10eXBlc2NyaXB0LXRhaWx3aW5kLXRlbXBsYXRlLy4vYXBwL3N0YXRpYy9wYWdlcy9nbG9iYWxzLmNzcz81NDFmIiwid2VicGFjazovL2ZsYXNrLXByZWFjdC10eXBlc2NyaXB0LXRhaWx3aW5kLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0BlZ2pzL3ByZWFjdC1mbGlja2luZy9kaXN0L2ZsaWNraW5nLmNzcz8zZmM3Iiwid2VicGFjazovL2ZsYXNrLXByZWFjdC10eXBlc2NyaXB0LXRhaWx3aW5kLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzIiwid2VicGFjazovL2ZsYXNrLXByZWFjdC10eXBlc2NyaXB0LXRhaWx3aW5kLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5zZXJ0QnlTZWxlY3Rvci5qcyIsIndlYnBhY2s6Ly9mbGFzay1wcmVhY3QtdHlwZXNjcmlwdC10YWlsd2luZC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydFN0eWxlRWxlbWVudC5qcyIsIndlYnBhY2s6Ly9mbGFzay1wcmVhY3QtdHlwZXNjcmlwdC10YWlsd2luZC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3NldEF0dHJpYnV0ZXNXaXRob3V0QXR0cmlidXRlcy5qcyIsIndlYnBhY2s6Ly9mbGFzay1wcmVhY3QtdHlwZXNjcmlwdC10YWlsd2luZC10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3N0eWxlRG9tQVBJLmpzIiwid2VicGFjazovL2ZsYXNrLXByZWFjdC10eXBlc2NyaXB0LXRhaWx3aW5kLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc3R5bGVUYWdUcmFuc2Zvcm0uanMiLCJ3ZWJwYWNrOi8vZmxhc2stcHJlYWN0LXR5cGVzY3JpcHQtdGFpbHdpbmQtdGVtcGxhdGUvLi9hcHAvc3RhdGljL3BhZ2VzL2NvbXBvbmVudHMvQmxvY2sxLnRzeCIsIndlYnBhY2s6Ly9mbGFzay1wcmVhY3QtdHlwZXNjcmlwdC10YWlsd2luZC10ZW1wbGF0ZS8uL2FwcC9zdGF0aWMvcGFnZXMvY29tcG9uZW50cy9CbG9jazIudHN4Iiwid2VicGFjazovL2ZsYXNrLXByZWFjdC10eXBlc2NyaXB0LXRhaWx3aW5kLXRlbXBsYXRlLy4vYXBwL3N0YXRpYy9wYWdlcy9jb21wb25lbnRzL0Jsb2NrMy50c3giLCJ3ZWJwYWNrOi8vZmxhc2stcHJlYWN0LXR5cGVzY3JpcHQtdGFpbHdpbmQtdGVtcGxhdGUvLi9hcHAvc3RhdGljL3BhZ2VzL2NvbXBvbmVudHMvQmxvY2s0LnRzeCIsIndlYnBhY2s6Ly9mbGFzay1wcmVhY3QtdHlwZXNjcmlwdC10YWlsd2luZC10ZW1wbGF0ZS8uL2FwcC9zdGF0aWMvcGFnZXMvY29tcG9uZW50cy9Gb290ZXIudHN4Iiwid2VicGFjazovL2ZsYXNrLXByZWFjdC10eXBlc2NyaXB0LXRhaWx3aW5kLXRlbXBsYXRlLy4vYXBwL3N0YXRpYy9wYWdlcy9jb21wb25lbnRzL05hdmJhci50c3giLCJ3ZWJwYWNrOi8vZmxhc2stcHJlYWN0LXR5cGVzY3JpcHQtdGFpbHdpbmQtdGVtcGxhdGUvLi9hcHAvc3RhdGljL3BhZ2VzL2xheW91dC50c3giLCJ3ZWJwYWNrOi8vZmxhc2stcHJlYWN0LXR5cGVzY3JpcHQtdGFpbHdpbmQtdGVtcGxhdGUvLi9hcHAvc3RhdGljL3BhZ2VzL3BhZ2UudHN4Iiwid2VicGFjazovL2ZsYXNrLXByZWFjdC10eXBlc2NyaXB0LXRhaWx3aW5kLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL3ByZWFjdC1yb3V0ZXIvZGlzdC9wcmVhY3Qtcm91dGVyLm1qcyIsIndlYnBhY2s6Ly9mbGFzay1wcmVhY3QtdHlwZXNjcmlwdC10YWlsd2luZC10ZW1wbGF0ZS93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9mbGFzay1wcmVhY3QtdHlwZXNjcmlwdC10YWlsd2luZC10ZW1wbGF0ZS93ZWJwYWNrL3J1bnRpbWUvY29tcGF0IGdldCBkZWZhdWx0IGV4cG9ydCIsIndlYnBhY2s6Ly9mbGFzay1wcmVhY3QtdHlwZXNjcmlwdC10YWlsd2luZC10ZW1wbGF0ZS93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vZmxhc2stcHJlYWN0LXR5cGVzY3JpcHQtdGFpbHdpbmQtdGVtcGxhdGUvd2VicGFjay9ydW50aW1lL2dldCBqYXZhc2NyaXB0IHVwZGF0ZSBjaHVuayBmaWxlbmFtZSIsIndlYnBhY2s6Ly9mbGFzay1wcmVhY3QtdHlwZXNjcmlwdC10YWlsd2luZC10ZW1wbGF0ZS93ZWJwYWNrL3J1bnRpbWUvZ2V0IHVwZGF0ZSBtYW5pZmVzdCBmaWxlbmFtZSIsIndlYnBhY2s6Ly9mbGFzay1wcmVhY3QtdHlwZXNjcmlwdC10YWlsd2luZC10ZW1wbGF0ZS93ZWJwYWNrL3J1bnRpbWUvZ2V0RnVsbEhhc2giLCJ3ZWJwYWNrOi8vZmxhc2stcHJlYWN0LXR5cGVzY3JpcHQtdGFpbHdpbmQtdGVtcGxhdGUvd2VicGFjay9ydW50aW1lL2dsb2JhbCIsIndlYnBhY2s6Ly9mbGFzay1wcmVhY3QtdHlwZXNjcmlwdC10YWlsd2luZC10ZW1wbGF0ZS93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovL2ZsYXNrLXByZWFjdC10eXBlc2NyaXB0LXRhaWx3aW5kLXRlbXBsYXRlL3dlYnBhY2svcnVudGltZS9sb2FkIHNjcmlwdCIsIndlYnBhY2s6Ly9mbGFzay1wcmVhY3QtdHlwZXNjcmlwdC10YWlsd2luZC10ZW1wbGF0ZS93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL2ZsYXNrLXByZWFjdC10eXBlc2NyaXB0LXRhaWx3aW5kLXRlbXBsYXRlL3dlYnBhY2svcnVudGltZS9ob3QgbW9kdWxlIHJlcGxhY2VtZW50Iiwid2VicGFjazovL2ZsYXNrLXByZWFjdC10eXBlc2NyaXB0LXRhaWx3aW5kLXRlbXBsYXRlL3dlYnBhY2svcnVudGltZS9wdWJsaWNQYXRoIiwid2VicGFjazovL2ZsYXNrLXByZWFjdC10eXBlc2NyaXB0LXRhaWx3aW5kLXRlbXBsYXRlL3dlYnBhY2svcnVudGltZS9qc29ucCBjaHVuayBsb2FkaW5nIiwid2VicGFjazovL2ZsYXNrLXByZWFjdC10eXBlc2NyaXB0LXRhaWx3aW5kLXRlbXBsYXRlL3dlYnBhY2svcnVudGltZS9ub25jZSIsIndlYnBhY2s6Ly9mbGFzay1wcmVhY3QtdHlwZXNjcmlwdC10YWlsd2luZC10ZW1wbGF0ZS93ZWJwYWNrL2JlZm9yZS1zdGFydHVwIiwid2VicGFjazovL2ZsYXNrLXByZWFjdC10eXBlc2NyaXB0LXRhaWx3aW5kLXRlbXBsYXRlL3dlYnBhY2svc3RhcnR1cCIsIndlYnBhY2s6Ly9mbGFzay1wcmVhY3QtdHlwZXNjcmlwdC10YWlsd2luZC10ZW1wbGF0ZS93ZWJwYWNrL2FmdGVyLXN0YXJ0dXAiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbkNvcHlyaWdodCAoYykgMjAyMS1wcmVzZW50IE5BVkVSIENvcnAuXG5uYW1lOiBAZWdqcy9wcmVhY3QtZmxpY2tpbmdcbmxpY2Vuc2U6IE1JVFxuYXV0aG9yOiBOQVZFUiBDb3JwLlxucmVwb3NpdG9yeTogaHR0cHM6Ly9naXRodWIuY29tL25hdmVyL2VnanMtZmxpY2tpbmcvYmxvYi9tYXN0ZXIvcGFja2FnZXMvcHJlYWN0LWZsaWNraW5nXG52ZXJzaW9uOiA0LjExLjRcbiovXG5pbXBvcnQgeyBvcHRpb25zLCBDb21wb25lbnQgYXMgQ29tcG9uZW50JDEsIGNyZWF0ZUVsZW1lbnQsIEZyYWdtZW50LCB0b0NoaWxkQXJyYXksIGNyZWF0ZUNvbnRleHQsIGNyZWF0ZVJlZiwgcmVuZGVyLCBoeWRyYXRlLCBjbG9uZUVsZW1lbnQgfSBmcm9tICdwcmVhY3QnO1xuXG52YXIgdCx1LHIsbz0wLGk9W10sYz1vcHRpb25zLl9fYixmPW9wdGlvbnMuX19yLGU9b3B0aW9ucy5kaWZmZWQsYT1vcHRpb25zLl9fYyx2PW9wdGlvbnMudW5tb3VudDtmdW5jdGlvbiBtKHQscil7b3B0aW9ucy5fX2gmJm9wdGlvbnMuX19oKHUsdCxvfHxyKSxvPTA7dmFyIGk9dS5fX0h8fCh1Ll9fSD17X186W10sX19oOltdfSk7cmV0dXJuIHQ+PWkuX18ubGVuZ3RoJiZpLl9fLnB1c2goe30pLGkuX19bdF19ZnVuY3Rpb24gbChuKXtyZXR1cm4gbz0xLHAodyxuKX1mdW5jdGlvbiBwKG4scixvKXt2YXIgaT1tKHQrKywyKTtyZXR1cm4gaS50PW4saS5fX2N8fChpLl9fPVtvP28ocik6dyh2b2lkIDAsciksZnVuY3Rpb24obil7dmFyIHQ9aS50KGkuX19bMF0sbik7aS5fX1swXSE9PXQmJihpLl9fPVt0LGkuX19bMV1dLGkuX19jLnNldFN0YXRlKHt9KSk7fV0saS5fX2M9dSksaS5fX31mdW5jdGlvbiB5KHIsbyl7dmFyIGk9bSh0KyssMyk7IW9wdGlvbnMuX19zJiZrKGkuX19ILG8pJiYoaS5fXz1yLGkuX19IPW8sdS5fX0guX19oLnB1c2goaSkpO31mdW5jdGlvbiBoKHIsbyl7dmFyIGk9bSh0KyssNCk7IW9wdGlvbnMuX19zJiZrKGkuX19ILG8pJiYoaS5fXz1yLGkuX19IPW8sdS5fX2gucHVzaChpKSk7fWZ1bmN0aW9uIHMobil7cmV0dXJuIG89NSxkKGZ1bmN0aW9uKCl7cmV0dXJuIHtjdXJyZW50Om59fSxbXSl9ZnVuY3Rpb24gXyhuLHQsdSl7bz02LGgoZnVuY3Rpb24oKXtcImZ1bmN0aW9uXCI9PXR5cGVvZiBuP24odCgpKTpuJiYobi5jdXJyZW50PXQoKSk7fSxudWxsPT11P3U6dS5jb25jYXQobikpO31mdW5jdGlvbiBkKG4sdSl7dmFyIHI9bSh0KyssNyk7cmV0dXJuIGsoci5fX0gsdSkmJihyLl9fPW4oKSxyLl9fSD11LHIuX19oPW4pLHIuX199ZnVuY3Rpb24gQShuLHQpe3JldHVybiBvPTgsZChmdW5jdGlvbigpe3JldHVybiBufSx0KX1mdW5jdGlvbiBGKG4pe3ZhciByPXUuY29udGV4dFtuLl9fY10sbz1tKHQrKyw5KTtyZXR1cm4gby5jPW4scj8obnVsbD09by5fXyYmKG8uX189ITAsci5zdWIodSkpLHIucHJvcHMudmFsdWUpOm4uX199ZnVuY3Rpb24gVCh0LHUpe29wdGlvbnMudXNlRGVidWdWYWx1ZSYmb3B0aW9ucy51c2VEZWJ1Z1ZhbHVlKHU/dSh0KTp0KTt9ZnVuY3Rpb24geCgpe3ZhciB0O2ZvcihpLnNvcnQoZnVuY3Rpb24obix0KXtyZXR1cm4gbi5fX3YuX19iLXQuX192Ll9fYn0pO3Q9aS5wb3AoKTspaWYodC5fX1ApdHJ5e3QuX19ILl9faC5mb3JFYWNoKGcpLHQuX19ILl9faC5mb3JFYWNoKGopLHQuX19ILl9faD1bXTt9Y2F0Y2godSl7dC5fX0guX19oPVtdLG9wdGlvbnMuX19lKHUsdC5fX3YpO319b3B0aW9ucy5fX2I9ZnVuY3Rpb24obil7dT1udWxsLGMmJmMobik7fSxvcHRpb25zLl9fcj1mdW5jdGlvbihuKXtmJiZmKG4pLHQ9MDt2YXIgcj0odT1uLl9fYykuX19IO3ImJihyLl9faC5mb3JFYWNoKGcpLHIuX19oLmZvckVhY2goaiksci5fX2g9W10pO30sb3B0aW9ucy5kaWZmZWQ9ZnVuY3Rpb24odCl7ZSYmZSh0KTt2YXIgbz10Ll9fYztvJiZvLl9fSCYmby5fX0guX19oLmxlbmd0aCYmKDEhPT1pLnB1c2gobykmJnI9PT1vcHRpb25zLnJlcXVlc3RBbmltYXRpb25GcmFtZXx8KChyPW9wdGlvbnMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKXx8ZnVuY3Rpb24obil7dmFyIHQsdT1mdW5jdGlvbigpe2NsZWFyVGltZW91dChyKSxiJiZjYW5jZWxBbmltYXRpb25GcmFtZSh0KSxzZXRUaW1lb3V0KG4pO30scj1zZXRUaW1lb3V0KHUsMTAwKTtiJiYodD1yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodSkpO30pKHgpKSx1PW51bGw7fSxvcHRpb25zLl9fYz1mdW5jdGlvbih0LHUpe3Uuc29tZShmdW5jdGlvbih0KXt0cnl7dC5fX2guZm9yRWFjaChnKSx0Ll9faD10Ll9faC5maWx0ZXIoZnVuY3Rpb24obil7cmV0dXJuICFuLl9ffHxqKG4pfSk7fWNhdGNoKHIpe3Uuc29tZShmdW5jdGlvbihuKXtuLl9faCYmKG4uX19oPVtdKTt9KSx1PVtdLG9wdGlvbnMuX19lKHIsdC5fX3YpO319KSxhJiZhKHQsdSk7fSxvcHRpb25zLnVubW91bnQ9ZnVuY3Rpb24odCl7diYmdih0KTt2YXIgdSxyPXQuX19jO3ImJnIuX19IJiYoci5fX0guX18uZm9yRWFjaChmdW5jdGlvbihuKXt0cnl7ZyhuKTt9Y2F0Y2gobil7dT1uO319KSx1JiZvcHRpb25zLl9fZSh1LHIuX192KSk7fTt2YXIgYj1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWU7ZnVuY3Rpb24gZyhuKXt2YXIgdD11LHI9bi5fX2M7XCJmdW5jdGlvblwiPT10eXBlb2YgciYmKG4uX19jPXZvaWQgMCxyKCkpLHU9dDt9ZnVuY3Rpb24gaihuKXt2YXIgdD11O24uX19jPW4uX18oKSx1PXQ7fWZ1bmN0aW9uIGsobix0KXtyZXR1cm4gIW58fG4ubGVuZ3RoIT09dC5sZW5ndGh8fHQuc29tZShmdW5jdGlvbih0LHUpe3JldHVybiB0IT09blt1XX0pfWZ1bmN0aW9uIHcobix0KXtyZXR1cm4gXCJmdW5jdGlvblwiPT10eXBlb2YgdD90KG4pOnR9XG5cbmZ1bmN0aW9uIFMobix0KXtmb3IodmFyIGUgaW4gdCluW2VdPXRbZV07cmV0dXJuIG59ZnVuY3Rpb24gQyhuLHQpe2Zvcih2YXIgZSBpbiBuKWlmKFwiX19zb3VyY2VcIiE9PWUmJiEoZSBpbiB0KSlyZXR1cm4gITA7Zm9yKHZhciByIGluIHQpaWYoXCJfX3NvdXJjZVwiIT09ciYmbltyXSE9PXRbcl0pcmV0dXJuICEwO3JldHVybiAhMX1mdW5jdGlvbiBFKG4pe3RoaXMucHJvcHM9bjt9ZnVuY3Rpb24gZyQxKG4sdCl7ZnVuY3Rpb24gZShuKXt2YXIgZT10aGlzLnByb3BzLnJlZixyPWU9PW4ucmVmO3JldHVybiAhciYmZSYmKGUuY2FsbD9lKG51bGwpOmUuY3VycmVudD1udWxsKSx0PyF0KHRoaXMucHJvcHMsbil8fCFyOkModGhpcy5wcm9wcyxuKX1mdW5jdGlvbiByKHQpe3JldHVybiB0aGlzLnNob3VsZENvbXBvbmVudFVwZGF0ZT1lLGNyZWF0ZUVsZW1lbnQobix0KX1yZXR1cm4gci5kaXNwbGF5TmFtZT1cIk1lbW8oXCIrKG4uZGlzcGxheU5hbWV8fG4ubmFtZSkrXCIpXCIsci5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudD0hMCxyLl9fZj0hMCxyfShFLnByb3RvdHlwZT1uZXcgQ29tcG9uZW50JDEpLmlzUHVyZVJlYWN0Q29tcG9uZW50PSEwLEUucHJvdG90eXBlLnNob3VsZENvbXBvbmVudFVwZGF0ZT1mdW5jdGlvbihuLHQpe3JldHVybiBDKHRoaXMucHJvcHMsbil8fEModGhpcy5zdGF0ZSx0KX07dmFyIHckMT1vcHRpb25zLl9fYjtvcHRpb25zLl9fYj1mdW5jdGlvbihuKXtuLnR5cGUmJm4udHlwZS5fX2YmJm4ucmVmJiYobi5wcm9wcy5yZWY9bi5yZWYsbi5yZWY9bnVsbCksdyQxJiZ3JDEobik7fTt2YXIgUj1cInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sJiZTeW1ib2wuZm9yJiZTeW1ib2wuZm9yKFwicmVhY3QuZm9yd2FyZF9yZWZcIil8fDM5MTE7ZnVuY3Rpb24geCQxKG4pe2Z1bmN0aW9uIHQodCxlKXt2YXIgcj1TKHt9LHQpO3JldHVybiBkZWxldGUgci5yZWYsbihyLChlPXQucmVmfHxlKSYmKFwib2JqZWN0XCIhPXR5cGVvZiBlfHxcImN1cnJlbnRcImluIGUpP2U6bnVsbCl9cmV0dXJuIHQuJCR0eXBlb2Y9Uix0LnJlbmRlcj10LHQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQ9dC5fX2Y9ITAsdC5kaXNwbGF5TmFtZT1cIkZvcndhcmRSZWYoXCIrKG4uZGlzcGxheU5hbWV8fG4ubmFtZSkrXCIpXCIsdH12YXIgTj1mdW5jdGlvbihuLHQpe3JldHVybiBudWxsPT1uP251bGw6dG9DaGlsZEFycmF5KHRvQ2hpbGRBcnJheShuKS5tYXAodCkpfSxrJDE9e21hcDpOLGZvckVhY2g6Tixjb3VudDpmdW5jdGlvbihuKXtyZXR1cm4gbj90b0NoaWxkQXJyYXkobikubGVuZ3RoOjB9LG9ubHk6ZnVuY3Rpb24obil7dmFyIHQ9dG9DaGlsZEFycmF5KG4pO2lmKDEhPT10Lmxlbmd0aCl0aHJvdyBcIkNoaWxkcmVuLm9ubHlcIjtyZXR1cm4gdFswXX0sdG9BcnJheTp0b0NoaWxkQXJyYXl9LEEkMT1vcHRpb25zLl9fZTtvcHRpb25zLl9fZT1mdW5jdGlvbihuLHQsZSl7aWYobi50aGVuKWZvcih2YXIgcix1PXQ7dT11Ll9fOylpZigocj11Ll9fYykmJnIuX19jKXJldHVybiBudWxsPT10Ll9fZSYmKHQuX19lPWUuX19lLHQuX19rPWUuX19rKSxyLl9fYyhuLHQpO0EkMShuLHQsZSk7fTt2YXIgTz1vcHRpb25zLnVubW91bnQ7ZnVuY3Rpb24gTCgpe3RoaXMuX191PTAsdGhpcy50PW51bGwsdGhpcy5fX2I9bnVsbDt9ZnVuY3Rpb24gVShuKXt2YXIgdD1uLl9fLl9fYztyZXR1cm4gdCYmdC5fX2UmJnQuX19lKG4pfWZ1bmN0aW9uIEYkMShuKXt2YXIgdCxlLHI7ZnVuY3Rpb24gdSh1KXtpZih0fHwodD1uKCkpLnRoZW4oZnVuY3Rpb24obil7ZT1uLmRlZmF1bHR8fG47fSxmdW5jdGlvbihuKXtyPW47fSkscil0aHJvdyByO2lmKCFlKXRocm93IHQ7cmV0dXJuIGNyZWF0ZUVsZW1lbnQoZSx1KX1yZXR1cm4gdS5kaXNwbGF5TmFtZT1cIkxhenlcIix1Ll9fZj0hMCx1fWZ1bmN0aW9uIE0oKXt0aGlzLnU9bnVsbCx0aGlzLm89bnVsbDt9b3B0aW9ucy51bm1vdW50PWZ1bmN0aW9uKG4pe3ZhciB0PW4uX19jO3QmJnQuX19SJiZ0Ll9fUigpLHQmJiEwPT09bi5fX2gmJihuLnR5cGU9bnVsbCksTyYmTyhuKTt9LChMLnByb3RvdHlwZT1uZXcgQ29tcG9uZW50JDEpLl9fYz1mdW5jdGlvbihuLHQpe3ZhciBlPXQuX19jLHI9dGhpcztudWxsPT1yLnQmJihyLnQ9W10pLHIudC5wdXNoKGUpO3ZhciB1PVUoci5fX3YpLG89ITEsaT1mdW5jdGlvbigpe298fChvPSEwLGUuX19SPW51bGwsdT91KGwpOmwoKSk7fTtlLl9fUj1pO3ZhciBsPWZ1bmN0aW9uKCl7aWYoIS0tci5fX3Upe2lmKHIuc3RhdGUuX19lKXt2YXIgbj1yLnN0YXRlLl9fZTtyLl9fdi5fX2tbMF09ZnVuY3Rpb24gbih0LGUscil7cmV0dXJuIHQmJih0Ll9fdj1udWxsLHQuX19rPXQuX19rJiZ0Ll9fay5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIG4odCxlLHIpfSksdC5fX2MmJnQuX19jLl9fUD09PWUmJih0Ll9fZSYmci5pbnNlcnRCZWZvcmUodC5fX2UsdC5fX2QpLHQuX19jLl9fZT0hMCx0Ll9fYy5fX1A9cikpLHR9KG4sbi5fX2MuX19QLG4uX19jLl9fTyk7fXZhciB0O2ZvcihyLnNldFN0YXRlKHtfX2U6ci5fX2I9bnVsbH0pO3Q9ci50LnBvcCgpOyl0LmZvcmNlVXBkYXRlKCk7fX0sYz0hMD09PXQuX19oO3IuX191Kyt8fGN8fHIuc2V0U3RhdGUoe19fZTpyLl9fYj1yLl9fdi5fX2tbMF19KSxuLnRoZW4oaSxpKTt9LEwucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50PWZ1bmN0aW9uKCl7dGhpcy50PVtdO30sTC5wcm90b3R5cGUucmVuZGVyPWZ1bmN0aW9uKG4sdCl7aWYodGhpcy5fX2Ipe2lmKHRoaXMuX192Ll9fayl7dmFyIGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSxyPXRoaXMuX192Ll9fa1swXS5fX2M7dGhpcy5fX3YuX19rWzBdPWZ1bmN0aW9uIG4odCxlLHIpe3JldHVybiB0JiYodC5fX2MmJnQuX19jLl9fSCYmKHQuX19jLl9fSC5fXy5mb3JFYWNoKGZ1bmN0aW9uKG4pe1wiZnVuY3Rpb25cIj09dHlwZW9mIG4uX19jJiZuLl9fYygpO30pLHQuX19jLl9fSD1udWxsKSxudWxsIT0odD1TKHt9LHQpKS5fX2MmJih0Ll9fYy5fX1A9PT1yJiYodC5fX2MuX19QPWUpLHQuX19jPW51bGwpLHQuX19rPXQuX19rJiZ0Ll9fay5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIG4odCxlLHIpfSkpLHR9KHRoaXMuX19iLGUsci5fX089ci5fX1ApO310aGlzLl9fYj1udWxsO312YXIgdT10Ll9fZSYmY3JlYXRlRWxlbWVudChGcmFnbWVudCxudWxsLG4uZmFsbGJhY2spO3JldHVybiB1JiYodS5fX2g9bnVsbCksW2NyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsbnVsbCx0Ll9fZT9udWxsOm4uY2hpbGRyZW4pLHVdfTt2YXIgVCQxPWZ1bmN0aW9uKG4sdCxlKXtpZigrK2VbMV09PT1lWzBdJiZuLm8uZGVsZXRlKHQpLG4ucHJvcHMucmV2ZWFsT3JkZXImJihcInRcIiE9PW4ucHJvcHMucmV2ZWFsT3JkZXJbMF18fCFuLm8uc2l6ZSkpZm9yKGU9bi51O2U7KXtmb3IoO2UubGVuZ3RoPjM7KWUucG9wKCkoKTtpZihlWzFdPGVbMF0pYnJlYWs7bi51PWU9ZVsyXTt9fTtmdW5jdGlvbiBEKG4pe3JldHVybiB0aGlzLmdldENoaWxkQ29udGV4dD1mdW5jdGlvbigpe3JldHVybiBuLmNvbnRleHR9LG4uY2hpbGRyZW59ZnVuY3Rpb24gSShuKXt2YXIgdD10aGlzLGU9bi5pO3QuY29tcG9uZW50V2lsbFVubW91bnQ9ZnVuY3Rpb24oKXtyZW5kZXIobnVsbCx0LmwpLHQubD1udWxsLHQuaT1udWxsO30sdC5pJiZ0LmkhPT1lJiZ0LmNvbXBvbmVudFdpbGxVbm1vdW50KCksbi5fX3Y/KHQubHx8KHQuaT1lLHQubD17bm9kZVR5cGU6MSxwYXJlbnROb2RlOmUsY2hpbGROb2RlczpbXSxhcHBlbmRDaGlsZDpmdW5jdGlvbihuKXt0aGlzLmNoaWxkTm9kZXMucHVzaChuKSx0LmkuYXBwZW5kQ2hpbGQobik7fSxpbnNlcnRCZWZvcmU6ZnVuY3Rpb24obixlKXt0aGlzLmNoaWxkTm9kZXMucHVzaChuKSx0LmkuYXBwZW5kQ2hpbGQobik7fSxyZW1vdmVDaGlsZDpmdW5jdGlvbihuKXt0aGlzLmNoaWxkTm9kZXMuc3BsaWNlKHRoaXMuY2hpbGROb2Rlcy5pbmRleE9mKG4pPj4+MSwxKSx0LmkucmVtb3ZlQ2hpbGQobik7fX0pLHJlbmRlcihjcmVhdGVFbGVtZW50KEQse2NvbnRleHQ6dC5jb250ZXh0fSxuLl9fdiksdC5sKSk6dC5sJiZ0LmNvbXBvbmVudFdpbGxVbm1vdW50KCk7fWZ1bmN0aW9uIFcobix0KXtyZXR1cm4gY3JlYXRlRWxlbWVudChJLHtfX3Y6bixpOnR9KX0oTS5wcm90b3R5cGU9bmV3IENvbXBvbmVudCQxKS5fX2U9ZnVuY3Rpb24obil7dmFyIHQ9dGhpcyxlPVUodC5fX3YpLHI9dC5vLmdldChuKTtyZXR1cm4gclswXSsrLGZ1bmN0aW9uKHUpe3ZhciBvPWZ1bmN0aW9uKCl7dC5wcm9wcy5yZXZlYWxPcmRlcj8oci5wdXNoKHUpLFQkMSh0LG4scikpOnUoKTt9O2U/ZShvKTpvKCk7fX0sTS5wcm90b3R5cGUucmVuZGVyPWZ1bmN0aW9uKG4pe3RoaXMudT1udWxsLHRoaXMubz1uZXcgTWFwO3ZhciB0PXRvQ2hpbGRBcnJheShuLmNoaWxkcmVuKTtuLnJldmVhbE9yZGVyJiZcImJcIj09PW4ucmV2ZWFsT3JkZXJbMF0mJnQucmV2ZXJzZSgpO2Zvcih2YXIgZT10Lmxlbmd0aDtlLS07KXRoaXMuby5zZXQodFtlXSx0aGlzLnU9WzEsMCx0aGlzLnVdKTtyZXR1cm4gbi5jaGlsZHJlbn0sTS5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlPU0ucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50PWZ1bmN0aW9uKCl7dmFyIG49dGhpczt0aGlzLm8uZm9yRWFjaChmdW5jdGlvbih0LGUpe1QkMShuLGUsdCk7fSk7fTt2YXIgaiQxPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBTeW1ib2wmJlN5bWJvbC5mb3ImJlN5bWJvbC5mb3IoXCJyZWFjdC5lbGVtZW50XCIpfHw2MDEwMyxQPS9eKD86YWNjZW50fGFsaWdubWVudHxhcmFiaWN8YmFzZWxpbmV8Y2FwfGNsaXAoPyFQYXRoVSl8Y29sb3J8ZG9taW5hbnR8ZmlsbHxmbG9vZHxmb250fGdseXBoKD8hUil8aG9yaXp8bWFya2VyKD8hSHxXfFUpfG92ZXJsaW5lfHBhaW50fHN0b3B8c3RyaWtldGhyb3VnaHxzdHJva2V8dGV4dCg/IUwpfHVuZGVybGluZXx1bmljb2RlfHVuaXRzfHZ8dmVjdG9yfHZlcnR8d29yZHx3cml0aW5nfHgoPyFDKSlbQS1aXS8sVj1cInVuZGVmaW5lZFwiIT10eXBlb2YgZG9jdW1lbnQsej1mdW5jdGlvbihuKXtyZXR1cm4gKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2woKT8vZmlsfGNoZXxyYWQvaTovZmlsfGNoZXxyYS9pKS50ZXN0KG4pfTtmdW5jdGlvbiBCKG4sdCxlKXtyZXR1cm4gbnVsbD09dC5fX2smJih0LnRleHRDb250ZW50PVwiXCIpLHJlbmRlcihuLHQpLFwiZnVuY3Rpb25cIj09dHlwZW9mIGUmJmUoKSxuP24uX19jOm51bGx9ZnVuY3Rpb24gJChuLHQsZSl7cmV0dXJuIGh5ZHJhdGUobix0KSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBlJiZlKCksbj9uLl9fYzpudWxsfUNvbXBvbmVudCQxLnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50PXt9LFtcImNvbXBvbmVudFdpbGxNb3VudFwiLFwiY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1wiLFwiY29tcG9uZW50V2lsbFVwZGF0ZVwiXS5mb3JFYWNoKGZ1bmN0aW9uKG4pe09iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnQkMS5wcm90b3R5cGUsbix7Y29uZmlndXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzW1wiVU5TQUZFX1wiK25dfSxzZXQ6ZnVuY3Rpb24odCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsbix7Y29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnR9KTt9fSk7fSk7dmFyIEg9b3B0aW9ucy5ldmVudDtmdW5jdGlvbiBaKCl7fWZ1bmN0aW9uIFkoKXtyZXR1cm4gdGhpcy5jYW5jZWxCdWJibGV9ZnVuY3Rpb24gcSgpe3JldHVybiB0aGlzLmRlZmF1bHRQcmV2ZW50ZWR9b3B0aW9ucy5ldmVudD1mdW5jdGlvbihuKXtyZXR1cm4gSCYmKG49SChuKSksbi5wZXJzaXN0PVosbi5pc1Byb3BhZ2F0aW9uU3RvcHBlZD1ZLG4uaXNEZWZhdWx0UHJldmVudGVkPXEsbi5uYXRpdmVFdmVudD1ufTt2YXIgRyxKPXtjb25maWd1cmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2xhc3N9fSxLPW9wdGlvbnMudm5vZGU7b3B0aW9ucy52bm9kZT1mdW5jdGlvbihuKXt2YXIgdD1uLnR5cGUsZT1uLnByb3BzLHI9ZTtpZihcInN0cmluZ1wiPT10eXBlb2YgdCl7dmFyIHU9LTE9PT10LmluZGV4T2YoXCItXCIpO2Zvcih2YXIgbyBpbiByPXt9LGUpe3ZhciBpPWVbb107ViYmXCJjaGlsZHJlblwiPT09byYmXCJub3NjcmlwdFwiPT09dHx8XCJ2YWx1ZVwiPT09byYmXCJkZWZhdWx0VmFsdWVcImluIGUmJm51bGw9PWl8fChcImRlZmF1bHRWYWx1ZVwiPT09byYmXCJ2YWx1ZVwiaW4gZSYmbnVsbD09ZS52YWx1ZT9vPVwidmFsdWVcIjpcImRvd25sb2FkXCI9PT1vJiYhMD09PWk/aT1cIlwiOi9vbmRvdWJsZWNsaWNrL2kudGVzdChvKT9vPVwib25kYmxjbGlja1wiOi9eb25jaGFuZ2UodGV4dGFyZWF8aW5wdXQpL2kudGVzdChvK3QpJiYheihlLnR5cGUpP289XCJvbmlucHV0XCI6L15vbmZvY3VzJC9pLnRlc3Qobyk/bz1cIm9uZm9jdXNpblwiOi9eb25ibHVyJC9pLnRlc3Qobyk/bz1cIm9uZm9jdXNvdXRcIjovXm9uKEFuaXxUcmF8VG91fEJlZm9yZUlucCkvLnRlc3Qobyk/bz1vLnRvTG93ZXJDYXNlKCk6dSYmUC50ZXN0KG8pP289by5yZXBsYWNlKC9bQS1aMC05XS8sXCItJCZcIikudG9Mb3dlckNhc2UoKTpudWxsPT09aSYmKGk9dm9pZCAwKSxyW29dPWkpO31cInNlbGVjdFwiPT10JiZyLm11bHRpcGxlJiZBcnJheS5pc0FycmF5KHIudmFsdWUpJiYoci52YWx1ZT10b0NoaWxkQXJyYXkoZS5jaGlsZHJlbikuZm9yRWFjaChmdW5jdGlvbihuKXtuLnByb3BzLnNlbGVjdGVkPS0xIT1yLnZhbHVlLmluZGV4T2Yobi5wcm9wcy52YWx1ZSk7fSkpLFwic2VsZWN0XCI9PXQmJm51bGwhPXIuZGVmYXVsdFZhbHVlJiYoci52YWx1ZT10b0NoaWxkQXJyYXkoZS5jaGlsZHJlbikuZm9yRWFjaChmdW5jdGlvbihuKXtuLnByb3BzLnNlbGVjdGVkPXIubXVsdGlwbGU/LTEhPXIuZGVmYXVsdFZhbHVlLmluZGV4T2Yobi5wcm9wcy52YWx1ZSk6ci5kZWZhdWx0VmFsdWU9PW4ucHJvcHMudmFsdWU7fSkpLG4ucHJvcHM9cixlLmNsYXNzIT1lLmNsYXNzTmFtZSYmKEouZW51bWVyYWJsZT1cImNsYXNzTmFtZVwiaW4gZSxudWxsIT1lLmNsYXNzTmFtZSYmKHIuY2xhc3M9ZS5jbGFzc05hbWUpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyLFwiY2xhc3NOYW1lXCIsSikpO31uLiQkdHlwZW9mPWokMSxLJiZLKG4pO307dmFyIFE9b3B0aW9ucy5fX3I7b3B0aW9ucy5fX3I9ZnVuY3Rpb24obil7USYmUShuKSxHPW4uX19jO307dmFyIFg9e1JlYWN0Q3VycmVudERpc3BhdGNoZXI6e2N1cnJlbnQ6e3JlYWRDb250ZXh0OmZ1bmN0aW9uKG4pe3JldHVybiBHLl9fbltuLl9fY10ucHJvcHMudmFsdWV9fX19O2Z1bmN0aW9uIHRuKG4pe3JldHVybiBjcmVhdGVFbGVtZW50LmJpbmQobnVsbCxuKX1mdW5jdGlvbiBlbihuKXtyZXR1cm4gISFuJiZuLiQkdHlwZW9mPT09aiQxfWZ1bmN0aW9uIHJuKG4pe3JldHVybiBlbihuKT9jbG9uZUVsZW1lbnQuYXBwbHkobnVsbCxhcmd1bWVudHMpOm59ZnVuY3Rpb24gdW4obil7cmV0dXJuICEhbi5fX2smJihyZW5kZXIobnVsbCxuKSwhMCl9ZnVuY3Rpb24gb24obil7cmV0dXJuIG4mJihuLmJhc2V8fDE9PT1uLm5vZGVUeXBlJiZuKXx8bnVsbH12YXIgbG49ZnVuY3Rpb24obix0KXtyZXR1cm4gbih0KX0sY249ZnVuY3Rpb24obix0KXtyZXR1cm4gbih0KX07dmFyIFJlYWN0X19kZWZhdWx0ID0ge3VzZVN0YXRlOmwsdXNlUmVkdWNlcjpwLHVzZUVmZmVjdDp5LHVzZUxheW91dEVmZmVjdDpoLHVzZVJlZjpzLHVzZUltcGVyYXRpdmVIYW5kbGU6Xyx1c2VNZW1vOmQsdXNlQ2FsbGJhY2s6QSx1c2VDb250ZXh0OkYsdXNlRGVidWdWYWx1ZTpULHZlcnNpb246XCIxNy4wLjJcIixDaGlsZHJlbjprJDEscmVuZGVyOkIsaHlkcmF0ZTokLHVubW91bnRDb21wb25lbnRBdE5vZGU6dW4sY3JlYXRlUG9ydGFsOlcsY3JlYXRlRWxlbWVudDpjcmVhdGVFbGVtZW50LGNyZWF0ZUNvbnRleHQ6Y3JlYXRlQ29udGV4dCxjcmVhdGVGYWN0b3J5OnRuLGNsb25lRWxlbWVudDpybixjcmVhdGVSZWY6Y3JlYXRlUmVmLEZyYWdtZW50OkZyYWdtZW50LGlzVmFsaWRFbGVtZW50OmVuLGZpbmRET01Ob2RlOm9uLENvbXBvbmVudDpDb21wb25lbnQkMSxQdXJlQ29tcG9uZW50OkUsbWVtbzpnJDEsZm9yd2FyZFJlZjp4JDEsZmx1c2hTeW5jOmNuLHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzOmxuLFN0cmljdE1vZGU6RnJhZ21lbnQsU3VzcGVuc2U6TCxTdXNwZW5zZUxpc3Q6TSxsYXp5OkYkMSxfX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDpYfTtcblxuLypcbkNvcHlyaWdodCAoYykgTkFWRVIgQ29ycC5cbm5hbWU6IEBlZ2pzL2NvbXBvbmVudFxubGljZW5zZTogTUlUXG5hdXRob3I6IE5BVkVSIENvcnAuXG5yZXBvc2l0b3J5OiBodHRwczovL2dpdGh1Yi5jb20vbmF2ZXIvZWdqcy1jb21wb25lbnRcbnZlcnNpb246IDMuMC40XG4qL1xuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cbmZ1bmN0aW9uIF9fdmFsdWVzKG8pIHtcbiAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLFxuICAgIG0gPSBzICYmIG9bc10sXG4gICAgaSA9IDA7XG4gIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xuICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XG4gICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiBvICYmIG9baSsrXSxcbiAgICAgICAgZG9uZTogIW9cbiAgICAgIH07XG4gICAgfVxuICB9O1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG59XG5mdW5jdGlvbiBfX3JlYWQobywgbikge1xuICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gIGlmICghbSkgcmV0dXJuIG87XG4gIHZhciBpID0gbS5jYWxsKG8pLFxuICAgIHIsXG4gICAgYXIgPSBbXSxcbiAgICBlO1xuICB0cnkge1xuICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGUgPSB7XG4gICAgICBlcnJvcjogZXJyb3JcbiAgICB9O1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKGUpIHRocm93IGUuZXJyb3I7XG4gICAgfVxuICB9XG4gIHJldHVybiBhcjtcbn1cbmZ1bmN0aW9uIF9fc3ByZWFkKCkge1xuICBmb3IgKHZhciBhciA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xuICByZXR1cm4gYXI7XG59XG5cbi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgTkFWRVIgQ29ycC5cbiAqIGVnanMgcHJvamVjdHMgYXJlIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG52YXIgaXNVbmRlZmluZWQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIjtcbn07XG5cbi8vIFRoaXMgY2xhc3MgbmFtZSBpcyBub3QgbWF0Y2hlZCB0byBmaWxlIG5hbWUgaW50ZW50aW9uYWxseVxuLyoqXG4gKiBFdmVudCBjbGFzcyB0byBwcm92aWRlIGFkZGl0aW9uYWwgcHJvcGVydGllc1xuICogQGtvIENvbXBvbmVudOyXkOyEnCDstpTqsIDsoIHsnbgg7ZSE66Gc7Y287Yuw66W8IOygnOqzte2VmOuKlCDsnbTrsqTtirgg7YG0656Y7IqkXG4gKi9cbnZhciBDb21wb25lbnRFdmVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgQ29tcG9uZW50RXZlbnQuXG4gICAqIEBrbyBDb21wb25lbnRFdmVudOydmCDsg4jroZzsmrQg7J247Iqk7YS07Iqk66W8IOyDneyEse2VnOuLpC5cbiAgICogQHBhcmFtIGV2ZW50VHlwZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQuPGtvPuydtOuypO2KuCDsnbTrpoQuPC9rbz5cbiAgICogQHBhcmFtIHByb3BzIEFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGFkZGl0aW9uYWwgZXZlbnQgcHJvcGVydGllcy48a28+7LaU6rCA7KCB7J24IOydtOuypO2KuCDtlITroZztjbzti7Ag7Jik67iM7KCd7Yq4Ljwva28+XG4gICAqL1xuICBmdW5jdGlvbiBDb21wb25lbnRFdmVudChldmVudFR5cGUsIHByb3BzKSB7XG4gICAgdmFyIGVfMSwgX2E7XG4gICAgdGhpcy5fY2FuY2VsZWQgPSBmYWxzZTtcbiAgICBpZiAocHJvcHMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXMoT2JqZWN0LmtleXMocHJvcHMpKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xuICAgICAgICAgIHZhciBrZXkgPSBfYy52YWx1ZTtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50XG4gICAgICAgICAgdGhpc1trZXldID0gcHJvcHNba2V5XTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZV8xXzEpIHtcbiAgICAgICAgZV8xID0ge1xuICAgICAgICAgIGVycm9yOiBlXzFfMVxuICAgICAgICB9O1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZXZlbnRUeXBlID0gZXZlbnRUeXBlO1xuICB9XG4gIC8qKlxuICAgKiBTdG9wIHRoZSBldmVudC4ge0BsaW5rIENvbXBvbmVudEV2ZW50I2lzQ2FuY2VsZWR9IHdpbGwgcmV0dXJuIGB0cnVlYCBhZnRlci5cbiAgICogQGtvIOydtOuypO2KuOulvCDspJHri6jtlZzri6QuIOydtO2bhCB7QGxpbmsgQ29tcG9uZW50RXZlbnQjaXNDYW5jZWxlZH3qsIAgYHRydWVg66W8IOuwmO2ZmO2VnOuLpC5cbiAgICovXG4gIHZhciBfX3Byb3RvID0gQ29tcG9uZW50RXZlbnQucHJvdG90eXBlO1xuICBfX3Byb3RvLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fY2FuY2VsZWQgPSB0cnVlO1xuICB9O1xuICAvKipcbiAgICogUmV0dXJucyBhIGJvb2xlYW4gdmFsdWUgdGhhdCBpbmRpY2F0ZXMgd2hldGhlciB7QGxpbmsgQ29tcG9uZW50RXZlbnQjc3RvcH0gaXMgY2FsbGVkIGJlZm9yZS5cbiAgICogQGtvIHtAbGluayBDb21wb25lbnRFdmVudCNzdG9wfeydtCDtmLjstpzrkJjsl4jripTsp4Ag7Jes67aA66W8IOuwmO2ZmO2VnOuLpC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gQSBib29sZWFuIHZhbHVlIHRoYXQgaW5kaWNhdGVzIHdoZXRoZXIge0BsaW5rIENvbXBvbmVudEV2ZW50I3N0b3B9IGlzIGNhbGxlZCBiZWZvcmUuPGtvPuydtOyghOyXkCB7QGxpbmsgQ29tcG9uZW50RXZlbnQjc3RvcH3snbQg67aI66Ck7KGM64qU7KeAIOyXrOu2gOulvCDrsJjtmZjtlZzri6QuPC9rbz5cbiAgICovXG4gIF9fcHJvdG8uaXNDYW5jZWxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FuY2VsZWQ7XG4gIH07XG4gIHJldHVybiBDb21wb25lbnRFdmVudDtcbn0oKTtcblxuLyoqXG4gKiBBIGNsYXNzIHVzZWQgdG8gbWFuYWdlIGV2ZW50cyBpbiBhIGNvbXBvbmVudFxuICogQGtvIOy7tO2PrOuEjO2KuOydmCDsnbTrsqTtirjsnYQg6rSA66as7ZWgIOyImCDsnojqsowg7ZWY64qUIO2BtOuemOyKpFxuICovXG52YXIgQ29tcG9uZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBzdXBwb3J0IHtcImllXCI6IFwiNytcIiwgXCJjaFwiIDogXCJsYXRlc3RcIiwgXCJmZlwiIDogXCJsYXRlc3RcIiwgIFwic2ZcIiA6IFwibGF0ZXN0XCIsIFwiZWRnZVwiIDogXCJsYXRlc3RcIiwgXCJpb3NcIiA6IFwiNytcIiwgXCJhblwiIDogXCIyLjErIChleGNlcHQgMy54KVwifVxuICAgKi9cbiAgZnVuY3Rpb24gQ29tcG9uZW50KCkge1xuICAgIHRoaXMuX2V2ZW50SGFuZGxlciA9IHt9O1xuICB9XG4gIC8qKlxuICAgKiBUcmlnZ2VyIGEgY3VzdG9tIGV2ZW50LlxuICAgKiBAa28g7Luk7Iqk7YWAIOydtOuypO2KuOulvCDrsJzsg53si5ztgqjri6RcbiAgICogQHBhcmFtIHtzdHJpbmcgfCBDb21wb25lbnRFdmVudH0gZXZlbnQgVGhlIG5hbWUgb2YgdGhlIGN1c3RvbSBldmVudCB0byBiZSB0cmlnZ2VyZWQgb3IgYW4gaW5zdGFuY2Ugb2YgdGhlIENvbXBvbmVudEV2ZW50PGtvPuuwnOyDne2VoCDsu6TsiqTthYAg7J2067Kk7Yq47J2YIOydtOumhCDrmJDripQgQ29tcG9uZW50RXZlbnTsnZgg7J247Iqk7YS07IqkPC9rbz5cbiAgICogQHBhcmFtIHthbnlbXX0gcGFyYW1zIEV2ZW50IGRhdGEgdG8gYmUgc2VudCB3aGVuIHRyaWdnZXJpbmcgYSBjdXN0b20gZXZlbnQgPGtvPuy7pOyKpO2FgCDsnbTrsqTtirjqsIAg67Cc7IOd7ZWgIOuVjCDsoITri6ztlaAg642w7J207YSwPC9rbz5cbiAgICogQHJldHVybiBBbiBpbnN0YW5jZSBvZiB0aGUgY29tcG9uZW50IGl0c2VsZjxrbz7su7Ttj6zrhIztirgg7J6Q7Iug7J2YIOyduOyKpO2EtOyKpDwva28+XG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzXG4gICAqIGltcG9ydCBDb21wb25lbnQsIHsgQ29tcG9uZW50RXZlbnQgfSBmcm9tIFwiQGVnanMvY29tcG9uZW50XCI7XG4gICAqXG4gICAqIGNsYXNzIFNvbWUgZXh0ZW5kcyBDb21wb25lbnQ8e1xuICAgKiAgIGJlZm9yZUhpOiBDb21wb25lbnRFdmVudDx7IGZvbzogbnVtYmVyOyBiYXI6IHN0cmluZyB9PjtcbiAgICogICBoaTogeyBmb286IHsgYTogbnVtYmVyOyBiOiBib29sZWFuIH0gfTtcbiAgICogICBzb21lRXZlbnQ6IChmb286IG51bWJlciwgYmFyOiBzdHJpbmcpID0+IHZvaWQ7XG4gICAqICAgc29tZU90aGVyRXZlbnQ6IHZvaWQ7IC8vIFdoZW4gdGhlcmUncyBubyBldmVudCBhcmd1bWVudFxuICAgKiB9PiB7XG4gICAqICAgc29tZSgpe1xuICAgKiAgICAgaWYodGhpcy50cmlnZ2VyKFwiYmVmb3JlSGlcIikpeyAvLyBXaGVuIGV2ZW50IGNhbGwgdG8gc3RvcCByZXR1cm4gZmFsc2UuXG4gICAqICAgICAgIHRoaXMudHJpZ2dlcihcImhpXCIpOy8vIGZpcmUgaGkgZXZlbnQuXG4gICAqICAgICB9XG4gICAqICAgfVxuICAgKiB9XG4gICAqXG4gICAqIGNvbnN0IHNvbWUgPSBuZXcgU29tZSgpO1xuICAgKiBzb21lLm9uKFwiYmVmb3JlSGlcIiwgZSA9PiB7XG4gICAqICAgaWYoY29uZGl0aW9uKXtcbiAgICogICAgIGUuc3RvcCgpOyAvLyBXaGVuIGV2ZW50IGNhbGwgdG8gc3RvcCwgYGhpYCBldmVudCBub3QgY2FsbC5cbiAgICogICB9XG4gICAqICAgLy8gYGN1cnJlbnRUYXJnZXRgIGlzIGNvbXBvbmVudCBpbnN0YW5jZS5cbiAgICogICBjb25zb2xlLmxvZyhzb21lID09PSBlLmN1cnJlbnRUYXJnZXQpOyAvLyB0cnVlXG4gICAqXG4gICAqICAgdHlwZW9mIGUuZm9vOyAvLyBudW1iZXJcbiAgICogICB0eXBlb2YgZS5iYXI7IC8vIHN0cmluZ1xuICAgKiB9KTtcbiAgICogc29tZS5vbihcImhpXCIsIGUgPT4ge1xuICAgKiAgIHR5cGVvZiBlLmZvby5iOyAvLyBib29sZWFuXG4gICAqIH0pO1xuICAgKiAvLyBJZiB5b3Ugd2FudCB0byBtb3JlIGtub3cgZXZlbnQgZGVzaWduLiBZb3UgY2FuIHNlZSBhcnRpY2xlLlxuICAgKiAvLyBodHRwczovL2dpdGh1Yi5jb20vbmF2ZXIvZWdqcy1jb21wb25lbnQvd2lraS9Ib3ctdG8tbWFrZS1Db21wb25lbnQtZXZlbnQtZGVzaWduJTNGXG4gICAqIGBgYFxuICAgKi9cbiAgdmFyIF9fcHJvdG8gPSBDb21wb25lbnQucHJvdG90eXBlO1xuICBfX3Byb3RvLnRyaWdnZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgcGFyYW1zID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHBhcmFtc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgdmFyIGV2ZW50TmFtZSA9IGV2ZW50IGluc3RhbmNlb2YgQ29tcG9uZW50RXZlbnQgPyBldmVudC5ldmVudFR5cGUgOiBldmVudDtcbiAgICB2YXIgaGFuZGxlcnMgPSBfX3NwcmVhZCh0aGlzLl9ldmVudEhhbmRsZXJbZXZlbnROYW1lXSB8fCBbXSk7XG4gICAgaWYgKGhhbmRsZXJzLmxlbmd0aCA8PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKGV2ZW50IGluc3RhbmNlb2YgQ29tcG9uZW50RXZlbnQpIHtcbiAgICAgIGV2ZW50LmN1cnJlbnRUYXJnZXQgPSB0aGlzO1xuICAgICAgaGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgICAgICBoYW5kbGVyKGV2ZW50KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBoYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWNhbGxcbiAgICAgICAgaGFuZGxlci5hcHBseSh2b2lkIDAsIF9fc3ByZWFkKHBhcmFtcykpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogRXhlY3V0ZWQgZXZlbnQganVzdCBvbmUgdGltZS5cbiAgICogQGtvIOydtOuypO2KuOqwgCDtlZzrsojrp4wg7Iuk7ZaJ65Cc64ukLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBiZSBhdHRhY2hlZCBvciBhbiBldmVudCBuYW1lIC0gZXZlbnQgaGFuZGxlciBtYXBwZWQgb2JqZWN0Ljxrbz7rk7HroZ3tlaAg7J2067Kk7Yq47J2YIOydtOumhCDrmJDripQg7J2067Kk7Yq4IOydtOumhC3tlbjrk6Trn6wg7Jik67iM7KCd7Yq4PC9rbz5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gaGFuZGxlclRvQXR0YWNoIFRoZSBoYW5kbGVyIGZ1bmN0aW9uIG9mIHRoZSBldmVudCB0byBiZSBhdHRhY2hlZCA8a28+65Ox66Gd7ZWgIOydtOuypO2KuOydmCDtlbjrk6Trn6wg7ZWo7IiYPC9rbz5cbiAgICogQHJldHVybiBBbiBpbnN0YW5jZSBvZiB0aGUgY29tcG9uZW50IGl0c2VsZjxrbz7su7Ttj6zrhIztirgg7J6Q7Iug7J2YIOyduOyKpO2EtOyKpDwva28+XG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzXG4gICAqIGltcG9ydCBDb21wb25lbnQsIHsgQ29tcG9uZW50RXZlbnQgfSBmcm9tIFwiQGVnanMvY29tcG9uZW50XCI7XG4gICAqXG4gICAqIGNsYXNzIFNvbWUgZXh0ZW5kcyBDb21wb25lbnQ8e1xuICAgKiAgIGhpOiBDb21wb25lbnRFdmVudDtcbiAgICogfT4ge1xuICAgKiAgIGhpKCkge1xuICAgKiAgICAgYWxlcnQoXCJoaVwiKTtcbiAgICogICB9XG4gICAqICAgdGhpbmcoKSB7XG4gICAqICAgICB0aGlzLm9uY2UoXCJoaVwiLCB0aGlzLmhpKTtcbiAgICogICB9XG4gICAqIH1cbiAgICpcbiAgICogdmFyIHNvbWUgPSBuZXcgU29tZSgpO1xuICAgKiBzb21lLnRoaW5nKCk7XG4gICAqIHNvbWUudHJpZ2dlcihuZXcgQ29tcG9uZW50RXZlbnQoXCJoaVwiKSk7XG4gICAqIC8vIGZpcmUgYWxlcnQoXCJoaVwiKTtcbiAgICogc29tZS50cmlnZ2VyKG5ldyBDb21wb25lbnRFdmVudChcImhpXCIpKTtcbiAgICogLy8gTm90aGluZyBoYXBwZW5zXG4gICAqIGBgYFxuICAgKi9cbiAgX19wcm90by5vbmNlID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgaGFuZGxlclRvQXR0YWNoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBpZiAodHlwZW9mIGV2ZW50TmFtZSA9PT0gXCJvYmplY3RcIiAmJiBpc1VuZGVmaW5lZChoYW5kbGVyVG9BdHRhY2gpKSB7XG4gICAgICB2YXIgZXZlbnRIYXNoID0gZXZlbnROYW1lO1xuICAgICAgZm9yICh2YXIga2V5IGluIGV2ZW50SGFzaCkge1xuICAgICAgICB0aGlzLm9uY2Uoa2V5LCBldmVudEhhc2hba2V5XSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBldmVudE5hbWUgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIGhhbmRsZXJUb0F0dGFjaCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB2YXIgbGlzdGVuZXJfMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtY2FsbFxuICAgICAgICBoYW5kbGVyVG9BdHRhY2guYXBwbHkodm9pZCAwLCBfX3NwcmVhZChhcmdzKSk7XG4gICAgICAgIF90aGlzLm9mZihldmVudE5hbWUsIGxpc3RlbmVyXzEpO1xuICAgICAgfTtcbiAgICAgIHRoaXMub24oZXZlbnROYW1lLCBsaXN0ZW5lcl8xKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBhbiBldmVudCBoYXMgYmVlbiBhdHRhY2hlZCB0byBhIGNvbXBvbmVudC5cbiAgICogQGtvIOy7tO2PrOuEjO2KuOyXkCDsnbTrsqTtirjqsIAg65Ox66Gd65CQ64qU7KeAIO2ZleyduO2VnOuLpC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gYmUgYXR0YWNoZWQgPGtvPuuTseuhnSDsl6zrtoDrpbwg7ZmV7J247ZWgIOydtOuypO2KuOydmCDsnbTrpoQ8L2tvPlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZXZlbnQgaXMgYXR0YWNoZWQuIDxrbz7snbTrsqTtirgg65Ox66GdIOyXrOu2gDwva28+XG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzXG4gICAqIGltcG9ydCBDb21wb25lbnQgZnJvbSBcIkBlZ2pzL2NvbXBvbmVudFwiO1xuICAgKlxuICAgKiBjbGFzcyBTb21lIGV4dGVuZHMgQ29tcG9uZW50PHtcbiAgICogICBoaTogdm9pZDtcbiAgICogfT4ge1xuICAgKiAgIHNvbWUoKSB7XG4gICAqICAgICB0aGlzLmhhc09uKFwiaGlcIik7Ly8gY2hlY2sgaGkgZXZlbnQuXG4gICAqICAgfVxuICAgKiB9XG4gICAqIGBgYFxuICAgKi9cbiAgX19wcm90by5oYXNPbiA9IGZ1bmN0aW9uIChldmVudE5hbWUpIHtcbiAgICByZXR1cm4gISF0aGlzLl9ldmVudEhhbmRsZXJbZXZlbnROYW1lXTtcbiAgfTtcbiAgLyoqXG4gICAqIEF0dGFjaGVzIGFuIGV2ZW50IHRvIGEgY29tcG9uZW50LlxuICAgKiBAa28g7Lu07Y+s64SM7Yq47JeQIOydtOuypO2KuOulvCDrk7HroZ3tlZzri6QuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIGJlIGF0dGFjaGVkIG9yIGFuIGV2ZW50IG5hbWUgLSBldmVudCBoYW5kbGVyIG1hcHBlZCBvYmplY3QuPGtvPuuTseuhne2VoCDsnbTrsqTtirjsnZgg7J2066aEIOuYkOuKlCDsnbTrsqTtirgg7J2066aELe2VuOuTpOufrCDsmKTruIzsoJ3tirg8L2tvPlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBoYW5kbGVyVG9BdHRhY2ggVGhlIGhhbmRsZXIgZnVuY3Rpb24gb2YgdGhlIGV2ZW50IHRvIGJlIGF0dGFjaGVkIDxrbz7rk7HroZ3tlaAg7J2067Kk7Yq47J2YIO2VuOuTpOufrCDtlajsiJg8L2tvPlxuICAgKiBAcmV0dXJuIEFuIGluc3RhbmNlIG9mIGEgY29tcG9uZW50IGl0c2VsZjxrbz7su7Ttj6zrhIztirgg7J6Q7Iug7J2YIOyduOyKpO2EtOyKpDwva28+XG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzXG4gICAqIGltcG9ydCBDb21wb25lbnQsIHsgQ29tcG9uZW50RXZlbnQgfSBmcm9tIFwiQGVnanMvY29tcG9uZW50XCI7XG4gICAqXG4gICAqIGNsYXNzIFNvbWUgZXh0ZW5kcyBDb21wb25lbnQ8e1xuICAgKiAgIGhpOiB2b2lkO1xuICAgKiB9PiB7XG4gICAqICAgaGkoKSB7XG4gICAqICAgICBjb25zb2xlLmxvZyhcImhpXCIpO1xuICAgKiAgIH1cbiAgICogICBzb21lKCkge1xuICAgKiAgICAgdGhpcy5vbihcImhpXCIsdGhpcy5oaSk7IC8vYXR0YWNoIGV2ZW50XG4gICAqICAgfVxuICAgKiB9XG4gICAqIGBgYFxuICAgKi9cbiAgX19wcm90by5vbiA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGhhbmRsZXJUb0F0dGFjaCkge1xuICAgIGlmICh0eXBlb2YgZXZlbnROYW1lID09PSBcIm9iamVjdFwiICYmIGlzVW5kZWZpbmVkKGhhbmRsZXJUb0F0dGFjaCkpIHtcbiAgICAgIHZhciBldmVudEhhc2ggPSBldmVudE5hbWU7XG4gICAgICBmb3IgKHZhciBuYW1lIGluIGV2ZW50SGFzaCkge1xuICAgICAgICB0aGlzLm9uKG5hbWUsIGV2ZW50SGFzaFtuYW1lXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBldmVudE5hbWUgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIGhhbmRsZXJUb0F0dGFjaCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB2YXIgaGFuZGxlckxpc3QgPSB0aGlzLl9ldmVudEhhbmRsZXJbZXZlbnROYW1lXTtcbiAgICAgIGlmIChpc1VuZGVmaW5lZChoYW5kbGVyTGlzdCkpIHtcbiAgICAgICAgdGhpcy5fZXZlbnRIYW5kbGVyW2V2ZW50TmFtZV0gPSBbXTtcbiAgICAgICAgaGFuZGxlckxpc3QgPSB0aGlzLl9ldmVudEhhbmRsZXJbZXZlbnROYW1lXTtcbiAgICAgIH1cbiAgICAgIGhhbmRsZXJMaXN0LnB1c2goaGFuZGxlclRvQXR0YWNoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxuICAgKiBEZXRhY2hlcyBhbiBldmVudCBmcm9tIHRoZSBjb21wb25lbnQuPGJyLz5JZiB0aGUgYGV2ZW50TmFtZWAgaXMgbm90IGdpdmVuIHRoaXMgd2lsbCBkZXRhY2ggYWxsIGV2ZW50IGhhbmRsZXJzIGF0dGFjaGVkLjxici8+SWYgdGhlIGBoYW5kbGVyVG9EZXRhY2hgIGlzIG5vdCBnaXZlbiwgdGhpcyB3aWxsIGRldGFjaCBhbGwgZXZlbnQgaGFuZGxlcnMgZm9yIGBldmVudE5hbWVgLlxuICAgKiBAa28g7Lu07Y+s64SM7Yq47JeQIOuTseuhneuQnCDsnbTrsqTtirjrpbwg7ZW07KCc7ZWc64ukLjxici8+YGV2ZW50TmFtZWDsnbQg7KO87Ja07KeA7KeAIOyViuyVmOydhCDqsr3smrAg66qo65OgIOydtOuypO2KuCDtlbjrk6Trn6zrpbwg7KCc6rGw7ZWc64ukLjxici8+YGhhbmRsZXJUb0F0dGFjaGDqsIAg7KO87Ja07KeA7KeAIOyViuyVmOydhCDqsr3smrAgYGV2ZW50TmFtZWDsl5Ag7ZW064u57ZWY64qUIOuqqOuToCDsnbTrsqTtirgg7ZW465Ok65+s66W8IOygnOqxsO2VnOuLpC5cbiAgICogQHBhcmFtIHtzdHJpbmc/fSBldmVudE5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIGJlIGRldGFjaGVkIDxrbz7tlbTsoJztlaAg7J2067Kk7Yq47J2YIOydtOumhDwva28+XG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24/fSBoYW5kbGVyVG9EZXRhY2ggVGhlIGhhbmRsZXIgZnVuY3Rpb24gb2YgdGhlIGV2ZW50IHRvIGJlIGRldGFjaGVkIDxrbz7tlbTsoJztlaAg7J2067Kk7Yq47J2YIO2VuOuTpOufrCDtlajsiJg8L2tvPlxuICAgKiBAcmV0dXJuIEFuIGluc3RhbmNlIG9mIGEgY29tcG9uZW50IGl0c2VsZiA8a28+7Lu07Y+s64SM7Yq4IOyekOyLoOydmCDsnbjsiqTthLTsiqQ8L2tvPlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c1xuICAgKiBpbXBvcnQgQ29tcG9uZW50LCB7IENvbXBvbmVudEV2ZW50IH0gZnJvbSBcIkBlZ2pzL2NvbXBvbmVudFwiO1xuICAgKlxuICAgKiBjbGFzcyBTb21lIGV4dGVuZHMgQ29tcG9uZW50PHtcbiAgICogICBoaTogdm9pZDtcbiAgICogfT4ge1xuICAgKiAgIGhpKCkge1xuICAgKiAgICAgY29uc29sZS5sb2coXCJoaVwiKTtcbiAgICogICB9XG4gICAqICAgc29tZSgpIHtcbiAgICogICAgIHRoaXMub2ZmKFwiaGlcIix0aGlzLmhpKTsgLy9kZXRhY2ggZXZlbnRcbiAgICogICB9XG4gICAqIH1cbiAgICogYGBgXG4gICAqL1xuICBfX3Byb3RvLm9mZiA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGhhbmRsZXJUb0RldGFjaCkge1xuICAgIHZhciBlXzEsIF9hO1xuICAgIC8vIERldGFjaCBhbGwgZXZlbnQgaGFuZGxlcnMuXG4gICAgaWYgKGlzVW5kZWZpbmVkKGV2ZW50TmFtZSkpIHtcbiAgICAgIHRoaXMuX2V2ZW50SGFuZGxlciA9IHt9O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIERldGFjaCBhbGwgaGFuZGxlcnMgZm9yIGV2ZW50bmFtZSBvciBkZXRhY2ggZXZlbnQgaGFuZGxlcnMgYnkgb2JqZWN0LlxuICAgIGlmIChpc1VuZGVmaW5lZChoYW5kbGVyVG9EZXRhY2gpKSB7XG4gICAgICBpZiAodHlwZW9mIGV2ZW50TmFtZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBkZWxldGUgdGhpcy5fZXZlbnRIYW5kbGVyW2V2ZW50TmFtZV07XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGV2ZW50SGFzaCA9IGV2ZW50TmFtZTtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBldmVudEhhc2gpIHtcbiAgICAgICAgICB0aGlzLm9mZihuYW1lLCBldmVudEhhc2hbbmFtZV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBEZXRhY2ggc2luZ2xlIGV2ZW50IGhhbmRsZXJcbiAgICB2YXIgaGFuZGxlckxpc3QgPSB0aGlzLl9ldmVudEhhbmRsZXJbZXZlbnROYW1lXTtcbiAgICBpZiAoaGFuZGxlckxpc3QpIHtcbiAgICAgIHZhciBpZHggPSAwO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgaGFuZGxlckxpc3RfMSA9IF9fdmFsdWVzKGhhbmRsZXJMaXN0KSwgaGFuZGxlckxpc3RfMV8xID0gaGFuZGxlckxpc3RfMS5uZXh0KCk7ICFoYW5kbGVyTGlzdF8xXzEuZG9uZTsgaGFuZGxlckxpc3RfMV8xID0gaGFuZGxlckxpc3RfMS5uZXh0KCkpIHtcbiAgICAgICAgICB2YXIgaGFuZGxlckZ1bmN0aW9uID0gaGFuZGxlckxpc3RfMV8xLnZhbHVlO1xuICAgICAgICAgIGlmIChoYW5kbGVyRnVuY3Rpb24gPT09IGhhbmRsZXJUb0RldGFjaCkge1xuICAgICAgICAgICAgaGFuZGxlckxpc3Quc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgICAgICBpZiAoaGFuZGxlckxpc3QubGVuZ3RoIDw9IDApIHtcbiAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50SGFuZGxlcltldmVudE5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlkeCsrO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlXzFfMSkge1xuICAgICAgICBlXzEgPSB7XG4gICAgICAgICAgZXJyb3I6IGVfMV8xXG4gICAgICAgIH07XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChoYW5kbGVyTGlzdF8xXzEgJiYgIWhhbmRsZXJMaXN0XzFfMS5kb25lICYmIChfYSA9IGhhbmRsZXJMaXN0XzEucmV0dXJuKSkgX2EuY2FsbChoYW5kbGVyTGlzdF8xKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxuICAgKiBWZXJzaW9uIGluZm8gc3RyaW5nXG4gICAqIEBrbyDrsoTsoITsoJXrs7Qg66y47J6Q7Je0XG4gICAqIEBuYW1lIFZFUlNJT05cbiAgICogQHN0YXRpY1xuICAgKiBAZXhhbXBsZVxuICAgKiBDb21wb25lbnQuVkVSU0lPTjsgIC8vIGV4KSAzLjAuMFxuICAgKiBAbWVtYmVyb2YgQ29tcG9uZW50XG4gICAqL1xuICBDb21wb25lbnQuVkVSU0lPTiA9IFwiMy4wLjRcIjtcbiAgcmV0dXJuIENvbXBvbmVudDtcbn0oKTtcblxuLypcbiAqIENvcHlyaWdodCAoYykgMjAxNSBOQVZFUiBDb3JwLlxuICogZWdqcyBwcm9qZWN0cyBhcmUgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb24sIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudFxudmFyIENvbXBvbmVudEV2ZW50JDEgPSBDb21wb25lbnRFdmVudDtcblxuLypcbkNvcHlyaWdodCAoYykgMjAxOS1wcmVzZW50IE5BVkVSIENvcnAuXG5uYW1lOiBAZWdqcy9saXN0LWRpZmZlclxubGljZW5zZTogTUlUXG5hdXRob3I6IE5BVkVSIENvcnAuXG5yZXBvc2l0b3J5OiBodHRwczovL2dpdGh1Yi5jb20vbmF2ZXIvZWdqcy1saXN0LWRpZmZlclxudmVyc2lvbjogMS4wLjFcbiovXG4vKlxuZWdqcy1saXN0LWRpZmZlclxuQ29weXJpZ2h0IChjKSAyMDE5LXByZXNlbnQgTkFWRVIgQ29ycC5cbk1JVCBsaWNlbnNlXG4qL1xudmFyIFBvbHlNYXAgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQb2x5TWFwKCkge1xuICAgIHRoaXMua2V5cyA9IFtdO1xuICAgIHRoaXMudmFsdWVzID0gW107XG4gIH1cblxuICB2YXIgX19wcm90byA9IFBvbHlNYXAucHJvdG90eXBlO1xuXG4gIF9fcHJvdG8uZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlc1t0aGlzLmtleXMuaW5kZXhPZihrZXkpXTtcbiAgfTtcblxuICBfX3Byb3RvLnNldCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgdmFyIGtleXMgPSB0aGlzLmtleXM7XG4gICAgdmFyIHZhbHVlcyA9IHRoaXMudmFsdWVzO1xuICAgIHZhciBwcmV2SW5kZXggPSBrZXlzLmluZGV4T2Yoa2V5KTtcbiAgICB2YXIgaW5kZXggPSBwcmV2SW5kZXggPT09IC0xID8ga2V5cy5sZW5ndGggOiBwcmV2SW5kZXg7XG4gICAga2V5c1tpbmRleF0gPSBrZXk7XG4gICAgdmFsdWVzW2luZGV4XSA9IHZhbHVlO1xuICB9O1xuXG4gIHJldHVybiBQb2x5TWFwO1xufSgpO1xuXG4vKlxuZWdqcy1saXN0LWRpZmZlclxuQ29weXJpZ2h0IChjKSAyMDE5LXByZXNlbnQgTkFWRVIgQ29ycC5cbk1JVCBsaWNlbnNlXG4qL1xudmFyIEhhc2hNYXAgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBIYXNoTWFwKCkge1xuICAgIHRoaXMub2JqZWN0ID0ge307XG4gIH1cblxuICB2YXIgX19wcm90byA9IEhhc2hNYXAucHJvdG90eXBlO1xuXG4gIF9fcHJvdG8uZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiB0aGlzLm9iamVjdFtrZXldO1xuICB9O1xuXG4gIF9fcHJvdG8uc2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICB0aGlzLm9iamVjdFtrZXldID0gdmFsdWU7XG4gIH07XG5cbiAgcmV0dXJuIEhhc2hNYXA7XG59KCk7XG5cbi8qXG5lZ2pzLWxpc3QtZGlmZmVyXG5Db3B5cmlnaHQgKGMpIDIwMTktcHJlc2VudCBOQVZFUiBDb3JwLlxuTUlUIGxpY2Vuc2VcbiovXG52YXIgU1VQUE9SVF9NQVAgPSB0eXBlb2YgTWFwID09PSBcImZ1bmN0aW9uXCI7XG5cbi8qXG5lZ2pzLWxpc3QtZGlmZmVyXG5Db3B5cmlnaHQgKGMpIDIwMTktcHJlc2VudCBOQVZFUiBDb3JwLlxuTUlUIGxpY2Vuc2VcbiovXG52YXIgTGluayA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIExpbmsoKSB7fVxuXG4gIHZhciBfX3Byb3RvID0gTGluay5wcm90b3R5cGU7XG5cbiAgX19wcm90by5jb25uZWN0ID0gZnVuY3Rpb24gKHByZXZMaW5rLCBuZXh0TGluaykge1xuICAgIHRoaXMucHJldiA9IHByZXZMaW5rO1xuICAgIHRoaXMubmV4dCA9IG5leHRMaW5rO1xuICAgIHByZXZMaW5rICYmIChwcmV2TGluay5uZXh0ID0gdGhpcyk7XG4gICAgbmV4dExpbmsgJiYgKG5leHRMaW5rLnByZXYgPSB0aGlzKTtcbiAgfTtcblxuICBfX3Byb3RvLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gSW4gZG91YmxlIGxpbmtlZCBsaXN0LCBkaWNvbm5lY3QgdGhlIGludGVyY29ubmVjdGVkIHJlbGF0aW9uc2hpcC5cbiAgICB2YXIgcHJldkxpbmsgPSB0aGlzLnByZXY7XG4gICAgdmFyIG5leHRMaW5rID0gdGhpcy5uZXh0O1xuICAgIHByZXZMaW5rICYmIChwcmV2TGluay5uZXh0ID0gbmV4dExpbmspO1xuICAgIG5leHRMaW5rICYmIChuZXh0TGluay5wcmV2ID0gcHJldkxpbmspO1xuICB9O1xuXG4gIF9fcHJvdG8uZ2V0SW5kZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxpbmsgPSB0aGlzO1xuICAgIHZhciBpbmRleCA9IC0xO1xuXG4gICAgd2hpbGUgKGxpbmspIHtcbiAgICAgIGxpbmsgPSBsaW5rLnByZXY7XG4gICAgICArK2luZGV4O1xuICAgIH1cblxuICAgIHJldHVybiBpbmRleDtcbiAgfTtcblxuICByZXR1cm4gTGluaztcbn0oKTtcblxuLypcbmVnanMtbGlzdC1kaWZmZXJcbkNvcHlyaWdodCAoYykgMjAxOS1wcmVzZW50IE5BVkVSIENvcnAuXG5NSVQgbGljZW5zZVxuKi9cblxuZnVuY3Rpb24gb3JkZXJDaGFuZ2VkKGNoYW5nZWQsIGZpeGVkKSB7XG4gIC8vIEl0IGlzIHJvdWdobHkgaW4gdGhlIG9yZGVyIG9mIHRoZXNlIGV4YW1wbGVzLlxuICAvLyA0LCA2LCAwLCAyLCAxLCAzLCA1LCA3XG4gIHZhciBmcm9tTGlua3MgPSBbXTsgLy8gMCwgMSwgMiwgMywgNCwgNSwgNiwgN1xuXG4gIHZhciB0b0xpbmtzID0gW107XG4gIGNoYW5nZWQuZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgZnJvbSA9IF9hWzBdLFxuICAgICAgICB0byA9IF9hWzFdO1xuICAgIHZhciBsaW5rID0gbmV3IExpbmsoKTtcbiAgICBmcm9tTGlua3NbZnJvbV0gPSBsaW5rO1xuICAgIHRvTGlua3NbdG9dID0gbGluaztcbiAgfSk7IC8vIGBmcm9tTGlua3NgIGFyZSBjb25uZWN0ZWQgdG8gZWFjaCBvdGhlciBieSBkb3VibGUgbGlua2VkIGxpc3QuXG5cbiAgZnJvbUxpbmtzLmZvckVhY2goZnVuY3Rpb24gKGxpbmssIGkpIHtcbiAgICBsaW5rLmNvbm5lY3QoZnJvbUxpbmtzW2kgLSAxXSk7XG4gIH0pO1xuICByZXR1cm4gY2hhbmdlZC5maWx0ZXIoZnVuY3Rpb24gKF8sIGkpIHtcbiAgICByZXR1cm4gIWZpeGVkW2ldO1xuICB9KS5tYXAoZnVuY3Rpb24gKF9hLCBpKSB7XG4gICAgdmFyIGZyb20gPSBfYVswXSxcbiAgICAgICAgdG8gPSBfYVsxXTtcblxuICAgIGlmIChmcm9tID09PSB0bykge1xuICAgICAgcmV0dXJuIFswLCAwXTtcbiAgICB9XG5cbiAgICB2YXIgZnJvbUxpbmsgPSBmcm9tTGlua3NbZnJvbV07XG4gICAgdmFyIHRvTGluayA9IHRvTGlua3NbdG8gLSAxXTtcbiAgICB2YXIgZnJvbUluZGV4ID0gZnJvbUxpbmsuZ2V0SW5kZXgoKTsgLy8gRGlzY29ubmVjdCB0aGUgbGluayBjb25uZWN0ZWQgdG8gYGZyb21MaW5rYC5cblxuICAgIGZyb21MaW5rLmRpc2Nvbm5lY3QoKTsgLy8gQ29ubmVjdCBgZnJvbUxpbmtgIHRvIHRoZSByaWdodCBvZiBgdG9MaW5rYC5cblxuICAgIGlmICghdG9MaW5rKSB7XG4gICAgICBmcm9tTGluay5jb25uZWN0KHVuZGVmaW5lZCwgZnJvbUxpbmtzWzBdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZnJvbUxpbmsuY29ubmVjdCh0b0xpbmssIHRvTGluay5uZXh0KTtcbiAgICB9XG5cbiAgICB2YXIgdG9JbmRleCA9IGZyb21MaW5rLmdldEluZGV4KCk7XG4gICAgcmV0dXJuIFtmcm9tSW5kZXgsIHRvSW5kZXhdO1xuICB9KTtcbn1cblxudmFyIFJlc3VsdCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFJlc3VsdChwcmV2TGlzdCwgbGlzdCwgYWRkZWQsIHJlbW92ZWQsIGNoYW5nZWQsIG1haW50YWluZWQsIGNoYW5nZWRCZWZvcmVBZGRlZCwgZml4ZWQpIHtcbiAgICB0aGlzLnByZXZMaXN0ID0gcHJldkxpc3Q7XG4gICAgdGhpcy5saXN0ID0gbGlzdDtcbiAgICB0aGlzLmFkZGVkID0gYWRkZWQ7XG4gICAgdGhpcy5yZW1vdmVkID0gcmVtb3ZlZDtcbiAgICB0aGlzLmNoYW5nZWQgPSBjaGFuZ2VkO1xuICAgIHRoaXMubWFpbnRhaW5lZCA9IG1haW50YWluZWQ7XG4gICAgdGhpcy5jaGFuZ2VkQmVmb3JlQWRkZWQgPSBjaGFuZ2VkQmVmb3JlQWRkZWQ7XG4gICAgdGhpcy5maXhlZCA9IGZpeGVkO1xuICB9XG5cbiAgdmFyIF9fcHJvdG8gPSBSZXN1bHQucHJvdG90eXBlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJvcmRlcmVkXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghdGhpcy5jYWNoZU9yZGVyZWQpIHtcbiAgICAgICAgdGhpcy5jYWN1bGF0ZU9yZGVyZWQoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuY2FjaGVPcmRlcmVkO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcInB1cmVDaGFuZ2VkXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghdGhpcy5jYWNoZVB1cmVDaGFuZ2VkKSB7XG4gICAgICAgIHRoaXMuY2FjdWxhdGVPcmRlcmVkKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmNhY2hlUHVyZUNoYW5nZWQ7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcblxuICBfX3Byb3RvLmNhY3VsYXRlT3JkZXJlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3JkZXJlZCA9IG9yZGVyQ2hhbmdlZCh0aGlzLmNoYW5nZWRCZWZvcmVBZGRlZCwgdGhpcy5maXhlZCk7XG4gICAgdmFyIGNoYW5nZWQgPSB0aGlzLmNoYW5nZWQ7XG4gICAgdmFyIHB1cmVDaGFuZ2VkID0gW107XG4gICAgdGhpcy5jYWNoZU9yZGVyZWQgPSBvcmRlcmVkLmZpbHRlcihmdW5jdGlvbiAoX2EsIGkpIHtcbiAgICAgIHZhciBmcm9tID0gX2FbMF0sXG4gICAgICAgICAgdG8gPSBfYVsxXTtcbiAgICAgIHZhciBfYiA9IGNoYW5nZWRbaV0sXG4gICAgICAgICAgZnJvbUJlZm9yZSA9IF9iWzBdLFxuICAgICAgICAgIHRvQmVmb3JlID0gX2JbMV07XG5cbiAgICAgIGlmIChmcm9tICE9PSB0bykge1xuICAgICAgICBwdXJlQ2hhbmdlZC5wdXNoKFtmcm9tQmVmb3JlLCB0b0JlZm9yZV0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmNhY2hlUHVyZUNoYW5nZWQgPSBwdXJlQ2hhbmdlZDtcbiAgfTtcblxuICByZXR1cm4gUmVzdWx0O1xufSgpO1xuXG4vKipcbiAqXG4gKiBAbWVtYmVyb2YgZWcuTGlzdERpZmZlclxuICogQHN0YXRpY1xuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0gLSBQcmV2aW91cyBMaXN0IDxrbz4g7J207KCEIOuqqeuhnSA8L2tvPlxuICogQHBhcmFtIC0gTGlzdCB0byBVcGRhdGUgPGtvPiDsl4XrjbDsnbTtirgg7ZWgIOuqqeuhnSA8L2tvPlxuICogQHBhcmFtIC0gVGhpcyBjYWxsYmFjayBmdW5jdGlvbiByZXR1cm5zIHRoZSBrZXkgb2YgdGhlIGl0ZW0uIDxrbz4g7JWE7J207YWc7J2YIO2CpOulvCDrsJjtmZjtlZjripQg7L2c67CxIO2VqOyImOyeheuLiOuLpC48L2tvPlxuICogQHJldHVybiAtIFJldHVybnMgdGhlIGRpZmYgYmV0d2VlbiBgcHJldkxpc3RgIGFuZCBgbGlzdGAgPGtvPiBgcHJldkxpc3Rg7JmAIGBsaXN0YOydmCDri6Trpbgg7KCQ7J2EIOuwmO2ZmO2VnOuLpC48L2tvPlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IGRpZmYgfSBmcm9tIFwiQGVnanMvbGlzdC1kaWZmZXJcIjtcbiAqIC8vIHNjcmlwdCA9PiBlZy5MaXN0RGlmZmVyLmRpZmZcbiAqIGNvbnN0IHJlc3VsdCA9IGRpZmYoWzAsIDEsIDIsIDMsIDQsIDVdLCBbNywgOCwgMCwgNCwgMywgNiwgMiwgMV0sIGUgPT4gZSk7XG4gKiAvLyBMaXN0IGJlZm9yZSB1cGRhdGVcbiAqIC8vIFsxLCAyLCAzLCA0LCA1XVxuICogY29uc29sZS5sb2cocmVzdWx0LnByZXZMaXN0KTtcbiAqIC8vIFVwZGF0ZWQgbGlzdFxuICogLy8gWzQsIDMsIDYsIDIsIDFdXG4gKiBjb25zb2xlLmxvZyhyZXN1bHQubGlzdCk7XG4gKiAvLyBJbmRleCBhcnJheSBvZiB2YWx1ZXMgYWRkZWQgdG8gYGxpc3RgXG4gKiAvLyBbMCwgMSwgNV1cbiAqIGNvbnNvbGUubG9nKHJlc3VsdC5hZGRlZCk7XG4gKiAvLyBJbmRleCBhcnJheSBvZiB2YWx1ZXMgcmVtb3ZlZCBpbiBgcHJldkxpc3RgXG4gKiAvLyBbNV1cbiAqIGNvbnNvbGUubG9nKHJlc3VsdC5yZW1vdmVkKTtcbiAqIC8vIEFuIGFycmF5IG9mIGluZGV4IHBhaXJzIG9mIGBwcmV2TGlzdGAgYW5kIGBsaXN0YCB3aXRoIGRpZmZlcmVudCBpbmRleGVzIGZyb20gYHByZXZMaXN0YCBhbmQgYGxpc3RgXG4gKiAvLyBbWzAsIDJdLCBbNCwgM10sIFszLCA0XSwgWzIsIDZdLCBbMSwgN11dXG4gKiBjb25zb2xlLmxvZyhyZXN1bHQuY2hhbmdlZCk7XG4gKiAvLyBUaGUgc3Vic2V0IG9mIGBjaGFuZ2VkYCBhbmQgYW4gYXJyYXkgb2YgaW5kZXggcGFpcnMgdGhhdCBtb3ZlZCBkYXRhIGRpcmVjdGx5LiBJbmRpY2F0ZSBhbiBhcnJheSBvZiBhYnNvbHV0ZSBpbmRleCBwYWlycyBvZiBgb3JkZXJlZGAuKEZvcm1hdHRlZCBieTogQXJyYXk8W2luZGV4IG9mIHByZXZMaXN0LCBpbmRleCBvZiBsaXN0XT4pXG4gKiAvLyBbWzQsIDNdLCBbMywgNF0sIFsyLCA2XV1cbiAqIGNvbnNvbGUubG9nKHJlc3VsdC5wdXJlQ2hhbmdlZCk7XG4gKiAvLyBBbiBhcnJheSBvZiBpbmRleCBwYWlycyB0byBiZSBgb3JkZXJlZGAgdGhhdCBjYW4gc3luY2hyb25pemUgYGxpc3RgIGJlZm9yZSBhZGRpbmcgZGF0YS4gKEZvcm1hdHRlZCBieTogQXJyYXk8W3ByZXZJbmRleCwgbmV4dEluZGV4XT4pXG4gKiAvLyBbWzQsIDFdLCBbNCwgMl0sIFs0LCAzXV1cbiAqIGNvbnNvbGUubG9nKHJlc3VsdC5vcmRlcmVkKTtcbiAqIC8vIEFuIGFycmF5IG9mIGluZGV4IHBhaXJzIG9mIGBwcmV2TGlzdGAgYW5kIGBsaXN0YCB0aGF0IGhhdmUgbm90IGJlZW4gYWRkZWQvcmVtb3ZlZCBzbyBkYXRhIGlzIHByZXNlcnZlZFxuICogLy8gW1swLCAyXSwgWzQsIDNdLCBbMywgNF0sIFsyLCA2XSwgWzEsIDddXVxuICogY29uc29sZS5sb2cocmVzdWx0Lm1haW50YWluZWQpO1xuICovXG5cbmZ1bmN0aW9uIGRpZmYocHJldkxpc3QsIGxpc3QsIGZpbmRLZXlDYWxsYmFjaykge1xuICB2YXIgbWFwQ2xhc3MgPSBTVVBQT1JUX01BUCA/IE1hcCA6IGZpbmRLZXlDYWxsYmFjayA/IEhhc2hNYXAgOiBQb2x5TWFwO1xuXG4gIHZhciBjYWxsYmFjayA9IGZpbmRLZXlDYWxsYmFjayB8fCBmdW5jdGlvbiAoZSkge1xuICAgIHJldHVybiBlO1xuICB9O1xuXG4gIHZhciBhZGRlZCA9IFtdO1xuICB2YXIgcmVtb3ZlZCA9IFtdO1xuICB2YXIgbWFpbnRhaW5lZCA9IFtdO1xuICB2YXIgcHJldktleXMgPSBwcmV2TGlzdC5tYXAoY2FsbGJhY2spO1xuICB2YXIga2V5cyA9IGxpc3QubWFwKGNhbGxiYWNrKTtcbiAgdmFyIHByZXZLZXlNYXAgPSBuZXcgbWFwQ2xhc3MoKTtcbiAgdmFyIGtleU1hcCA9IG5ldyBtYXBDbGFzcygpO1xuICB2YXIgY2hhbmdlZEJlZm9yZUFkZGVkID0gW107XG4gIHZhciBmaXhlZCA9IFtdO1xuICB2YXIgcmVtb3ZlZE1hcCA9IHt9O1xuICB2YXIgY2hhbmdlZCA9IFtdO1xuICB2YXIgYWRkZWRDb3VudCA9IDA7XG4gIHZhciByZW1vdmVkQ291bnQgPSAwOyAvLyBBZGQgcHJldktleXMgYW5kIGtleXMgdG8gdGhlIGhhc2htYXAuXG5cbiAgcHJldktleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5LCBwcmV2TGlzdEluZGV4KSB7XG4gICAgcHJldktleU1hcC5zZXQoa2V5LCBwcmV2TGlzdEluZGV4KTtcbiAgfSk7XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5LCBsaXN0SW5kZXgpIHtcbiAgICBrZXlNYXAuc2V0KGtleSwgbGlzdEluZGV4KTtcbiAgfSk7IC8vIENvbXBhcmUgYHByZXZLZXlzYCBhbmQgYGtleXNgIGFuZCBhZGQgdGhlbSB0byBgcmVtb3ZlZGAgaWYgdGhleSBhcmUgbm90IGluIGBrZXlzYC5cblxuICBwcmV2S2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXksIHByZXZMaXN0SW5kZXgpIHtcbiAgICB2YXIgbGlzdEluZGV4ID0ga2V5TWFwLmdldChrZXkpOyAvLyBJbiBwcmV2TGlzdCwgYnV0IG5vdCBpbiBsaXN0LCBpdCBpcyByZW1vdmVkLlxuXG4gICAgaWYgKHR5cGVvZiBsaXN0SW5kZXggPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICsrcmVtb3ZlZENvdW50O1xuICAgICAgcmVtb3ZlZC5wdXNoKHByZXZMaXN0SW5kZXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZW1vdmVkTWFwW2xpc3RJbmRleF0gPSByZW1vdmVkQ291bnQ7XG4gICAgfVxuICB9KTsgLy8gQ29tcGFyZSBgcHJldktleXNgIGFuZCBga2V5c2AgYW5kIGFkZCB0aGVtIHRvIGBhZGRlZGAgaWYgdGhleSBhcmUgbm90IGluIGBwcmV2S2V5c2AuXG5cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXksIGxpc3RJbmRleCkge1xuICAgIHZhciBwcmV2TGlzdEluZGV4ID0gcHJldktleU1hcC5nZXQoa2V5KTsgLy8gSW4gbGlzdCwgYnV0IG5vdCBpbiBwcmV2TGlzdCwgaXQgaXMgYWRkZWQuXG5cbiAgICBpZiAodHlwZW9mIHByZXZMaXN0SW5kZXggPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGFkZGVkLnB1c2gobGlzdEluZGV4KTtcbiAgICAgICsrYWRkZWRDb3VudDtcbiAgICB9IGVsc2Uge1xuICAgICAgbWFpbnRhaW5lZC5wdXNoKFtwcmV2TGlzdEluZGV4LCBsaXN0SW5kZXhdKTtcbiAgICAgIHJlbW92ZWRDb3VudCA9IHJlbW92ZWRNYXBbbGlzdEluZGV4XSB8fCAwO1xuICAgICAgY2hhbmdlZEJlZm9yZUFkZGVkLnB1c2goW3ByZXZMaXN0SW5kZXggLSByZW1vdmVkQ291bnQsIGxpc3RJbmRleCAtIGFkZGVkQ291bnRdKTtcbiAgICAgIGZpeGVkLnB1c2gobGlzdEluZGV4ID09PSBwcmV2TGlzdEluZGV4KTtcblxuICAgICAgaWYgKHByZXZMaXN0SW5kZXggIT09IGxpc3RJbmRleCkge1xuICAgICAgICBjaGFuZ2VkLnB1c2goW3ByZXZMaXN0SW5kZXgsIGxpc3RJbmRleF0pO1xuICAgICAgfVxuICAgIH1cbiAgfSk7IC8vIFNvcnQgYnkgYXNjZW5kaW5nIG9yZGVyIG9mICd0byhsaXN0J3MgaW5kZXgpLlxuXG4gIHJlbW92ZWQucmV2ZXJzZSgpO1xuICByZXR1cm4gbmV3IFJlc3VsdChwcmV2TGlzdCwgbGlzdCwgYWRkZWQsIHJlbW92ZWQsIGNoYW5nZWQsIG1haW50YWluZWQsIGNoYW5nZWRCZWZvcmVBZGRlZCwgZml4ZWQpO1xufVxuXG4vKipcbiAqIEEgbW9kdWxlIHRoYXQgY2hlY2tzIGRpZmYgd2hlbiB2YWx1ZXMgYXJlIGFkZGVkLCByZW1vdmVkLCBvciBjaGFuZ2VkIGluIGFuIGFycmF5LlxuICogQGtvIOuwsOyXtCDrmJDripQg7Jik67iM7KCd7Yq47JeQ7IScIOqwkuydtCDstpTqsIDrkJjqsbDrgpgg7IKt7KCc65CY6rGw64KYIOyInOyEnOqwgCDrs4Dqsr3sgqztla3snYQg7LK07YGs7ZWY64qUIOuqqOuTiOyeheuLiOuLpC5cbiAqIEBtZW1iZXJvZiBlZ1xuICovXG5cbnZhciBMaXN0RGlmZmVyID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSAtIEluaXRpYWxpemluZyBEYXRhIEFycmF5LiA8a28+IOy0iOq4sCDshKTsoJXtlaAg642w7J207YSwIOuwsOyXtC48L2tvPlxuICAgKiBAcGFyYW0gLSBUaGlzIGNhbGxiYWNrIGZ1bmN0aW9uIHJldHVybnMgdGhlIGtleSBvZiB0aGUgaXRlbS4gPGtvPiDslYTsnbTthZzsnZgg7YKk66W8IOuwmO2ZmO2VmOuKlCDsvZzrsLEg7ZWo7IiY7J6F64uI64ukLjwva28+XG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCBMaXN0RGlmZmVyIGZyb20gXCJAZWdqcy9saXN0LWRpZmZlclwiO1xuICAgKiAvLyBzY3JpcHQgPT4gZWcuTGlzdERpZmZlclxuICAgKiBjb25zdCBkaWZmZXIgPSBuZXcgTGlzdERpZmZlcihbMCwgMSwgMiwgMywgNCwgNV0sIGUgPT4gZSk7XG4gICAqIGNvbnN0IHJlc3VsdCA9IGRpZmZlci51cGRhdGUoWzcsIDgsIDAsIDQsIDMsIDYsIDIsIDFdKTtcbiAgICogLy8gTGlzdCBiZWZvcmUgdXBkYXRlXG4gICAqIC8vIFsxLCAyLCAzLCA0LCA1XVxuICAgKiBjb25zb2xlLmxvZyhyZXN1bHQucHJldkxpc3QpO1xuICAgKiAvLyBVcGRhdGVkIGxpc3RcbiAgICogLy8gWzQsIDMsIDYsIDIsIDFdXG4gICAqIGNvbnNvbGUubG9nKHJlc3VsdC5saXN0KTtcbiAgICogLy8gSW5kZXggYXJyYXkgb2YgdmFsdWVzIGFkZGVkIHRvIGBsaXN0YC5cbiAgICogLy8gWzAsIDEsIDVdXG4gICAqIGNvbnNvbGUubG9nKHJlc3VsdC5hZGRlZCk7XG4gICAqIC8vIEluZGV4IGFycmF5IG9mIHZhbHVlcyByZW1vdmVkIGluIGBwcmV2TGlzdGAuXG4gICAqIC8vIFs1XVxuICAgKiBjb25zb2xlLmxvZyhyZXN1bHQucmVtb3ZlZCk7XG4gICAqIC8vIEFuIGFycmF5IG9mIGluZGV4IHBhaXJzIG9mIGBwcmV2TGlzdGAgYW5kIGBsaXN0YCB3aXRoIGRpZmZlcmVudCBpbmRleGVzIGZyb20gYHByZXZMaXN0YCBhbmQgYGxpc3RgLlxuICAgKiAvLyBbWzAsIDJdLCBbNCwgM10sIFszLCA0XSwgWzIsIDZdLCBbMSwgN11dXG4gICAqIGNvbnNvbGUubG9nKHJlc3VsdC5jaGFuZ2VkKTtcbiAgICogLy8gVGhlIHN1YnNldCBvZiBgY2hhbmdlZGAgYW5kIGFuIGFycmF5IG9mIGluZGV4IHBhaXJzIHRoYXQgbW92ZWQgZGF0YSBkaXJlY3RseS4gSW5kaWNhdGUgYW4gYXJyYXkgb2YgYWJzb2x1dGUgaW5kZXggcGFpcnMgb2YgYG9yZGVyZWRgLihGb3JtYXR0ZWQgYnk6IEFycmF5PFtpbmRleCBvZiBwcmV2TGlzdCwgaW5kZXggb2YgbGlzdF0+KVxuICAgKiAvLyBbWzQsIDNdLCBbMywgNF0sIFsyLCA2XV1cbiAgICogY29uc29sZS5sb2cocmVzdWx0LnB1cmVDaGFuZ2VkKTtcbiAgICogLy8gQW4gYXJyYXkgb2YgaW5kZXggcGFpcnMgdG8gYmUgYG9yZGVyZWRgIHRoYXQgY2FuIHN5bmNocm9uaXplIGBsaXN0YCBiZWZvcmUgYWRkaW5nIGRhdGEuIChGb3JtYXR0ZWQgYnk6IEFycmF5PFtwcmV2SW5kZXgsIG5leHRJbmRleF0+KVxuICAgKiAvLyBbWzQsIDFdLCBbNCwgMl0sIFs0LCAzXV1cbiAgICogY29uc29sZS5sb2cocmVzdWx0Lm9yZGVyZWQpO1xuICAgKiAvLyBBbiBhcnJheSBvZiBpbmRleCBwYWlycyBvZiBgcHJldkxpc3RgIGFuZCBgbGlzdGAgdGhhdCBoYXZlIG5vdCBiZWVuIGFkZGVkL3JlbW92ZWQgc28gZGF0YSBpcyBwcmVzZXJ2ZWQuXG4gICAqIC8vIFtbMCwgMl0sIFs0LCAzXSwgWzMsIDRdLCBbMiwgNl0sIFsxLCA3XV1cbiAgICogY29uc29sZS5sb2cocmVzdWx0Lm1haW50YWluZWQpO1xuICAgKi9cbiAgZnVuY3Rpb24gTGlzdERpZmZlcihsaXN0LCBmaW5kS2V5Q2FsbGJhY2spIHtcbiAgICBpZiAobGlzdCA9PT0gdm9pZCAwKSB7XG4gICAgICBsaXN0ID0gW107XG4gICAgfVxuXG4gICAgdGhpcy5maW5kS2V5Q2FsbGJhY2sgPSBmaW5kS2V5Q2FsbGJhY2s7XG4gICAgdGhpcy5saXN0ID0gW10uc2xpY2UuY2FsbChsaXN0KTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlIGxpc3QuXG4gICAqIEBrbyDrpqzsiqTtirjrpbwg7JeF642w7J207Yq466W8IO2VqeuLiOuLpC5cbiAgICogQHBhcmFtIC0gTGlzdCB0byB1cGRhdGUgPGtvPiDsl4XrjbDsnbTtirjtlaAg66as7Iqk7Yq4IDwva28+XG4gICAqIEByZXR1cm4gLSBSZXR1cm5zIHRoZSByZXN1bHRzIG9mIGFuIHVwZGF0ZSBmcm9tIGBwcmV2TGlzdGAgdG8gYGxpc3RgLjxrbz4gYHByZXZMaXN0YOyXkOyEnCBgbGlzdGDroZwg7JeF642w7J207Yq47ZWcIOqysOqzvOulvCDrsJjtmZjtlZzri6QuIDwva28+XG4gICAqL1xuXG5cbiAgdmFyIF9fcHJvdG8gPSBMaXN0RGlmZmVyLnByb3RvdHlwZTtcblxuICBfX3Byb3RvLnVwZGF0ZSA9IGZ1bmN0aW9uIChsaXN0KSB7XG4gICAgdmFyIG5ld0RhdGEgPSBbXS5zbGljZS5jYWxsKGxpc3QpO1xuICAgIHZhciByZXN1bHQgPSBkaWZmKHRoaXMubGlzdCwgbmV3RGF0YSwgdGhpcy5maW5kS2V5Q2FsbGJhY2spO1xuICAgIHRoaXMubGlzdCA9IG5ld0RhdGE7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICByZXR1cm4gTGlzdERpZmZlcjtcbn0oKTtcblxuLypcbkNvcHlyaWdodCAoYykgMjAxNSBOQVZFUiBDb3JwLlxubmFtZTogQGVnanMvYWdlbnRcbmxpY2Vuc2U6IE1JVFxuYXV0aG9yOiBOQVZFUiBDb3JwLlxucmVwb3NpdG9yeTogZ2l0K2h0dHBzOi8vZ2l0aHViLmNvbS9uYXZlci9hZ2VudC5naXRcbnZlcnNpb246IDIuNC4zXG4qL1xuZnVuY3Rpb24gc29tZShhcnIsIGNhbGxiYWNrKSB7XG4gIHZhciBsZW5ndGggPSBhcnIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoY2FsbGJhY2soYXJyW2ldLCBpKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZmluZChhcnIsIGNhbGxiYWNrKSB7XG4gIHZhciBsZW5ndGggPSBhcnIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoY2FsbGJhY2soYXJyW2ldLCBpKSkge1xuICAgICAgcmV0dXJuIGFycltpXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGdldFVzZXJBZ2VudFN0cmluZyhhZ2VudCkge1xuICB2YXIgdXNlckFnZW50ID0gYWdlbnQ7XG5cbiAgaWYgKHR5cGVvZiB1c2VyQWdlbnQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBpZiAodHlwZW9mIG5hdmlnYXRvciA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhbmF2aWdhdG9yKSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG5cbiAgICB1c2VyQWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50IHx8IFwiXCI7XG4gIH1cblxuICByZXR1cm4gdXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XG59XG5mdW5jdGlvbiBleGVjUmVnRXhwKHBhdHRlcm4sIHRleHQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChwYXR0ZXJuLCBcImdcIikuZXhlYyh0ZXh0KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5mdW5jdGlvbiBoYXNVc2VyQWdlbnREYXRhKCkge1xuICBpZiAodHlwZW9mIG5hdmlnYXRvciA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhbmF2aWdhdG9yIHx8ICFuYXZpZ2F0b3IudXNlckFnZW50RGF0YSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciB1c2VyQWdlbnREYXRhID0gbmF2aWdhdG9yLnVzZXJBZ2VudERhdGE7XG4gIHZhciBicmFuZHMgPSB1c2VyQWdlbnREYXRhLmJyYW5kcyB8fCB1c2VyQWdlbnREYXRhLnVhTGlzdDtcbiAgcmV0dXJuICEhKGJyYW5kcyAmJiBicmFuZHMubGVuZ3RoKTtcbn1cbmZ1bmN0aW9uIGZpbmRWZXJzaW9uKHZlcnNpb25UZXN0LCB1c2VyQWdlbnQpIHtcbiAgdmFyIHJlc3VsdCA9IGV4ZWNSZWdFeHAoXCIoXCIgKyB2ZXJzaW9uVGVzdCArIFwiKSgoPzpcXFxcL3xcXFxcc3w6KShbMC05fFxcXFwufF9dKykpXCIsIHVzZXJBZ2VudCk7XG4gIHJldHVybiByZXN1bHQgPyByZXN1bHRbM10gOiBcIlwiO1xufVxuZnVuY3Rpb24gY29udmVydFZlcnNpb24odGV4dCkge1xuICByZXR1cm4gdGV4dC5yZXBsYWNlKC9fL2csIFwiLlwiKTtcbn1cbmZ1bmN0aW9uIGZpbmRQcmVzZXQocHJlc2V0cywgdXNlckFnZW50KSB7XG4gIHZhciB1c2VyUHJlc2V0ID0gbnVsbDtcbiAgdmFyIHZlcnNpb24gPSBcIi0xXCI7XG4gIHNvbWUocHJlc2V0cywgZnVuY3Rpb24gKHByZXNldCkge1xuICAgIHZhciByZXN1bHQgPSBleGVjUmVnRXhwKFwiKFwiICsgcHJlc2V0LnRlc3QgKyBcIikoKD86XFxcXC98XFxcXHN8OikoWzAtOXxcXFxcLnxfXSspKT9cIiwgdXNlckFnZW50KTtcblxuICAgIGlmICghcmVzdWx0IHx8IHByZXNldC5icmFuZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHVzZXJQcmVzZXQgPSBwcmVzZXQ7XG4gICAgdmVyc2lvbiA9IHJlc3VsdFszXSB8fCBcIi0xXCI7XG5cbiAgICBpZiAocHJlc2V0LnZlcnNpb25BbGlhcykge1xuICAgICAgdmVyc2lvbiA9IHByZXNldC52ZXJzaW9uQWxpYXM7XG4gICAgfSBlbHNlIGlmIChwcmVzZXQudmVyc2lvblRlc3QpIHtcbiAgICAgIHZlcnNpb24gPSBmaW5kVmVyc2lvbihwcmVzZXQudmVyc2lvblRlc3QudG9Mb3dlckNhc2UoKSwgdXNlckFnZW50KSB8fCB2ZXJzaW9uO1xuICAgIH1cblxuICAgIHZlcnNpb24gPSBjb252ZXJ0VmVyc2lvbih2ZXJzaW9uKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgcHJlc2V0OiB1c2VyUHJlc2V0LFxuICAgIHZlcnNpb246IHZlcnNpb25cbiAgfTtcbn1cbmZ1bmN0aW9uIGZpbmRQcmVzZXRCcmFuZChwcmVzZXRzLCBicmFuZHMpIHtcbiAgdmFyIGJyYW5kSW5mbyA9IHtcbiAgICBicmFuZDogXCJcIixcbiAgICB2ZXJzaW9uOiBcIi0xXCJcbiAgfTtcbiAgc29tZShwcmVzZXRzLCBmdW5jdGlvbiAocHJlc2V0KSB7XG4gICAgdmFyIHJlc3VsdCA9IGZpbmRCcmFuZChicmFuZHMsIHByZXNldCk7XG5cbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGJyYW5kSW5mby5icmFuZCA9IHByZXNldC5pZDtcbiAgICBicmFuZEluZm8udmVyc2lvbiA9IHByZXNldC52ZXJzaW9uQWxpYXMgfHwgcmVzdWx0LnZlcnNpb247XG4gICAgcmV0dXJuIGJyYW5kSW5mby52ZXJzaW9uICE9PSBcIi0xXCI7XG4gIH0pO1xuICByZXR1cm4gYnJhbmRJbmZvO1xufVxuZnVuY3Rpb24gZmluZEJyYW5kKGJyYW5kcywgcHJlc2V0KSB7XG4gIHJldHVybiBmaW5kKGJyYW5kcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIGJyYW5kID0gX2EuYnJhbmQ7XG4gICAgcmV0dXJuIGV4ZWNSZWdFeHAoXCJcIiArIHByZXNldC50ZXN0LCBicmFuZC50b0xvd2VyQ2FzZSgpKTtcbiAgfSk7XG59XG5cbnZhciBCUk9XU0VSX1BSRVNFVFMgPSBbe1xuICB0ZXN0OiBcInBoYW50b21qc1wiLFxuICBpZDogXCJwaGFudG9tanNcIlxufSwge1xuICB0ZXN0OiBcIndoYWxlXCIsXG4gIGlkOiBcIndoYWxlXCJcbn0sIHtcbiAgdGVzdDogXCJlZGdpb3N8ZWRnZXxlZGdcIixcbiAgaWQ6IFwiZWRnZVwiXG59LCB7XG4gIHRlc3Q6IFwibXNpZXx0cmlkZW50fHdpbmRvd3MgcGhvbmVcIixcbiAgaWQ6IFwiaWVcIixcbiAgdmVyc2lvblRlc3Q6IFwiaWVtb2JpbGV8bXNpZXxydlwiXG59LCB7XG4gIHRlc3Q6IFwibWl1aWJyb3dzZXJcIixcbiAgaWQ6IFwibWl1aSBicm93c2VyXCJcbn0sIHtcbiAgdGVzdDogXCJzYW1zdW5nYnJvd3NlclwiLFxuICBpZDogXCJzYW1zdW5nIGludGVybmV0XCJcbn0sIHtcbiAgdGVzdDogXCJzYW1zdW5nXCIsXG4gIGlkOiBcInNhbXN1bmcgaW50ZXJuZXRcIixcbiAgdmVyc2lvblRlc3Q6IFwidmVyc2lvblwiXG59LCB7XG4gIHRlc3Q6IFwiY2hyb21lfGNyaW9zXCIsXG4gIGlkOiBcImNocm9tZVwiXG59LCB7XG4gIHRlc3Q6IFwiZmlyZWZveHxmeGlvc1wiLFxuICBpZDogXCJmaXJlZm94XCJcbn0sIHtcbiAgdGVzdDogXCJhbmRyb2lkXCIsXG4gIGlkOiBcImFuZHJvaWQgYnJvd3NlclwiLFxuICB2ZXJzaW9uVGVzdDogXCJ2ZXJzaW9uXCJcbn0sIHtcbiAgdGVzdDogXCJzYWZhcml8aXBob25lfGlwYWR8aXBvZFwiLFxuICBpZDogXCJzYWZhcmlcIixcbiAgdmVyc2lvblRlc3Q6IFwidmVyc2lvblwiXG59XTsgLy8gY2hyb21pdW0ncyBlbmdpbmUoYmxpbmspIGlzIGJhc2VkIG9uIGFwcGxld2Via2l0IDUzNy4zNi5cblxudmFyIENIUk9NSVVNX1BSRVNFVFMgPSBbe1xuICB0ZXN0OiBcIig/PS4qYXBwbGV3ZWJraXQvKDUzWzAtN118NVswLTJdfFswLTRdKSkoPz0uKlxcXFxzY2hyb21lKVwiLFxuICBpZDogXCJjaHJvbWVcIixcbiAgdmVyc2lvblRlc3Q6IFwiY2hyb21lXCJcbn0sIHtcbiAgdGVzdDogXCJjaHJvbWl1bVwiLFxuICBpZDogXCJjaHJvbWVcIlxufSwge1xuICB0ZXN0OiBcIndoYWxlXCIsXG4gIGlkOiBcImNocm9tZVwiLFxuICB2ZXJzaW9uQWxpYXM6IFwiLTFcIixcbiAgYnJhbmQ6IHRydWVcbn1dO1xudmFyIFdFQktJVF9QUkVTRVRTID0gW3tcbiAgdGVzdDogXCJhcHBsZXdlYmtpdFwiLFxuICBpZDogXCJ3ZWJraXRcIixcbiAgdmVyc2lvblRlc3Q6IFwiYXBwbGV3ZWJraXR8c2FmYXJpXCJcbn1dO1xudmFyIFdFQlZJRVdfUFJFU0VUUyA9IFt7XG4gIHRlc3Q6IFwiKD89KGlwaG9uZXxpcGFkKSkoPyEoLip2ZXJzaW9uKSlcIixcbiAgaWQ6IFwid2Vidmlld1wiXG59LCB7XG4gIHRlc3Q6IFwiKD89KGFuZHJvaWR8aXBob25lfGlwYWQpKSg/PS4qKG5hdmVyfGRhdW18OyB3dikpXCIsXG4gIGlkOiBcIndlYnZpZXdcIlxufSwge1xuICAvLyB0ZXN0IHdlYnZpZXdcbiAgdGVzdDogXCJ3ZWJ2aWV3XCIsXG4gIGlkOiBcIndlYnZpZXdcIlxufV07XG52YXIgT1NfUFJFU0VUUyA9IFt7XG4gIHRlc3Q6IFwid2luZG93cyBwaG9uZVwiLFxuICBpZDogXCJ3aW5kb3dzIHBob25lXCJcbn0sIHtcbiAgdGVzdDogXCJ3aW5kb3dzIDIwMDBcIixcbiAgaWQ6IFwid2luZG93XCIsXG4gIHZlcnNpb25BbGlhczogXCI1LjBcIlxufSwge1xuICB0ZXN0OiBcIndpbmRvd3MgbnRcIixcbiAgaWQ6IFwid2luZG93XCJcbn0sIHtcbiAgdGVzdDogXCJ3aW4zMnx3aW5kb3dzXCIsXG4gIGlkOiBcIndpbmRvd1wiXG59LCB7XG4gIHRlc3Q6IFwiaXBob25lfGlwYWR8aXBvZFwiLFxuICBpZDogXCJpb3NcIixcbiAgdmVyc2lvblRlc3Q6IFwiaXBob25lIG9zfGNwdSBvc1wiXG59LCB7XG4gIHRlc3Q6IFwibWFjb3N8bWFjaW50ZWx8bWFjIG9zIHhcIixcbiAgaWQ6IFwibWFjXCJcbn0sIHtcbiAgdGVzdDogXCJhbmRyb2lkfGxpbnV4IGFybXY4MVwiLFxuICBpZDogXCJhbmRyb2lkXCJcbn0sIHtcbiAgdGVzdDogXCJ0aXplblwiLFxuICBpZDogXCJ0aXplblwiXG59LCB7XG4gIHRlc3Q6IFwid2Vib3N8d2ViMHNcIixcbiAgaWQ6IFwid2Vib3NcIlxufV07XG5cbmZ1bmN0aW9uIGlzV2ViVmlldyh1c2VyQWdlbnQpIHtcbiAgcmV0dXJuICEhZmluZFByZXNldChXRUJWSUVXX1BSRVNFVFMsIHVzZXJBZ2VudCkucHJlc2V0O1xufVxuZnVuY3Rpb24gZ2V0TGVnYWN5QWdlbnQodXNlckFnZW50KSB7XG4gIHZhciBuZXh0QWdlbnQgPSBnZXRVc2VyQWdlbnRTdHJpbmcodXNlckFnZW50KTtcbiAgdmFyIGlzTW9iaWxlID0gISEvbW9iaS9nLmV4ZWMobmV4dEFnZW50KTtcbiAgdmFyIGJyb3dzZXIgPSB7XG4gICAgbmFtZTogXCJ1bmtub3duXCIsXG4gICAgdmVyc2lvbjogXCItMVwiLFxuICAgIG1ham9yVmVyc2lvbjogLTEsXG4gICAgd2VidmlldzogaXNXZWJWaWV3KG5leHRBZ2VudCksXG4gICAgY2hyb21pdW06IGZhbHNlLFxuICAgIGNocm9taXVtVmVyc2lvbjogXCItMVwiLFxuICAgIHdlYmtpdDogZmFsc2UsXG4gICAgd2Via2l0VmVyc2lvbjogXCItMVwiXG4gIH07XG4gIHZhciBvcyA9IHtcbiAgICBuYW1lOiBcInVua25vd25cIixcbiAgICB2ZXJzaW9uOiBcIi0xXCIsXG4gICAgbWFqb3JWZXJzaW9uOiAtMVxuICB9O1xuXG4gIHZhciBfYSA9IGZpbmRQcmVzZXQoQlJPV1NFUl9QUkVTRVRTLCBuZXh0QWdlbnQpLFxuICAgICAgYnJvd3NlclByZXNldCA9IF9hLnByZXNldCxcbiAgICAgIGJyb3dzZXJWZXJzaW9uID0gX2EudmVyc2lvbjtcblxuICB2YXIgX2IgPSBmaW5kUHJlc2V0KE9TX1BSRVNFVFMsIG5leHRBZ2VudCksXG4gICAgICBvc1ByZXNldCA9IF9iLnByZXNldCxcbiAgICAgIG9zVmVyc2lvbiA9IF9iLnZlcnNpb247XG5cbiAgdmFyIGNocm9taXVtUHJlc2V0ID0gZmluZFByZXNldChDSFJPTUlVTV9QUkVTRVRTLCBuZXh0QWdlbnQpO1xuICBicm93c2VyLmNocm9taXVtID0gISFjaHJvbWl1bVByZXNldC5wcmVzZXQ7XG4gIGJyb3dzZXIuY2hyb21pdW1WZXJzaW9uID0gY2hyb21pdW1QcmVzZXQudmVyc2lvbjtcblxuICBpZiAoIWJyb3dzZXIuY2hyb21pdW0pIHtcbiAgICB2YXIgd2Via2l0UHJlc2V0ID0gZmluZFByZXNldChXRUJLSVRfUFJFU0VUUywgbmV4dEFnZW50KTtcbiAgICBicm93c2VyLndlYmtpdCA9ICEhd2Via2l0UHJlc2V0LnByZXNldDtcbiAgICBicm93c2VyLndlYmtpdFZlcnNpb24gPSB3ZWJraXRQcmVzZXQudmVyc2lvbjtcbiAgfVxuXG4gIGlmIChvc1ByZXNldCkge1xuICAgIG9zLm5hbWUgPSBvc1ByZXNldC5pZDtcbiAgICBvcy52ZXJzaW9uID0gb3NWZXJzaW9uO1xuICAgIG9zLm1ham9yVmVyc2lvbiA9IHBhcnNlSW50KG9zVmVyc2lvbiwgMTApO1xuICB9XG5cbiAgaWYgKGJyb3dzZXJQcmVzZXQpIHtcbiAgICBicm93c2VyLm5hbWUgPSBicm93c2VyUHJlc2V0LmlkO1xuICAgIGJyb3dzZXIudmVyc2lvbiA9IGJyb3dzZXJWZXJzaW9uOyAvLyBFYXJseSB3aGFsZSBidWdzXG5cbiAgICBpZiAoYnJvd3Nlci53ZWJ2aWV3ICYmIG9zLm5hbWUgPT09IFwiaW9zXCIgJiYgYnJvd3Nlci5uYW1lICE9PSBcInNhZmFyaVwiKSB7XG4gICAgICBicm93c2VyLndlYnZpZXcgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBicm93c2VyLm1ham9yVmVyc2lvbiA9IHBhcnNlSW50KGJyb3dzZXIudmVyc2lvbiwgMTApO1xuICByZXR1cm4ge1xuICAgIGJyb3dzZXI6IGJyb3dzZXIsXG4gICAgb3M6IG9zLFxuICAgIGlzTW9iaWxlOiBpc01vYmlsZSxcbiAgICBpc0hpbnRzOiBmYWxzZVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRDbGllbnRIaW50c0FnZW50KG9zRGF0YSkge1xuICB2YXIgdXNlckFnZW50RGF0YSA9IG5hdmlnYXRvci51c2VyQWdlbnREYXRhO1xuICB2YXIgYnJhbmRzID0gKHVzZXJBZ2VudERhdGEudWFMaXN0IHx8IHVzZXJBZ2VudERhdGEuYnJhbmRzKS5zbGljZSgpO1xuICB2YXIgZnVsbFZlcnNpb25MaXN0ID0gb3NEYXRhICYmIG9zRGF0YS5mdWxsVmVyc2lvbkxpc3Q7XG4gIHZhciBpc01vYmlsZSA9IHVzZXJBZ2VudERhdGEubW9iaWxlIHx8IGZhbHNlO1xuICB2YXIgZmlyc3RCcmFuZCA9IGJyYW5kc1swXTtcbiAgdmFyIHBsYXRmb3JtID0gKG9zRGF0YSAmJiBvc0RhdGEucGxhdGZvcm0gfHwgdXNlckFnZW50RGF0YS5wbGF0Zm9ybSB8fCBuYXZpZ2F0b3IucGxhdGZvcm0pLnRvTG93ZXJDYXNlKCk7XG4gIHZhciBicm93c2VyID0ge1xuICAgIG5hbWU6IGZpcnN0QnJhbmQuYnJhbmQsXG4gICAgdmVyc2lvbjogZmlyc3RCcmFuZC52ZXJzaW9uLFxuICAgIG1ham9yVmVyc2lvbjogLTEsXG4gICAgd2Via2l0OiBmYWxzZSxcbiAgICB3ZWJraXRWZXJzaW9uOiBcIi0xXCIsXG4gICAgY2hyb21pdW06IGZhbHNlLFxuICAgIGNocm9taXVtVmVyc2lvbjogXCItMVwiLFxuICAgIHdlYnZpZXc6ICEhZmluZFByZXNldEJyYW5kKFdFQlZJRVdfUFJFU0VUUywgYnJhbmRzKS5icmFuZCB8fCBpc1dlYlZpZXcoZ2V0VXNlckFnZW50U3RyaW5nKCkpXG4gIH07XG4gIHZhciBvcyA9IHtcbiAgICBuYW1lOiBcInVua25vd25cIixcbiAgICB2ZXJzaW9uOiBcIi0xXCIsXG4gICAgbWFqb3JWZXJzaW9uOiAtMVxuICB9O1xuICBicm93c2VyLndlYmtpdCA9ICFicm93c2VyLmNocm9taXVtICYmIHNvbWUoV0VCS0lUX1BSRVNFVFMsIGZ1bmN0aW9uIChwcmVzZXQpIHtcbiAgICByZXR1cm4gZmluZEJyYW5kKGJyYW5kcywgcHJlc2V0KTtcbiAgfSk7XG4gIHZhciBjaHJvbWl1bUJyYW5kID0gZmluZFByZXNldEJyYW5kKENIUk9NSVVNX1BSRVNFVFMsIGJyYW5kcyk7XG4gIGJyb3dzZXIuY2hyb21pdW0gPSAhIWNocm9taXVtQnJhbmQuYnJhbmQ7XG4gIGJyb3dzZXIuY2hyb21pdW1WZXJzaW9uID0gY2hyb21pdW1CcmFuZC52ZXJzaW9uO1xuXG4gIGlmICghYnJvd3Nlci5jaHJvbWl1bSkge1xuICAgIHZhciB3ZWJraXRCcmFuZCA9IGZpbmRQcmVzZXRCcmFuZChXRUJLSVRfUFJFU0VUUywgYnJhbmRzKTtcbiAgICBicm93c2VyLndlYmtpdCA9ICEhd2Via2l0QnJhbmQuYnJhbmQ7XG4gICAgYnJvd3Nlci53ZWJraXRWZXJzaW9uID0gd2Via2l0QnJhbmQudmVyc2lvbjtcbiAgfVxuXG4gIHZhciBwbGF0Zm9tUmVzdWx0ID0gZmluZChPU19QUkVTRVRTLCBmdW5jdGlvbiAocHJlc2V0KSB7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoXCJcIiArIHByZXNldC50ZXN0LCBcImdcIikuZXhlYyhwbGF0Zm9ybSk7XG4gIH0pO1xuICBvcy5uYW1lID0gcGxhdGZvbVJlc3VsdCA/IHBsYXRmb21SZXN1bHQuaWQgOiBcIlwiO1xuXG4gIGlmIChvc0RhdGEpIHtcbiAgICBvcy52ZXJzaW9uID0gb3NEYXRhLnBsYXRmb3JtVmVyc2lvbjtcbiAgfVxuXG4gIGlmIChmdWxsVmVyc2lvbkxpc3QgJiYgZnVsbFZlcnNpb25MaXN0Lmxlbmd0aCkge1xuICAgIHZhciBicm93c2VyQnJhbmRCeUZ1bGxWZXJzaW9uTGlzdCA9IGZpbmRQcmVzZXRCcmFuZChCUk9XU0VSX1BSRVNFVFMsIGZ1bGxWZXJzaW9uTGlzdCk7XG4gICAgYnJvd3Nlci5uYW1lID0gYnJvd3NlckJyYW5kQnlGdWxsVmVyc2lvbkxpc3QuYnJhbmQgfHwgYnJvd3Nlci5uYW1lO1xuICAgIGJyb3dzZXIudmVyc2lvbiA9IGJyb3dzZXJCcmFuZEJ5RnVsbFZlcnNpb25MaXN0LnZlcnNpb24gfHwgYnJvd3Nlci52ZXJzaW9uO1xuICB9IGVsc2Uge1xuICAgIHZhciBicm93c2VyQnJhbmQgPSBmaW5kUHJlc2V0QnJhbmQoQlJPV1NFUl9QUkVTRVRTLCBicmFuZHMpO1xuICAgIGJyb3dzZXIubmFtZSA9IGJyb3dzZXJCcmFuZC5icmFuZCB8fCBicm93c2VyLm5hbWU7XG4gICAgYnJvd3Nlci52ZXJzaW9uID0gYnJvd3NlckJyYW5kLmJyYW5kICYmIG9zRGF0YSA/IG9zRGF0YS51YUZ1bGxWZXJzaW9uIDogYnJvd3NlckJyYW5kLnZlcnNpb247XG4gIH1cblxuICBpZiAoYnJvd3Nlci53ZWJraXQpIHtcbiAgICBvcy5uYW1lID0gaXNNb2JpbGUgPyBcImlvc1wiIDogXCJtYWNcIjtcbiAgfVxuXG4gIGlmIChvcy5uYW1lID09PSBcImlvc1wiICYmIGJyb3dzZXIud2Vidmlldykge1xuICAgIGJyb3dzZXIudmVyc2lvbiA9IFwiLTFcIjtcbiAgfVxuXG4gIG9zLnZlcnNpb24gPSBjb252ZXJ0VmVyc2lvbihvcy52ZXJzaW9uKTtcbiAgYnJvd3Nlci52ZXJzaW9uID0gY29udmVydFZlcnNpb24oYnJvd3Nlci52ZXJzaW9uKTtcbiAgb3MubWFqb3JWZXJzaW9uID0gcGFyc2VJbnQob3MudmVyc2lvbiwgMTApO1xuICBicm93c2VyLm1ham9yVmVyc2lvbiA9IHBhcnNlSW50KGJyb3dzZXIudmVyc2lvbiwgMTApO1xuICByZXR1cm4ge1xuICAgIGJyb3dzZXI6IGJyb3dzZXIsXG4gICAgb3M6IG9zLFxuICAgIGlzTW9iaWxlOiBpc01vYmlsZSxcbiAgICBpc0hpbnRzOiB0cnVlXG4gIH07XG59XG4vKipcbiAqIEV4dHJhY3RzIGJyb3dzZXIgYW5kIG9wZXJhdGluZyBzeXN0ZW0gaW5mb3JtYXRpb24gZnJvbSB0aGUgdXNlciBhZ2VudCBzdHJpbmcuXG4gKiBAa28g7Jyg7KCAIOyXkOydtOyghO2KuCDrrLjsnpDsl7Tsl5DshJwg67iM65287Jqw7KCA7JmAIOyatOyYgeyytOygnCDsoJXrs7Trpbwg7LaU7Lac7ZWc64ukLlxuICogQGZ1bmN0aW9uIGVnLmFnZW50I2FnZW50XG4gKiBAcGFyYW0gLSB1c2VyIGFnZW50IHN0cmluZyB0byBwYXJzZSA8a28+7YyM7Iux7ZWgIOycoOyggOyXkOydtOyghO2KuCDrrLjsnpDsl7Q8L2tvPlxuICogQHJldHVybiAtIGFnZW50IEluZm8gPGtvPiDsl5DsnbTsoITtirgg7KCV67O0IDwva28+XG4gKiBAZXhhbXBsZVxuaW1wb3J0IGFnZW50IGZyb20gXCJAZWdqcy9hZ2VudFwiO1xuLy8gZWcuYWdlbnQoKTtcbmNvbnN0IHsgb3MsIGJyb3dzZXIsIGlzTW9iaWxlIH0gPSBhZ2VudCgpO1xuICovXG5cbmZ1bmN0aW9uIGFnZW50KHVzZXJBZ2VudCkge1xuICBpZiAodHlwZW9mIHVzZXJBZ2VudCA9PT0gXCJ1bmRlZmluZWRcIiAmJiBoYXNVc2VyQWdlbnREYXRhKCkpIHtcbiAgICByZXR1cm4gZ2V0Q2xpZW50SGludHNBZ2VudCgpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBnZXRMZWdhY3lBZ2VudCh1c2VyQWdlbnQpO1xuICB9XG59XG5cbi8qXG5Db3B5cmlnaHQgKGMpIDIwMjItcHJlc2VudCBOQVZFUiBDb3JwLlxubmFtZTogQGNmY3MvY29yZVxubGljZW5zZTogTUlUXG5hdXRob3I6IE5BVkVSIENyb3AuXG5yZXBvc2l0b3J5OiBodHRwczovL2dpdGh1Yi5jb20vbmF2ZXIvY2Zjcy90cmVlL21haW4vcGFja2FnZXMvY29yZVxudmVyc2lvbjogMC4xLjBcbiovXG5cbi8qKlxuICogY2Zjc1xuICogQ29weXJpZ2h0IChjKSAyMDIyLXByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIE1JVCBsaWNlbnNlXG4gKi9cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmZ1bmN0aW9uIGtleXMob2JqKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmopO1xufVxuXG4vKipcbiAqIGNmY3NcbiAqIENvcHlyaWdodCAoYykgMjAyMi1wcmVzZW50IE5BVkVSIENvcnAuXG4gKiBNSVQgbGljZW5zZVxuICovXG52YXIgT0JTRVJWRVJTX1BBVEggPSBcIl9fb2JzZXJ2ZXJzX19cIjtcbnZhciBDT01QVVRFRF9QQVRIID0gXCJfX2NvbXB1dGVkX19cIjtcbnZhciBDRkNTX0RFVEVDVEVEX0RFUEVOREVOQ0lFU19WRVJTSU9OID0gMTtcbnZhciBDRkNTX0RFVEVDVEVEX0RFUEVOREVOQ0lFUyA9IFwiX19DRkNTX0RFVEVDVEVEX0RFUEVOREVOQ0lFU19fXCI7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xudmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IHtcbiAgICBfX3Byb3RvX186IFtdXG4gIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikge1xuICAgIGQuX19wcm90b19fID0gYjtcbiAgfSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07XG4gIH07XG5cbiAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG59O1xuXG5mdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xuICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cbiAgZnVuY3Rpb24gX18oKSB7XG4gICAgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7XG4gIH1cblxuICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59XG5cbi8qKlxuICogY2Zjc1xuICogQ29weXJpZ2h0IChjKSAyMDIyLXByZXNlbnQgTkFWRVIgQ29ycC5cbiAqIE1JVCBsaWNlbnNlXG4gKi9cbmZ1bmN0aW9uIGdldERldGVjdGVkU3RhY2soKSB7XG4gIC8vIFZlcnNpb24gaXNzdWVzIGRvIG5vdCBvY2N1ciB3aGVuIHlvdSBhY2Nlc3MgdGhlIG5hdGl2ZSBvYmplY3QgaW4gdGhlIGdsb2JhbC5cbiAgT2JqZWN0W0NGQ1NfREVURUNURURfREVQRU5ERU5DSUVTXSA9IE9iamVjdFtDRkNTX0RFVEVDVEVEX0RFUEVOREVOQ0lFU10gfHwge307XG4gIHZhciB2ZXJzaW9uTGlzdCA9IE9iamVjdFtDRkNTX0RFVEVDVEVEX0RFUEVOREVOQ0lFU107XG4gIHZlcnNpb25MaXN0W0NGQ1NfREVURUNURURfREVQRU5ERU5DSUVTX1ZFUlNJT05dID0gdmVyc2lvbkxpc3RbQ0ZDU19ERVRFQ1RFRF9ERVBFTkRFTkNJRVNfVkVSU0lPTl0gfHwgW107XG4gIHJldHVybiB2ZXJzaW9uTGlzdFtDRkNTX0RFVEVDVEVEX0RFUEVOREVOQ0lFU19WRVJTSU9OXTtcbn1cbmZ1bmN0aW9uIGdldEN1cnJlbnREZXRlY3RlZCgpIHtcbiAgdmFyIHN0YWNrID0gZ2V0RGV0ZWN0ZWRTdGFjaygpO1xuICByZXR1cm4gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG59XG5mdW5jdGlvbiBkZXRlY3REZXBlbmRlbmNpZXMoaG9zdCkge1xuICB2YXIgc3RhY2sgPSBnZXREZXRlY3RlZFN0YWNrKCk7XG4gIHZhciBvYnNlcnZlcnMgPSBbXTtcbiAgdmFyIGRldGVjdGVkID0ge1xuICAgIGhvc3Q6IGhvc3QsXG4gICAgb2JzZXJ2ZXJzOiBvYnNlcnZlcnMsXG4gICAgcHVzaDogZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICBpZiAoaG9zdCAhPT0gb2JzZXJ2ZXIgJiYgb2JzZXJ2ZXJzLmluZGV4T2Yob2JzZXJ2ZXIpID09PSAtMSkge1xuICAgICAgICBvYnNlcnZlcnMucHVzaChvYnNlcnZlcik7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBzdGFjay5wdXNoKGRldGVjdGVkKTtcbiAgcmV0dXJuIGRldGVjdGVkO1xufVxuZnVuY3Rpb24gZW5kRGV0ZWN0RGVwZW5kZW5jaWVzKCkge1xuICB2YXIgc3RhY2sgPSBnZXREZXRlY3RlZFN0YWNrKCk7XG4gIHJldHVybiBzdGFjay5wb3AoKTtcbn1cblxuLyoqXG4gKiBjZmNzXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjItcHJlc2VudCBOQVZFUiBDb3JwLlxuICogTUlUIGxpY2Vuc2VcbiAqL1xuLyoqXG4gKiBDcmVhdGVzIGEgbXV0YWJsZSByZWYgb2JqZWN0LiBZb3UgY2FuIGFjY2VzcyB0aGUgYC5jdXJyZW50YCB2YWx1ZSBhbmQgZGV0ZWN0IHRoZSB2YWx1ZSBjaGFuZ2UgdGhyb3VnaCBgLnN1YnNjcmliZWAuXG4gKiBAY2F0ZWdvcnkgUmVhY3RpdmVcbiAqIEBzZWUgb2JzZXJ2ZVxuICovXG5cbnZhciBPYnNlcnZlciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKlxuICAgKi9cbiAgZnVuY3Rpb24gT2JzZXJ2ZXIodmFsdWUpIHtcbiAgICB0aGlzLl9lbWl0dGVyID0gbmV3IENvbXBvbmVudCgpO1xuICAgIHRoaXMuX2N1cnJlbnQgPSB2YWx1ZTtcbiAgfVxuXG4gIHZhciBfX3Byb3RvID0gT2JzZXJ2ZXIucHJvdG90eXBlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJjdXJyZW50XCIsIHtcbiAgICAvKipcbiAgICAgKiByZXR1cm4gdGhlIGN1cnJlbnQgdmFsdWUuXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY3VycmVudERldGVjdGVkID0gZ2V0Q3VycmVudERldGVjdGVkKCk7XG4gICAgICBjdXJyZW50RGV0ZWN0ZWQgPT09IG51bGwgfHwgY3VycmVudERldGVjdGVkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyZW50RGV0ZWN0ZWQucHVzaCh0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50O1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHRoaXMuX3NldEN1cnJlbnQodmFsdWUpO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICAvKipcbiAgICogV2hlbiB0aGUgY3VycmVudCB2YWx1ZSBjaGFuZ2VzLCB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gaXMgY2FsbGVkLlxuICAgKi9cblxuICBfX3Byb3RvLnN1YnNjcmliZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIHRoaXMuY3VycmVudDtcblxuICAgIHRoaXMuX2VtaXR0ZXIub24oXCJ1cGRhdGVcIiwgY2FsbGJhY2spO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxuICAgKiBDYW5jZWwgdGhlIHJlZ2lzdGVyZWQgc3Vic2NyaXB0aW9uIHRocm91Z2ggY2FsbGJhY2suXG4gICAqL1xuXG5cbiAgX19wcm90by51bnN1YnNjcmliZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIHRoaXMuX2VtaXR0ZXIub2ZmKFwidXBkYXRlXCIsIGNhbGxiYWNrKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9fcHJvdG8uX3NldEN1cnJlbnQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2YXIgcHJldlZhbHVlID0gdGhpcy5fY3VycmVudDtcbiAgICB2YXIgaXNVcGRhdGUgPSB2YWx1ZSAhPT0gcHJldlZhbHVlO1xuICAgIHRoaXMuX2N1cnJlbnQgPSB2YWx1ZTtcblxuICAgIGlmIChpc1VwZGF0ZSkge1xuICAgICAgdGhpcy5fZW1pdHRlci50cmlnZ2VyKFwidXBkYXRlXCIsIHZhbHVlLCBwcmV2VmFsdWUpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIEBoaWRkZW5cbiAgICovXG5cblxuICBfX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBcIlwiLmNvbmNhdCh0aGlzLmN1cnJlbnQpO1xuICB9O1xuICAvKipcbiAgICogQGhpZGRlblxuICAgKi9cblxuXG4gIF9fcHJvdG8udmFsdWVPZiA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50O1xuICB9O1xuXG4gIHJldHVybiBPYnNlcnZlcjtcbn0oKTtcblxuLyoqXG4gKiBAY2F0ZWdvcnkgUmVhY3RpdmVcbiAqIEBoaWRkZW5cbiAqL1xuXG52YXIgQ29tcHV0ZWRPYnNlcnZlciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhDb21wdXRlZE9ic2VydmVyLCBfc3VwZXIpO1xuICAvKipcbiAgICogQGRlc2NyaXB0aW9uIENyZWF0ZXMgYSBuZXcgY29tcHV0ZWQgb2JzZXJ2ZXIgZnJvbSB0aGUgdmFsdWVzIG9mIG90aGVyIG9ic2VydmVycy5cbiAgICogSXQgaXMgcmVhZC1vbmx5IGFuZCBpZiB5b3UgY2hhbmdlIHRoZSB2YWx1ZSBvZiB0aGUgb2JzZXJ2ZXIgdXNlZCBpbnNpZGUgdGhlIGNhbGxiYWNrLCBpdHMgdmFsdWUgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IHVwZGF0ZWQuXG4gICAqIEBwYXJhbSBfY29tcHV0ZWRDYWxsYmFjayBBIGZ1bmN0aW9uIGZvciBvYnNlcnZlcnMgdG8gYmUgY29tcHV0ZWQuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gQ29tcHV0ZWRPYnNlcnZlcihfY29tcHV0ZWRDYWxsYmFjaykge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy5fY29tcHV0ZWRDYWxsYmFjayA9IF9jb21wdXRlZENhbGxiYWNrO1xuICAgIF90aGlzLl9yZWdpc3RlcmVkID0gW107XG5cbiAgICBfdGhpcy5fb25DaGVja1VwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLl9zZXRDdXJyZW50KF90aGlzLmN1cnJlbnQpO1xuICAgIH07XG5cbiAgICBfdGhpcy5fY3VycmVudCA9IF90aGlzLmN1cnJlbnQ7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9fcHJvdG8gPSBDb21wdXRlZE9ic2VydmVyLnByb3RvdHlwZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwiY3VycmVudFwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBkZXRlY3REZXBlbmRlbmNpZXModGhpcyk7XG5cbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX2NvbXB1dGVkQ2FsbGJhY2soKTtcblxuICAgICAgdmFyIHJlc3VsdHMgPSBlbmREZXRlY3REZXBlbmRlbmNpZXMoKTtcblxuICAgICAgdGhpcy5fcmVnaXN0ZXJlZC5mb3JFYWNoKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICBvYnNlcnZlci51bnN1YnNjcmliZShfdGhpcy5fb25DaGVja1VwZGF0ZSk7XG4gICAgICB9KTtcblxuICAgICAgcmVzdWx0cy5vYnNlcnZlcnMuZm9yRWFjaChmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgb2JzZXJ2ZXIuc3Vic2NyaWJlKF90aGlzLl9vbkNoZWNrVXBkYXRlKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fcmVnaXN0ZXJlZCA9IHJlc3VsdHMub2JzZXJ2ZXJzO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICByZXR1cm4gQ29tcHV0ZWRPYnNlcnZlcjtcbn0oT2JzZXJ2ZXIpO1xuXG4vKipcbiAqIGNmY3NcbiAqIENvcHlyaWdodCAoYykgMjAyMi1wcmVzZW50IE5BVkVSIENvcnAuXG4gKiBNSVQgbGljZW5zZVxuICovXG5cbmZ1bmN0aW9uIGluamVjdE9ic2VydmUocHJvdG90eXBlLCBtZW1iZXJOYW1lLCBwdWJsaWNOYW1lKSB7XG4gIGlmIChwdWJsaWNOYW1lID09PSB2b2lkIDApIHtcbiAgICBwdWJsaWNOYW1lID0gbWVtYmVyTmFtZTtcbiAgfVxuXG4gIHZhciBuZXh0QXR0cmlidXRlcyA9IHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZ2V0T2JzZXJ2ZXIodGhpcywgcHVibGljTmFtZSkuY3VycmVudDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBnZXRPYnNlcnZlcih0aGlzLCBwdWJsaWNOYW1lLCB2YWx1ZSkuY3VycmVudCA9IHZhbHVlO1xuICAgIH1cbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvdHlwZSwgbWVtYmVyTmFtZSwgbmV4dEF0dHJpYnV0ZXMpO1xuXG4gIGlmIChwdWJsaWNOYW1lICE9PSBtZW1iZXJOYW1lKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvdHlwZSwgcHVibGljTmFtZSwge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBnZXRPYnNlcnZlcih0aGlzLCBwdWJsaWNOYW1lKS5jdXJyZW50O1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG4vKipcbiAqIEBkZXNjcmlwdGlvbiBgT2JzZXJ2ZWAgaXMgYSBwcm9wZXJ0eSBkZWNvcmF0b3IgYW5kIGNvbnZlcnRzIHRoZSBwcm9wZXJ0eSBpbnRvIGEgYHJlYWN0aXZlIHN0YXRlYC4gWW91IGNhbiBkZXRlY3QgaXRzIHN0YXR1cyB0aHJvdWdoIGAuc3Vic2NyaWJlYC5cbiAqIEBjYXRlZ29yeSBSZWFjdGl2ZS1EZWNvcmF0b3JcbiAqIEBzZWUgUmVhY3RpdmVTdWJzY3JpYmVcbiAqIEBleGFtcGxlXG4qIGBgYHRzXG5pbXBvcnQgeyBSZWFjdGl2ZVN1YnNjcmliZSwgT2JzZXJ2ZSB9IGZyb20gXCJAY2Zjcy9jb3JlXCI7XG5cbkBSZWFjdGl2ZVN1YnNjcmliZVxuY2xhc3MgQ29tcG9uZW50IHtcbiAgLy8gVGhlIHB1YmxpYyBuYW1lIGFuZCBzdGF0ZSBuYW1lIGFyZSB0aGUgc2FtZS5cbiAgQE9ic2VydmUgdmFsdWUxID0gMTtcbiAgLy8gSWYgeW91IHdhbnQgdG8gc2V0IHB1YmxpYyBuYW1lIGFuZCBwcml2YXRlIHByb3BlcnRpZXMgc2VwYXJhdGVseVxuICBAT2JzZXJ2ZShcInZhbHVlMlwiKSBfdmFsdWUyID0gMTtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgdGhpcy52YWx1ZTEgPSAyO1xuICAgIH0pO1xuICB9XG59XG5pbnRlcmZhY2UgQ1xuYGBgXG4gKi9cblxuXG5mdW5jdGlvbiBPYnNlcnZlKCkge1xuICB2YXIgYXJncyA9IFtdO1xuXG4gIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICB9XG5cbiAgaWYgKGFyZ3MubGVuZ3RoID4gMSkge1xuICAgIHJldHVybiBpbmplY3RPYnNlcnZlKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChwcm90b3R5cGUsIG1lbWJlck5hbWUpIHtcbiAgICByZXR1cm4gaW5qZWN0T2JzZXJ2ZShwcm90b3R5cGUsIG1lbWJlck5hbWUsIGFyZ3NbMF0pO1xuICB9O1xufVxuXG4vKipcbiAqIGNmY3NcbiAqIENvcHlyaWdodCAoYykgMjAyMi1wcmVzZW50IE5BVkVSIENvcnAuXG4gKiBNSVQgbGljZW5zZVxuICovXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuXG5mdW5jdGlvbiBpbmplY3RSZWFjdGl2ZVN1YnNjcmliZShvYmplY3QpIHtcbiAgb2JqZWN0W1wic3Vic2NyaWJlXCJdID0gZnVuY3Rpb24gKG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgdGhpc1tuYW1lXTtcbiAgICBnZXRPYnNlcnZlcih0aGlzLCBuYW1lKS5zdWJzY3JpYmUoY2FsbGJhY2spO1xuICB9O1xuXG4gIG9iamVjdFtcInVuc3Vic2NyaWJlXCJdID0gZnVuY3Rpb24gKG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGlmICghbmFtZSkge1xuICAgICAga2V5cyhnZXRPYnNlcnZlcnModGhpcykpLmZvckVhY2goZnVuY3Rpb24gKG9ic2VydmVyTmFtZSkge1xuICAgICAgICBfdGhpcy51bnN1YnNjcmliZShvYnNlcnZlck5hbWUpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCEobmFtZSBpbiB0aGlzKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGdldE9ic2VydmVyKHRoaXMsIG5hbWUpLnVuc3Vic2NyaWJlKGNhbGxiYWNrKTtcbiAgfTtcbn1cbi8qKlxuICogQGRlc2NyaXB0aW9uIGBSZWFjdGl2ZVN1YnNjcmliZWAgaXMgYSBjbGFzcyBkZWNvcmF0b3IgYW5kIGFkZHMgYC5zdWJzY3JpYmVgIGFuZCBgLnVuc3Vic2NyaWJlYCBtZXRob2RzLlxuICogQGNhdGVnb3J5IFJlYWN0aXZlLURlY29yYXRvclxuICogQHNlZSBPYnNlcnZlXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbmltcG9ydCB7IFJlYWN0aXZlU3Vic2NyaWJlLCBPYnNlcnZlIH0gZnJvbSBcIkBjZmNzL2NvcmVcIjtcblxuQFJlYWN0aXZlU3Vic2NyaWJlXG5jbGFzcyBDb21wb25lbnQge1xuICBAT2JzZXJ2ZSB2YWx1ZTEgPSAxO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICB0aGlzLnZhbHVlMSA9IDI7XG4gICAgfSk7XG4gIH1cbn1cblxuaW50ZXJmYWNlIENvbXBvbmVudCBleHRlbmRzIFJlYWN0aXZlU3Vic2NyaWJlPHtcbiAgdmFsdWUxOiBudW1iZXI7XG4gIHZhbHVlMjogbnVtYmVyO1xufT4ge31cblxuY29uc3QgY29tcG9uZW50ID0gbmV3IENvbXBvbmVudCgpO1xuXG4vLyAxXG5jb25zb2xlLmxvZyhjb21wb25lbnQudmFsdWUxKTtcblxuY29tcG9uZW50LnN1YnNjcmliZShcInZhbHVlMVwiLCBuZXh0VmFsdWUgPT4ge1xuICAvLyBXaGVuIHRoZSBjaGFuZ2UgZXZlbnQgb2NjdXJzID0+ICgyLCAyKVxuICBjb25zb2xlLmxvZyhuZXh0VmFsdWUsIGNvbXBvbmVudC52YWx1ZTIpO1xufSk7XG5gYGBcbiAqL1xuXG5mdW5jdGlvbiBSZWFjdGl2ZVN1YnNjcmliZShDb25zdHJ1Y3Rvcikge1xuICB2YXIgcHJvdG90eXBlID0gQ29uc3RydWN0b3IucHJvdG90eXBlO1xuICBpbmplY3RSZWFjdGl2ZVN1YnNjcmliZShwcm90b3R5cGUpO1xufVxuLyoqXG4gKiBAZGVzY3JpcHRpb24gQ3JlYXRlcyBhIG11dGFibGUgcmVmIG9iamVjdC4gWW91IGNhbiBhY2Nlc3MgdGhlIGAuY3VycmVudGAgdmFsdWUgYW5kIGRldGVjdCB0aGUgdmFsdWUgY2hhbmdlIHRocm91Z2ggYC5zdWJzY3JpYmVgLlxuICogQGNhdGVnb3J5IFJlYWN0aXZlXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IG9ic2VydmUgfSBmcm9tIFwiQGNmY3MvY29yZVwiO1xuICpcbiAqIGNvbnN0IG9iMSA9IG9ic2VydmUoMSk7XG4gKlxuICogb2IxLnN1YnNjcmliZShuZXh0VmFsdWUgPT4ge1xuICogICBjb25zb2xlLmxvZyhuZXh0VmFsdWUpO1xuICogfSk7XG4gKlxuICogb2IxLmN1cnJlbnQgPSAyO1xuICogYGBgXG4gKi9cblxuZnVuY3Rpb24gb2JzZXJ2ZShkZWZhdWx0VmFsdWUpIHtcbiAgcmV0dXJuIG5ldyBPYnNlcnZlcihkZWZhdWx0VmFsdWUpO1xufVxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cblxuZnVuY3Rpb24gY29tcHV0ZWQoY29tcHV0ZWRDYWxsYmFjaykge1xuICByZXR1cm4gbmV3IENvbXB1dGVkT2JzZXJ2ZXIoY29tcHV0ZWRDYWxsYmFjayk7XG59XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuXG5mdW5jdGlvbiBkZWZpbmVPYnNlcnZlcnMoaW5zdGFuY2UpIHtcbiAgdmFyIG9ic2VydmVycyA9IHt9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaW5zdGFuY2UsIE9CU0VSVkVSU19QQVRILCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gb2JzZXJ2ZXJzO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBvYnNlcnZlcnM7XG59XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuXG5mdW5jdGlvbiBnZXRPYnNlcnZlcnMoaW5zdGFuY2UsIGlzQ29tcHV0ZWQpIHtcbiAgdmFyIF9hLCBfYjtcblxuICBpZiAoIWluc3RhbmNlW09CU0VSVkVSU19QQVRIXSkge1xuICAgIGRlZmluZU9ic2VydmVycyhpbnN0YW5jZSk7XG4gIH1cblxuICB2YXIgb2JzZXJ2ZXJzID0gaW5zdGFuY2VbT0JTRVJWRVJTX1BBVEhdO1xuXG4gIGlmICghaXNDb21wdXRlZCkge1xuICAgIHZhciBjb21wdXRlZExpc3QgPSAoX2IgPSAoX2EgPSBpbnN0YW5jZSA9PT0gbnVsbCB8fCBpbnN0YW5jZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5zdGFuY2UuY29uc3RydWN0b3IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wcm90b3R5cGUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYltDT01QVVRFRF9QQVRIXTtcblxuICAgIGlmIChjb21wdXRlZExpc3QpIHtcbiAgICAgIGNvbXB1dGVkTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIGlmICghKG5hbWUgaW4gb2JzZXJ2ZXJzKSAmJiBuYW1lIGluIGluc3RhbmNlKSB7XG4gICAgICAgICAgaW5zdGFuY2VbbmFtZV07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYnNlcnZlcnM7XG59XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuXG5mdW5jdGlvbiBnZXRPYnNlcnZlcihpbnN0YW5jZSwgbmFtZSwgZGVmYXVsdFZhbHVlKSB7XG4gIHZhciBvYnNlcnZlcnMgPSBnZXRPYnNlcnZlcnMoaW5zdGFuY2UpO1xuXG4gIGlmICghb2JzZXJ2ZXJzW25hbWVdKSB7XG4gICAgb2JzZXJ2ZXJzW25hbWVdID0gb2JzZXJ2ZShkZWZhdWx0VmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIG9ic2VydmVyc1tuYW1lXTtcbn1cblxuLyoqXG4gKiBjZmNzXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjItcHJlc2VudCBOQVZFUiBDb3JwLlxuICogTUlUIGxpY2Vuc2VcbiAqL1xuLyoqXG4gKiBAZGVzY3JpcHRpb24gYENvbXB1dGVkYCBpcyBhIHByb3BlcnR5IGRlY29yYXRvci5cbiAqIENoYW5nZXMgaW4gY29tcHV0ZWQgc3RhdGUgdmFsdWVzIGFyZSBhbHNvIHJlY29nbml6ZWQgYWNjb3JkaW5nIHRvIGNoYW5nZXMgaW4gb2JzZXJ2ZXJzIHVzZWQgd2l0aGluIHRoZSBnZXR0ZXIgZnVuY3Rpb24uXG4gKiBZb3UgY2FuIGRldGVjdCBpdHMgc3RhdHVzIHRocm91Z2ggYC5zdWJzY3JpYmVgLlxuICogQGhpZGRlblxuICogQGNhdGVnb3J5IFJlYWN0aXZlLURlY29yYXRvclxuICogQHNlZSBSZWFjdGl2ZVN1YnNjcmliZVxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG5jb25zdCBvYjEgPSBvYnNlcnZlKDApO1xuY29uc3Qgb2IyID0gb2JzZXJ2ZSgxKTtcblxuLy8gV2hlblxuQFJlYWN0aXZlU3Vic2NyaWJlXG5jbGFzcyBUZXN0Q29tcHV0ZWQge1xuICBAQ29tcHV0ZWRcbiAgZ2V0IG9iMygpIHtcbiAgICByZXR1cm4gb2IxLmN1cnJlbnQgKyBvYjIuY3VycmVudDtcbiAgfVxufVxuY29uc3QgaW5zdCA9IG5ldyBUZXN0Q29tcHV0ZWQoKTtcblxuaW5zdC5zdWJzY3JpYmUoXCJvYjNcIiwgb2IzID0+IHtcbiAgY29uc29sZS5sb2cob2IzKTtcbn0pO1xuXG5vYjEuY3VycmVudCA9IDE7XG5gYGBcbiAqL1xuXG5mdW5jdGlvbiBDb21wdXRlZChwcm90b3R5cGUsIG1lbWJlck5hbWUsIGF0dHJpYnV0ZXMpIHtcbiAgdmFyIGdldCA9IGF0dHJpYnV0ZXMuZ2V0O1xuXG4gIGZ1bmN0aW9uIGdldENvbXB1dGVkKCkge1xuICAgIHZhciBvYnNlcnZlcnMgPSBnZXRPYnNlcnZlcnModGhpcywgdHJ1ZSk7XG5cbiAgICBpZiAoIShtZW1iZXJOYW1lIGluIG9ic2VydmVycykpIHtcbiAgICAgIG9ic2VydmVyc1ttZW1iZXJOYW1lXSA9IGNvbXB1dGVkKGdldC5iaW5kKHRoaXMpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZ2V0T2JzZXJ2ZXIodGhpcywgbWVtYmVyTmFtZSkuY3VycmVudDtcbiAgfVxuXG4gIHZhciBuZXh0QXR0cmlidXRlcyA9IHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBnZXRDb21wdXRlZFxuICB9O1xuICBwcm90b3R5cGVbQ09NUFVURURfUEFUSF0gfHwgKHByb3RvdHlwZVtDT01QVVRFRF9QQVRIXSA9IFtdKTtcbiAgdmFyIGNvbXB1dGVkTGlzdCA9IHByb3RvdHlwZVtDT01QVVRFRF9QQVRIXTtcblxuICBpZiAoY29tcHV0ZWRMaXN0LmluZGV4T2YobWVtYmVyTmFtZSkgPT09IC0xKSB7XG4gICAgY29tcHV0ZWRMaXN0LnB1c2gobWVtYmVyTmFtZSk7XG4gIH1cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG90eXBlLCBtZW1iZXJOYW1lLCBuZXh0QXR0cmlidXRlcyk7XG4gIHJldHVybiBuZXh0QXR0cmlidXRlcztcbn1cblxuLypcbkNvcHlyaWdodCAoYykgTkFWRVIgQ29ycC5cbm5hbWU6IEBlZ2pzL2F4ZXNcbmxpY2Vuc2U6IE1JVFxuYXV0aG9yOiBOQVZFUiBDb3JwLlxucmVwb3NpdG9yeTogaHR0cHM6Ly9naXRodWIuY29tL25hdmVyL2VnanMtYXhlc1xudmVyc2lvbjogMy45LjFcbiovXG5cbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlXHJcbnRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlXHJcbkxpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5USElTIENPREUgSVMgUFJPVklERUQgT04gQU4gKkFTIElTKiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbktJTkQsIEVJVEhFUiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBXSVRIT1VUIExJTUlUQVRJT04gQU5ZIElNUExJRURcclxuV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIFRJVExFLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSxcclxuTUVSQ0hBTlRBQkxJVFkgT1IgTk9OLUlORlJJTkdFTUVOVC5cclxuXHJcblNlZSB0aGUgQXBhY2hlIFZlcnNpb24gMi4wIExpY2Vuc2UgZm9yIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9uc1xyXG5hbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xuXG52YXIgZXh0ZW5kU3RhdGljcyQxID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgZXh0ZW5kU3RhdGljcyQxID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IHtcbiAgICBfX3Byb3RvX186IFtdXG4gIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikge1xuICAgIGQuX19wcm90b19fID0gYjtcbiAgfSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICB9O1xuICByZXR1cm4gZXh0ZW5kU3RhdGljcyQxKGQsIGIpO1xufTtcbmZ1bmN0aW9uIF9fZXh0ZW5kcyQxKGQsIGIpIHtcbiAgZXh0ZW5kU3RhdGljcyQxKGQsIGIpO1xuICBmdW5jdGlvbiBfXygpIHtcbiAgICB0aGlzLmNvbnN0cnVjdG9yID0gZDtcbiAgfVxuICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59XG52YXIgX19hc3NpZ24gPSBmdW5jdGlvbiAoKSB7XG4gIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XG4gICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcbiAgICB9XG4gICAgcmV0dXJuIHQ7XG4gIH07XG4gIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbmZ1bmN0aW9uIF9fZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLFxuICAgIGQ7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7ZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn1cblxuLypcbiAqIENvcHlyaWdodCAoYykgMjAxNSBOQVZFUiBDb3JwLlxuICogZWdqcyBwcm9qZWN0cyBhcmUgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLW5ldy1mdW5jLCBuby1uZXN0ZWQtdGVybmFyeSAqL1xudmFyIHdpbjtcbmlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gIC8vIHdpbmRvdyBpcyB1bmRlZmluZWQgaW4gbm9kZS5qc1xuICB3aW4gPSB7XG4gICAgbmF2aWdhdG9yOiB7XG4gICAgICB1c2VyQWdlbnQ6IFwiXCJcbiAgICB9XG4gIH07XG59IGVsc2Uge1xuICB3aW4gPSB3aW5kb3c7XG59XG5cbi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgTkFWRVIgQ29ycC5cbiAqIGVnanMgcHJvamVjdHMgYXJlIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG52YXIgRElSRUNUSU9OX05PTkUgPSAxO1xudmFyIERJUkVDVElPTl9MRUZUID0gMjtcbnZhciBESVJFQ1RJT05fUklHSFQgPSA0O1xudmFyIERJUkVDVElPTl9IT1JJWk9OVEFMID0gMiB8IDQ7XG52YXIgRElSRUNUSU9OX1VQID0gODtcbnZhciBESVJFQ1RJT05fRE9XTiA9IDE2O1xudmFyIERJUkVDVElPTl9WRVJUSUNBTCA9IDggfCAxNjtcbnZhciBESVJFQ1RJT05fQUxMID0gMiB8IDQgfCA4IHwgMTY7XG52YXIgTU9VU0VfTEVGVCA9IFwibGVmdFwiO1xudmFyIE1PVVNFX1JJR0hUID0gXCJyaWdodFwiO1xudmFyIE1PVVNFX01JRERMRSA9IFwibWlkZGxlXCI7XG52YXIgTU9VU0VfQlVUVE9OX0NPREVfTUFQID0ge1xuICAxOiBNT1VTRV9MRUZULFxuICAyOiBNT1VTRV9NSURETEUsXG4gIDM6IE1PVVNFX1JJR0hUXG59O1xudmFyIEFOWSA9IFwiYW55XCI7XG52YXIgTk9ORSA9IFwibm9uZVwiO1xudmFyIFNISUZUID0gXCJzaGlmdFwiO1xudmFyIENUUkwgPSBcImN0cmxcIjtcbnZhciBBTFQgPSBcImFsdFwiO1xudmFyIE1FVEEgPSBcIm1ldGFcIjtcbnZhciBWRUxPQ0lUWV9JTlRFUlZBTCA9IDE2O1xudmFyIElPU19FREdFX1RIUkVTSE9MRCA9IDMwO1xudmFyIElTX0lPU19TQUZBUkkgPSBcIm9udG91Y2hzdGFydFwiIGluIHdpbiAmJiBhZ2VudCgpLmJyb3dzZXIubmFtZSA9PT0gXCJzYWZhcmlcIjtcbnZhciBUUkFOU0ZPUk0gPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxuICB2YXIgYm9keVN0eWxlID0gKGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdKS5zdHlsZTtcbiAgdmFyIHRhcmdldCA9IFtcInRyYW5zZm9ybVwiLCBcIndlYmtpdFRyYW5zZm9ybVwiLCBcIm1zVHJhbnNmb3JtXCIsIFwibW96VHJhbnNmb3JtXCJdO1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGFyZ2V0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKHRhcmdldFtpXSBpbiBib2R5U3R5bGUpIHtcbiAgICAgIHJldHVybiB0YXJnZXRbaV07XG4gICAgfVxuICB9XG4gIHJldHVybiBcIlwiO1xufSgpO1xudmFyIFBSRVZFTlRfRFJBR19DU1NQUk9QUyA9IHtcbiAgXCItd2Via2l0LXVzZXItc2VsZWN0XCI6IFwibm9uZVwiLFxuICBcIi1tcy11c2VyLXNlbGVjdFwiOiBcIm5vbmVcIixcbiAgXCItbW96LXVzZXItc2VsZWN0XCI6IFwibm9uZVwiLFxuICBcInVzZXItc2VsZWN0XCI6IFwibm9uZVwiLFxuICBcIi13ZWJraXQtdXNlci1kcmFnXCI6IFwibm9uZVwiXG59O1xuXG52YXIgdG9BcnJheSA9IGZ1bmN0aW9uIChub2Rlcykge1xuICAvLyBjb25zdCBlbCA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG5vZGVzKTtcbiAgLy8gZm9yIElFOFxuICB2YXIgZWwgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG5vZGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgZWwucHVzaChub2Rlc1tpXSk7XG4gIH1cbiAgcmV0dXJuIGVsO1xufTtcbnZhciAkJDEgPSBmdW5jdGlvbiAocGFyYW0sIG11bHRpKSB7XG4gIGlmIChtdWx0aSA9PT0gdm9pZCAwKSB7XG4gICAgbXVsdGkgPSBmYWxzZTtcbiAgfVxuICB2YXIgZWw7XG4gIGlmICh0eXBlb2YgcGFyYW0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAvLyBTdHJpbmcgKEhUTUwsIFNlbGVjdG9yKVxuICAgIC8vIGNoZWNrIGlmIHN0cmluZyBpcyBIVE1MIHRhZyBmb3JtYXRcbiAgICB2YXIgbWF0Y2ggPSBwYXJhbS5tYXRjaCgvXjwoW2Etel0rKVxccyooW14+XSopPi8pO1xuICAgIC8vIGNyZWF0aW5nIGVsZW1lbnRcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIC8vIEhUTUxcbiAgICAgIHZhciBkdW1teSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBkdW1teS5pbm5lckhUTUwgPSBwYXJhbTtcbiAgICAgIGVsID0gdG9BcnJheShkdW1teS5jaGlsZE5vZGVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU2VsZWN0b3JcbiAgICAgIGVsID0gdG9BcnJheShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHBhcmFtKSk7XG4gICAgfVxuICAgIGlmICghbXVsdGkpIHtcbiAgICAgIGVsID0gZWwubGVuZ3RoID49IDEgPyBlbFswXSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gZWxzZSBpZiAocGFyYW0gPT09IHdpbikge1xuICAgIC8vIHdpbmRvd1xuICAgIGVsID0gcGFyYW07XG4gIH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIHBhcmFtIHx8IFwiY3VycmVudFwiIGluIHBhcmFtKSB7XG4gICAgZWwgPSBwYXJhbS52YWx1ZSB8fCBwYXJhbS5jdXJyZW50O1xuICB9IGVsc2UgaWYgKHBhcmFtLm5vZGVOYW1lICYmIChwYXJhbS5ub2RlVHlwZSA9PT0gMSB8fCBwYXJhbS5ub2RlVHlwZSA9PT0gOSkpIHtcbiAgICAvLyBIVE1MRWxlbWVudCwgRG9jdW1lbnRcbiAgICBlbCA9IHBhcmFtO1xuICB9IGVsc2UgaWYgKFwialF1ZXJ5XCIgaW4gd2luICYmIHBhcmFtIGluc3RhbmNlb2YgalF1ZXJ5IHx8IHBhcmFtLmNvbnN0cnVjdG9yLnByb3RvdHlwZS5qcXVlcnkpIHtcbiAgICAvLyBqUXVlcnlcbiAgICBlbCA9IG11bHRpID8gcGFyYW0udG9BcnJheSgpIDogcGFyYW0uZ2V0KDApO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocGFyYW0pKSB7XG4gICAgZWwgPSBwYXJhbS5tYXAoZnVuY3Rpb24gKHYpIHtcbiAgICAgIHJldHVybiAkJDEodik7XG4gICAgfSk7XG4gICAgaWYgKCFtdWx0aSkge1xuICAgICAgZWwgPSBlbC5sZW5ndGggPj0gMSA/IGVsWzBdIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZWw7XG59O1xudmFyIHJhZiA9IHdpbi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luLndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZTtcbnZhciBjYWYgPSB3aW4uY2FuY2VsQW5pbWF0aW9uRnJhbWUgfHwgd2luLndlYmtpdENhbmNlbEFuaW1hdGlvbkZyYW1lO1xuaWYgKHJhZiAmJiAhY2FmKSB7XG4gIHZhciBrZXlJbmZvXzEgPSB7fTtcbiAgdmFyIG9sZHJhZl8xID0gcmFmO1xuICByYWYgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICB2YXIgd3JhcENhbGxiYWNrID0gZnVuY3Rpb24gKHRpbWVzdGFtcCkge1xuICAgICAgaWYgKGtleUluZm9fMVtrZXldKSB7XG4gICAgICAgIGNhbGxiYWNrKHRpbWVzdGFtcCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIga2V5ID0gb2xkcmFmXzEod3JhcENhbGxiYWNrKTtcbiAgICBrZXlJbmZvXzFba2V5XSA9IHRydWU7XG4gICAgcmV0dXJuIGtleTtcbiAgfTtcbiAgY2FmID0gZnVuY3Rpb24gKGtleSkge1xuICAgIGRlbGV0ZSBrZXlJbmZvXzFba2V5XTtcbiAgfTtcbn0gZWxzZSBpZiAoIShyYWYgJiYgY2FmKSkge1xuICByYWYgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gd2luLnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgY2FsbGJhY2sod2luLnBlcmZvcm1hbmNlICYmIHdpbi5wZXJmb3JtYW5jZS5ub3cgJiYgd2luLnBlcmZvcm1hbmNlLm5vdygpIHx8IG5ldyBEYXRlKCkuZ2V0VGltZSgpKTtcbiAgICB9LCAxNik7XG4gIH07XG4gIGNhZiA9IHdpbi5jbGVhclRpbWVvdXQ7XG59XG4vKipcbiAqIEEgcG9seWZpbGwgZm9yIHRoZSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCkgbWV0aG9kLlxuICogQHNlZSAgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL3dpbmRvdy9yZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAqIEBwcml2YXRlXG4gKi9cbnZhciByZXF1ZXN0QW5pbWF0aW9uRnJhbWUkMSA9IGZ1bmN0aW9uIChmcCkge1xuICByZXR1cm4gcmFmKGZwKTtcbn07XG4vKipcbiAqIEEgcG9seWZpbGwgZm9yIHRoZSB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUoKSBtZXRob2QuIEl0IGNhbmNlbHMgYW4gYW5pbWF0aW9uIGV4ZWN1dGVkIHRocm91Z2ggYSBjYWxsIHRvIHRoZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKSBtZXRob2QuXG4gKiBAcGFyYW0ge051bWJlcn0ga2V5IOKIkiAgVGhlIElEIHZhbHVlIHJldHVybmVkIHRocm91Z2ggYSBjYWxsIHRvIHRoZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKSBtZXRob2QuIDxrbz5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKSDrqZTshJzrk5zqsIAg67CY7ZmY7ZWcIOyVhOydtOuUlCDqsJI8L2tvPlxuICogQHNlZSAgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dpbmRvdy9jYW5jZWxBbmltYXRpb25GcmFtZVxuICogQHByaXZhdGVcbiAqL1xudmFyIGNhbmNlbEFuaW1hdGlvbkZyYW1lJDEgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIGNhZihrZXkpO1xufTtcbnZhciBtYXAgPSBmdW5jdGlvbiAob2JqLCBjYWxsYmFjaykge1xuICB2YXIgdHJhbmZvcm1lZCA9IHt9O1xuICBmb3IgKHZhciBrIGluIG9iaikge1xuICAgIGlmIChrKSB7XG4gICAgICB0cmFuZm9ybWVkW2tdID0gY2FsbGJhY2sob2JqW2tdLCBrKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRyYW5mb3JtZWQ7XG59O1xudmFyIGZpbHRlciA9IGZ1bmN0aW9uIChvYmosIGNhbGxiYWNrKSB7XG4gIHZhciBmaWx0ZXJlZCA9IHt9O1xuICBmb3IgKHZhciBrIGluIG9iaikge1xuICAgIGlmIChrICYmIGNhbGxiYWNrKG9ialtrXSwgaykpIHtcbiAgICAgIGZpbHRlcmVkW2tdID0gb2JqW2tdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmlsdGVyZWQ7XG59O1xudmFyIGV2ZXJ5ID0gZnVuY3Rpb24gKG9iaiwgY2FsbGJhY2spIHtcbiAgZm9yICh2YXIgayBpbiBvYmopIHtcbiAgICBpZiAoayAmJiAhY2FsbGJhY2sob2JqW2tdLCBrKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG52YXIgZXF1YWwgPSBmdW5jdGlvbiAodGFyZ2V0LCBiYXNlKSB7XG4gIHJldHVybiBldmVyeSh0YXJnZXQsIGZ1bmN0aW9uICh2LCBrKSB7XG4gICAgcmV0dXJuIHYgPT09IGJhc2Vba107XG4gIH0pO1xufTtcbnZhciByb3VuZE51bUZ1bmMgPSB7fTtcbnZhciByb3VuZE51bWJlciA9IGZ1bmN0aW9uIChudW0sIHJvdW5kVW5pdCkge1xuICAvLyBDYWNoZSBmb3IgcGVyZm9ybWFuY2VcbiAgaWYgKCFyb3VuZE51bUZ1bmNbcm91bmRVbml0XSkge1xuICAgIHJvdW5kTnVtRnVuY1tyb3VuZFVuaXRdID0gZ2V0Um91bmRGdW5jKHJvdW5kVW5pdCk7XG4gIH1cbiAgcmV0dXJuIHJvdW5kTnVtRnVuY1tyb3VuZFVuaXRdKG51bSk7XG59O1xudmFyIHJvdW5kTnVtYmVycyA9IGZ1bmN0aW9uIChudW0sIHJvdW5kVW5pdCkge1xuICBpZiAoIW51bSB8fCAhcm91bmRVbml0KSB7XG4gICAgcmV0dXJuIG51bTtcbiAgfVxuICByZXR1cm4gbWFwKG51bSwgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICByZXR1cm4gcm91bmROdW1iZXIodmFsdWUsIHR5cGVvZiByb3VuZFVuaXQgPT09IFwibnVtYmVyXCIgPyByb3VuZFVuaXQgOiByb3VuZFVuaXRba2V5XSk7XG4gIH0pO1xufTtcbnZhciBnZXREZWNpbWFsUGxhY2UgPSBmdW5jdGlvbiAodmFsKSB7XG4gIGlmICghaXNGaW5pdGUodmFsKSkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIHZhciB2ID0gXCJcIi5jb25jYXQodmFsKTtcbiAgaWYgKHYuaW5kZXhPZihcImVcIikgPj0gMCkge1xuICAgIC8vIEV4cG9uZW50aWFsIEZvcm1hdFxuICAgIC8vIDFlLTEwLCAxZS0xMlxuICAgIHZhciBwID0gMDtcbiAgICB2YXIgZSA9IDE7XG4gICAgd2hpbGUgKE1hdGgucm91bmQodmFsICogZSkgLyBlICE9PSB2YWwpIHtcbiAgICAgIGUgKj0gMTA7XG4gICAgICBwKys7XG4gICAgfVxuICAgIHJldHVybiBwO1xuICB9XG4gIC8vIEluIGdlbmVyYWwsIGZvbGxvd2luZyBoYXMgcGVyZm9ybWFuY2UgYmVuZWZpdC5cbiAgLy8gaHR0cHM6Ly9qc3BlcmYuY29tL3ByZWNpc2lvbi1jYWxjdWxhdGlvblxuICByZXR1cm4gdi5pbmRleE9mKFwiLlwiKSA+PSAwID8gdi5sZW5ndGggLSB2LmluZGV4T2YoXCIuXCIpIC0gMSA6IDA7XG59O1xudmFyIGludmVyc2VQb3cgPSBmdW5jdGlvbiAobikge1xuICAvLyByZXBsYWNlIE1hdGgucG93KDEwLCAtbikgdG8gc29sdmUgZmxvYXRpbmcgcG9pbnQgaXNzdWUuXG4gIC8vIGVnLiBNYXRoLnBvdygxMCwgLTQpID0+IDAuMDAwMDk5OTk5OTk5OTk5OTk5OTlcbiAgcmV0dXJuIDEgLyBNYXRoLnBvdygxMCwgbik7XG59O1xudmFyIGdldFJvdW5kRnVuYyA9IGZ1bmN0aW9uICh2KSB7XG4gIHZhciBwID0gdiA8IDEgPyBNYXRoLnBvdygxMCwgZ2V0RGVjaW1hbFBsYWNlKHYpKSA6IDE7XG4gIHJldHVybiBmdW5jdGlvbiAobikge1xuICAgIGlmICh2ID09PSAwKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGgucm91bmQoTWF0aC5yb3VuZChuIC8gdikgKiB2ICogcCkgLyBwO1xuICB9O1xufTtcbnZhciBnZXRBbmdsZSA9IGZ1bmN0aW9uIChwb3NYLCBwb3NZKSB7XG4gIHJldHVybiBNYXRoLmF0YW4yKHBvc1ksIHBvc1gpICogMTgwIC8gTWF0aC5QSTtcbn07XG52YXIgaXNDc3NQcm9wc0Zyb21BeGVzID0gZnVuY3Rpb24gKG9yaWdpbmFsQ3NzUHJvcHMpIHtcbiAgdmFyIHNhbWUgPSB0cnVlO1xuICBPYmplY3Qua2V5cyhQUkVWRU5UX0RSQUdfQ1NTUFJPUFMpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICBpZiAoIW9yaWdpbmFsQ3NzUHJvcHMgfHwgb3JpZ2luYWxDc3NQcm9wc1twcm9wXSAhPT0gUFJFVkVOVF9EUkFHX0NTU1BST1BTW3Byb3BdKSB7XG4gICAgICBzYW1lID0gZmFsc2U7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHNhbWU7XG59O1xudmFyIGdldERpcmVjdGlvbiA9IGZ1bmN0aW9uICh1c2VIb3Jpem9udGFsLCB1c2VWZXJ0aWNhbCkge1xuICBpZiAodXNlSG9yaXpvbnRhbCAmJiB1c2VWZXJ0aWNhbCkge1xuICAgIHJldHVybiBESVJFQ1RJT05fQUxMO1xuICB9IGVsc2UgaWYgKHVzZUhvcml6b250YWwpIHtcbiAgICByZXR1cm4gRElSRUNUSU9OX0hPUklaT05UQUw7XG4gIH0gZWxzZSBpZiAodXNlVmVydGljYWwpIHtcbiAgICByZXR1cm4gRElSRUNUSU9OX1ZFUlRJQ0FMO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBESVJFQ1RJT05fTk9ORTtcbiAgfVxufTtcbnZhciB1c2VEaXJlY3Rpb24gPSBmdW5jdGlvbiAoY2hlY2tUeXBlLCBkaXJlY3Rpb24sIHVzZXJEaXJlY3Rpb24pIHtcbiAgaWYgKHVzZXJEaXJlY3Rpb24pIHtcbiAgICByZXR1cm4gISEoZGlyZWN0aW9uID09PSBESVJFQ1RJT05fQUxMIHx8IGRpcmVjdGlvbiAmIGNoZWNrVHlwZSAmJiB1c2VyRGlyZWN0aW9uICYgY2hlY2tUeXBlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gISEoZGlyZWN0aW9uICYgY2hlY2tUeXBlKTtcbiAgfVxufTtcbnZhciBzZXRDc3NQcm9wcyA9IGZ1bmN0aW9uIChlbGVtZW50LCBvcHRpb24sIGRpcmVjdGlvbikge1xuICB2YXIgX2E7XG4gIHZhciB0b3VjaEFjdGlvbk1hcCA9IChfYSA9IHt9LCBfYVtESVJFQ1RJT05fTk9ORV0gPSBcImF1dG9cIiwgX2FbRElSRUNUSU9OX0FMTF0gPSBcIm5vbmVcIiwgX2FbRElSRUNUSU9OX1ZFUlRJQ0FMXSA9IFwicGFuLXhcIiwgX2FbRElSRUNUSU9OX0hPUklaT05UQUxdID0gXCJwYW4teVwiLCBfYSk7XG4gIHZhciBvbGRDc3NQcm9wcyA9IHt9O1xuICBpZiAoZWxlbWVudCAmJiBlbGVtZW50LnN0eWxlKSB7XG4gICAgdmFyIHRvdWNoQWN0aW9uID0gb3B0aW9uLnRvdWNoQWN0aW9uID8gb3B0aW9uLnRvdWNoQWN0aW9uIDogdG91Y2hBY3Rpb25NYXBbZGlyZWN0aW9uXTtcbiAgICB2YXIgbmV3Q3NzUHJvcHNfMSA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBQUkVWRU5UX0RSQUdfQ1NTUFJPUFMpLCB7XG4gICAgICBcInRvdWNoLWFjdGlvblwiOiBlbGVtZW50LnN0eWxlW1widG91Y2gtYWN0aW9uXCJdID09PSBcIm5vbmVcIiA/IFwibm9uZVwiIDogdG91Y2hBY3Rpb25cbiAgICB9KTtcbiAgICBPYmplY3Qua2V5cyhuZXdDc3NQcm9wc18xKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICBvbGRDc3NQcm9wc1twcm9wXSA9IGVsZW1lbnQuc3R5bGVbcHJvcF07XG4gICAgfSk7XG4gICAgLy8gT2xkIHN0eWxlIHByb3BzIGxpa2UgdXNlci1zZWxlY3QgY2FuIGJlIGNvcnJ1cHRlZCBpZiB5b3UgY2hhbmdlIHRoZSBzdHlsZSBkaXJlY3RseSBpbiB0aGUgbG9naWMgYWJvdmUuXG4gICAgT2JqZWN0LmtleXMobmV3Q3NzUHJvcHNfMSkuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgZWxlbWVudC5zdHlsZVtwcm9wXSA9IG5ld0Nzc1Byb3BzXzFbcHJvcF07XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIG9sZENzc1Byb3BzO1xufTtcbnZhciByZXZlcnRDc3NQcm9wcyA9IGZ1bmN0aW9uIChlbGVtZW50LCBvcmlnaW5hbENzc1Byb3BzKSB7XG4gIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuc3R5bGUgJiYgb3JpZ2luYWxDc3NQcm9wcykge1xuICAgIE9iamVjdC5rZXlzKG9yaWdpbmFsQ3NzUHJvcHMpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgIGVsZW1lbnQuc3R5bGVbcHJvcF0gPSBvcmlnaW5hbENzc1Byb3BzW3Byb3BdO1xuICAgIH0pO1xuICB9XG4gIHJldHVybjtcbn07XG5cbnZhciBFdmVudE1hbmFnZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBFdmVudE1hbmFnZXIoX2F4ZXMpIHtcbiAgICB0aGlzLl9heGVzID0gX2F4ZXM7XG4gICAgdGhpcy5ob2xkaW5nQ291bnQgPSAwO1xuICB9XG4gIC8qKlxuICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gYSB1c2VyIGhvbGRzIGFuIGVsZW1lbnQgb24gdGhlIHNjcmVlbiBvZiB0aGUgZGV2aWNlLlxuICAgKiBAa28g7IKs7Jqp7J6Q6rCAIOq4sOq4sOydmCDtmZTrqbTsl5Ag7IaQ7J2EIOuMgOqzoCDsnojsnYQg65WMIOuwnOyDne2VmOuKlCDsnbTrsqTtirhcbiAgICogQGV2ZW50IEF4ZXMjaG9sZFxuICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgKiBAcHJvcGVydHkge09iamVjdC48c3RyaW5nLCBudW1iZXI+fSBwb3MgY29vcmRpbmF0ZSA8a28+7KKM7ZGcIOygleuztDwva28+XG4gICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBpbnB1dCBUaGUgaW5zdGFuY2Ugb2YgaW5wdXRUeXBlIHdoZXJlIHRoZSBldmVudCBvY2N1cnJlZDxrbz7snbTrsqTtirjqsIAg67Cc7IOd7ZWcIGlucHV0VHlwZSDsnbjsiqTthLTsiqQ8L2tvPlxuICAgKiBAcHJvcGVydHkge09iamVjdH0gaW5wdXRFdmVudCBUaGUgZXZlbnQgb2JqZWN0IHJlY2VpdmVkIGZyb20gaW5wdXRUeXBlIDxrbz5pbnB1dFR5cGXsnLzroZwg67aA7YSwIOuwm+ydgCDsnbTrsqTtirgg6rCd7LK0PC9rbz5cbiAgICogQHByb3BlcnR5IHtCb29sZWFufSBpc1RydXN0ZWQgUmV0dXJucyB0cnVlIGlmIGFuIGV2ZW50IHdhcyBnZW5lcmF0ZWQgYnkgdGhlIHVzZXIgYWN0aW9uLCBvciBmYWxzZSBpZiBpdCB3YXMgY2F1c2VkIGJ5IGEgc2NyaXB0IG9yIEFQSSBjYWxsIDxrbz7sgqzsmqnsnpDsnZgg7JWh7IWY7JeQIOydmO2VtCDsnbTrsqTtirjqsIAg67Cc7IOd7ZWY7JiA7Jy866m0IHRydWUsIOyKpO2BrOumve2KuOuCmCBBUEntmLjstpzsl5Ag7J2Y7ZW0IOuwnOyDne2VmOyYgOydhCDqsr3smrDsl5DripQgZmFsc2Xrpbwg67CY7ZmY7ZWc64ukLjwva28+XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IGF4ZXMgPSBuZXcgZWcuQXhlcyh7XG4gICAqICAgXCJ4XCI6IHtcbiAgICogICAgICByYW5nZTogWzAsIDEwMF1cbiAgICogICB9LFxuICAgKiAgIFwiem9vbVwiOiB7XG4gICAqICAgICAgcmFuZ2U6IFs1MCwgMzBdXG4gICAqICAgfVxuICAgKiB9KS5vbihcImhvbGRcIiwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICogICAvLyBldmVudC5wb3NcbiAgICogICAvLyBldmVudC5pbnB1dFxuICAgKiAgIC8vIGV2ZW50LmlucHV0RXZlbnRcbiAgICogICAvLyBpc1RydXN0ZWRcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKi9cbiAgdmFyIF9fcHJvdG8gPSBFdmVudE1hbmFnZXIucHJvdG90eXBlO1xuICBfX3Byb3RvLmhvbGQgPSBmdW5jdGlvbiAocG9zLCBvcHRpb24pIHtcbiAgICB2YXIgcm91bmRQb3MgPSB0aGlzLl9nZXRSb3VuZFBvcyhwb3MpLnJvdW5kUG9zO1xuICAgIHRoaXMuX2F4ZXMudHJpZ2dlcihuZXcgQ29tcG9uZW50RXZlbnQkMShcImhvbGRcIiwge1xuICAgICAgcG9zOiByb3VuZFBvcyxcbiAgICAgIGlucHV0OiBvcHRpb24uaW5wdXQgfHwgbnVsbCxcbiAgICAgIGlucHV0RXZlbnQ6IG9wdGlvbi5ldmVudCB8fCBudWxsLFxuICAgICAgaXNUcnVzdGVkOiB0cnVlXG4gICAgfSkpO1xuICB9O1xuICAvKipcbiAgICogU3BlY2lmaWVzIHRoZSBjb29yZGluYXRlcyB0byBtb3ZlIGFmdGVyIHRoZSAnY2hhbmdlJyBldmVudC4gSXQgd29ya3Mgd2hlbiB0aGUgaG9sZGluZyB2YWx1ZSBvZiB0aGUgY2hhbmdlIGV2ZW50IGlzIHRydWUuXG4gICAqIEBrbyAnY2hhbmdlJyDsnbTrsqTtirgg7J207ZuEIOydtOuPme2VoCDsooztkZzrpbwg7KeA7KCV7ZWc64ukLiBjaGFuZ2XsnbTrsqTtirjsnZggaG9sZGluZyDqsJLsnbQgdHJ1ZeydvCDqsr3smrDsl5Ag64+Z7J6R7ZWc64ukXG4gICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsIG51bWJlcj59IHBvcyBUaGUgY29vcmRpbmF0ZSB0byBtb3ZlIHRvIDxrbz7snbTrj5ntlaAg7KKM7ZGcPC9rbz5cbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogY29uc3QgYXhlcyA9IG5ldyBlZy5BeGVzKHtcbiAgICogICBcInhcIjoge1xuICAgKiAgICAgIHJhbmdlOiBbMCwgMTAwXVxuICAgKiAgIH0sXG4gICAqICAgXCJ6b29tXCI6IHtcbiAgICogICAgICByYW5nZTogWzUwLCAzMF1cbiAgICogICB9XG4gICAqIH0pLm9uKFwiY2hhbmdlXCIsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAqICAgZXZlbnQuaG9sZGluZyAmJiBldmVudC5zZXQoe3g6IDEwfSk7XG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICovXG4gIC8qKiBTcGVjaWZpZXMgdGhlIGFuaW1hdGlvbiBjb29yZGluYXRlcyB0byBtb3ZlIGFmdGVyIHRoZSAncmVsZWFzZScgb3IgJ2FuaW1hdGlvblN0YXJ0JyBldmVudHMuXG4gICAqIEBrbyAncmVsZWFzZScg65iQ64qUICdhbmltYXRpb25TdGFydCcg7J2067Kk7Yq4IOydtO2bhCDsnbTrj5ntlaAg7KKM7ZGc66W8IOyngOygle2VnOuLpC5cbiAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgbnVtYmVyPn0gcG9zIFRoZSBjb29yZGluYXRlIHRvIG1vdmUgdG8gPGtvPuydtOuPme2VoCDsooztkZw8L2tvPlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2R1cmF0aW9uPTBdIER1cmF0aW9uIG9mIHRoZSBhbmltYXRpb24gKHVuaXQ6IG1zKSA8a28+7JWg64uI66mU7J207IWYIOynhO2WiSDsi5zqsIQo64uo7JyEOiBtcyk8L2tvPlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBjb25zdCBheGVzID0gbmV3IGVnLkF4ZXMoe1xuICAgKiAgIFwieFwiOiB7XG4gICAqICAgICAgcmFuZ2U6IFswLCAxMDBdXG4gICAqICAgfSxcbiAgICogICBcInpvb21cIjoge1xuICAgKiAgICAgIHJhbmdlOiBbNTAsIDMwXVxuICAgKiAgIH1cbiAgICogfSkub24oXCJhbmltYXRpb25TdGFydFwiLCBmdW5jdGlvbihldmVudCkge1xuICAgKiAgIGV2ZW50LnNldFRvKHt4OiAxMH0sIDIwMDApO1xuICAgKiB9KTtcbiAgICogYGBgXG4gICAqL1xuICAvKipcbiAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIGEgdXNlciByZWxlYXNlIGFuIGVsZW1lbnQgb24gdGhlIHNjcmVlbiBvZiB0aGUgZGV2aWNlLlxuICAgKiBAa28g7IKs7Jqp7J6Q6rCAIOq4sOq4sOydmCDtmZTrqbTsl5DshJwg7IaQ7J2EIOuXkOydhCDrlYwg67Cc7IOd7ZWY64qUIOydtOuypO2KuFxuICAgKiBAZXZlbnQgQXhlcyNyZWxlYXNlXG4gICAqIEB0eXBlIHtvYmplY3R9XG4gICAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsIG51bWJlcj59IGRlcGFQb3MgVGhlIGNvb3JkaW5hdGVzIHdoZW4gcmVsZWFzaW5nIGFuIGVsZW1lbnQ8a28+7IaQ7J2EIOuXkOydhCDrlYzsnZgg7KKM7ZGcIDwva28+XG4gICAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsIG51bWJlcj59IGRlc3RQb3MgVGhlIGNvb3JkaW5hdGVzIHRvIG1vdmUgdG8gYWZ0ZXIgcmVsZWFzaW5nIGFuIGVsZW1lbnQ8a28+7IaQ7J2EIOuXgCDrkqTsl5Ag7J2064+Z7ZWgIOyijO2RnDwva28+XG4gICAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsIG51bWJlcj59IGRlbHRhICBUaGUgbW92ZW1lbnQgdmFyaWF0aW9uIG9mIGNvb3JkaW5hdGUgPGtvPuyijO2RnOydmCDrs4DtmZTrn4k8L2tvPlxuICAgKiBAcHJvcGVydHkge09iamVjdC48c3RyaW5nLCBudW1iZXI+fSBib3VuY2VSYXRpbyBJZiB0aGUgY29vcmRpbmF0ZXMgYXQgdGhlIHRpbWUgb2YgcmVsZWFzZSBhcmUgaW4gdGhlIGJvdW5jZSBhcmVhLCB0aGUgY3VycmVudCBib3VuY2UgdmFsdWUgZGl2aWRlZCBieSB0aGUgbWF4aW11bSBib3VuY2UgdmFsdWUgPGtvPuyGkOydhCDrl5DsnYQg65WM7J2YIOyijO2RnOqwgCBib3VuY2Ug7JiB7Jet7JeQIOyeiOuKlCDqsr3smrAg7ZiE7J6sIGJvdW5jZeuQnCDqsJLsnYQg7LWc64yAIGJvdW5jZSDqsJLsnLzroZwg64KY64iIIOyImOy5mC48L2tvPlxuICAgKiBAcHJvcGVydHkge09iamVjdH0gaW5wdXRFdmVudCBUaGUgZXZlbnQgb2JqZWN0IHJlY2VpdmVkIGZyb20gaW5wdXRUeXBlIDxrbz5pbnB1dFR5cGXsnLzroZwg67aA7YSwIOuwm+ydgCDsnbTrsqTtirgg6rCd7LK0PC9rbz5cbiAgICogQHByb3BlcnR5IHtPYmplY3R9IGlucHV0IFRoZSBpbnN0YW5jZSBvZiBpbnB1dFR5cGUgd2hlcmUgdGhlIGV2ZW50IG9jY3VycmVkPGtvPuydtOuypO2KuOqwgCDrsJzsg53tlZwgaW5wdXRUeXBlIOyduOyKpO2EtOyKpDwva28+XG4gICAqIEBwcm9wZXJ0eSB7c2V0VG99IHNldFRvIFNwZWNpZmllcyB0aGUgYW5pbWF0aW9uIGNvb3JkaW5hdGVzIHRvIG1vdmUgYWZ0ZXIgdGhlIGV2ZW50IDxrbz7snbTrsqTtirgg7J207ZuEIOydtOuPme2VoCDslaDri4jrqZTsnbTshZgg7KKM7ZGc66W8IOyngOygle2VnOuLpDwva28+XG4gICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gaXNUcnVzdGVkIFJldHVybnMgdHJ1ZSBpZiBhbiBldmVudCB3YXMgZ2VuZXJhdGVkIGJ5IHRoZSB1c2VyIGFjdGlvbiwgb3IgZmFsc2UgaWYgaXQgd2FzIGNhdXNlZCBieSBhIHNjcmlwdCBvciBBUEkgY2FsbCA8a28+7IKs7Jqp7J6Q7J2YIOyVoeyFmOyXkCDsnZjtlbQg7J2067Kk7Yq46rCAIOuwnOyDne2VmOyYgOycvOuptCB0cnVlLCDsiqTtgazrpr3tirjrgpggQVBJ7Zi47Lac7JeQIOydmO2VtCDrsJzsg53tlZjsmIDsnYQg6rK97Jqw7JeQ64qUIGZhbHNl66W8IOuwmO2ZmO2VnOuLpC48L2tvPlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBjb25zdCBheGVzID0gbmV3IGVnLkF4ZXMoe1xuICAgKiAgIFwieFwiOiB7XG4gICAqICAgICAgcmFuZ2U6IFswLCAxMDBdXG4gICAqICAgfSxcbiAgICogICBcInpvb21cIjoge1xuICAgKiAgICAgIHJhbmdlOiBbNTAsIDMwXVxuICAgKiAgIH1cbiAgICogfSkub24oXCJyZWxlYXNlXCIsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAqICAgLy8gZXZlbnQuZGVwYVBvc1xuICAgKiAgIC8vIGV2ZW50LmRlc3RQb3NcbiAgICogICAvLyBldmVudC5kZWx0YVxuICAgKiAgIC8vIGV2ZW50LmlucHV0XG4gICAqICAgLy8gZXZlbnQuaW5wdXRFdmVudFxuICAgKiAgIC8vIGV2ZW50LnNldFRvXG4gICAqICAgLy8gZXZlbnQuaXNUcnVzdGVkXG4gICAqXG4gICAqICAgLy8gaWYgeW91IHdhbnQgdG8gY2hhbmdlIHRoZSBhbmltYXRpb24gY29vcmRpbmF0ZXMgdG8gbW92ZSBhZnRlciB0aGUgJ3JlbGVhc2UnIGV2ZW50LlxuICAgKiAgIGV2ZW50LnNldFRvKHt4OiAxMH0sIDIwMDApO1xuICAgKiB9KTtcbiAgICogYGBgXG4gICAqL1xuICBfX3Byb3RvLnRyaWdnZXJSZWxlYXNlID0gZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgdmFyIF9hID0gdGhpcy5fZ2V0Um91bmRQb3MocGFyYW0uZGVzdFBvcywgcGFyYW0uZGVwYVBvcyksXG4gICAgICByb3VuZFBvcyA9IF9hLnJvdW5kUG9zLFxuICAgICAgcm91bmREZXBhID0gX2Eucm91bmREZXBhO1xuICAgIHBhcmFtLmRlc3RQb3MgPSByb3VuZFBvcztcbiAgICBwYXJhbS5kZXBhUG9zID0gcm91bmREZXBhO1xuICAgIHBhcmFtLnNldFRvID0gdGhpcy5fY3JlYXRlVXNlckNvbnRyb2xsKHBhcmFtLmRlc3RQb3MsIHBhcmFtLmR1cmF0aW9uKTtcbiAgICB0aGlzLl9heGVzLnRyaWdnZXIobmV3IENvbXBvbmVudEV2ZW50JDEoXCJyZWxlYXNlXCIsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBwYXJhbSksIHtcbiAgICAgIGJvdW5jZVJhdGlvOiB0aGlzLl9nZXRCb3VuY2VSYXRpbyhyb3VuZFBvcylcbiAgICB9KSkpO1xuICB9O1xuICAvKipcbiAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIGNvb3JkaW5hdGUgY2hhbmdlcy5cbiAgICogQGtvIOyijO2RnOqwgCDrs4Dqsr3rkJDsnYQg65WMIOuwnOyDne2VmOuKlCDsnbTrsqTtirhcbiAgICogQGV2ZW50IEF4ZXMjY2hhbmdlXG4gICAqIEB0eXBlIHtvYmplY3R9XG4gICAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsIG51bWJlcj59IHBvcyAgVGhlIGNvb3JkaW5hdGUgPGtvPuyijO2RnDwva28+XG4gICAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsIG51bWJlcj59IGRlbHRhICBUaGUgbW92ZW1lbnQgdmFyaWF0aW9uIG9mIGNvb3JkaW5hdGUgPGtvPuyijO2RnOydmCDrs4DtmZTrn4k8L2tvPlxuICAgKiBAcHJvcGVydHkge09iamVjdC48c3RyaW5nLCBudW1iZXI+fSBib3VuY2VSYXRpbyBJZiB0aGUgY3VycmVudCBjb29yZGluYXRlcyBhcmUgaW4gdGhlIGJvdW5jZSBhcmVhLCB0aGUgY3VycmVudCBib3VuY2UgdmFsdWUgZGl2aWRlZCBieSB0aGUgbWF4aW11bSBib3VuY2UgdmFsdWUgPGtvPu2YhOyerCDsooztkZzqsIAgYm91bmNlIOyYgeyXreyXkCDsnojripQg6rK97JqwIO2YhOyerCBib3VuY2XrkJwg6rCS7J2EIOy1nOuMgCBib3VuY2Ug6rCS7Jy866GcIOuCmOuIiCDsiJjsuZguPC9rbz5cbiAgICogQHByb3BlcnR5IHtCb29sZWFufSBob2xkaW5nIEluZGljYXRlcyB3aGV0aGVyIGEgdXNlciBob2xkcyBhbiBlbGVtZW50IG9uIHRoZSBzY3JlZW4gb2YgdGhlIGRldmljZS48a28+7IKs7Jqp7J6Q6rCAIOq4sOq4sOydmCDtmZTrqbTsnYQg64iE66W06rOgIOyeiOuKlOyngCDsl6zrtoA8L2tvPlxuICAgKiBAcHJvcGVydHkge09iamVjdH0gaW5wdXQgVGhlIGluc3RhbmNlIG9mIGlucHV0VHlwZSB3aGVyZSB0aGUgZXZlbnQgb2NjdXJyZWQuIElmIHRoZSB2YWx1ZSBpcyBjaGFuZ2VkIGJ5IGFuaW1hdGlvbiwgaXQgcmV0dXJucyAnbnVsbCcuPGtvPuydtOuypO2KuOqwgCDrsJzsg53tlZwgaW5wdXRUeXBlIOyduOyKpO2EtOyKpC4g7JWg64uI66mU7J207IWY7JeQIOydmO2VtCDqsJLsnbQg67OA6rK965CgIOqyveyasOyXkOuKlCAnbnVsbCfsnYQg67CY7ZmY7ZWc64ukLjwva28+XG4gICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBpbnB1dEV2ZW50IFRoZSBldmVudCBvYmplY3QgcmVjZWl2ZWQgZnJvbSBpbnB1dFR5cGUuIElmIHRoZSB2YWx1ZSBpcyBjaGFuZ2VkIGJ5IGFuaW1hdGlvbiwgaXQgcmV0dXJucyAnbnVsbCcuPGtvPmlucHV0VHlwZeycvOuhnCDrtoDthLAg67Cb7J2AIOydtOuypO2KuCDqsJ3ssrQuIOyVoOuLiOuplOydtOyFmOyXkCDsnZjtlbQg6rCS7J20IOuzgOqyveuQoCDqsr3smrDsl5DripQgJ251bGwn7J2EIOuwmO2ZmO2VnOuLpC48L2tvPlxuICAgKiBAcHJvcGVydHkge3NldH0gc2V0IFNwZWNpZmllcyB0aGUgY29vcmRpbmF0ZXMgdG8gbW92ZSBhZnRlciB0aGUgZXZlbnQuIEl0IHdvcmtzIHdoZW4gdGhlIGhvbGRpbmcgdmFsdWUgaXMgdHJ1ZSA8a28+7J2067Kk7Yq4IOydtO2bhCDsnbTrj5ntlaAg7KKM7ZGc66W8IOyngOygle2VnOuLpC4gaG9sZGluZyDqsJLsnbQgdHJ1ZeydvCDqsr3smrDsl5Ag64+Z7J6R7ZWc64ukLjwva28+XG4gICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gaXNUcnVzdGVkIFJldHVybnMgdHJ1ZSBpZiBhbiBldmVudCB3YXMgZ2VuZXJhdGVkIGJ5IHRoZSB1c2VyIGFjdGlvbiwgb3IgZmFsc2UgaWYgaXQgd2FzIGNhdXNlZCBieSBhIHNjcmlwdCBvciBBUEkgY2FsbCA8a28+7IKs7Jqp7J6Q7J2YIOyVoeyFmOyXkCDsnZjtlbQg7J2067Kk7Yq46rCAIOuwnOyDne2VmOyYgOycvOuptCB0cnVlLCDsiqTtgazrpr3tirjrgpggQVBJ7Zi47Lac7JeQIOydmO2VtCDrsJzsg53tlZjsmIDsnYQg6rK97Jqw7JeQ64qUIGZhbHNl66W8IOuwmO2ZmO2VnOuLpC48L2tvPlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBjb25zdCBheGVzID0gbmV3IGVnLkF4ZXMoe1xuICAgKiAgIFwieFwiOiB7XG4gICAqICAgICAgcmFuZ2U6IFswLCAxMDBdXG4gICAqICAgfSxcbiAgICogICBcInpvb21cIjoge1xuICAgKiAgICAgIHJhbmdlOiBbNTAsIDMwXVxuICAgKiAgIH1cbiAgICogfSkub24oXCJjaGFuZ2VcIiwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICogICAvLyBldmVudC5wb3NcbiAgICogICAvLyBldmVudC5kZWx0YVxuICAgKiAgIC8vIGV2ZW50LmlucHV0XG4gICAqICAgLy8gZXZlbnQuaW5wdXRFdmVudFxuICAgKiAgIC8vIGV2ZW50LmhvbGRpbmdcbiAgICogICAvLyBldmVudC5zZXRcbiAgICogICAvLyBldmVudC5pc1RydXN0ZWRcbiAgICpcbiAgICogICAvLyBpZiB5b3Ugd2FudCB0byBjaGFuZ2UgdGhlIGNvb3JkaW5hdGVzIHRvIG1vdmUgYWZ0ZXIgdGhlICdjaGFuZ2UnIGV2ZW50LlxuICAgKiAgIC8vIGl0IHdvcmtzIHdoZW4gdGhlIGhvbGRpbmcgdmFsdWUgb2YgdGhlIGNoYW5nZSBldmVudCBpcyB0cnVlLlxuICAgKiAgIGV2ZW50LmhvbGRpbmcgJiYgZXZlbnQuc2V0KHt4OiAxMH0pO1xuICAgKiB9KTtcbiAgICogYGBgXG4gICAqL1xuICBfX3Byb3RvLnRyaWdnZXJDaGFuZ2UgPSBmdW5jdGlvbiAocG9zLCBkZXBhUG9zLCBvcHRpb24sIGhvbGRpbmcpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIGlmIChob2xkaW5nID09PSB2b2lkIDApIHtcbiAgICAgIGhvbGRpbmcgPSBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGFuaW1hdGlvbk1hbmFnZXIgPSB0aGlzLmFuaW1hdGlvbk1hbmFnZXI7XG4gICAgdmFyIGF4aXNNYW5hZ2VyID0gYW5pbWF0aW9uTWFuYWdlci5heGlzTWFuYWdlcjtcbiAgICB2YXIgZXZlbnRJbmZvID0gYW5pbWF0aW9uTWFuYWdlci5nZXRFdmVudEluZm8oKTtcbiAgICB2YXIgX2EgPSB0aGlzLl9nZXRSb3VuZFBvcyhwb3MsIGRlcGFQb3MpLFxuICAgICAgcm91bmRQb3MgPSBfYS5yb3VuZFBvcyxcbiAgICAgIHJvdW5kRGVwYSA9IF9hLnJvdW5kRGVwYTtcbiAgICB2YXIgbW92ZVRvID0gYXhpc01hbmFnZXIubW92ZVRvKHJvdW5kUG9zLCByb3VuZERlcGEpO1xuICAgIHZhciBpbnB1dEV2ZW50ID0gKG9wdGlvbiA9PT0gbnVsbCB8fCBvcHRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbi5ldmVudCkgfHwgKGV2ZW50SW5mbyA9PT0gbnVsbCB8fCBldmVudEluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGV2ZW50SW5mby5ldmVudCkgfHwgbnVsbDtcbiAgICB2YXIgcGFyYW0gPSB7XG4gICAgICBwb3M6IG1vdmVUby5wb3MsXG4gICAgICBkZWx0YTogbW92ZVRvLmRlbHRhLFxuICAgICAgYm91bmNlUmF0aW86IHRoaXMuX2dldEJvdW5jZVJhdGlvKG1vdmVUby5wb3MpLFxuICAgICAgaG9sZGluZzogaG9sZGluZyxcbiAgICAgIGlucHV0RXZlbnQ6IGlucHV0RXZlbnQsXG4gICAgICBpc1RydXN0ZWQ6ICEhaW5wdXRFdmVudCxcbiAgICAgIGlucHV0OiAob3B0aW9uID09PSBudWxsIHx8IG9wdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9uLmlucHV0KSB8fCAoZXZlbnRJbmZvID09PSBudWxsIHx8IGV2ZW50SW5mbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXZlbnRJbmZvLmlucHV0KSB8fCBudWxsLFxuICAgICAgc2V0OiBpbnB1dEV2ZW50ID8gdGhpcy5fY3JlYXRlVXNlckNvbnRyb2xsKG1vdmVUby5wb3MpIDogZnVuY3Rpb24gKCkge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZW1wdHktZnVuY3Rpb25cbiAgICB9O1xuXG4gICAgdmFyIGV2ZW50ID0gbmV3IENvbXBvbmVudEV2ZW50JDEoXCJjaGFuZ2VcIiwgcGFyYW0pO1xuICAgIHRoaXMuX2F4ZXMudHJpZ2dlcihldmVudCk7XG4gICAgT2JqZWN0LmtleXMobW92ZVRvLnBvcykuZm9yRWFjaChmdW5jdGlvbiAoYXhpcykge1xuICAgICAgdmFyIHAgPSBtb3ZlVG8ucG9zW2F4aXNdO1xuICAgICAgZ2V0T2JzZXJ2ZXIoX3RoaXMuX2F4ZXMsIGF4aXMsIHApLmN1cnJlbnQgPSBwO1xuICAgIH0pO1xuICAgIGlmIChpbnB1dEV2ZW50KSB7XG4gICAgICBheGlzTWFuYWdlci5zZXQocGFyYW0uc2V0KCkuZGVzdFBvcyk7XG4gICAgfVxuICAgIHJldHVybiAhZXZlbnQuaXNDYW5jZWxlZCgpO1xuICB9O1xuICAvKipcbiAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIGFuaW1hdGlvbiBzdGFydHMuXG4gICAqIEBrbyDsl5Dri4jrqZTsnbTshZjsnbQg7Iuc7J6R7ZWgIOuVjCDrsJzsg53tlZzri6QuXG4gICAqIEBldmVudCBBeGVzI2FuaW1hdGlvblN0YXJ0XG4gICAqIEB0eXBlIHtvYmplY3R9XG4gICAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsIG51bWJlcj59IGRlcGFQb3MgVGhlIGNvb3JkaW5hdGVzIHdoZW4gYW5pbWF0aW9uIHN0YXJ0czxrbz7slaDri4jrqZTsnbTshZjsnbQg7Iuc7J6RIOuQmOyXiOydhCDrlYzsnZgg7KKM7ZGcIDwva28+XG4gICAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsIG51bWJlcj59IGRlc3RQb3MgVGhlIGNvb3JkaW5hdGVzIHRvIG1vdmUgdG8uIElmIHlvdSBjaGFuZ2UgdGhpcyB2YWx1ZSwgeW91IGNhbiBydW4gdGhlIGFuaW1hdGlvbjxrbz7snbTrj5ntlaAg7KKM7ZGcLiDsnbTqsJLsnYQg67OA6rK97ZWY7JesIOyVoOuLiOuplOydtOyFmOydhCDrj5nsnpHsi5ztgqzsiJgg7J6I64ukPC9rbz5cbiAgICogQHByb3BlcnR5IHtPYmplY3QuPHN0cmluZywgbnVtYmVyPn0gZGVsdGEgIFRoZSBtb3ZlbWVudCB2YXJpYXRpb24gb2YgY29vcmRpbmF0ZSA8a28+7KKM7ZGc7J2YIOuzgO2ZlOufiTwva28+XG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBkdXJhdGlvbiBEdXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uICh1bml0OiBtcykuIElmIHlvdSBjaGFuZ2UgdGhpcyB2YWx1ZSwgeW91IGNhbiBjb250cm9sIHRoZSBhbmltYXRpb24gZHVyYXRpb24gdGltZS48a28+7JWg64uI66mU7J207IWYIOynhO2WiSDsi5zqsIQo64uo7JyEOiBtcykuIOydtOqwkuydhCDrs4Dqsr3tlZjsl6wg7JWg64uI66mU7J207IWY7J2YIOydtOuPmeyLnOqwhOydhCDsobDsoIjtlaAg7IiYIOyeiOuLpC48L2tvPlxuICAgKiBAcHJvcGVydHkge09iamVjdH0gaW5wdXQgVGhlIGluc3RhbmNlIG9mIGlucHV0VHlwZSB3aGVyZSB0aGUgZXZlbnQgb2NjdXJyZWQuIElmIHRoZSB2YWx1ZSBpcyBjaGFuZ2VkIGJ5IGFuaW1hdGlvbiwgaXQgcmV0dXJucyAnbnVsbCcuPGtvPuydtOuypO2KuOqwgCDrsJzsg53tlZwgaW5wdXRUeXBlIOyduOyKpO2EtOyKpC4g7JWg64uI66mU7J207IWY7JeQIOydmO2VtCDqsJLsnbQg67OA6rK965CgIOqyveyasOyXkOuKlCAnbnVsbCfsnYQg67CY7ZmY7ZWc64ukLjwva28+XG4gICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBpbnB1dEV2ZW50IFRoZSBldmVudCBvYmplY3QgcmVjZWl2ZWQgZnJvbSBpbnB1dFR5cGUgPGtvPmlucHV0VHlwZeycvOuhnCDrtoDthLAg67Cb7J2AIOydtOuypO2KuCDqsJ3ssrQ8L2tvPlxuICAgKiBAcHJvcGVydHkge3NldFRvfSBzZXRUbyBTcGVjaWZpZXMgdGhlIGFuaW1hdGlvbiBjb29yZGluYXRlcyB0byBtb3ZlIGFmdGVyIHRoZSBldmVudCA8a28+7J2067Kk7Yq4IOydtO2bhCDsnbTrj5ntlaAg7JWg64uI66mU7J207IWYIOyijO2RnOulvCDsp4DsoJXtlZzri6Q8L2tvPlxuICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGlzVHJ1c3RlZCBSZXR1cm5zIHRydWUgaWYgYW4gZXZlbnQgd2FzIGdlbmVyYXRlZCBieSB0aGUgdXNlciBhY3Rpb24sIG9yIGZhbHNlIGlmIGl0IHdhcyBjYXVzZWQgYnkgYSBzY3JpcHQgb3IgQVBJIGNhbGwgPGtvPuyCrOyaqeyekOydmCDslaHshZjsl5Ag7J2Y7ZW0IOydtOuypO2KuOqwgCDrsJzsg53tlZjsmIDsnLzrqbQgdHJ1ZSwg7Iqk7YGs66a97Yq464KYIEFQSe2YuOy2nOyXkCDsnZjtlbQg67Cc7IOd7ZWY7JiA7J2EIOqyveyasOyXkOuKlCBmYWxzZeulvCDrsJjtmZjtlZzri6QuPC9rbz5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogY29uc3QgYXhlcyA9IG5ldyBlZy5BeGVzKHtcbiAgICogICBcInhcIjoge1xuICAgKiAgICAgIHJhbmdlOiBbMCwgMTAwXVxuICAgKiAgIH0sXG4gICAqICAgXCJ6b29tXCI6IHtcbiAgICogICAgICByYW5nZTogWzUwLCAzMF1cbiAgICogICB9XG4gICAqIH0pLm9uKFwicmVsZWFzZVwiLCBmdW5jdGlvbihldmVudCkge1xuICAgKiAgIC8vIGV2ZW50LmRlcGFQb3NcbiAgICogICAvLyBldmVudC5kZXN0UG9zXG4gICAqICAgLy8gZXZlbnQuZGVsdGFcbiAgICogICAvLyBldmVudC5pbnB1dFxuICAgKiAgIC8vIGV2ZW50LmlucHV0RXZlbnRcbiAgICogICAvLyBldmVudC5zZXRUb1xuICAgKiAgIC8vIGV2ZW50LmlzVHJ1c3RlZFxuICAgKlxuICAgKiAgIC8vIGlmIHlvdSB3YW50IHRvIGNoYW5nZSB0aGUgYW5pbWF0aW9uIGNvb3JkaW5hdGVzIHRvIG1vdmUgYWZ0ZXIgdGhlICdhbmltYXRpb25TdGFydCcgZXZlbnQuXG4gICAqICAgZXZlbnQuc2V0VG8oe3g6IDEwfSwgMjAwMCk7XG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICovXG4gIF9fcHJvdG8udHJpZ2dlckFuaW1hdGlvblN0YXJ0ID0gZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgdmFyIF9hID0gdGhpcy5fZ2V0Um91bmRQb3MocGFyYW0uZGVzdFBvcywgcGFyYW0uZGVwYVBvcyksXG4gICAgICByb3VuZFBvcyA9IF9hLnJvdW5kUG9zLFxuICAgICAgcm91bmREZXBhID0gX2Eucm91bmREZXBhO1xuICAgIHBhcmFtLmRlc3RQb3MgPSByb3VuZFBvcztcbiAgICBwYXJhbS5kZXBhUG9zID0gcm91bmREZXBhO1xuICAgIHBhcmFtLnNldFRvID0gdGhpcy5fY3JlYXRlVXNlckNvbnRyb2xsKHBhcmFtLmRlc3RQb3MsIHBhcmFtLmR1cmF0aW9uKTtcbiAgICB2YXIgZXZlbnQgPSBuZXcgQ29tcG9uZW50RXZlbnQkMShcImFuaW1hdGlvblN0YXJ0XCIsIHBhcmFtKTtcbiAgICB0aGlzLl9heGVzLnRyaWdnZXIoZXZlbnQpO1xuICAgIHJldHVybiAhZXZlbnQuaXNDYW5jZWxlZCgpO1xuICB9O1xuICAvKipcbiAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIGFuaW1hdGlvbiBlbmRzLlxuICAgKiBAa28g7JeQ64uI66mU7J207IWY7J20IOuBneuCrOydhCDrlYwg67Cc7IOd7ZWc64ukLlxuICAgKiBAZXZlbnQgQXhlcyNhbmltYXRpb25FbmRcbiAgICogQHR5cGUge29iamVjdH1cbiAgICogQHByb3BlcnR5IHtCb29sZWFufSBpc1RydXN0ZWQgUmV0dXJucyB0cnVlIGlmIGFuIGV2ZW50IHdhcyBnZW5lcmF0ZWQgYnkgdGhlIHVzZXIgYWN0aW9uLCBvciBmYWxzZSBpZiBpdCB3YXMgY2F1c2VkIGJ5IGEgc2NyaXB0IG9yIEFQSSBjYWxsIDxrbz7sgqzsmqnsnpDsnZgg7JWh7IWY7JeQIOydmO2VtCDsnbTrsqTtirjqsIAg67Cc7IOd7ZWY7JiA7Jy866m0IHRydWUsIOyKpO2BrOumve2KuOuCmCBBUEntmLjstpzsl5Ag7J2Y7ZW0IOuwnOyDne2VmOyYgOydhCDqsr3smrDsl5DripQgZmFsc2Xrpbwg67CY7ZmY7ZWc64ukLjwva28+XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IGF4ZXMgPSBuZXcgZWcuQXhlcyh7XG4gICAqICAgXCJ4XCI6IHtcbiAgICogICAgICByYW5nZTogWzAsIDEwMF1cbiAgICogICB9LFxuICAgKiAgIFwiem9vbVwiOiB7XG4gICAqICAgICAgcmFuZ2U6IFs1MCwgMzBdXG4gICAqICAgfVxuICAgKiB9KS5vbihcImFuaW1hdGlvbkVuZFwiLCBmdW5jdGlvbihldmVudCkge1xuICAgKiAgIC8vIGV2ZW50LmlzVHJ1c3RlZFxuICAgKiB9KTtcbiAgICogYGBgXG4gICAqL1xuICBfX3Byb3RvLnRyaWdnZXJBbmltYXRpb25FbmQgPSBmdW5jdGlvbiAoaXNUcnVzdGVkKSB7XG4gICAgaWYgKGlzVHJ1c3RlZCA9PT0gdm9pZCAwKSB7XG4gICAgICBpc1RydXN0ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5fYXhlcy50cmlnZ2VyKG5ldyBDb21wb25lbnRFdmVudCQxKFwiYW5pbWF0aW9uRW5kXCIsIHtcbiAgICAgIGlzVHJ1c3RlZDogaXNUcnVzdGVkXG4gICAgfSkpO1xuICB9O1xuICAvKipcbiAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIGFsbCBhY3Rpb25zIGhhdmUgYmVlbiBjb21wbGV0ZWQuXG4gICAqIEBrbyDsl5Dri4jrqZTsnbTshZjsnbQg64Gd64Ks7J2EIOuVjCDrsJzsg53tlZzri6QuXG4gICAqIEBldmVudCBBeGVzI2ZpbmlzaFxuICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGlzVHJ1c3RlZCBSZXR1cm5zIHRydWUgaWYgYW4gZXZlbnQgd2FzIGdlbmVyYXRlZCBieSB0aGUgdXNlciBhY3Rpb24sIG9yIGZhbHNlIGlmIGl0IHdhcyBjYXVzZWQgYnkgYSBzY3JpcHQgb3IgQVBJIGNhbGwgPGtvPuyCrOyaqeyekOydmCDslaHshZjsl5Ag7J2Y7ZW0IOydtOuypO2KuOqwgCDrsJzsg53tlZjsmIDsnLzrqbQgdHJ1ZSwg7Iqk7YGs66a97Yq464KYIEFQSe2YuOy2nOyXkCDsnZjtlbQg67Cc7IOd7ZWY7JiA7J2EIOqyveyasOyXkOuKlCBmYWxzZeulvCDrsJjtmZjtlZzri6QuPC9rbz5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogY29uc3QgYXhlcyA9IG5ldyBlZy5BeGVzKHtcbiAgICogICBcInhcIjoge1xuICAgKiAgICAgIHJhbmdlOiBbMCwgMTAwXVxuICAgKiAgIH0sXG4gICAqICAgXCJ6b29tXCI6IHtcbiAgICogICAgICByYW5nZTogWzUwLCAzMF1cbiAgICogICB9XG4gICAqIH0pLm9uKFwiZmluaXNoXCIsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAqICAgLy8gZXZlbnQuaXNUcnVzdGVkXG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICovXG4gIF9fcHJvdG8udHJpZ2dlckZpbmlzaCA9IGZ1bmN0aW9uIChpc1RydXN0ZWQpIHtcbiAgICBpZiAoaXNUcnVzdGVkID09PSB2b2lkIDApIHtcbiAgICAgIGlzVHJ1c3RlZCA9IGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLl9heGVzLnRyaWdnZXIobmV3IENvbXBvbmVudEV2ZW50JDEoXCJmaW5pc2hcIiwge1xuICAgICAgaXNUcnVzdGVkOiBpc1RydXN0ZWRcbiAgICB9KSk7XG4gIH07XG4gIF9fcHJvdG8uc2V0QW5pbWF0aW9uTWFuYWdlciA9IGZ1bmN0aW9uIChhbmltYXRpb25NYW5hZ2VyKSB7XG4gICAgdGhpcy5hbmltYXRpb25NYW5hZ2VyID0gYW5pbWF0aW9uTWFuYWdlcjtcbiAgfTtcbiAgX19wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2F4ZXMub2ZmKCk7XG4gIH07XG4gIF9fcHJvdG8uX2NyZWF0ZVVzZXJDb250cm9sbCA9IGZ1bmN0aW9uIChwb3MsIGR1cmF0aW9uKSB7XG4gICAgaWYgKGR1cmF0aW9uID09PSB2b2lkIDApIHtcbiAgICAgIGR1cmF0aW9uID0gMDtcbiAgICB9XG4gICAgLy8gdG8gY29udHJvbGxcbiAgICB2YXIgdXNlckNvbnRyb2wgPSB7XG4gICAgICBkZXN0UG9zOiBfX2Fzc2lnbih7fSwgcG9zKSxcbiAgICAgIGR1cmF0aW9uOiBkdXJhdGlvblxuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0b1BvcywgdXNlckR1cmF0aW9uKSB7XG4gICAgICBpZiAodG9Qb3MpIHtcbiAgICAgICAgdXNlckNvbnRyb2wuZGVzdFBvcyA9IF9fYXNzaWduKHt9LCB0b1Bvcyk7XG4gICAgICB9XG4gICAgICBpZiAodXNlckR1cmF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdXNlckNvbnRyb2wuZHVyYXRpb24gPSB1c2VyRHVyYXRpb247XG4gICAgICB9XG4gICAgICByZXR1cm4gdXNlckNvbnRyb2w7XG4gICAgfTtcbiAgfTtcbiAgX19wcm90by5fZ2V0Um91bmRQb3MgPSBmdW5jdGlvbiAocG9zLCBkZXBhUG9zKSB7XG4gICAgLy8gcm91bmQgdmFsdWUgaWYgcm91bmQgZXhpc3RcbiAgICB2YXIgcm91bmRVbml0ID0gdGhpcy5fYXhlcy5vcHRpb25zLnJvdW5kO1xuICAgIC8vIGlmIChyb3VuZCA9PSBudWxsKSB7XG4gICAgLy8gICByZXR1cm4ge3BvcywgZGVwYVBvc307IC8vIHVuZGVmaW5lZCwgdW5kZWZpbmVkXG4gICAgLy8gfVxuICAgIHJldHVybiB7XG4gICAgICByb3VuZFBvczogcm91bmROdW1iZXJzKHBvcywgcm91bmRVbml0KSxcbiAgICAgIHJvdW5kRGVwYTogcm91bmROdW1iZXJzKGRlcGFQb3MsIHJvdW5kVW5pdClcbiAgICB9O1xuICB9O1xuICBfX3Byb3RvLl9nZXRCb3VuY2VSYXRpbyA9IGZ1bmN0aW9uIChwb3MpIHtcbiAgICByZXR1cm4gdGhpcy5fYXhlcy5heGlzTWFuYWdlci5tYXAocG9zLCBmdW5jdGlvbiAodiwgb3B0KSB7XG4gICAgICBpZiAodiA8IG9wdC5yYW5nZVswXSAmJiBvcHQuYm91bmNlWzBdICE9PSAwKSB7XG4gICAgICAgIHJldHVybiAob3B0LnJhbmdlWzBdIC0gdikgLyBvcHQuYm91bmNlWzBdO1xuICAgICAgfSBlbHNlIGlmICh2ID4gb3B0LnJhbmdlWzFdICYmIG9wdC5ib3VuY2VbMV0gIT09IDApIHtcbiAgICAgICAgcmV0dXJuICh2IC0gb3B0LnJhbmdlWzFdKSAvIG9wdC5ib3VuY2VbMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgX19kZWNvcmF0ZShbT2JzZXJ2ZV0sIEV2ZW50TWFuYWdlci5wcm90b3R5cGUsIFwiaG9sZGluZ0NvdW50XCIsIHZvaWQgMCk7XG4gIHJldHVybiBFdmVudE1hbmFnZXI7XG59KCk7XG5cbnZhciBJbnRlcnJ1cHRNYW5hZ2VyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gSW50ZXJydXB0TWFuYWdlcihfb3B0aW9ucykge1xuICAgIHRoaXMuX29wdGlvbnMgPSBfb3B0aW9ucztcbiAgICB0aGlzLl9wcmV2ZW50ZWQgPSBmYWxzZTsgLy8gIGNoZWNrIHdoZXRoZXIgdGhlIGFuaW1hdGlvbiBldmVudCB3YXMgcHJldmVudGVkXG4gIH1cbiAgdmFyIF9fcHJvdG8gPSBJbnRlcnJ1cHRNYW5hZ2VyLnByb3RvdHlwZTtcbiAgX19wcm90by5pc0ludGVycnVwdGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyB3aGVuIGludGVycnVwdGFibGUgaXMgJ3RydWUnLCByZXR1cm4gdmFsdWUgaXMgYWx3YXlzICd0cnVlJy5cbiAgICByZXR1cm4gdGhpcy5fb3B0aW9ucy5pbnRlcnJ1cHRhYmxlIHx8IHRoaXMuX3ByZXZlbnRlZDtcbiAgfTtcbiAgX19wcm90by5pc0ludGVycnVwdGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAhdGhpcy5fb3B0aW9ucy5pbnRlcnJ1cHRhYmxlICYmIHRoaXMuX3ByZXZlbnRlZDtcbiAgfTtcbiAgX19wcm90by5zZXRJbnRlcnJ1cHQgPSBmdW5jdGlvbiAocHJldmVudGVkKSB7XG4gICAgaWYgKCF0aGlzLl9vcHRpb25zLmludGVycnVwdGFibGUpIHtcbiAgICAgIHRoaXMuX3ByZXZlbnRlZCA9IHByZXZlbnRlZDtcbiAgICB9XG4gIH07XG4gIHJldHVybiBJbnRlcnJ1cHRNYW5hZ2VyO1xufSgpO1xuXG4vKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IE5BVkVSIENvcnAuXG4gKiBlZ2pzIHByb2plY3RzIGFyZSBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xudmFyIGdldEluc2lkZVBvc2l0aW9uID0gZnVuY3Rpb24gKGRlc3RQb3MsIHJhbmdlLCBjaXJjdWxhciwgYm91bmNlKSB7XG4gIHZhciB0b0Rlc3RQb3MgPSBkZXN0UG9zO1xuICB2YXIgdGFyZ2V0UmFuZ2UgPSBbY2lyY3VsYXJbMF0gPyByYW5nZVswXSA6IGJvdW5jZSA/IHJhbmdlWzBdIC0gYm91bmNlWzBdIDogcmFuZ2VbMF0sIGNpcmN1bGFyWzFdID8gcmFuZ2VbMV0gOiBib3VuY2UgPyByYW5nZVsxXSArIGJvdW5jZVsxXSA6IHJhbmdlWzFdXTtcbiAgdG9EZXN0UG9zID0gTWF0aC5tYXgodGFyZ2V0UmFuZ2VbMF0sIHRvRGVzdFBvcyk7XG4gIHRvRGVzdFBvcyA9IE1hdGgubWluKHRhcmdldFJhbmdlWzFdLCB0b0Rlc3RQb3MpO1xuICByZXR1cm4gdG9EZXN0UG9zO1xufTtcbi8vIGRldGVybWluZSBvdXRzaWRlXG52YXIgaXNPdXRzaWRlID0gZnVuY3Rpb24gKHBvcywgcmFuZ2UpIHtcbiAgcmV0dXJuIHBvcyA8IHJhbmdlWzBdIHx8IHBvcyA+IHJhbmdlWzFdO1xufTtcbi8vIGRldGVybWluZSB3aGV0aGVyIHBvc2l0aW9uIGhhcyByZWFjaGVkIHRoZSBtYXhpbXVtIG1vdmVhYmxlIGFyZWFcbnZhciBpc0VuZG9mQm91bmNlID0gZnVuY3Rpb24gKHBvcywgcmFuZ2UsIGJvdW5jZSwgY2lyY3VsYXIpIHtcbiAgcmV0dXJuICFjaXJjdWxhclswXSAmJiBwb3MgPT09IHJhbmdlWzBdIC0gYm91bmNlWzBdIHx8ICFjaXJjdWxhclsxXSAmJiBwb3MgPT09IHJhbmdlWzFdICsgYm91bmNlWzFdO1xufTtcbnZhciBnZXREdXJhdGlvbiA9IGZ1bmN0aW9uIChkaXN0YW5jZSwgZGVjZWxlcmF0aW9uKSB7XG4gIHZhciBkdXJhdGlvbiA9IE1hdGguc3FydChkaXN0YW5jZSAvIGRlY2VsZXJhdGlvbiAqIDIpO1xuICAvLyB3aGVuIGR1cmF0aW9uIGlzIHVuZGVyIDEwMCwgdGhlbiB2YWx1ZSBpcyB6ZXJvXG4gIHJldHVybiBkdXJhdGlvbiA8IDEwMCA/IDAgOiBkdXJhdGlvbjtcbn07XG52YXIgaXNDaXJjdWxhcmFibGUgPSBmdW5jdGlvbiAoZGVzdFBvcywgcmFuZ2UsIGNpcmN1bGFyKSB7XG4gIHJldHVybiBjaXJjdWxhclsxXSAmJiBkZXN0UG9zID4gcmFuZ2VbMV0gfHwgY2lyY3VsYXJbMF0gJiYgZGVzdFBvcyA8IHJhbmdlWzBdO1xufTtcbnZhciBnZXRDaXJjdWxhdGVkUG9zID0gZnVuY3Rpb24gKHBvcywgcmFuZ2UsIGNpcmN1bGFyKSB7XG4gIHZhciB0b1BvcyA9IHBvcztcbiAgdmFyIG1pbiA9IHJhbmdlWzBdO1xuICB2YXIgbWF4ID0gcmFuZ2VbMV07XG4gIHZhciBsZW5ndGggPSBtYXggLSBtaW47XG4gIGlmIChjaXJjdWxhclsxXSAmJiBwb3MgPiBtYXgpIHtcbiAgICAvLyByaWdodFxuICAgIHRvUG9zID0gKHRvUG9zIC0gbWF4KSAlIGxlbmd0aCArIG1pbjtcbiAgfVxuICBpZiAoY2lyY3VsYXJbMF0gJiYgcG9zIDwgbWluKSB7XG4gICAgLy8gbGVmdFxuICAgIHRvUG9zID0gKHRvUG9zIC0gbWluKSAlIGxlbmd0aCArIG1heDtcbiAgfVxuICByZXR1cm4gdG9Qb3M7XG59O1xuXG52YXIgQXhpc01hbmFnZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBBeGlzTWFuYWdlcihfYXhpcykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdGhpcy5fYXhpcyA9IF9heGlzO1xuICAgIHRoaXMuX2NvbXBsZW1lbnRPcHRpb25zKCk7XG4gICAgdGhpcy5fcG9zID0gT2JqZWN0LmtleXModGhpcy5fYXhpcykucmVkdWNlKGZ1bmN0aW9uIChwb3MsIHYpIHtcbiAgICAgIHBvc1t2XSA9IF90aGlzLl9heGlzW3ZdLnN0YXJ0UG9zO1xuICAgICAgcmV0dXJuIHBvcztcbiAgICB9LCB7fSk7XG4gIH1cbiAgdmFyIF9fcHJvdG8gPSBBeGlzTWFuYWdlci5wcm90b3R5cGU7XG4gIF9fcHJvdG8uZ2V0RGVsdGEgPSBmdW5jdGlvbiAoZGVwYVBvcywgZGVzdFBvcykge1xuICAgIHZhciBmdWxsRGVwYVBvcyA9IHRoaXMuZ2V0KGRlcGFQb3MpO1xuICAgIHJldHVybiBtYXAodGhpcy5nZXQoZGVzdFBvcyksIGZ1bmN0aW9uICh2LCBrKSB7XG4gICAgICByZXR1cm4gdiAtIGZ1bGxEZXBhUG9zW2tdO1xuICAgIH0pO1xuICB9O1xuICBfX3Byb3RvLmdldCA9IGZ1bmN0aW9uIChheGVzKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBpZiAoYXhlcyAmJiBBcnJheS5pc0FycmF5KGF4ZXMpKSB7XG4gICAgICByZXR1cm4gYXhlcy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgdikge1xuICAgICAgICBpZiAodiAmJiB2IGluIF90aGlzLl9wb3MpIHtcbiAgICAgICAgICBhY2Nbdl0gPSBfdGhpcy5fcG9zW3ZdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICB9LCB7fSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgdGhpcy5fcG9zKSwgYXhlcyB8fCB7fSk7XG4gICAgfVxuICB9O1xuICBfX3Byb3RvLm1vdmVUbyA9IGZ1bmN0aW9uIChwb3MsIGRlcGFQb3MpIHtcbiAgICBpZiAoZGVwYVBvcyA9PT0gdm9pZCAwKSB7XG4gICAgICBkZXBhUG9zID0gdGhpcy5fcG9zO1xuICAgIH1cbiAgICB2YXIgZGVsdGEgPSBtYXAodGhpcy5fcG9zLCBmdW5jdGlvbiAodiwga2V5KSB7XG4gICAgICByZXR1cm4ga2V5IGluIHBvcyAmJiBrZXkgaW4gZGVwYVBvcyA/IHBvc1trZXldIC0gZGVwYVBvc1trZXldIDogMDtcbiAgICB9KTtcbiAgICB0aGlzLnNldCh0aGlzLm1hcChwb3MsIGZ1bmN0aW9uICh2LCBvcHQpIHtcbiAgICAgIHJldHVybiBvcHQgPyBnZXRDaXJjdWxhdGVkUG9zKHYsIG9wdC5yYW5nZSwgb3B0LmNpcmN1bGFyKSA6IDA7XG4gICAgfSkpO1xuICAgIHJldHVybiB7XG4gICAgICBwb3M6IF9fYXNzaWduKHt9LCB0aGlzLl9wb3MpLFxuICAgICAgZGVsdGE6IGRlbHRhXG4gICAgfTtcbiAgfTtcbiAgX19wcm90by5zZXQgPSBmdW5jdGlvbiAocG9zKSB7XG4gICAgZm9yICh2YXIgayBpbiBwb3MpIHtcbiAgICAgIGlmIChrICYmIGsgaW4gdGhpcy5fcG9zKSB7XG4gICAgICAgIHRoaXMuX3Bvc1trXSA9IHBvc1trXTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIF9fcHJvdG8uZXZlcnkgPSBmdW5jdGlvbiAocG9zLCBjYWxsYmFjaykge1xuICAgIHZhciBheGlzT3B0aW9ucyA9IHRoaXMuX2F4aXM7XG4gICAgcmV0dXJuIGV2ZXJ5KHBvcywgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayh2YWx1ZSwgYXhpc09wdGlvbnNba2V5XSwga2V5KTtcbiAgICB9KTtcbiAgfTtcbiAgX19wcm90by5maWx0ZXIgPSBmdW5jdGlvbiAocG9zLCBjYWxsYmFjaykge1xuICAgIHZhciBheGlzT3B0aW9ucyA9IHRoaXMuX2F4aXM7XG4gICAgcmV0dXJuIGZpbHRlcihwb3MsIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2sodmFsdWUsIGF4aXNPcHRpb25zW2tleV0sIGtleSk7XG4gICAgfSk7XG4gIH07XG4gIF9fcHJvdG8ubWFwID0gZnVuY3Rpb24gKHBvcywgY2FsbGJhY2spIHtcbiAgICB2YXIgYXhpc09wdGlvbnMgPSB0aGlzLl9heGlzO1xuICAgIHJldHVybiBtYXAocG9zLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKHZhbHVlLCBheGlzT3B0aW9uc1trZXldLCBrZXkpO1xuICAgIH0pO1xuICB9O1xuICBfX3Byb3RvLmlzT3V0c2lkZSA9IGZ1bmN0aW9uIChheGVzKSB7XG4gICAgcmV0dXJuICF0aGlzLmV2ZXJ5KGF4ZXMgPyB0aGlzLmdldChheGVzKSA6IHRoaXMuX3BvcywgZnVuY3Rpb24gKHYsIG9wdCkge1xuICAgICAgcmV0dXJuICFpc091dHNpZGUodiwgb3B0LnJhbmdlKTtcbiAgICB9KTtcbiAgfTtcbiAgX19wcm90by5nZXRBeGlzT3B0aW9ucyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5fYXhpc1trZXldO1xuICB9O1xuICBfX3Byb3RvLnNldEF4aXMgPSBmdW5jdGlvbiAoYXhpcykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgT2JqZWN0LmtleXMoYXhpcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBpZiAoIV90aGlzLl9heGlzW2tleV0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXhpcyBcIi5jb25jYXQoa2V5LCBcIiBkb2VzIG5vdCBleGlzdCBpbiBBeGVzIGluc3RhbmNlXCIpKTtcbiAgICAgIH1cbiAgICAgIF90aGlzLl9heGlzW2tleV0gPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgX3RoaXMuX2F4aXNba2V5XSksIGF4aXNba2V5XSk7XG4gICAgfSk7XG4gICAgdGhpcy5fY29tcGxlbWVudE9wdGlvbnMoKTtcbiAgfTtcbiAgLyoqXG4gICAqIHNldCB1cCAnY3NzJyBleHByZXNzaW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfX3Byb3RvLl9jb21wbGVtZW50T3B0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIE9iamVjdC5rZXlzKHRoaXMuX2F4aXMpLmZvckVhY2goZnVuY3Rpb24gKGF4aXMpIHtcbiAgICAgIF90aGlzLl9heGlzW2F4aXNdID0gX19hc3NpZ24oe1xuICAgICAgICByYW5nZTogWzAsIDEwMF0sXG4gICAgICAgIHN0YXJ0UG9zOiBfdGhpcy5fYXhpc1theGlzXS5yYW5nZVswXSxcbiAgICAgICAgYm91bmNlOiBbMCwgMF0sXG4gICAgICAgIGNpcmN1bGFyOiBbZmFsc2UsIGZhbHNlXVxuICAgICAgfSwgX3RoaXMuX2F4aXNbYXhpc10pO1xuICAgICAgW1wiYm91bmNlXCIsIFwiY2lyY3VsYXJcIl0uZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgICAgICB2YXIgYXhpc09wdGlvbiA9IF90aGlzLl9heGlzO1xuICAgICAgICB2YXIga2V5ID0gYXhpc09wdGlvbltheGlzXVt2XTtcbiAgICAgICAgaWYgKC9zdHJpbmd8bnVtYmVyfGJvb2xlYW4vLnRlc3QodHlwZW9mIGtleSkpIHtcbiAgICAgICAgICBheGlzT3B0aW9uW2F4aXNdW3ZdID0gW2tleSwga2V5XTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG4gIHJldHVybiBBeGlzTWFuYWdlcjtcbn0oKTtcblxudmFyIFNVUFBPUlRfVE9VQ0ggPSAoXCJvbnRvdWNoc3RhcnRcIiBpbiB3aW4pO1xudmFyIFNVUFBPUlRfUE9JTlRFUiA9IChcIlBvaW50ZXJFdmVudFwiIGluIHdpbik7XG52YXIgU1VQUE9SVF9NU1BPSU5URVIgPSAoXCJNU1BvaW50ZXJFdmVudFwiIGluIHdpbik7XG52YXIgU1VQUE9SVF9QT0lOVEVSX0VWRU5UUyA9IFNVUFBPUlRfUE9JTlRFUiB8fCBTVVBQT1JUX01TUE9JTlRFUjtcbnZhciBpc1ZhbGlkS2V5ID0gZnVuY3Rpb24gKGV2ZW50LCBpbnB1dEtleSkge1xuICBpZiAoIWlucHV0S2V5IHx8IGlucHV0S2V5LmluZGV4T2YoQU5ZKSA+IC0xIHx8IGlucHV0S2V5LmluZGV4T2YoTk9ORSkgPiAtMSAmJiAhZXZlbnQuc2hpZnRLZXkgJiYgIWV2ZW50LmN0cmxLZXkgJiYgIWV2ZW50LmFsdEtleSAmJiAhZXZlbnQubWV0YUtleSB8fCBpbnB1dEtleS5pbmRleE9mKFNISUZUKSA+IC0xICYmIGV2ZW50LnNoaWZ0S2V5IHx8IGlucHV0S2V5LmluZGV4T2YoQ1RSTCkgPiAtMSAmJiBldmVudC5jdHJsS2V5IHx8IGlucHV0S2V5LmluZGV4T2YoQUxUKSA+IC0xICYmIGV2ZW50LmFsdEtleSB8fCBpbnB1dEtleS5pbmRleE9mKE1FVEEpID4gLTEgJiYgZXZlbnQubWV0YUtleSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG52YXIgRXZlbnRJbnB1dCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEV2ZW50SW5wdXQoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB0aGlzLl9zdG9wQ29udGV4dE1lbnUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB3aW4ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNvbnRleHRtZW51XCIsIF90aGlzLl9zdG9wQ29udGV4dE1lbnUpO1xuICAgIH07XG4gIH1cbiAgdmFyIF9fcHJvdG8gPSBFdmVudElucHV0LnByb3RvdHlwZTtcbiAgX19wcm90by5leHRlbmRFdmVudCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciBfYTtcbiAgICB2YXIgcHJldkV2ZW50ID0gdGhpcy5wcmV2RXZlbnQ7XG4gICAgdmFyIGNlbnRlciA9IHRoaXMuX2dldENlbnRlcihldmVudCk7XG4gICAgdmFyIG1vdmVtZW50ID0gcHJldkV2ZW50ID8gdGhpcy5fZ2V0TW92ZW1lbnQoZXZlbnQpIDoge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDBcbiAgICB9O1xuICAgIHZhciBzY2FsZSA9IHByZXZFdmVudCA/IHRoaXMuX2dldFNjYWxlKGV2ZW50KSA6IDE7XG4gICAgdmFyIGFuZ2xlID0gcHJldkV2ZW50ID8gZ2V0QW5nbGUoY2VudGVyLnggLSBwcmV2RXZlbnQuY2VudGVyLngsIGNlbnRlci55IC0gcHJldkV2ZW50LmNlbnRlci55KSA6IDA7XG4gICAgdmFyIGRlbHRhWCA9IHByZXZFdmVudCA/IHByZXZFdmVudC5kZWx0YVggKyBtb3ZlbWVudC54IDogbW92ZW1lbnQueDtcbiAgICB2YXIgZGVsdGFZID0gcHJldkV2ZW50ID8gcHJldkV2ZW50LmRlbHRhWSArIG1vdmVtZW50LnkgOiBtb3ZlbWVudC55O1xuICAgIHZhciBvZmZzZXRYID0gbW92ZW1lbnQueDtcbiAgICB2YXIgb2Zmc2V0WSA9IG1vdmVtZW50Lnk7XG4gICAgdmFyIGxhdGVzdEludGVydmFsID0gdGhpcy5fbGF0ZXN0SW50ZXJ2YWw7XG4gICAgdmFyIHRpbWVTdGFtcCA9IERhdGUubm93KCk7XG4gICAgdmFyIGRlbHRhVGltZSA9IGxhdGVzdEludGVydmFsID8gdGltZVN0YW1wIC0gbGF0ZXN0SW50ZXJ2YWwudGltZXN0YW1wIDogMDtcbiAgICB2YXIgdmVsb2NpdHlYID0gcHJldkV2ZW50ID8gcHJldkV2ZW50LnZlbG9jaXR5WCA6IDA7XG4gICAgdmFyIHZlbG9jaXR5WSA9IHByZXZFdmVudCA/IHByZXZFdmVudC52ZWxvY2l0eVkgOiAwO1xuICAgIGlmICghbGF0ZXN0SW50ZXJ2YWwgfHwgZGVsdGFUaW1lID49IFZFTE9DSVRZX0lOVEVSVkFMKSB7XG4gICAgICBpZiAobGF0ZXN0SW50ZXJ2YWwpIHtcbiAgICAgICAgX2EgPSBbKGRlbHRhWCAtIGxhdGVzdEludGVydmFsLmRlbHRhWCkgLyBkZWx0YVRpbWUsIChkZWx0YVkgLSBsYXRlc3RJbnRlcnZhbC5kZWx0YVkpIC8gZGVsdGFUaW1lXSwgdmVsb2NpdHlYID0gX2FbMF0sIHZlbG9jaXR5WSA9IF9hWzFdO1xuICAgICAgfVxuICAgICAgdGhpcy5fbGF0ZXN0SW50ZXJ2YWwgPSB7XG4gICAgICAgIHRpbWVzdGFtcDogdGltZVN0YW1wLFxuICAgICAgICBkZWx0YVg6IGRlbHRhWCxcbiAgICAgICAgZGVsdGFZOiBkZWx0YVlcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBzcmNFdmVudDogZXZlbnQsXG4gICAgICBzY2FsZTogc2NhbGUsXG4gICAgICBhbmdsZTogYW5nbGUsXG4gICAgICBjZW50ZXI6IGNlbnRlcixcbiAgICAgIGRlbHRhWDogZGVsdGFYLFxuICAgICAgZGVsdGFZOiBkZWx0YVksXG4gICAgICBvZmZzZXRYOiBvZmZzZXRYLFxuICAgICAgb2Zmc2V0WTogb2Zmc2V0WSxcbiAgICAgIHZlbG9jaXR5WDogdmVsb2NpdHlYLFxuICAgICAgdmVsb2NpdHlZOiB2ZWxvY2l0eVksXG4gICAgICBwcmV2ZW50U3lzdGVtRXZlbnQ6IHRydWVcbiAgICB9O1xuICB9O1xuICBfX3Byb3RvLl9nZXREaXN0YW5jZSA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gICAgdmFyIHggPSBlbmQuY2xpZW50WCAtIHN0YXJ0LmNsaWVudFg7XG4gICAgdmFyIHkgPSBlbmQuY2xpZW50WSAtIHN0YXJ0LmNsaWVudFk7XG4gICAgcmV0dXJuIE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcbiAgfTtcbiAgX19wcm90by5fZ2V0QnV0dG9uID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIGJ1dHRvbkNvZGVNYXAgPSB7XG4gICAgICAxOiBNT1VTRV9MRUZULFxuICAgICAgMjogTU9VU0VfUklHSFQsXG4gICAgICA0OiBNT1VTRV9NSURETEVcbiAgICB9O1xuICAgIHZhciBidXR0b24gPSB0aGlzLl9pc1RvdWNoRXZlbnQoZXZlbnQpID8gTU9VU0VfTEVGVCA6IGJ1dHRvbkNvZGVNYXBbZXZlbnQuYnV0dG9uc107XG4gICAgcmV0dXJuIGJ1dHRvbiA/IGJ1dHRvbiA6IG51bGw7XG4gIH07XG4gIF9fcHJvdG8uX2lzVG91Y2hFdmVudCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiBldmVudC50eXBlICYmIGV2ZW50LnR5cGUuaW5kZXhPZihcInRvdWNoXCIpID4gLTE7XG4gIH07XG4gIF9fcHJvdG8uX2lzVmFsaWRCdXR0b24gPSBmdW5jdGlvbiAoYnV0dG9uLCBpbnB1dEJ1dHRvbikge1xuICAgIHJldHVybiBpbnB1dEJ1dHRvbi5pbmRleE9mKGJ1dHRvbikgPiAtMTtcbiAgfTtcbiAgX19wcm90by5faXNWYWxpZEV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50LCBpbnB1dEtleSwgaW5wdXRCdXR0b24pIHtcbiAgICByZXR1cm4gKCFpbnB1dEtleSB8fCBpc1ZhbGlkS2V5KGV2ZW50LCBpbnB1dEtleSkpICYmICghaW5wdXRCdXR0b24gfHwgdGhpcy5faXNWYWxpZEJ1dHRvbih0aGlzLl9nZXRCdXR0b24oZXZlbnQpLCBpbnB1dEJ1dHRvbikpO1xuICB9O1xuICBfX3Byb3RvLl9wcmV2ZW50TW91c2VCdXR0b24gPSBmdW5jdGlvbiAoZXZlbnQsIGJ1dHRvbikge1xuICAgIGlmIChidXR0b24gPT09IE1PVVNFX1JJR0hUKSB7XG4gICAgICB3aW4uYWRkRXZlbnRMaXN0ZW5lcihcImNvbnRleHRtZW51XCIsIHRoaXMuX3N0b3BDb250ZXh0TWVudSk7XG4gICAgfSBlbHNlIGlmIChidXR0b24gPT09IE1PVVNFX01JRERMRSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBFdmVudElucHV0O1xufSgpO1xuXG52YXIgTW91c2VFdmVudElucHV0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzJDEoTW91c2VFdmVudElucHV0LCBfc3VwZXIpO1xuICBmdW5jdGlvbiBNb3VzZUV2ZW50SW5wdXQoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgX3RoaXMuc3RhcnQgPSBbXCJtb3VzZWRvd25cIl07XG4gICAgX3RoaXMubW92ZSA9IFtcIm1vdXNlbW92ZVwiXTtcbiAgICBfdGhpcy5lbmQgPSBbXCJtb3VzZXVwXCJdO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICB2YXIgX19wcm90byA9IE1vdXNlRXZlbnRJbnB1dC5wcm90b3R5cGU7XG4gIF9fcHJvdG8ub25FdmVudFN0YXJ0ID0gZnVuY3Rpb24gKGV2ZW50LCBpbnB1dEtleSwgaW5wdXRCdXR0b24pIHtcbiAgICB2YXIgYnV0dG9uID0gdGhpcy5fZ2V0QnV0dG9uKGV2ZW50KTtcbiAgICBpZiAoIXRoaXMuX2lzVmFsaWRFdmVudChldmVudCwgaW5wdXRLZXksIGlucHV0QnV0dG9uKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHRoaXMuX3ByZXZlbnRNb3VzZUJ1dHRvbihldmVudCwgYnV0dG9uKTtcbiAgICByZXR1cm4gdGhpcy5leHRlbmRFdmVudChldmVudCk7XG4gIH07XG4gIF9fcHJvdG8ub25FdmVudE1vdmUgPSBmdW5jdGlvbiAoZXZlbnQsIGlucHV0S2V5LCBpbnB1dEJ1dHRvbikge1xuICAgIGlmICghdGhpcy5faXNWYWxpZEV2ZW50KGV2ZW50LCBpbnB1dEtleSwgaW5wdXRCdXR0b24pKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZXh0ZW5kRXZlbnQoZXZlbnQpO1xuICB9O1xuICBfX3Byb3RvLm9uRXZlbnRFbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuO1xuICB9O1xuICBfX3Byb3RvLm9uUmVsZWFzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnByZXZFdmVudCA9IG51bGw7XG4gICAgcmV0dXJuO1xuICB9O1xuICBfX3Byb3RvLmdldFRvdWNoZXMgPSBmdW5jdGlvbiAoZXZlbnQsIGlucHV0QnV0dG9uKSB7XG4gICAgaWYgKGlucHV0QnV0dG9uKSB7XG4gICAgICByZXR1cm4gdGhpcy5faXNWYWxpZEJ1dHRvbihNT1VTRV9CVVRUT05fQ09ERV9NQVBbZXZlbnQud2hpY2hdLCBpbnB1dEJ1dHRvbikgJiYgdGhpcy5lbmQuaW5kZXhPZihldmVudC50eXBlKSA9PT0gLTEgPyAxIDogMDtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH07XG4gIF9fcHJvdG8uX2dldFNjYWxlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAxO1xuICB9O1xuICBfX3Byb3RvLl9nZXRDZW50ZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogZXZlbnQuY2xpZW50WCxcbiAgICAgIHk6IGV2ZW50LmNsaWVudFlcbiAgICB9O1xuICB9O1xuICBfX3Byb3RvLl9nZXRNb3ZlbWVudCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciBwcmV2ID0gdGhpcy5wcmV2RXZlbnQuc3JjRXZlbnQ7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGV2ZW50LmNsaWVudFggLSBwcmV2LmNsaWVudFgsXG4gICAgICB5OiBldmVudC5jbGllbnRZIC0gcHJldi5jbGllbnRZXG4gICAgfTtcbiAgfTtcbiAgcmV0dXJuIE1vdXNlRXZlbnRJbnB1dDtcbn0oRXZlbnRJbnB1dCk7XG5cbnZhciBUb3VjaEV2ZW50SW5wdXQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMkMShUb3VjaEV2ZW50SW5wdXQsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIFRvdWNoRXZlbnRJbnB1dCgpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICBfdGhpcy5zdGFydCA9IFtcInRvdWNoc3RhcnRcIl07XG4gICAgX3RoaXMubW92ZSA9IFtcInRvdWNobW92ZVwiXTtcbiAgICBfdGhpcy5lbmQgPSBbXCJ0b3VjaGVuZFwiLCBcInRvdWNoY2FuY2VsXCJdO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICB2YXIgX19wcm90byA9IFRvdWNoRXZlbnRJbnB1dC5wcm90b3R5cGU7XG4gIF9fcHJvdG8ub25FdmVudFN0YXJ0ID0gZnVuY3Rpb24gKGV2ZW50LCBpbnB1dEtleSkge1xuICAgIHRoaXMuX2Jhc2VUb3VjaGVzID0gZXZlbnQudG91Y2hlcztcbiAgICBpZiAoIXRoaXMuX2lzVmFsaWRFdmVudChldmVudCwgaW5wdXRLZXkpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZXh0ZW5kRXZlbnQoZXZlbnQpO1xuICB9O1xuICBfX3Byb3RvLm9uRXZlbnRNb3ZlID0gZnVuY3Rpb24gKGV2ZW50LCBpbnB1dEtleSkge1xuICAgIGlmICghdGhpcy5faXNWYWxpZEV2ZW50KGV2ZW50LCBpbnB1dEtleSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5leHRlbmRFdmVudChldmVudCk7XG4gIH07XG4gIF9fcHJvdG8ub25FdmVudEVuZCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHRoaXMuX2Jhc2VUb3VjaGVzID0gZXZlbnQudG91Y2hlcztcbiAgICByZXR1cm47XG4gIH07XG4gIF9fcHJvdG8ub25SZWxlYXNlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucHJldkV2ZW50ID0gbnVsbDtcbiAgICB0aGlzLl9iYXNlVG91Y2hlcyA9IG51bGw7XG4gICAgcmV0dXJuO1xuICB9O1xuICBfX3Byb3RvLmdldFRvdWNoZXMgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQudG91Y2hlcy5sZW5ndGg7XG4gIH07XG4gIF9fcHJvdG8uX2dldFNjYWxlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnRvdWNoZXMubGVuZ3RoICE9PSAyIHx8IHRoaXMuX2Jhc2VUb3VjaGVzLmxlbmd0aCA8IDIpIHtcbiAgICAgIHJldHVybiBudWxsOyAvLyBUT0RPOiBjb25zaWRlciBjYWxjdWxhdGluZyBub24tcGluY2ggZ2VzdHVyZSBzY2FsZVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9nZXREaXN0YW5jZShldmVudC50b3VjaGVzWzBdLCBldmVudC50b3VjaGVzWzFdKSAvIHRoaXMuX2dldERpc3RhbmNlKHRoaXMuX2Jhc2VUb3VjaGVzWzBdLCB0aGlzLl9iYXNlVG91Y2hlc1sxXSk7XG4gIH07XG4gIF9fcHJvdG8uX2dldENlbnRlciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiBldmVudC50b3VjaGVzWzBdLmNsaWVudFgsXG4gICAgICB5OiBldmVudC50b3VjaGVzWzBdLmNsaWVudFlcbiAgICB9O1xuICB9O1xuICBfX3Byb3RvLl9nZXRNb3ZlbWVudCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciBwcmV2ID0gdGhpcy5wcmV2RXZlbnQuc3JjRXZlbnQ7XG4gICAgaWYgKGV2ZW50LnRvdWNoZXNbMF0uaWRlbnRpZmllciAhPT0gcHJldi50b3VjaGVzWzBdLmlkZW50aWZpZXIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDBcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB4OiBldmVudC50b3VjaGVzWzBdLmNsaWVudFggLSBwcmV2LnRvdWNoZXNbMF0uY2xpZW50WCxcbiAgICAgIHk6IGV2ZW50LnRvdWNoZXNbMF0uY2xpZW50WSAtIHByZXYudG91Y2hlc1swXS5jbGllbnRZXG4gICAgfTtcbiAgfTtcbiAgcmV0dXJuIFRvdWNoRXZlbnRJbnB1dDtcbn0oRXZlbnRJbnB1dCk7XG5cbnZhciBQb2ludGVyRXZlbnRJbnB1dCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyQxKFBvaW50ZXJFdmVudElucHV0LCBfc3VwZXIpO1xuICBmdW5jdGlvbiBQb2ludGVyRXZlbnRJbnB1dCgpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICBfdGhpcy5zdGFydCA9IFNVUFBPUlRfUE9JTlRFUiA/IFtcInBvaW50ZXJkb3duXCJdIDogW1wiTVNQb2ludGVyRG93blwiXTtcbiAgICBfdGhpcy5tb3ZlID0gU1VQUE9SVF9QT0lOVEVSID8gW1wicG9pbnRlcm1vdmVcIl0gOiBbXCJNU1BvaW50ZXJNb3ZlXCJdO1xuICAgIF90aGlzLmVuZCA9IFNVUFBPUlRfUE9JTlRFUiA/IFtcInBvaW50ZXJ1cFwiLCBcInBvaW50ZXJjYW5jZWxcIl0gOiBbXCJNU1BvaW50ZXJVcFwiLCBcIk1TUG9pbnRlckNhbmNlbFwiXTtcbiAgICAvLyBzdG9yZSBmaXJzdCwgcmVjZW50IGlucHV0cyBmb3IgZWFjaCBldmVudCBpZFxuICAgIF90aGlzLl9maXJzdElucHV0cyA9IFtdO1xuICAgIF90aGlzLl9yZWNlbnRJbnB1dHMgPSBbXTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgdmFyIF9fcHJvdG8gPSBQb2ludGVyRXZlbnRJbnB1dC5wcm90b3R5cGU7XG4gIF9fcHJvdG8ub25FdmVudFN0YXJ0ID0gZnVuY3Rpb24gKGV2ZW50LCBpbnB1dEtleSwgaW5wdXRCdXR0b24pIHtcbiAgICB2YXIgYnV0dG9uID0gdGhpcy5fZ2V0QnV0dG9uKGV2ZW50KTtcbiAgICBpZiAoIXRoaXMuX2lzVmFsaWRFdmVudChldmVudCwgaW5wdXRLZXksIGlucHV0QnV0dG9uKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHRoaXMuX3ByZXZlbnRNb3VzZUJ1dHRvbihldmVudCwgYnV0dG9uKTtcbiAgICB0aGlzLl91cGRhdGVQb2ludGVyRXZlbnQoZXZlbnQpO1xuICAgIHJldHVybiB0aGlzLmV4dGVuZEV2ZW50KGV2ZW50KTtcbiAgfTtcbiAgX19wcm90by5vbkV2ZW50TW92ZSA9IGZ1bmN0aW9uIChldmVudCwgaW5wdXRLZXksIGlucHV0QnV0dG9uKSB7XG4gICAgaWYgKCF0aGlzLl9pc1ZhbGlkRXZlbnQoZXZlbnQsIGlucHV0S2V5LCBpbnB1dEJ1dHRvbikpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB0aGlzLl91cGRhdGVQb2ludGVyRXZlbnQoZXZlbnQpO1xuICAgIHJldHVybiB0aGlzLmV4dGVuZEV2ZW50KGV2ZW50KTtcbiAgfTtcbiAgX19wcm90by5vbkV2ZW50RW5kID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdGhpcy5fcmVtb3ZlUG9pbnRlckV2ZW50KGV2ZW50KTtcbiAgfTtcbiAgX19wcm90by5vblJlbGVhc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5wcmV2RXZlbnQgPSBudWxsO1xuICAgIHRoaXMuX2ZpcnN0SW5wdXRzID0gW107XG4gICAgdGhpcy5fcmVjZW50SW5wdXRzID0gW107XG4gICAgcmV0dXJuO1xuICB9O1xuICBfX3Byb3RvLmdldFRvdWNoZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlY2VudElucHV0cy5sZW5ndGg7XG4gIH07XG4gIF9fcHJvdG8uX2dldFNjYWxlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9yZWNlbnRJbnB1dHMubGVuZ3RoICE9PSAyKSB7XG4gICAgICByZXR1cm4gbnVsbDsgLy8gVE9ETzogY29uc2lkZXIgY2FsY3VsYXRpbmcgbm9uLXBpbmNoIGdlc3R1cmUgc2NhbGVcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fZ2V0RGlzdGFuY2UodGhpcy5fcmVjZW50SW5wdXRzWzBdLCB0aGlzLl9yZWNlbnRJbnB1dHNbMV0pIC8gdGhpcy5fZ2V0RGlzdGFuY2UodGhpcy5fZmlyc3RJbnB1dHNbMF0sIHRoaXMuX2ZpcnN0SW5wdXRzWzFdKTtcbiAgfTtcbiAgX19wcm90by5fZ2V0Q2VudGVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGV2ZW50LmNsaWVudFgsXG4gICAgICB5OiBldmVudC5jbGllbnRZXG4gICAgfTtcbiAgfTtcbiAgX19wcm90by5fZ2V0TW92ZW1lbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgcHJldiA9IHRoaXMucHJldkV2ZW50LnNyY0V2ZW50O1xuICAgIGlmIChldmVudC5wb2ludGVySWQgIT09IHByZXYucG9pbnRlcklkKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgeDogZXZlbnQuY2xpZW50WCAtIHByZXYuY2xpZW50WCxcbiAgICAgIHk6IGV2ZW50LmNsaWVudFkgLSBwcmV2LmNsaWVudFlcbiAgICB9O1xuICB9O1xuICBfX3Byb3RvLl91cGRhdGVQb2ludGVyRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHZhciBhZGRGbGFnID0gZmFsc2U7XG4gICAgdGhpcy5fcmVjZW50SW5wdXRzLmZvckVhY2goZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgIGlmIChlLnBvaW50ZXJJZCA9PT0gZXZlbnQucG9pbnRlcklkKSB7XG4gICAgICAgIGFkZEZsYWcgPSB0cnVlO1xuICAgICAgICBfdGhpcy5fcmVjZW50SW5wdXRzW2ldID0gZXZlbnQ7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCFhZGRGbGFnKSB7XG4gICAgICB0aGlzLl9maXJzdElucHV0cy5wdXNoKGV2ZW50KTtcbiAgICAgIHRoaXMuX3JlY2VudElucHV0cy5wdXNoKGV2ZW50KTtcbiAgICB9XG4gIH07XG4gIF9fcHJvdG8uX3JlbW92ZVBvaW50ZXJFdmVudCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHRoaXMuX2ZpcnN0SW5wdXRzID0gdGhpcy5fZmlyc3RJbnB1dHMuZmlsdGVyKGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4geC5wb2ludGVySWQgIT09IGV2ZW50LnBvaW50ZXJJZDtcbiAgICB9KTtcbiAgICB0aGlzLl9yZWNlbnRJbnB1dHMgPSB0aGlzLl9yZWNlbnRJbnB1dHMuZmlsdGVyKGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4geC5wb2ludGVySWQgIT09IGV2ZW50LnBvaW50ZXJJZDtcbiAgICB9KTtcbiAgfTtcbiAgcmV0dXJuIFBvaW50ZXJFdmVudElucHV0O1xufShFdmVudElucHV0KTtcblxudmFyIFRvdWNoTW91c2VFdmVudElucHV0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzJDEoVG91Y2hNb3VzZUV2ZW50SW5wdXQsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIFRvdWNoTW91c2VFdmVudElucHV0KCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIF90aGlzLnN0YXJ0ID0gW1wibW91c2Vkb3duXCIsIFwidG91Y2hzdGFydFwiXTtcbiAgICBfdGhpcy5tb3ZlID0gW1wibW91c2Vtb3ZlXCIsIFwidG91Y2htb3ZlXCJdO1xuICAgIF90aGlzLmVuZCA9IFtcIm1vdXNldXBcIiwgXCJ0b3VjaGVuZFwiLCBcInRvdWNoY2FuY2VsXCJdO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICB2YXIgX19wcm90byA9IFRvdWNoTW91c2VFdmVudElucHV0LnByb3RvdHlwZTtcbiAgX19wcm90by5vbkV2ZW50U3RhcnQgPSBmdW5jdGlvbiAoZXZlbnQsIGlucHV0S2V5LCBpbnB1dEJ1dHRvbikge1xuICAgIHZhciBidXR0b24gPSB0aGlzLl9nZXRCdXR0b24oZXZlbnQpO1xuICAgIGlmICh0aGlzLl9pc1RvdWNoRXZlbnQoZXZlbnQpKSB7XG4gICAgICB0aGlzLl9iYXNlVG91Y2hlcyA9IGV2ZW50LnRvdWNoZXM7XG4gICAgfVxuICAgIGlmICghdGhpcy5faXNWYWxpZEV2ZW50KGV2ZW50LCBpbnB1dEtleSwgaW5wdXRCdXR0b24pKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5fcHJldmVudE1vdXNlQnV0dG9uKGV2ZW50LCBidXR0b24pO1xuICAgIHJldHVybiB0aGlzLmV4dGVuZEV2ZW50KGV2ZW50KTtcbiAgfTtcbiAgX19wcm90by5vbkV2ZW50TW92ZSA9IGZ1bmN0aW9uIChldmVudCwgaW5wdXRLZXksIGlucHV0QnV0dG9uKSB7XG4gICAgaWYgKCF0aGlzLl9pc1ZhbGlkRXZlbnQoZXZlbnQsIGlucHV0S2V5LCBpbnB1dEJ1dHRvbikpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5leHRlbmRFdmVudChldmVudCk7XG4gIH07XG4gIF9fcHJvdG8ub25FdmVudEVuZCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmICh0aGlzLl9pc1RvdWNoRXZlbnQoZXZlbnQpKSB7XG4gICAgICB0aGlzLl9iYXNlVG91Y2hlcyA9IGV2ZW50LnRvdWNoZXM7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfTtcbiAgX19wcm90by5vblJlbGVhc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5wcmV2RXZlbnQgPSBudWxsO1xuICAgIHRoaXMuX2Jhc2VUb3VjaGVzID0gbnVsbDtcbiAgICByZXR1cm47XG4gIH07XG4gIF9fcHJvdG8uZ2V0VG91Y2hlcyA9IGZ1bmN0aW9uIChldmVudCwgaW5wdXRCdXR0b24pIHtcbiAgICBpZiAodGhpcy5faXNUb3VjaEV2ZW50KGV2ZW50KSkge1xuICAgICAgcmV0dXJuIGV2ZW50LnRvdWNoZXMubGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5faXNWYWxpZEJ1dHRvbihNT1VTRV9CVVRUT05fQ09ERV9NQVBbZXZlbnQud2hpY2hdLCBpbnB1dEJ1dHRvbikgJiYgdGhpcy5lbmQuaW5kZXhPZihldmVudC50eXBlKSA9PT0gLTEgPyAxIDogMDtcbiAgICB9XG4gIH07XG4gIF9fcHJvdG8uX2dldFNjYWxlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuX2lzVG91Y2hFdmVudChldmVudCkpIHtcbiAgICAgIGlmIChldmVudC50b3VjaGVzLmxlbmd0aCAhPT0gMiB8fCB0aGlzLl9iYXNlVG91Y2hlcy5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAxOyAvLyBUT0RPOiBjb25zaWRlciBjYWxjdWxhdGluZyBub24tcGluY2ggZ2VzdHVyZSBzY2FsZVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fZ2V0RGlzdGFuY2UoZXZlbnQudG91Y2hlc1swXSwgZXZlbnQudG91Y2hlc1sxXSkgLyB0aGlzLl9nZXREaXN0YW5jZSh0aGlzLl9iYXNlVG91Y2hlc1swXSwgdGhpcy5fYmFzZVRvdWNoZXNbMV0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wcmV2RXZlbnQuc2NhbGU7XG4gIH07XG4gIF9fcHJvdG8uX2dldENlbnRlciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmICh0aGlzLl9pc1RvdWNoRXZlbnQoZXZlbnQpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBldmVudC50b3VjaGVzWzBdLmNsaWVudFgsXG4gICAgICAgIHk6IGV2ZW50LnRvdWNoZXNbMF0uY2xpZW50WVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGV2ZW50LmNsaWVudFgsXG4gICAgICB5OiBldmVudC5jbGllbnRZXG4gICAgfTtcbiAgfTtcbiAgX19wcm90by5fZ2V0TW92ZW1lbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHZhciBwcmV2ID0gdGhpcy5wcmV2RXZlbnQuc3JjRXZlbnQ7XG4gICAgdmFyIF9hID0gW2V2ZW50LCBwcmV2XS5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKF90aGlzLl9pc1RvdWNoRXZlbnQoZSkpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWQ6IGUudG91Y2hlc1swXS5pZGVudGlmaWVyLFxuICAgICAgICAgICAgeDogZS50b3VjaGVzWzBdLmNsaWVudFgsXG4gICAgICAgICAgICB5OiBlLnRvdWNoZXNbMF0uY2xpZW50WVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpZDogbnVsbCxcbiAgICAgICAgICB4OiBlLmNsaWVudFgsXG4gICAgICAgICAgeTogZS5jbGllbnRZXG4gICAgICAgIH07XG4gICAgICB9KSxcbiAgICAgIG5leHRTcG90ID0gX2FbMF0sXG4gICAgICBwcmV2U3BvdCA9IF9hWzFdO1xuICAgIHJldHVybiBuZXh0U3BvdC5pZCA9PT0gcHJldlNwb3QuaWQgPyB7XG4gICAgICB4OiBuZXh0U3BvdC54IC0gcHJldlNwb3QueCxcbiAgICAgIHk6IG5leHRTcG90LnkgLSBwcmV2U3BvdC55XG4gICAgfSA6IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfTtcbiAgfTtcbiAgcmV0dXJuIFRvdWNoTW91c2VFdmVudElucHV0O1xufShFdmVudElucHV0KTtcblxudmFyIHRvQXhpcyA9IGZ1bmN0aW9uIChzb3VyY2UsIG9mZnNldCkge1xuICByZXR1cm4gb2Zmc2V0LnJlZHVjZShmdW5jdGlvbiAoYWNjLCB2LCBpKSB7XG4gICAgaWYgKHNvdXJjZVtpXSkge1xuICAgICAgYWNjW3NvdXJjZVtpXV0gPSB2O1xuICAgIH1cbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG59O1xudmFyIGNvbnZlcnRJbnB1dFR5cGUgPSBmdW5jdGlvbiAoaW5wdXRUeXBlKSB7XG4gIGlmIChpbnB1dFR5cGUgPT09IHZvaWQgMCkge1xuICAgIGlucHV0VHlwZSA9IFtdO1xuICB9XG4gIHZhciBoYXNUb3VjaCA9IGZhbHNlO1xuICB2YXIgaGFzTW91c2UgPSBmYWxzZTtcbiAgdmFyIGhhc1BvaW50ZXIgPSBmYWxzZTtcbiAgaW5wdXRUeXBlLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICBzd2l0Y2ggKHYpIHtcbiAgICAgIGNhc2UgXCJtb3VzZVwiOlxuICAgICAgICBoYXNNb3VzZSA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInRvdWNoXCI6XG4gICAgICAgIGhhc1RvdWNoID0gU1VQUE9SVF9UT1VDSDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwicG9pbnRlclwiOlxuICAgICAgICBoYXNQb2ludGVyID0gU1VQUE9SVF9QT0lOVEVSX0VWRU5UUztcbiAgICAgIC8vIG5vIGRlZmF1bHRcbiAgICB9XG4gIH0pO1xuXG4gIGlmIChoYXNQb2ludGVyKSB7XG4gICAgcmV0dXJuIG5ldyBQb2ludGVyRXZlbnRJbnB1dCgpO1xuICB9IGVsc2UgaWYgKGhhc1RvdWNoICYmIGhhc01vdXNlKSB7XG4gICAgcmV0dXJuIG5ldyBUb3VjaE1vdXNlRXZlbnRJbnB1dCgpO1xuICB9IGVsc2UgaWYgKGhhc1RvdWNoKSB7XG4gICAgcmV0dXJuIG5ldyBUb3VjaEV2ZW50SW5wdXQoKTtcbiAgfSBlbHNlIGlmIChoYXNNb3VzZSkge1xuICAgIHJldHVybiBuZXcgTW91c2VFdmVudElucHV0KCk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuZnVuY3Rpb24gZ2V0QWRkRXZlbnRPcHRpb25zKGV2ZW50TmFtZSkge1xuICAvLyBUaGUgcGFzc2l2ZSBkZWZhdWx0IHZhbHVlIG9mIHRoZSB0b3VjaCBldmVudCBpcyB0cnVlLlxuICAvLyBJZiBub3QgYSB0b3VjaCBldmVudCwgcmV0dXJuIGZhbHNlIHRvIHN1cHBvcnQgaWUxMVxuICByZXR1cm4gZXZlbnROYW1lLmluZGV4T2YoXCJ0b3VjaFwiKSA+IC0xID8ge1xuICAgIHBhc3NpdmU6IGZhbHNlXG4gIH0gOiBmYWxzZTtcbn1cblxudmFyIElucHV0T2JzZXJ2ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBJbnB1dE9ic2VydmVyKF9hKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBfYS5vcHRpb25zLFxuICAgICAgaW50ZXJydXB0TWFuYWdlciA9IF9hLmludGVycnVwdE1hbmFnZXIsXG4gICAgICBldmVudE1hbmFnZXIgPSBfYS5ldmVudE1hbmFnZXIsXG4gICAgICBheGlzTWFuYWdlciA9IF9hLmF4aXNNYW5hZ2VyLFxuICAgICAgYW5pbWF0aW9uTWFuYWdlciA9IF9hLmFuaW1hdGlvbk1hbmFnZXI7XG4gICAgdGhpcy5faXNPdXRzaWRlID0gZmFsc2U7XG4gICAgdGhpcy5fbW92ZURpc3RhbmNlID0gbnVsbDtcbiAgICB0aGlzLl9pc1N0b3BwZWQgPSBmYWxzZTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuX2ludGVycnVwdE1hbmFnZXIgPSBpbnRlcnJ1cHRNYW5hZ2VyO1xuICAgIHRoaXMuX2V2ZW50TWFuYWdlciA9IGV2ZW50TWFuYWdlcjtcbiAgICB0aGlzLl9heGlzTWFuYWdlciA9IGF4aXNNYW5hZ2VyO1xuICAgIHRoaXMuX2FuaW1hdGlvbk1hbmFnZXIgPSBhbmltYXRpb25NYW5hZ2VyO1xuICB9XG4gIHZhciBfX3Byb3RvID0gSW5wdXRPYnNlcnZlci5wcm90b3R5cGU7XG4gIF9fcHJvdG8uZ2V0ID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2F4aXNNYW5hZ2VyLmdldChpbnB1dC5heGVzKTtcbiAgfTtcbiAgX19wcm90by5ob2xkID0gZnVuY3Rpb24gKGlucHV0LCBldmVudCkge1xuICAgIGlmICh0aGlzLl9pbnRlcnJ1cHRNYW5hZ2VyLmlzSW50ZXJydXB0ZWQoKSB8fCAhaW5wdXQuYXhlcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGNoYW5nZU9wdGlvbiA9IHtcbiAgICAgIGlucHV0OiBpbnB1dCxcbiAgICAgIGV2ZW50OiBldmVudFxuICAgIH07XG4gICAgdGhpcy5faXNTdG9wcGVkID0gZmFsc2U7XG4gICAgdGhpcy5faW50ZXJydXB0TWFuYWdlci5zZXRJbnRlcnJ1cHQodHJ1ZSk7XG4gICAgdGhpcy5fYW5pbWF0aW9uTWFuYWdlci5zdG9wQW5pbWF0aW9uKGNoYW5nZU9wdGlvbik7XG4gICAgKyt0aGlzLl9ldmVudE1hbmFnZXIuaG9sZGluZ0NvdW50O1xuICAgIGlmICghdGhpcy5fbW92ZURpc3RhbmNlKSB7XG4gICAgICB0aGlzLl9ldmVudE1hbmFnZXIuaG9sZCh0aGlzLl9heGlzTWFuYWdlci5nZXQoKSwgY2hhbmdlT3B0aW9uKTtcbiAgICB9XG4gICAgdGhpcy5faXNPdXRzaWRlID0gdGhpcy5fYXhpc01hbmFnZXIuaXNPdXRzaWRlKGlucHV0LmF4ZXMpO1xuICAgIHRoaXMuX21vdmVEaXN0YW5jZSA9IHRoaXMuX2F4aXNNYW5hZ2VyLmdldChpbnB1dC5heGVzKTtcbiAgfTtcbiAgX19wcm90by5jaGFuZ2UgPSBmdW5jdGlvbiAoaW5wdXQsIGV2ZW50LCBvZmZzZXQsIHVzZUFuaW1hdGlvbikge1xuICAgIGlmICh0aGlzLl9pc1N0b3BwZWQgfHwgIXRoaXMuX2ludGVycnVwdE1hbmFnZXIuaXNJbnRlcnJ1cHRpbmcoKSB8fCB0aGlzLl9heGlzTWFuYWdlci5ldmVyeShvZmZzZXQsIGZ1bmN0aW9uICh2KSB7XG4gICAgICByZXR1cm4gdiA9PT0gMDtcbiAgICB9KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbmF0aXZlRXZlbnQgPSBldmVudC5zcmNFdmVudCA/IGV2ZW50LnNyY0V2ZW50IDogZXZlbnQ7XG4gICAgaWYgKG5hdGl2ZUV2ZW50Ll9fY2hpbGRyZW5BeGVzQWxyZWFkeUNoYW5nZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGRlcGFQb3MgPSB0aGlzLl9tb3ZlRGlzdGFuY2UgfHwgdGhpcy5fYXhpc01hbmFnZXIuZ2V0KGlucHV0LmF4ZXMpO1xuICAgIHZhciBkZXN0UG9zO1xuICAgIC8vIGZvciBvdXRzaWRlIGxvZ2ljXG4gICAgZGVzdFBvcyA9IG1hcChkZXBhUG9zLCBmdW5jdGlvbiAodiwgaykge1xuICAgICAgcmV0dXJuIHYgKyAob2Zmc2V0W2tdIHx8IDApO1xuICAgIH0pO1xuICAgIGlmICh0aGlzLl9tb3ZlRGlzdGFuY2UpIHtcbiAgICAgIHRoaXMuX21vdmVEaXN0YW5jZSA9IHRoaXMuX2F4aXNNYW5hZ2VyLm1hcChkZXN0UG9zLCBmdW5jdGlvbiAodiwgX2EpIHtcbiAgICAgICAgdmFyIGNpcmN1bGFyID0gX2EuY2lyY3VsYXIsXG4gICAgICAgICAgcmFuZ2UgPSBfYS5yYW5nZTtcbiAgICAgICAgcmV0dXJuIGNpcmN1bGFyICYmIChjaXJjdWxhclswXSB8fCBjaXJjdWxhclsxXSkgPyBnZXRDaXJjdWxhdGVkUG9zKHYsIHJhbmdlLCBjaXJjdWxhcikgOiB2O1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIGZyb20gb3V0c2lkZSB0byBpbnNpZGVcbiAgICBpZiAodGhpcy5faXNPdXRzaWRlICYmIHRoaXMuX2F4aXNNYW5hZ2VyLmV2ZXJ5KGRlcGFQb3MsIGZ1bmN0aW9uICh2LCBvcHQpIHtcbiAgICAgIHJldHVybiAhaXNPdXRzaWRlKHYsIG9wdC5yYW5nZSk7XG4gICAgfSkpIHtcbiAgICAgIHRoaXMuX2lzT3V0c2lkZSA9IGZhbHNlO1xuICAgIH1cbiAgICBkZXBhUG9zID0gdGhpcy5fYXRPdXRzaWRlKGRlcGFQb3MpO1xuICAgIGRlc3RQb3MgPSB0aGlzLl9hdE91dHNpZGUoZGVzdFBvcyk7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMubmVzdGVkIHx8ICF0aGlzLl9pc0VuZG9mQXhpcyhvZmZzZXQsIGRlcGFQb3MsIGRlc3RQb3MpKSB7XG4gICAgICBuYXRpdmVFdmVudC5fX2NoaWxkcmVuQXhlc0FscmVhZHlDaGFuZ2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIGNoYW5nZU9wdGlvbiA9IHtcbiAgICAgIGlucHV0OiBpbnB1dCxcbiAgICAgIGV2ZW50OiBldmVudFxuICAgIH07XG4gICAgaWYgKHVzZUFuaW1hdGlvbikge1xuICAgICAgdmFyIGR1cmF0aW9uID0gdGhpcy5fYW5pbWF0aW9uTWFuYWdlci5nZXREdXJhdGlvbihkZXN0UG9zLCBkZXBhUG9zKTtcbiAgICAgIHRoaXMuX2FuaW1hdGlvbk1hbmFnZXIuYW5pbWF0ZVRvKGRlc3RQb3MsIGR1cmF0aW9uLCBjaGFuZ2VPcHRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaXNDYW5jZWxlZCA9ICF0aGlzLl9ldmVudE1hbmFnZXIudHJpZ2dlckNoYW5nZShkZXN0UG9zLCBkZXBhUG9zLCBjaGFuZ2VPcHRpb24sIHRydWUpO1xuICAgICAgaWYgKGlzQ2FuY2VsZWQpIHtcbiAgICAgICAgdGhpcy5faXNTdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fbW92ZURpc3RhbmNlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fYW5pbWF0aW9uTWFuYWdlci5maW5pc2goZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgX19wcm90by5yZWxlYXNlID0gZnVuY3Rpb24gKGlucHV0LCBldmVudCwgdmVsb2NpdHksIGlucHV0RHVyYXRpb24pIHtcbiAgICBpZiAodGhpcy5faXNTdG9wcGVkIHx8ICF0aGlzLl9pbnRlcnJ1cHRNYW5hZ2VyLmlzSW50ZXJydXB0aW5nKCkgfHwgIXRoaXMuX21vdmVEaXN0YW5jZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbmF0aXZlRXZlbnQgPSBldmVudC5zcmNFdmVudCA/IGV2ZW50LnNyY0V2ZW50IDogZXZlbnQ7XG4gICAgaWYgKG5hdGl2ZUV2ZW50Ll9fY2hpbGRyZW5BeGVzQWxyZWFkeVJlbGVhc2VkKSB7XG4gICAgICB2ZWxvY2l0eSA9IHZlbG9jaXR5Lm1hcChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHZhciBwb3MgPSB0aGlzLl9heGlzTWFuYWdlci5nZXQoaW5wdXQuYXhlcyk7XG4gICAgdmFyIGRlcGFQb3MgPSB0aGlzLl9heGlzTWFuYWdlci5nZXQoKTtcbiAgICB2YXIgZGlzcGxhY2VtZW50ID0gdGhpcy5fYW5pbWF0aW9uTWFuYWdlci5nZXREaXNwbGFjZW1lbnQodmVsb2NpdHkpO1xuICAgIHZhciBvZmZzZXQgPSB0b0F4aXMoaW5wdXQuYXhlcywgZGlzcGxhY2VtZW50KTtcbiAgICB2YXIgZGVzdFBvcyA9IHRoaXMuX2F4aXNNYW5hZ2VyLmdldCh0aGlzLl9heGlzTWFuYWdlci5tYXAob2Zmc2V0LCBmdW5jdGlvbiAodiwgb3B0LCBrKSB7XG4gICAgICBpZiAob3B0LmNpcmN1bGFyICYmIChvcHQuY2lyY3VsYXJbMF0gfHwgb3B0LmNpcmN1bGFyWzFdKSkge1xuICAgICAgICByZXR1cm4gcG9zW2tdICsgdjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBnZXRJbnNpZGVQb3NpdGlvbihwb3Nba10gKyB2LCBvcHQucmFuZ2UsIG9wdC5jaXJjdWxhciwgb3B0LmJvdW5jZSk7XG4gICAgICB9XG4gICAgfSkpO1xuICAgIG5hdGl2ZUV2ZW50Ll9fY2hpbGRyZW5BeGVzQWxyZWFkeVJlbGVhc2VkID0gdHJ1ZTtcbiAgICB2YXIgZHVyYXRpb24gPSB0aGlzLl9hbmltYXRpb25NYW5hZ2VyLmdldER1cmF0aW9uKGRlc3RQb3MsIHBvcywgaW5wdXREdXJhdGlvbik7XG4gICAgaWYgKGR1cmF0aW9uID09PSAwKSB7XG4gICAgICBkZXN0UG9zID0gX19hc3NpZ24oe30sIGRlcGFQb3MpO1xuICAgIH1cbiAgICAvLyBwcmVwYXJlIHBhcmFtc1xuICAgIHZhciBwYXJhbSA9IHtcbiAgICAgIGRlcGFQb3M6IGRlcGFQb3MsXG4gICAgICBkZXN0UG9zOiBkZXN0UG9zLFxuICAgICAgZHVyYXRpb246IGR1cmF0aW9uLFxuICAgICAgZGVsdGE6IHRoaXMuX2F4aXNNYW5hZ2VyLmdldERlbHRhKGRlcGFQb3MsIGRlc3RQb3MpLFxuICAgICAgaW5wdXRFdmVudDogZXZlbnQsXG4gICAgICBpbnB1dDogaW5wdXQsXG4gICAgICBpc1RydXN0ZWQ6IHRydWVcbiAgICB9O1xuICAgIC0tdGhpcy5fZXZlbnRNYW5hZ2VyLmhvbGRpbmdDb3VudDtcbiAgICB0aGlzLl9ldmVudE1hbmFnZXIudHJpZ2dlclJlbGVhc2UocGFyYW0pO1xuICAgIGlmICh0aGlzLl9ldmVudE1hbmFnZXIuaG9sZGluZ0NvdW50ID09PSAwKSB7XG4gICAgICB0aGlzLl9tb3ZlRGlzdGFuY2UgPSBudWxsO1xuICAgIH1cbiAgICAvLyB0byBjb250b2xcbiAgICB2YXIgdXNlcldpc2ggPSB0aGlzLl9hbmltYXRpb25NYW5hZ2VyLmdldFVzZXJDb250cm9sKHBhcmFtKTtcbiAgICB2YXIgaXNFcXVhbCA9IGVxdWFsKHVzZXJXaXNoLmRlc3RQb3MsIGRlcGFQb3MpO1xuICAgIHZhciBjaGFuZ2VPcHRpb24gPSB7XG4gICAgICBpbnB1dDogaW5wdXQsXG4gICAgICBldmVudDogZXZlbnRcbiAgICB9O1xuICAgIGlmIChpc0VxdWFsIHx8IHVzZXJXaXNoLmR1cmF0aW9uID09PSAwKSB7XG4gICAgICBpZiAoIWlzRXF1YWwpIHtcbiAgICAgICAgdGhpcy5fZXZlbnRNYW5hZ2VyLnRyaWdnZXJDaGFuZ2UodXNlcldpc2guZGVzdFBvcywgZGVwYVBvcywgY2hhbmdlT3B0aW9uLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2ludGVycnVwdE1hbmFnZXIuc2V0SW50ZXJydXB0KGZhbHNlKTtcbiAgICAgIGlmICh0aGlzLl9heGlzTWFuYWdlci5pc091dHNpZGUoKSkge1xuICAgICAgICB0aGlzLl9hbmltYXRpb25NYW5hZ2VyLnJlc3RvcmUoY2hhbmdlT3B0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2V2ZW50TWFuYWdlci50cmlnZ2VyRmluaXNoKHRydWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9hbmltYXRpb25NYW5hZ2VyLmFuaW1hdGVUbyh1c2VyV2lzaC5kZXN0UG9zLCB1c2VyV2lzaC5kdXJhdGlvbiwgY2hhbmdlT3B0aW9uKTtcbiAgICB9XG4gIH07XG4gIC8vIHdoZW4gbW92ZSBwb2ludGVyIGlzIGhlbGQgaW4gb3V0c2lkZVxuICBfX3Byb3RvLl9hdE91dHNpZGUgPSBmdW5jdGlvbiAocG9zKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBpZiAodGhpcy5faXNPdXRzaWRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYXhpc01hbmFnZXIubWFwKHBvcywgZnVuY3Rpb24gKHYsIG9wdCkge1xuICAgICAgICB2YXIgdG4gPSBvcHQucmFuZ2VbMF0gLSBvcHQuYm91bmNlWzBdO1xuICAgICAgICB2YXIgdHggPSBvcHQucmFuZ2VbMV0gKyBvcHQuYm91bmNlWzFdO1xuICAgICAgICByZXR1cm4gdiA+IHR4ID8gdHggOiB2IDwgdG4gPyB0biA6IHY7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX2F4aXNNYW5hZ2VyLm1hcChwb3MsIGZ1bmN0aW9uICh2LCBvcHQpIHtcbiAgICAgICAgdmFyIG1pbiA9IG9wdC5yYW5nZVswXTtcbiAgICAgICAgdmFyIG1heCA9IG9wdC5yYW5nZVsxXTtcbiAgICAgICAgdmFyIG91dCA9IG9wdC5ib3VuY2U7XG4gICAgICAgIHZhciBjaXJjdWxhciA9IG9wdC5jaXJjdWxhcjtcbiAgICAgICAgaWYgKGNpcmN1bGFyWzBdICYmIHYgPCBtaW4gfHwgY2lyY3VsYXJbMV0gJiYgdiA+IG1heCkge1xuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICB9IGVsc2UgaWYgKHYgPCBtaW4pIHtcbiAgICAgICAgICAvLyBsZWZ0XG4gICAgICAgICAgcmV0dXJuIG1pbiAtIF90aGlzLl9hbmltYXRpb25NYW5hZ2VyLmludGVycG9sYXRlKG1pbiAtIHYsIG91dFswXSk7XG4gICAgICAgIH0gZWxzZSBpZiAodiA+IG1heCkge1xuICAgICAgICAgIC8vIHJpZ2h0XG4gICAgICAgICAgcmV0dXJuIG1heCArIF90aGlzLl9hbmltYXRpb25NYW5hZ2VyLmludGVycG9sYXRlKHYgLSBtYXgsIG91dFsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHY7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIF9fcHJvdG8uX2lzRW5kb2ZBeGlzID0gZnVuY3Rpb24gKG9mZnNldCwgZGVwYVBvcywgZGVzdFBvcykge1xuICAgIHJldHVybiB0aGlzLl9heGlzTWFuYWdlci5ldmVyeShkZXBhUG9zLCBmdW5jdGlvbiAodmFsdWUsIG9wdGlvbiwga2V5KSB7XG4gICAgICByZXR1cm4gb2Zmc2V0W2tleV0gPT09IDAgfHwgZGVwYVBvc1trZXldID09PSBkZXN0UG9zW2tleV0gJiYgaXNFbmRvZkJvdW5jZSh2YWx1ZSwgb3B0aW9uLnJhbmdlLCBvcHRpb24uYm91bmNlLCBvcHRpb24uY2lyY3VsYXIpO1xuICAgIH0pO1xuICB9O1xuICByZXR1cm4gSW5wdXRPYnNlcnZlcjtcbn0oKTtcblxudmFyIGNsYW1wID0gZnVuY3Rpb24gKHZhbHVlLCBtaW4sIG1heCkge1xuICByZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4odmFsdWUsIG1heCksIG1pbik7XG59O1xudmFyIEFuaW1hdGlvbk1hbmFnZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBBbmltYXRpb25NYW5hZ2VyKF9hKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBfYS5vcHRpb25zLFxuICAgICAgaW50ZXJydXB0TWFuYWdlciA9IF9hLmludGVycnVwdE1hbmFnZXIsXG4gICAgICBldmVudE1hbmFnZXIgPSBfYS5ldmVudE1hbmFnZXIsXG4gICAgICBheGlzTWFuYWdlciA9IF9hLmF4aXNNYW5hZ2VyO1xuICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuaW50ZXJydXB0TWFuYWdlciA9IGludGVycnVwdE1hbmFnZXI7XG4gICAgdGhpcy5ldmVudE1hbmFnZXIgPSBldmVudE1hbmFnZXI7XG4gICAgdGhpcy5heGlzTWFuYWdlciA9IGF4aXNNYW5hZ2VyO1xuICAgIHRoaXMuYW5pbWF0aW9uRW5kID0gdGhpcy5hbmltYXRpb25FbmQuYmluZCh0aGlzKTtcbiAgfVxuICB2YXIgX19wcm90byA9IEFuaW1hdGlvbk1hbmFnZXIucHJvdG90eXBlO1xuICBfX3Byb3RvLmdldER1cmF0aW9uID0gZnVuY3Rpb24gKGRlcGFQb3MsIGRlc3RQb3MsIHdpc2hEdXJhdGlvbikge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIGR1cmF0aW9uO1xuICAgIGlmICh0eXBlb2Ygd2lzaER1cmF0aW9uICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBkdXJhdGlvbiA9IHdpc2hEdXJhdGlvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGR1cmF0aW9uc18xID0gbWFwKGRlc3RQb3MsIGZ1bmN0aW9uICh2LCBrKSB7XG4gICAgICAgIHJldHVybiBnZXREdXJhdGlvbihNYXRoLmFicyh2IC0gZGVwYVBvc1trXSksIF90aGlzLl9vcHRpb25zLmRlY2VsZXJhdGlvbik7XG4gICAgICB9KTtcbiAgICAgIGR1cmF0aW9uID0gT2JqZWN0LmtleXMoZHVyYXRpb25zXzEpLnJlZHVjZShmdW5jdGlvbiAobWF4LCB2KSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heChtYXgsIGR1cmF0aW9uc18xW3ZdKTtcbiAgICAgIH0sIC1JbmZpbml0eSk7XG4gICAgfVxuICAgIHJldHVybiBjbGFtcChkdXJhdGlvbiwgdGhpcy5fb3B0aW9ucy5taW5pbXVtRHVyYXRpb24sIHRoaXMuX29wdGlvbnMubWF4aW11bUR1cmF0aW9uKTtcbiAgfTtcbiAgX19wcm90by5nZXREaXNwbGFjZW1lbnQgPSBmdW5jdGlvbiAodmVsb2NpdHkpIHtcbiAgICB2YXIgdG90YWxWZWxvY2l0eSA9IE1hdGgucG93KHZlbG9jaXR5LnJlZHVjZShmdW5jdGlvbiAodG90YWwsIHYpIHtcbiAgICAgIHJldHVybiB0b3RhbCArIHYgKiB2O1xuICAgIH0sIDApLCAxIC8gdmVsb2NpdHkubGVuZ3RoKTtcbiAgICB2YXIgZHVyYXRpb24gPSBNYXRoLmFicyh0b3RhbFZlbG9jaXR5IC8gLXRoaXMuX29wdGlvbnMuZGVjZWxlcmF0aW9uKTtcbiAgICByZXR1cm4gdmVsb2NpdHkubWFwKGZ1bmN0aW9uICh2KSB7XG4gICAgICByZXR1cm4gdiAvIDIgKiBkdXJhdGlvbjtcbiAgICB9KTtcbiAgfTtcbiAgX19wcm90by5zdG9wQW5pbWF0aW9uID0gZnVuY3Rpb24gKG9wdGlvbikge1xuICAgIGlmICh0aGlzLl9hbmltYXRlUGFyYW0pIHtcbiAgICAgIHZhciBvcmdQb3NfMSA9IHRoaXMuYXhpc01hbmFnZXIuZ2V0KCk7XG4gICAgICB2YXIgcG9zID0gdGhpcy5heGlzTWFuYWdlci5tYXAob3JnUG9zXzEsIGZ1bmN0aW9uICh2LCBvcHQpIHtcbiAgICAgICAgcmV0dXJuIGdldENpcmN1bGF0ZWRQb3Modiwgb3B0LnJhbmdlLCBvcHQuY2lyY3VsYXIpO1xuICAgICAgfSk7XG4gICAgICBpZiAoIWV2ZXJ5KHBvcywgZnVuY3Rpb24gKHYsIGspIHtcbiAgICAgICAgcmV0dXJuIG9yZ1Bvc18xW2tdID09PSB2O1xuICAgICAgfSkpIHtcbiAgICAgICAgdGhpcy5ldmVudE1hbmFnZXIudHJpZ2dlckNoYW5nZShwb3MsIG9yZ1Bvc18xLCBvcHRpb24sICEhb3B0aW9uKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2FuaW1hdGVQYXJhbSA9IG51bGw7XG4gICAgICBpZiAodGhpcy5fcmFmKSB7XG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lJDEodGhpcy5fcmFmKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3JhZiA9IG51bGw7XG4gICAgICB0aGlzLmV2ZW50TWFuYWdlci50cmlnZ2VyQW5pbWF0aW9uRW5kKCEhKG9wdGlvbiA9PT0gbnVsbCB8fCBvcHRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbi5ldmVudCkpO1xuICAgIH1cbiAgfTtcbiAgX19wcm90by5nZXRFdmVudEluZm8gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX2FuaW1hdGVQYXJhbSAmJiB0aGlzLl9hbmltYXRlUGFyYW0uaW5wdXQgJiYgdGhpcy5fYW5pbWF0ZVBhcmFtLmlucHV0RXZlbnQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlucHV0OiB0aGlzLl9hbmltYXRlUGFyYW0uaW5wdXQsXG4gICAgICAgIGV2ZW50OiB0aGlzLl9hbmltYXRlUGFyYW0uaW5wdXRFdmVudFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9O1xuICBfX3Byb3RvLnJlc3RvcmUgPSBmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgdmFyIHBvcyA9IHRoaXMuYXhpc01hbmFnZXIuZ2V0KCk7XG4gICAgdmFyIGRlc3RQb3MgPSB0aGlzLmF4aXNNYW5hZ2VyLm1hcChwb3MsIGZ1bmN0aW9uICh2LCBvcHQpIHtcbiAgICAgIHJldHVybiBNYXRoLm1pbihvcHQucmFuZ2VbMV0sIE1hdGgubWF4KG9wdC5yYW5nZVswXSwgdikpO1xuICAgIH0pO1xuICAgIHRoaXMuc3RvcEFuaW1hdGlvbigpO1xuICAgIHRoaXMuYW5pbWF0ZVRvKGRlc3RQb3MsIHRoaXMuZ2V0RHVyYXRpb24ocG9zLCBkZXN0UG9zKSwgb3B0aW9uKTtcbiAgfTtcbiAgX19wcm90by5hbmltYXRpb25FbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGJlZm9yZVBhcmFtID0gdGhpcy5nZXRFdmVudEluZm8oKTtcbiAgICB0aGlzLl9hbmltYXRlUGFyYW0gPSBudWxsO1xuICAgIC8vIGZvciBDaXJjdWxhclxuICAgIHZhciBjaXJjdWxhclRhcmdldHMgPSB0aGlzLmF4aXNNYW5hZ2VyLmZpbHRlcih0aGlzLmF4aXNNYW5hZ2VyLmdldCgpLCBmdW5jdGlvbiAodiwgb3B0KSB7XG4gICAgICByZXR1cm4gaXNDaXJjdWxhcmFibGUodiwgb3B0LnJhbmdlLCBvcHQuY2lyY3VsYXIpO1xuICAgIH0pO1xuICAgIGlmIChPYmplY3Qua2V5cyhjaXJjdWxhclRhcmdldHMpLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuc2V0VG8odGhpcy5heGlzTWFuYWdlci5tYXAoY2lyY3VsYXJUYXJnZXRzLCBmdW5jdGlvbiAodiwgb3B0KSB7XG4gICAgICAgIHJldHVybiBnZXRDaXJjdWxhdGVkUG9zKHYsIG9wdC5yYW5nZSwgb3B0LmNpcmN1bGFyKTtcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgdGhpcy5pbnRlcnJ1cHRNYW5hZ2VyLnNldEludGVycnVwdChmYWxzZSk7XG4gICAgdGhpcy5ldmVudE1hbmFnZXIudHJpZ2dlckFuaW1hdGlvbkVuZCghIWJlZm9yZVBhcmFtKTtcbiAgICBpZiAodGhpcy5heGlzTWFuYWdlci5pc091dHNpZGUoKSkge1xuICAgICAgdGhpcy5yZXN0b3JlKGJlZm9yZVBhcmFtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5maW5pc2goISFiZWZvcmVQYXJhbSk7XG4gICAgfVxuICB9O1xuICBfX3Byb3RvLmZpbmlzaCA9IGZ1bmN0aW9uIChpc1RydXN0ZWQpIHtcbiAgICB0aGlzLl9hbmltYXRlUGFyYW0gPSBudWxsO1xuICAgIHRoaXMuaW50ZXJydXB0TWFuYWdlci5zZXRJbnRlcnJ1cHQoZmFsc2UpO1xuICAgIHRoaXMuZXZlbnRNYW5hZ2VyLnRyaWdnZXJGaW5pc2goaXNUcnVzdGVkKTtcbiAgfTtcbiAgX19wcm90by5nZXRVc2VyQ29udHJvbCA9IGZ1bmN0aW9uIChwYXJhbSkge1xuICAgIHZhciB1c2VyV2lzaCA9IHBhcmFtLnNldFRvKCk7XG4gICAgdXNlcldpc2guZGVzdFBvcyA9IHRoaXMuYXhpc01hbmFnZXIuZ2V0KHVzZXJXaXNoLmRlc3RQb3MpO1xuICAgIHVzZXJXaXNoLmR1cmF0aW9uID0gY2xhbXAodXNlcldpc2guZHVyYXRpb24sIHRoaXMuX29wdGlvbnMubWluaW11bUR1cmF0aW9uLCB0aGlzLl9vcHRpb25zLm1heGltdW1EdXJhdGlvbik7XG4gICAgcmV0dXJuIHVzZXJXaXNoO1xuICB9O1xuICBfX3Byb3RvLmFuaW1hdGVUbyA9IGZ1bmN0aW9uIChkZXN0UG9zLCBkdXJhdGlvbiwgb3B0aW9uKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB0aGlzLnN0b3BBbmltYXRpb24oKTtcbiAgICB2YXIgcGFyYW0gPSB0aGlzLl9jcmVhdGVBbmltYXRpb25QYXJhbShkZXN0UG9zLCBkdXJhdGlvbiwgb3B0aW9uKTtcbiAgICB2YXIgZGVwYVBvcyA9IF9fYXNzaWduKHt9LCBwYXJhbS5kZXBhUG9zKTtcbiAgICB2YXIgcmV0VHJpZ2dlciA9IHRoaXMuZXZlbnRNYW5hZ2VyLnRyaWdnZXJBbmltYXRpb25TdGFydChwYXJhbSk7XG4gICAgLy8gdG8gY29udHJvbFxuICAgIHZhciB1c2VyV2lzaCA9IHRoaXMuZ2V0VXNlckNvbnRyb2wocGFyYW0pO1xuICAgIC8vIFlvdSBjYW4ndCBzdG9wIHRoZSAnYW5pbWF0aW9uU3RhcnQnIGV2ZW50IHdoZW4gJ2NpcmN1bGFyJyBpcyB0cnVlLlxuICAgIGlmICghcmV0VHJpZ2dlciAmJiB0aGlzLmF4aXNNYW5hZ2VyLmV2ZXJ5KHVzZXJXaXNoLmRlc3RQb3MsIGZ1bmN0aW9uICh2LCBvcHQpIHtcbiAgICAgIHJldHVybiBpc0NpcmN1bGFyYWJsZSh2LCBvcHQucmFuZ2UsIG9wdC5jaXJjdWxhcik7XG4gICAgfSkpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIllvdSBjYW4ndCBzdG9wIHRoZSAnYW5pbWF0aW9uJyBldmVudCB3aGVuICdjaXJjdWxhcicgaXMgdHJ1ZS5cIik7XG4gICAgfVxuICAgIGlmIChyZXRUcmlnZ2VyICYmICFlcXVhbCh1c2VyV2lzaC5kZXN0UG9zLCBkZXBhUG9zKSkge1xuICAgICAgdmFyIGlucHV0RXZlbnQgPSAob3B0aW9uID09PSBudWxsIHx8IG9wdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9uLmV2ZW50KSB8fCBudWxsO1xuICAgICAgdGhpcy5fYW5pbWF0ZUxvb3Aoe1xuICAgICAgICBkZXBhUG9zOiBkZXBhUG9zLFxuICAgICAgICBkZXN0UG9zOiB1c2VyV2lzaC5kZXN0UG9zLFxuICAgICAgICBkdXJhdGlvbjogdXNlcldpc2guZHVyYXRpb24sXG4gICAgICAgIGRlbHRhOiB0aGlzLmF4aXNNYW5hZ2VyLmdldERlbHRhKGRlcGFQb3MsIHVzZXJXaXNoLmRlc3RQb3MpLFxuICAgICAgICBpc1RydXN0ZWQ6ICEhaW5wdXRFdmVudCxcbiAgICAgICAgaW5wdXRFdmVudDogaW5wdXRFdmVudCxcbiAgICAgICAgaW5wdXQ6IChvcHRpb24gPT09IG51bGwgfHwgb3B0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb24uaW5wdXQpIHx8IG51bGxcbiAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLmFuaW1hdGlvbkVuZCgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICBfX3Byb3RvLnNldFRvID0gZnVuY3Rpb24gKHBvcywgZHVyYXRpb24pIHtcbiAgICBpZiAoZHVyYXRpb24gPT09IHZvaWQgMCkge1xuICAgICAgZHVyYXRpb24gPSAwO1xuICAgIH1cbiAgICB2YXIgYXhlcyA9IE9iamVjdC5rZXlzKHBvcyk7XG4gICAgdmFyIG9yZ1BvcyA9IHRoaXMuYXhpc01hbmFnZXIuZ2V0KGF4ZXMpO1xuICAgIGlmIChlcXVhbChwb3MsIG9yZ1BvcykpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB0aGlzLmludGVycnVwdE1hbmFnZXIuc2V0SW50ZXJydXB0KHRydWUpO1xuICAgIHZhciBtb3ZlZFBvcyA9IGZpbHRlcihwb3MsIGZ1bmN0aW9uICh2LCBrKSB7XG4gICAgICByZXR1cm4gb3JnUG9zW2tdICE9PSB2O1xuICAgIH0pO1xuICAgIGlmICghT2JqZWN0LmtleXMobW92ZWRQb3MpLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG1vdmVkUG9zID0gdGhpcy5heGlzTWFuYWdlci5tYXAobW92ZWRQb3MsIGZ1bmN0aW9uICh2LCBvcHQpIHtcbiAgICAgIHZhciByYW5nZSA9IG9wdC5yYW5nZSxcbiAgICAgICAgY2lyY3VsYXIgPSBvcHQuY2lyY3VsYXI7XG4gICAgICBpZiAoY2lyY3VsYXIgJiYgKGNpcmN1bGFyWzBdIHx8IGNpcmN1bGFyWzFdKSkge1xuICAgICAgICByZXR1cm4gdjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBnZXRJbnNpZGVQb3NpdGlvbih2LCByYW5nZSwgY2lyY3VsYXIpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChlcXVhbChtb3ZlZFBvcywgb3JnUG9zKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmIChkdXJhdGlvbiA+IDApIHtcbiAgICAgIHRoaXMuYW5pbWF0ZVRvKG1vdmVkUG9zLCBkdXJhdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RvcEFuaW1hdGlvbigpO1xuICAgICAgdGhpcy5ldmVudE1hbmFnZXIudHJpZ2dlckNoYW5nZShtb3ZlZFBvcyk7XG4gICAgICB0aGlzLmZpbmlzaChmYWxzZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBfX3Byb3RvLnNldEJ5ID0gZnVuY3Rpb24gKHBvcywgZHVyYXRpb24pIHtcbiAgICBpZiAoZHVyYXRpb24gPT09IHZvaWQgMCkge1xuICAgICAgZHVyYXRpb24gPSAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zZXRUbyhtYXAodGhpcy5heGlzTWFuYWdlci5nZXQoT2JqZWN0LmtleXMocG9zKSksIGZ1bmN0aW9uICh2LCBrKSB7XG4gICAgICByZXR1cm4gdiArIHBvc1trXTtcbiAgICB9KSwgZHVyYXRpb24pO1xuICB9O1xuICBfX3Byb3RvLnNldE9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHRoaXMuX29wdGlvbnMgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgdGhpcy5fb3B0aW9ucyksIG9wdGlvbnMpO1xuICB9O1xuICBfX3Byb3RvLl9jcmVhdGVBbmltYXRpb25QYXJhbSA9IGZ1bmN0aW9uIChwb3MsIGR1cmF0aW9uLCBvcHRpb24pIHtcbiAgICB2YXIgZGVwYVBvcyA9IHRoaXMuYXhpc01hbmFnZXIuZ2V0KCk7XG4gICAgdmFyIGRlc3RQb3MgPSBwb3M7XG4gICAgdmFyIGlucHV0RXZlbnQgPSAob3B0aW9uID09PSBudWxsIHx8IG9wdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9uLmV2ZW50KSB8fCBudWxsO1xuICAgIHJldHVybiB7XG4gICAgICBkZXBhUG9zOiBkZXBhUG9zLFxuICAgICAgZGVzdFBvczogZGVzdFBvcyxcbiAgICAgIGR1cmF0aW9uOiBjbGFtcChkdXJhdGlvbiwgdGhpcy5fb3B0aW9ucy5taW5pbXVtRHVyYXRpb24sIHRoaXMuX29wdGlvbnMubWF4aW11bUR1cmF0aW9uKSxcbiAgICAgIGRlbHRhOiB0aGlzLmF4aXNNYW5hZ2VyLmdldERlbHRhKGRlcGFQb3MsIGRlc3RQb3MpLFxuICAgICAgaW5wdXRFdmVudDogaW5wdXRFdmVudCxcbiAgICAgIGlucHV0OiAob3B0aW9uID09PSBudWxsIHx8IG9wdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9uLmlucHV0KSB8fCBudWxsLFxuICAgICAgaXNUcnVzdGVkOiAhIWlucHV0RXZlbnQsXG4gICAgICBkb25lOiB0aGlzLmFuaW1hdGlvbkVuZFxuICAgIH07XG4gIH07XG4gIF9fcHJvdG8uX2FuaW1hdGVMb29wID0gZnVuY3Rpb24gKHBhcmFtLCBjb21wbGV0ZSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgaWYgKHBhcmFtLmR1cmF0aW9uKSB7XG4gICAgICB0aGlzLl9hbmltYXRlUGFyYW0gPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcGFyYW0pLCB7XG4gICAgICAgIHN0YXJ0VGltZTogbmV3IERhdGUoKS5nZXRUaW1lKClcbiAgICAgIH0pO1xuICAgICAgdmFyIG9yaWdpbmFsSW50ZW5kZWRQb3NfMSA9IG1hcChwYXJhbS5kZXN0UG9zLCBmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gdjtcbiAgICAgIH0pO1xuICAgICAgdmFyIHN0YXRlXzEgPSB0aGlzLl9pbml0U3RhdGUodGhpcy5fYW5pbWF0ZVBhcmFtKTtcbiAgICAgIHZhciBsb29wXzEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLl9yYWYgPSBudWxsO1xuICAgICAgICB2YXIgYW5pbWF0ZVBhcmFtID0gX3RoaXMuX2FuaW1hdGVQYXJhbTtcbiAgICAgICAgdmFyIG5leHRTdGF0ZSA9IF90aGlzLl9nZXROZXh0U3RhdGUoc3RhdGVfMSk7XG4gICAgICAgIHZhciBpc0NhbmNlbGVkID0gIV90aGlzLmV2ZW50TWFuYWdlci50cmlnZ2VyQ2hhbmdlKG5leHRTdGF0ZS5wb3MsIHN0YXRlXzEucG9zKTtcbiAgICAgICAgc3RhdGVfMSA9IG5leHRTdGF0ZTtcbiAgICAgICAgaWYgKG5leHRTdGF0ZS5maW5pc2hlZCkge1xuICAgICAgICAgIGFuaW1hdGVQYXJhbS5kZXN0UG9zID0gX3RoaXMuX2dldEZpbmFsUG9zKGFuaW1hdGVQYXJhbS5kZXN0UG9zLCBvcmlnaW5hbEludGVuZGVkUG9zXzEpO1xuICAgICAgICAgIGlmICghZXF1YWwoYW5pbWF0ZVBhcmFtLmRlc3RQb3MsIF90aGlzLmF4aXNNYW5hZ2VyLmdldChPYmplY3Qua2V5cyhhbmltYXRlUGFyYW0uZGVzdFBvcykpKSkge1xuICAgICAgICAgICAgX3RoaXMuZXZlbnRNYW5hZ2VyLnRyaWdnZXJDaGFuZ2UoYW5pbWF0ZVBhcmFtLmRlc3RQb3MsIG5leHRTdGF0ZS5wb3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb21wbGV0ZSgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIGlmIChpc0NhbmNlbGVkKSB7XG4gICAgICAgICAgX3RoaXMuZmluaXNoKGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdGhpcy5fcmFmID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lJDEobG9vcF8xKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGxvb3BfMSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmV2ZW50TWFuYWdlci50cmlnZ2VyQ2hhbmdlKHBhcmFtLmRlc3RQb3MpO1xuICAgICAgY29tcGxldGUoKTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBHZXQgZXN0aW1hdGVkIGZpbmFsIHZhbHVlLlxuICAgKlxuICAgKiBJZiBkZXN0UG9zIGlzIHdpdGhpbiB0aGUgJ2Vycm9yIHJhbmdlJyBvZiB0aGUgb3JpZ2luYWwgaW50ZW5kZWQgcG9zaXRpb24sIHRoZSBpbml0aWFsIGludGVuZGVkIHBvc2l0aW9uIGlzIHJldHVybmVkLlxuICAgKiAgIC0gZWcuIG9yaWdpbmFsIGludGVuZGVkIHBvczogMTAwLCBkZXN0UG9zOiAxMDAuMDAwMDAwMDAwNCA9PT4gcmV0dXJuIDEwMDtcbiAgICogSWYgZGVzdCBQb3MgaXMgb3V0c2lkZSB0aGUgJ3JhbmdlIG9mIGVycm9yJyBjb21wYXJlZCB0byB0aGUgb3JpZ2luYWxseSBpbnRlbmRlZCBwb3MsIGl0IGlzIHJldHVybmVkIHJvdW5kZWQgYmFzZWQgb24gdGhlIG9yaWdpbmFsbHkgaW50ZW5kZWQgcG9zLlxuICAgKiAgIC0gZWcuIG9yaWdpbmFsIGludGVuZGVkIHBvczogMTAwLjEyMyBkZXN0UG9zOiA1MC4xMjM0NSA9PiByZXR1cm4gNTAuMTIzXG4gICAqIEBwYXJhbSBvcmlnaW5hbEludGVuZGVkUG9zXG4gICAqIEBwYXJhbSBkZXN0UG9zXG4gICAqL1xuICBfX3Byb3RvLl9nZXRGaW5hbFBvcyA9IGZ1bmN0aW9uIChkZXN0UG9zLCBvcmlnaW5hbEludGVuZGVkUG9zKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAvLyBjb21wYXJlIGRlc3RQb3MgYW5kIG9yaWdpbmFsSW50ZW5kZWRQb3NcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG4gICAgdmFyIEVSUk9SX0xJTUlUID0gMC4wMDAwMDE7XG4gICAgdmFyIGZpbmFsUG9zID0gbWFwKGRlc3RQb3MsIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICBpZiAodmFsdWUgPj0gb3JpZ2luYWxJbnRlbmRlZFBvc1trZXldIC0gRVJST1JfTElNSVQgJiYgdmFsdWUgPD0gb3JpZ2luYWxJbnRlbmRlZFBvc1trZXldICsgRVJST1JfTElNSVQpIHtcbiAgICAgICAgLy8gSW4gZXJyb3IgcmFuZ2UsIHJldHVybiBvcmlnaW5hbCBpbnRlbmRlZFxuICAgICAgICByZXR1cm4gb3JpZ2luYWxJbnRlbmRlZFBvc1trZXldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gT3V0IG9mIGVycm9yIHJhbmdlLCByZXR1cm4gcm91bmRlZCBwb3MuXG4gICAgICAgIHZhciByb3VuZFVuaXQgPSBfdGhpcy5fZ2V0Um91bmRVbml0KHZhbHVlLCBrZXkpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gcm91bmROdW1iZXIodmFsdWUsIHJvdW5kVW5pdCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGZpbmFsUG9zO1xuICB9O1xuICBfX3Byb3RvLl9nZXRSb3VuZFVuaXQgPSBmdW5jdGlvbiAodmFsLCBrZXkpIHtcbiAgICB2YXIgcm91bmRVbml0ID0gdGhpcy5fb3B0aW9ucy5yb3VuZDsgLy8gbWFudWFsIG1vZGVcbiAgICB2YXIgbWluUm91bmRVbml0ID0gbnVsbDsgLy8gYXV0byBtb2RlXG4gICAgLy8gYXV0byBtb2RlXG4gICAgaWYgKCFyb3VuZFVuaXQpIHtcbiAgICAgIC8vIEdldCBtaW5pbXVtIHJvdW5kIHVuaXRcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5heGlzTWFuYWdlci5nZXRBeGlzT3B0aW9ucyhrZXkpO1xuICAgICAgbWluUm91bmRVbml0ID0gaW52ZXJzZVBvdyhNYXRoLm1heChnZXREZWNpbWFsUGxhY2Uob3B0aW9ucy5yYW5nZVswXSksIGdldERlY2ltYWxQbGFjZShvcHRpb25zLnJhbmdlWzFdKSwgZ2V0RGVjaW1hbFBsYWNlKHZhbCkpKTtcbiAgICB9XG4gICAgcmV0dXJuIG1pblJvdW5kVW5pdCB8fCByb3VuZFVuaXQ7XG4gIH07XG4gIHJldHVybiBBbmltYXRpb25NYW5hZ2VyO1xufSgpO1xuXG52YXIgRWFzaW5nTWFuYWdlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyQxKEVhc2luZ01hbmFnZXIsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIEVhc2luZ01hbmFnZXIoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgX3RoaXMuX3VzZUR1cmF0aW9uID0gdHJ1ZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgdmFyIF9fcHJvdG8gPSBFYXNpbmdNYW5hZ2VyLnByb3RvdHlwZTtcbiAgX19wcm90by5pbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uIChkaXNwbGFjZW1lbnQsIHRocmVzaG9sZCkge1xuICAgIHZhciBpbml0U2xvcGUgPSB0aGlzLl9lYXNpbmcoMC4wMDAwMSkgLyAwLjAwMDAxO1xuICAgIHJldHVybiB0aGlzLl9lYXNpbmcoZGlzcGxhY2VtZW50IC8gKHRocmVzaG9sZCAqIGluaXRTbG9wZSkpICogdGhyZXNob2xkO1xuICB9O1xuICBfX3Byb3RvLnVwZGF0ZUFuaW1hdGlvbiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdmFyIF9hO1xuICAgIHZhciBhbmltYXRlUGFyYW0gPSB0aGlzLl9hbmltYXRlUGFyYW07XG4gICAgaWYgKCFhbmltYXRlUGFyYW0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGRpZmZUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSBhbmltYXRlUGFyYW0uc3RhcnRUaW1lO1xuICAgIHZhciBwb3MgPSAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmRlc3RQb3MpIHx8IGFuaW1hdGVQYXJhbS5kZXN0UG9zO1xuICAgIHZhciBkdXJhdGlvbiA9IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kdXJhdGlvbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogYW5pbWF0ZVBhcmFtLmR1cmF0aW9uO1xuICAgIGlmICgob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnJlc3RhcnQpIHx8IGR1cmF0aW9uIDw9IGRpZmZUaW1lKSB7XG4gICAgICB0aGlzLnNldFRvKHBvcywgZHVyYXRpb24gLSBkaWZmVGltZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZGVzdFBvcykge1xuICAgICAgdmFyIGN1cnJlbnRQb3MgPSB0aGlzLmF4aXNNYW5hZ2VyLmdldCgpO1xuICAgICAgLy8gV2hlbiBkZXN0aW5hdGlvbiBpcyBjaGFuZ2VkLCBuZXcgZGVsdGEgc2hvdWxkIGJlIGNhbGN1bGF0ZWQgYXMgcmVtYWluaW5nIHBlcmNlbnQuXG4gICAgICAvLyBGb3IgZXhhbXBsZSwgbW92aW5nIHg6MCwgeTowIHRvIHg6MjAwLCB5OjIwMCBhbmQgaXQgaGFzIGN1cnJlbnQgZWFzaW5nIHBlcmNlbnQgb2YgOTIlLiBjb29yZGluYXRlIGlzIHg6MTg0IGFuZCB5OjE4NFxuICAgICAgLy8gSWYgZGVzdGluYXRpb24gY2hhbmdlcyB0byB4OjMwMCwgeTozMDAuIHhkZWx0YToyMDAsIHlkZWx0YToyMDAgY2hhbmdlcyB0byB4ZGVsdGE6MTE2LCB5ZGVsdGE6MTE2IGFuZCB1c2UgcmVtYWluaW5nIGVhc2luZ1BlciBhcyAxMDAlLCBub3QgOCUgYXMgcHJldmlvdXMuXG4gICAgICAvLyBUaGVyZWZvcmUsIG9yaWdpbmFsIGVhc2luZ1BlciBieSB0aW1lIGlzIGtlcHQuIEFuZCBkaXZpZGVkIGJ5ICgxIC0gc2VsZi5faW5pdGlhbEVhc2luZ1Blcikgd2hpY2ggbWVhbnMgbmV3IHRvdGFsIGVhc2luZyBwZXJjZW50LiBMaWtlIGNhbGN1bGF0aW5nIDglIGFzIDEwMCUuXG4gICAgICB0aGlzLl9pbml0aWFsRWFzaW5nUGVyID0gdGhpcy5fcHJldkVhc2luZ1BlcjtcbiAgICAgIGFuaW1hdGVQYXJhbS5kZWx0YSA9IHRoaXMuYXhpc01hbmFnZXIuZ2V0RGVsdGEoY3VycmVudFBvcywgcG9zKTtcbiAgICAgIGFuaW1hdGVQYXJhbS5kZXN0UG9zID0gcG9zO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmR1cmF0aW9uKSB7XG4gICAgICB2YXIgcmF0aW8gPSAoZGlmZlRpbWUgKyB0aGlzLl9kdXJhdGlvbk9mZnNldCkgLyBhbmltYXRlUGFyYW0uZHVyYXRpb247XG4gICAgICAvLyBVc2UgZHVyYXRpb25PZmZzZXQgZm9yIGtlZXBpbmcgYW5pbWF0aW9uIHJhdGlvIGFmdGVyIGR1cmF0aW9uIGlzIGNoYW5nZWQuXG4gICAgICAvLyBuZXdSYXRpbyA9IChkaWZmVGltZSArIG5ld0R1cmF0aW9uT2Zmc2V0KSAvIG5ld0R1cmF0aW9uID0gb2xkUmF0aW9cbiAgICAgIC8vIG5ld0R1cmF0aW9uT2Zmc2V0ID0gb2xkUmF0aW8gKiBuZXdEdXJhdGlvbiAtIGRpZmZUaW1lXG4gICAgICB0aGlzLl9kdXJhdGlvbk9mZnNldCA9IHJhdGlvICogZHVyYXRpb24gLSBkaWZmVGltZTtcbiAgICAgIGFuaW1hdGVQYXJhbS5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgIH1cbiAgfTtcbiAgX19wcm90by5faW5pdFN0YXRlID0gZnVuY3Rpb24gKGluZm8pIHtcbiAgICB0aGlzLl9pbml0aWFsRWFzaW5nUGVyID0gMDtcbiAgICB0aGlzLl9wcmV2RWFzaW5nUGVyID0gMDtcbiAgICB0aGlzLl9kdXJhdGlvbk9mZnNldCA9IDA7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvczogaW5mby5kZXBhUG9zLFxuICAgICAgZWFzaW5nUGVyOiAwLFxuICAgICAgZmluaXNoZWQ6IGZhbHNlXG4gICAgfTtcbiAgfTtcbiAgX19wcm90by5fZ2V0TmV4dFN0YXRlID0gZnVuY3Rpb24gKHByZXZTdGF0ZSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIGFuaW1hdGVQYXJhbSA9IHRoaXMuX2FuaW1hdGVQYXJhbTtcbiAgICB2YXIgcHJldlBvcyA9IHByZXZTdGF0ZS5wb3M7XG4gICAgdmFyIGRlc3RQb3MgPSBhbmltYXRlUGFyYW0uZGVzdFBvcztcbiAgICB2YXIgZGlyZWN0aW9ucyA9IG1hcChwcmV2UG9zLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgcmV0dXJuIHZhbHVlIDw9IGRlc3RQb3Nba2V5XSA/IDEgOiAtMTtcbiAgICB9KTtcbiAgICB2YXIgZGlmZlRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIGFuaW1hdGVQYXJhbS5zdGFydFRpbWU7XG4gICAgdmFyIHJhdGlvID0gKGRpZmZUaW1lICsgdGhpcy5fZHVyYXRpb25PZmZzZXQpIC8gYW5pbWF0ZVBhcmFtLmR1cmF0aW9uO1xuICAgIHZhciBlYXNpbmdQZXIgPSB0aGlzLl9lYXNpbmcocmF0aW8pO1xuICAgIHZhciB0b1BvcyA9IHRoaXMuYXhpc01hbmFnZXIubWFwKHByZXZQb3MsIGZ1bmN0aW9uIChwb3MsIG9wdGlvbnMsIGtleSkge1xuICAgICAgdmFyIG5leHRQb3MgPSByYXRpbyA+PSAxID8gZGVzdFBvc1trZXldIDogcG9zICsgYW5pbWF0ZVBhcmFtLmRlbHRhW2tleV0gKiAoZWFzaW5nUGVyIC0gX3RoaXMuX3ByZXZFYXNpbmdQZXIpIC8gKDEgLSBfdGhpcy5faW5pdGlhbEVhc2luZ1Blcik7XG4gICAgICAvLyBTdWJ0cmFjdCBkaXN0YW5jZSBmcm9tIGRpc3RhbmNlIGFscmVhZHkgbW92ZWQuXG4gICAgICAvLyBSZWNhbGN1bGF0ZSB0aGUgcmVtYWluaW5nIGRpc3RhbmNlLlxuICAgICAgLy8gRml4IHRoZSBib3VuY2luZyBwaGVub21lbm9uIGJ5IGNoYW5naW5nIHRoZSByYW5nZS5cbiAgICAgIHZhciBjaXJjdWxhdGVkUG9zID0gZ2V0Q2lyY3VsYXRlZFBvcyhuZXh0UG9zLCBvcHRpb25zLnJhbmdlLCBvcHRpb25zLmNpcmN1bGFyKTtcbiAgICAgIGlmIChuZXh0UG9zICE9PSBjaXJjdWxhdGVkUG9zKSB7XG4gICAgICAgIC8vIGNpcmN1bGFyXG4gICAgICAgIHZhciByYW5nZU9mZnNldCA9IGRpcmVjdGlvbnNba2V5XSAqIChvcHRpb25zLnJhbmdlWzFdIC0gb3B0aW9ucy5yYW5nZVswXSk7XG4gICAgICAgIGRlc3RQb3Nba2V5XSAtPSByYW5nZU9mZnNldDtcbiAgICAgICAgcHJldlBvc1trZXldIC09IHJhbmdlT2Zmc2V0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNpcmN1bGF0ZWRQb3M7XG4gICAgfSk7XG4gICAgdGhpcy5fcHJldkVhc2luZ1BlciA9IGVhc2luZ1BlcjtcbiAgICByZXR1cm4ge1xuICAgICAgcG9zOiB0b1BvcyxcbiAgICAgIGVhc2luZ1BlcjogZWFzaW5nUGVyLFxuICAgICAgZmluaXNoZWQ6IGVhc2luZ1BlciA+PSAxXG4gICAgfTtcbiAgfTtcbiAgX19wcm90by5fZWFzaW5nID0gZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gcCA+IDEgPyAxIDogdGhpcy5fb3B0aW9ucy5lYXNpbmcocCk7XG4gIH07XG4gIHJldHVybiBFYXNpbmdNYW5hZ2VyO1xufShBbmltYXRpb25NYW5hZ2VyKTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBBeGlzT3B0aW9uIFRoZSBBeGlzIGluZm9ybWF0aW9uLiBUaGUga2V5IG9mIHRoZSBheGlzIHNwZWNpZmllcyB0aGUgbmFtZSB0byB1c2UgYXMgdGhlIGxvZ2ljYWwgdmlydHVhbCBjb29yZGluYXRlIHN5c3RlbS5cbiAqIEBrbyDstpUg7KCV67O0LiDstpXsnZgg7YKk64qUIOuFvOumrOyggeyduCDqsIDsg4Eg7KKM7ZGc6rOE66GcIOyCrOyaqe2VoCDsnbTrpoTsnYQg7KeA7KCV7ZWc64ukLlxuICogQHBhcmFtIHtOdW1iZXJbXX0gW3JhbmdlXSBUaGUgcmFuZ2Ugb2YgY29vcmRpbmF0ZSA8a28+7KKM7ZGcIOuylOychDwva28+XG4gKiBAcGFyYW0ge051bWJlcn0gW3JhbmdlWzBdPTBdIFRoZSBjb29yZGluYXRlIG9mIHRoZSBtaW5pbXVtIDxrbz7stZzshowg7KKM7ZGcPC9rbz5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbcmFuZ2VbMV09MF0gVGhlIGNvb3JkaW5hdGUgb2YgdGhlIG1heGltdW0gPGtvPuy1nOuMgCDsooztkZw8L2tvPlxuICogQHBhcmFtIHtOdW1iZXJ9IFtzdGFydFBvcz1yYW5nZVswXV0gVGhlIGNvb3JkaW5hdGVzIHRvIGJlIG1vdmVkIHdoZW4gY3JlYXRpbmcgYW4gaW5zdGFuY2UgPGtvPuyduOyKpO2EtOyKpCDsg53shLHsi5wg7J2064+Z7ZWgIOyijO2RnDwva28+XG4gKiBAcGFyYW0ge051bWJlcltdfSBbYm91bmNlXSBUaGUgc2l6ZSBvZiBib3VuY2luZyBhcmVhLiBUaGUgY29vcmRpbmF0ZXMgY2FuIGV4Y2VlZCB0aGUgY29vcmRpbmF0ZSBhcmVhIGFzIG11Y2ggYXMgdGhlIGJvdW5jaW5nIGFyZWEgYmFzZWQgb24gdXNlciBhY3Rpb24uIElmIHRoZSBjb29yZGluYXRlcyBkb2VzIG5vdCBleGNlZWQgdGhlIGJvdW5jaW5nIGFyZWEgd2hlbiBhbiBlbGVtZW50IGlzIGRyYWdnZWQsIHRoZSBjb29yZGluYXRlcyB3aGVyZSBib3VuY2luZyBlZmZlY3RzIGFyZSBhcHBsaWVkIGFyZSByZXR1bmVkIGJhY2sgaW50byB0aGUgY29vcmRpbmF0ZSBhcmVhPGtvPuuwlOyatOyKpCDsmIHsl63snZgg7YGs6riwLiDsgqzsmqnsnpDsnZgg64+Z7J6R7JeQIOuUsOudvCDsooztkZzqsIAg7KKM7ZGcIOyYgeyXreydhCDrhJjslrQg67CU7Jq07IqkIOyYgeyXreydmCDtgazquLDrp4ztgbwg642UIOydtOuPme2VoCDsiJgg7J6I64ukLiDsgqzsmqnsnpDqsIAg64GM7Ja064ukIOuGk+uKlCDrj5nsnpHsnYQg7ZaI7J2EIOuVjCDsooztkZzqsIAg67CU7Jq07IqkIOyYgeyXreyXkCDsnojsnLzrqbQsIOuwlOyatOyKpCDtmqjqs7zqsIAg7KCB7Jqp65CcIOyijO2RnOqwgCDri6Tsi5wg7KKM7ZGcIOyYgeyXrSDslYjsnLzroZwg65Ok7Ja07Jio64ukPC9rbz5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbYm91bmNlWzBdPTBdIFRoZSBzaXplIG9mIGNvb3JkaW5hdGUgb2YgdGhlIG1pbmltdW0gYXJlYSA8a28+7LWc7IaMIOyijO2RnCDrsJTsmrTsiqQg7JiB7Jet7J2YIO2BrOq4sDwva28+XG4gKiBAcGFyYW0ge051bWJlcn0gW2JvdW5jZVsxXT0wXSBUaGUgc2l6ZSBvZiBjb29yZGluYXRlIG9mIHRoZSBtYXhpbXVtIGFyZWEgPGtvPuy1nOuMgCDsooztkZwg67CU7Jq07IqkIOyYgeyXreydmCDtgazquLA8L2tvPlxuICogQHBhcmFtIHtCb29sZWFuW119IFtjaXJjdWxhcl0gSW5kaWNhdGVzIHdoZXRoZXIgYSBjaXJjdWxhciBlbGVtZW50IGlzIGF2YWlsYWJsZS4gSWYgaXQgaXMgc2V0IHRvIFwidHJ1ZVwiIGFuZCBhbiBlbGVtZW50IGlzIGRyYWdnZWQgb3V0c2lkZSB0aGUgY29vcmRpbmF0ZSBhcmVhLCB0aGUgZWxlbWVudCB3aWxsIGFwcGVhciBvbiB0aGUgb3RoZXIgc2lkZS48a28+7Iic7ZmYIOyXrOu2gC4gJ3RydWUn66GcIOyEpOygle2VnCDrsKntlqXsnZgg7KKM7ZGcIOyYgeyXrSDrsJbsnLzroZwg7JeY66as66i87Yq46rCAIOydtOuPme2VmOuptCDrsJjrjIAg67Cp7Zal7JeQ7IScIOyXmOumrOuovO2KuOqwgCDrgpjtg4Drgpzri6Q8L2tvPlxuICogQHBhcmFtIHtCb29sZWFufSBbY2lyY3VsYXJbMF09ZmFsc2VdIEluZGljYXRlcyB3aGV0aGVyIHRvIGNpcmN1bGF0ZSB0byB0aGUgY29vcmRpbmF0ZSBvZiB0aGUgbWluaW11bSA8a28+7LWc7IaMIOyijO2RnCDrsKntlqXsnZgg7Iic7ZmYIOyXrOu2gDwva28+XG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtjaXJjdWxhclsxXT1mYWxzZV0gSW5kaWNhdGVzIHdoZXRoZXIgdG8gY2lyY3VsYXRlIHRvIHRoZSBjb29yZGluYXRlIG9mIHRoZSBtYXhpbXVtIDxrbz7stZzrjIAg7KKM7ZGcIOuwqe2WpeydmCDsiJztmZgg7Jes67aAPC9rbz5cbiAqKi9cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gQXhlc09wdGlvbiBUaGUgb3B0aW9uIG9iamVjdCBvZiB0aGUgZWcuQXhlcyBtb2R1bGVcbiAqIEBrbyBlZy5BeGVzIOuqqOuTiOydmCDsmLXshZgg6rCd7LK0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZWFzaW5nPWVhc2luZy5lYXNlT3V0Q3ViaWNdIFRoZSBlYXNpbmcgZnVuY3Rpb24gdG8gYXBwbHkgdG8gYW4gYW5pbWF0aW9uIDxrbz7slaDri4jrqZTsnbTshZjsl5Ag7KCB7Jqp7ZWgIGVhc2luZyDtlajsiJg8L2tvPlxuICogQHBhcmFtIHtOdW1iZXJ9IFttYXhpbXVtRHVyYXRpb249SW5maW5pdHldIE1heGltdW0gZHVyYXRpb24gb2YgdGhlIGFuaW1hdGlvbiA8a28+6rCA7IaN64+E7JeQIOydmO2VtCDslaDri4jrqZTsnbTshZjsnbQg64+Z7J6R7ZWgIOuVjOydmCDstZzrjIAg7KKM7ZGcIOydtOuPmSDsi5zqsIQ8L2tvPlxuICogQHBhcmFtIHtOdW1iZXJ9IFttaW5pbXVtRHVyYXRpb249MF0gTWluaW11bSBkdXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uIDxrbz7qsIDsho3rj4Tsl5Ag7J2Y7ZW0IOyVoOuLiOuplOydtOyFmOydtCDrj5nsnpHtlaAg65WM7J2YIOy1nOyGjCDsooztkZwg7J2064+ZIOyLnOqwhDwva28+XG4gKiBAcGFyYW0ge051bWJlcn0gW2RlY2VsZXJhdGlvbj0wLjAwMDZdIERlY2VsZXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uIHdoZXJlIGFjY2VsZXJhdGlvbiBpcyBtYW51YWxseSBlbmFibGVkIGJ5IHVzZXIuIEEgaGlnaGVyIHZhbHVlIGluZGljYXRlcyBzaG9ydGVyIHJ1bm5pbmcgdGltZS4gPGtvPuyCrOyaqeyekOydmCDrj5nsnpHsnLzroZwg6rCA7IaN64+E6rCAIOyggeyaqeuQnCDslaDri4jrqZTsnbTshZjsnZgg6rCQ7IaN64+ELiDqsJLsnbQg64aS7J2E7IiY66GdIOyVoOuLiOuplOydtOyFmCDsi6Ttlokg7Iuc6rCE7J20IOynp+yVhOynhOuLpDwva28+XG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtpbnRlcnJ1cHRhYmxlPXRydWVdIEluZGljYXRlcyB3aGV0aGVyIGFuIGFuaW1hdGlvbiBpcyBpbnRlcnJ1cHRpYmxlLlxuICogLSB0cnVlOiBJdCBjYW4gYmUgcGF1c2VkIG9yIHN0b3BwZWQgYnkgdXNlciBhY3Rpb24gb3IgdGhlIEFQSS5cbiAqIC0gZmFsc2U6IEl0IGNhbm5vdCBiZSBwYXVzZWQgb3Igc3RvcHBlZCBieSB1c2VyIGFjdGlvbiBvciB0aGUgQVBJIHdoaWxlIGl0IGlzIHJ1bm5pbmcuXG4gKiA8a28+7KeE7ZaJIOykkeyduCDslaDri4jrqZTsnbTshZgg7KSR7KeAIOqwgOuKpSDsl6zrtoAuXG4gKiAtIHRydWU6IOyCrOyaqeyekOydmCDrj5nsnpHsnbTrgpggQVBJ66GcIOyVoOuLiOuplOydtOyFmOydhCDspJHsp4DtlaAg7IiYIOyeiOuLpC5cbiAqIC0gZmFsc2U6IOyVoOuLiOuplOydtOyFmOydtCDsp4Ttlokg7KSR7J28IOuVjOuKlCDsgqzsmqnsnpDsnZgg64+Z7J6R7J2064KYIEFQSeqwgCDsoIHsmqnrkJjsp4Ag7JWK64qU64ukPC9rbz5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbcm91bmQ9bnVsbF0gUm91bmRpbmcgdW5pdC4gRm9yIGV4YW1wbGUsIDAuMSByb3VuZHMgdG8gMC4xIGRlY2ltYWwgcG9pbnQoNi4xMjM0ID0+IDYuMSksIDUgcm91bmRzIHRvIDUgKDkzID0+IDk1KVxuICogW0RldGFpbHNdKGh0dHBzOi8vZ2l0aHViLmNvbS9uYXZlci9lZ2pzLWF4ZXMvd2lraS9yb3VuZC1vcHRpb24pPGtvPuuwmOyYrOumvCDri6jsnIQuIOyYiOulvCDrk6TslrQgMC4xIOydgCDshozsiKvsoJAgMC4xIOq5jOyngCDrsJjsmKzrprwoNi4xMjM0ID0+IDYuMSksIDUg64qUIDUg64uo7JyE66GcIOuwmOyYrOumvCg5MyA9PiA5NSkuXG4gKiBb7IOB7IS464K07JqpXShodHRwczovL2dpdGh1Yi5jb20vbmF2ZXIvZWdqcy1heGVzL3dpa2kvcm91bmQtb3B0aW9uKTwva28+XG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtuZXN0ZWQ9ZmFsc2VdIFdoZXRoZXIgdGhlIGV2ZW50IHByb3BhZ2F0ZXMgdG8gb3RoZXIgaW5zdGFuY2VzIHdoZW4gdGhlIGNvb3JkaW5hdGVzIHJlYWNoIHRoZSBlbmQgb2YgdGhlIG1vdmFibGUgYXJlYSA8a28+7KKM7ZGc6rCAIOydtOuPmSDqsIDriqXtlZwg7JiB7Jet7J2YIOuBneq5jOyngCDrj4Tri6ztlojsnYQg65WMIOuLpOuluCDsnbjsiqTthLTsiqTrk6TroZzsnZgg7J2067Kk7Yq4IOyghO2MjCDsl6zrtoA8L2tvPlxuICoqL1xuLyoqXG4gKiBBIG1vZHVsZSB1c2VkIHRvIGNoYW5nZSB0aGUgaW5mb3JtYXRpb24gb2YgdXNlciBhY3Rpb24gZW50ZXJlZCBieSB2YXJpb3VzIGlucHV0IGRldmljZXMgc3VjaCBhcyB0b3VjaCBzY3JlZW4gb3IgbW91c2UgaW50byB0aGUgbG9naWNhbCB2aXJ0dWFsIGNvb3JkaW5hdGVzLiBZb3UgY2FuIGVhc2lseSBjcmVhdGUgYSBVSSB0aGF0IHJlc3BvbmRzIHRvIHVzZXIgYWN0aW9ucy5cbiAqIEBrbyDthLDsuZgg7J6F66ClIOyepey5mOuCmCDrp4jsmrDsiqTsmYAg6rCZ7J2AIOuLpOyWke2VnCDsnoXroKUg7J6l7LmY66W8IO2Gte2VtCDsoITri6wg67Cb7J2AIOyCrOyaqeyekOydmCDrj5nsnpHsnYQg64W866as7KCB7J24IOqwgOyDgSDsooztkZzroZwg67OA6rK97ZWY64qUIOuqqOuTiOydtOuLpC4g7IKs7Jqp7J6QIOuPmeyekeyXkCDrsJjsnZHtlZjripQgVUnrpbwg7IaQ7Im96rKMIOunjOuTpOyImCDsnojri6QuXG4gKiBAZXh0ZW5kcyBlZy5Db21wb25lbnRcbiAqXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCBBeGlzT3B0aW9uPn0gYXhpcyBBeGlzIGluZm9ybWF0aW9uIG1hbmFnZWQgYnkgZWcuQXhlcy4gVGhlIGtleSBvZiB0aGUgYXhpcyBzcGVjaWZpZXMgdGhlIG5hbWUgdG8gdXNlIGFzIHRoZSBsb2dpY2FsIHZpcnR1YWwgY29vcmRpbmF0ZSBzeXN0ZW0uICA8a28+ZWcuQXhlc+qwgCDqtIDrpqztlZjripQg7LaVIOygleuztC4g7LaV7J2YIO2CpOuKlCDrhbzrpqzsoIHsnbgg6rCA7IOBIOyijO2RnOqzhOuhnCDsgqzsmqntlaAg7J2066aE7J2EIOyngOygle2VnOuLpC48L2tvPlxuICogQHBhcmFtIHtBeGVzT3B0aW9ufSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbiBvYmplY3Qgb2YgdGhlIGVnLkF4ZXMgbW9kdWxlPGtvPmVnLkF4ZXMg66qo65OI7J2YIOyYteyFmCDqsJ3ssrQ8L2tvPlxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgbnVtYmVyPn0gW3N0YXJ0UG9zPXt9XSBUaGUgY29vcmRpbmF0ZXMgdG8gYmUgbW92ZWQgd2hlbiBjcmVhdGluZyBhbiBpbnN0YW5jZS4gSXQgaXMgYXBwbGllZCB3aXRoIGhpZ2hlciBwcmlvcml0eSB0aGFuIHN0YXJ0UG9zIG9mIGF4aXNPcHRpb24uPGtvPuyduOyKpO2EtOyKpCDsg53shLHsi5wg7J2064+Z7ZWgIOyijO2RnCwgYXhpc09wdGlvbuydmCBzdGFydFBvc+uztOuLpCDrhpLsnYAg7Jqw7ISg7Iic7JyE66GcIOyggeyaqeuQnOuLpC48L2tvPlxuICpcbiAqIEBzdXBwb3J0IHtcImllXCI6IFwiMTArXCIsIFwiY2hcIiA6IFwibGF0ZXN0XCIsIFwiZmZcIiA6IFwibGF0ZXN0XCIsICBcInNmXCIgOiBcImxhdGVzdFwiLCBcImVkZ2VcIiA6IFwibGF0ZXN0XCIsIFwiaW9zXCIgOiBcIjcrXCIsIFwiYW5cIiA6IFwiMi4zKyAoZXhjZXB0IDMueClcIn1cbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogLy8gMS4gSW5pdGlhbGl6ZSBlZy5BeGVzXG4gKiBjb25zdCBheGVzID0gbmV3IGVnLkF4ZXMoe1xuICogIHNvbWV0aGluZzE6IHtcbiAqICAgIHJhbmdlOiBbMCwgMTUwXSxcbiAqICAgIGJvdW5jZTogNTBcbiAqICB9LFxuICogIHNvbWV0aGluZzI6IHtcbiAqICAgIHJhbmdlOiBbMCwgMjAwXSxcbiAqICAgIGJvdW5jZTogMTAwXG4gKiAgfSxcbiAqICBzb21ldGhpbmdOOiB7XG4gKiAgICByYW5nZTogWzEsIDEwXSxcbiAqICB9XG4gKiB9LCB7XG4gKiAgZGVjZWxlcmF0aW9uIDogMC4wMDI0XG4gKiB9KTtcbiAqXG4gKiAvLyAyLiBhdHRhY2ggZXZlbnQgaGFuZGxlclxuICogYXhlcy5vbih7XG4gKiAgXCJob2xkXCIgOiBmdW5jdGlvbihldnQpIHtcbiAqICB9LFxuICogIFwicmVsZWFzZVwiIDogZnVuY3Rpb24oZXZ0KSB7XG4gKiAgfSxcbiAqICBcImFuaW1hdGlvblN0YXJ0XCIgOiBmdW5jdGlvbihldnQpIHtcbiAqICB9LFxuICogIFwiYW5pbWF0aW9uRW5kXCIgOiBmdW5jdGlvbihldnQpIHtcbiAqICB9LFxuICogIFwiY2hhbmdlXCIgOiBmdW5jdGlvbihldnQpIHtcbiAqICB9XG4gKiB9KTtcbiAqXG4gKiAvLyAzLiBJbml0aWFsaXplIGlucHV0VHlwZXNcbiAqIGNvbnN0IHBhbklucHV0QXJlYSA9IG5ldyBlZy5BeGVzLlBhbklucHV0KFwiI2FyZWFcIiwge1xuICogIHNjYWxlOiBbMC41LCAxXVxuICogfSk7XG4gKiBjb25zdCBwYW5JbnB1dEhtb3ZlID0gbmV3IGVnLkF4ZXMuUGFuSW5wdXQoXCIjaG1vdmVcIik7XG4gKiBjb25zdCBwYW5JbnB1dFZtb3ZlID0gbmV3IGVnLkF4ZXMuUGFuSW5wdXQoXCIjdm1vdmVcIik7XG4gKiBjb25zdCBwaW5jaElucHV0QXJlYSA9IG5ldyBlZy5BeGVzLlBpbmNoSW5wdXQoXCIjYXJlYVwiLCB7XG4gKiAgc2NhbGU6IDEuNVxuICogfSk7XG4gKlxuICogLy8gNC4gQ29ubmVjdCBlZy5BeGVzIGFuZCBJbnB1dFR5cGVzXG4gKiAvLyBbUGFuSW5wdXRdIFdoZW4gdGhlIG1vdXNlIG9yIHRvdWNoc2NyZWVuIGlzIGRvd24gYW5kIG1vdmVkLlxuICogLy8gQ29ubmVjdCB0aGUgJ3NvbWV0aGluZzInIGF4aXMgdG8gdGhlIG1vdXNlIG9yIHRvdWNoc2NyZWVuIHggcG9zaXRpb24gYW5kXG4gKiAvLyBjb25uZWN0IHRoZSAnc29tZXRoaW5nTicgYXhpcyB0byB0aGUgbW91c2Ugb3IgdG91Y2hzY3JlZW4geSBwb3NpdGlvbi5cbiAqIGF4ZXMuY29ubmVjdChbXCJzb21ldGhpbmcyXCIsIFwic29tZXRoaW5nTlwiXSwgcGFuSW5wdXRBcmVhKTsgLy8gb3IgYXhlcy5jb25uZWN0KFwic29tZXRoaW5nMiBzb21ldGhpbmdOXCIsIHBhbklucHV0QXJlYSk7XG4gKlxuICogLy8gQ29ubmVjdCBvbmx5IG9uZSAnc29tZXRoaW5nMScgYXhpcyB0byB0aGUgbW91c2Ugb3IgdG91Y2hzY3JlZW4geCBwb3NpdGlvbi5cbiAqIGF4ZXMuY29ubmVjdChbXCJzb21ldGhpbmcxXCJdLCBwYW5JbnB1dEhtb3ZlKTsgLy8gb3IgYXhlcy5jb25uZWN0KFwic29tZXRoaW5nMVwiLCBwYW5JbnB1dEhtb3ZlKTtcbiAqXG4gKiAvLyBDb25uZWN0IG9ubHkgb25lICdzb21ldGhpbmcyJyBheGlzIHRvIHRoZSBtb3VzZSBvciB0b3VjaHNjcmVlbiB5IHBvc2l0aW9uLlxuICogYXhlcy5jb25uZWN0KFtcIlwiLCBcInNvbWV0aGluZzJcIl0sIHBhbklucHV0Vm1vdmUpOyAvLyBvciBheGVzLmNvbm5lY3QoXCIgc29tZXRoaW5nMlwiLCBwYW5JbnB1dFZtb3ZlKTtcbiAqXG4gKiAvLyBbUGluY2hJbnB1dF0gQ29ubmVjdCAnc29tZXRoaW5nMicgYXhpcyB3aGVuIHR3byBwb2ludGVycyBhcmUgbW92aW5nIHRvd2FyZCAoem9vbS1pbikgb3IgYXdheSBmcm9tIGVhY2ggb3RoZXIgKHpvb20tb3V0KS5cbiAqIGF4ZXMuY29ubmVjdChcInNvbWV0aGluZzJcIiwgcGluY2hJbnB1dEFyZWEpO1xuICogYGBgXG4gKi9cbnZhciBBeGVzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzJDEoQXhlcywgX3N1cGVyKTtcbiAgLyoqXG4gICAqXG4gICAqL1xuICBmdW5jdGlvbiBBeGVzKGF4aXMsIG9wdGlvbnMsIHN0YXJ0UG9zKSB7XG4gICAgaWYgKGF4aXMgPT09IHZvaWQgMCkge1xuICAgICAgYXhpcyA9IHt9O1xuICAgIH1cbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICAgIGlmIChzdGFydFBvcyA9PT0gdm9pZCAwKSB7XG4gICAgICBzdGFydFBvcyA9IHt9O1xuICAgIH1cbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgIF90aGlzLmF4aXMgPSBheGlzO1xuICAgIF90aGlzLl9pbnB1dHMgPSBbXTtcbiAgICBfdGhpcy5vcHRpb25zID0gX19hc3NpZ24oe1xuICAgICAgZWFzaW5nOiBmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4gMSAtIE1hdGgucG93KDEgLSB4LCAzKTtcbiAgICAgIH0sXG4gICAgICBpbnRlcnJ1cHRhYmxlOiB0cnVlLFxuICAgICAgbWF4aW11bUR1cmF0aW9uOiBJbmZpbml0eSxcbiAgICAgIG1pbmltdW1EdXJhdGlvbjogMCxcbiAgICAgIGRlY2VsZXJhdGlvbjogMC4wMDA2LFxuICAgICAgcm91bmQ6IG51bGwsXG4gICAgICBuZXN0ZWQ6IGZhbHNlXG4gICAgfSwgb3B0aW9ucyk7XG4gICAgT2JqZWN0LmtleXMoc3RhcnRQb3MpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgX3RoaXMuYXhpc1trZXldLnN0YXJ0UG9zID0gc3RhcnRQb3Nba2V5XTtcbiAgICB9KTtcbiAgICBfdGhpcy5pbnRlcnJ1cHRNYW5hZ2VyID0gbmV3IEludGVycnVwdE1hbmFnZXIoX3RoaXMub3B0aW9ucyk7XG4gICAgX3RoaXMuYXhpc01hbmFnZXIgPSBuZXcgQXhpc01hbmFnZXIoX3RoaXMuYXhpcyk7XG4gICAgX3RoaXMuZXZlbnRNYW5hZ2VyID0gbmV3IEV2ZW50TWFuYWdlcihfdGhpcyk7XG4gICAgX3RoaXMuYW5pbWF0aW9uTWFuYWdlciA9IG5ldyBFYXNpbmdNYW5hZ2VyKF90aGlzKTtcbiAgICBfdGhpcy5pbnB1dE9ic2VydmVyID0gbmV3IElucHV0T2JzZXJ2ZXIoX3RoaXMpO1xuICAgIF90aGlzLmV2ZW50TWFuYWdlci5zZXRBbmltYXRpb25NYW5hZ2VyKF90aGlzLmFuaW1hdGlvbk1hbmFnZXIpO1xuICAgIF90aGlzLmV2ZW50TWFuYWdlci50cmlnZ2VyQ2hhbmdlKF90aGlzLmF4aXNNYW5hZ2VyLmdldCgpKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgdmFyIF9fcHJvdG8gPSBBeGVzLnByb3RvdHlwZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwiaG9sZGluZ1wiLCB7XG4gICAgLyoqXG4gICAgICogQG5hbWUgQXhlcyNob2xkaW5nXG4gICAgICogQGRlc2MgUmV0dXJucyB0cnVlIGlmIGF0IGxlYXN0IG9uZSBpbnB1dCBpcyBpbiBwcm9ncmVzcy5cbiAgICAgKiBAa28g7J6F66Cl7J20IO2VmOuCmCDsnbTsg4Eg7KeE7ZaJIOykkeyduOyngCDsl6zrtoDrpbwg67CY7ZmY7ZWc64ukLlxuICAgICAqXG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIGNvbnN0IGF4ZXMgPSBuZXcgZWcuQXhlcyh7XG4gICAgICogIHg6IHtcbiAgICAgKiAgICByYW5nZTogWzAsIDEwMF0sXG4gICAgICogIH0sXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBheGVzLmhvbGRpbmdcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmV2ZW50TWFuYWdlci5ob2xkaW5nQ291bnQgPiAwO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICAvKipcbiAgICogQ29ubmVjdCB0aGUgYXhpcyBvZiBlZy5BeGVzIHRvIHRoZSBpbnB1dFR5cGUuXG4gICAqIEBrbyBlZy5BeGVz7J2YIOy2leqzvCBpbnB1dFR5cGXsnYQg7Jew6rKw7ZWc64ukXG4gICAqIEBwYXJhbSB7KFN0cmluZ1tdfFN0cmluZyl9IGF4ZXMgVGhlIG5hbWUgb2YgdGhlIGF4aXMgdG8gYXNzb2NpYXRlIHdpdGggaW5wdXRUeXBlIDxrbz5pbnB1dFR5cGXqs7wg7Jew6rKw7ZWgIOy2leydmCDsnbTrpoQ8L2tvPlxuICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRUeXBlIFRoZSBpbnB1dFR5cGUgaW5zdGFuY2UgdG8gYXNzb2NpYXRlIHdpdGggdGhlIGF4aXMgb2YgZWcuQXhlcyA8a28+ZWcuQXhlc+ydmCDstpXqs7wg7Jew6rKw7ZWgIGlucHV0VHlwZSDsnbjsiqTthLTsiqQ8L2tvPlxuICAgKiBAcmV0dXJuIHtlZy5BeGVzfSBBbiBpbnN0YW5jZSBvZiBhIG1vZHVsZSBpdHNlbGYgPGtvPuuqqOuTiCDsnpDsi6DsnZgg7J247Iqk7YS07IqkPC9rbz5cbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogY29uc3QgYXhlcyA9IG5ldyBlZy5BeGVzKHtcbiAgICogICBcInhcIjoge1xuICAgKiAgICAgIHJhbmdlOiBbMCwgMTAwXVxuICAgKiAgIH0sXG4gICAqICAgXCJ4T3RoZXJcIjoge1xuICAgKiAgICAgIHJhbmdlOiBbLTEwMCwgMTAwXVxuICAgKiAgIH1cbiAgICogfSk7XG4gICAqXG4gICAqIGF4ZXMuY29ubmVjdChcInhcIiwgbmV3IGVnLkF4ZXMuUGFuSW5wdXQoXCIjYXJlYTFcIikpXG4gICAqICAgIC5jb25uZWN0KFwieCB4T3RoZXJcIiwgbmV3IGVnLkF4ZXMuUGFuSW5wdXQoXCIjYXJlYTJcIikpXG4gICAqICAgIC5jb25uZWN0KFwiIHhPdGhlclwiLCBuZXcgZWcuQXhlcy5QYW5JbnB1dChcIiNhcmVhM1wiKSlcbiAgICogICAgLmNvbm5lY3QoW1wieFwiXSwgbmV3IGVnLkF4ZXMuUGFuSW5wdXQoXCIjYXJlYTRcIikpXG4gICAqICAgIC5jb25uZWN0KFtcInhPdGhlclwiLCBcInhcIl0sIG5ldyBlZy5BeGVzLlBhbklucHV0KFwiI2FyZWE1XCIpKVxuICAgKiAgICAuY29ubmVjdChbXCJcIiwgXCJ4T3RoZXJcIl0sIG5ldyBlZy5BeGVzLlBhbklucHV0KFwiI2FyZWE2XCIpKTtcbiAgICogYGBgXG4gICAqL1xuICBfX3Byb3RvLmNvbm5lY3QgPSBmdW5jdGlvbiAoYXhlcywgaW5wdXRUeXBlKSB7XG4gICAgdmFyIG1hcHBlZDtcbiAgICBpZiAodHlwZW9mIGF4ZXMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIG1hcHBlZCA9IGF4ZXMuc3BsaXQoXCIgXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYXBwZWQgPSBheGVzLmNvbmNhdCgpO1xuICAgIH1cbiAgICAvLyBjaGVjayBzYW1lIGluc3RhbmNlXG4gICAgaWYgKH50aGlzLl9pbnB1dHMuaW5kZXhPZihpbnB1dFR5cGUpKSB7XG4gICAgICB0aGlzLmRpc2Nvbm5lY3QoaW5wdXRUeXBlKTtcbiAgICB9XG4gICAgaW5wdXRUeXBlLm1hcEF4ZXMobWFwcGVkKTtcbiAgICBpbnB1dFR5cGUuY29ubmVjdCh0aGlzLmlucHV0T2JzZXJ2ZXIpO1xuICAgIHRoaXMuX2lucHV0cy5wdXNoKGlucHV0VHlwZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxuICAgKiBEaXNjb25uZWN0IHRoZSBheGlzIG9mIGVnLkF4ZXMgZnJvbSB0aGUgaW5wdXRUeXBlLlxuICAgKiBAa28gZWcuQXhlc+ydmCDstpXqs7wgaW5wdXRUeXBl7J2YIOyXsOqysOydhCDrgYrripTri6QuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbaW5wdXRUeXBlXSBBbiBpbnB1dFR5cGUgaW5zdGFuY2UgYXNzb2NpYXRlZCB3aXRoIHRoZSBheGlzIG9mIGVnLkF4ZXMgPGtvPmVnLkF4ZXPsnZgg7LaV6rO8IOyXsOqysO2VnCBpbnB1dFR5cGUg7J247Iqk7YS07IqkPC9rbz5cbiAgICogQHJldHVybiB7ZWcuQXhlc30gQW4gaW5zdGFuY2Ugb2YgYSBtb2R1bGUgaXRzZWxmIDxrbz7rqqjrk4gg7J6Q7Iug7J2YIOyduOyKpO2EtOyKpDwva28+XG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IGF4ZXMgPSBuZXcgZWcuQXhlcyh7XG4gICAqICAgXCJ4XCI6IHtcbiAgICogICAgICByYW5nZTogWzAsIDEwMF1cbiAgICogICB9LFxuICAgKiAgIFwieE90aGVyXCI6IHtcbiAgICogICAgICByYW5nZTogWy0xMDAsIDEwMF1cbiAgICogICB9XG4gICAqIH0pO1xuICAgKlxuICAgKiBjb25zdCBpbnB1dDEgPSBuZXcgZWcuQXhlcy5QYW5JbnB1dChcIiNhcmVhMVwiKTtcbiAgICogY29uc3QgaW5wdXQyID0gbmV3IGVnLkF4ZXMuUGFuSW5wdXQoXCIjYXJlYTJcIik7XG4gICAqIGNvbnN0IGlucHV0MyA9IG5ldyBlZy5BeGVzLlBhbklucHV0KFwiI2FyZWEzXCIpO1xuICAgKlxuICAgKiBheGVzLmNvbm5lY3QoXCJ4XCIsIGlucHV0MSk7XG4gICAqICAgIC5jb25uZWN0KFwieCB4T3RoZXJcIiwgaW5wdXQyKVxuICAgKiAgICAuY29ubmVjdChbXCJ4T3RoZXJcIiwgXCJ4XCJdLCBpbnB1dDMpO1xuICAgKlxuICAgKiBheGVzLmRpc2Nvbm5lY3QoaW5wdXQxKTsgLy8gZGlzY29ubmVjdHMgaW5wdXQxXG4gICAqIGF4ZXMuZGlzY29ubmVjdCgpOyAvLyBkaXNjb25uZWN0cyBhbGwgb2YgdGhlbVxuICAgKiBgYGBcbiAgICovXG4gIF9fcHJvdG8uZGlzY29ubmVjdCA9IGZ1bmN0aW9uIChpbnB1dFR5cGUpIHtcbiAgICBpZiAoaW5wdXRUeXBlKSB7XG4gICAgICB2YXIgaW5kZXggPSB0aGlzLl9pbnB1dHMuaW5kZXhPZihpbnB1dFR5cGUpO1xuICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgdGhpcy5faW5wdXRzW2luZGV4XS5kaXNjb25uZWN0KCk7XG4gICAgICAgIHRoaXMuX2lucHV0cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9pbnB1dHMuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gdi5kaXNjb25uZWN0KCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX2lucHV0cyA9IFtdO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgcG9zaXRpb24gb2YgdGhlIGNvb3JkaW5hdGVzLlxuICAgKiBAa28g7KKM7ZGc7J2YIO2YhOyerCDsnITsuZjrpbwg67CY7ZmY7ZWc64ukXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbYXhlc10gVGhlIG5hbWVzIG9mIHRoZSBheGlzIDxrbz7stpUg7J2066aE65OkPC9rbz5cbiAgICogQHJldHVybiB7T2JqZWN0LjxzdHJpbmcsIG51bWJlcj59IEF4aXMgY29vcmRpbmF0ZSBpbmZvcm1hdGlvbiA8a28+7LaVIOyijO2RnCDsoJXrs7Q8L2tvPlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBjb25zdCBheGVzID0gbmV3IGVnLkF4ZXMoe1xuICAgKiAgIFwieFwiOiB7XG4gICAqICAgICAgcmFuZ2U6IFswLCAxMDBdXG4gICAqICAgfSxcbiAgICogICBcInhPdGhlclwiOiB7XG4gICAqICAgICAgcmFuZ2U6IFstMTAwLCAxMDBdXG4gICAqICAgfSxcbiAgICogICAgXCJ6b29tXCI6IHtcbiAgICogICAgICByYW5nZTogWzUwLCAzMF1cbiAgICogICB9XG4gICAqIH0pO1xuICAgKlxuICAgKiBheGVzLmdldCgpOyAvLyB7XCJ4XCI6IDAsIFwieE90aGVyXCI6IC0xMDAsIFwiem9vbVwiOiA1MH1cbiAgICogYXhlcy5nZXQoW1wieFwiLCBcInpvb21cIl0pOyAvLyB7XCJ4XCI6IDAsIFwiem9vbVwiOiA1MH1cbiAgICogYGBgXG4gICAqL1xuICBfX3Byb3RvLmdldCA9IGZ1bmN0aW9uIChheGVzKSB7XG4gICAgcmV0dXJuIHRoaXMuYXhpc01hbmFnZXIuZ2V0KGF4ZXMpO1xuICB9O1xuICAvKipcbiAgICogTW92ZXMgYW4gYXhpcyB0byBzcGVjaWZpYyBjb29yZGluYXRlcy5cbiAgICogQGtvIOyijO2RnOulvCDsnbTrj5ntlZzri6QuXG4gICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsIG51bWJlcj59IHBvcyBUaGUgY29vcmRpbmF0ZSB0byBtb3ZlIHRvIDxrbz7snbTrj5ntlaAg7KKM7ZGcPC9rbz5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtkdXJhdGlvbj0wXSBEdXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uICh1bml0OiBtcykgPGtvPuyVoOuLiOuplOydtOyFmCDsp4Ttlokg7Iuc6rCEKOuLqOychDogbXMpPC9rbz5cbiAgICogQHJldHVybiB7ZWcuQXhlc30gQW4gaW5zdGFuY2Ugb2YgYSBtb2R1bGUgaXRzZWxmIDxrbz7rqqjrk4gg7J6Q7Iug7J2YIOyduOyKpO2EtOyKpDwva28+XG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IGF4ZXMgPSBuZXcgZWcuQXhlcyh7XG4gICAqICAgXCJ4XCI6IHtcbiAgICogICAgICByYW5nZTogWzAsIDEwMF1cbiAgICogICB9LFxuICAgKiAgIFwieE90aGVyXCI6IHtcbiAgICogICAgICByYW5nZTogWy0xMDAsIDEwMF1cbiAgICogICB9LFxuICAgKiAgICBcInpvb21cIjoge1xuICAgKiAgICAgIHJhbmdlOiBbNTAsIDMwXVxuICAgKiAgIH1cbiAgICogfSk7XG4gICAqXG4gICAqIGF4ZXMuc2V0VG8oe1wieFwiOiAzMCwgXCJ6b29tXCI6IDYwfSk7XG4gICAqIGF4ZXMuZ2V0KCk7IC8vIHtcInhcIjogMzAsIFwieE90aGVyXCI6IC0xMDAsIFwiem9vbVwiOiA2MH1cbiAgICpcbiAgICogYXhlcy5zZXRUbyh7XCJ4XCI6IDEwMCwgXCJ4T3RoZXJcIjogNjB9LCAxMDAwKTsgLy8gYW5pbWF0YXRpb25cbiAgICpcbiAgICogLy8gYWZ0ZXIgMTAwMCBtc1xuICAgKiBheGVzLmdldCgpOyAvLyB7XCJ4XCI6IDEwMCwgXCJ4T3RoZXJcIjogNjAsIFwiem9vbVwiOiA2MH1cbiAgICogYGBgXG4gICAqL1xuICBfX3Byb3RvLnNldFRvID0gZnVuY3Rpb24gKHBvcywgZHVyYXRpb24pIHtcbiAgICBpZiAoZHVyYXRpb24gPT09IHZvaWQgMCkge1xuICAgICAgZHVyYXRpb24gPSAwO1xuICAgIH1cbiAgICB0aGlzLmFuaW1hdGlvbk1hbmFnZXIuc2V0VG8ocG9zLCBkdXJhdGlvbik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxuICAgKiBNb3ZlcyBhbiBheGlzIGZyb20gdGhlIGN1cnJlbnQgY29vcmRpbmF0ZXMgdG8gc3BlY2lmaWMgY29vcmRpbmF0ZXMuXG4gICAqIEBrbyDtmITsnqwg7KKM7ZGc66W8IOq4sOykgOycvOuhnCDsooztkZzrpbwg7J2064+Z7ZWc64ukLlxuICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCBudW1iZXI+fSBwb3MgVGhlIGNvb3JkaW5hdGUgdG8gbW92ZSB0byA8a28+7J2064+Z7ZWgIOyijO2RnDwva28+XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZHVyYXRpb249MF0gRHVyYXRpb24gb2YgdGhlIGFuaW1hdGlvbiAodW5pdDogbXMpIDxrbz7slaDri4jrqZTsnbTshZgg7KeE7ZaJIOyLnOqwhCjri6jsnIQ6IG1zKTwva28+XG4gICAqIEByZXR1cm4ge2VnLkF4ZXN9IEFuIGluc3RhbmNlIG9mIGEgbW9kdWxlIGl0c2VsZiA8a28+66qo65OIIOyekOyLoOydmCDsnbjsiqTthLTsiqQ8L2tvPlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBjb25zdCBheGVzID0gbmV3IGVnLkF4ZXMoe1xuICAgKiAgIFwieFwiOiB7XG4gICAqICAgICAgcmFuZ2U6IFswLCAxMDBdXG4gICAqICAgfSxcbiAgICogICBcInhPdGhlclwiOiB7XG4gICAqICAgICAgcmFuZ2U6IFstMTAwLCAxMDBdXG4gICAqICAgfSxcbiAgICogICAgXCJ6b29tXCI6IHtcbiAgICogICAgICByYW5nZTogWzUwLCAzMF1cbiAgICogICB9XG4gICAqIH0pO1xuICAgKlxuICAgKiBheGVzLnNldEJ5KHtcInhcIjogMzAsIFwiem9vbVwiOiAxMH0pO1xuICAgKiBheGVzLmdldCgpOyAvLyB7XCJ4XCI6IDMwLCBcInhPdGhlclwiOiAtMTAwLCBcInpvb21cIjogNjB9XG4gICAqXG4gICAqIGF4ZXMuc2V0Qnkoe1wieFwiOiA3MCwgXCJ4T3RoZXJcIjogNjB9LCAxMDAwKTsgLy8gYW5pbWF0YXRpb25cbiAgICpcbiAgICogLy8gYWZ0ZXIgMTAwMCBtc1xuICAgKiBheGVzLmdldCgpOyAvLyB7XCJ4XCI6IDEwMCwgXCJ4T3RoZXJcIjogLTQwLCBcInpvb21cIjogNjB9XG4gICAqIGBgYFxuICAgKi9cbiAgX19wcm90by5zZXRCeSA9IGZ1bmN0aW9uIChwb3MsIGR1cmF0aW9uKSB7XG4gICAgaWYgKGR1cmF0aW9uID09PSB2b2lkIDApIHtcbiAgICAgIGR1cmF0aW9uID0gMDtcbiAgICB9XG4gICAgdGhpcy5hbmltYXRpb25NYW5hZ2VyLnNldEJ5KHBvcywgZHVyYXRpb24pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogQ2hhbmdlIHRoZSBvcHRpb25zIG9mIEF4ZXMgaW5zdGFuY2UuXG4gICAqIEBrbyDsnbjsiqTthLTsiqTsnZgg7Ji17IWY7J2EIOuzgOqyve2VnOuLpC5cbiAgICogQHBhcmFtIHtBeGVzT3B0aW9ufSBvcHRpb25zIEF4ZXMgb3B0aW9ucyB0byBjaGFuZ2UgPGtvPuuzgOqyve2VoCDsmLXshZgg66qp66GdPC9rbz5cbiAgICogQHJldHVybiB7ZWcuQXhlc30gQW4gaW5zdGFuY2Ugb2YgYSBtb2R1bGUgaXRzZWxmIDxrbz7rqqjrk4gg7J6Q7Iug7J2YIOyduOyKpO2EtOyKpDwva28+XG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IGF4ZXMgPSBuZXcgZWcuQXhlcyh7XG4gICAqICAgXCJ4XCI6IHtcbiAgICogICAgICByYW5nZTogWzAsIDEwMF1cbiAgICogICB9LFxuICAgKiB9LCB7XG4gICAqICAgcm91bmQ6IDEwLFxuICAgKiB9KTtcbiAgICpcbiAgICogYXhlcy5zZXRUbyh7XCJ4XCI6IDQ4fSk7XG4gICAqIGF4ZXMuZ2V0KCk7IC8vIHtcInhcIjogNTB9XG4gICAqXG4gICAqIGF4ZXMuc2V0T3B0aW9ucyh7XG4gICAqICAgcm91bmQ6IDEsXG4gICAqIH0pO1xuICAgKlxuICAgKiBheGVzLnNldFRvKHtcInhcIjogNDh9KTtcbiAgICogYXhlcy5nZXQoKTsgLy8ge1wieFwiOiA0OH1cbiAgICogYGBgXG4gICAqL1xuICBfX3Byb3RvLnNldE9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICB0aGlzLmFuaW1hdGlvbk1hbmFnZXIuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXG4gICAqIENoYW5nZSB0aGUgaW5mb3JtYXRpb24gb2YgYW4gZXhpc3RpbmcgYXhpcy5cbiAgICogQGtvIOyhtOyerO2VmOuKlCDstpXsnZgg7KCV67O066W8IOuzgOqyve2VnOuLpC5cbiAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgQXhpc09wdGlvbj59IGF4aXMgQXhpcyBvcHRpb25zIHRvIGNoYW5nZSA8a28+67OA6rK97ZWgIOy2leydmCDsoJXrs7Q8L2tvPlxuICAgKiBAcmV0dXJuIHtlZy5BeGVzfSBBbiBpbnN0YW5jZSBvZiBhIG1vZHVsZSBpdHNlbGYgPGtvPuuqqOuTiCDsnpDsi6DsnZgg7J247Iqk7YS07IqkPC9rbz5cbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogY29uc3QgYXhlcyA9IG5ldyBlZy5BeGVzKHtcbiAgICogICBcInhcIjoge1xuICAgKiAgICAgIHJhbmdlOiBbMCwgMTAwXVxuICAgKiAgIH0sXG4gICAqIH0pO1xuICAgKlxuICAgKiBheGVzLnNldFRvKHtcInhcIjogMTUwfSk7XG4gICAqIGF4ZXMuZ2V0KCk7IC8vIHtcInhcIjogMTAwfVxuICAgKlxuICAgKiBheGVzLnNldEF4aXMoe1xuICAgKiAgIFwieFwiOiB7XG4gICAqICAgICAgcmFuZ2U6IFswLCAyMDBdXG4gICAqICAgfSxcbiAgICogfSk7XG4gICAqXG4gICAqIGF4ZXMuc2V0VG8oe1wieFwiOiAxNTB9KTtcbiAgICogYXhlcy5nZXQoKTsgLy8ge1wieFwiOiAxNTB9XG4gICAqIGBgYFxuICAgKi9cbiAgX19wcm90by5zZXRBeGlzID0gZnVuY3Rpb24gKGF4aXMpIHtcbiAgICB0aGlzLmF4aXNNYW5hZ2VyLnNldEF4aXMoYXhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxuICAgKiBTdG9wIGFuIGFuaW1hdGlvbiBpbiBwcm9ncmVzcy5cbiAgICogQGtvIOyerOyDnSDspJHsnbgg7JWg64uI66mU7J207IWY7J2EIOygleyngO2VnOuLpC5cbiAgICogQHJldHVybiB7ZWcuQXhlc30gQW4gaW5zdGFuY2Ugb2YgYSBtb2R1bGUgaXRzZWxmIDxrbz7rqqjrk4gg7J6Q7Iug7J2YIOyduOyKpO2EtOyKpDwva28+XG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IGF4ZXMgPSBuZXcgZWcuQXhlcyh7XG4gICAqICAgXCJ4XCI6IHtcbiAgICogICAgICByYW5nZTogWzAsIDEwMF1cbiAgICogICB9LFxuICAgKiB9KTtcbiAgICpcbiAgICogYXhlcy5zZXRUbyh7XCJ4XCI6IDEwfSwgMTAwMCk7IC8vIHN0YXJ0IGFuaW1hdGF0aW9uXG4gICAqXG4gICAqIC8vIGFmdGVyIDUwMCBtc1xuICAgKiBheGVzLnN0b3BBbmltYXRpb24oKTsgLy8gc3RvcCBhbmltYXRpb24gZHVyaW5nIG1vdmVtZW50LlxuICAgKiBgYGBcbiAgICovXG4gIF9fcHJvdG8uc3RvcEFuaW1hdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmFuaW1hdGlvbk1hbmFnZXIuc3RvcEFuaW1hdGlvbigpO1xuICAgIHRoaXMuYW5pbWF0aW9uTWFuYWdlci5maW5pc2goZmFsc2UpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogQ2hhbmdlIHRoZSBkZXN0aW5hdGlvbiBvZiBhbiBhbmltYXRpb24gaW4gcHJvZ3Jlc3MuXG4gICAqIEBrbyDsnqzsg50g7KSR7J24IOyVoOuLiOuplOydtOyFmOydmCDrqqnsoIHsp4DsmYAg7KeE7ZaJIOyLnOqwhOydhCDrs4Dqsr3tlZzri6QuXG4gICAqIEBwYXJhbSB7VXBkYXRlQW5pbWF0aW9uT3B0aW9ufSBwb3MgVGhlIGNvb3JkaW5hdGUgdG8gbW92ZSB0byA8a28+7J2064+Z7ZWgIOyijO2RnDwva28+XG4gICAqIEByZXR1cm4ge2VnLkF4ZXN9IEFuIGluc3RhbmNlIG9mIGEgbW9kdWxlIGl0c2VsZiA8a28+66qo65OIIOyekOyLoOydmCDsnbjsiqTthLTsiqQ8L2tvPlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBjb25zdCBheGVzID0gbmV3IGVnLkF4ZXMoe1xuICAgKiAgIFwieFwiOiB7XG4gICAqICAgICAgcmFuZ2U6IFswLCAyMDBdXG4gICAqICAgfSxcbiAgICogICBcInlcIjoge1xuICAgKiAgICAgIHJhbmdlOiBbMCwgMjAwXVxuICAgKiAgIH1cbiAgICogfSk7XG4gICAqXG4gICAqIGF4ZXMuc2V0VG8oe1wieFwiOiA1MCwgXCJ5XCI6IDUwfSwgMTAwMCk7IC8vIHRyaWdnZXIgYW5pbWF0aW9uIGJ5IHNldFRvXG4gICAqXG4gICAqIC8vIGFmdGVyIDUwMCBtc1xuICAgKiBheGVzLnVwZGF0ZUFuaW1hdGlvbih7ZGVzdFBvczoge1wieFwiOiAxMDAsIFwieVwiOiAxMDB9fSk7IC8vIGFuaW1hdGlvbiB3aWxsIGVuZCBhZnRlciA1MDAgbXMsIGF0IHtcInhcIjogMTAwLCBcInlcIjogMTAwfVxuICAgKlxuICAgKiAvLyBhZnRlciA1MDAgbXNcbiAgICogYXhlcy5zZXRUbyh7XCJ4XCI6IDUwLCBcInlcIjogNTB9LCAxMDAwKTsgLy8gdHJpZ2dlciBhbmltYXRpb24gYnkgc2V0VG9cbiAgICpcbiAgICogLy8gYWZ0ZXIgNzAwIG1zXG4gICAqIGF4ZXMudXBkYXRlQW5pbWF0aW9uKHtkZXN0UG9zOiB7XCJ4XCI6IDEwMCwgXCJ5XCI6IDEwMH0sIGR1cmF0aW9uOiAxNTAwLCByZXN0YXJ0OiB0cnVlfSk7IC8vIHRoaXMgd29ya3Mgc2FtZSBhcyBheGVzLnNldFRvKHtcInhcIjogMTAwLCBcInlcIjogMTAwfSwgODAwKSBzaW5jZSByZXN0YXJ0IGlzIHRydWUuXG4gICAqIGBgYFxuICAgKi9cbiAgX19wcm90by51cGRhdGVBbmltYXRpb24gPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHRoaXMuYW5pbWF0aW9uTWFuYWdlci51cGRhdGVBbmltYXRpb24ob3B0aW9ucyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlcmUgaXMgYSBjb29yZGluYXRlIGluIHRoZSBib3VuY2UgYXJlYSBvZiDigIvigIt0aGUgdGFyZ2V0IGF4aXMuXG4gICAqIEBrbyDrjIDsg4Eg7LaVIOykkSBib3VuY2XsmIHsl63sl5Ag7KKM7ZGc6rCAIOyhtOyerO2VmOuKlOyngOulvCDrsJjtmZjtlZzri6RcbiAgICogQHBhcmFtIHtPYmplY3R9IFtheGVzXSBUaGUgbmFtZXMgb2YgdGhlIGF4aXMgPGtvPuy2lSDsnbTrpoTrk6Q8L2tvPlxuICAgKiBAcmV0dXJuIHtCb29sZW59IFdoZXRoZXIgdGhlIGJvdW5jZSBhcmVhIGV4aXN0cy4gPGtvPmJvdW5jZSDsmIHsl60g7KG07J6sIOyXrOu2gDwva28+XG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IGF4ZXMgPSBuZXcgZWcuQXhlcyh7XG4gICAqICAgXCJ4XCI6IHtcbiAgICogICAgICByYW5nZTogWzAsIDEwMF1cbiAgICogICB9LFxuICAgKiAgIFwieE90aGVyXCI6IHtcbiAgICogICAgICByYW5nZTogWy0xMDAsIDEwMF1cbiAgICogICB9LFxuICAgKiAgICBcInpvb21cIjoge1xuICAgKiAgICAgIHJhbmdlOiBbNTAsIDMwXVxuICAgKiAgIH1cbiAgICogfSk7XG4gICAqXG4gICAqIGF4ZXMuaXNCb3VuY2VBcmVhKFtcInhcIl0pO1xuICAgKiBheGVzLmlzQm91bmNlQXJlYShbXCJ4XCIsIFwiem9vbVwiXSk7XG4gICAqIGF4ZXMuaXNCb3VuY2VBcmVhKCk7XG4gICAqIGBgYFxuICAgKi9cbiAgX19wcm90by5pc0JvdW5jZUFyZWEgPSBmdW5jdGlvbiAoYXhlcykge1xuICAgIHJldHVybiB0aGlzLmF4aXNNYW5hZ2VyLmlzT3V0c2lkZShheGVzKTtcbiAgfTtcbiAgLyoqXG4gICAqIERlc3Ryb3lzIHByb3BlcnRpZXMsIGFuZCBldmVudHMgdXNlZCBpbiBhIG1vZHVsZSBhbmQgZGlzY29ubmVjdCBhbGwgY29ubmVjdGlvbnMgdG8gaW5wdXRUeXBlcy5cbiAgICogQGtvIOuqqOuTiOyXkCDsgqzsmqntlZwg7IaN7ISxLCDsnbTrsqTtirjrpbwg7ZW07KCc7ZWc64ukLiDrqqjrk6AgaW5wdXRUeXBl6rO87J2YIOyXsOqysOydhCDrgYrripTri6QuXG4gICAqL1xuICBfX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgdGhpcy5ldmVudE1hbmFnZXIuZGVzdHJveSgpO1xuICB9O1xuICAvKipcbiAgICogQG5hbWUgVkVSU0lPTlxuICAgKiBAZGVzYyBWZXJzaW9uIGluZm8gc3RyaW5nXG4gICAqIEBrbyDrsoTsoITsoJXrs7Qg66y47J6Q7Je0XG4gICAqXG4gICAqIEBjb25zdGFudFxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBlZy5BeGVzLlZFUlNJT047ICAvLyBleCkgMy4zLjNcbiAgICogYGBgXG4gICAqL1xuICBBeGVzLlZFUlNJT04gPSBcIjMuOS4xXCI7XG4gIC8qIGVzbGludC1lbmFibGUgKi9cbiAgLyoqXG4gICAqIEBuYW1lIFRSQU5TRk9STVxuICAgKiBAZGVzYyBSZXR1cm5zIHRoZSB0cmFuc2Zvcm0gYXR0cmlidXRlIHdpdGggQ1NTIHZlbmRvciBwcmVmaXhlcy5cbiAgICogQGtvIENTUyB2ZW5kb3IgcHJlZml4ZXPrpbwg67aZ7J24IHRyYW5zZm9ybSDsho3shLHsnYQg67CY7ZmY7ZWc64ukLlxuICAgKlxuICAgKiBAY29uc3RhbnRcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogZWcuQXhlcy5UUkFOU0ZPUk07IC8vIFwidHJhbnNmb3JtXCIgb3IgXCJ3ZWJraXRUcmFuc2Zvcm1cIlxuICAgKiBgYGBcbiAgICovXG4gIEF4ZXMuVFJBTlNGT1JNID0gVFJBTlNGT1JNO1xuICAvKipcbiAgICogQG5hbWUgRElSRUNUSU9OX05PTkVcbiAgICogQGNvbnN0YW50XG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBBeGVzLkRJUkVDVElPTl9OT05FID0gRElSRUNUSU9OX05PTkU7XG4gIC8qKlxuICAgKiBAbmFtZSBESVJFQ1RJT05fTEVGVFxuICAgKiBAY29uc3RhbnRcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIEF4ZXMuRElSRUNUSU9OX0xFRlQgPSBESVJFQ1RJT05fTEVGVDtcbiAgLyoqXG4gICAqIEBuYW1lIERJUkVDVElPTl9SSUdIVFxuICAgKiBAY29uc3RhbnRcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIEF4ZXMuRElSRUNUSU9OX1JJR0hUID0gRElSRUNUSU9OX1JJR0hUO1xuICAvKipcbiAgICogQG5hbWUgRElSRUNUSU9OX1VQXG4gICAqIEBjb25zdGFudFxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgQXhlcy5ESVJFQ1RJT05fVVAgPSBESVJFQ1RJT05fVVA7XG4gIC8qKlxuICAgKiBAbmFtZSBESVJFQ1RJT05fRE9XTlxuICAgKiBAY29uc3RhbnRcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIEF4ZXMuRElSRUNUSU9OX0RPV04gPSBESVJFQ1RJT05fRE9XTjtcbiAgLyoqXG4gICAqIEBuYW1lIERJUkVDVElPTl9IT1JJWk9OVEFMXG4gICAqIEBjb25zdGFudFxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgQXhlcy5ESVJFQ1RJT05fSE9SSVpPTlRBTCA9IERJUkVDVElPTl9IT1JJWk9OVEFMO1xuICAvKipcbiAgICogQG5hbWUgRElSRUNUSU9OX1ZFUlRJQ0FMXG4gICAqIEBjb25zdGFudFxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgQXhlcy5ESVJFQ1RJT05fVkVSVElDQUwgPSBESVJFQ1RJT05fVkVSVElDQUw7XG4gIC8qKlxuICAgKiBAbmFtZSBESVJFQ1RJT05fQUxMXG4gICAqIEBjb25zdGFudFxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgQXhlcy5ESVJFQ1RJT05fQUxMID0gRElSRUNUSU9OX0FMTDtcbiAgX19kZWNvcmF0ZShbQ29tcHV0ZWRdLCBBeGVzLnByb3RvdHlwZSwgXCJob2xkaW5nXCIsIG51bGwpO1xuICBBeGVzID0gX19kZWNvcmF0ZShbUmVhY3RpdmVTdWJzY3JpYmVdLCBBeGVzKTtcbiAgcmV0dXJuIEF4ZXM7XG59KENvbXBvbmVudCk7XG5cbi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgTkFWRVIgQ29ycC5cbiAqIGVnanMgcHJvamVjdHMgYXJlIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG4vLyBnZXQgdXNlcidzIGRpcmVjdGlvblxudmFyIGdldERpcmVjdGlvbkJ5QW5nbGUgPSBmdW5jdGlvbiAoYW5nbGUsIHRocmVzaG9sZEFuZ2xlKSB7XG4gIGlmICh0aHJlc2hvbGRBbmdsZSA8IDAgfHwgdGhyZXNob2xkQW5nbGUgPiA5MCkge1xuICAgIHJldHVybiBESVJFQ1RJT05fTk9ORTtcbiAgfVxuICB2YXIgdG9BbmdsZSA9IE1hdGguYWJzKGFuZ2xlKTtcbiAgcmV0dXJuIHRvQW5nbGUgPiB0aHJlc2hvbGRBbmdsZSAmJiB0b0FuZ2xlIDwgMTgwIC0gdGhyZXNob2xkQW5nbGUgPyBESVJFQ1RJT05fVkVSVElDQUwgOiBESVJFQ1RJT05fSE9SSVpPTlRBTDtcbn07XG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFBhbklucHV0T3B0aW9uIFRoZSBvcHRpb24gb2JqZWN0IG9mIHRoZSBlZy5BeGVzLlBhbklucHV0IG1vZHVsZS5cbiAqIEBrbyBlZy5BeGVzLlBhbklucHV0IOuqqOuTiOydmCDsmLXshZgg6rCd7LK0XG4gKiBAcGFyYW0ge1N0cmluZ1tdfSBbaW5wdXRUeXBlPVtcInRvdWNoXCIsIFwibW91c2VcIiwgXCJwb2ludGVyXCJdXSBUeXBlcyBvZiBpbnB1dCBkZXZpY2VzXG4gKiAtIHRvdWNoOiBUb3VjaCBzY3JlZW5cbiAqIC0gbW91c2U6IE1vdXNlXG4gKiAtIHBvaW50ZXI6IE1vdXNlIGFuZCB0b3VjaCA8a28+7J6F66ClIOyepey5mCDsooXrpZhcbiAqIC0gdG91Y2g6IO2EsOy5mCDsnoXroKUg7J6l7LmYXG4gKiAtIG1vdXNlOiDrp4jsmrDsiqRcbiAqIC0gcG9pbnRlcjog66eI7Jqw7IqkIOuwjyDthLDsuZg8L2tvPlxuICogQHBhcmFtIHtTdHJpbmdbXX0gW2lucHV0S2V5PVtcImFueVwiXV0gTGlzdCBvZiBrZXkgY29tYmluYXRpb25zIHRvIGFsbG93IGlucHV0XG4gKiAtIGFueTogYW55IGtleVxuICogLSBzaGlmdDogc2hpZnQga2V5XG4gKiAtIGN0cmw6IGN0cmwga2V5IGFuZCBwaW5jaCBnZXN0dXJlIG9uIHRoZSB0cmFja3BhZFxuICogLSBhbHQ6IGFsdCBrZXlcbiAqIC0gbWV0YTogbWV0YSBrZXlcbiAqIC0gbm9uZTogbm9uZSBvZiB0aGVzZSBrZXlzIGFyZSBwcmVzc2VkIDxrbz7snoXroKXsnYQg7ZeI7Jqp7ZWgIO2CpCDsobDtlakg66qp66GdXG4gKiAtIGFueTog7JWE66y0IO2CpFxuICogLSBzaGlmdDogc2hpZnQg7YKkXG4gKiAtIGN0cmw6IGN0cmwg7YKkIOuwjyDtirjrnpntjKjrk5zsnZggcGluY2gg7KCc7Iqk7LOQXG4gKiAtIGFsdDogYWx0IO2CpFxuICogLSBtZXRhOiBtZXRhIO2CpFxuICogLSBub25lOiDslYTrrLQg7YKk64+EIOuIjOumrOyngCDslYrsnYAg7IOB7YOcIDwva28+XG4gKiBAcGFyYW0ge1N0cmluZ1tdfSBbaW5wdXRCdXR0b249W1wibGVmdFwiXV0gTGlzdCBvZiBidXR0b25zIHRvIGFsbG93IGlucHV0XG4gKiAtIGxlZnQ6IExlZnQgbW91c2UgYnV0dG9uIGFuZCBub3JtYWwgdG91Y2hcbiAqIC0gbWlkZGxlOiBNb3VzZSB3aGVlbCBwcmVzc1xuICogLSByaWdodDogUmlnaHQgbW91c2UgYnV0dG9uIDxrbz7snoXroKXsnYQg7ZeI7Jqp7ZWgIOuyhO2KvCDrqqnroZ1cbiAqIC0gbGVmdDog66eI7Jqw7IqkIOyZvOyqvSDrsoTtirxcbiAqIC0gbWlkZGxlOiDrp4jsmrDsiqQg7ZygIOuIjOumvFxuICogLSByaWdodDog66eI7Jqw7IqkIOyYpOuluOyqvSDrsoTtirwgPC9rbz5cbiAqIEBwYXJhbSB7TnVtYmVyW119IFtzY2FsZV0gQ29vcmRpbmF0ZSBzY2FsZSB0aGF0IGEgdXNlciBjYW4gbW92ZTxrbz7sgqzsmqnsnpDsnZgg64+Z7J6R7Jy866GcIOydtOuPme2VmOuKlCDsooztkZzsnZgg67Cw7JyoPC9rbz5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbc2NhbGVbMF09MV0gaG9yaXpvbnRhbCBheGlzIHNjYWxlIDxrbz7siJjtj4nstpUg67Cw7JyoPC9rbz5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbc2NhbGVbMV09MV0gdmVydGljYWwgYXhpcyBzY2FsZSA8a28+7IiY7KeB7LaVIOuwsOycqDwva28+XG4gKiBAcGFyYW0ge051bWJlcn0gW3RocmVzaG9sZEFuZ2xlPTQ1XSBUaGUgdGhyZXNob2xkIHZhbHVlIHRoYXQgZGV0ZXJtaW5lcyB3aGV0aGVyIHVzZXIgYWN0aW9uIGlzIGhvcml6b250YWwgb3IgdmVydGljYWwgKDB+OTApIDxrbz7sgqzsmqnsnpDsnZgg64+Z7J6R7J20IOqwgOuhnCDrsKntlqXsnbjsp4Ag7IS466GcIOuwqe2WpeyduOyngCDtjJDri6jtlZjripQg6riw7KSAIOqwgeuPhCgwfjkwKTwva28+XG4gKiBAcGFyYW0ge051bWJlcn0gW3RocmVzaG9sZD0wXSBNaW5pbWFsIHBhbiBkaXN0YW5jZSByZXF1aXJlZCBiZWZvcmUgcmVjb2duaXppbmcgPGtvPuyCrOyaqeyekOydmCBQYW4g64+Z7J6R7J2EIOyduOyLne2VmOq4sCDsnITtlbTsgrAg7LWc7IaM7ZWc7J2YIOqxsOumrDwva28+XG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtwcmV2ZW50Q2xpY2tPbkRyYWc9ZmFsc2VdIFdoZXRoZXIgdG8gY2FuY2VsIHRoZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL0VsZW1lbnQvY2xpY2tfZXZlbnQgY2xpY2t9IGV2ZW50IHdoZW4gdGhlIHVzZXIgZmluaXNoZXMgZHJhZ2dpbmcgbW9yZSB0aGFuIDEgcGl4ZWwgPGtvPuyCrOyaqeyekOqwgCAx7ZS97IWAIOydtOyDgSDrk5zrnpjqt7jrpbwg66eI7LOk7J2EIOuVjCB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcva28vZG9jcy9XZWIvQVBJL0VsZW1lbnQvY2xpY2tfZXZlbnQgY2xpY2t9IOydtOuypO2KuCDst6jshowg7Jes67aAPC9rbz5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3ByZXZlbnREZWZhdWx0T25EcmFnPWZhbHNlXSBXaGV0aGVyIHRvIHVzZSB0aGUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2tvL2RvY3MvV2ViL0FQSS9FdmVudC9wcmV2ZW50RGVmYXVsdCBwcmV2ZW50RGVmYXVsdH0gd2hlbiB0aGUgdXNlciBzdGFydHMgZHJhZ2dpbmcgPGtvPuyCrOyaqeyekOqwgCDrk5zrnpjqt7jrpbwg7Iuc7J6R7ZWgIOuVjCB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcva28vZG9jcy9XZWIvQVBJL0V2ZW50L3ByZXZlbnREZWZhdWx0IHByZXZlbnREZWZhdWx0fSDsi6Ttlokg7Jes67aAPC9rbz5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbaU9TRWRnZVN3aXBlVGhyZXNob2xkPTMwXSBBcmVhIChweCkgdGhhdCBjYW4gZ28gdG8gdGhlIG5leHQgcGFnZSB3aGVuIHN3aXBpbmcgdGhlIHJpZ2h0IGVkZ2UgaW4gaU9TIHNhZmFyaSA8a28+aU9TIFNhZmFyaeyXkOyEnCDsmKTrpbjsqr0g7Jej7KeA66W8IOyKpOyZgOydtO2UhCDtlZjripQg6rK97JqwIOuLpOydjCDtjpjsnbTsp4DroZwg64SY7Ja06rCIIOyImCDsnojripQg7JiB7JetKHB4KTwva28+XG4gKiBAcGFyYW0ge1N0cmluZ30gW3RvdWNoQWN0aW9uPW51bGxdIFZhbHVlIHRoYXQgb3ZlcnJpZGVzIHRoZSBlbGVtZW50J3MgXCJ0b3VjaC1hY3Rpb25cIiBjc3MgcHJvcGVydHkuIElmIHNldCB0byBudWxsLCBpdCBpcyBhdXRvbWF0aWNhbGx5IHNldCB0byBwcmV2ZW50IHNjcm9sbGluZyBpbiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBjb25uZWN0ZWQgYXhpcy4gPGtvPuyXmOumrOuovO2KuOydmCBcInRvdWNoLWFjdGlvblwiIENTUyDsho3shLHsnYQg642u7Ja07JOw64qUIOqwki4g66eM7JW9IG51bGzroZwg7ISk7KCV65CcIOqyveyasCwg7Jew6rKw65CcIOy2lSDrsKntlqXsnLzroZzsnZgg7Iqk7YGs66Gk7J2EIOuwqeyngO2VmOqyjOuBlCDsnpDrj5nsnLzroZwg7ISk7KCV65Cc64ukLjwva28+XG4gKiovXG4vKipcbiAqIEEgbW9kdWxlIHRoYXQgcGFzc2VzIHRoZSBhbW91bnQgb2YgY2hhbmdlIHRvIGVnLkF4ZXMgd2hlbiB0aGUgbW91c2Ugb3IgdG91Y2hzY3JlZW4gaXMgZG93biBhbmQgbW92ZWQuIHVzZSBsZXNzIHRoYW4gdHdvIGF4ZXMuXG4gKiBAa28g66eI7Jqw7Iqk64KYIO2EsOy5mCDsiqTtgazrprDsnYQg64iE66W06rOgIOybgOyngeydvOuVjOydmCDrs4DtmZTrn4nsnYQgZWcuQXhlc+yXkCDsoITri6ztlZjripQg66qo65OILiDrkZDqsJwg7J207ZWY7J2YIOy2leydhCDsgqzsmqntlZzri6QuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiBjb25zdCBwYW4gPSBuZXcgZWcuQXhlcy5QYW5JbnB1dChcIiNhcmVhXCIsIHtcbiAqICAgICBpbnB1dFR5cGU6IFtcInRvdWNoXCJdLFxuICogICAgIHNjYWxlOiBbMSwgMS4zXSxcbiAqIH0pO1xuICpcbiAqIC8vIENvbm5lY3QgdGhlICdzb21ldGhpbmcyJyBheGlzIHRvIHRoZSBtb3VzZSBvciB0b3VjaHNjcmVlbiB4IHBvc2l0aW9uIHdoZW4gdGhlIG1vdXNlIG9yIHRvdWNoc2NyZWVuIGlzIGRvd24gYW5kIG1vdmVkLlxuICogLy8gQ29ubmVjdCB0aGUgJ3NvbWV0aGluZ04nIGF4aXMgdG8gdGhlIG1vdXNlIG9yIHRvdWNoc2NyZWVuIHkgcG9zaXRpb24gd2hlbiB0aGUgbW91c2Ugb3IgdG91Y2hzY3JlZW4gaXMgZG93biBhbmQgbW92ZWQuXG4gKiBheGVzLmNvbm5lY3QoW1wic29tZXRoaW5nMlwiLCBcInNvbWV0aGluZ05cIl0sIHBhbik7IC8vIG9yIGF4ZXMuY29ubmVjdChcInNvbWV0aGluZzIgc29tZXRoaW5nTlwiLCBwYW4pO1xuICpcbiAqIC8vIENvbm5lY3Qgb25seSBvbmUgJ3NvbWV0aGluZzEnIGF4aXMgdG8gdGhlIG1vdXNlIG9yIHRvdWNoc2NyZWVuIHggcG9zaXRpb24gd2hlbiB0aGUgbW91c2Ugb3IgdG91Y2hzY3JlZW4gaXMgZG93biBhbmQgbW92ZWQuXG4gKiBheGVzLmNvbm5lY3QoW1wic29tZXRoaW5nMVwiXSwgcGFuKTsgLy8gb3IgYXhlcy5jb25uZWN0KFwic29tZXRoaW5nMVwiLCBwYW4pO1xuICpcbiAqIC8vIENvbm5lY3Qgb25seSBvbmUgJ3NvbWV0aGluZzInIGF4aXMgdG8gdGhlIG1vdXNlIG9yIHRvdWNoc2NyZWVuIHkgcG9zaXRpb24gd2hlbiB0aGUgbW91c2Ugb3IgdG91Y2hzY3JlZW4gaXMgZG93biBhbmQgbW92ZWQuXG4gKiBheGVzLmNvbm5lY3QoW1wiXCIsIFwic29tZXRoaW5nMlwiXSwgcGFuKTsgLy8gb3IgYXhlcy5jb25uZWN0KFwiIHNvbWV0aGluZzJcIiwgcGFuKTtcbiAqIGBgYFxuICogQHBhcmFtIHtTdHJpbmd8SFRNTEVsZW1lbnR8UmVmPEhUTUxFbGVtZW50PnxqUXVlcnl9IGVsZW1lbnQgQW4gZWxlbWVudCB0byB1c2UgdGhlIGVnLkF4ZXMuUGFuSW5wdXQgbW9kdWxlIDxrbz5lZy5BeGVzLlBhbklucHV0IOuqqOuTiOydhCDsgqzsmqntlaAg7JeY66as66i87Yq4PC9rbz5cbiAqIEBwYXJhbSB7UGFuSW5wdXRPcHRpb259IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9uIG9iamVjdCBvZiB0aGUgZWcuQXhlcy5QYW5JbnB1dCBtb2R1bGU8a28+ZWcuQXhlcy5QYW5JbnB1dCDrqqjrk4jsnZgg7Ji17IWYIOqwneyytDwva28+XG4gKi9cbnZhciBQYW5JbnB1dCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKlxuICAgKi9cbiAgZnVuY3Rpb24gUGFuSW5wdXQoZWwsIG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHRoaXMuYXhlcyA9IFtdO1xuICAgIHRoaXMuZWxlbWVudCA9IG51bGw7XG4gICAgdGhpcy5fZW5hYmxlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2FjdGl2ZUV2ZW50ID0gbnVsbDtcbiAgICB0aGlzLl9hdFJpZ2h0RWRnZSA9IGZhbHNlO1xuICAgIHRoaXMuX3JpZ2h0RWRnZVRpbWVyID0gMDtcbiAgICB0aGlzLl9kcmFnZ2VkID0gZmFsc2U7XG4gICAgdGhpcy5faXNPdmVyVGhyZXNob2xkID0gZmFsc2U7XG4gICAgdGhpcy5fcHJldmVudENsaWNrV2hlbkRyYWdnZWQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKF90aGlzLl9kcmFnZ2VkKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIH1cbiAgICAgIF90aGlzLl9kcmFnZ2VkID0gZmFsc2U7XG4gICAgfTtcbiAgICB0aGlzLl92b2lkRnVuY3Rpb24gPSBmdW5jdGlvbiAoKSB7fTtcbiAgICB0aGlzLmVsZW1lbnQgPSAkJDEoZWwpO1xuICAgIHRoaXMub3B0aW9ucyA9IF9fYXNzaWduKHtcbiAgICAgIGlucHV0VHlwZTogW1widG91Y2hcIiwgXCJtb3VzZVwiLCBcInBvaW50ZXJcIl0sXG4gICAgICBpbnB1dEtleTogW0FOWV0sXG4gICAgICBpbnB1dEJ1dHRvbjogW01PVVNFX0xFRlRdLFxuICAgICAgc2NhbGU6IFsxLCAxXSxcbiAgICAgIHRocmVzaG9sZEFuZ2xlOiA0NSxcbiAgICAgIHRocmVzaG9sZDogMCxcbiAgICAgIHByZXZlbnRDbGlja09uRHJhZzogZmFsc2UsXG4gICAgICBwcmV2ZW50RGVmYXVsdE9uRHJhZzogZmFsc2UsXG4gICAgICBpT1NFZGdlU3dpcGVUaHJlc2hvbGQ6IElPU19FREdFX1RIUkVTSE9MRCxcbiAgICAgIHJlbGVhc2VPblNjcm9sbDogZmFsc2UsXG4gICAgICB0b3VjaEFjdGlvbjogbnVsbFxuICAgIH0sIG9wdGlvbnMpO1xuICAgIHRoaXMuX29uUGFuc3RhcnQgPSB0aGlzLl9vblBhbnN0YXJ0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25QYW5tb3ZlID0gdGhpcy5fb25QYW5tb3ZlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25QYW5lbmQgPSB0aGlzLl9vblBhbmVuZC5iaW5kKHRoaXMpO1xuICB9XG4gIHZhciBfX3Byb3RvID0gUGFuSW5wdXQucHJvdG90eXBlO1xuICBfX3Byb3RvLm1hcEF4ZXMgPSBmdW5jdGlvbiAoYXhlcykge1xuICAgIHRoaXMuX2RpcmVjdGlvbiA9IGdldERpcmVjdGlvbighIWF4ZXNbMF0sICEhYXhlc1sxXSk7XG4gICAgdGhpcy5heGVzID0gYXhlcztcbiAgfTtcbiAgX19wcm90by5jb25uZWN0ID0gZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgaWYgKHRoaXMuX2FjdGl2ZUV2ZW50KSB7XG4gICAgICB0aGlzLl9kZXRhY2hFbGVtZW50RXZlbnQoKTtcbiAgICAgIHRoaXMuX2RldGFjaFdpbmRvd0V2ZW50KHRoaXMuX2FjdGl2ZUV2ZW50KTtcbiAgICB9XG4gICAgdGhpcy5fYXR0YWNoRWxlbWVudEV2ZW50KG9ic2VydmVyKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgX19wcm90by5kaXNjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2RldGFjaEVsZW1lbnRFdmVudCgpO1xuICAgIHRoaXMuX2RldGFjaFdpbmRvd0V2ZW50KHRoaXMuX2FjdGl2ZUV2ZW50KTtcbiAgICB0aGlzLl9kaXJlY3Rpb24gPSBESVJFQ1RJT05fTk9ORTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXG4gICAqIERlc3Ryb3lzIGVsZW1lbnRzLCBwcm9wZXJ0aWVzLCBhbmQgZXZlbnRzIHVzZWQgaW4gYSBtb2R1bGUuXG4gICAqIEBrbyDrqqjrk4jsl5Ag7IKs7Jqp7ZWcIOyXmOumrOuovO2KuOyZgCDsho3shLEsIOydtOuypO2KuOulvCDtlbTsoJztlZzri6QuXG4gICAqL1xuICBfX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgdGhpcy5lbGVtZW50ID0gbnVsbDtcbiAgfTtcbiAgLyoqXG4gICAqIEVuYWJsZXMgaW5wdXQgZGV2aWNlc1xuICAgKiBAa28g7J6F66ClIOyepey5mOulvCDsgqzsmqntlaAg7IiYIOyeiOqyjCDtlZzri6RcbiAgICogQHJldHVybiB7UGFuSW5wdXR9IEFuIGluc3RhbmNlIG9mIGEgbW9kdWxlIGl0c2VsZiA8a28+66qo65OIIOyekOyLoOydmCDsnbjsiqTthLTsiqQ8L2tvPlxuICAgKi9cbiAgX19wcm90by5lbmFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLl9lbmFibGVkKSB7XG4gICAgICB0aGlzLl9lbmFibGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuX29yaWdpbmFsQ3NzUHJvcHMgPSBzZXRDc3NQcm9wcyh0aGlzLmVsZW1lbnQsIHRoaXMub3B0aW9ucywgdGhpcy5fZGlyZWN0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxuICAgKiBEaXNhYmxlcyBpbnB1dCBkZXZpY2VzXG4gICAqIEBrbyDsnoXroKUg7J6l7LmY66W8IOyCrOyaqe2VoCDsiJgg7JeG6rKMIO2VnOuLpC5cbiAgICogQHJldHVybiB7UGFuSW5wdXR9IEFuIGluc3RhbmNlIG9mIGEgbW9kdWxlIGl0c2VsZiA8a28+66qo65OIIOyekOyLoOydmCDsnbjsiqTthLTsiqQ8L2tvPlxuICAgKi9cbiAgX19wcm90by5kaXNhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9lbmFibGVkKSB7XG4gICAgICB0aGlzLl9lbmFibGVkID0gZmFsc2U7XG4gICAgICBpZiAoIWlzQ3NzUHJvcHNGcm9tQXhlcyh0aGlzLl9vcmlnaW5hbENzc1Byb3BzKSkge1xuICAgICAgICByZXZlcnRDc3NQcm9wcyh0aGlzLmVsZW1lbnQsIHRoaXMuX29yaWdpbmFsQ3NzUHJvcHMpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0byB1c2UgYW4gaW5wdXQgZGV2aWNlXG4gICAqIEBrbyDsnoXroKUg7J6l7LmYIOyCrOyaqSDsl6zrtoDrpbwg67CY7ZmY7ZWc64ukLlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIHRvIHVzZSBhbiBpbnB1dCBkZXZpY2UgPGtvPuyeheugpeyepey5mCDsgqzsmqnsl6zrtoA8L2tvPlxuICAgKi9cbiAgX19wcm90by5pc0VuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VuYWJsZWQ7XG4gIH07XG4gIC8qKlxuICAgKiBSZWxlYXNlcyBjdXJyZW50IHVzZXIgaW5wdXQuXG4gICAqIEBrbyDsgqzsmqnsnpDsnZgg7J6F66Cl7J2EIOqwleygnOuhnCDspJHri6jsi5ztgqjri6QuXG4gICAqIEByZXR1cm4ge1BhbklucHV0fSBBbiBpbnN0YW5jZSBvZiBhIG1vZHVsZSBpdHNlbGYgPGtvPuuqqOuTiCDsnpDsi6DsnZgg7J247Iqk7YS07IqkPC9rbz5cbiAgICovXG4gIF9fcHJvdG8ucmVsZWFzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYWN0aXZlRXZlbnQgPSB0aGlzLl9hY3RpdmVFdmVudDtcbiAgICB2YXIgcHJldkV2ZW50ID0gYWN0aXZlRXZlbnQucHJldkV2ZW50O1xuICAgIGFjdGl2ZUV2ZW50Lm9uUmVsZWFzZSgpO1xuICAgIHRoaXMuX29ic2VydmVyLnJlbGVhc2UodGhpcywgcHJldkV2ZW50LCBbMCwgMF0pO1xuICAgIHRoaXMuX2RldGFjaFdpbmRvd0V2ZW50KGFjdGl2ZUV2ZW50KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgX19wcm90by5fb25QYW5zdGFydCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciBfYSA9IHRoaXMub3B0aW9ucyxcbiAgICAgIGlucHV0S2V5ID0gX2EuaW5wdXRLZXksXG4gICAgICBpbnB1dEJ1dHRvbiA9IF9hLmlucHV0QnV0dG9uLFxuICAgICAgcHJldmVudERlZmF1bHRPbkRyYWcgPSBfYS5wcmV2ZW50RGVmYXVsdE9uRHJhZztcbiAgICB2YXIgYWN0aXZlRXZlbnQgPSB0aGlzLl9hY3RpdmVFdmVudDtcbiAgICB2YXIgcGFuRXZlbnQgPSBhY3RpdmVFdmVudC5vbkV2ZW50U3RhcnQoZXZlbnQsIGlucHV0S2V5LCBpbnB1dEJ1dHRvbik7XG4gICAgaWYgKCFwYW5FdmVudCB8fCAhdGhpcy5fZW5hYmxlZCB8fCBhY3RpdmVFdmVudC5nZXRUb3VjaGVzKGV2ZW50LCBpbnB1dEJ1dHRvbikgPiAxKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChwYW5FdmVudC5zcmNFdmVudC5jYW5jZWxhYmxlICE9PSBmYWxzZSkge1xuICAgICAgdmFyIGVkZ2VUaHJlc2hvbGQgPSB0aGlzLm9wdGlvbnMuaU9TRWRnZVN3aXBlVGhyZXNob2xkO1xuICAgICAgdGhpcy5fZHJhZ2dlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5faXNPdmVyVGhyZXNob2xkID0gZmFsc2U7XG4gICAgICB0aGlzLl9vYnNlcnZlci5ob2xkKHRoaXMsIHBhbkV2ZW50KTtcbiAgICAgIHRoaXMuX2F0UmlnaHRFZGdlID0gSVNfSU9TX1NBRkFSSSAmJiBwYW5FdmVudC5jZW50ZXIueCA+IHdpbmRvdy5pbm5lcldpZHRoIC0gZWRnZVRocmVzaG9sZDtcbiAgICAgIHRoaXMuX2F0dGFjaFdpbmRvd0V2ZW50KGFjdGl2ZUV2ZW50KTtcbiAgICAgIHByZXZlbnREZWZhdWx0T25EcmFnICYmIHBhbkV2ZW50LnNyY0V2ZW50LnR5cGUgIT09IFwidG91Y2hzdGFydFwiICYmIHBhbkV2ZW50LnNyY0V2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBhY3RpdmVFdmVudC5wcmV2RXZlbnQgPSBwYW5FdmVudDtcbiAgICB9XG4gIH07XG4gIF9fcHJvdG8uX29uUGFubW92ZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIF9hID0gdGhpcy5vcHRpb25zLFxuICAgICAgaU9TRWRnZVN3aXBlVGhyZXNob2xkID0gX2EuaU9TRWRnZVN3aXBlVGhyZXNob2xkLFxuICAgICAgcHJldmVudENsaWNrT25EcmFnID0gX2EucHJldmVudENsaWNrT25EcmFnLFxuICAgICAgcmVsZWFzZU9uU2Nyb2xsID0gX2EucmVsZWFzZU9uU2Nyb2xsLFxuICAgICAgaW5wdXRLZXkgPSBfYS5pbnB1dEtleSxcbiAgICAgIGlucHV0QnV0dG9uID0gX2EuaW5wdXRCdXR0b24sXG4gICAgICB0aHJlc2hvbGQgPSBfYS50aHJlc2hvbGQsXG4gICAgICB0aHJlc2hvbGRBbmdsZSA9IF9hLnRocmVzaG9sZEFuZ2xlO1xuICAgIHZhciBhY3RpdmVFdmVudCA9IHRoaXMuX2FjdGl2ZUV2ZW50O1xuICAgIHZhciBwYW5FdmVudCA9IGFjdGl2ZUV2ZW50Lm9uRXZlbnRNb3ZlKGV2ZW50LCBpbnB1dEtleSwgaW5wdXRCdXR0b24pO1xuICAgIHZhciB0b3VjaGVzID0gYWN0aXZlRXZlbnQuZ2V0VG91Y2hlcyhldmVudCwgaW5wdXRCdXR0b24pO1xuICAgIGlmICh0b3VjaGVzID09PSAwIHx8IHJlbGVhc2VPblNjcm9sbCAmJiBwYW5FdmVudCAmJiAhcGFuRXZlbnQuc3JjRXZlbnQuY2FuY2VsYWJsZSkge1xuICAgICAgdGhpcy5fb25QYW5lbmQoZXZlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXBhbkV2ZW50IHx8ICF0aGlzLl9lbmFibGVkIHx8IHRvdWNoZXMgPiAxKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB1c2VyRGlyZWN0aW9uID0gZ2V0RGlyZWN0aW9uQnlBbmdsZShwYW5FdmVudC5hbmdsZSwgdGhyZXNob2xkQW5nbGUpO1xuICAgIHZhciB1c2VIb3Jpem9udGFsID0gdXNlRGlyZWN0aW9uKERJUkVDVElPTl9IT1JJWk9OVEFMLCB0aGlzLl9kaXJlY3Rpb24sIHVzZXJEaXJlY3Rpb24pO1xuICAgIHZhciB1c2VWZXJ0aWNhbCA9IHVzZURpcmVjdGlvbihESVJFQ1RJT05fVkVSVElDQUwsIHRoaXMuX2RpcmVjdGlvbiwgdXNlckRpcmVjdGlvbik7XG4gICAgaWYgKGFjdGl2ZUV2ZW50LnByZXZFdmVudCAmJiBJU19JT1NfU0FGQVJJKSB7XG4gICAgICB2YXIgc3dpcGVMZWZ0VG9SaWdodCA9IHBhbkV2ZW50LmNlbnRlci54IDwgMDtcbiAgICAgIGlmIChzd2lwZUxlZnRUb1JpZ2h0KSB7XG4gICAgICAgIC8vIGlPUyBzd2lwZSBsZWZ0ID0+IHJpZ2h0XG4gICAgICAgIHRoaXMucmVsZWFzZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2F0UmlnaHRFZGdlKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9yaWdodEVkZ2VUaW1lcik7XG4gICAgICAgIC8vIC0gaXMgcmlnaHQgdG8gbGVmdFxuICAgICAgICB2YXIgc3dpcGVSaWdodFRvTGVmdCA9IHBhbkV2ZW50LmRlbHRhWCA8IC1pT1NFZGdlU3dpcGVUaHJlc2hvbGQ7XG4gICAgICAgIGlmIChzd2lwZVJpZ2h0VG9MZWZ0KSB7XG4gICAgICAgICAgdGhpcy5fYXRSaWdodEVkZ2UgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBpT1Mgc3dpcGUgcmlnaHQgPT4gbGVmdFxuICAgICAgICAgIHRoaXMuX3JpZ2h0RWRnZVRpbWVyID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnJlbGVhc2UoKTtcbiAgICAgICAgICB9LCAxMDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBkaXN0YW5jZSA9IHRoaXMuX2dldERpc3RhbmNlKFtwYW5FdmVudC5kZWx0YVgsIHBhbkV2ZW50LmRlbHRhWV0sIFt1c2VIb3Jpem9udGFsLCB1c2VWZXJ0aWNhbF0pO1xuICAgIHZhciBvZmZzZXQgPSB0aGlzLl9nZXRPZmZzZXQoW3BhbkV2ZW50Lm9mZnNldFgsIHBhbkV2ZW50Lm9mZnNldFldLCBbdXNlSG9yaXpvbnRhbCwgdXNlVmVydGljYWxdKTtcbiAgICB2YXIgcHJldmVudCA9IG9mZnNldC5zb21lKGZ1bmN0aW9uICh2KSB7XG4gICAgICByZXR1cm4gdiAhPT0gMDtcbiAgICB9KTtcbiAgICBpZiAocHJldmVudCkge1xuICAgICAgaWYgKHBhbkV2ZW50LnNyY0V2ZW50LmNhbmNlbGFibGUgIT09IGZhbHNlKSB7XG4gICAgICAgIHBhbkV2ZW50LnNyY0V2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgICBwYW5FdmVudC5zcmNFdmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9XG4gICAgcGFuRXZlbnQucHJldmVudFN5c3RlbUV2ZW50ID0gcHJldmVudDtcbiAgICBpZiAocHJldmVudCAmJiAodGhpcy5faXNPdmVyVGhyZXNob2xkIHx8IGRpc3RhbmNlID49IHRocmVzaG9sZCkpIHtcbiAgICAgIHRoaXMuX2RyYWdnZWQgPSBwcmV2ZW50Q2xpY2tPbkRyYWc7XG4gICAgICB0aGlzLl9pc092ZXJUaHJlc2hvbGQgPSB0cnVlO1xuICAgICAgdGhpcy5fb2JzZXJ2ZXIuY2hhbmdlKHRoaXMsIHBhbkV2ZW50LCB0b0F4aXModGhpcy5heGVzLCBvZmZzZXQpKTtcbiAgICB9XG4gICAgYWN0aXZlRXZlbnQucHJldkV2ZW50ID0gcGFuRXZlbnQ7XG4gIH07XG4gIF9fcHJvdG8uX29uUGFuZW5kID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIGlucHV0QnV0dG9uID0gdGhpcy5vcHRpb25zLmlucHV0QnV0dG9uO1xuICAgIHZhciBhY3RpdmVFdmVudCA9IHRoaXMuX2FjdGl2ZUV2ZW50O1xuICAgIGFjdGl2ZUV2ZW50Lm9uRXZlbnRFbmQoZXZlbnQpO1xuICAgIGlmICghdGhpcy5fZW5hYmxlZCB8fCBhY3RpdmVFdmVudC5nZXRUb3VjaGVzKGV2ZW50LCBpbnB1dEJ1dHRvbikgIT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fZGV0YWNoV2luZG93RXZlbnQoYWN0aXZlRXZlbnQpO1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl9yaWdodEVkZ2VUaW1lcik7XG4gICAgdmFyIHByZXZFdmVudCA9IGFjdGl2ZUV2ZW50LnByZXZFdmVudDtcbiAgICB2YXIgdmVsb2NpdHkgPSB0aGlzLl9pc092ZXJUaHJlc2hvbGQgPyB0aGlzLl9nZXRPZmZzZXQoW01hdGguYWJzKHByZXZFdmVudC52ZWxvY2l0eVgpICogKHByZXZFdmVudC5vZmZzZXRYIDwgMCA/IC0xIDogMSksIE1hdGguYWJzKHByZXZFdmVudC52ZWxvY2l0eVkpICogKHByZXZFdmVudC5vZmZzZXRZIDwgMCA/IC0xIDogMSldLCBbdXNlRGlyZWN0aW9uKERJUkVDVElPTl9IT1JJWk9OVEFMLCB0aGlzLl9kaXJlY3Rpb24pLCB1c2VEaXJlY3Rpb24oRElSRUNUSU9OX1ZFUlRJQ0FMLCB0aGlzLl9kaXJlY3Rpb24pXSkgOiBbMCwgMF07XG4gICAgYWN0aXZlRXZlbnQub25SZWxlYXNlKCk7XG4gICAgdGhpcy5fb2JzZXJ2ZXIucmVsZWFzZSh0aGlzLCBwcmV2RXZlbnQsIHZlbG9jaXR5KTtcbiAgfTtcbiAgX19wcm90by5fYXR0YWNoV2luZG93RXZlbnQgPSBmdW5jdGlvbiAoYWN0aXZlRXZlbnQpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIGFjdGl2ZUV2ZW50ID09PSBudWxsIHx8IGFjdGl2ZUV2ZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhY3RpdmVFdmVudC5tb3ZlLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgX3RoaXMuX29uUGFubW92ZSwgZ2V0QWRkRXZlbnRPcHRpb25zKGV2ZW50KSk7XG4gICAgfSk7XG4gICAgYWN0aXZlRXZlbnQgPT09IG51bGwgfHwgYWN0aXZlRXZlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFjdGl2ZUV2ZW50LmVuZC5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIF90aGlzLl9vblBhbmVuZCwgZ2V0QWRkRXZlbnRPcHRpb25zKGV2ZW50KSk7XG4gICAgfSk7XG4gIH07XG4gIF9fcHJvdG8uX2RldGFjaFdpbmRvd0V2ZW50ID0gZnVuY3Rpb24gKGFjdGl2ZUV2ZW50KSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBhY3RpdmVFdmVudCA9PT0gbnVsbCB8fCBhY3RpdmVFdmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWN0aXZlRXZlbnQubW92ZS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIF90aGlzLl9vblBhbm1vdmUpO1xuICAgIH0pO1xuICAgIGFjdGl2ZUV2ZW50ID09PSBudWxsIHx8IGFjdGl2ZUV2ZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhY3RpdmVFdmVudC5lbmQuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBfdGhpcy5fb25QYW5lbmQpO1xuICAgIH0pO1xuICB9O1xuICBfX3Byb3RvLl9nZXRPZmZzZXQgPSBmdW5jdGlvbiAocHJvcGVydGllcywgZGlyZWN0aW9uKSB7XG4gICAgdmFyIHNjYWxlID0gdGhpcy5vcHRpb25zLnNjYWxlO1xuICAgIHJldHVybiBbZGlyZWN0aW9uWzBdID8gcHJvcGVydGllc1swXSAqIHNjYWxlWzBdIDogMCwgZGlyZWN0aW9uWzFdID8gcHJvcGVydGllc1sxXSAqIHNjYWxlWzFdIDogMF07XG4gIH07XG4gIF9fcHJvdG8uX2dldERpc3RhbmNlID0gZnVuY3Rpb24gKGRlbHRhLCBkaXJlY3Rpb24pIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KE51bWJlcihkaXJlY3Rpb25bMF0pICogTWF0aC5wb3coZGVsdGFbMF0sIDIpICsgTnVtYmVyKGRpcmVjdGlvblsxXSkgKiBNYXRoLnBvdyhkZWx0YVsxXSwgMikpO1xuICB9O1xuICBfX3Byb3RvLl9hdHRhY2hFbGVtZW50RXZlbnQgPSBmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHZhciBhY3RpdmVFdmVudCA9IGNvbnZlcnRJbnB1dFR5cGUodGhpcy5vcHRpb25zLmlucHV0VHlwZSk7XG4gICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG4gICAgaWYgKCFhY3RpdmVFdmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkVsZW1lbnQgdG8gY29ubmVjdCBpbnB1dCBkb2VzIG5vdCBleGlzdC5cIik7XG4gICAgfVxuICAgIHRoaXMuX29ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgdGhpcy5lbmFibGUoKTtcbiAgICB0aGlzLl9hY3RpdmVFdmVudCA9IGFjdGl2ZUV2ZW50O1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX3ByZXZlbnRDbGlja1doZW5EcmFnZ2VkLCB0cnVlKTtcbiAgICBhY3RpdmVFdmVudC5zdGFydC5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBfdGhpcy5fb25QYW5zdGFydCk7XG4gICAgfSk7XG4gICAgLy8gYWRkaW5nIGV2ZW50IGxpc3RlbmVyIHRvIGVsZW1lbnQgcHJldmVudHMgaW52YWxpZCBiZWhhdmlvciBpbiBpT1MgU2FmYXJpXG4gICAgYWN0aXZlRXZlbnQubW92ZS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBfdGhpcy5fdm9pZEZ1bmN0aW9uKTtcbiAgICB9KTtcbiAgfTtcbiAgX19wcm90by5fZGV0YWNoRWxlbWVudEV2ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIGFjdGl2ZUV2ZW50ID0gdGhpcy5fYWN0aXZlRXZlbnQ7XG4gICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX3ByZXZlbnRDbGlja1doZW5EcmFnZ2VkLCB0cnVlKTtcbiAgICAgIGFjdGl2ZUV2ZW50ID09PSBudWxsIHx8IGFjdGl2ZUV2ZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhY3RpdmVFdmVudC5zdGFydC5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIF90aGlzLl9vblBhbnN0YXJ0KTtcbiAgICAgIH0pO1xuICAgICAgYWN0aXZlRXZlbnQgPT09IG51bGwgfHwgYWN0aXZlRXZlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFjdGl2ZUV2ZW50Lm1vdmUuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBfdGhpcy5fdm9pZEZ1bmN0aW9uKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLmRpc2FibGUoKTtcbiAgICB0aGlzLl9vYnNlcnZlciA9IG51bGw7XG4gIH07XG4gIHJldHVybiBQYW5JbnB1dDtcbn0oKTtcblxuLypcbkNvcHlyaWdodCAoYykgMjAyMC1wcmVzZW50IE5BVkVSIENvcnAuXG5uYW1lOiBAZWdqcy9pbXJlYWR5XG5saWNlbnNlOiBNSVRcbmF1dGhvcjogTkFWRVIgQ29ycC5cbnJlcG9zaXRvcnk6IGh0dHBzOi8vZ2l0aHViLmNvbS9uYXZlci9lZ2pzLWltcmVhZHlcbnZlcnNpb246IDEuMy4xXG4qL1xuXG4vKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xudmFyIGV4dGVuZFN0YXRpY3MkMiA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gIGV4dGVuZFN0YXRpY3MkMiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCB7XG4gICAgX19wcm90b19fOiBbXVxuICB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBkLl9fcHJvdG9fXyA9IGI7XG4gIH0gfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdO1xuICB9O1xuXG4gIHJldHVybiBleHRlbmRTdGF0aWNzJDIoZCwgYik7XG59O1xuXG5mdW5jdGlvbiBfX2V4dGVuZHMkMihkLCBiKSB7XG4gIGV4dGVuZFN0YXRpY3MkMihkLCBiKTtcblxuICBmdW5jdGlvbiBfXygpIHtcbiAgICB0aGlzLmNvbnN0cnVjdG9yID0gZDtcbiAgfVxuXG4gIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn1cbnZhciBfX2Fzc2lnbiQxID0gZnVuY3Rpb24gKCkge1xuICBfX2Fzc2lnbiQxID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XG4gICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICBzID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xuICAgIH1cblxuICAgIHJldHVybiB0O1xuICB9O1xuXG4gIHJldHVybiBfX2Fzc2lnbiQxLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuZnVuY3Rpb24gX19zcHJlYWRBcnJheXMoKSB7XG4gIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykgcyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xuXG4gIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKykgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspIHJba10gPSBhW2pdO1xuXG4gIHJldHVybiByO1xufVxuXG4vKlxuZWdqcy1pbXJlYWR5XG5Db3B5cmlnaHQgKGMpIDIwMjAtcHJlc2VudCBOQVZFUiBDb3JwLlxuTUlUIGxpY2Vuc2VcbiovXG52YXIgaXNXaW5kb3cgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiO1xudmFyIHVhID0gaXNXaW5kb3cgPyB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCA6IFwiXCI7XG52YXIgU1VQUE9SVF9DT01QVVRFRFNUWUxFID0gaXNXaW5kb3cgPyAhIShcImdldENvbXB1dGVkU3R5bGVcIiBpbiB3aW5kb3cpIDogZmFsc2U7XG52YXIgSVNfSUUgPSAvTVNJRXxUcmlkZW50fFdpbmRvd3MgUGhvbmV8RWRnZS8udGVzdCh1YSk7XG52YXIgU1VQUE9SVF9BRERFVkVOVExJU1RFTkVSID0gaXNXaW5kb3cgPyAhIShcImFkZEV2ZW50TGlzdGVuZXJcIiBpbiBkb2N1bWVudCkgOiBmYWxzZTtcbnZhciBXSURUSCA9IFwid2lkdGhcIjtcbnZhciBIRUlHSFQgPSBcImhlaWdodFwiO1xuXG5mdW5jdGlvbiBnZXRBdHRyaWJ1dGUoZWwsIG5hbWUpIHtcbiAgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZShuYW1lKSB8fCBcIlwiO1xufVxuZnVuY3Rpb24gdG9BcnJheSQxKGFycikge1xuICByZXR1cm4gW10uc2xpY2UuY2FsbChhcnIpO1xufVxuZnVuY3Rpb24gaGFzU2l6ZUF0dHJpYnV0ZSh0YXJnZXQsIHByZWZpeCkge1xuICBpZiAocHJlZml4ID09PSB2b2lkIDApIHtcbiAgICBwcmVmaXggPSBcImRhdGEtXCI7XG4gIH1cblxuICByZXR1cm4gISF0YXJnZXQuZ2V0QXR0cmlidXRlKHByZWZpeCArIFwid2lkdGhcIik7XG59XG5mdW5jdGlvbiBoYXNMb2FkaW5nQXR0cmlidXRlKHRhcmdldCwgcHJlZml4KSB7XG4gIGlmIChwcmVmaXggPT09IHZvaWQgMCkge1xuICAgIHByZWZpeCA9IFwiZGF0YS1cIjtcbiAgfVxuXG4gIHJldHVybiBcImxvYWRpbmdcIiBpbiB0YXJnZXQgJiYgdGFyZ2V0LmdldEF0dHJpYnV0ZShcImxvYWRpbmdcIikgPT09IFwibGF6eVwiIHx8ICEhdGFyZ2V0LmdldEF0dHJpYnV0ZShwcmVmaXggKyBcImxhenlcIik7XG59XG5mdW5jdGlvbiBoYXNTa2lwQXR0cmlidXRlKHRhcmdldCwgcHJlZml4KSB7XG4gIGlmIChwcmVmaXggPT09IHZvaWQgMCkge1xuICAgIHByZWZpeCA9IFwiZGF0YS1cIjtcbiAgfVxuXG4gIHJldHVybiAhIXRhcmdldC5nZXRBdHRyaWJ1dGUocHJlZml4ICsgXCJza2lwXCIpO1xufVxuZnVuY3Rpb24gYWRkRXZlbnQoZWxlbWVudCwgdHlwZSwgaGFuZGxlcikge1xuICBpZiAoU1VQUE9SVF9BRERFVkVOVExJU1RFTkVSKSB7XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcbiAgfSBlbHNlIGlmIChlbGVtZW50LmF0dGFjaEV2ZW50KSB7XG4gICAgZWxlbWVudC5hdHRhY2hFdmVudChcIm9uXCIgKyB0eXBlLCBoYW5kbGVyKTtcbiAgfSBlbHNlIHtcbiAgICBlbGVtZW50W1wib25cIiArIHR5cGVdID0gaGFuZGxlcjtcbiAgfVxufVxuZnVuY3Rpb24gcmVtb3ZlRXZlbnQoZWxlbWVudCwgdHlwZSwgaGFuZGxlcikge1xuICBpZiAoZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKSB7XG4gICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcbiAgfSBlbHNlIGlmIChlbGVtZW50LmRldGFjaEV2ZW50KSB7XG4gICAgZWxlbWVudC5kZXRhY2hFdmVudChcIm9uXCIgKyB0eXBlLCBoYW5kbGVyKTtcbiAgfSBlbHNlIHtcbiAgICBlbGVtZW50W1wib25cIiArIHR5cGVdID0gbnVsbDtcbiAgfVxufVxuZnVuY3Rpb24gaW5uZXJXaWR0aChlbCkge1xuICByZXR1cm4gZ2V0U2l6ZShlbCwgXCJXaWR0aFwiKTtcbn1cbmZ1bmN0aW9uIGlubmVySGVpZ2h0KGVsKSB7XG4gIHJldHVybiBnZXRTaXplKGVsLCBcIkhlaWdodFwiKTtcbn1cbmZ1bmN0aW9uIGdldFN0eWxlcyhlbCkge1xuICByZXR1cm4gKFNVUFBPUlRfQ09NUFVURURTVFlMRSA/IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKSA6IGVsLmN1cnJlbnRTdHlsZSkgfHwge307XG59XG5cbmZ1bmN0aW9uIGdldFNpemUoZWwsIG5hbWUpIHtcbiAgdmFyIHNpemUgPSBlbFtcImNsaWVudFwiICsgbmFtZV0gfHwgZWxbXCJvZmZzZXRcIiArIG5hbWVdO1xuICByZXR1cm4gcGFyc2VGbG9hdChzaXplIHx8IGdldFN0eWxlcyhlbClbbmFtZS50b0xvd2VyQ2FzZSgpXSkgfHwgMDtcbn1cblxuZnVuY3Rpb24gZ2V0Q29udGVudEVsZW1lbnRzKGVsZW1lbnQsIHRhZ3MsIHByZWZpeCkge1xuICB2YXIgc2tpcEVsZW1lbnRzID0gdG9BcnJheSQxKGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChfX3NwcmVhZEFycmF5cyhbXCJbXCIgKyBwcmVmaXggKyBcInNraXBdIFtcIiArIHByZWZpeCArIFwid2lkdGhdXCJdLCB0YWdzLm1hcChmdW5jdGlvbiAodGFnKSB7XG4gICAgcmV0dXJuIFtcIltcIiArIHByZWZpeCArIFwic2tpcF0gXCIgKyB0YWcsIHRhZyArIFwiW1wiICsgcHJlZml4ICsgXCJza2lwXVwiLCBcIltcIiArIHByZWZpeCArIFwid2lkdGhdIFwiICsgdGFnXS5qb2luKFwiLCBcIik7XG4gIH0pKS5qb2luKFwiLCBcIikpKTtcbiAgcmV0dXJuIHRvQXJyYXkkMShlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJbXCIgKyBwcmVmaXggKyBcIndpZHRoXSwgXCIgKyB0YWdzLmpvaW4oXCIsIFwiKSkpLmZpbHRlcihmdW5jdGlvbiAoZWwpIHtcbiAgICByZXR1cm4gc2tpcEVsZW1lbnRzLmluZGV4T2YoZWwpID09PSAtMTtcbiAgfSk7XG59XG5cbi8qXG5lZ2pzLWltcmVhZHlcbkNvcHlyaWdodCAoYykgMjAyMC1wcmVzZW50IE5BVkVSIENvcnAuXG5NSVQgbGljZW5zZVxuKi9cbnZhciBlbGVtZW50cyA9IFtdO1xuZnVuY3Rpb24gYWRkQXV0b1NpemVyKGVsZW1lbnQsIHByZWZpeCkge1xuICAhZWxlbWVudHMubGVuZ3RoICYmIGFkZEV2ZW50KHdpbmRvdywgXCJyZXNpemVcIiwgcmVzaXplQWxsQXV0b1NpemVycyk7XG4gIGVsZW1lbnQuX19QUkVGSVhfXyA9IHByZWZpeDtcbiAgZWxlbWVudHMucHVzaChlbGVtZW50KTtcbiAgcmVzaXplKGVsZW1lbnQpO1xufVxuZnVuY3Rpb24gcmVtb3ZlQXV0b1NpemVyKGVsZW1lbnQsIHByZWZpeCkge1xuICB2YXIgaW5kZXggPSBlbGVtZW50cy5pbmRleE9mKGVsZW1lbnQpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZml4ZWQgPSBnZXRBdHRyaWJ1dGUoZWxlbWVudCwgcHJlZml4ICsgXCJmaXhlZFwiKTtcbiAgZGVsZXRlIGVsZW1lbnQuX19QUkVGSVhfXztcbiAgZWxlbWVudC5zdHlsZVtmaXhlZCA9PT0gSEVJR0hUID8gV0lEVEggOiBIRUlHSFRdID0gXCJcIjtcbiAgZWxlbWVudHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgIWVsZW1lbnRzLmxlbmd0aCAmJiByZW1vdmVFdmVudCh3aW5kb3csIFwicmVzaXplXCIsIHJlc2l6ZUFsbEF1dG9TaXplcnMpO1xufVxuXG5mdW5jdGlvbiByZXNpemUoZWxlbWVudCwgcHJlZml4KSB7XG4gIGlmIChwcmVmaXggPT09IHZvaWQgMCkge1xuICAgIHByZWZpeCA9IFwiZGF0YS1cIjtcbiAgfVxuXG4gIHZhciBlbGVtZW50UHJlZml4ID0gZWxlbWVudC5fX1BSRUZJWF9fIHx8IHByZWZpeDtcbiAgdmFyIGRhdGFXaWR0aCA9IHBhcnNlSW50KGdldEF0dHJpYnV0ZShlbGVtZW50LCBcIlwiICsgZWxlbWVudFByZWZpeCArIFdJRFRIKSwgMTApIHx8IDA7XG4gIHZhciBkYXRhSGVpZ2h0ID0gcGFyc2VJbnQoZ2V0QXR0cmlidXRlKGVsZW1lbnQsIFwiXCIgKyBlbGVtZW50UHJlZml4ICsgSEVJR0hUKSwgMTApIHx8IDA7XG4gIHZhciBmaXhlZCA9IGdldEF0dHJpYnV0ZShlbGVtZW50LCBlbGVtZW50UHJlZml4ICsgXCJmaXhlZFwiKTtcblxuICBpZiAoZml4ZWQgPT09IEhFSUdIVCkge1xuICAgIHZhciBzaXplID0gaW5uZXJIZWlnaHQoZWxlbWVudCkgfHwgZGF0YUhlaWdodDtcbiAgICBlbGVtZW50LnN0eWxlW1dJRFRIXSA9IGRhdGFXaWR0aCAvIGRhdGFIZWlnaHQgKiBzaXplICsgXCJweFwiO1xuICB9IGVsc2Uge1xuICAgIHZhciBzaXplID0gaW5uZXJXaWR0aChlbGVtZW50KSB8fCBkYXRhV2lkdGg7XG4gICAgZWxlbWVudC5zdHlsZVtIRUlHSFRdID0gZGF0YUhlaWdodCAvIGRhdGFXaWR0aCAqIHNpemUgKyBcInB4XCI7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzaXplQWxsQXV0b1NpemVycygpIHtcbiAgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIHJlc2l6ZShlbGVtZW50KTtcbiAgfSk7XG59XG5cbnZhciBMb2FkZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMkMihMb2FkZXIsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gTG9hZGVyKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcblxuICAgIF90aGlzLmlzUmVhZHkgPSBmYWxzZTtcbiAgICBfdGhpcy5pc1ByZVJlYWR5ID0gZmFsc2U7XG4gICAgX3RoaXMuaGFzRGF0YVNpemUgPSBmYWxzZTtcbiAgICBfdGhpcy5oYXNMb2FkaW5nID0gZmFsc2U7XG4gICAgX3RoaXMuaXNTa2lwID0gZmFsc2U7XG5cbiAgICBfdGhpcy5vbkNoZWNrID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIF90aGlzLmNsZWFyKCk7XG5cbiAgICAgIGlmIChlICYmIGUudHlwZSA9PT0gXCJlcnJvclwiKSB7XG4gICAgICAgIF90aGlzLm9uRXJyb3IoX3RoaXMuZWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChfdGhpcy5oYXNMb2FkaW5nICYmIF90aGlzLmNoZWNrRWxlbWVudCgpKSB7XG4gICAgICAgIC8vIEknbSBub3QgcmVhZHlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBJJ20gcHJlLXJlYWR5IGFuZCByZWFkeSFcblxuXG4gICAgICB2YXIgd2l0aFByZVJlYWR5ID0gIV90aGlzLmhhc0RhdGFTaXplICYmICFfdGhpcy5oYXNMb2FkaW5nO1xuXG4gICAgICBfdGhpcy5vblJlYWR5KHdpdGhQcmVSZWFkeSk7XG4gICAgfTtcblxuICAgIF90aGlzLm9wdGlvbnMgPSBfX2Fzc2lnbiQxKHtcbiAgICAgIHByZWZpeDogXCJkYXRhLVwiXG4gICAgfSwgb3B0aW9ucyk7XG4gICAgX3RoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdmFyIHByZWZpeCA9IF90aGlzLm9wdGlvbnMucHJlZml4O1xuICAgIF90aGlzLmhhc0RhdGFTaXplID0gaGFzU2l6ZUF0dHJpYnV0ZShlbGVtZW50LCBwcmVmaXgpO1xuICAgIF90aGlzLmlzU2tpcCA9IGhhc1NraXBBdHRyaWJ1dGUoZWxlbWVudCwgcHJlZml4KTtcbiAgICBfdGhpcy5oYXNMb2FkaW5nID0gaGFzTG9hZGluZ0F0dHJpYnV0ZShlbGVtZW50LCBwcmVmaXgpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfX3Byb3RvID0gTG9hZGVyLnByb3RvdHlwZTtcblxuICBfX3Byb3RvLmNoZWNrID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmlzU2tpcCB8fCAhdGhpcy5jaGVja0VsZW1lbnQoKSkge1xuICAgICAgLy8gSSdtIFJlYWR5XG4gICAgICB0aGlzLm9uQWxyZWFkeVJlYWR5KHRydWUpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmhhc0RhdGFTaXplKSB7XG4gICAgICBhZGRBdXRvU2l6ZXIodGhpcy5lbGVtZW50LCB0aGlzLm9wdGlvbnMucHJlZml4KTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5oYXNEYXRhU2l6ZSB8fCB0aGlzLmhhc0xvYWRpbmcpIHtcbiAgICAgIC8vIEknbSBQcmUgUmVhZHlcbiAgICAgIHRoaXMub25BbHJlYWR5UHJlUmVhZHkoKTtcbiAgICB9IC8vIFdhdGkgUHJlIFJlYWR5LCBSZWFkeVxuXG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBfX3Byb3RvLmFkZEV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG4gICAgdGhpcy5jb25zdHJ1Y3Rvci5FVkVOVFMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgYWRkRXZlbnQoZWxlbWVudCwgbmFtZSwgX3RoaXMub25DaGVjayk7XG4gICAgfSk7XG4gIH07XG5cbiAgX19wcm90by5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG4gICAgdGhpcy5jb25zdHJ1Y3Rvci5FVkVOVFMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgcmVtb3ZlRXZlbnQoZWxlbWVudCwgbmFtZSwgX3RoaXMub25DaGVjayk7XG4gICAgfSk7XG4gICAgdGhpcy5yZW1vdmVBdXRvU2l6ZXIoKTtcbiAgfTtcblxuICBfX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jbGVhcigpO1xuICAgIHRoaXMub2ZmKCk7XG4gIH07XG5cbiAgX19wcm90by5yZW1vdmVBdXRvU2l6ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuaGFzRGF0YVNpemUpIHtcbiAgICAgIC8vIEknbSBhbHJlYWR5IHJlYWR5LlxuICAgICAgdmFyIHByZWZpeCA9IHRoaXMub3B0aW9ucy5wcmVmaXg7XG4gICAgICByZW1vdmVBdXRvU2l6ZXIodGhpcy5lbGVtZW50LCBwcmVmaXgpO1xuICAgIH1cbiAgfTtcblxuICBfX3Byb3RvLm9uRXJyb3IgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgdGhpcy50cmlnZ2VyKFwiZXJyb3JcIiwge1xuICAgICAgZWxlbWVudDogdGhpcy5lbGVtZW50LFxuICAgICAgdGFyZ2V0OiB0YXJnZXRcbiAgICB9KTtcbiAgfTtcblxuICBfX3Byb3RvLm9uUHJlUmVhZHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuaXNQcmVSZWFkeSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuaXNQcmVSZWFkeSA9IHRydWU7XG4gICAgdGhpcy50cmlnZ2VyKFwicHJlUmVhZHlcIiwge1xuICAgICAgZWxlbWVudDogdGhpcy5lbGVtZW50LFxuICAgICAgaGFzTG9hZGluZzogdGhpcy5oYXNMb2FkaW5nLFxuICAgICAgaXNTa2lwOiB0aGlzLmlzU2tpcFxuICAgIH0pO1xuICB9O1xuXG4gIF9fcHJvdG8ub25SZWFkeSA9IGZ1bmN0aW9uICh3aXRoUHJlUmVhZHkpIHtcbiAgICBpZiAodGhpcy5pc1JlYWR5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2l0aFByZVJlYWR5ID0gIXRoaXMuaXNQcmVSZWFkeSAmJiB3aXRoUHJlUmVhZHk7XG5cbiAgICBpZiAod2l0aFByZVJlYWR5KSB7XG4gICAgICB0aGlzLmlzUHJlUmVhZHkgPSB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMucmVtb3ZlQXV0b1NpemVyKCk7XG4gICAgdGhpcy5pc1JlYWR5ID0gdHJ1ZTtcbiAgICB0aGlzLnRyaWdnZXIoXCJyZWFkeVwiLCB7XG4gICAgICBlbGVtZW50OiB0aGlzLmVsZW1lbnQsXG4gICAgICB3aXRoUHJlUmVhZHk6IHdpdGhQcmVSZWFkeSxcbiAgICAgIGhhc0xvYWRpbmc6IHRoaXMuaGFzTG9hZGluZyxcbiAgICAgIGlzU2tpcDogdGhpcy5pc1NraXBcbiAgICB9KTtcbiAgfTtcblxuICBfX3Byb3RvLm9uQWxyZWFkeUVycm9yID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLm9uRXJyb3IodGFyZ2V0KTtcbiAgICB9KTtcbiAgfTtcblxuICBfX3Byb3RvLm9uQWxyZWFkeVByZVJlYWR5ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLm9uUHJlUmVhZHkoKTtcbiAgICB9KTtcbiAgfTtcblxuICBfX3Byb3RvLm9uQWxyZWFkeVJlYWR5ID0gZnVuY3Rpb24gKHdpdGhQcmVSZWFkeSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLm9uUmVhZHkod2l0aFByZVJlYWR5KTtcbiAgICB9KTtcbiAgfTtcblxuICBMb2FkZXIuRVZFTlRTID0gW107XG4gIHJldHVybiBMb2FkZXI7XG59KENvbXBvbmVudCk7XG5cbnZhciBFbGVtZW50TG9hZGVyID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzJDIoRWxlbWVudExvYWRlciwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBFbGVtZW50TG9hZGVyKCkge1xuICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfX3Byb3RvID0gRWxlbWVudExvYWRlci5wcm90b3R5cGU7XG5cbiAgX19wcm90by5zZXRIYXNMb2FkaW5nID0gZnVuY3Rpb24gKGhhc0xvYWRpbmcpIHtcbiAgICB0aGlzLmhhc0xvYWRpbmcgPSBoYXNMb2FkaW5nO1xuICB9O1xuXG4gIF9fcHJvdG8uY2hlY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuaXNTa2lwKSB7XG4gICAgICAvLyBJJ20gUmVhZHlcbiAgICAgIHRoaXMub25BbHJlYWR5UmVhZHkodHJ1ZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaGFzRGF0YVNpemUpIHtcbiAgICAgIGFkZEF1dG9TaXplcih0aGlzLmVsZW1lbnQsIHRoaXMub3B0aW9ucy5wcmVmaXgpO1xuICAgICAgdGhpcy5vbkFscmVhZHlQcmVSZWFkeSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBoYXMgbm90IGRhdGEgc2l6ZVxuICAgICAgdGhpcy50cmlnZ2VyKFwicmVxdWVzdENoaWxkcmVuXCIpO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIF9fcHJvdG8uY2hlY2tFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIF9fcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNsZWFyKCk7XG4gICAgdGhpcy50cmlnZ2VyKFwicmVxdWVzdERlc3Ryb3lcIik7XG4gICAgdGhpcy5vZmYoKTtcbiAgfTtcblxuICBfX3Byb3RvLm9uQWxyZWFkeVByZVJlYWR5ID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIGhhcyBkYXRhIHNpemVcbiAgICBfc3VwZXIucHJvdG90eXBlLm9uQWxyZWFkeVByZVJlYWR5LmNhbGwodGhpcyk7XG5cbiAgICB0aGlzLnRyaWdnZXIoXCJyZXFldXN0UmVhZHlDaGlsZHJlblwiKTtcbiAgfTtcblxuICBFbGVtZW50TG9hZGVyLkVWRU5UUyA9IFtdO1xuICByZXR1cm4gRWxlbWVudExvYWRlcjtcbn0oTG9hZGVyKTtcblxuLyoqXG4gKiBAYWxpYXMgZWcuSW1SZWFkeVxuICogQGV4dGVuZHMgZWcuQ29tcG9uZW50XG4gKi9cblxudmFyIEltUmVhZHlNYW5hZ2VyID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzJDIoSW1SZWFkeU1hbmFnZXIsIF9zdXBlcik7XG4gIC8qKlxuICAgKiBAcGFyYW0gLSBJbVJlYWR5J3Mgb3B0aW9uc1xuICAgKi9cblxuXG4gIGZ1bmN0aW9uIEltUmVhZHlNYW5hZ2VyKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcblxuICAgIF90aGlzLnJlYWR5Q291bnQgPSAwO1xuICAgIF90aGlzLnByZVJlYWR5Q291bnQgPSAwO1xuICAgIF90aGlzLnRvdGFsQ291bnQgPSAwO1xuICAgIF90aGlzLnRvdGFsRXJyb3JDb3VudCA9IDA7XG4gICAgX3RoaXMuaXNQcmVSZWFkeU92ZXIgPSB0cnVlO1xuICAgIF90aGlzLmVsZW1lbnRJbmZvcyA9IFtdO1xuICAgIF90aGlzLm9wdGlvbnMgPSBfX2Fzc2lnbiQxKHtcbiAgICAgIGxvYWRlcnM6IHt9LFxuICAgICAgcHJlZml4OiBcImRhdGEtXCJcbiAgICB9LCBvcHRpb25zKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIGVsZW1lbnRzIGFyZSBpbiB0aGUgcmVhZHkgc3RhdGUuXG4gICAqIEBrbyDsl5jrpqzrqLztirjqsIAg7KSA67mEIOyDge2DnOyduOyngCDssrTtgaztlZzri6QuXG4gICAqIEBlbGVtZW50cyAtIEVsZW1lbnRzIHRvIGNoZWNrIHJlYWR5IHN0YXR1cy4gPGtvPiDspIDruYQg7IOB7YOc66W8IOyytO2BrO2VoCDsl5jrpqzrqLztirjrk6QuPC9rbz5cbiAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdj5cbiAgICAgKiAgICA8aW1nIHNyYz1cIi4vMS5qcGdcIiBkYXRhLXdpZHRoPVwiMTI4MFwiIGRhdGEtaGVpZ2h0PVwiODUzXCIgc3R5bGU9XCJ3aWR0aDoxMDAlXCIvPlxuICAgICAqICAgIDxpbWcgc3JjPVwiLi8yLmpwZ1wiIGRhdGEtd2lkdGg9XCIxMjgwXCIgZGF0YS1oZWlnaHQ9XCI4NTNcIi8+XG4gICAgICogICAgPGltZyBzcmM9XCJFUlJcIiBkYXRhLXdpZHRoPVwiMTI4MFwiIGRhdGEtaGVpZ2h0PVwiODUzXCIvPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqICMjIEphdmFzY3JpcHRcbiAgICAgKiBgYGBqc1xuICAgICAqIGltcG9ydCBJbVJlYWR5IGZyb20gXCJAZWdqcy9pbXJlYWR5XCI7XG4gICAgICpcbiAgICAgKiBjb25zdCBpbSA9IG5ldyBJbVJlYWR5KCk7IC8vIHVtZDogZWcuSW1SZWFkeVxuICAgICAqIGltLmNoZWNrKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJpbWdcIikpLm9uKHtcbiAgICAgKiAgIHByZVJlYWR5RWxlbWVudDogZSA9PiB7XG4gICAgICogICAgIC8vIDEsIDNcbiAgICAgKiAgICAgLy8gMiwgM1xuICAgICAqICAgICAvLyAzLCAzXG4gICAgICogICAgIGNvbnNvbGUubG9nKGUucHJlUmVhZHlDb3VudCwgZS50b3RhbENvdW50KSxcbiAgICAgKiAgIH0sXG4gICAgICogfSk7XG4gICAgICogYGBgXG4gICAqL1xuXG5cbiAgdmFyIF9fcHJvdG8gPSBJbVJlYWR5TWFuYWdlci5wcm90b3R5cGU7XG5cbiAgX19wcm90by5jaGVjayA9IGZ1bmN0aW9uIChlbGVtZW50cykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgcHJlZml4ID0gdGhpcy5vcHRpb25zLnByZWZpeDtcbiAgICB0aGlzLmNsZWFyKCk7XG4gICAgdGhpcy5lbGVtZW50SW5mb3MgPSB0b0FycmF5JDEoZWxlbWVudHMpLm1hcChmdW5jdGlvbiAoZWxlbWVudCwgaW5kZXgpIHtcbiAgICAgIHZhciBsb2FkZXIgPSBfdGhpcy5nZXRMb2FkZXIoZWxlbWVudCwge1xuICAgICAgICBwcmVmaXg6IHByZWZpeFxuICAgICAgfSk7XG5cbiAgICAgIGxvYWRlci5jaGVjaygpO1xuICAgICAgbG9hZGVyLm9uKFwiZXJyb3JcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgX3RoaXMub25FcnJvcihpbmRleCwgZS50YXJnZXQpO1xuICAgICAgfSkub24oXCJwcmVSZWFkeVwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgaW5mbyA9IF90aGlzLmVsZW1lbnRJbmZvc1tpbmRleF07XG4gICAgICAgIGluZm8uaGFzTG9hZGluZyA9IGUuaGFzTG9hZGluZztcbiAgICAgICAgaW5mby5pc1NraXAgPSBlLmlzU2tpcDtcblxuICAgICAgICB2YXIgaXNQcmVSZWFkeSA9IF90aGlzLmNoZWNrUHJlUmVhZHkoaW5kZXgpO1xuXG4gICAgICAgIF90aGlzLm9uUHJlUmVhZHlFbGVtZW50KGluZGV4KTtcblxuICAgICAgICBpc1ByZVJlYWR5ICYmIF90aGlzLm9uUHJlUmVhZHkoKTtcbiAgICAgIH0pLm9uKFwicmVhZHlcIiwgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciB3aXRoUHJlUmVhZHkgPSBfYS53aXRoUHJlUmVhZHksXG4gICAgICAgICAgICBoYXNMb2FkaW5nID0gX2EuaGFzTG9hZGluZyxcbiAgICAgICAgICAgIGlzU2tpcCA9IF9hLmlzU2tpcDtcbiAgICAgICAgdmFyIGluZm8gPSBfdGhpcy5lbGVtZW50SW5mb3NbaW5kZXhdO1xuICAgICAgICBpbmZvLmhhc0xvYWRpbmcgPSBoYXNMb2FkaW5nO1xuICAgICAgICBpbmZvLmlzU2tpcCA9IGlzU2tpcDtcblxuICAgICAgICB2YXIgaXNQcmVSZWFkeSA9IHdpdGhQcmVSZWFkeSAmJiBfdGhpcy5jaGVja1ByZVJlYWR5KGluZGV4KTtcblxuICAgICAgICB2YXIgaXNSZWFkeSA9IF90aGlzLmNoZWNrUmVhZHkoaW5kZXgpOyAvLyBQcmUtcmVhZHkgYW5kIHJlYWR5IG9jY3VyIHNpbXVsdGFuZW91c2x5XG5cblxuICAgICAgICB3aXRoUHJlUmVhZHkgJiYgX3RoaXMub25QcmVSZWFkeUVsZW1lbnQoaW5kZXgpO1xuXG4gICAgICAgIF90aGlzLm9uUmVhZHlFbGVtZW50KGluZGV4KTtcblxuICAgICAgICBpc1ByZVJlYWR5ICYmIF90aGlzLm9uUHJlUmVhZHkoKTtcbiAgICAgICAgaXNSZWFkeSAmJiBfdGhpcy5vblJlYWR5KCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxvYWRlcjogbG9hZGVyLFxuICAgICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgICBoYXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgaGFzRXJyb3I6IGZhbHNlLFxuICAgICAgICBpc1ByZVJlYWR5OiBmYWxzZSxcbiAgICAgICAgaXNSZWFkeTogZmFsc2UsXG4gICAgICAgIGlzU2tpcDogZmFsc2VcbiAgICAgIH07XG4gICAgfSk7XG4gICAgdmFyIGxlbmd0aCA9IHRoaXMuZWxlbWVudEluZm9zLmxlbmd0aDtcbiAgICB0aGlzLnRvdGFsQ291bnQgPSBsZW5ndGg7XG5cbiAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLm9uUHJlUmVhZHkoKTtcblxuICAgICAgICBfdGhpcy5vblJlYWR5KCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXG4gICAqIEdldHMgdGhlIHRvdGFsIGNvdW50IG9mIGVsZW1lbnRzIHRvIGJlIGNoZWNrZWQuXG4gICAqIEBrbyDssrTtgaztlZjripQgZWxlbWVudOydmCDstJ0g6rCc7IiY66W8IOqwgOyguOyYqOuLpC5cbiAgICovXG5cblxuICBfX3Byb3RvLmdldFRvdGFsQ291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudG90YWxDb3VudDtcbiAgfTtcbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIGVsZW1lbnRzIGFyZSBhbGwgcHJlLXJlYWR5LiAoYWxsIHNpemVzIGFyZSBrbm93bilcbiAgICogQGtvIOyXmOumrOuovO2KuOuTpOydtCDrqqjrkZAg7IKs7KCEIOykgOu5hOqwgCDrkJDripTsp4AgKOyCrOydtOymiOulvCDsoITrtoAg7JWMIOyImCDsnojripTsp4ApIOyXrOu2gC5cbiAgICovXG5cblxuICBfX3Byb3RvLmlzUHJlUmVhZHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudEluZm9zLmV2ZXJ5KGZ1bmN0aW9uIChpbmZvKSB7XG4gICAgICByZXR1cm4gaW5mby5pc1ByZVJlYWR5O1xuICAgIH0pO1xuICB9O1xuICAvKipcbiAgICogV2hldGhlciB0aGUgZWxlbWVudHMgYXJlIGFsbCByZWFkeS5cbiAgICogQGtvIOyXmOumrOuovO2KuOuTpOydtCDrqqjrkZAg7KSA67mE6rCAIOuQkOuKlOyngCDsl6zrtoAuXG4gICAqL1xuXG5cbiAgX19wcm90by5pc1JlYWR5ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnRJbmZvcy5ldmVyeShmdW5jdGlvbiAoaW5mbykge1xuICAgICAgcmV0dXJuIGluZm8uaXNSZWFkeTtcbiAgICB9KTtcbiAgfTtcbiAgLyoqXG4gICAqIFdoZXRoZXIgYW4gZXJyb3IgaGFzIG9jY3VycmVkIGluIHRoZSBlbGVtZW50cyBpbiB0aGUgY3VycmVudCBzdGF0ZS5cbiAgICogQGtvIO2YhOyerCDsg4Htg5zsl5DshJwg7JeY66as66i87Yq465Ok7J20IOyXkOufrOqwgCDrsJzsg53tlojripTsp4Ag7Jes67aALlxuICAgKi9cblxuXG4gIF9fcHJvdG8uaGFzRXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudG90YWxFcnJvckNvdW50ID4gMDtcbiAgfTtcbiAgLyoqXG4gICAqIENsZWFycyBldmVudHMgb2YgZWxlbWVudHMgYmVpbmcgY2hlY2tlZC5cbiAgICogQGtvIOyytO2BrCDspJHsnbgg7JeY66as66i87Yq465Ok7J2YIOydtOuypO2KuOulvCDtlbTsoJwg7ZWc64ukLlxuICAgKi9cblxuXG4gIF9fcHJvdG8uY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5pc1ByZVJlYWR5T3ZlciA9IGZhbHNlO1xuICAgIHRoaXMudG90YWxDb3VudCA9IDA7XG4gICAgdGhpcy5wcmVSZWFkeUNvdW50ID0gMDtcbiAgICB0aGlzLnJlYWR5Q291bnQgPSAwO1xuICAgIHRoaXMudG90YWxFcnJvckNvdW50ID0gMDtcbiAgICB0aGlzLmVsZW1lbnRJbmZvcy5mb3JFYWNoKGZ1bmN0aW9uIChpbmZvKSB7XG4gICAgICBpZiAoaW5mby5sb2FkZXIpIHtcbiAgICAgICAgaW5mby5sb2FkZXIuZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuZWxlbWVudEluZm9zID0gW107XG4gIH07XG4gIC8qKlxuICAgKiBEZXN0b3J5IGFsbCBldmVudHMuXG4gICAqIEBrbyDrqqjrk6Ag7J2067Kk7Yq466W8IO2VtOygnCDtlZzri6QuXG4gICAqL1xuXG5cbiAgX19wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuY2xlYXIoKTtcbiAgICB0aGlzLm9mZigpO1xuICB9O1xuXG4gIF9fcHJvdG8uZ2V0TG9hZGVyID0gZnVuY3Rpb24gKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIHRhZ05hbWUgPSBlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgbG9hZGVycyA9IHRoaXMub3B0aW9ucy5sb2FkZXJzO1xuICAgIHZhciBwcmVmaXggPSBvcHRpb25zLnByZWZpeDtcbiAgICB2YXIgdGFncyA9IE9iamVjdC5rZXlzKGxvYWRlcnMpO1xuXG4gICAgaWYgKGxvYWRlcnNbdGFnTmFtZV0pIHtcbiAgICAgIHJldHVybiBuZXcgbG9hZGVyc1t0YWdOYW1lXShlbGVtZW50LCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICB2YXIgbG9hZGVyID0gbmV3IEVsZW1lbnRMb2FkZXIoZWxlbWVudCwgb3B0aW9ucyk7XG4gICAgdmFyIGNoaWxkcmVuID0gdG9BcnJheSQxKGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCh0YWdzLmpvaW4oXCIsIFwiKSkpO1xuICAgIGxvYWRlci5zZXRIYXNMb2FkaW5nKGNoaWxkcmVuLnNvbWUoZnVuY3Rpb24gKGVsKSB7XG4gICAgICByZXR1cm4gaGFzTG9hZGluZ0F0dHJpYnV0ZShlbCwgcHJlZml4KTtcbiAgICB9KSk7XG4gICAgdmFyIHdpdGhQcmVSZWFkeSA9IGZhbHNlO1xuICAgIHZhciBjaGlsZHJlbkltUmVhZHkgPSB0aGlzLmNsb25lKCkub24oXCJlcnJvclwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgbG9hZGVyLm9uRXJyb3IoZS50YXJnZXQpO1xuICAgIH0pLm9uKFwicmVhZHlcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgbG9hZGVyLm9uUmVhZHkod2l0aFByZVJlYWR5KTtcbiAgICB9KTtcbiAgICBsb2FkZXIub24oXCJyZXF1ZXN0Q2hpbGRyZW5cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgLy8gaGFzIG5vdCBkYXRhIHNpemVcbiAgICAgIHZhciBjb250ZW50RWxlbWVudHMgPSBnZXRDb250ZW50RWxlbWVudHMoZWxlbWVudCwgdGFncywgX3RoaXMub3B0aW9ucy5wcmVmaXgpO1xuICAgICAgY2hpbGRyZW5JbVJlYWR5LmNoZWNrKGNvbnRlbnRFbGVtZW50cykub24oXCJwcmVSZWFkeVwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICB3aXRoUHJlUmVhZHkgPSBlLmlzUmVhZHk7XG5cbiAgICAgICAgaWYgKCF3aXRoUHJlUmVhZHkpIHtcbiAgICAgICAgICBsb2FkZXIub25QcmVSZWFkeSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KS5vbihcInJlcWV1c3RSZWFkeUNoaWxkcmVuXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIGhhcyBkYXRhIHNpemVcbiAgICAgIC8vIGxvYWRlciBjYWxsIHByZVJlYWR5XG4gICAgICAvLyBjaGVjayBvbmx5IHZpZGVvLCBpbWFnZSBlbGVtZW50c1xuICAgICAgY2hpbGRyZW5JbVJlYWR5LmNoZWNrKGNoaWxkcmVuKTtcbiAgICB9KS5vbihcInJlcXVlc3REZXN0cm95XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNoaWxkcmVuSW1SZWFkeS5kZXN0cm95KCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGxvYWRlcjtcbiAgfTtcblxuICBfX3Byb3RvLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgSW1SZWFkeU1hbmFnZXIoX19hc3NpZ24kMSh7fSwgdGhpcy5vcHRpb25zKSk7XG4gIH07XG5cbiAgX19wcm90by5jaGVja1ByZVJlYWR5ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgdGhpcy5lbGVtZW50SW5mb3NbaW5kZXhdLmlzUHJlUmVhZHkgPSB0cnVlO1xuICAgICsrdGhpcy5wcmVSZWFkeUNvdW50O1xuXG4gICAgaWYgKHRoaXMucHJlUmVhZHlDb3VudCA8IHRoaXMudG90YWxDb3VudCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIF9fcHJvdG8uY2hlY2tSZWFkeSA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgIHRoaXMuZWxlbWVudEluZm9zW2luZGV4XS5pc1JlYWR5ID0gdHJ1ZTtcbiAgICArK3RoaXMucmVhZHlDb3VudDtcblxuICAgIGlmICh0aGlzLnJlYWR5Q291bnQgPCB0aGlzLnRvdGFsQ291bnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBfX3Byb3RvLm9uRXJyb3IgPSBmdW5jdGlvbiAoaW5kZXgsIHRhcmdldCkge1xuICAgIHZhciBpbmZvID0gdGhpcy5lbGVtZW50SW5mb3NbaW5kZXhdO1xuICAgIGluZm8uaGFzRXJyb3IgPSB0cnVlO1xuICAgIC8qKlxuICAgICAqIEFuIGV2ZW50IG9jY3VycyBpZiB0aGUgaW1hZ2UsIHZpZGVvIGZhaWxzIHRvIGxvYWQuXG4gICAgICogQGtvIOydtOuvuOyngCwg67mE65SU7Jik6rCAIOuhnOuUqeyXkCDsi6TtjKjtlZjrqbQg7J2067Kk7Yq46rCAIOuwnOyDne2VnOuLpC5cbiAgICAgKiBAZXZlbnQgZWcuSW1SZWFkeSNlcnJvclxuICAgICAqIEBwYXJhbSB7ZWcuSW1SZWFkeS5PbkVycm9yfSBlIC0gVGhlIG9iamVjdCBvZiBkYXRhIHRvIGJlIHNlbnQgdG8gYW4gZXZlbnQgPGtvPuydtOuypO2KuOyXkCDsoITri6zrkJjripQg642w7J207YSwIOqwneyytDwva28+XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdj5cbiAgICAgKiAgICA8aW1nIHNyYz1cIi4vMS5qcGdcIiBkYXRhLXdpZHRoPVwiMTI4MFwiIGRhdGEtaGVpZ2h0PVwiODUzXCIgc3R5bGU9XCJ3aWR0aDoxMDAlXCIvPlxuICAgICAqICAgIDxpbWcgc3JjPVwiLi8yLmpwZ1wiLz5cbiAgICAgKiAgICA8aW1nIHNyYz1cIkVSUlwiLz5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKiAjIyBKYXZhc2NyaXB0XG4gICAgICogYGBganNcbiAgICAgKiBpbXBvcnQgSW1SZWFkeSBmcm9tIFwiQGVnanMvaW1yZWFkeVwiO1xuICAgICAqXG4gICAgICogY29uc3QgaW0gPSBuZXcgSW1SZWFkeSgpOyAvLyB1bWQ6IGVnLkltUmVhZHlcbiAgICAgKiBpbS5jaGVjayhbZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcImRpdlwiKV0pLm9uKHtcbiAgICAgKiAgIGVycm9yOiBlID0+IHtcbiAgICAgKiAgICAgLy8gPGRpdj4uLi48L2Rpdj4sIDAsIDxpbWcgc3JjPVwiRVJSXCIvPlxuICAgICAqICAgICBjb25zb2xlLmxvZyhlLmVsZW1lbnQsIGUuaW5kZXgsIGUudGFyZ2V0KSxcbiAgICAgKiAgIH0sXG4gICAgICogfSk7XG4gICAgICogYGBgXG4gICAgICovXG5cbiAgICB0aGlzLnRyaWdnZXIobmV3IENvbXBvbmVudEV2ZW50JDEoXCJlcnJvclwiLCB7XG4gICAgICBlbGVtZW50OiBpbmZvLmVsZW1lbnQsXG4gICAgICBpbmRleDogaW5kZXgsXG4gICAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICAgIGVycm9yQ291bnQ6IHRoaXMuZ2V0RXJyb3JDb3VudCgpLFxuICAgICAgdG90YWxFcnJvckNvdW50OiArK3RoaXMudG90YWxFcnJvckNvdW50XG4gICAgfSkpO1xuICB9O1xuXG4gIF9fcHJvdG8ub25QcmVSZWFkeUVsZW1lbnQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICB2YXIgaW5mbyA9IHRoaXMuZWxlbWVudEluZm9zW2luZGV4XTtcbiAgICAvKipcbiAgICAgKiBBbiBldmVudCBvY2N1cnMgd2hlbiB0aGUgZWxlbWVudCBpcyBwcmUtcmVhZHkgKHdoZW4gdGhlIGxvYWRpbmcgYXR0cmlidXRlIGlzIGFwcGxpZWQgb3IgdGhlIHNpemUgaXMga25vd24pXG4gICAgICogQGtvIO2VtOuLuSDsl5jrpqzrqLztirjqsIAg7IKs7KCEIOykgOu5hOuQmOyXiOydhCDrlYwobG9hZGluZyDsho3shLHsnbQg7KCB7Jqp65CY7JeI6rGw64KYIOyCrOydtOymiOulvCDslYwg7IiYIOyeiOydhCDrlYwpIOydtOuypO2KuOqwgCDrsJzsg53tlZzri6QuXG4gICAgICogQGV2ZW50IGVnLkltUmVhZHkjcHJlUmVhZHlFbGVtZW50XG4gICAgICogQHBhcmFtIHtlZy5JbVJlYWR5Lk9uUHJlUmVhZHlFbGVtZW50fSBlIC0gVGhlIG9iamVjdCBvZiBkYXRhIHRvIGJlIHNlbnQgdG8gYW4gZXZlbnQgPGtvPuydtOuypO2KuOyXkCDsoITri6zrkJjripQg642w7J207YSwIOqwneyytDwva28+XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdj5cbiAgICAgKiAgICA8aW1nIHNyYz1cIi4vMS5qcGdcIiBkYXRhLXdpZHRoPVwiMTI4MFwiIGRhdGEtaGVpZ2h0PVwiODUzXCIgc3R5bGU9XCJ3aWR0aDoxMDAlXCIvPlxuICAgICAqICAgIDxpbWcgc3JjPVwiLi8yLmpwZ1wiIGRhdGEtd2lkdGg9XCIxMjgwXCIgZGF0YS1oZWlnaHQ9XCI4NTNcIi8+XG4gICAgICogICAgPGltZyBzcmM9XCJFUlJcIiBkYXRhLXdpZHRoPVwiMTI4MFwiIGRhdGEtaGVpZ2h0PVwiODUzXCIvPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqICMjIEphdmFzY3JpcHRcbiAgICAgKiBgYGBqc1xuICAgICAqIGltcG9ydCBJbVJlYWR5IGZyb20gXCJAZWdqcy9pbXJlYWR5XCI7XG4gICAgICpcbiAgICAgKiBjb25zdCBpbSA9IG5ldyBJbVJlYWR5KCk7IC8vIHVtZDogZWcuSW1SZWFkeVxuICAgICAqIGltLmNoZWNrKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJpbWdcIikpLm9uKHtcbiAgICAgKiAgIHByZVJlYWR5RWxlbWVudDogZSA9PiB7XG4gICAgICogICAgIC8vIDEsIDNcbiAgICAgKiAgICAgLy8gMiwgM1xuICAgICAqICAgICAvLyAzLCAzXG4gICAgICogICAgIGNvbnNvbGUubG9nKGUucHJlUmVhZHlDb3VudCwgZS50b3RhbENvdW50KSxcbiAgICAgKiAgIH0sXG4gICAgICogfSk7XG4gICAgICogYGBgXG4gICAgICovXG5cbiAgICB0aGlzLnRyaWdnZXIobmV3IENvbXBvbmVudEV2ZW50JDEoXCJwcmVSZWFkeUVsZW1lbnRcIiwge1xuICAgICAgZWxlbWVudDogaW5mby5lbGVtZW50LFxuICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgcHJlUmVhZHlDb3VudDogdGhpcy5wcmVSZWFkeUNvdW50LFxuICAgICAgcmVhZHlDb3VudDogdGhpcy5yZWFkeUNvdW50LFxuICAgICAgdG90YWxDb3VudDogdGhpcy50b3RhbENvdW50LFxuICAgICAgaXNQcmVSZWFkeTogdGhpcy5pc1ByZVJlYWR5KCksXG4gICAgICBpc1JlYWR5OiB0aGlzLmlzUmVhZHkoKSxcbiAgICAgIGhhc0xvYWRpbmc6IGluZm8uaGFzTG9hZGluZyxcbiAgICAgIGlzU2tpcDogaW5mby5pc1NraXBcbiAgICB9KSk7XG4gIH07XG5cbiAgX19wcm90by5vblByZVJlYWR5ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaXNQcmVSZWFkeU92ZXIgPSB0cnVlO1xuICAgIC8qKlxuICAgICAqIEFuIGV2ZW50IG9jY3VycyB3aGVuIGFsbCBlbGVtZW50IGFyZSBwcmUtcmVhZHkgKFdoZW4gYWxsIGVsZW1lbnRzIGhhdmUgdGhlIGxvYWRpbmcgYXR0cmlidXRlIGFwcGxpZWQgb3IgdGhlIHNpemUgaXMga25vd24pXG4gICAgICogQGtvIOuqqOuToCDsl5jrpqzrqLztirjrk6TsnbQg7IKs7KCEIOykgOu5hOuQnCDqsr3smrAgKOuqqOuToCDsl5jrpqzrqLztirjrk6TsnbQgbG9hZGluZyDsho3shLHsnbQg7KCB7Jqp65CY7JeI6rGw64KYIOyCrOydtOymiOulvCDslYwg7IiYIOyeiOuKlCDqsr3smrApIOydtOuypO2KuOqwgCDrsJzsg53tlZzri6QuXG4gICAgICogQGV2ZW50IGVnLkltUmVhZHkjcHJlUmVhZHlcbiAgICAgKiBAcGFyYW0ge2VnLkltUmVhZHkuT25QcmVSZWFkeX0gZSAtIFRoZSBvYmplY3Qgb2YgZGF0YSB0byBiZSBzZW50IHRvIGFuIGV2ZW50IDxrbz7snbTrsqTtirjsl5Ag7KCE64us65CY64qUIOuNsOydtO2EsCDqsJ3ssrQ8L2tvPlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXY+XG4gICAgICogICAgPGltZyBzcmM9XCIuLzEuanBnXCIgZGF0YS13aWR0aD1cIjEyODBcIiBkYXRhLWhlaWdodD1cIjg1M1wiIHN0eWxlPVwid2lkdGg6MTAwJVwiLz5cbiAgICAgKiAgICA8aW1nIHNyYz1cIi4vMi5qcGdcIiBkYXRhLXdpZHRoPVwiMTI4MFwiIGRhdGEtaGVpZ2h0PVwiODUzXCIvPlxuICAgICAqICAgIDxpbWcgc3JjPVwiRVJSXCIgZGF0YS13aWR0aD1cIjEyODBcIiBkYXRhLWhlaWdodD1cIjg1M1wiLz5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKiAjIyBKYXZhc2NyaXB0XG4gICAgICogYGBganNcbiAgICAgKiBpbXBvcnQgSW1SZWFkeSBmcm9tIFwiQGVnanMvaW1yZWFkeVwiO1xuICAgICAqXG4gICAgICogY29uc3QgaW0gPSBuZXcgSW1SZWFkeSgpOyAvLyB1bWQ6IGVnLkltUmVhZHlcbiAgICAgKiBpbS5jaGVjayhkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiaW1nXCIpKS5vbih7XG4gICAgICogICBwcmVSZWFkeTogZSA9PiB7XG4gICAgICogICAgIC8vIDAsIDNcbiAgICAgKiAgICAgY29uc29sZS5sb2coZS5yZWFkeUNvdW50LCBlLnRvdGFsQ291bnQpLFxuICAgICAqICAgfSxcbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cblxuICAgIHRoaXMudHJpZ2dlcihuZXcgQ29tcG9uZW50RXZlbnQkMShcInByZVJlYWR5XCIsIHtcbiAgICAgIHJlYWR5Q291bnQ6IHRoaXMucmVhZHlDb3VudCxcbiAgICAgIHRvdGFsQ291bnQ6IHRoaXMudG90YWxDb3VudCxcbiAgICAgIGlzUmVhZHk6IHRoaXMuaXNSZWFkeSgpLFxuICAgICAgaGFzTG9hZGluZzogdGhpcy5oYXNMb2FkaW5nKClcbiAgICB9KSk7XG4gIH07XG5cbiAgX19wcm90by5vblJlYWR5RWxlbWVudCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgIHZhciBpbmZvID0gdGhpcy5lbGVtZW50SW5mb3NbaW5kZXhdO1xuICAgIC8qKlxuICAgICAqIEFuIGV2ZW50IG9jY3VycyB3aGVuIHRoZSBlbGVtZW50IGlzIHJlYWR5XG4gICAgICogQGtvIO2VtOuLuSDsl5jrpqzrqLztirjqsIAg7KSA67mE6rCAIOuQmOyXiOydhCDrlYwg7J2067Kk7Yq46rCAIOuwnOyDne2VnOuLpC5cbiAgICAgKiBAZXZlbnQgZWcuSW1SZWFkeSNyZWFkeUVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge2VnLkltUmVhZHkuT25SZWFkeUVsZW1lbnR9IGUgLSBUaGUgb2JqZWN0IG9mIGRhdGEgdG8gYmUgc2VudCB0byBhbiBldmVudCA8a28+7J2067Kk7Yq47JeQIOyghOuLrOuQmOuKlCDrjbDsnbTthLAg6rCd7LK0PC9rbz5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2PlxuICAgICAqICAgIDxpbWcgc3JjPVwiLi8xLmpwZ1wiIGRhdGEtd2lkdGg9XCIxMjgwXCIgZGF0YS1oZWlnaHQ9XCI4NTNcIiBzdHlsZT1cIndpZHRoOjEwMCVcIi8+XG4gICAgICogICAgPGltZyBzcmM9XCIuLzIuanBnXCIgZGF0YS13aWR0aD1cIjEyODBcIiBkYXRhLWhlaWdodD1cIjg1M1wiLz5cbiAgICAgKiAgICA8aW1nIHNyYz1cIkVSUlwiIGRhdGEtd2lkdGg9XCIxMjgwXCIgZGF0YS1oZWlnaHQ9XCI4NTNcIi8+XG4gICAgICogPC9kaXY+XG4gICAgICogYGBgXG4gICAgICogIyMgSmF2YXNjcmlwdFxuICAgICAqIGBgYGpzXG4gICAgICogaW1wb3J0IEltUmVhZHkgZnJvbSBcIkBlZ2pzL2ltcmVhZHlcIjtcbiAgICAgKlxuICAgICAqIGNvbnN0IGltID0gbmV3IEltUmVhZHkoKTsgLy8gdW1kOiBlZy5JbVJlYWR5XG4gICAgICogaW0uY2hlY2soZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcImltZ1wiKSkub24oe1xuICAgICAqICAgcmVhZHlFbGVtZW50OiBlID0+IHtcbiAgICAgKiAgICAgLy8gMSwgMCwgZmFsc2UsIDNcbiAgICAgKiAgICAgLy8gMiwgMSwgZmFsc2UsIDNcbiAgICAgKiAgICAgLy8gMywgMiwgdHJ1ZSwgM1xuICAgICAqICAgICBjb25zb2xlLmxvZyhlLnJlYWR5Q291bnQsIGUuaW5kZXgsIGUuaGFzRXJyb3IsIGUudG90YWxDb3VudCksXG4gICAgICogICB9LFxuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqL1xuXG4gICAgdGhpcy50cmlnZ2VyKG5ldyBDb21wb25lbnRFdmVudCQxKFwicmVhZHlFbGVtZW50XCIsIHtcbiAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgIGVsZW1lbnQ6IGluZm8uZWxlbWVudCxcbiAgICAgIGhhc0Vycm9yOiBpbmZvLmhhc0Vycm9yLFxuICAgICAgZXJyb3JDb3VudDogdGhpcy5nZXRFcnJvckNvdW50KCksXG4gICAgICB0b3RhbEVycm9yQ291bnQ6IHRoaXMudG90YWxFcnJvckNvdW50LFxuICAgICAgcHJlUmVhZHlDb3VudDogdGhpcy5wcmVSZWFkeUNvdW50LFxuICAgICAgcmVhZHlDb3VudDogdGhpcy5yZWFkeUNvdW50LFxuICAgICAgdG90YWxDb3VudDogdGhpcy50b3RhbENvdW50LFxuICAgICAgaXNQcmVSZWFkeTogdGhpcy5pc1ByZVJlYWR5KCksXG4gICAgICBpc1JlYWR5OiB0aGlzLmlzUmVhZHkoKSxcbiAgICAgIGhhc0xvYWRpbmc6IGluZm8uaGFzTG9hZGluZyxcbiAgICAgIGlzUHJlUmVhZHlPdmVyOiB0aGlzLmlzUHJlUmVhZHlPdmVyLFxuICAgICAgaXNTa2lwOiBpbmZvLmlzU2tpcFxuICAgIH0pKTtcbiAgfTtcblxuICBfX3Byb3RvLm9uUmVhZHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQW4gZXZlbnQgb2NjdXJzIHdoZW4gYWxsIGVsZW1lbnQgYXJlIHJlYWR5XG4gICAgICogQGtvIOuqqOuToCDsl5jrpqzrqLztirjrk6TsnbQg7KSA67mE65CcIOqyveyasCDsnbTrsqTtirjqsIAg67Cc7IOd7ZWc64ukLlxuICAgICAqIEBldmVudCBlZy5JbVJlYWR5I3JlYWR5XG4gICAgICogQHBhcmFtIHtlZy5JbVJlYWR5Lk9uUmVhZHl9IGUgLSBUaGUgb2JqZWN0IG9mIGRhdGEgdG8gYmUgc2VudCB0byBhbiBldmVudCA8a28+7J2067Kk7Yq47JeQIOyghOuLrOuQmOuKlCDrjbDsnbTthLAg6rCd7LK0PC9rbz5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2PlxuICAgICAqICAgIDxpbWcgc3JjPVwiLi8xLmpwZ1wiIGRhdGEtd2lkdGg9XCIxMjgwXCIgZGF0YS1oZWlnaHQ9XCI4NTNcIiBzdHlsZT1cIndpZHRoOjEwMCVcIi8+XG4gICAgICogICAgPGltZyBzcmM9XCIuLzIuanBnXCIgZGF0YS13aWR0aD1cIjEyODBcIiBkYXRhLWhlaWdodD1cIjg1M1wiLz5cbiAgICAgKiAgICA8aW1nIHNyYz1cIkVSUlwiIGRhdGEtd2lkdGg9XCIxMjgwXCIgZGF0YS1oZWlnaHQ9XCI4NTNcIi8+XG4gICAgICogPC9kaXY+XG4gICAgICogYGBgXG4gICAgICogIyMgSmF2YXNjcmlwdFxuICAgICAqIGBgYGpzXG4gICAgICogaW1wb3J0IEltUmVhZHkgZnJvbSBcIkBlZ2pzL2ltcmVhZHlcIjtcbiAgICAgKlxuICAgICAqIGNvbnN0IGltID0gbmV3IEltUmVhZHkoKTsgLy8gdW1kOiBlZy5JbVJlYWR5XG4gICAgICogaW0uY2hlY2soZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcImltZ1wiKSkub24oe1xuICAgICAqICAgcHJlUmVhZHk6IGUgPT4ge1xuICAgICAqICAgICAvLyAwLCAzXG4gICAgICogICAgIGNvbnNvbGUubG9nKGUucmVhZHlDb3VudCwgZS50b3RhbENvdW50KSxcbiAgICAgKiAgIH0sXG4gICAgICogICByZWFkeTogZSA9PiB7XG4gICAgICogICAgIC8vIDEsIDNcbiAgICAgKiAgICAgY29uc29sZS5sb2coZS5lcnJvckNvdW50LCBlLnRvdGFsQ291bnQpLFxuICAgICAqICAgfSxcbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICB0aGlzLnRyaWdnZXIobmV3IENvbXBvbmVudEV2ZW50JDEoXCJyZWFkeVwiLCB7XG4gICAgICBlcnJvckNvdW50OiB0aGlzLmdldEVycm9yQ291bnQoKSxcbiAgICAgIHRvdGFsRXJyb3JDb3VudDogdGhpcy50b3RhbEVycm9yQ291bnQsXG4gICAgICB0b3RhbENvdW50OiB0aGlzLnRvdGFsQ291bnRcbiAgICB9KSk7XG4gIH07XG5cbiAgX19wcm90by5nZXRFcnJvckNvdW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnRJbmZvcy5maWx0ZXIoZnVuY3Rpb24gKGluZm8pIHtcbiAgICAgIHJldHVybiBpbmZvLmhhc0Vycm9yO1xuICAgIH0pLmxlbmd0aDtcbiAgfTtcblxuICBfX3Byb3RvLmhhc0xvYWRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudEluZm9zLnNvbWUoZnVuY3Rpb24gKGluZm8pIHtcbiAgICAgIHJldHVybiBpbmZvLmhhc0xvYWRpbmc7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIEltUmVhZHlNYW5hZ2VyO1xufShDb21wb25lbnQpO1xuXG52YXIgSW1hZ2VMb2FkZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMkMihJbWFnZUxvYWRlciwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBJbWFnZUxvYWRlcigpIHtcbiAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX19wcm90byA9IEltYWdlTG9hZGVyLnByb3RvdHlwZTtcblxuICBfX3Byb3RvLmNoZWNrRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcbiAgICB2YXIgc3JjID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJzcmNcIik7XG5cbiAgICBpZiAoZWxlbWVudC5jb21wbGV0ZSkge1xuICAgICAgaWYgKHNyYykge1xuICAgICAgICAvLyBjb21wbGV0ZVxuICAgICAgICBpZiAoIWVsZW1lbnQubmF0dXJhbFdpZHRoKSB7XG4gICAgICAgICAgdGhpcy5vbkFscmVhZHlFcnJvcihlbGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFVzaW5nIGFuIGV4dGVybmFsIGxhenkgbG9hZGluZyBtb2R1bGVcbiAgICAgICAgdGhpcy5vbkFscmVhZHlQcmVSZWFkeSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuYWRkRXZlbnRzKCk7XG4gICAgSVNfSUUgJiYgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJzcmNcIiwgc3JjKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBJbWFnZUxvYWRlci5FVkVOVFMgPSBbXCJsb2FkXCIsIFwiZXJyb3JcIl07XG4gIHJldHVybiBJbWFnZUxvYWRlcjtcbn0oTG9hZGVyKTtcblxudmFyIFZpZGVvTG9hZGVyID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzJDIoVmlkZW9Mb2FkZXIsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gVmlkZW9Mb2FkZXIoKSB7XG4gICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9fcHJvdG8gPSBWaWRlb0xvYWRlci5wcm90b3R5cGU7XG5cbiAgX19wcm90by5jaGVja0VsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7IC8vIEhBVkVfTk9USElORzogMCwgbm8gaW5mb3JtYXRpb24gd2hldGhlciBvciBub3QgdGhlIGF1ZGlvL3ZpZGVvIGlzIHJlYWR5XG4gICAgLy8gSEFWRV9NRVRBREFUQTogMSwgSEFWRV9NRVRBREFUQSAtIG1ldGFkYXRhIGZvciB0aGUgYXVkaW8vdmlkZW8gaXMgcmVhZHlcbiAgICAvLyBIQVZFX0NVUlJFTlRfREFUQTogMiwgZGF0YSBmb3IgdGhlIGN1cnJlbnQgcGxheWJhY2sgcG9zaXRpb24gaXMgYXZhaWxhYmxlLCBidXQgbm90IGVub3VnaCBkYXRhIHRvIHBsYXkgbmV4dCBmcmFtZS9taWxsaXNlY29uZFxuICAgIC8vIEhBVkVfRlVUVVJFX0RBVEE6IDMsIGRhdGEgZm9yIHRoZSBjdXJyZW50IGFuZCBhdCBsZWFzdCB0aGUgbmV4dCBmcmFtZSBpcyBhdmFpbGFibGVcbiAgICAvLyBIQVZFX0VOT1VHSF9EQVRBOiA0LCBlbm91Z2ggZGF0YSBhdmFpbGFibGUgdG8gc3RhcnQgcGxheWluZ1xuXG4gICAgaWYgKGVsZW1lbnQucmVhZHlTdGF0ZSA+PSAxKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGVsZW1lbnQuZXJyb3IpIHtcbiAgICAgIHRoaXMub25BbHJlYWR5RXJyb3IoZWxlbWVudCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5hZGRFdmVudHMoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBWaWRlb0xvYWRlci5FVkVOVFMgPSBbXCJsb2FkZWRtZXRhZGF0YVwiLCBcImVycm9yXCJdO1xuICByZXR1cm4gVmlkZW9Mb2FkZXI7XG59KExvYWRlcik7XG5cbnZhciBJbVJlYWR5ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzJDIoSW1SZWFkeSwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBJbVJlYWR5KG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIF9fYXNzaWduJDEoe1xuICAgICAgbG9hZGVyczoge1xuICAgICAgICBpbWc6IEltYWdlTG9hZGVyLFxuICAgICAgICB2aWRlbzogVmlkZW9Mb2FkZXJcbiAgICAgIH1cbiAgICB9LCBvcHRpb25zKSkgfHwgdGhpcztcbiAgfVxuXG4gIHJldHVybiBJbVJlYWR5O1xufShJbVJlYWR5TWFuYWdlcik7XG5cbi8qXG5Db3B5cmlnaHQgKGMpIDIwMTUtcHJlc2VudCBOQVZFUiBDb3JwLlxubmFtZTogQGVnanMvZmxpY2tpbmdcbmxpY2Vuc2U6IE1JVFxuYXV0aG9yOiBOQVZFUiBDb3JwLlxucmVwb3NpdG9yeTogaHR0cHM6Ly9naXRodWIuY29tL25hdmVyL2VnanMtZmxpY2tpbmdcbnZlcnNpb246IDQuMTEuNFxuKi9cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSwgU3VwcHJlc3NlZEVycm9yLCBTeW1ib2wgKi9cblxudmFyIGV4dGVuZFN0YXRpY3MkMyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gIGV4dGVuZFN0YXRpY3MkMyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCB7XG4gICAgX19wcm90b19fOiBbXVxuICB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBkLl9fcHJvdG9fXyA9IGI7XG4gIH0gfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdO1xuICB9O1xuICByZXR1cm4gZXh0ZW5kU3RhdGljcyQzKGQsIGIpO1xufTtcbmZ1bmN0aW9uIF9fZXh0ZW5kcyQzKGQsIGIpIHtcbiAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbCkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICBleHRlbmRTdGF0aWNzJDMoZCwgYik7XG4gIGZ1bmN0aW9uIF9fKCkge1xuICAgIHRoaXMuY29uc3RydWN0b3IgPSBkO1xuICB9XG4gIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn1cbnZhciBfX2Fzc2lnbiQyID0gZnVuY3Rpb24gKCkge1xuICBfX2Fzc2lnbiQyID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XG4gICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcbiAgICB9XG4gICAgcmV0dXJuIHQ7XG4gIH07XG4gIHJldHVybiBfX2Fzc2lnbiQyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7XG4gICAgICByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTtcbiAgICB9XG4gICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcbiAgdmFyIF8gPSB7XG4gICAgICBsYWJlbDogMCxcbiAgICAgIHNlbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdO1xuICAgICAgICByZXR1cm4gdFsxXTtcbiAgICAgIH0sXG4gICAgICB0cnlzOiBbXSxcbiAgICAgIG9wczogW11cbiAgICB9LFxuICAgIGYsXG4gICAgeSxcbiAgICB0LFxuICAgIGc7XG4gIHJldHVybiBnID0ge1xuICAgIG5leHQ6IHZlcmIoMCksXG4gICAgXCJ0aHJvd1wiOiB2ZXJiKDEpLFxuICAgIFwicmV0dXJuXCI6IHZlcmIoMilcbiAgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pLCBnO1xuICBmdW5jdGlvbiB2ZXJiKG4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHYpIHtcbiAgICAgIHJldHVybiBzdGVwKFtuLCB2XSk7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgIHdoaWxlIChnICYmIChnID0gMCwgb3BbMF0gJiYgKF8gPSAwKSksIF8pIHRyeSB7XG4gICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHQgPSBvcDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIF8ubGFiZWwrKztcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IG9wWzFdLFxuICAgICAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgICAgICB9O1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgXy5sYWJlbCsrO1xuICAgICAgICAgIHkgPSBvcFsxXTtcbiAgICAgICAgICBvcCA9IFswXTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY2FzZSA3OlxuICAgICAgICAgIG9wID0gXy5vcHMucG9wKCk7XG4gICAgICAgICAgXy50cnlzLnBvcCgpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7XG4gICAgICAgICAgICBfID0gMDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSB7XG4gICAgICAgICAgICBfLmxhYmVsID0gb3BbMV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7XG4gICAgICAgICAgICBfLmxhYmVsID0gdFsxXTtcbiAgICAgICAgICAgIHQgPSBvcDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkge1xuICAgICAgICAgICAgXy5sYWJlbCA9IHRbMl07XG4gICAgICAgICAgICBfLm9wcy5wdXNoKG9wKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgXy50cnlzLnBvcCgpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgb3AgPSBbNiwgZV07XG4gICAgICB5ID0gMDtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgZiA9IHQgPSAwO1xuICAgIH1cbiAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsXG4gICAgICBkb25lOiB0cnVlXG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gX192YWx1ZXMkMShvKSB7XG4gIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvcixcbiAgICBtID0gcyAmJiBvW3NdLFxuICAgIGkgPSAwO1xuICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xuICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogbyAmJiBvW2krK10sXG4gICAgICAgIGRvbmU6ICFvXG4gICAgICB9O1xuICAgIH1cbiAgfTtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xufVxuZnVuY3Rpb24gX19yZWFkJDEobywgbikge1xuICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gIGlmICghbSkgcmV0dXJuIG87XG4gIHZhciBpID0gbS5jYWxsKG8pLFxuICAgIHIsXG4gICAgYXIgPSBbXSxcbiAgICBlO1xuICB0cnkge1xuICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGUgPSB7XG4gICAgICBlcnJvcjogZXJyb3JcbiAgICB9O1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKGUpIHRocm93IGUuZXJyb3I7XG4gICAgfVxuICB9XG4gIHJldHVybiBhcjtcbn1cblxuLyoqIEBkZXByZWNhdGVkICovXG5mdW5jdGlvbiBfX3NwcmVhZCQxKCkge1xuICBmb3IgKHZhciBhciA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgYXIgPSBhci5jb25jYXQoX19yZWFkJDEoYXJndW1lbnRzW2ldKSk7XG4gIHJldHVybiBhcjtcbn1cbnR5cGVvZiBTdXBwcmVzc2VkRXJyb3IgPT09IFwiZnVuY3Rpb25cIiA/IFN1cHByZXNzZWRFcnJvciA6IGZ1bmN0aW9uIChlcnJvciwgc3VwcHJlc3NlZCwgbWVzc2FnZSkge1xuICB2YXIgZSA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgcmV0dXJuIGUubmFtZSA9IFwiU3VwcHJlc3NlZEVycm9yXCIsIGUuZXJyb3IgPSBlcnJvciwgZS5zdXBwcmVzc2VkID0gc3VwcHJlc3NlZCwgZTtcbn07XG5cbi8qXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNSBOQVZFUiBDb3JwLlxyXG4gKiBlZ2pzIHByb2plY3RzIGFyZSBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvcmVzdHJpY3QtdGVtcGxhdGUtZXhwcmVzc2lvbnMgKi9cbi8qKlxyXG4gKiBFcnJvciBjb2RlcyBvZiB7QGxpbmsgRmxpY2tpbmdFcnJvcn0uIEJlbG93IGFyZSB0aGUgY29uZGl0aW9ucyB3aGVyZSBlYWNoIGVycm9yIGNvZGUgb2NjdXJzLlxyXG4gKiBAa28ge0BsaW5rIEZsaWNraW5nRXJyb3J97J2YIOyXkOufrCDsvZTrk5wuIOyVhOuemOuKlCDqsIHqsIHsnZgg7JeQ65+sIOy9lOuTnOqwgCDrsJzsg53tlZjripQg7KGw6rG07J6F64uI64ukLlxyXG4gKiBAbmFtZSBFUlJPUl9DT0RFXHJcbiAqIEBjb25zdGFudFxyXG4gKiBAdHlwZSBvYmplY3RcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IFdST05HX1RZUEUgUGFyYW1ldGVyIHR5cGUgaXMgd3Jvbmc8a28+7Yyo65+s66+47YSw7J2YIO2DgOyeheydtCDsnpjrqrvrkJjsl4jsnYQg6rK97JqwPC9rbz5cclxuICogQHByb3BlcnR5IHtudW1iZXJ9IEVMRU1FTlRfTk9UX0ZPVU5EIEVsZW1lbnQgaXMgbm90IGZvdW5kIGluc2lkZSBwYWdlIHdpdGggdGhlIGdpdmVuIENTUyBzZWxlY3Rvcjxrbz7so7zslrTsp4QgQ1NTIHNlbGVjdG9y66GcIO2OmOydtOyngCDrgrTsl5DshJwg7ZW064u5IOyXmOumrOuovO2KuOulvCDssL7sp4Ag66q77ZaI7J2EIOqyveyasDwva28+XHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBWQUxfTVVTVF9OT1RfTlVMTCBFeHBlY3RlZCBub24tbnVsbCB2YWx1ZSwgYnV0IGdpdmVuIGBudWxsYCBvciBgdW5kZWZpbmVkYDxrbz7qsJLsnYQg6riw64yA7ZaI7Jy864KYLCBgbnVsbGDsnbTrgpggYHVuZGVmaW5lZGDrpbwg67Cb7J2AIOqyveyasDwva28+XHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBOT1RfQVRUQUNIRURfVE9fRkxJQ0tJTkcgV2hlbiBGbGlja2luZydzIGNvbXBvbmVudCBpcyBub3QgaW5pdGlhbGl6ZWQgKGkuZS4ge0BsaW5rIEZsaWNraW5nI2luaXR9IGlzIG5vdCBjYWxsZWQpPGtvPkZsaWNraW5nIOuCtOu2gCDsu7Ttj6zrhIztirjqsIAg7LSI6riw7ZmU65CY7KeAIOyViuydgCDqsr3smrAgKHtAbGluayBGbGlja2luZyNpbml0feydtCDtmLjstpzrkJjsp4Ag7JWK7J2AIOqyveyasCk8L2tvPlxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gV1JPTkdfT1BUSU9OIE9uZSBvZiB0aGUgb3B0aW9ucyBpcyB3cm9uZzxrbz7smLXshZjrk6Qg7KSRIOyemOuqu+uQnCDqsJLsnbQg7J6I7J2EIOuVjDwva28+XHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBJTkRFWF9PVVRfT0ZfUkFOR0UgV2hlbiB0aGUgZ2l2ZW4gaW5kZXggaXMgb3V0IG9mIHBvc3NpYmxlIHJhbmdlPGtvPuyduOuNseyKpOqwgCDso7zslrTsp4Qg67KU7JyE66W8IOuyl+yWtOuCnCDqsr3smrA8L2tvPlxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gUE9TSVRJT05fTk9UX1JFQUNIQUJMRSBXaGVuIHtAbGluayBDb250cm9sI21vdmVUb1Bvc2l0aW9ufSdzIHBvc2l0aW9uIHBhcmFtZXRlciBpcyBvdXQgb2YgcG9zc2libGUgcmFuZ2UuPGtvPntAbGluayBDb250cm9sI21vdmVUb1Bvc2l0aW9ufeydmCBgcG9zaXRpb25gIO2MqOufrOuvuO2EsOqwgCDrj4Tri6wg6rCA64ql7ZWcIOuylOychOulvCDrspfslrTrgpwg6rK97JqwPC9rbz5cclxuICogQHByb3BlcnR5IHtudW1iZXJ9IFRSQU5TRk9STV9OT1RfU1VQUE9SVEVEIENTUyBgdHJhbnNmb3JtYCBwcm9wZXJ0eSBpcyBub3QgYXZhaWxhYmxlKDw9SUU4KSA8a28+Q1NTIGB0cmFuc2Zvcm1gIOyGjeyEseydhCDsgqzsmqntlaAg7IiYIOyXhuuKlCDqsr3smrAoPD1JRTgpPC9rbz5cclxuICogQHByb3BlcnR5IHtudW1iZXJ9IFNUT1BfQ0FMTEVEX0JZX1VTRVIgV2hlbiB0aGUgZXZlbnQncyBgc3RvcCgpYCBpcyBjYWxsZWQgYnkgdXNlci48a28+7IKs7Jqp7J6Q7JeQIOydmO2VtCDsnbTrsqTtirjsnZggYHN0b3AoKWDsnbQg7Zi47Lac65CcIOqyveyasDwva28+XHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBBTklNQVRJT05fSU5URVJSVVBURUQgV2hlbiB0aGUgYW5pbWF0aW9uIGlzIGludGVycnVwdGVkIGJ5IHVzZXIuPGtvPuyCrOyaqeyekOyXkCDsnZjtlbQg7JWg64uI66mU7J207IWY7J20IOykkeuLqOuQnCDqsr3smrA8L2tvPlxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gQU5JTUFUSU9OX0FMUkVBRFlfUExBWUlORyBXaGVuIHRoZSBhbmltYXRpb24gaXMgYWxyZWFkeSBwbGF5aW5nLjxrbz7tmITsnqwg7JWg64uI66mU7J207IWY7J20IOydtOuvuCDsp4TtlonspJHsnbgg6rK97JqwPC9rbz5cclxuICogQHByb3BlcnR5IHtudW1iZXJ9IE5PVF9BTExPV0VEX0lOX0ZSQU1FV09SSyBXaGVuIHRoZSBub24tYWxsb3dlZCBtZXRob2QgaXMgY2FsbGVkIGZyb20gZnJhbWV3b3JrcyAoUmVhY3QsIEFuZ3VsYXIsIFZ1ZS4uLilcclxuICogPGtvPu2UhOugiOyehOybjO2BrChSZWFjdCwgQW5ndWxhciwgVnVlIC4uLinsl5DshJwg7IKs7JqpIOu2iOqwgOuKpe2VnCDrqZTshozrk5zrpbwg7Zi47Lac7ZaI7J2EIOqyveyasDwva28+XHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBOT1RfSU5JVElBTElaRUQgV2hlbiB0aGUge0BsaW5rIEZsaWNraW5nI2luaXR9IGlzIG5vdCBjYWxsZWQgYmVmb3JlIGJ1dCBpcyBuZWVkZWQ8a28+e0BsaW5rIEZsaWNraW5nI2luaXR97J2YIO2YuOy2nOydtCDtlYTsmpTtlZjrgpgsIOyVhOyngSDtmLjstpzrkJjsp4Ag7JWK7JWY7J2EIOqyveyasDwva28+XHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBOT19BQ1RJVkUgV2hlbiB0aGVyZSdyZSBubyBhY3RpdmUgcGFuZWwgdGhhdCBmbGlja2luZyBoYXMgc2VsZWN0ZWQuIFRoaXMgbWF5IGJlIGR1ZSB0byB0aGUgYWJzZW5jZSBvZiBhbnkgcGFuZWxzPGtvPu2YhOyerCBGbGlja2luZ+ydtCDshKDtg53tlZwg7Yyo64SQ7J20IOyXhuydhCDqsr3smrAuIOydvOuwmOyggeycvOuhnCDtjKjrhJDsnbQg7ZWY64KY64+EIOyXhuuKlCDqsr3smrDsl5Ag67Cc7IOd7ZWgIOyImCDsnojsirXri4jri6Q8L2tvPlxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gTk9UX0FMTE9XRURfSU5fVklSVFVBTCBXaGVuIHRoZSBub24tYWxsb3dlZCBtZXRob2QgaXMgY2FsbGVkIHdoaWxlIHRoZSB2aXJ0dWFsIG9wdGlvbiBpcyBlbmFibGVkPGtvPnZpcnR1YWwg7Ji17IWY7J20IO2ZnOyEse2ZlOuQnCDsg4Htg5zsl5DshJwg7IKs7JqpIOu2iOqwgOuKpe2VnCDrqZTshozrk5zqsIAg7Zi47Lac65CY7JeI7J2EIOqyveyasDwva28+XHJcbiAqL1xudmFyIENPREUgPSB7XG4gIFdST05HX1RZUEU6IDAsXG4gIEVMRU1FTlRfTk9UX0ZPVU5EOiAxLFxuICBWQUxfTVVTVF9OT1RfTlVMTDogMixcbiAgTk9UX0FUVEFDSEVEX1RPX0ZMSUNLSU5HOiAzLFxuICBXUk9OR19PUFRJT046IDQsXG4gIElOREVYX09VVF9PRl9SQU5HRTogNSxcbiAgUE9TSVRJT05fTk9UX1JFQUNIQUJMRTogNixcbiAgVFJBTlNGT1JNX05PVF9TVVBQT1JURUQ6IDcsXG4gIFNUT1BfQ0FMTEVEX0JZX1VTRVI6IDgsXG4gIEFOSU1BVElPTl9JTlRFUlJVUFRFRDogOSxcbiAgQU5JTUFUSU9OX0FMUkVBRFlfUExBWUlORzogMTAsXG4gIE5PVF9BTExPV0VEX0lOX0ZSQU1FV09SSzogMTEsXG4gIE5PVF9JTklUSUFMSVpFRDogMTIsXG4gIE5PX0FDVElWRTogMTMsXG4gIE5PVF9BTExPV0VEX0lOX1ZJUlRVQUw6IDE0XG59O1xudmFyIE1FU1NBR0UgPSB7XG4gIFdST05HX1RZUEU6IGZ1bmN0aW9uICh3cm9uZ1ZhbCwgY29ycmVjdFR5cGVzKSB7XG4gICAgcmV0dXJuIHdyb25nVmFsICsgXCIoXCIgKyB0eXBlb2Ygd3JvbmdWYWwgKyBcIikgaXMgbm90IGEgXCIgKyBjb3JyZWN0VHlwZXMubWFwKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICByZXR1cm4gXCJcXFwiXCIgKyB0eXBlICsgXCJcXFwiXCI7XG4gICAgfSkuam9pbihcIiBvciBcIikgKyBcIi5cIjtcbiAgfSxcbiAgRUxFTUVOVF9OT1RfRk9VTkQ6IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgIHJldHVybiBcIkVsZW1lbnQgd2l0aCBzZWxlY3RvciBcXFwiXCIgKyBzZWxlY3RvciArIFwiXFxcIiBub3QgZm91bmQuXCI7XG4gIH0sXG4gIFZBTF9NVVNUX05PVF9OVUxMOiBmdW5jdGlvbiAodmFsLCBuYW1lKSB7XG4gICAgcmV0dXJuIG5hbWUgKyBcIiBzaG91bGQgYmUgcHJvdmlkZWQuIEdpdmVuOiBcIiArIHZhbDtcbiAgfSxcbiAgTk9UX0FUVEFDSEVEX1RPX0ZMSUNLSU5HOiBcIlRoaXMgbW9kdWxlIGlzIG5vdCBhdHRhY2hlZCB0byB0aGUgRmxpY2tpbmcgaW5zdGFuY2UuIFxcXCJpbml0KClcXFwiIHNob3VsZCBiZSBjYWxsZWQgZmlyc3QuXCIsXG4gIFdST05HX09QVElPTjogZnVuY3Rpb24gKG9wdGlvbk5hbWUsIHZhbCkge1xuICAgIHJldHVybiBcIk9wdGlvbiBcXFwiXCIgKyBvcHRpb25OYW1lICsgXCJcXFwiIGlzIG5vdCBpbiBjb3JyZWN0IGZvcm1hdCwgZ2l2ZW46IFwiICsgdmFsO1xuICB9LFxuICBJTkRFWF9PVVRfT0ZfUkFOR0U6IGZ1bmN0aW9uICh2YWwsIG1pbiwgbWF4KSB7XG4gICAgcmV0dXJuIFwiSW5kZXggXFxcIlwiICsgdmFsICsgXCJcXFwiIGlzIG91dCBvZiByYW5nZTogc2hvdWxkIGJlIGJldHdlZW4gXCIgKyBtaW4gKyBcIiBhbmQgXCIgKyBtYXggKyBcIi5cIjtcbiAgfSxcbiAgUE9TSVRJT05fTk9UX1JFQUNIQUJMRTogZnVuY3Rpb24gKHBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIFwiUG9zaXRpb24gXFxcIlwiICsgcG9zaXRpb24gKyBcIlxcXCIgaXMgbm90IHJlYWNoYWJsZS5cIjtcbiAgfSxcbiAgVFJBTlNGT1JNX05PVF9TVVBQT1JURUQ6IFwiQnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IENTUyB0cmFuc2Zvcm0uXCIsXG4gIFNUT1BfQ0FMTEVEX0JZX1VTRVI6IFwiRXZlbnQgc3RvcCgpIGlzIGNhbGxlZCBieSB1c2VyLlwiLFxuICBBTklNQVRJT05fSU5URVJSVVBURUQ6IFwiQW5pbWF0aW9uIGlzIGludGVycnVwdGVkIGJ5IHVzZXIgaW5wdXQuXCIsXG4gIEFOSU1BVElPTl9BTFJFQURZX1BMQVlJTkc6IFwiQW5pbWF0aW9uIGlzIGFscmVhZHkgcGxheWluZy5cIixcbiAgTk9UX0FMTE9XRURfSU5fRlJBTUVXT1JLOiBcIlRoaXMgYmVoYXZpb3IgaXMgbm90IGFsbG93ZWQgaW4gdGhlIGZyYW1ld29ya3MgbGlrZSBSZWFjdCwgVnVlLCBvciBBbmd1bGFyLlwiLFxuICBOT1RfSU5JVElBTElaRUQ6IFwiRmxpY2tpbmcgaXMgbm90IGluaXRpYWxpemVkIHlldCwgY2FsbCBpbml0KCkgZmlyc3QuXCIsXG4gIE5PX0FDVElWRTogXCJUaGVyZSdzIG5vIGFjdGl2ZSBwYW5lbCB0aGF0IEZsaWNraW5nIGhhcyBzZWxlY3RlZC4gVGhpcyBtYXkgYmUgZHVlIHRvIHRoZSBhYnNlbmNlIG9mIGFueSBwYW5lbHMuXCIsXG4gIE5PVF9BTExPV0VEX0lOX1ZJUlRVQUw6IFwiVGhpcyBiZWhhdmlvciBpcyBub3QgYWxsb3dlZCB3aGVuIHRoZSB2aXJ0dWFsIG9wdGlvbiBpcyBlbmFibGVkXCJcbn07XG5cbi8qXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNSBOQVZFUiBDb3JwLlxyXG4gKiBlZ2pzIHByb2plY3RzIGFyZSBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXG4vKipcclxuICogRXZlbnQgdHlwZSBvYmplY3Qgd2l0aCBldmVudCBuYW1lIHN0cmluZ3Mgb2Yge0BsaW5rIEZsaWNraW5nfVxyXG4gKiBAa28ge0BsaW5rIEZsaWNraW5nfeydmCDsnbTrsqTtirgg7J2066aEIOusuOyekOyXtOuTpOydhCDri7TsnYAg6rCd7LK0XHJcbiAqIEB0eXBlIHtvYmplY3R9XHJcbiAqIEBwcm9wZXJ0eSB7XCJob2xkU3RhcnRcIn0gSE9MRF9TVEFSVCBob2xkU3RhcnQgZXZlbnQ8a28+aG9sZFN0YXJ0IOydtOuypO2KuDwva28+XHJcbiAqIEBwcm9wZXJ0eSB7XCJob2xkRW5kXCJ9IEhPTERfRU5EIGhvbGRFbmQgZXZlbnQ8a28+aG9sZEVuZCDsnbTrsqTtirg8L2tvPlxyXG4gKiBAcHJvcGVydHkge1wibW92ZVN0YXJ0XCJ9IE1PVkVfU1RBUlQgbW92ZVN0YXJ0IGV2ZW50PGtvPm1vdmVTdGFydCDsnbTrsqTtirg8L2tvPlxyXG4gKiBAcHJvcGVydHkge1wibW92ZVwifSBNT1ZFIG1vdmUgZXZlbnQ8a28+bW92ZSDsnbTrsqTtirg8L2tvPlxyXG4gKiBAcHJvcGVydHkge1wibW92ZUVuZFwifSBNT1ZFX0VORCBtb3ZlRW5kIGV2ZW50PGtvPm1vdmVFbmQg7J2067Kk7Yq4PC9rbz5cclxuICogQHByb3BlcnR5IHtcIndpbGxDaGFuZ2VcIn0gV0lMTF9DSEFOR0Ugd2lsbENoYW5nZSBldmVudDxrbz53aWxsQ2hhbmdlIOydtOuypO2KuDwva28+XHJcbiAqIEBwcm9wZXJ0eSB7XCJjaGFuZ2VkXCJ9IENIQU5HRUQgY2hhbmdlZCBldmVudDxrbz5jaGFuZ2VkIOydtOuypO2KuDwva28+XHJcbiAqIEBwcm9wZXJ0eSB7XCJ3aWxsUmVzdG9yZVwifSBXSUxMX1JFU1RPUkUgd2lsbFJlc3RvcmUgZXZlbnQ8a28+d2lsbFJlc3RvcmUg7J2067Kk7Yq4PC9rbz5cclxuICogQHByb3BlcnR5IHtcInJlc3RvcmVkXCJ9IFJFU1RPUkVEIHJlc3RvcmVkIGV2ZW50PGtvPnJlc3RvcmVkIOydtOuypO2KuDwva28+XHJcbiAqIEBwcm9wZXJ0eSB7XCJzZWxlY3RcIn0gU0VMRUNUIHNlbGVjdCBldmVudDxrbz5zZWxlY3Qg7J2067Kk7Yq4PC9rbz5cclxuICogQHByb3BlcnR5IHtcIm5lZWRQYW5lbFwifSBORUVEX1BBTkVMIG5lZWRQYW5lbCBldmVudDxrbz5uZWVkUGFuZWwg7J2067Kk7Yq4PC9rbz5cclxuICogQHByb3BlcnR5IHtcInBhbmVsQ2hhbmdlXCJ9IFBBTkVMX0NIQU5HRSBwYW5lbENoYW5nZSBldmVudDxrbz5wYW5lbENoYW5nZSDsnbTrsqTtirg8L2tvPlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGB0c1xyXG4gKiBpbXBvcnQgeyBFVkVOVFMgfSBmcm9tIFwiQGVnanMvZmxpY2tpbmdcIjtcclxuICogRVZFTlRTLk1PVkVfU1RBUlQ7IC8vIFwibW92ZVN0YXJ0XCJcclxuICogYGBgXHJcbiAqL1xudmFyIEVWRU5UUyA9IHtcbiAgUkVBRFk6IFwicmVhZHlcIixcbiAgQkVGT1JFX1JFU0laRTogXCJiZWZvcmVSZXNpemVcIixcbiAgQUZURVJfUkVTSVpFOiBcImFmdGVyUmVzaXplXCIsXG4gIEhPTERfU1RBUlQ6IFwiaG9sZFN0YXJ0XCIsXG4gIEhPTERfRU5EOiBcImhvbGRFbmRcIixcbiAgTU9WRV9TVEFSVDogXCJtb3ZlU3RhcnRcIixcbiAgTU9WRTogXCJtb3ZlXCIsXG4gIE1PVkVfRU5EOiBcIm1vdmVFbmRcIixcbiAgV0lMTF9DSEFOR0U6IFwid2lsbENoYW5nZVwiLFxuICBDSEFOR0VEOiBcImNoYW5nZWRcIixcbiAgV0lMTF9SRVNUT1JFOiBcIndpbGxSZXN0b3JlXCIsXG4gIFJFU1RPUkVEOiBcInJlc3RvcmVkXCIsXG4gIFNFTEVDVDogXCJzZWxlY3RcIixcbiAgTkVFRF9QQU5FTDogXCJuZWVkUGFuZWxcIixcbiAgVklTSUJMRV9DSEFOR0U6IFwidmlzaWJsZUNoYW5nZVwiLFxuICBSRUFDSF9FREdFOiBcInJlYWNoRWRnZVwiLFxuICBQQU5FTF9DSEFOR0U6IFwicGFuZWxDaGFuZ2VcIlxufTtcbi8qKlxyXG4gKiBBbiBvYmplY3Qgd2l0aCBhbGwgcG9zc2libGUgcHJlZGVmaW5lZCBsaXRlcmFsIHN0cmluZyBmb3IgdGhlIHtAbGluayBGbGlja2luZyNhbGlnbiBhbGlnbn0gb3B0aW9uXHJcbiAqIEBrbyB7QGxpbmsgRmxpY2tpbmcjYWxpZ24gYWxpZ259IOyYteyFmOyXkCDsgqzsmqnrkJjripQg66+466asIOygleydmOuQnCDrpqzthLDrn7Qg7IOB7IiY65Ok7J2EIOuLtOqzoCDsnojripQg6rCd7LK0XHJcbiAqIEB0eXBlIHtvYmplY3R9XHJcbiAqIEBwcm9wZXJ0eSB7XCJwcmV2XCJ9IFBSRVYgbGVmdC90b3AgYWxpZ248a28+7KKML+yDgSDsoJXroKw8L2tvPlxyXG4gKiBAcHJvcGVydHkge1wiY2VudGVyXCJ9IENFTlRFUiBjZW50ZXIgYWxpZ248a28+7KSR7JWZIOygleugrDwva28+XHJcbiAqIEBwcm9wZXJ0eSB7XCJuZXh0XCJ9IE5FWFQgcmlnaHQvYm90dG9tIGFsaWduPGtvPuyasC/tlZgg7KCV66CsPC9rbz5cclxuICovXG52YXIgQUxJR04gPSB7XG4gIFBSRVY6IFwicHJldlwiLFxuICBDRU5URVI6IFwiY2VudGVyXCIsXG4gIE5FWFQ6IFwibmV4dFwiXG59O1xuLyoqXHJcbiAqIEFuIG9iamVjdCBvZiBkaXJlY3Rpb25zXHJcbiAqIEBrbyDrsKntlqXsnYQg64KY7YOA64K064qUIOqwkuuTpOydhCDri7Tqs6Ag7J6I64qUIOqwneyytFxyXG4gKiBAdHlwZSB7b2JqZWN0fVxyXG4gKiBAcHJvcGVydHkge1wiUFJFVlwifSBQUkVWIFwibGVmdFwiIHdoZW4ge0BsaW5rIEZsaWNraW5nI2hvcml6b250YWwgaG9yaXpvbnRhbH0gaXMgdHJ1ZSwgYW5kIFwidG9wXCIgd2hlbiB7QGxpbmsgRmxpY2tpbmcjaG9yaXpvbnRhbCBob3Jpem9udGFsfSBpcyBmYWxzZVxyXG4gKiA8a28+e0BsaW5rIEZsaWNraW5nI2hvcml6b250YWwgaG9yaXpvbnRhbH3qsIAgYHRydWVg7J28IOqyveyasCDsmbzsqr0sIHtAbGluayBGbGlja2luZyNob3Jpem9udGFsIGhvcml6b250YWx96rCAIGBmYWxzZWDsnbwg6rK97JqwIOychOyqveydhCDsnZjrr7jtlanri4jri6Q8L2tvPlxyXG4gKiBAcHJvcGVydHkge1wiTkVYVFwifSBORVhUIFwicmlnaHRcIiB3aGVuIHtAbGluayBGbGlja2luZyNob3Jpem9udGFsIGhvcml6b250YWx9IGlzIHRydWUsIGFuZCBcImJvdHRvbVwiIHdoZW4ge0BsaW5rIEZsaWNraW5nI2hvcml6b250YWwgaG9yaXpvbnRhbH0gaXMgZmFsc2VcclxuICogPGtvPntAbGluayBGbGlja2luZyNob3Jpem9udGFsIGhvcml6b250YWx96rCAIGB0cnVlYOydvCDqsr3smrAg7Jik66W47Kq9LCB7QGxpbmsgRmxpY2tpbmcjaG9yaXpvbnRhbCBob3Jpem9udGFsfeqwgCBgZmFsc2Vg7J28IOqyveyasCDslYTrnpjsqr3snYQg7J2Y66+47ZWp64uI64ukPC9rbz5cclxuICogQHByb3BlcnR5IHtudWxsfSBOT05FIFRoaXMgdmFsdWUgdXN1YWxseSBtZWFucyBpdCdzIHRoZSBzYW1lIHBvc2l0aW9uPGtvPuyjvOuhnCDsoJzsnpDrpqzsnbgg6rK97Jqw66W8IOydmOuvuO2VqeuLiOuLpDwva28+XHJcbiAqL1xudmFyIERJUkVDVElPTiA9IHtcbiAgUFJFVjogXCJQUkVWXCIsXG4gIE5FWFQ6IFwiTkVYVFwiLFxuICBOT05FOiBudWxsXG59O1xuLyoqXHJcbiAqIEFuIG9iamVjdCB3aXRoIGFsbCBwb3NzaWJsZSB7QGxpbmsgRmxpY2tpbmcjbW92ZVR5cGUgbW92ZVR5cGV9c1xyXG4gKiBAa28gRmxpY2tpbmfsnbQg7KCc6rO17ZWY64qUIHtAbGluayBGbGlja2luZyNtb3ZlVHlwZSBtb3ZlVHlwZX3rk6TsnYQg64u06rOgIOyeiOuKlCDqsJ3ssrRcclxuICogQHR5cGUge29iamVjdH1cclxuICogQHByb3BlcnR5IHtcInNuYXBcIn0gU05BUCBGbGlja2luZydzIHtAbGluayBGbGlja2luZyNtb3ZlVHlwZSBtb3ZlVHlwZX0gdGhhdCBlbmFibGVzIHtAbGluayBTbmFwQ29udHJvbH0gYXMgYSBGbGlja2luZydzIHtAbGluayBGbGlja2luZyNjb250cm9sIGNvbnRyb2x9XHJcbiAqIDxrbz5GbGlja2luZ+ydmCB7QGxpbmsgRmxpY2tpbmcjY29udHJvbCBjb250cm9sfeydhCB7QGxpbmsgU25hcENvbnRyb2x966GcIOyEpOygle2VmOqyjCDtlZjripQge0BsaW5rIEZsaWNraW5nI21vdmVUeXBlIG1vdmVUeXBlfTwva28+XHJcbiAqIEBwcm9wZXJ0eSB7XCJmcmVlU2Nyb2xsXCJ9IEZSRUVfU0NST0xMIEZsaWNraW5nJ3Mge0BsaW5rIEZsaWNraW5nI21vdmVUeXBlIG1vdmVUeXBlfSB0aGF0IGVuYWJsZXMge0BsaW5rIEZyZWVDb250cm9sfSBhcyBhIEZsaWNraW5nJ3Mge0BsaW5rIEZsaWNraW5nI2NvbnRyb2wgY29udHJvbH1cclxuICogPGtvPkZsaWNraW5n7J2YIHtAbGluayBGbGlja2luZyNjb250cm9sIGNvbnRyb2x97J2EIHtAbGluayBGcmVlQ29udHJvbH3roZwg7ISk7KCV7ZWY6rKMIO2VmOuKlCB7QGxpbmsgRmxpY2tpbmcjbW92ZVR5cGUgbW92ZVR5cGV9PC9rbz5cclxuICogQHByb3BlcnR5IHtcInN0cmljdFwifSBTVFJJQ1QgRmxpY2tpbmcncyB7QGxpbmsgRmxpY2tpbmcjbW92ZVR5cGUgbW92ZVR5cGV9IHRoYXQgZW5hYmxlcyB7QGxpbmsgU3RyaWN0Q29udHJvbH0gYXMgYSBGbGlja2luZydzIHtAbGluayBGbGlja2luZyNjb250cm9sIGNvbnRyb2x9XHJcbiAqIDxrbz5GbGlja2luZ+ydmCB7QGxpbmsgRmxpY2tpbmcjY29udHJvbCBjb250cm9sfeydhCB7QGxpbmsgU3RyaWN0Q29udHJvbH3roZwg7ISk7KCV7ZWY6rKMIO2VmOuKlCB7QGxpbmsgRmxpY2tpbmcjbW92ZVR5cGUgbW92ZVR5cGV9PC9rbz5cclxuICovXG52YXIgTU9WRV9UWVBFID0ge1xuICBTTkFQOiBcInNuYXBcIixcbiAgRlJFRV9TQ1JPTEw6IFwiZnJlZVNjcm9sbFwiLFxuICBTVFJJQ1Q6IFwic3RyaWN0XCJcbn07XG52YXIgQ0xBU1MgPSB7XG4gIFZFUlRJQ0FMOiBcInZlcnRpY2FsXCIsXG4gIEhJRERFTjogXCJmbGlja2luZy1oaWRkZW5cIixcbiAgREVGQVVMVF9WSVJUVUFMOiBcImZsaWNraW5nLXBhbmVsXCJcbn07XG4vKipcclxuICogQW4gb2JqZWN0IHdpdGggYWxsIHBvc3NpYmxlIHtAbGluayBGbGlja2luZyNjaXJjdWxhckZhbGxiYWNrIGNpcmN1bGFyRmFsbGJhY2t9c1xyXG4gKiBAa28gRmxpY2tpbmfsnZgge0BsaW5rIEZsaWNraW5nI2NpcmN1bGFyRmFsbGJhY2sgY2lyY3VsYXJGYWxsYmFja33sl5Ag7ISk7KCVIOqwgOuKpe2VnCDqsJLrk6TsnYQg64u06rOgIOyeiOuKlCDqsJ3ssrRcclxuICogQHR5cGUge29iamVjdH1cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IExJTkVBUiBcImxpbmVhclwiXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBCT1VORCBcImJvdW5kXCJcclxuICovXG52YXIgQ0lSQ1VMQVJfRkFMTEJBQ0sgPSB7XG4gIExJTkVBUjogXCJsaW5lYXJcIixcbiAgQk9VTkQ6IFwiYm91bmRcIlxufTtcbi8qKlxyXG4gKiBBbiBvYmplY3QgZm9yIGlkZW50aWZ5aW5nIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvZGlyZWN0aW9uIGRpcmVjdGlvbn0gQ1NTIHByb3BlcnR5IGFwcGxpZWQgdG8gdGhlIGNhbWVyYSBlbGVtZW50KGAuZmxpY2tpbmctY2FtZXJhYClcclxuICogQGtvIOy5tOuplOudvCDsl5jrpqzrqLztirgoYC5mbGlja2luZy1jYW1lcmFgKeyXkCDsoIHsmqnrkJwge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9kaXJlY3Rpb24gZGlyZWN0aW9ufSBDU1Mg7IaN7ISx7J2EIOq1rOu2hO2VmOq4sCDsnITtlZwg6rCd7LK0XHJcbiAqIEB0eXBlIHtvYmplY3R9XHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBMVFIgXCJsdHJcIlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gUlRMIFwicnRsXCJcclxuICovXG52YXIgT1JERVIgPSB7XG4gIExUUjogXCJsdHJcIixcbiAgUlRMOiBcInJ0bFwiXG59O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlc1xudmFyIG1lcmdlID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICB2YXIgc291cmNlcyA9IFtdO1xuICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgIHNvdXJjZXNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gIH1cbiAgc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICBPYmplY3Qua2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiB0YXJnZXQ7XG59O1xudmFyIGdldEVsZW1lbnQgPSBmdW5jdGlvbiAoZWwsIHBhcmVudCkge1xuICB2YXIgdGFyZ2V0RWwgPSBudWxsO1xuICBpZiAoaXNTdHJpbmcoZWwpKSB7XG4gICAgdmFyIHBhcmVudEVsID0gcGFyZW50ID8gcGFyZW50IDogZG9jdW1lbnQ7XG4gICAgdmFyIHF1ZXJ5UmVzdWx0ID0gcGFyZW50RWwucXVlcnlTZWxlY3RvcihlbCk7XG4gICAgaWYgKCFxdWVyeVJlc3VsdCkge1xuICAgICAgdGhyb3cgbmV3IEZsaWNraW5nRXJyb3IoTUVTU0FHRS5FTEVNRU5UX05PVF9GT1VORChlbCksIENPREUuRUxFTUVOVF9OT1RfRk9VTkQpO1xuICAgIH1cbiAgICB0YXJnZXRFbCA9IHF1ZXJ5UmVzdWx0O1xuICB9IGVsc2UgaWYgKGVsICYmIGVsLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgIHRhcmdldEVsID0gZWw7XG4gIH1cbiAgaWYgKCF0YXJnZXRFbCkge1xuICAgIHRocm93IG5ldyBGbGlja2luZ0Vycm9yKE1FU1NBR0UuV1JPTkdfVFlQRShlbCwgW1wiSFRNTEVsZW1lbnRcIiwgXCJzdHJpbmdcIl0pLCBDT0RFLldST05HX1RZUEUpO1xuICB9XG4gIHJldHVybiB0YXJnZXRFbDtcbn07XG52YXIgY2hlY2tFeGlzdGVuY2UgPSBmdW5jdGlvbiAodmFsdWUsIG5hbWVPbkVyck1zZykge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBGbGlja2luZ0Vycm9yKE1FU1NBR0UuVkFMX01VU1RfTk9UX05VTEwodmFsdWUsIG5hbWVPbkVyck1zZyksIENPREUuVkFMX01VU1RfTk9UX05VTEwpO1xuICB9XG59O1xudmFyIGNsYW1wJDEgPSBmdW5jdGlvbiAoeCwgbWluLCBtYXgpIHtcbiAgcmV0dXJuIE1hdGgubWF4KE1hdGgubWluKHgsIG1heCksIG1pbik7XG59O1xudmFyIGdldEZsaWNraW5nQXR0YWNoZWQgPSBmdW5jdGlvbiAodmFsKSB7XG4gIGlmICghdmFsKSB7XG4gICAgdGhyb3cgbmV3IEZsaWNraW5nRXJyb3IoTUVTU0FHRS5OT1RfQVRUQUNIRURfVE9fRkxJQ0tJTkcsIENPREUuTk9UX0FUVEFDSEVEX1RPX0ZMSUNLSU5HKTtcbiAgfVxuICByZXR1cm4gdmFsO1xufTtcbnZhciB0b0FycmF5JDIgPSBmdW5jdGlvbiAoaXRlcmFibGUpIHtcbiAgcmV0dXJuIFtdLnNsaWNlLmNhbGwoaXRlcmFibGUpO1xufTtcbnZhciBwYXJzZUFsaWduJDEgPSBmdW5jdGlvbiAoYWxpZ24sIHNpemUpIHtcbiAgdmFyIGFsaWduUG9pbnQ7XG4gIGlmIChpc1N0cmluZyhhbGlnbikpIHtcbiAgICBzd2l0Y2ggKGFsaWduKSB7XG4gICAgICBjYXNlIEFMSUdOLlBSRVY6XG4gICAgICAgIGFsaWduUG9pbnQgPSAwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQUxJR04uQ0VOVEVSOlxuICAgICAgICBhbGlnblBvaW50ID0gMC41ICogc2l6ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEFMSUdOLk5FWFQ6XG4gICAgICAgIGFsaWduUG9pbnQgPSBzaXplO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGFsaWduUG9pbnQgPSBwYXJzZUFyaXRobWV0aWNTaXplKGFsaWduLCBzaXplKTtcbiAgICAgICAgaWYgKGFsaWduUG9pbnQgPT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBGbGlja2luZ0Vycm9yKE1FU1NBR0UuV1JPTkdfT1BUSU9OKFwiYWxpZ25cIiwgYWxpZ24pLCBDT0RFLldST05HX09QVElPTik7XG4gICAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYWxpZ25Qb2ludCA9IGFsaWduO1xuICB9XG4gIHJldHVybiBhbGlnblBvaW50O1xufTtcbnZhciBwYXJzZUJvdW5jZSA9IGZ1bmN0aW9uIChib3VuY2UsIHNpemUpIHtcbiAgdmFyIHBhcnNlZEJvdW5jZTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYm91bmNlKSkge1xuICAgIHBhcnNlZEJvdW5jZSA9IGJvdW5jZS5tYXAoZnVuY3Rpb24gKHZhbCkge1xuICAgICAgcmV0dXJuIHBhcnNlQXJpdGhtZXRpY1NpemUodmFsLCBzaXplKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcGFyc2VkVmFsID0gcGFyc2VBcml0aG1ldGljU2l6ZShib3VuY2UsIHNpemUpO1xuICAgIHBhcnNlZEJvdW5jZSA9IFtwYXJzZWRWYWwsIHBhcnNlZFZhbF07XG4gIH1cbiAgcmV0dXJuIHBhcnNlZEJvdW5jZS5tYXAoZnVuY3Rpb24gKHZhbCkge1xuICAgIGlmICh2YWwgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEZsaWNraW5nRXJyb3IoTUVTU0FHRS5XUk9OR19PUFRJT04oXCJib3VuY2VcIiwgYm91bmNlKSwgQ09ERS5XUk9OR19PUFRJT04pO1xuICAgIH1cbiAgICByZXR1cm4gdmFsO1xuICB9KTtcbn07XG52YXIgcGFyc2VBcml0aG1ldGljU2l6ZSA9IGZ1bmN0aW9uIChjc3NWYWx1ZSwgYmFzZSkge1xuICB2YXIgcGFyc2VkID0gcGFyc2VBcml0aG1ldGljRXhwcmVzc2lvbihjc3NWYWx1ZSk7XG4gIGlmIChwYXJzZWQgPT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gIHJldHVybiBwYXJzZWQucGVyY2VudGFnZSAqIGJhc2UgKyBwYXJzZWQuYWJzb2x1dGU7XG59O1xudmFyIHBhcnNlQXJpdGhtZXRpY0V4cHJlc3Npb24gPSBmdW5jdGlvbiAoY3NzVmFsdWUpIHtcbiAgdmFyIGNzc1JlZ2V4ID0gLyg/OihcXCt8XFwtKVxccyopPyhcXGQrKD86XFwuXFxkKyk/KCV8cHgpPykvZztcbiAgaWYgKHR5cGVvZiBjc3NWYWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgIHJldHVybiB7XG4gICAgICBwZXJjZW50YWdlOiAwLFxuICAgICAgYWJzb2x1dGU6IGNzc1ZhbHVlXG4gICAgfTtcbiAgfVxuICB2YXIgcGFyc2VkID0ge1xuICAgIHBlcmNlbnRhZ2U6IDAsXG4gICAgYWJzb2x1dGU6IDBcbiAgfTtcbiAgdmFyIGlkeCA9IDA7XG4gIHZhciBtYXRjaFJlc3VsdCA9IGNzc1JlZ2V4LmV4ZWMoY3NzVmFsdWUpO1xuICB3aGlsZSAobWF0Y2hSZXN1bHQgIT0gbnVsbCkge1xuICAgIHZhciBzaWduID0gbWF0Y2hSZXN1bHRbMV07XG4gICAgdmFyIHZhbHVlID0gbWF0Y2hSZXN1bHRbMl07XG4gICAgdmFyIHVuaXQgPSBtYXRjaFJlc3VsdFszXTtcbiAgICB2YXIgcGFyc2VkVmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICBpZiAoaWR4IDw9IDApIHtcbiAgICAgIHNpZ24gPSBzaWduIHx8IFwiK1wiO1xuICAgIH1cbiAgICAvLyBSZXR1cm4gZGVmYXVsdCB2YWx1ZSBmb3IgdmFsdWVzIG5vdCBpbiBnb29kIGZvcm1cbiAgICBpZiAoIXNpZ24pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgc2lnbk11bHRpcGxpZXIgPSBzaWduID09PSBcIitcIiA/IDEgOiAtMTtcbiAgICBpZiAodW5pdCA9PT0gXCIlXCIpIHtcbiAgICAgIHBhcnNlZC5wZXJjZW50YWdlICs9IHNpZ25NdWx0aXBsaWVyICogKHBhcnNlZFZhbHVlIC8gMTAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyc2VkLmFic29sdXRlICs9IHNpZ25NdWx0aXBsaWVyICogcGFyc2VkVmFsdWU7XG4gICAgfVxuICAgIC8vIE1hdGNoIG5leHQgb2NjdXJyZW5jZVxuICAgICsraWR4O1xuICAgIG1hdGNoUmVzdWx0ID0gY3NzUmVnZXguZXhlYyhjc3NWYWx1ZSk7XG4gIH1cbiAgLy8gTm9uZS1tYXRjaGVkXG4gIGlmIChpZHggPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gcGFyc2VkO1xufTtcbnZhciBwYXJzZUNTU1NpemVWYWx1ZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgcmV0dXJuIGlzU3RyaW5nKHZhbCkgPyB2YWwgOiB2YWwgKyBcInB4XCI7XG59O1xudmFyIHBhcnNlUGFuZWxBbGlnbiA9IGZ1bmN0aW9uIChhbGlnbikge1xuICByZXR1cm4gdHlwZW9mIGFsaWduID09PSBcIm9iamVjdFwiID8gYWxpZ24ucGFuZWwgOiBhbGlnbjtcbn07XG52YXIgZ2V0RGlyZWN0aW9uJDEgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IGVuZCkgcmV0dXJuIERJUkVDVElPTi5OT05FO1xuICByZXR1cm4gc3RhcnQgPCBlbmQgPyBESVJFQ1RJT04uTkVYVCA6IERJUkVDVElPTi5QUkVWO1xufTtcbnZhciBwYXJzZUVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoZWxlbWVudCkpIHtcbiAgICBlbGVtZW50ID0gW2VsZW1lbnRdO1xuICB9XG4gIHZhciBlbGVtZW50cyA9IFtdO1xuICBlbGVtZW50LmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgaWYgKGlzU3RyaW5nKGVsKSkge1xuICAgICAgdmFyIHRlbXBEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgdGVtcERpdi5pbm5lckhUTUwgPSBlbDtcbiAgICAgIGVsZW1lbnRzLnB1c2guYXBwbHkoZWxlbWVudHMsIF9fc3ByZWFkJDEodG9BcnJheSQyKHRlbXBEaXYuY2hpbGRyZW4pKSk7XG4gICAgICB3aGlsZSAodGVtcERpdi5maXJzdENoaWxkKSB7XG4gICAgICAgIHRlbXBEaXYucmVtb3ZlQ2hpbGQodGVtcERpdi5maXJzdENoaWxkKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVsICYmIGVsLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgZWxlbWVudHMucHVzaChlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBGbGlja2luZ0Vycm9yKE1FU1NBR0UuV1JPTkdfVFlQRShlbCwgW1wiSFRNTEVsZW1lbnRcIiwgXCJzdHJpbmdcIl0pLCBDT0RFLldST05HX1RZUEUpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBlbGVtZW50cztcbn07XG52YXIgZ2V0TWludXNDb21wZW5zYXRlZEluZGV4ID0gZnVuY3Rpb24gKGlkeCwgbWF4KSB7XG4gIHJldHVybiBpZHggPCAwID8gY2xhbXAkMShpZHggKyBtYXgsIDAsIG1heCkgOiBjbGFtcCQxKGlkeCwgMCwgbWF4KTtcbn07XG52YXIgaW5jbHVkZXMgPSBmdW5jdGlvbiAoYXJyYXksIHRhcmdldCkge1xuICB2YXIgZV8xLCBfYTtcbiAgdHJ5IHtcbiAgICBmb3IgKHZhciBhcnJheV8xID0gX192YWx1ZXMkMShhcnJheSksIGFycmF5XzFfMSA9IGFycmF5XzEubmV4dCgpOyAhYXJyYXlfMV8xLmRvbmU7IGFycmF5XzFfMSA9IGFycmF5XzEubmV4dCgpKSB7XG4gICAgICB2YXIgdmFsID0gYXJyYXlfMV8xLnZhbHVlO1xuICAgICAgaWYgKHZhbCA9PT0gdGFyZ2V0KSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVfMV8xKSB7XG4gICAgZV8xID0ge1xuICAgICAgZXJyb3I6IGVfMV8xXG4gICAgfTtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKGFycmF5XzFfMSAmJiAhYXJyYXlfMV8xLmRvbmUgJiYgKF9hID0gYXJyYXlfMS5yZXR1cm4pKSBfYS5jYWxsKGFycmF5XzEpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG52YXIgaXNTdHJpbmcgPSBmdW5jdGlvbiAodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiO1xufTtcbnZhciBjaXJjdWxhdGVQb3NpdGlvbiA9IGZ1bmN0aW9uIChwb3MsIG1pbiwgbWF4KSB7XG4gIHZhciBzaXplID0gbWF4IC0gbWluO1xuICBpZiAocG9zIDwgbWluKSB7XG4gICAgdmFyIG9mZnNldCA9IChtaW4gLSBwb3MpICUgc2l6ZTtcbiAgICBwb3MgPSBtYXggLSBvZmZzZXQ7XG4gIH0gZWxzZSBpZiAocG9zID4gbWF4KSB7XG4gICAgdmFyIG9mZnNldCA9IChwb3MgLSBtYXgpICUgc2l6ZTtcbiAgICBwb3MgPSBtaW4gKyBvZmZzZXQ7XG4gIH1cbiAgcmV0dXJuIHBvcztcbn07XG52YXIgZmluZCQxID0gZnVuY3Rpb24gKGFycmF5LCBjaGVja2VyKSB7XG4gIHZhciBlXzIsIF9hO1xuICB0cnkge1xuICAgIGZvciAodmFyIGFycmF5XzIgPSBfX3ZhbHVlcyQxKGFycmF5KSwgYXJyYXlfMl8xID0gYXJyYXlfMi5uZXh0KCk7ICFhcnJheV8yXzEuZG9uZTsgYXJyYXlfMl8xID0gYXJyYXlfMi5uZXh0KCkpIHtcbiAgICAgIHZhciB2YWwgPSBhcnJheV8yXzEudmFsdWU7XG4gICAgICBpZiAoY2hlY2tlcih2YWwpKSB7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlXzJfMSkge1xuICAgIGVfMiA9IHtcbiAgICAgIGVycm9yOiBlXzJfMVxuICAgIH07XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChhcnJheV8yXzEgJiYgIWFycmF5XzJfMS5kb25lICYmIChfYSA9IGFycmF5XzIucmV0dXJuKSkgX2EuY2FsbChhcnJheV8yKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKGVfMikgdGhyb3cgZV8yLmVycm9yO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG52YXIgZmluZFJpZ2h0ID0gZnVuY3Rpb24gKGFycmF5LCBjaGVja2VyKSB7XG4gIGZvciAodmFyIGlkeCA9IGFycmF5Lmxlbmd0aCAtIDE7IGlkeCA+PSAwOyBpZHgtLSkge1xuICAgIHZhciB2YWwgPSBhcnJheVtpZHhdO1xuICAgIGlmIChjaGVja2VyKHZhbCkpIHtcbiAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufTtcbnZhciBmaW5kSW5kZXggPSBmdW5jdGlvbiAoYXJyYXksIGNoZWNrZXIpIHtcbiAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgYXJyYXkubGVuZ3RoOyBpZHgrKykge1xuICAgIGlmIChjaGVja2VyKGFycmF5W2lkeF0pKSB7XG4gICAgICByZXR1cm4gaWR4O1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59O1xudmFyIGdldFByb2dyZXNzID0gZnVuY3Rpb24gKHBvcywgcHJldiwgbmV4dCkge1xuICByZXR1cm4gKHBvcyAtIHByZXYpIC8gKG5leHQgLSBwcmV2KTtcbn07XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzXG52YXIgZ2V0U3R5bGUgPSBmdW5jdGlvbiAoZWwpIHtcbiAgcmV0dXJuIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKSB8fCBlbC5jdXJyZW50U3R5bGU7XG59O1xudmFyIHNldFNpemUgPSBmdW5jdGlvbiAoZWwsIF9hKSB7XG4gIHZhciB3aWR0aCA9IF9hLndpZHRoLFxuICAgIGhlaWdodCA9IF9hLmhlaWdodDtcbiAgaWYgKHdpZHRoICE9IG51bGwpIHtcbiAgICBpZiAoaXNTdHJpbmcod2lkdGgpKSB7XG4gICAgICBlbC5zdHlsZS53aWR0aCA9IHdpZHRoO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zdHlsZS53aWR0aCA9IHdpZHRoICsgXCJweFwiO1xuICAgIH1cbiAgfVxuICBpZiAoaGVpZ2h0ICE9IG51bGwpIHtcbiAgICBpZiAoaXNTdHJpbmcoaGVpZ2h0KSkge1xuICAgICAgZWwuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyBcInB4XCI7XG4gICAgfVxuICB9XG59O1xudmFyIGlzQmV0d2VlbiA9IGZ1bmN0aW9uICh2YWwsIG1pbiwgbWF4KSB7XG4gIHJldHVybiB2YWwgPj0gbWluICYmIHZhbCA8PSBtYXg7XG59O1xudmFyIGNpcmN1bGF0ZUluZGV4ID0gZnVuY3Rpb24gKGluZGV4LCBtYXgpIHtcbiAgaWYgKGluZGV4ID49IG1heCkge1xuICAgIHJldHVybiBpbmRleCAlIG1heDtcbiAgfSBlbHNlIGlmIChpbmRleCA8IDApIHtcbiAgICByZXR1cm4gZ2V0TWludXNDb21wZW5zYXRlZEluZGV4KChpbmRleCArIDEpICUgbWF4IC0gMSwgbWF4KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cbn07XG52YXIgcmFuZ2UgPSBmdW5jdGlvbiAoZW5kKSB7XG4gIHZhciBhcnIgPSBuZXcgQXJyYXkoZW5kKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbmQ7IGkrKykge1xuICAgIGFycltpXSA9IGk7XG4gIH1cbiAgcmV0dXJuIGFycjtcbn07XG52YXIgZ2V0RWxlbWVudFNpemUgPSBmdW5jdGlvbiAoX2EpIHtcbiAgdmFyIGVsID0gX2EuZWwsXG4gICAgaG9yaXpvbnRhbCA9IF9hLmhvcml6b250YWwsXG4gICAgdXNlRnJhY3Rpb25hbFNpemUgPSBfYS51c2VGcmFjdGlvbmFsU2l6ZSxcbiAgICB1c2VPZmZzZXQgPSBfYS51c2VPZmZzZXQsXG4gICAgc3R5bGUgPSBfYS5zdHlsZTtcbiAgdmFyIHNpemUgPSAwO1xuICBpZiAodXNlRnJhY3Rpb25hbFNpemUpIHtcbiAgICB2YXIgYmFzZVNpemUgPSBwYXJzZUZsb2F0KGhvcml6b250YWwgPyBzdHlsZS53aWR0aCA6IHN0eWxlLmhlaWdodCkgfHwgMDtcbiAgICB2YXIgaXNCb3JkZXJCb3hTaXppbmcgPSBzdHlsZS5ib3hTaXppbmcgPT09IFwiYm9yZGVyLWJveFwiO1xuICAgIHZhciBib3JkZXIgPSBob3Jpem9udGFsID8gcGFyc2VGbG9hdChzdHlsZS5ib3JkZXJMZWZ0V2lkdGggfHwgXCIwXCIpICsgcGFyc2VGbG9hdChzdHlsZS5ib3JkZXJSaWdodFdpZHRoIHx8IFwiMFwiKSA6IHBhcnNlRmxvYXQoc3R5bGUuYm9yZGVyVG9wV2lkdGggfHwgXCIwXCIpICsgcGFyc2VGbG9hdChzdHlsZS5ib3JkZXJCb3R0b21XaWR0aCB8fCBcIjBcIik7XG4gICAgaWYgKGlzQm9yZGVyQm94U2l6aW5nKSB7XG4gICAgICBzaXplID0gdXNlT2Zmc2V0ID8gYmFzZVNpemUgOiBiYXNlU2l6ZSAtIGJvcmRlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHBhZGRpbmcgPSBob3Jpem9udGFsID8gcGFyc2VGbG9hdChzdHlsZS5wYWRkaW5nTGVmdCB8fCBcIjBcIikgKyBwYXJzZUZsb2F0KHN0eWxlLnBhZGRpbmdSaWdodCB8fCBcIjBcIikgOiBwYXJzZUZsb2F0KHN0eWxlLnBhZGRpbmdUb3AgfHwgXCIwXCIpICsgcGFyc2VGbG9hdChzdHlsZS5wYWRkaW5nQm90dG9tIHx8IFwiMFwiKTtcbiAgICAgIHNpemUgPSB1c2VPZmZzZXQgPyBiYXNlU2l6ZSArIHBhZGRpbmcgKyBib3JkZXIgOiBiYXNlU2l6ZSArIHBhZGRpbmc7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBzaXplU3RyID0gaG9yaXpvbnRhbCA/IFwiV2lkdGhcIiA6IFwiSGVpZ2h0XCI7XG4gICAgc2l6ZSA9IHVzZU9mZnNldCA/IGVsW1wib2Zmc2V0XCIgKyBzaXplU3RyXSA6IGVsW1wiY2xpZW50XCIgKyBzaXplU3RyXTtcbiAgfVxuICByZXR1cm4gTWF0aC5tYXgoc2l6ZSwgMCk7XG59O1xudmFyIHNldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIChvYmosIHByb3RvKSB7XG4gIG9iai5fX3Byb3RvX18gPSBwcm90bztcbiAgcmV0dXJuIG9iajtcbn07XG5cbi8qXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNSBOQVZFUiBDb3JwLlxyXG4gKiBlZ2pzIHByb2plY3RzIGFyZSBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXG4vKipcclxuICogU3BlY2lhbCB0eXBlIG9mIGtub3duIGVycm9yIHRoYXQge0BsaW5rIEZsaWNraW5nfSB0aHJvd3MuXHJcbiAqIEBrbyBGbGlja2luZyDrgrTrtoDsl5DshJwg7JWM66Ck7KeEIOyYpOulmCDrsJzsg53si5wgdGhyb3frkJjripQg7JeQ65+sXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb2RlIEVycm9yIGNvZGU8a28+7JeQ65+sIOy9lOuTnDwva28+XHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtZXNzYWdlIEVycm9yIG1lc3NhZ2U8a28+7JeQ65+sIOuplOyLnOyngDwva28+XHJcbiAqIEBzZWUge0BsaW5rIEVSUk9SX0NPREUgRVJST1JfQ09ERX1cclxuICogQGV4YW1wbGVcclxuICogYGBgdHNcclxuICogaW1wb3J0IEZsaWNraW5nLCB7IEZsaWNraW5nRXJyb3IsIEVSUk9SX0NPREVTIH0gZnJvbSBcIkBlZ2pzL2ZsaWNraW5nXCI7XHJcbiAqIHRyeSB7XHJcbiAqICAgY29uc3QgZmxpY2tpbmcgPSBuZXcgRmxpY2tpbmcoXCIuZmxpY2tpbmctdmlld3BvcnRcIilcclxuICogfSBjYXRjaCAoZSkge1xyXG4gKiAgIGlmIChlIGluc3RhbmNlb2YgRmxpY2tpbmdFcnJvciAmJiBlLmNvZGUgPT09IEVSUk9SX0NPREVTLkVMRU1FTlRfTk9UX0ZPVU5EKSB7XHJcbiAqICAgICBjb25zb2xlLmVycm9yKFwiRWxlbWVudCBub3QgZm91bmRcIilcclxuICogICB9XHJcbiAqIH1cclxuICogYGBgXHJcbiAqL1xudmFyIEZsaWNraW5nRXJyb3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMkMyhGbGlja2luZ0Vycm9yLCBfc3VwZXIpO1xuICAvKipcclxuICAgKiBAcGFyYW0gbWVzc2FnZSBFcnJvciBtZXNzYWdlPGtvPuyXkOufrCDrqZTsi5zsp4A8L2tvPlxyXG4gICAqIEBwYXJhbSBjb2RlIEVycm9yIGNvZGU8a28+7JeQ65+sIOy9lOuTnDwva28+XHJcbiAgICovXG4gIGZ1bmN0aW9uIEZsaWNraW5nRXJyb3IobWVzc2FnZSwgY29kZSkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG1lc3NhZ2UpIHx8IHRoaXM7XG4gICAgc2V0UHJvdG90eXBlT2YoX3RoaXMsIEZsaWNraW5nRXJyb3IucHJvdG90eXBlKTtcbiAgICBfdGhpcy5uYW1lID0gXCJGbGlja2luZ0Vycm9yXCI7XG4gICAgX3RoaXMuY29kZSA9IGNvZGU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIHJldHVybiBGbGlja2luZ0Vycm9yO1xufShFcnJvcik7XG5cbi8qKlxyXG4gKiBBIGNvbXBvbmVudCB0aGF0IG1hbmFnZXMgdmlld3BvcnQgc2l6ZVxyXG4gKiBAa28g67ew7Y+s7Yq4IO2BrOq4sCDsoJXrs7Trpbwg64u064u57ZWY64qUIOy7tO2PrOuEjO2KuFxyXG4gKi9cbnZhciBWaWV3cG9ydCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxyXG4gICAqIEBwYXJhbSBlbCBBIHZpZXdwb3J0IGVsZW1lbnQ8a28+67ew7Y+s7Yq4IOyXmOumrOuovO2KuDwva28+XHJcbiAgICovXG4gIGZ1bmN0aW9uIFZpZXdwb3J0KGZsaWNraW5nLCBlbCkge1xuICAgIHRoaXMuX2ZsaWNraW5nID0gZmxpY2tpbmc7XG4gICAgdGhpcy5fZWwgPSBlbDtcbiAgICB0aGlzLl93aWR0aCA9IDA7XG4gICAgdGhpcy5faGVpZ2h0ID0gMDtcbiAgICB0aGlzLl9wYWRkaW5nID0ge1xuICAgICAgbGVmdDogMCxcbiAgICAgIHJpZ2h0OiAwLFxuICAgICAgdG9wOiAwLFxuICAgICAgYm90dG9tOiAwXG4gICAgfTtcbiAgICB0aGlzLl9pc0JvcmRlckJveFNpemluZyA9IGZhbHNlO1xuICB9XG4gIHZhciBfX3Byb3RvID0gVmlld3BvcnQucHJvdG90eXBlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJlbGVtZW50XCIsIHtcbiAgICAvKipcclxuICAgICAqIEEgdmlld3BvcnQocm9vdCkgZWxlbWVudFxyXG4gICAgICogQGtvIOu3sO2PrO2KuChyb290KSDsl5jrpqzrqLztirhcclxuICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZWw7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcIndpZHRoXCIsIHtcbiAgICAvKipcclxuICAgICAqIFZpZXdwb3J0IHdpZHRoLCB3aXRob3V0IHBhZGRpbmdzXHJcbiAgICAgKiBAa28g67ew7Y+s7Yq4IOuEiOu5hFxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fd2lkdGggLSB0aGlzLl9wYWRkaW5nLmxlZnQgLSB0aGlzLl9wYWRkaW5nLnJpZ2h0O1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJoZWlnaHRcIiwge1xuICAgIC8qKlxyXG4gICAgICogVmlld3BvcnQgaGVpZ2h0LCB3aXRob3V0IHBhZGRpbmdzXHJcbiAgICAgKiBAa28g67ew7Y+s7Yq4IOuGkuydtFxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5faGVpZ2h0IC0gdGhpcy5fcGFkZGluZy50b3AgLSB0aGlzLl9wYWRkaW5nLmJvdHRvbTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwicGFkZGluZ1wiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBWaWV3cG9ydCBwYWRkaW5nc1xyXG4gICAgICogQGtvIOu3sO2PrO2KuCBDU1MgcGFkZGluZyDqsJJcclxuICAgICAqIEB0eXBlIHtvYmplY3R9XHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbGVmdCBDU1MgYHBhZGRpbmctbGVmdGBcclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSByaWdodCBDU1MgYHBhZGRpbmctcmlnaHRgXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gdG9wIENTUyBgcGFkZGluZy10b3BgXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gYm90dG9tIENTUyBgcGFkZGluZy1ib3R0b21gXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3BhZGRpbmc7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIC8qKlxyXG4gICAqIENoYW5nZSB2aWV3cG9ydCdzIHNpemUuXHJcbiAgICogVGhpcyB3aWxsIGNoYW5nZSB0aGUgYWN0dWFsIHNpemUgb2YgYC5mbGlja2luZy12aWV3cG9ydGAgZWxlbWVudCBieSBjaGFuZ2luZyBpdHMgQ1NTIHdpZHRoL2hlaWdodCBwcm9wZXJ0eVxyXG4gICAqIEBrbyDrt7Dtj6ztirgg7YGs6riw66W8IOuzgOqyve2VqeuLiOuLpC5cclxuICAgKiBgLmZsaWNraW5nLXZpZXdwb3J0YCDsl5jrpqzrqLztirjsl5Ag7ZW064u5IO2BrOq4sOydmCBDU1Mgd2lkdGgvaGVpZ2h066W8IOyggeyaqe2VqeuLiOuLpFxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbc2l6ZV0gTmV3IHZpZXdwb3J0IHNpemU8a28+7IOIIOu3sO2PrO2KuCDtgazquLA8L2tvPlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW3NpemUud2lkdGhdIENTUyBzdHJpbmcgb3IgbnVtYmVyKGluIHB4KTxrbz5DU1Mg66y47J6Q7Je0IOuYkOuKlCDsiKvsnpAocHgpPC9rbz5cclxuICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtzaXplLmhlaWdodF0gQ1NTIHN0cmluZyBvciBudW1iZXIoaW4gcHgpPGtvPkNTUyDrrLjsnpDsl7Qg65iQ64qUIOyIq+yekChweCk8L2tvPlxyXG4gICAqL1xuICBfX3Byb3RvLnNldFNpemUgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgd2lkdGggPSBfYS53aWR0aCxcbiAgICAgIGhlaWdodCA9IF9hLmhlaWdodDtcbiAgICB2YXIgZWwgPSB0aGlzLl9lbDtcbiAgICB2YXIgcGFkZGluZyA9IHRoaXMuX3BhZGRpbmc7XG4gICAgdmFyIGlzQm9yZGVyQm94U2l6aW5nID0gdGhpcy5faXNCb3JkZXJCb3hTaXppbmc7XG4gICAgaWYgKHdpZHRoICE9IG51bGwpIHtcbiAgICAgIGlmIChpc1N0cmluZyh3aWR0aCkpIHtcbiAgICAgICAgZWwuc3R5bGUud2lkdGggPSB3aWR0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBuZXdXaWR0aCA9IGlzQm9yZGVyQm94U2l6aW5nID8gd2lkdGggKyBwYWRkaW5nLmxlZnQgKyBwYWRkaW5nLnJpZ2h0IDogd2lkdGg7XG4gICAgICAgIGVsLnN0eWxlLndpZHRoID0gbmV3V2lkdGggKyBcInB4XCI7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChoZWlnaHQgIT0gbnVsbCkge1xuICAgICAgaWYgKGlzU3RyaW5nKGhlaWdodCkpIHtcbiAgICAgICAgZWwuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG5ld0hlaWdodCA9IGlzQm9yZGVyQm94U2l6aW5nID8gaGVpZ2h0ICsgcGFkZGluZy50b3AgKyBwYWRkaW5nLmJvdHRvbSA6IGhlaWdodDtcbiAgICAgICAgZWwuc3R5bGUuaGVpZ2h0ID0gbmV3SGVpZ2h0ICsgXCJweFwiO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnJlc2l6ZSgpO1xuICB9O1xuICAvKipcclxuICAgKiBVcGRhdGUgd2lkdGgvaGVpZ2h0IHRvIHRoZSBjdXJyZW50IHZpZXdwb3J0IGVsZW1lbnQncyBzaXplXHJcbiAgICogQGtvIO2YhOyerCDrt7Dtj6ztirgg7JeY66as66i87Yq47J2YIO2BrOq4sOuhnCDrhIjruYQv64aS7J2066W8IOyXheuNsOydtO2KuO2VqeuLiOuLpFxyXG4gICAqL1xuICBfX3Byb3RvLnJlc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZWwgPSB0aGlzLl9lbDtcbiAgICB2YXIgZWxTdHlsZSA9IGdldFN0eWxlKGVsKTtcbiAgICB2YXIgdXNlRnJhY3Rpb25hbFNpemUgPSB0aGlzLl9mbGlja2luZy51c2VGcmFjdGlvbmFsU2l6ZTtcbiAgICB0aGlzLl93aWR0aCA9IGdldEVsZW1lbnRTaXplKHtcbiAgICAgIGVsOiBlbCxcbiAgICAgIGhvcml6b250YWw6IHRydWUsXG4gICAgICB1c2VGcmFjdGlvbmFsU2l6ZTogdXNlRnJhY3Rpb25hbFNpemUsXG4gICAgICB1c2VPZmZzZXQ6IGZhbHNlLFxuICAgICAgc3R5bGU6IGVsU3R5bGVcbiAgICB9KTtcbiAgICB0aGlzLl9oZWlnaHQgPSBnZXRFbGVtZW50U2l6ZSh7XG4gICAgICBlbDogZWwsXG4gICAgICBob3Jpem9udGFsOiBmYWxzZSxcbiAgICAgIHVzZUZyYWN0aW9uYWxTaXplOiB1c2VGcmFjdGlvbmFsU2l6ZSxcbiAgICAgIHVzZU9mZnNldDogZmFsc2UsXG4gICAgICBzdHlsZTogZWxTdHlsZVxuICAgIH0pO1xuICAgIHRoaXMuX3BhZGRpbmcgPSB7XG4gICAgICBsZWZ0OiBlbFN0eWxlLnBhZGRpbmdMZWZ0ID8gcGFyc2VGbG9hdChlbFN0eWxlLnBhZGRpbmdMZWZ0KSA6IDAsXG4gICAgICByaWdodDogZWxTdHlsZS5wYWRkaW5nUmlnaHQgPyBwYXJzZUZsb2F0KGVsU3R5bGUucGFkZGluZ1JpZ2h0KSA6IDAsXG4gICAgICB0b3A6IGVsU3R5bGUucGFkZGluZ1RvcCA/IHBhcnNlRmxvYXQoZWxTdHlsZS5wYWRkaW5nVG9wKSA6IDAsXG4gICAgICBib3R0b206IGVsU3R5bGUucGFkZGluZ0JvdHRvbSA/IHBhcnNlRmxvYXQoZWxTdHlsZS5wYWRkaW5nQm90dG9tKSA6IDBcbiAgICB9O1xuICAgIHRoaXMuX2lzQm9yZGVyQm94U2l6aW5nID0gZWxTdHlsZS5ib3hTaXppbmcgPT09IFwiYm9yZGVyLWJveFwiO1xuICB9O1xuICByZXR1cm4gVmlld3BvcnQ7XG59KCk7XG5cbnZhciBBdXRvUmVzaXplciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEF1dG9SZXNpemVyKGZsaWNraW5nKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB0aGlzLl9vblJlc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBmbGlja2luZyA9IF90aGlzLl9mbGlja2luZztcbiAgICAgIHZhciByZXNpemVEZWJvdW5jZSA9IGZsaWNraW5nLnJlc2l6ZURlYm91bmNlO1xuICAgICAgdmFyIG1heFJlc2l6ZURlYm91bmNlID0gZmxpY2tpbmcubWF4UmVzaXplRGVib3VuY2U7XG4gICAgICBpZiAocmVzaXplRGVib3VuY2UgPD0gMCkge1xuICAgICAgICB2b2lkIGZsaWNraW5nLnJlc2l6ZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKF90aGlzLl9tYXhSZXNpemVEZWJvdW5jZVRpbWVyIDw9IDApIHtcbiAgICAgICAgICBpZiAobWF4UmVzaXplRGVib3VuY2UgPiAwICYmIG1heFJlc2l6ZURlYm91bmNlID49IHJlc2l6ZURlYm91bmNlKSB7XG4gICAgICAgICAgICBfdGhpcy5fbWF4UmVzaXplRGVib3VuY2VUaW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KF90aGlzLl9kb1NjaGVkdWxlZFJlc2l6ZSwgbWF4UmVzaXplRGVib3VuY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoX3RoaXMuX3Jlc2l6ZVRpbWVyID4gMCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dChfdGhpcy5fcmVzaXplVGltZXIpO1xuICAgICAgICAgIF90aGlzLl9yZXNpemVUaW1lciA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMuX3Jlc2l6ZVRpbWVyID0gd2luZG93LnNldFRpbWVvdXQoX3RoaXMuX2RvU2NoZWR1bGVkUmVzaXplLCByZXNpemVEZWJvdW5jZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLl9kb1NjaGVkdWxlZFJlc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGNsZWFyVGltZW91dChfdGhpcy5fcmVzaXplVGltZXIpO1xuICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLl9tYXhSZXNpemVEZWJvdW5jZVRpbWVyKTtcbiAgICAgIF90aGlzLl9tYXhSZXNpemVEZWJvdW5jZVRpbWVyID0gLTE7XG4gICAgICBfdGhpcy5fcmVzaXplVGltZXIgPSAtMTtcbiAgICAgIHZvaWQgX3RoaXMuX2ZsaWNraW5nLnJlc2l6ZSgpO1xuICAgIH07XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9tZW1iZXItb3JkZXJpbmdcbiAgICB0aGlzLl9za2lwRmlyc3RSZXNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaXNGaXJzdFJlc2l6ZSA9IHRydWU7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaXNGaXJzdFJlc2l6ZSkge1xuICAgICAgICAgIGlzRmlyc3RSZXNpemUgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMuX29uUmVzaXplKCk7XG4gICAgICB9O1xuICAgIH0oKTtcbiAgICB0aGlzLl9mbGlja2luZyA9IGZsaWNraW5nO1xuICAgIHRoaXMuX2VuYWJsZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZXNpemVPYnNlcnZlciA9IG51bGw7XG4gICAgdGhpcy5fcmVzaXplVGltZXIgPSAtMTtcbiAgICB0aGlzLl9tYXhSZXNpemVEZWJvdW5jZVRpbWVyID0gLTE7XG4gIH1cbiAgdmFyIF9fcHJvdG8gPSBBdXRvUmVzaXplci5wcm90b3R5cGU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcImVuYWJsZWRcIiwge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2VuYWJsZWQ7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIF9fcHJvdG8uZW5hYmxlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBmbGlja2luZyA9IHRoaXMuX2ZsaWNraW5nO1xuICAgIHZhciB2aWV3cG9ydCA9IGZsaWNraW5nLnZpZXdwb3J0O1xuICAgIGlmICh0aGlzLl9lbmFibGVkKSB7XG4gICAgICB0aGlzLmRpc2FibGUoKTtcbiAgICB9XG4gICAgaWYgKGZsaWNraW5nLnVzZVJlc2l6ZU9ic2VydmVyICYmICEhd2luZG93LlJlc2l6ZU9ic2VydmVyKSB7XG4gICAgICB2YXIgdmlld3BvcnRTaXplTm90MCA9IHZpZXdwb3J0LndpZHRoICE9PSAwIHx8IHZpZXdwb3J0LmhlaWdodCAhPT0gMDtcbiAgICAgIHZhciByZXNpemVPYnNlcnZlciA9IHZpZXdwb3J0U2l6ZU5vdDAgPyBuZXcgUmVzaXplT2JzZXJ2ZXIodGhpcy5fc2tpcEZpcnN0UmVzaXplKSA6IG5ldyBSZXNpemVPYnNlcnZlcih0aGlzLl9vblJlc2l6ZSk7XG4gICAgICByZXNpemVPYnNlcnZlci5vYnNlcnZlKGZsaWNraW5nLnZpZXdwb3J0LmVsZW1lbnQpO1xuICAgICAgdGhpcy5fcmVzaXplT2JzZXJ2ZXIgPSByZXNpemVPYnNlcnZlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5fb25SZXNpemUpO1xuICAgIH1cbiAgICB0aGlzLl9lbmFibGVkID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgX19wcm90by5kaXNhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5fZW5hYmxlZCkgcmV0dXJuIHRoaXM7XG4gICAgdmFyIHJlc2l6ZU9ic2VydmVyID0gdGhpcy5fcmVzaXplT2JzZXJ2ZXI7XG4gICAgaWYgKHJlc2l6ZU9ic2VydmVyKSB7XG4gICAgICByZXNpemVPYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICB0aGlzLl9yZXNpemVPYnNlcnZlciA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMuX29uUmVzaXplKTtcbiAgICB9XG4gICAgdGhpcy5fZW5hYmxlZCA9IGZhbHNlO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICByZXR1cm4gQXV0b1Jlc2l6ZXI7XG59KCk7XG5cbi8qKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXG52YXIgVmFuaWxsYUVsZW1lbnRQcm92aWRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFZhbmlsbGFFbGVtZW50UHJvdmlkZXIoZWxlbWVudCkge1xuICAgIHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMuX3JlbmRlcmVkID0gdHJ1ZTtcbiAgfVxuICB2YXIgX19wcm90byA9IFZhbmlsbGFFbGVtZW50UHJvdmlkZXIucHJvdG90eXBlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJlbGVtZW50XCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9lbGVtZW50O1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJyZW5kZXJlZFwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVuZGVyZWQ7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIF9fcHJvdG8uc2hvdyA9IGZ1bmN0aW9uIChmbGlja2luZykge1xuICAgIHZhciBlbCA9IHRoaXMuZWxlbWVudDtcbiAgICB2YXIgY2FtZXJhRWwgPSBmbGlja2luZy5jYW1lcmEuZWxlbWVudDtcbiAgICBpZiAoZWwucGFyZW50RWxlbWVudCAhPT0gY2FtZXJhRWwpIHtcbiAgICAgIGNhbWVyYUVsLmFwcGVuZENoaWxkKGVsKTtcbiAgICAgIHRoaXMuX3JlbmRlcmVkID0gdHJ1ZTtcbiAgICB9XG4gIH07XG4gIF9fcHJvdG8uaGlkZSA9IGZ1bmN0aW9uIChmbGlja2luZykge1xuICAgIHZhciBlbCA9IHRoaXMuZWxlbWVudDtcbiAgICB2YXIgY2FtZXJhRWwgPSBmbGlja2luZy5jYW1lcmEuZWxlbWVudDtcbiAgICBpZiAoZWwucGFyZW50RWxlbWVudCA9PT0gY2FtZXJhRWwpIHtcbiAgICAgIGNhbWVyYUVsLnJlbW92ZUNoaWxkKGVsKTtcbiAgICAgIHRoaXMuX3JlbmRlcmVkID0gZmFsc2U7XG4gICAgfVxuICB9O1xuICByZXR1cm4gVmFuaWxsYUVsZW1lbnRQcm92aWRlcjtcbn0oKTtcblxuLypcclxuICogQ29weXJpZ2h0IChjKSAyMDE1IE5BVkVSIENvcnAuXHJcbiAqIGVnanMgcHJvamVjdHMgYXJlIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cbi8qKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXG52YXIgVmlydHVhbEVsZW1lbnRQcm92aWRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFZpcnR1YWxFbGVtZW50UHJvdmlkZXIoZmxpY2tpbmcpIHtcbiAgICB0aGlzLl9mbGlja2luZyA9IGZsaWNraW5nO1xuICB9XG4gIHZhciBfX3Byb3RvID0gVmlydHVhbEVsZW1lbnRQcm92aWRlci5wcm90b3R5cGU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcImVsZW1lbnRcIiwge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3ZpcnR1YWxFbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcInJlbmRlcmVkXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl92aXJ0dWFsRWxlbWVudC52aXNpYmxlO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJfdmlydHVhbEVsZW1lbnRcIiwge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGZsaWNraW5nID0gdGhpcy5fZmxpY2tpbmc7XG4gICAgICB2YXIgZWxJbmRleCA9IHRoaXMuX3BhbmVsLmVsZW1lbnRJbmRleDtcbiAgICAgIHZhciB2aXJ0dWFsRWxlbWVudHMgPSBmbGlja2luZy52aXJ0dWFsLmVsZW1lbnRzO1xuICAgICAgcmV0dXJuIHZpcnR1YWxFbGVtZW50c1tlbEluZGV4XTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgX19wcm90by5pbml0ID0gZnVuY3Rpb24gKHBhbmVsKSB7XG4gICAgdGhpcy5fcGFuZWwgPSBwYW5lbDtcbiAgfTtcbiAgX19wcm90by5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIERPX05PVEhJTkdcbiAgICAvLyBBY3R1YWwgZWxlbWVudCB2aXNpYmlsaXR5IGlzIGNvbnRyb2xsZWQgYnkgVmlydHVhbE1hbmFnZXJcbiAgfTtcbiAgX19wcm90by5oaWRlID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIERPX05PVEhJTkdcbiAgICAvLyBBY3R1YWwgZWxlbWVudCB2aXNpYmlsaXR5IGlzIGNvbnRyb2xsZWQgYnkgVmlydHVhbE1hbmFnZXJcbiAgfTtcbiAgcmV0dXJuIFZpcnR1YWxFbGVtZW50UHJvdmlkZXI7XG59KCk7XG5cbi8qKlxyXG4gKiBBIG1hbmFnZXIgY2xhc3MgdG8gYWRkIC8gcmVtb3ZlIHZpcnR1YWwgcGFuZWxzXHJcbiAqL1xudmFyIFZpcnR1YWxNYW5hZ2VyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVmlydHVhbE1hbmFnZXIoZmxpY2tpbmcsIG9wdGlvbnMpIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgdGhpcy5fZmxpY2tpbmcgPSBmbGlja2luZztcbiAgICB0aGlzLl9yZW5kZXJQYW5lbCA9IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5yZW5kZXJQYW5lbCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfTtcbiAgICB0aGlzLl9pbml0aWFsUGFuZWxDb3VudCA9IChfYiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5pbml0aWFsUGFuZWxDb3VudCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogLTE7XG4gICAgdGhpcy5fY2FjaGUgPSAoX2MgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2FjaGUpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IGZhbHNlO1xuICAgIHRoaXMuX3BhbmVsQ2xhc3MgPSAoX2QgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucGFuZWxDbGFzcykgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogQ0xBU1MuREVGQVVMVF9WSVJUVUFMO1xuICAgIHRoaXMuX2VsZW1lbnRzID0gW107XG4gIH1cbiAgdmFyIF9fcHJvdG8gPSBWaXJ0dWFsTWFuYWdlci5wcm90b3R5cGU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcImVsZW1lbnRzXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9lbGVtZW50cztcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwicmVuZGVyUGFuZWxcIiwge1xuICAgIC8vIE9wdGlvbnNcbiAgICAvKipcclxuICAgICAqIEEgcmVuZGVyaW5nIGZ1bmN0aW9uIGZvciB0aGUgcGFuZWwgZWxlbWVudCdzIGlubmVySFRNTFxyXG4gICAgICogQGtvIO2MqOuEkCDsl5jrpqzrqLztirjsnZggaW5uZXJIVE1M7J2EIOugjOuNlOunge2VmOuKlCDtlajsiJhcclxuICAgICAqIEB0eXBlIHtmdW5jdGlvbn1cclxuICAgICAqIEBwYXJhbSB7VmlydHVhbFBhbmVsfSBwYW5lbCBJbnN0YW5jZSBvZiB0aGUgcGFuZWw8a28+7Yyo64SQIOyduOyKpO2EtOyKpDwva28+XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggb2YgdGhlIHBhbmVsPGtvPu2MqOuEkCDsnbjrjbHsiqQ8L2tvPlxyXG4gICAgICogQGRlZmF1bHQgXCIoKSA9PiB7fVwiXHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJQYW5lbDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgdGhpcy5fcmVuZGVyUGFuZWwgPSB2YWw7XG4gICAgICB0aGlzLl9mbGlja2luZy5yZW5kZXJlci5wYW5lbHMuZm9yRWFjaChmdW5jdGlvbiAocGFuZWwpIHtcbiAgICAgICAgcmV0dXJuIHBhbmVsLnVuY2FjaGVSZW5kZXJSZXN1bHQoKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJpbml0aWFsUGFuZWxDb3VudFwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWFsIHBhbmVsIGNvdW50IHRvIHJlbmRlclxyXG4gICAgICogQGtvIOy1nOy0iOuhnCDroIzrjZTrp4HtlaAg7Yyo64SQ7J2YIOqwnOyImFxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgLTFcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2luaXRpYWxQYW5lbENvdW50O1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJjYWNoZVwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHRvIGNhY2hlIHJlbmRlcmVkIHBhbmVsJ3MgaW5uZXJIVE1MXHJcbiAgICAgKiBAa28g66CM642U66eB65CcIO2MqOuEkOydmCBpbm5lckhUTUwg7KCV67O066W8IOy6kOyLnO2VoOyngCDsl6zrtoBcclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICogQGRlZmF1bHQgZmFsc2VcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICB0aGlzLl9jYWNoZSA9IHZhbDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwicGFuZWxDbGFzc1wiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBUaGUgY2xhc3MgbmFtZSB0aGF0IHdpbGwgYmUgYXBwbGllZCB0byByZW5kZXJlZCBwYW5lbCBlbGVtZW50c1xyXG4gICAgICogQGtvIOugjOuNlOungeuQmOuKlCDtjKjrhJAg7JeY66as66i87Yq47JeQIOyggeyaqeuQoCDtgbTrnpjsiqQg7J2066aEXHJcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICogQGRlZmF1bHQgXCJmbGlja2luZy1wYW5lbFwiXHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wYW5lbENsYXNzO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICB0aGlzLl9wYW5lbENsYXNzID0gdmFsO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBfX3Byb3RvLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZsaWNraW5nID0gdGhpcy5fZmxpY2tpbmc7XG4gICAgaWYgKCFmbGlja2luZy52aXJ0dWFsRW5hYmxlZCkgcmV0dXJuO1xuICAgIGlmICghZmxpY2tpbmcuZXh0ZXJuYWxSZW5kZXJlciAmJiAhZmxpY2tpbmcucmVuZGVyRXh0ZXJuYWwpIHtcbiAgICAgIHRoaXMuX2luaXRWaXJ0dWFsRWxlbWVudHMoKTtcbiAgICB9XG4gICAgdmFyIHZpcnR1YWxFbGVtZW50cyA9IGZsaWNraW5nLmNhbWVyYS5jaGlsZHJlbjtcbiAgICB0aGlzLl9lbGVtZW50cyA9IHZpcnR1YWxFbGVtZW50cy5tYXAoZnVuY3Rpb24gKGVsKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYXRpdmVFbGVtZW50OiBlbCxcbiAgICAgICAgdmlzaWJsZTogdHJ1ZVxuICAgICAgfTtcbiAgICB9KTtcbiAgfTtcbiAgX19wcm90by5zaG93ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgdmFyIGVsID0gdGhpcy5fZWxlbWVudHNbaW5kZXhdO1xuICAgIHZhciBuYXRpdmVFbCA9IGVsLm5hdGl2ZUVsZW1lbnQ7XG4gICAgZWwudmlzaWJsZSA9IHRydWU7XG4gICAgaWYgKG5hdGl2ZUVsLnN0eWxlLmRpc3BsYXkpIHtcbiAgICAgIG5hdGl2ZUVsLnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuICAgIH1cbiAgfTtcbiAgX19wcm90by5oaWRlID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgdmFyIGVsID0gdGhpcy5fZWxlbWVudHNbaW5kZXhdO1xuICAgIHZhciBuYXRpdmVFbCA9IGVsLm5hdGl2ZUVsZW1lbnQ7XG4gICAgZWwudmlzaWJsZSA9IGZhbHNlO1xuICAgIG5hdGl2ZUVsLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgfTtcbiAgLyoqXHJcbiAgICogQWRkIG5ldyB2aXJ0dWFsIHBhbmVscyBhdCB0aGUgZW5kIG9mIHRoZSBsaXN0XHJcbiAgICogQGtvIOyDiOuhnOyatCDqsIDsg4Eg7Yyo64SQ65Ok7J2EIOumrOyKpO2KuOydmCDrgZ3sl5Ag7LaU6rCA7ZWp64uI64ukXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNvdW50IFRoZSBudW1iZXIgb2YgcGFuZWxzIHRvIGFkZDxrbz7stpTqsIDtlaAg7Yyo64SQ7J2YIOqwnOyImDwva28+XHJcbiAgICogQHJldHVybnMge0FycmF5PFZpcnR1YWxQYW5lbD59IFRoZSBuZXcgcGFuZWxzIGFkZGVkPGtvPuyDiOuhreqyjCDstpTqsIDrkJwg7Yyo64SQ65OkPC9rbz5cclxuICAgKi9cbiAgX19wcm90by5hcHBlbmQgPSBmdW5jdGlvbiAoY291bnQpIHtcbiAgICBpZiAoY291bnQgPT09IHZvaWQgMCkge1xuICAgICAgY291bnQgPSAxO1xuICAgIH1cbiAgICB2YXIgZmxpY2tpbmcgPSB0aGlzLl9mbGlja2luZztcbiAgICByZXR1cm4gdGhpcy5pbnNlcnQoZmxpY2tpbmcucGFuZWxzLmxlbmd0aCwgY291bnQpO1xuICB9O1xuICAvKipcclxuICAgKiBBZGQgbmV3IHZpcnR1YWwgcGFuZWxzIGF0IHRoZSBzdGFydCBvZiB0aGUgbGlzdFxyXG4gICAqIEBrbyDsg4jroZzsmrQg6rCA7IOBIO2MqOuEkOuTpOydhCDrpqzsiqTtirjsnZgg7Iuc7J6R7JeQIOy2lOqwgO2VqeuLiOuLpFxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudCBUaGUgbnVtYmVyIG9mIHBhbmVscyB0byBhZGQ8a28+7LaU6rCA7ZWgIO2MqOuEkOydmCDqsJzsiJg8L2tvPlxyXG4gICAqIEByZXR1cm5zIHtBcnJheTxWaXJ0dWFsUGFuZWw+fSBUaGUgbmV3IHBhbmVscyBhZGRlZDxrbz7sg4jroa3qsowg7LaU6rCA65CcIO2MqOuEkOuTpDwva28+XHJcbiAgICovXG4gIF9fcHJvdG8ucHJlcGVuZCA9IGZ1bmN0aW9uIChjb3VudCkge1xuICAgIGlmIChjb3VudCA9PT0gdm9pZCAwKSB7XG4gICAgICBjb3VudCA9IDE7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmluc2VydCgwLCBjb3VudCk7XG4gIH07XG4gIC8qKlxyXG4gICAqIEFkZCBuZXcgdmlydHVhbCBwYW5lbHMgYXQgdGhlIGdpdmVuIGluZGV4XHJcbiAgICogQGtvIOyDiOuhnOyatCDqsIDsg4Eg7Yyo64SQ65Ok7J2EIOyjvOyWtOynhCDsnbjrjbHsiqTsl5Ag7LaU6rCA7ZWp64uI64ukXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNvdW50IFRoZSBudW1iZXIgb2YgcGFuZWxzIHRvIGFkZDxrbz7stpTqsIDtlaAg7Yyo64SQ7J2YIOqwnOyImDwva28+XHJcbiAgICogQHJldHVybnMge0FycmF5PFZpcnR1YWxQYW5lbD59IFRoZSBuZXcgcGFuZWxzIGFkZGVkPGtvPuyDiOuhreqyjCDstpTqsIDrkJwg7Yyo64SQ65OkPC9rbz5cclxuICAgKi9cbiAgX19wcm90by5pbnNlcnQgPSBmdW5jdGlvbiAoaW5kZXgsIGNvdW50KSB7XG4gICAgaWYgKGNvdW50ID09PSB2b2lkIDApIHtcbiAgICAgIGNvdW50ID0gMTtcbiAgICB9XG4gICAgaWYgKGNvdW50IDw9IDApIHJldHVybiBbXTtcbiAgICB2YXIgZmxpY2tpbmcgPSB0aGlzLl9mbGlja2luZztcbiAgICByZXR1cm4gZmxpY2tpbmcucmVuZGVyZXIuYmF0Y2hJbnNlcnQoe1xuICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgZWxlbWVudHM6IHJhbmdlKGNvdW50KSxcbiAgICAgIGhhc0RPTUluRWxlbWVudHM6IGZhbHNlXG4gICAgfSk7XG4gIH07XG4gIC8qKlxyXG4gICAqIFJlbW92ZSBwYW5lbHMgYXQgdGhlIGdpdmVuIGluZGV4XHJcbiAgICogQGtvIOyjvOyWtOynhCDsnbjrjbHsiqTsl5DshJwg7Yyo64SQ65Ok7J2EIOyCreygnO2VqeuLiOuLpFxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudCBUaGUgbnVtYmVyIG9mIHBhbmVscyB0byByZW1vdmU8a28+7IKt7KCc7ZWgIO2MqOuEkOydmCDqsJzsiJg8L2tvPlxyXG4gICAqIEByZXR1cm5zIHtBcnJheTxWaXJ0dWFsUGFuZWw+fSBUaGUgcGFuZWxzIHJlbW92ZWQ8a28+7IKt7KCc65CcIO2MqOuEkOuTpDwva28+XHJcbiAgICovXG4gIF9fcHJvdG8ucmVtb3ZlID0gZnVuY3Rpb24gKGluZGV4LCBjb3VudCkge1xuICAgIGlmIChjb3VudCA8PSAwKSByZXR1cm4gW107XG4gICAgdmFyIGZsaWNraW5nID0gdGhpcy5fZmxpY2tpbmc7XG4gICAgcmV0dXJuIGZsaWNraW5nLnJlbmRlcmVyLmJhdGNoUmVtb3ZlKHtcbiAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgIGRlbGV0ZUNvdW50OiBjb3VudCxcbiAgICAgIGhhc0RPTUluRWxlbWVudHM6IGZhbHNlXG4gICAgfSk7XG4gIH07XG4gIF9fcHJvdG8uX2luaXRWaXJ0dWFsRWxlbWVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB2YXIgZmxpY2tpbmcgPSB0aGlzLl9mbGlja2luZztcbiAgICB2YXIgY2FtZXJhRWxlbWVudCA9IGZsaWNraW5nLmNhbWVyYS5lbGVtZW50O1xuICAgIHZhciBwYW5lbHNQZXJWaWV3ID0gZmxpY2tpbmcucGFuZWxzUGVyVmlldztcbiAgICB2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgdmFyIG5ld0VsZW1lbnRzID0gcmFuZ2UocGFuZWxzUGVyVmlldyArIDEpLm1hcChmdW5jdGlvbiAoaWR4KSB7XG4gICAgICB2YXIgcGFuZWxFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBwYW5lbEVsLmNsYXNzTmFtZSA9IF90aGlzLl9wYW5lbENsYXNzO1xuICAgICAgcGFuZWxFbC5kYXRhc2V0LmVsZW1lbnRJbmRleCA9IGlkeC50b1N0cmluZygpO1xuICAgICAgcmV0dXJuIHBhbmVsRWw7XG4gICAgfSk7XG4gICAgbmV3RWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKGVsKTtcbiAgICB9KTtcbiAgICBjYW1lcmFFbGVtZW50LmFwcGVuZENoaWxkKGZyYWdtZW50KTtcbiAgfTtcbiAgcmV0dXJuIFZpcnR1YWxNYW5hZ2VyO1xufSgpO1xuXG4vKipcclxuICogQWxsIHBvc3NpYmxlIEBlZ2pzL2F4ZXMgZXZlbnQga2V5c1xyXG4gKiBAaW50ZXJuYWxcclxuICovXG52YXIgRVZFTlQgPSB7XG4gIEhPTEQ6IFwiaG9sZFwiLFxuICBDSEFOR0U6IFwiY2hhbmdlXCIsXG4gIFJFTEVBU0U6IFwicmVsZWFzZVwiLFxuICBBTklNQVRJT05fRU5EOiBcImFuaW1hdGlvbkVuZFwiLFxuICBGSU5JU0g6IFwiZmluaXNoXCJcbn07XG4vKipcclxuICogQW4gQXhpcyBrZXkgdGhhdCBGbGlja2luZyB1c2VzXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cbnZhciBQT1NJVElPTl9LRVkgPSBcImZsaWNrXCI7XG5cbnZhciBTVEFURV9UWVBFO1xuKGZ1bmN0aW9uIChTVEFURV9UWVBFKSB7XG4gIFNUQVRFX1RZUEVbU1RBVEVfVFlQRVtcIklETEVcIl0gPSAwXSA9IFwiSURMRVwiO1xuICBTVEFURV9UWVBFW1NUQVRFX1RZUEVbXCJIT0xESU5HXCJdID0gMV0gPSBcIkhPTERJTkdcIjtcbiAgU1RBVEVfVFlQRVtTVEFURV9UWVBFW1wiRFJBR0dJTkdcIl0gPSAyXSA9IFwiRFJBR0dJTkdcIjtcbiAgU1RBVEVfVFlQRVtTVEFURV9UWVBFW1wiQU5JTUFUSU5HXCJdID0gM10gPSBcIkFOSU1BVElOR1wiO1xuICBTVEFURV9UWVBFW1NUQVRFX1RZUEVbXCJESVNBQkxFRFwiXSA9IDRdID0gXCJESVNBQkxFRFwiO1xufSkoU1RBVEVfVFlQRSB8fCAoU1RBVEVfVFlQRSA9IHt9KSk7XG4vKipcclxuICogQSBjb21wb25lbnQgdGhhdCBzaG93cyB0aGUgY3VycmVudCBzdGF0dXMgb2YgdGhlIHVzZXIgaW5wdXQgb3IgdGhlIGFuaW1hdGlvblxyXG4gKiBAa28g7ZiE7J6sIOyCrOyaqeyekCDsnoXroKUg65iQ64qUIOyVoOuLiOuplOydtOyFmCDsg4Htg5zrpbwg64KY7YOA64K064qUIOy7tO2PrOuEjO2KuFxyXG4gKiBAaW50ZXJuYWxcclxuICovXG52YXIgU3RhdGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTdGF0ZSgpIHtcbiAgICB0aGlzLl9kZWx0YSA9IDA7XG4gICAgdGhpcy5fdGFyZ2V0UGFuZWwgPSBudWxsO1xuICB9XG4gIHZhciBfX3Byb3RvID0gU3RhdGUucHJvdG90eXBlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJkZWx0YVwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBBIHN1bSBvZiBkZWx0YSB2YWx1ZXMgb2YgY2hhbmdlIGV2ZW50cyBmcm9tIHRoZSBsYXN0IGhvbGQgZXZlbnQgb2YgQXhlc1xyXG4gICAgICogQGtvIOydtOyghCBob2xk7J2067Kk7Yq467aA7YSwIGNoYW5nZeyXkCDsnZjtlbQg67Cc7IOd7ZWcIOydtOuPmSBkZWx0YeqwkuydmCDtlansgrBcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2RlbHRhO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJ0YXJnZXRQYW5lbFwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBBIHBhbmVsIHRvIHNldCBhcyB7QGxpbmsgQ29udHJvbCNhY3RpdmVQYW5lbH0gYWZ0ZXIgdGhlIGFuaW1hdGlvbiBpcyBmaW5pc2hlZFxyXG4gICAgICogQGtvIOyVoOuLiOuplOydtOyFmCDsooXro4zsi5wge0BsaW5rIENvbnRyb2wjYWN0aXZlUGFuZWx966GcIOyEpOygle2VoCDtjKjrhJBcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3RhcmdldFBhbmVsO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICB0aGlzLl90YXJnZXRQYW5lbCA9IHZhbDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgLyoqXHJcbiAgICogQW4gY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gc3RhdGUgaGFzIGNoYW5nZWQgdG8gdGhpcyBzdGF0ZVxyXG4gICAqIEBrbyDtmITsnqwg7IOB7YOc66GcIOuPjOyehe2WiOydhOuVjCDtmLjstpzrkJjripQg7L2c67CxIO2VqOyImFxyXG4gICAqIEBwYXJhbSB7U3RhdGV9IHByZXZTdGF0ZSBBbiBwcmV2aW91cyBzdGF0ZTxrbz7snbTsoIQg7IOB7YOc6rCSPC9rbz5cclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xuICBfX3Byb3RvLm9uRW50ZXIgPSBmdW5jdGlvbiAocHJldlN0YXRlKSB7XG4gICAgdGhpcy5fZGVsdGEgPSBwcmV2U3RhdGUuX2RlbHRhO1xuICAgIHRoaXMuX3RhcmdldFBhbmVsID0gcHJldlN0YXRlLl90YXJnZXRQYW5lbDtcbiAgfTtcbiAgLyoqXHJcbiAgICogQW4gZXZlbnQgaGFuZGxlciBmb3IgQXhlcydzIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWF4ZXMvcmVsZWFzZS9sYXRlc3QvZG9jL2VnLkF4ZXMuaHRtbCNldmVudDpob2xkIGhvbGR9IGV2ZW50XHJcbiAgICogQGtvIEF4ZXPsnZgge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtYXhlcy9yZWxlYXNlL2xhdGVzdC9kb2MvZWcuQXhlcy5odG1sI2V2ZW50OmhvbGQgaG9sZH0g7J2067Kk7Yq4IO2VuOuTpOufrFxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbY3R4XSBFdmVudCBjb250ZXh0PGtvPuydtOuypO2KuCDsvZjthY3siqTtirg8L2tvPlxyXG4gICAqIEBwYXJhbSB7RmxpY2tpbmd9IFtjdHguZmxpY2tpbmddIEFuIGluc3RhbmNlIG9mIEZsaWNraW5nPGtvPkZsaWNraW5nIOyduOyKpO2EtOyKpDwva28+XHJcbiAgICogQHBhcmFtIHtvYmplY3R9IFtjdHguYXhlc0V2ZW50XSBBIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWF4ZXMvcmVsZWFzZS9sYXRlc3QvZG9jL2VnLkF4ZXMuaHRtbCNldmVudDpob2xkIGhvbGR9IGV2ZW50IG9mIEF4ZXNcclxuICAgKiA8a28+QXhlc+ydmCB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1heGVzL3JlbGVhc2UvbGF0ZXN0L2RvYy9lZy5BeGVzLmh0bWwjZXZlbnQ6aG9sZCBob2xkfSDsnbTrsqTtirg8L2tvPlxyXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjdHgudHJhbnNpdFRvXSBBIGZ1bmN0aW9uIGZvciBjaGFuZ2luZyBjdXJyZW50IHN0YXRlIHRvIG90aGVyIHN0YXRlPGtvPuuLpOuluCDsg4Htg5zroZwg67OA6rK97ZWY6riwIOychO2VnCDtlajsiJg8L2tvPlxyXG4gICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICovXG4gIF9fcHJvdG8ub25Ib2xkID0gZnVuY3Rpb24gKGN0eCkge1xuICAgIC8vIERPIE5PVEhJTkdcbiAgfTtcbiAgLyoqXHJcbiAgICogQW4gZXZlbnQgaGFuZGxlciBmb3IgQXhlcydzIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWF4ZXMvcmVsZWFzZS9sYXRlc3QvZG9jL2VnLkF4ZXMuaHRtbCNldmVudDpjaGFuZ2UgY2hhbmdlfSBldmVudFxyXG4gICAqIEBrbyBBeGVz7J2YIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWF4ZXMvcmVsZWFzZS9sYXRlc3QvZG9jL2VnLkF4ZXMuaHRtbCNldmVudDpjaGFuZ2UgY2hhbmdlfSDsnbTrsqTtirgg7ZW465Ok65+sXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IFtjdHhdIEV2ZW50IGNvbnRleHQ8a28+7J2067Kk7Yq4IOy9mO2FjeyKpO2KuDwva28+XHJcbiAgICogQHBhcmFtIHtGbGlja2luZ30gW2N0eC5mbGlja2luZ10gQW4gaW5zdGFuY2Ugb2YgRmxpY2tpbmc8a28+RmxpY2tpbmcg7J247Iqk7YS07IqkPC9rbz5cclxuICAgKiBAcGFyYW0ge29iamVjdH0gW2N0eC5heGVzRXZlbnRdIEEge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtYXhlcy9yZWxlYXNlL2xhdGVzdC9kb2MvZWcuQXhlcy5odG1sI2V2ZW50OmNoYW5nZSBjaGFuZ2V9IGV2ZW50IG9mIEF4ZXNcclxuICAgKiA8a28+QXhlc+ydmCB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1heGVzL3JlbGVhc2UvbGF0ZXN0L2RvYy9lZy5BeGVzLmh0bWwjZXZlbnQ6Y2hhbmdlIGNoYW5nZX0g7J2067Kk7Yq4PC9rbz5cclxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY3R4LnRyYW5zaXRUb10gQSBmdW5jdGlvbiBmb3IgY2hhbmdpbmcgY3VycmVudCBzdGF0ZSB0byBvdGhlciBzdGF0ZTxrbz7ri6Trpbgg7IOB7YOc66GcIOuzgOqyve2VmOq4sCDsnITtlZwg7ZWo7IiYPC9rbz5cclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xuICBfX3Byb3RvLm9uQ2hhbmdlID0gZnVuY3Rpb24gKGN0eCkge1xuICAgIC8vIERPIE5PVEhJTkdcbiAgfTtcbiAgLyoqXHJcbiAgICogQW4gZXZlbnQgaGFuZGxlciBmb3IgQXhlcydzIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWF4ZXMvcmVsZWFzZS9sYXRlc3QvZG9jL2VnLkF4ZXMuaHRtbCNldmVudDpyZWxlYXNlIHJlbGVhc2V9IGV2ZW50XHJcbiAgICogQGtvIEF4ZXPsnZgge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtYXhlcy9yZWxlYXNlL2xhdGVzdC9kb2MvZWcuQXhlcy5odG1sI2V2ZW50OnJlbGVhc2UgcmVsZWFzZX0g7J2067Kk7Yq4IO2VuOuTpOufrFxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbY3R4XSBFdmVudCBjb250ZXh0PGtvPuydtOuypO2KuCDsvZjthY3siqTtirg8L2tvPlxyXG4gICAqIEBwYXJhbSB7RmxpY2tpbmd9IFtjdHguZmxpY2tpbmddIEFuIGluc3RhbmNlIG9mIEZsaWNraW5nPGtvPkZsaWNraW5nIOyduOyKpO2EtOyKpDwva28+XHJcbiAgICogQHBhcmFtIHtvYmplY3R9IFtjdHguYXhlc0V2ZW50XSBBIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWF4ZXMvcmVsZWFzZS9sYXRlc3QvZG9jL2VnLkF4ZXMuaHRtbCNldmVudDpyZWxlYXNlIHJlbGVhc2V9IGV2ZW50IG9mIEF4ZXNcclxuICAgKiA8a28+QXhlc+ydmCB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1heGVzL3JlbGVhc2UvbGF0ZXN0L2RvYy9lZy5BeGVzLmh0bWwjZXZlbnQ6cmVsZWFzZSByZWxlYXNlfSDsnbTrsqTtirg8L2tvPlxyXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjdHgudHJhbnNpdFRvXSBBIGZ1bmN0aW9uIGZvciBjaGFuZ2luZyBjdXJyZW50IHN0YXRlIHRvIG90aGVyIHN0YXRlPGtvPuuLpOuluCDsg4Htg5zroZwg67OA6rK97ZWY6riwIOychO2VnCDtlajsiJg8L2tvPlxyXG4gICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICovXG4gIF9fcHJvdG8ub25SZWxlYXNlID0gZnVuY3Rpb24gKGN0eCkge1xuICAgIC8vIERPIE5PVEhJTkdcbiAgfTtcbiAgLyoqXHJcbiAgICogQW4gZXZlbnQgaGFuZGxlciBmb3IgQXhlcydzIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWF4ZXMvcmVsZWFzZS9sYXRlc3QvZG9jL2VnLkF4ZXMuaHRtbCNldmVudDphbmltYXRpb25FbmQgYW5pbWF0aW9uRW5kfSBldmVudFxyXG4gICAqIEBrbyBBeGVz7J2YIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWF4ZXMvcmVsZWFzZS9sYXRlc3QvZG9jL2VnLkF4ZXMuaHRtbCNldmVudDphbmltYXRpb25FbmQgYW5pbWF0aW9uRW5kfSDsnbTrsqTtirgg7ZW465Ok65+sXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IFtjdHhdIEV2ZW50IGNvbnRleHQ8a28+7J2067Kk7Yq4IOy9mO2FjeyKpO2KuDwva28+XHJcbiAgICogQHBhcmFtIHtGbGlja2luZ30gW2N0eC5mbGlja2luZ10gQW4gaW5zdGFuY2Ugb2YgRmxpY2tpbmc8a28+RmxpY2tpbmcg7J247Iqk7YS07IqkPC9rbz5cclxuICAgKiBAcGFyYW0ge29iamVjdH0gW2N0eC5heGVzRXZlbnRdIEEge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtYXhlcy9yZWxlYXNlL2xhdGVzdC9kb2MvZWcuQXhlcy5odG1sI2V2ZW50OmFuaW1hdGlvbkVuZCBhbmltYXRpb25FbmR9IGV2ZW50IG9mIEF4ZXNcclxuICAgKiA8a28+QXhlc+ydmCB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1heGVzL3JlbGVhc2UvbGF0ZXN0L2RvYy9lZy5BeGVzLmh0bWwjZXZlbnQ6YW5pbWF0aW9uRW5kIGFuaW1hdGlvbkVuZH0g7J2067Kk7Yq4PC9rbz5cclxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY3R4LnRyYW5zaXRUb10gQSBmdW5jdGlvbiBmb3IgY2hhbmdpbmcgY3VycmVudCBzdGF0ZSB0byBvdGhlciBzdGF0ZTxrbz7ri6Trpbgg7IOB7YOc66GcIOuzgOqyve2VmOq4sCDsnITtlZwg7ZWo7IiYPC9rbz5cclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xuICBfX3Byb3RvLm9uQW5pbWF0aW9uRW5kID0gZnVuY3Rpb24gKGN0eCkge1xuICAgIC8vIERPIE5PVEhJTkdcbiAgfTtcbiAgLyoqXHJcbiAgICogQW4gZXZlbnQgaGFuZGxlciBmb3IgQXhlcydzIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWF4ZXMvcmVsZWFzZS9sYXRlc3QvZG9jL2VnLkF4ZXMuaHRtbCNldmVudDpmaW5pc2ggZmluaXNofSBldmVudFxyXG4gICAqIEBrbyBBeGVz7J2YIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWF4ZXMvcmVsZWFzZS9sYXRlc3QvZG9jL2VnLkF4ZXMuaHRtbCNldmVudDpmaW5pc2ggZmluaXNofSDsnbTrsqTtirgg7ZW465Ok65+sXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IFtjdHhdIEV2ZW50IGNvbnRleHQ8a28+7J2067Kk7Yq4IOy9mO2FjeyKpO2KuDwva28+XHJcbiAgICogQHBhcmFtIHtGbGlja2luZ30gW2N0eC5mbGlja2luZ10gQW4gaW5zdGFuY2Ugb2YgRmxpY2tpbmc8a28+RmxpY2tpbmcg7J247Iqk7YS07IqkPC9rbz5cclxuICAgKiBAcGFyYW0ge29iamVjdH0gW2N0eC5heGVzRXZlbnRdIEEge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtYXhlcy9yZWxlYXNlL2xhdGVzdC9kb2MvZWcuQXhlcy5odG1sI2V2ZW50OmZpbmlzaCBmaW5pc2h9IGV2ZW50IG9mIEF4ZXM8a28+QXhlc+ydmCB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1heGVzL3JlbGVhc2UvbGF0ZXN0L2RvYy9lZy5BeGVzLmh0bWwjZXZlbnQ6ZmluaXNoIGZpbmlzaH0g7J2067Kk7Yq4PC9rbz5cclxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY3R4LnRyYW5zaXRUb10gQSBmdW5jdGlvbiBmb3IgY2hhbmdpbmcgY3VycmVudCBzdGF0ZSB0byBvdGhlciBzdGF0ZTxrbz7ri6Trpbgg7IOB7YOc66GcIOuzgOqyve2VmOq4sCDsnITtlZwg7ZWo7IiYPC9rbz5cclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xuICBfX3Byb3RvLm9uRmluaXNoID0gZnVuY3Rpb24gKGN0eCkge1xuICAgIC8vIERPIE5PVEhJTkdcbiAgfTtcbiAgX19wcm90by5fbW92ZVRvQ2hhbmdlZFBvc2l0aW9uID0gZnVuY3Rpb24gKGN0eCkge1xuICAgIHZhciBmbGlja2luZyA9IGN0eC5mbGlja2luZyxcbiAgICAgIGF4ZXNFdmVudCA9IGN0eC5heGVzRXZlbnQsXG4gICAgICB0cmFuc2l0VG8gPSBjdHgudHJhbnNpdFRvO1xuICAgIHZhciBkZWx0YSA9IGF4ZXNFdmVudC5kZWx0YVtQT1NJVElPTl9LRVldO1xuICAgIGlmICghZGVsdGEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fZGVsdGEgKz0gZGVsdGE7XG4gICAgdmFyIGNhbWVyYSA9IGZsaWNraW5nLmNhbWVyYTtcbiAgICB2YXIgcHJldlBvc2l0aW9uID0gY2FtZXJhLnBvc2l0aW9uO1xuICAgIHZhciBwb3NpdGlvbiA9IGF4ZXNFdmVudC5wb3NbUE9TSVRJT05fS0VZXTtcbiAgICB2YXIgbmV3UG9zaXRpb24gPSBmbGlja2luZy5jaXJjdWxhckVuYWJsZWQgPyBjaXJjdWxhdGVQb3NpdGlvbihwb3NpdGlvbiwgY2FtZXJhLnJhbmdlLm1pbiwgY2FtZXJhLnJhbmdlLm1heCkgOiBwb3NpdGlvbjtcbiAgICBjYW1lcmEubG9va0F0KG5ld1Bvc2l0aW9uKTtcbiAgICB2YXIgbW92ZUV2ZW50ID0gbmV3IENvbXBvbmVudEV2ZW50JDEoRVZFTlRTLk1PVkUsIHtcbiAgICAgIGlzVHJ1c3RlZDogYXhlc0V2ZW50LmlzVHJ1c3RlZCxcbiAgICAgIGhvbGRpbmc6IHRoaXMuaG9sZGluZyxcbiAgICAgIGRpcmVjdGlvbjogZ2V0RGlyZWN0aW9uJDEoMCwgYXhlc0V2ZW50LmRlbHRhW1BPU0lUSU9OX0tFWV0pLFxuICAgICAgYXhlc0V2ZW50OiBheGVzRXZlbnRcbiAgICB9KTtcbiAgICBmbGlja2luZy50cmlnZ2VyKG1vdmVFdmVudCk7XG4gICAgaWYgKG1vdmVFdmVudC5pc0NhbmNlbGVkKCkpIHtcbiAgICAgIC8vIFJldHVybiB0byBwcmV2aW91cyBwb3NpdGlvblxuICAgICAgY2FtZXJhLmxvb2tBdChwcmV2UG9zaXRpb24pO1xuICAgICAgdHJhbnNpdFRvKFNUQVRFX1RZUEUuRElTQUJMRUQpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIFN0YXRlO1xufSgpO1xuXG4vKipcclxuICogQSBkZWZhdWx0IHN0YXRlIHdoZW4gdGhlcmUncyBubyB1c2VyIGlucHV0IGFuZCBubyBhbmltYXRpb24ncyBwbGF5aW5nXHJcbiAqIEBrbyDsgqzsmqnsnpDsnZgg7J6F66Cl7J20IOyXhuqzoCwg7JWg64uI66mU7J207IWY7J20IOuPmeyeke2VmOqzoOyeiOyngCDslYrsnYAg6riw67O4IOyDge2DnFxyXG4gKiBAaW50ZXJuYWxcclxuICovXG52YXIgSWRsZVN0YXRlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzJDMoSWRsZVN0YXRlLCBfc3VwZXIpO1xuICBmdW5jdGlvbiBJZGxlU3RhdGUoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHVzZXIgaXMgY2xpY2tpbmcgb3IgdG91Y2hpbmdcclxuICAgICAqIEBrbyDtmITsnqwg7IKs7Jqp7J6Q6rCAIO2BtOumrS/thLDsuZjspJHsnbjsp4Ag7Jes67aAXHJcbiAgICAgKiBAdHlwZSB7ZmFsc2V9XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIF90aGlzLmhvbGRpbmcgPSBmYWxzZTtcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgRmxpY2tpbmcncyBhbmltYXRpbmdcclxuICAgICAqIEBrbyDtmITsnqwg7JWg64uI66mU7J207IWYIOuPmeyekSDsl6zrtoBcclxuICAgICAqIEB0eXBlIHtmYWxzZX1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgX3RoaXMuYW5pbWF0aW5nID0gZmFsc2U7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIHZhciBfX3Byb3RvID0gSWRsZVN0YXRlLnByb3RvdHlwZTtcbiAgX19wcm90by5vbkVudGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2RlbHRhID0gMDtcbiAgICB0aGlzLl90YXJnZXRQYW5lbCA9IG51bGw7XG4gIH07XG4gIF9fcHJvdG8ub25Ib2xkID0gZnVuY3Rpb24gKGN0eCkge1xuICAgIC8vIFNob3VsZG4ndCBkbyBhbnkgYWN0aW9uIHVudGlsIGFueSBwYW5lbHMgb24gZmxpY2tpbmcgYXJlYVxuICAgIHZhciBmbGlja2luZyA9IGN0eC5mbGlja2luZyxcbiAgICAgIGF4ZXNFdmVudCA9IGN0eC5heGVzRXZlbnQsXG4gICAgICB0cmFuc2l0VG8gPSBjdHgudHJhbnNpdFRvO1xuICAgIGlmIChmbGlja2luZy5yZW5kZXJlci5wYW5lbENvdW50IDw9IDApIHtcbiAgICAgIHRyYW5zaXRUbyhTVEFURV9UWVBFLkRJU0FCTEVEKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGhvbGRTdGFydEV2ZW50ID0gbmV3IENvbXBvbmVudEV2ZW50JDEoRVZFTlRTLkhPTERfU1RBUlQsIHtcbiAgICAgIGF4ZXNFdmVudDogYXhlc0V2ZW50XG4gICAgfSk7XG4gICAgZmxpY2tpbmcudHJpZ2dlcihob2xkU3RhcnRFdmVudCk7XG4gICAgaWYgKGhvbGRTdGFydEV2ZW50LmlzQ2FuY2VsZWQoKSkge1xuICAgICAgdHJhbnNpdFRvKFNUQVRFX1RZUEUuRElTQUJMRUQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmFuc2l0VG8oU1RBVEVfVFlQRS5IT0xESU5HKTtcbiAgICB9XG4gIH07XG4gIC8vIEJ5IG1ldGhvZHMgY2FsbFxuICBfX3Byb3RvLm9uQ2hhbmdlID0gZnVuY3Rpb24gKGN0eCkge1xuICAgIHZhciBmbGlja2luZyA9IGN0eC5mbGlja2luZyxcbiAgICAgIGF4ZXNFdmVudCA9IGN0eC5heGVzRXZlbnQsXG4gICAgICB0cmFuc2l0VG8gPSBjdHgudHJhbnNpdFRvO1xuICAgIHZhciBjb250cm9sbGVyID0gZmxpY2tpbmcuY29udHJvbC5jb250cm9sbGVyO1xuICAgIHZhciBhbmltYXRpbmdDb250ZXh0ID0gY29udHJvbGxlci5hbmltYXRpbmdDb250ZXh0O1xuICAgIHZhciBtb3ZlU3RhcnRFdmVudCA9IG5ldyBDb21wb25lbnRFdmVudCQxKEVWRU5UUy5NT1ZFX1NUQVJULCB7XG4gICAgICBpc1RydXN0ZWQ6IGF4ZXNFdmVudC5pc1RydXN0ZWQsXG4gICAgICBob2xkaW5nOiB0aGlzLmhvbGRpbmcsXG4gICAgICBkaXJlY3Rpb246IGdldERpcmVjdGlvbiQxKGFuaW1hdGluZ0NvbnRleHQuc3RhcnQsIGFuaW1hdGluZ0NvbnRleHQuZW5kKSxcbiAgICAgIGF4ZXNFdmVudDogYXhlc0V2ZW50XG4gICAgfSk7XG4gICAgZmxpY2tpbmcudHJpZ2dlcihtb3ZlU3RhcnRFdmVudCk7XG4gICAgaWYgKG1vdmVTdGFydEV2ZW50LmlzQ2FuY2VsZWQoKSkge1xuICAgICAgdHJhbnNpdFRvKFNUQVRFX1RZUEUuRElTQUJMRUQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUcmlnZ2VyIEFuaW1hdGluZ1N0YXRlJ3Mgb25DaGFuZ2UsIHRvIHRyaWdnZXIgXCJtb3ZlXCIgZXZlbnQgaW1tZWRpYXRlbHlcbiAgICAgIHRyYW5zaXRUbyhTVEFURV9UWVBFLkFOSU1BVElORykub25DaGFuZ2UoY3R4KTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBJZGxlU3RhdGU7XG59KFN0YXRlKTtcblxuLyoqXHJcbiAqIEEgc3RhdGUgdGhhdCBhY3RpdmF0ZXMgd2hlbiB1c2VyJ3MgaG9sZGluZyB0aGUgRmxpY2tpbmcgYXJlYSwgYnV0IG5vdCBtb3ZlZCBhIHNpbmdsZSBwaXhlbCB5ZXRcclxuICogQGtvIOyCrOyaqeyekOydmCDsnoXroKXsnbQg7Iuc7J6R65CY7JeI7Jy864KYLCDslYTsp4Eg7JuA7KeB7J207KeA64qUIOyViuydgCDsg4Htg5xcclxuICogQGludGVybmFsXHJcbiAqL1xudmFyIEhvbGRpbmdTdGF0ZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyQzKEhvbGRpbmdTdGF0ZSwgX3N1cGVyKTtcbiAgZnVuY3Rpb24gSG9sZGluZ1N0YXRlKCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIC8qKlxyXG4gICAgICogV2hldGhlciB1c2VyIGlzIGNsaWNraW5nIG9yIHRvdWNoaW5nXHJcbiAgICAgKiBAa28g7ZiE7J6sIOyCrOyaqeyekOqwgCDtgbTrpq0v7YSw7LmY7KSR7J247KeAIOyXrOu2gFxyXG4gICAgICogQHR5cGUge3RydWV9XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIF90aGlzLmhvbGRpbmcgPSB0cnVlO1xuICAgIC8qKlxyXG4gICAgICogV2hldGhlciBGbGlja2luZydzIGFuaW1hdGluZ1xyXG4gICAgICogQGtvIO2YhOyerCDslaDri4jrqZTsnbTshZgg64+Z7J6RIOyXrOu2gFxyXG4gICAgICogQHR5cGUge2ZhbHNlfVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBfdGhpcy5hbmltYXRpbmcgPSBmYWxzZTtcbiAgICBfdGhpcy5fcmVsZWFzZUV2ZW50ID0gbnVsbDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgdmFyIF9fcHJvdG8gPSBIb2xkaW5nU3RhdGUucHJvdG90eXBlO1xuICBfX3Byb3RvLm9uQ2hhbmdlID0gZnVuY3Rpb24gKGN0eCkge1xuICAgIHZhciBmbGlja2luZyA9IGN0eC5mbGlja2luZyxcbiAgICAgIGF4ZXNFdmVudCA9IGN0eC5heGVzRXZlbnQsXG4gICAgICB0cmFuc2l0VG8gPSBjdHgudHJhbnNpdFRvO1xuICAgIHZhciBpbnB1dEV2ZW50ID0gYXhlc0V2ZW50LmlucHV0RXZlbnQ7XG4gICAgdmFyIG9mZnNldCA9IGZsaWNraW5nLmhvcml6b250YWwgPyBpbnB1dEV2ZW50Lm9mZnNldFggOiBpbnB1dEV2ZW50Lm9mZnNldFk7XG4gICAgdmFyIG1vdmVTdGFydEV2ZW50ID0gbmV3IENvbXBvbmVudEV2ZW50JDEoRVZFTlRTLk1PVkVfU1RBUlQsIHtcbiAgICAgIGlzVHJ1c3RlZDogYXhlc0V2ZW50LmlzVHJ1c3RlZCxcbiAgICAgIGhvbGRpbmc6IHRoaXMuaG9sZGluZyxcbiAgICAgIGRpcmVjdGlvbjogZ2V0RGlyZWN0aW9uJDEoMCwgLW9mZnNldCksXG4gICAgICBheGVzRXZlbnQ6IGF4ZXNFdmVudFxuICAgIH0pO1xuICAgIGZsaWNraW5nLnRyaWdnZXIobW92ZVN0YXJ0RXZlbnQpO1xuICAgIGlmIChtb3ZlU3RhcnRFdmVudC5pc0NhbmNlbGVkKCkpIHtcbiAgICAgIHRyYW5zaXRUbyhTVEFURV9UWVBFLkRJU0FCTEVEKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVHJpZ2dlciBEcmFnZ2luZ1N0YXRlJ3Mgb25DaGFuZ2UsIHRvIHRyaWdnZXIgXCJtb3ZlXCIgZXZlbnQgaW1tZWRpYXRlbHlcbiAgICAgIHRyYW5zaXRUbyhTVEFURV9UWVBFLkRSQUdHSU5HKS5vbkNoYW5nZShjdHgpO1xuICAgIH1cbiAgfTtcbiAgX19wcm90by5vblJlbGVhc2UgPSBmdW5jdGlvbiAoY3R4KSB7XG4gICAgdmFyIGZsaWNraW5nID0gY3R4LmZsaWNraW5nLFxuICAgICAgYXhlc0V2ZW50ID0gY3R4LmF4ZXNFdmVudCxcbiAgICAgIHRyYW5zaXRUbyA9IGN0eC50cmFuc2l0VG87XG4gICAgZmxpY2tpbmcudHJpZ2dlcihuZXcgQ29tcG9uZW50RXZlbnQkMShFVkVOVFMuSE9MRF9FTkQsIHtcbiAgICAgIGF4ZXNFdmVudDogYXhlc0V2ZW50XG4gICAgfSkpO1xuICAgIGlmIChheGVzRXZlbnQuZGVsdGEuZmxpY2sgIT09IDApIHtcbiAgICAgIC8vIFNvbWV0aW1lcyBcInJlbGVhc2VcIiBldmVudCBvbiBheGVzIHRyaWdnZXJlZCBiZWZvcmUgXCJjaGFuZ2VcIiBldmVudFxuICAgICAgLy8gRXNwZWNpYWxseSBpZiB1c2VyIGZsaWNrZWQgcGFuZWwgZmFzdCBpbiByZWFsbHkgc2hvcnQgYW1vdW50IG9mIHRpbWVcbiAgICAgIC8vIGlmIGRlbHRhIGlzIG5vdCB6ZXJvLCB0aGF0IG1lYW5zIGFib3ZlIGNhc2UgaGFwcGVuZWQuXG4gICAgICAvLyBFdmVudCBmbG93IHNob3VsZCBiZSBIT0xEX1NUQVJUIC0+IE1PVkVfU1RBUlQgLT4gTU9WRSAtPiBIT0xEX0VORFxuICAgICAgLy8gQXQgbGVhc3Qgb25lIG1vdmUgZXZlbnQgc2hvdWxkIGJlIGluY2x1ZGVkIGJldHdlZW4gaG9sZFN0YXJ0IGFuZCBob2xkRW5kXG4gICAgICBheGVzRXZlbnQuc2V0VG8oe1xuICAgICAgICBmbGljazogZmxpY2tpbmcuY2FtZXJhLnBvc2l0aW9uXG4gICAgICB9LCAwKTtcbiAgICAgIHRyYW5zaXRUbyhTVEFURV9UWVBFLklETEUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBDYW4ndCBoYW5kbGUgc2VsZWN0IGV2ZW50IGhlcmUsXG4gICAgLy8gQXMgXCJmaW5pc2hcIiBheGVzIGV2ZW50IGhhcHBlbnNcbiAgICB0aGlzLl9yZWxlYXNlRXZlbnQgPSBheGVzRXZlbnQ7XG4gIH07XG4gIF9fcHJvdG8ub25GaW5pc2ggPSBmdW5jdGlvbiAoY3R4KSB7XG4gICAgdmFyIGVfMSwgX2E7XG4gICAgdmFyIGZsaWNraW5nID0gY3R4LmZsaWNraW5nLFxuICAgICAgdHJhbnNpdFRvID0gY3R4LnRyYW5zaXRUbztcbiAgICAvLyBTaG91bGQgdHJhbnNpdGUgdG8gSURMRSBzdGF0ZSBiZWZvcmUgc2VsZWN0IGV2ZW50XG4gICAgLy8gQXMgdXNlciBleHBlY3RzIGhvbGQgaXMgYWxyZWFkeSBmaW5pc2hlZFxuICAgIHRyYW5zaXRUbyhTVEFURV9UWVBFLklETEUpO1xuICAgIGlmICghdGhpcy5fcmVsZWFzZUV2ZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIEhhbmRsZSByZWxlYXNlIGV2ZW50IGhlcmVcbiAgICAvLyBUbyBwcmV2ZW50IGZpbmlzaCBldmVudCBjYWxsZWQgdHdpY2VcbiAgICB2YXIgcmVsZWFzZUV2ZW50ID0gdGhpcy5fcmVsZWFzZUV2ZW50O1xuICAgIC8vIFN0YXRpYyBjbGlja1xuICAgIC8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudCwgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzICovXG4gICAgdmFyIHNyY0V2ZW50ID0gcmVsZWFzZUV2ZW50LmlucHV0RXZlbnQuc3JjRXZlbnQ7XG4gICAgdmFyIGNsaWNrZWRFbGVtZW50O1xuICAgIGlmIChzcmNFdmVudC50eXBlID09PSBcInRvdWNoZW5kXCIpIHtcbiAgICAgIHZhciB0b3VjaEV2ZW50ID0gc3JjRXZlbnQ7XG4gICAgICB2YXIgdG91Y2ggPSB0b3VjaEV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgICAgY2xpY2tlZEVsZW1lbnQgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KHRvdWNoLmNsaWVudFgsIHRvdWNoLmNsaWVudFkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjbGlja2VkRWxlbWVudCA9IHNyY0V2ZW50LnRhcmdldDtcbiAgICB9XG4gICAgLyogZXNsaW50LWVuYWJsZSAqL1xuICAgIHZhciBwYW5lbHMgPSBmbGlja2luZy5yZW5kZXJlci5wYW5lbHM7XG4gICAgdmFyIGNsaWNrZWRQYW5lbCA9IG51bGw7XG4gICAgdHJ5IHtcbiAgICAgIGZvciAodmFyIHBhbmVsc18xID0gX192YWx1ZXMkMShwYW5lbHMpLCBwYW5lbHNfMV8xID0gcGFuZWxzXzEubmV4dCgpOyAhcGFuZWxzXzFfMS5kb25lOyBwYW5lbHNfMV8xID0gcGFuZWxzXzEubmV4dCgpKSB7XG4gICAgICAgIHZhciBwYW5lbCA9IHBhbmVsc18xXzEudmFsdWU7XG4gICAgICAgIGlmIChwYW5lbC5jb250YWlucyhjbGlja2VkRWxlbWVudCkpIHtcbiAgICAgICAgICBjbGlja2VkUGFuZWwgPSBwYW5lbDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVfMV8xKSB7XG4gICAgICBlXzEgPSB7XG4gICAgICAgIGVycm9yOiBlXzFfMVxuICAgICAgfTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHBhbmVsc18xXzEgJiYgIXBhbmVsc18xXzEuZG9uZSAmJiAoX2EgPSBwYW5lbHNfMS5yZXR1cm4pKSBfYS5jYWxsKHBhbmVsc18xKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNsaWNrZWRQYW5lbCkge1xuICAgICAgdmFyIGNhbWVyYVBvc2l0aW9uID0gZmxpY2tpbmcuY2FtZXJhLnBvc2l0aW9uO1xuICAgICAgdmFyIGNsaWNrZWRQYW5lbFBvc2l0aW9uID0gY2xpY2tlZFBhbmVsLnBvc2l0aW9uO1xuICAgICAgZmxpY2tpbmcudHJpZ2dlcihuZXcgQ29tcG9uZW50RXZlbnQkMShFVkVOVFMuU0VMRUNULCB7XG4gICAgICAgIGluZGV4OiBjbGlja2VkUGFuZWwuaW5kZXgsXG4gICAgICAgIHBhbmVsOiBjbGlja2VkUGFuZWwsXG4gICAgICAgIC8vIERpcmVjdGlvbiB0byB0aGUgY2xpY2tlZCBwYW5lbFxuICAgICAgICBkaXJlY3Rpb246IGdldERpcmVjdGlvbiQxKGNhbWVyYVBvc2l0aW9uLCBjbGlja2VkUGFuZWxQb3NpdGlvbilcbiAgICAgIH0pKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBIb2xkaW5nU3RhdGU7XG59KFN0YXRlKTtcblxuLyoqXHJcbiAqIEEgc3RhdGUgdGhhdCBhY3RpdmF0ZXMgd2hlbiB1c2VyJ3MgZHJhZ2dpbmcgdGhlIEZsaWNraW5nIGFyZWFcclxuICogQGtvIOyCrOyaqeyekOqwgCDrk5zrnpjquYXspJHsnbgg7IOB7YOcXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cbnZhciBEcmFnZ2luZ1N0YXRlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzJDMoRHJhZ2dpbmdTdGF0ZSwgX3N1cGVyKTtcbiAgZnVuY3Rpb24gRHJhZ2dpbmdTdGF0ZSgpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgdXNlciBpcyBjbGlja2luZyBvciB0b3VjaGluZ1xyXG4gICAgICogQGtvIO2YhOyerCDsgqzsmqnsnpDqsIAg7YG066atL+2EsOy5mOykkeyduOyngCDsl6zrtoBcclxuICAgICAqIEB0eXBlIHt0cnVlfVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBfdGhpcy5ob2xkaW5nID0gdHJ1ZTtcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgRmxpY2tpbmcncyBhbmltYXRpbmdcclxuICAgICAqIEBrbyDtmITsnqwg7JWg64uI66mU7J207IWYIOuPmeyekSDsl6zrtoBcclxuICAgICAqIEB0eXBlIHt0cnVlfVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBfdGhpcy5hbmltYXRpbmcgPSB0cnVlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICB2YXIgX19wcm90byA9IERyYWdnaW5nU3RhdGUucHJvdG90eXBlO1xuICBfX3Byb3RvLm9uQ2hhbmdlID0gZnVuY3Rpb24gKGN0eCkge1xuICAgIHRoaXMuX21vdmVUb0NoYW5nZWRQb3NpdGlvbihjdHgpO1xuICB9O1xuICBfX3Byb3RvLm9uUmVsZWFzZSA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICB2YXIgX2E7XG4gICAgdmFyIGZsaWNraW5nID0gY3R4LmZsaWNraW5nLFxuICAgICAgYXhlc0V2ZW50ID0gY3R4LmF4ZXNFdmVudCxcbiAgICAgIHRyYW5zaXRUbyA9IGN0eC50cmFuc2l0VG87XG4gICAgLy8gVXBkYXRlIGxhc3QgcG9zaXRpb24gdG8gY29wZSB3aXRoIEF4ZXMncyBhbmltYXRpbmcgYmVoYXZpb3JcbiAgICAvLyBBeGVzIHVzZXMgc3RhcnQgcG9zaXRpb24gd2hlbiBhbmltYXRpb24gc3RhcnRcbiAgICBmbGlja2luZy50cmlnZ2VyKG5ldyBDb21wb25lbnRFdmVudCQxKEVWRU5UUy5IT0xEX0VORCwge1xuICAgICAgYXhlc0V2ZW50OiBheGVzRXZlbnRcbiAgICB9KSk7XG4gICAgaWYgKGZsaWNraW5nLnJlbmRlcmVyLnBhbmVsQ291bnQgPD0gMCkge1xuICAgICAgLy8gVGhlcmUncmUgbm8gcGFuZWxzXG4gICAgICB0cmFuc2l0VG8oU1RBVEVfVFlQRS5JRExFKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdHJhbnNpdFRvKFNUQVRFX1RZUEUuQU5JTUFUSU5HKTtcbiAgICB2YXIgY29udHJvbCA9IGZsaWNraW5nLmNvbnRyb2w7XG4gICAgdmFyIHBvc2l0aW9uID0gYXhlc0V2ZW50LmRlc3RQb3NbUE9TSVRJT05fS0VZXTtcbiAgICB2YXIgZHVyYXRpb24gPSBNYXRoLm1heChheGVzRXZlbnQuZHVyYXRpb24sIGZsaWNraW5nLmR1cmF0aW9uKTtcbiAgICB0cnkge1xuICAgICAgdm9pZCBjb250cm9sLm1vdmVUb1Bvc2l0aW9uKHBvc2l0aW9uLCBkdXJhdGlvbiwgYXhlc0V2ZW50KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRyYW5zaXRUbyhTVEFURV9UWVBFLklETEUpO1xuICAgICAgYXhlc0V2ZW50LnNldFRvKChfYSA9IHt9LCBfYVtQT1NJVElPTl9LRVldID0gZmxpY2tpbmcuY2FtZXJhLnBvc2l0aW9uLCBfYSksIDApO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIERyYWdnaW5nU3RhdGU7XG59KFN0YXRlKTtcblxuLyoqXHJcbiAqIEEgc3RhdGUgdGhhdCBhY3RpdmF0ZXMgd2hlbiBGbGlja2luZydzIGFuaW1hdGluZyBieSB1c2VyIGlucHV0IG9yIG1ldGhvZCBjYWxsXHJcbiAqIEBrbyDsgqzsmqnsnpAg7J6F66Cl7J2064KYIOuplOyGjOuTnCDtmLjstpzsl5Ag7J2Y7ZW0IEZsaWNraW5n7J2YIOyVoOuLiOuplOydtOyFmOydtCDrj5nsnpHspJHsnbgg7IOB7YOcXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cbnZhciBBbmltYXRpbmdTdGF0ZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyQzKEFuaW1hdGluZ1N0YXRlLCBfc3VwZXIpO1xuICBmdW5jdGlvbiBBbmltYXRpbmdTdGF0ZSgpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgdXNlciBpcyBjbGlja2luZyBvciB0b3VjaGluZ1xyXG4gICAgICogQGtvIO2YhOyerCDsgqzsmqnsnpDqsIAg7YG066atL+2EsOy5mOykkeyduOyngCDsl6zrtoBcclxuICAgICAqIEB0eXBlIHtmYWxzZX1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgX3RoaXMuaG9sZGluZyA9IGZhbHNlO1xuICAgIC8qKlxyXG4gICAgICogV2hldGhlciBGbGlja2luZydzIGFuaW1hdGluZ1xyXG4gICAgICogQGtvIO2YhOyerCDslaDri4jrqZTsnbTshZgg64+Z7J6RIOyXrOu2gFxyXG4gICAgICogQHR5cGUge3RydWV9XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIF90aGlzLmFuaW1hdGluZyA9IHRydWU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIHZhciBfX3Byb3RvID0gQW5pbWF0aW5nU3RhdGUucHJvdG90eXBlO1xuICBfX3Byb3RvLm9uSG9sZCA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICB2YXIgZmxpY2tpbmcgPSBjdHguZmxpY2tpbmcsXG4gICAgICBheGVzRXZlbnQgPSBjdHguYXhlc0V2ZW50LFxuICAgICAgdHJhbnNpdFRvID0gY3R4LnRyYW5zaXRUbztcbiAgICB2YXIgdGFyZ2V0UGFuZWwgPSB0aGlzLl90YXJnZXRQYW5lbDtcbiAgICB2YXIgY29udHJvbCA9IGZsaWNraW5nLmNvbnRyb2w7XG4gICAgdGhpcy5fZGVsdGEgPSAwO1xuICAgIGZsaWNraW5nLmNvbnRyb2wudXBkYXRlSW5wdXQoKTtcbiAgICBpZiAoZmxpY2tpbmcuY2hhbmdlT25Ib2xkICYmIHRhcmdldFBhbmVsKSB7XG4gICAgICBjb250cm9sLnNldEFjdGl2ZSh0YXJnZXRQYW5lbCwgY29udHJvbC5hY3RpdmVQYW5lbCwgYXhlc0V2ZW50LmlzVHJ1c3RlZCk7XG4gICAgfVxuICAgIHZhciBob2xkU3RhcnRFdmVudCA9IG5ldyBDb21wb25lbnRFdmVudCQxKEVWRU5UUy5IT0xEX1NUQVJULCB7XG4gICAgICBheGVzRXZlbnQ6IGF4ZXNFdmVudFxuICAgIH0pO1xuICAgIGZsaWNraW5nLnRyaWdnZXIoaG9sZFN0YXJ0RXZlbnQpO1xuICAgIGlmIChob2xkU3RhcnRFdmVudC5pc0NhbmNlbGVkKCkpIHtcbiAgICAgIHRyYW5zaXRUbyhTVEFURV9UWVBFLkRJU0FCTEVEKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJhbnNpdFRvKFNUQVRFX1RZUEUuRFJBR0dJTkcpO1xuICAgIH1cbiAgfTtcbiAgX19wcm90by5vbkNoYW5nZSA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICB0aGlzLl9tb3ZlVG9DaGFuZ2VkUG9zaXRpb24oY3R4KTtcbiAgfTtcbiAgX19wcm90by5vbkZpbmlzaCA9IGZ1bmN0aW9uIChjdHgpIHtcbiAgICB2YXIgZmxpY2tpbmcgPSBjdHguZmxpY2tpbmcsXG4gICAgICBheGVzRXZlbnQgPSBjdHguYXhlc0V2ZW50LFxuICAgICAgdHJhbnNpdFRvID0gY3R4LnRyYW5zaXRUbztcbiAgICB2YXIgY29udHJvbCA9IGZsaWNraW5nLmNvbnRyb2w7XG4gICAgdmFyIGNvbnRyb2xsZXIgPSBjb250cm9sLmNvbnRyb2xsZXI7XG4gICAgdmFyIGFuaW1hdGluZ0NvbnRleHQgPSBjb250cm9sbGVyLmFuaW1hdGluZ0NvbnRleHQ7XG4gICAgdHJhbnNpdFRvKFNUQVRFX1RZUEUuSURMRSk7XG4gICAgZmxpY2tpbmcudHJpZ2dlcihuZXcgQ29tcG9uZW50RXZlbnQkMShFVkVOVFMuTU9WRV9FTkQsIHtcbiAgICAgIGlzVHJ1c3RlZDogYXhlc0V2ZW50LmlzVHJ1c3RlZCxcbiAgICAgIGRpcmVjdGlvbjogZ2V0RGlyZWN0aW9uJDEoYW5pbWF0aW5nQ29udGV4dC5zdGFydCwgYW5pbWF0aW5nQ29udGV4dC5lbmQpLFxuICAgICAgYXhlc0V2ZW50OiBheGVzRXZlbnRcbiAgICB9KSk7XG4gICAgdmFyIHRhcmdldFBhbmVsID0gdGhpcy5fdGFyZ2V0UGFuZWw7XG4gICAgaWYgKHRhcmdldFBhbmVsKSB7XG4gICAgICBjb250cm9sLnNldEFjdGl2ZSh0YXJnZXRQYW5lbCwgY29udHJvbC5hY3RpdmVQYW5lbCwgYXhlc0V2ZW50LmlzVHJ1c3RlZCk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gQW5pbWF0aW5nU3RhdGU7XG59KFN0YXRlKTtcblxuLyoqXHJcbiAqIEEgc3RhdGUgdGhhdCBhY3RpdmF0ZXMgd2hlbiBGbGlja2luZyBpcyBzdG9wcGVkIGJ5IGV2ZW50J3MgYHN0b3BgIG1ldGhvZFxyXG4gKiBAa28g7J2067Kk7Yq47J2YIGBzdG9wYO2YuOy2nOyXkCDsnZjtlbQgRmxpY2tpbmfsnbQg7KCV7KeA65CcIOyDge2DnFxyXG4gKiBAaW50ZXJuYWxcclxuICovXG52YXIgRGlzYWJsZWRTdGF0ZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyQzKERpc2FibGVkU3RhdGUsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIERpc2FibGVkU3RhdGUoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHVzZXIgaXMgY2xpY2tpbmcgb3IgdG91Y2hpbmdcclxuICAgICAqIEBrbyDtmITsnqwg7IKs7Jqp7J6Q6rCAIO2BtOumrS/thLDsuZjspJHsnbjsp4Ag7Jes67aAXHJcbiAgICAgKiBAdHlwZSB7ZmFsc2V9XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIF90aGlzLmhvbGRpbmcgPSBmYWxzZTtcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgRmxpY2tpbmcncyBhbmltYXRpbmdcclxuICAgICAqIEBrbyDtmITsnqwg7JWg64uI66mU7J207IWYIOuPmeyekSDsl6zrtoBcclxuICAgICAqIEB0eXBlIHt0cnVlfVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBfdGhpcy5hbmltYXRpbmcgPSB0cnVlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICB2YXIgX19wcm90byA9IERpc2FibGVkU3RhdGUucHJvdG90eXBlO1xuICBfX3Byb3RvLm9uQW5pbWF0aW9uRW5kID0gZnVuY3Rpb24gKGN0eCkge1xuICAgIHZhciB0cmFuc2l0VG8gPSBjdHgudHJhbnNpdFRvO1xuICAgIHRyYW5zaXRUbyhTVEFURV9UWVBFLklETEUpO1xuICB9O1xuICBfX3Byb3RvLm9uQ2hhbmdlID0gZnVuY3Rpb24gKGN0eCkge1xuICAgIHZhciBheGVzRXZlbnQgPSBjdHguYXhlc0V2ZW50LFxuICAgICAgdHJhbnNpdFRvID0gY3R4LnRyYW5zaXRUbztcbiAgICAvLyBDYW4gc3RvcCBBeGVzJ3MgY2hhbmdlIGV2ZW50XG4gICAgYXhlc0V2ZW50LnN0b3AoKTtcbiAgICB0cmFuc2l0VG8oU1RBVEVfVFlQRS5JRExFKTtcbiAgfTtcbiAgX19wcm90by5vblJlbGVhc2UgPSBmdW5jdGlvbiAoY3R4KSB7XG4gICAgdmFyIGF4ZXNFdmVudCA9IGN0eC5heGVzRXZlbnQsXG4gICAgICB0cmFuc2l0VG8gPSBjdHgudHJhbnNpdFRvO1xuICAgIC8vIFRoaXMgaXMgbmVlZGVkIHdoZW4gc3RvcHBlZCBob2xkIHN0YXJ0IGV2ZW50XG4gICAgaWYgKGF4ZXNFdmVudC5kZWx0YS5mbGljayA9PT0gMCkge1xuICAgICAgdHJhbnNpdFRvKFNUQVRFX1RZUEUuSURMRSk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gRGlzYWJsZWRTdGF0ZTtcbn0oU3RhdGUpO1xuXG4vKipcclxuICogQGludGVybmFsXHJcbiAqL1xudmFyIFN0YXRlTWFjaGluZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFN0YXRlTWFjaGluZSgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHRoaXMudHJhbnNpdFRvID0gZnVuY3Rpb24gKG5leHRTdGF0ZVR5cGUpIHtcbiAgICAgIHZhciBuZXh0U3RhdGU7XG4gICAgICBzd2l0Y2ggKG5leHRTdGF0ZVR5cGUpIHtcbiAgICAgICAgY2FzZSBTVEFURV9UWVBFLklETEU6XG4gICAgICAgICAgbmV4dFN0YXRlID0gbmV3IElkbGVTdGF0ZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFNUQVRFX1RZUEUuSE9MRElORzpcbiAgICAgICAgICBuZXh0U3RhdGUgPSBuZXcgSG9sZGluZ1N0YXRlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgU1RBVEVfVFlQRS5EUkFHR0lORzpcbiAgICAgICAgICBuZXh0U3RhdGUgPSBuZXcgRHJhZ2dpbmdTdGF0ZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFNUQVRFX1RZUEUuQU5JTUFUSU5HOlxuICAgICAgICAgIG5leHRTdGF0ZSA9IG5ldyBBbmltYXRpbmdTdGF0ZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFNUQVRFX1RZUEUuRElTQUJMRUQ6XG4gICAgICAgICAgbmV4dFN0YXRlID0gbmV3IERpc2FibGVkU3RhdGUoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIG5leHRTdGF0ZS5vbkVudGVyKF90aGlzLl9zdGF0ZSk7XG4gICAgICBfdGhpcy5fc3RhdGUgPSBuZXh0U3RhdGU7XG4gICAgICByZXR1cm4gX3RoaXMuX3N0YXRlO1xuICAgIH07XG4gICAgdGhpcy5fc3RhdGUgPSBuZXcgSWRsZVN0YXRlKCk7XG4gIH1cbiAgdmFyIF9fcHJvdG8gPSBTdGF0ZU1hY2hpbmUucHJvdG90eXBlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJzdGF0ZVwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3RhdGU7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIF9fcHJvdG8uZmlyZSA9IGZ1bmN0aW9uIChldmVudFR5cGUsIGV4dGVybmFsQ3R4KSB7XG4gICAgdmFyIGN1cnJlbnRTdGF0ZSA9IHRoaXMuX3N0YXRlO1xuICAgIHZhciBjdHggPSBfX2Fzc2lnbiQyKF9fYXNzaWduJDIoe30sIGV4dGVybmFsQ3R4KSwge1xuICAgICAgdHJhbnNpdFRvOiB0aGlzLnRyYW5zaXRUb1xuICAgIH0pO1xuICAgIHN3aXRjaCAoZXZlbnRUeXBlKSB7XG4gICAgICBjYXNlIEVWRU5ULkhPTEQ6XG4gICAgICAgIGN1cnJlbnRTdGF0ZS5vbkhvbGQoY3R4KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEVWRU5ULkNIQU5HRTpcbiAgICAgICAgY3VycmVudFN0YXRlLm9uQ2hhbmdlKGN0eCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBFVkVOVC5SRUxFQVNFOlxuICAgICAgICBjdXJyZW50U3RhdGUub25SZWxlYXNlKGN0eCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBFVkVOVC5BTklNQVRJT05fRU5EOlxuICAgICAgICBjdXJyZW50U3RhdGUub25BbmltYXRpb25FbmQoY3R4KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEVWRU5ULkZJTklTSDpcbiAgICAgICAgY3VycmVudFN0YXRlLm9uRmluaXNoKGN0eCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIFN0YXRlTWFjaGluZTtcbn0oKTtcblxuLyoqXHJcbiAqIEEgY29udHJvbGxlciB0aGF0IGhhbmRsZXMgdGhlIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWF4ZXMvIEBlZ2pzL2F4ZXN9IGV2ZW50c1xyXG4gKiBAa28ge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtYXhlcy8gQGVnanMvYXhlc33snZgg7J2067Kk7Yq466W8IOyymOumrO2VmOuKlCDsu6jtirjroaTrn6wg7Lu07Y+s64SM7Yq4XHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cbnZhciBBeGVzQ29udHJvbGxlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKiAqL1xuICBmdW5jdGlvbiBBeGVzQ29udHJvbGxlcigpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHRoaXMuX29uQXhlc0hvbGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5fZHJhZ2dlZCA9IGZhbHNlO1xuICAgIH07XG4gICAgdGhpcy5fb25BeGVzQ2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgX3RoaXMuX2RyYWdnZWQgPSAhISgoX2EgPSBfdGhpcy5fcGFuSW5wdXQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pc0VuYWJsZWQoKSk7XG4gICAgfTtcbiAgICB0aGlzLl9wcmV2ZW50Q2xpY2tXaGVuRHJhZ2dlZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoX3RoaXMuX2RyYWdnZWQpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgfVxuICAgICAgX3RoaXMuX2RyYWdnZWQgPSBmYWxzZTtcbiAgICB9O1xuICAgIHRoaXMuX3Jlc2V0SW50ZXJuYWxWYWx1ZXMoKTtcbiAgICB0aGlzLl9zdGF0ZU1hY2hpbmUgPSBuZXcgU3RhdGVNYWNoaW5lKCk7XG4gIH1cbiAgdmFyIF9fcHJvdG8gPSBBeGVzQ29udHJvbGxlci5wcm90b3R5cGU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcImF4ZXNcIiwge1xuICAgIC8qKlxyXG4gICAgICogQW4ge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtYXhlcy9kb2NzL2FwaS9BeGVzIEF4ZXN9IGluc3RhbmNlXHJcbiAgICAgKiBAa28ge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtYXhlcy9kb2NzL2FwaS9BeGVzIEF4ZXN97J2YIOyduOyKpO2EtOyKpFxyXG4gICAgICogQHR5cGUge0F4ZXMgfCBudWxsfVxyXG4gICAgICogQHNlZSBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWF4ZXMvZG9jcy9hcGkvQXhlc1xyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9heGVzO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJwYW5JbnB1dFwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBBbiB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1heGVzL2RvY3MvYXBpL1BhbklucHV0IFBhbklucHV0fSBpbnN0YW5jZVxyXG4gICAgICogQGtvIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWF4ZXMvZG9jcy9hcGkvUGFuSW5wdXQgUGFuSW5wdXR97J2YIOyduOyKpO2EtOyKpFxyXG4gICAgICogQHR5cGUge1BhbklucHV0IHwgbnVsbH1cclxuICAgICAqIEBzZWUgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1heGVzL2RvY3MvYXBpL1BhbklucHV0XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3BhbklucHV0O1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJzdGF0ZU1hY2hpbmVcIiwge1xuICAgIC8qKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdGF0ZU1hY2hpbmU7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcInN0YXRlXCIsIHtcbiAgICAvKipcclxuICAgICAqIEEgYWN0aXZhdGVkIHtAbGluayBTdGF0ZX0gdGhhdCBzaG93cyB0aGUgY3VycmVudCBzdGF0dXMgb2YgdGhlIHVzZXIgaW5wdXQgb3IgdGhlIGFuaW1hdGlvblxyXG4gICAgICogQGtvIO2YhOyerCDtmZzshLHtmZTrkJwge0BsaW5rIFN0YXRlfSDsnbjsiqTthLTsiqTroZwg7IKs7Jqp7J6QIOyeheugpSDrmJDripQg7JWg64uI66mU7J207IWYIOyDge2DnOulvCDrgpjtg4Drg4Xri4jri6RcclxuICAgICAqIEB0eXBlIHtTdGF0ZX1cclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlTWFjaGluZS5zdGF0ZTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwiYW5pbWF0aW5nQ29udGV4dFwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBBIGNvbnRleHQgb2YgdGhlIGN1cnJlbnQgYW5pbWF0aW9uIHBsYXlpbmdcclxuICAgICAqIEBrbyDtmITsnqwg7J6s7IOd7KSR7J24IOyVoOuLiOuplOydtOyFmCDsoJXrs7RcclxuICAgICAqIEB0eXBlIHtvYmplY3R9XHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gc3RhcnQgQSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgYW5pbWF0aW9uPGtvPuyVoOuLiOuplOydtOyFmCDsi5zsnpEg7KeA7KCQPC9rbz5cclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBlbmQgQSBlbmQgcG9zaXRpb24gb2YgdGhlIGFuaW1hdGlvbjxrbz7slaDri4jrqZTsnbTshZgg64GdIOyngOygkDwva28+XHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gb2Zmc2V0IGNhbWVyYSBvZmZzZXQ8a28+7Lm066mU6528IOyYpO2UhOyFizwva28+XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2FuaW1hdGluZ0NvbnRleHQ7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcImNvbnRyb2xQYXJhbXNcIiwge1xuICAgIC8qKlxyXG4gICAgICogQSBjdXJyZW50IGNvbnRyb2wgcGFyYW1ldGVycyBvZiB0aGUgQXhlcyBpbnN0YW5jZVxyXG4gICAgICogQGtvIO2ZnOyEse2ZlOuQnCDtmITsnqwgQXhlcyDtjKjrn6zrr7jthLDrk6RcclxuICAgICAqIEB0eXBlIHtDb250cm9sUGFyYW1zfVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYXhlcyA9IHRoaXMuX2F4ZXM7XG4gICAgICBpZiAoIWF4ZXMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByYW5nZToge1xuICAgICAgICAgICAgbWluOiAwLFxuICAgICAgICAgICAgbWF4OiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBwb3NpdGlvbjogMCxcbiAgICAgICAgICBjaXJjdWxhcjogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHZhciBheGlzID0gYXhlcy5heGlzW1BPU0lUSU9OX0tFWV07XG4gICAgICByZXR1cm4ge1xuICAgICAgICByYW5nZToge1xuICAgICAgICAgIG1pbjogYXhpcy5yYW5nZVswXSxcbiAgICAgICAgICBtYXg6IGF4aXMucmFuZ2VbMV1cbiAgICAgICAgfSxcbiAgICAgICAgY2lyY3VsYXI6IGF4aXMuY2lyY3VsYXJbMF0sXG4gICAgICAgIHBvc2l0aW9uOiB0aGlzLnBvc2l0aW9uXG4gICAgICB9O1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJlbmFibGVkXCIsIHtcbiAgICAvKipcclxuICAgICAqIEEgQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIHVzZXIgaW5wdXQgaXMgZW5hYmxlZFxyXG4gICAgICogQGtvIO2YhOyerCDsgqzsmqnsnpAg7J6F66Cl7J20IO2ZnOyEse2ZlOuQmOyXiOuKlOyngOulvCDrgpjtg4DrgrTripQg6rCSXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMuX3BhbklucHV0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXNFbmFibGVkKCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGZhbHNlO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJwb3NpdGlvblwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBDdXJyZW50IHBvc2l0aW9uIHZhbHVlIGluIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWF4ZXMvcmVsZWFzZS9sYXRlc3QvZG9jL2VnLkF4ZXMuaHRtbCBBeGVzfSBpbnN0YW5jZVxyXG4gICAgICogQGtvIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWF4ZXMvcmVsZWFzZS9sYXRlc3QvZG9jL2VnLkF4ZXMuaHRtbCBBeGVzfSDsnbjsiqTthLTsiqQg64K067aA7J2YIO2YhOyerCDsooztkZwg6rCSXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfYSwgX2I7XG4gICAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5fYXhlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldChbUE9TSVRJT05fS0VZXSlbUE9TSVRJT05fS0VZXSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwicmFuZ2VcIiwge1xuICAgIC8qKlxyXG4gICAgICogQ3VycmVudCByYW5nZSB2YWx1ZSBpbiB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1heGVzL3JlbGVhc2UvbGF0ZXN0L2RvYy9lZy5BeGVzLmh0bWwgQXhlc30gaW5zdGFuY2VcclxuICAgICAqIEBrbyB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1heGVzL3JlbGVhc2UvbGF0ZXN0L2RvYy9lZy5BeGVzLmh0bWwgQXhlc30g7J247Iqk7YS07IqkIOuCtOu2gOydmCDtmITsnqwg7J2064+ZIOuylOychCDqsJJcclxuICAgICAqIEB0eXBlIHtudW1iZXJbXX1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMuX2F4ZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5heGlzW1BPU0lUSU9OX0tFWV0ucmFuZ2UpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFswLCAwXTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwiYm91bmNlXCIsIHtcbiAgICAvKipcclxuICAgICAqIEFjdHVhbCBib3VuY2Ugc2l6ZShweClcclxuICAgICAqIEBrbyDsoIHsmqnrkJwgYm91bmNlIO2BrOq4sChweCDri6jsnIQpXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyW119XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgcmV0dXJuIChfYSA9IHRoaXMuX2F4ZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5heGlzW1BPU0lUSU9OX0tFWV0uYm91bmNlO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICAvKipcclxuICAgKiBJbml0aWFsaXplIEF4ZXNDb250cm9sbGVyXHJcbiAgICogQGtvIEF4ZXNDb250cm9sbGVy66W8IOy0iOq4sO2ZlO2VqeuLiOuLpFxyXG4gICAqIEBwYXJhbSB7RmxpY2tpbmd9IGZsaWNraW5nIEFuIGluc3RhbmNlIG9mIEZsaWNraW5nXHJcbiAgICogQGNoYWluYWJsZVxyXG4gICAqIEByZXR1cm4ge3RoaXN9XHJcbiAgICovXG4gIF9fcHJvdG8uaW5pdCA9IGZ1bmN0aW9uIChmbGlja2luZykge1xuICAgIHZhciBfYTtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHRoaXMuX2ZsaWNraW5nID0gZmxpY2tpbmc7XG4gICAgdGhpcy5fYXhlcyA9IG5ldyBBeGVzKChfYSA9IHt9LCBfYVtQT1NJVElPTl9LRVldID0ge1xuICAgICAgcmFuZ2U6IFswLCAwXSxcbiAgICAgIGNpcmN1bGFyOiBmYWxzZSxcbiAgICAgIGJvdW5jZTogWzAsIDBdXG4gICAgfSwgX2EpLCB7XG4gICAgICBkZWNlbGVyYXRpb246IGZsaWNraW5nLmRlY2VsZXJhdGlvbixcbiAgICAgIGludGVycnVwdGFibGU6IGZsaWNraW5nLmludGVycnVwdGFibGUsXG4gICAgICBuZXN0ZWQ6IGZsaWNraW5nLm5lc3RlZCxcbiAgICAgIGVhc2luZzogZmxpY2tpbmcuZWFzaW5nXG4gICAgfSk7XG4gICAgdGhpcy5fcGFuSW5wdXQgPSBuZXcgUGFuSW5wdXQoZmxpY2tpbmcudmlld3BvcnQuZWxlbWVudCwge1xuICAgICAgaW5wdXRUeXBlOiBmbGlja2luZy5pbnB1dFR5cGUsXG4gICAgICB0aHJlc2hvbGQ6IDEsXG4gICAgICBpT1NFZGdlU3dpcGVUaHJlc2hvbGQ6IGZsaWNraW5nLmlPU0VkZ2VTd2lwZVRocmVzaG9sZCxcbiAgICAgIHByZXZlbnREZWZhdWx0T25EcmFnOiBmbGlja2luZy5wcmV2ZW50RGVmYXVsdE9uRHJhZyxcbiAgICAgIHNjYWxlOiBmbGlja2luZy5ob3Jpem9udGFsID8gW2ZsaWNraW5nLmNhbWVyYS5wYW5lbE9yZGVyID09PSBPUkRFUi5SVEwgPyAxIDogLTEsIDBdIDogWzAsIC0xXSxcbiAgICAgIHJlbGVhc2VPblNjcm9sbDogdHJ1ZVxuICAgIH0pO1xuICAgIHZhciBheGVzID0gdGhpcy5fYXhlcztcbiAgICBheGVzLmNvbm5lY3QoZmxpY2tpbmcuaG9yaXpvbnRhbCA/IFtQT1NJVElPTl9LRVksIFwiXCJdIDogW1wiXCIsIFBPU0lUSU9OX0tFWV0sIHRoaXMuX3BhbklucHV0KTtcbiAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHZhciBldmVudFR5cGUgPSBFVkVOVFtrZXldO1xuICAgICAgYXhlcy5vbihldmVudFR5cGUsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIF90aGlzLl9zdGF0ZU1hY2hpbmUuZmlyZShldmVudFR5cGUsIHtcbiAgICAgICAgICBmbGlja2luZzogZmxpY2tpbmcsXG4gICAgICAgICAgYXhlc0V2ZW50OiBlXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBmb3IgKHZhciBrZXkgaW4gRVZFTlQpIHtcbiAgICAgIF9sb29wXzEoa2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxyXG4gICAqIERlc3Ryb3kgQXhlc0NvbnRyb2xsZXIgYW5kIHJldHVybiB0byBpbml0aWFsIHN0YXRlXHJcbiAgICogQGtvIEF4ZXNDb250cm9sbGVy66W8IOy0iOq4sCDsg4Htg5zroZwg65CY64+M66a964uI64ukXHJcbiAgICogQHJldHVybiB7dm9pZH1cclxuICAgKi9cbiAgX19wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfYTtcbiAgICBpZiAodGhpcy5fYXhlcykge1xuICAgICAgdGhpcy5yZW1vdmVQcmV2ZW50Q2xpY2tIYW5kbGVyKCk7XG4gICAgICB0aGlzLl9heGVzLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgKF9hID0gdGhpcy5fcGFuSW5wdXQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZXN0cm95KCk7XG4gICAgdGhpcy5fcmVzZXRJbnRlcm5hbFZhbHVlcygpO1xuICB9O1xuICAvKipcclxuICAgKiBFbmFibGUgaW5wdXQgZnJvbSB0aGUgdXNlciAobW91c2UvdG91Y2gpXHJcbiAgICogQGtvIOyCrOyaqeyekOydmCDsnoXroKUo66eI7Jqw7IqkL+2EsOy5mCnrpbwg7Zmc7ISx7ZmU7ZWp64uI64ukXHJcbiAgICogQGNoYWluYWJsZVxyXG4gICAqIEByZXR1cm4ge3RoaXN9XHJcbiAgICovXG4gIF9fcHJvdG8uZW5hYmxlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfYTtcbiAgICAoX2EgPSB0aGlzLl9wYW5JbnB1dCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmVuYWJsZSgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcclxuICAgKiBEaXNhYmxlIGlucHV0IGZyb20gdGhlIHVzZXIgKG1vdXNlL3RvdWNoKVxyXG4gICAqIEBrbyDsgqzsmqnsnpDsnZgg7J6F66ClKOuniOyasOyKpC/thLDsuZgp66W8IOunieyKteuLiOuLpFxyXG4gICAqIEBjaGFpbmFibGVcclxuICAgKiBAcmV0dXJuIHt0aGlzfVxyXG4gICAqL1xuICBfX3Byb3RvLmRpc2FibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9hO1xuICAgIChfYSA9IHRoaXMuX3BhbklucHV0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGlzYWJsZSgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcclxuICAgKiBSZWxlYXNlcyBvbmdvaW5nIHVzZXIgaW5wdXQgKG1vdXNlL3RvdWNoKVxyXG4gICAqIEBrbyDsgqzsmqnsnpDsnZgg7ZiE7J6sIOyeheugpSjrp4jsmrDsiqQv7YSw7LmYKeulvCDspJHri6jsi5ztgrXri4jri6RcclxuICAgKiBAY2hhaW5hYmxlXHJcbiAgICogQHJldHVybiB7dGhpc31cclxuICAgKi9cbiAgX19wcm90by5yZWxlYXNlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfYTtcbiAgICAoX2EgPSB0aGlzLl9wYW5JbnB1dCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlbGVhc2UoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXHJcbiAgICogQ2hhbmdlIHRoZSBkZXN0aW5hdGlvbiBhbmQgZHVyYXRpb24gb2YgdGhlIGFuaW1hdGlvbiBjdXJyZW50bHkgcGxheWluZ1xyXG4gICAqIEBrbyDsnqzsg50g7KSR7J24IOyVoOuLiOuplOydtOyFmOydmCDrqqnsoIHsp4DsmYAg7J6s7IOdIOyLnOqwhOydhCDrs4Dqsr3tlanri4jri6RcclxuICAgKiBAcGFyYW0ge251bWJlcn0gcG9zaXRpb24gQSBwb3NpdGlvbiB0byBtb3ZlPGtvPuydtOuPme2VoCDsooztkZw8L2tvPlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkdXJhdGlvbiBEdXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uICh1bml0OiBtcyk8a28+7JWg64uI66mU7J207IWYIOynhO2WiSDsi5zqsIQgKOuLqOychDogbXMpPC9rbz5cclxuICAgKiBAY2hhaW5hYmxlXHJcbiAgICogQHJldHVybiB7dGhpc31cclxuICAgKi9cbiAgX19wcm90by51cGRhdGVBbmltYXRpb24gPSBmdW5jdGlvbiAocG9zaXRpb24sIGR1cmF0aW9uKSB7XG4gICAgdmFyIF9hO1xuICAgIHZhciBfYjtcbiAgICB0aGlzLl9hbmltYXRpbmdDb250ZXh0ID0gX19hc3NpZ24kMihfX2Fzc2lnbiQyKHt9LCB0aGlzLl9hbmltYXRpbmdDb250ZXh0KSwge1xuICAgICAgZW5kOiBwb3NpdGlvblxuICAgIH0pO1xuICAgIChfYiA9IHRoaXMuX2F4ZXMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi51cGRhdGVBbmltYXRpb24oe1xuICAgICAgZGVzdFBvczogKF9hID0ge30sIF9hW1BPU0lUSU9OX0tFWV0gPSBwb3NpdGlvbiwgX2EpLFxuICAgICAgZHVyYXRpb246IGR1cmF0aW9uXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxyXG4gICAqIFN0b3BzIHRoZSBhbmltYXRpb24gY3VycmVudGx5IHBsYXlpbmdcclxuICAgKiBAa28g7J6s7IOdIOykkeyduCDslaDri4jrqZTsnbTshZjsnYQg7KSR64uo7Iuc7YK164uI64ukXHJcbiAgICogQGNoYWluYWJsZVxyXG4gICAqIEByZXR1cm4ge3RoaXN9XHJcbiAgICovXG4gIF9fcHJvdG8uc3RvcEFuaW1hdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX2E7XG4gICAgKF9hID0gdGhpcy5fYXhlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN0b3BBbmltYXRpb24oKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXHJcbiAgICogVXBkYXRlIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWF4ZXMvIEBlZ2pzL2F4ZXN9J3Mgc3RhdGVcclxuICAgKiBAa28ge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtYXhlcy8gQGVnanMvYXhlc33snZgg7IOB7YOc66W8IOqwseyLoO2VqeuLiOuLpFxyXG4gICAqIEBjaGFpbmFibGVcclxuICAgKiBAdGhyb3dzIHtGbGlja2luZ0Vycm9yfVxyXG4gICAqIHtAbGluayBFUlJPUl9DT0RFIE5PVF9BVFRBQ0hFRF9UT19GTElDS0lOR30gV2hlbiB7QGxpbmsgQXhlc0NvbnRyb2xsZXIjaW5pdCBpbml0fSBpcyBub3QgY2FsbGVkIGJlZm9yZVxyXG4gICAqIDxrbz57QGxpbmsgQXhlc0NvbnRyb2xsZXIjaW5pdCBpbml0feydtCDsnbTsoITsl5Ag7Zi47Lac65CY7KeAIOyViuydgCDqsr3smrA8L2tvPlxyXG4gICAqIEByZXR1cm4ge3RoaXN9XHJcbiAgICovXG4gIF9fcHJvdG8udXBkYXRlID0gZnVuY3Rpb24gKGNvbnRyb2xQYXJhbXMpIHtcbiAgICB2YXIgX2E7XG4gICAgdmFyIGZsaWNraW5nID0gZ2V0RmxpY2tpbmdBdHRhY2hlZCh0aGlzLl9mbGlja2luZyk7XG4gICAgdmFyIGNhbWVyYSA9IGZsaWNraW5nLmNhbWVyYTtcbiAgICB2YXIgYXhlcyA9IHRoaXMuX2F4ZXM7XG4gICAgdmFyIGF4aXMgPSBheGVzLmF4aXNbUE9TSVRJT05fS0VZXTtcbiAgICBheGlzLmNpcmN1bGFyID0gW2NvbnRyb2xQYXJhbXMuY2lyY3VsYXIsIGNvbnRyb2xQYXJhbXMuY2lyY3VsYXJdO1xuICAgIGF4aXMucmFuZ2UgPSBbY29udHJvbFBhcmFtcy5yYW5nZS5taW4sIGNvbnRyb2xQYXJhbXMucmFuZ2UubWF4XTtcbiAgICBheGlzLmJvdW5jZSA9IHBhcnNlQm91bmNlKGZsaWNraW5nLmJvdW5jZSwgY2FtZXJhLnNpemUpO1xuICAgIGF4ZXMuYXhpc01hbmFnZXIuc2V0KChfYSA9IHt9LCBfYVtQT1NJVElPTl9LRVldID0gY29udHJvbFBhcmFtcy5wb3NpdGlvbiwgX2EpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXHJcbiAgICogQXR0YWNoIGEgaGFuZGxlciB0byB0aGUgY2FtZXJhIGVsZW1lbnQgdG8gcHJldmVudCBjbGljayBldmVudHMgZHVyaW5nIGFuaW1hdGlvblxyXG4gICAqIEBrbyDsubTrqZTrnbwg7JeY66as66i87Yq47JeQIOyVoOuLiOuplOydtOyFmCDrj4TspJHsl5Ag7YG066atIOydtOuypO2KuOulvCDrsKnsp4DtlZjripQg7ZW465Ok65+s66W8IOu2gOywqe2VqeuLiOuLpFxyXG4gICAqIEByZXR1cm4ge3RoaXN9XHJcbiAgICovXG4gIF9fcHJvdG8uYWRkUHJldmVudENsaWNrSGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZmxpY2tpbmcgPSBnZXRGbGlja2luZ0F0dGFjaGVkKHRoaXMuX2ZsaWNraW5nKTtcbiAgICB2YXIgYXhlcyA9IHRoaXMuX2F4ZXM7XG4gICAgdmFyIGNhbWVyYUVsID0gZmxpY2tpbmcuY2FtZXJhLmVsZW1lbnQ7XG4gICAgYXhlcy5vbihFVkVOVC5IT0xELCB0aGlzLl9vbkF4ZXNIb2xkKTtcbiAgICBheGVzLm9uKEVWRU5ULkNIQU5HRSwgdGhpcy5fb25BeGVzQ2hhbmdlKTtcbiAgICBjYW1lcmFFbC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fcHJldmVudENsaWNrV2hlbkRyYWdnZWQsIHRydWUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcclxuICAgKiBEZXRhY2ggYSBoYW5kbGVyIHRvIHRoZSBjYW1lcmEgZWxlbWVudCB0byBwcmV2ZW50IGNsaWNrIGV2ZW50cyBkdXJpbmcgYW5pbWF0aW9uXHJcbiAgICogQGtvIOy5tOuplOudvCDsl5jrpqzrqLztirjsl5Ag7JWg64uI66mU7J207IWYIOuPhOykkeyXkCDtgbTrpq0g7J2067Kk7Yq466W8IOuwqeyngO2VmOuKlCDtlbjrk6Trn6zrpbwg7YOI7LCp7ZWp64uI64ukXHJcbiAgICogQHJldHVybiB7dGhpc31cclxuICAgKi9cbiAgX19wcm90by5yZW1vdmVQcmV2ZW50Q2xpY2tIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBmbGlja2luZyA9IGdldEZsaWNraW5nQXR0YWNoZWQodGhpcy5fZmxpY2tpbmcpO1xuICAgIHZhciBheGVzID0gdGhpcy5fYXhlcztcbiAgICB2YXIgY2FtZXJhRWwgPSBmbGlja2luZy5jYW1lcmEuZWxlbWVudDtcbiAgICBheGVzLm9mZihFVkVOVC5IT0xELCB0aGlzLl9vbkF4ZXNIb2xkKTtcbiAgICBheGVzLm9mZihFVkVOVC5DSEFOR0UsIHRoaXMuX29uQXhlc0NoYW5nZSk7XG4gICAgY2FtZXJhRWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX3ByZXZlbnRDbGlja1doZW5EcmFnZ2VkLCB0cnVlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXHJcbiAgICogUnVuIEF4ZXMncyB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1heGVzL3JlbGVhc2UvbGF0ZXN0L2RvYy9lZy5BeGVzLmh0bWwjc2V0VG8gc2V0VG99IHVzaW5nIHRoZSBnaXZlbiBwb3NpdGlvblxyXG4gICAqIEBrbyBBeGVz7J2YIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWF4ZXMvcmVsZWFzZS9sYXRlc3QvZG9jL2VnLkF4ZXMuaHRtbCNzZXRUbyBzZXRUb30g66mU7IaM65Oc66W8IOyjvOyWtOynhCDsooztkZzrpbwg7J207Jqp7ZWY7JesIOyImO2Wie2VqeuLiOuLpFxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwb3NpdGlvbiBBIHBvc2l0aW9uIHRvIG1vdmU8a28+7J2064+Z7ZWgIOyijO2RnDwva28+XHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGR1cmF0aW9uIER1cmF0aW9uIG9mIHRoZSBhbmltYXRpb24gKHVuaXQ6IG1zKTxrbz7slaDri4jrqZTsnbTshZgg7KeE7ZaJIOyLnOqwhCAo64uo7JyEOiBtcyk8L2tvPlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbYXhlc0V2ZW50XSBJZiBwcm92aWRlZCwgaXQnbGwgdXNlIGl0cyB7QGxpbmsgaHR0cHM6Ly9uYXZlciNnaXRodWIjaW8vZWdqcy1heGVzL3JlbGVhc2UvbGF0ZXN0L2RvYy9lZyNBeGVzI2h0bWwjc2V0VG8gc2V0VG99IG1ldGhvZCBpbnN0ZWFkPGtvPuydtCDqsJLsnbQg7KO87Ja07KGM7J2EIOqyveyasCwg7ZW064u5IOydtOuypO2KuOydmCB7QGxpbmsgaHR0cHM6Ly9uYXZlciNnaXRodWIjaW8vZWdqcy1heGVzL3JlbGVhc2UvbGF0ZXN0L2RvYy9lZyNBeGVzI2h0bWwjc2V0VG8gc2V0VG99IOuplOyGjOuTnOulvCDrjIDsi6DtlbTshJwg7IKs7Jqp7ZWp64uI64ukLjwva28+XHJcbiAgICogQHRocm93cyB7RmxpY2tpbmdFcnJvcn1cclxuICAgKiB8Y29kZXxjb25kaXRpb258XHJcbiAgICogfC0tLXwtLS18XHJcbiAgICogfHtAbGluayBFUlJPUl9DT0RFIE5PVF9BVFRBQ0hFRF9UT19GTElDS0lOR318V2hlbiB7QGxpbmsgQ29udHJvbCNpbml0IGluaXR9IGlzIG5vdCBjYWxsZWQgYmVmb3JlfFxyXG4gICAqIHx7QGxpbmsgRVJST1JfQ09ERSBBTklNQVRJT05fSU5URVJSVVBURUR9fFdoZW4gdGhlIGFuaW1hdGlvbiBpcyBpbnRlcnJ1cHRlZCBieSB1c2VyIGlucHV0fFxyXG4gICAqIDxrbz5cclxuICAgKlxyXG4gICAqIHxjb2RlfGNvbmRpdGlvbnxcclxuICAgKiB8LS0tfC0tLXxcclxuICAgKiB8e0BsaW5rIEVSUk9SX0NPREUgTk9UX0FUVEFDSEVEX1RPX0ZMSUNLSU5HfXx7QGxpbmsgQ29udHJvbCNpbml0IGluaXR97J20IOydtOyghOyXkCDtmLjstpzrkJjsp4Ag7JWK7J2AIOqyveyasHxcclxuICAgKiB8e0BsaW5rIEVSUk9SX0NPREUgQU5JTUFUSU9OX0lOVEVSUlVQVEVEfXzsgqzsmqnsnpAg7J6F66Cl7JeQIOydmO2VtCDslaDri4jrqZTsnbTshZjsnbQg7KSR64uo65CcIOqyveyasHxcclxuICAgKlxyXG4gICAqIDwva28+XHJcbiAgICogQHJldHVybiB7UHJvbWlzZTx2b2lkPn0gQSBQcm9taXNlIHdoaWNoIHdpbGwgYmUgcmVzb2x2ZWQgYWZ0ZXIgcmVhY2hpbmcgdGhlIHRhcmdldCBwb3NpdGlvbjxrbz7tlbTri7kg7KKM7ZGcIOuPhOuLrOyLnOyXkCByZXNvbHZl65CY64qUIFByb21pc2U8L2tvPlxyXG4gICAqL1xuICBfX3Byb3RvLmFuaW1hdGVUbyA9IGZ1bmN0aW9uIChwb3NpdGlvbiwgZHVyYXRpb24sIGF4ZXNFdmVudCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIF9hO1xuICAgIHZhciBheGVzID0gdGhpcy5fYXhlcztcbiAgICB2YXIgc3RhdGUgPSB0aGlzLl9zdGF0ZU1hY2hpbmUuc3RhdGU7XG4gICAgaWYgKCFheGVzKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEZsaWNraW5nRXJyb3IoTUVTU0FHRS5OT1RfQVRUQUNIRURfVE9fRkxJQ0tJTkcsIENPREUuTk9UX0FUVEFDSEVEX1RPX0ZMSUNLSU5HKSk7XG4gICAgfVxuICAgIHZhciBzdGFydFBvcyA9IGF4ZXMuZ2V0KFtQT1NJVElPTl9LRVldKVtQT1NJVElPTl9LRVldO1xuICAgIGlmIChzdGFydFBvcyA9PT0gcG9zaXRpb24pIHtcbiAgICAgIHZhciBmbGlja2luZyA9IGdldEZsaWNraW5nQXR0YWNoZWQodGhpcy5fZmxpY2tpbmcpO1xuICAgICAgZmxpY2tpbmcuY2FtZXJhLmxvb2tBdChwb3NpdGlvbik7XG4gICAgICBpZiAoc3RhdGUudGFyZ2V0UGFuZWwpIHtcbiAgICAgICAgZmxpY2tpbmcuY29udHJvbC5zZXRBY3RpdmUoc3RhdGUudGFyZ2V0UGFuZWwsIGZsaWNraW5nLmNvbnRyb2wuYWN0aXZlUGFuZWwsIChfYSA9IGF4ZXNFdmVudCA9PT0gbnVsbCB8fCBheGVzRXZlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGF4ZXNFdmVudC5pc1RydXN0ZWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgdGhpcy5fYW5pbWF0aW5nQ29udGV4dCA9IHtcbiAgICAgIHN0YXJ0OiBzdGFydFBvcyxcbiAgICAgIGVuZDogcG9zaXRpb24sXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9O1xuICAgIHZhciBhbmltYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIHZhciByZXNldENvbnRleHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLl9hbmltYXRpbmdDb250ZXh0ID0ge1xuICAgICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICAgIGVuZDogMCxcbiAgICAgICAgICBvZmZzZXQ6IDBcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgICBheGVzLm9uY2UoRVZFTlQuRklOSVNILCByZXNldENvbnRleHQpO1xuICAgICAgaWYgKGF4ZXNFdmVudCkge1xuICAgICAgICBheGVzRXZlbnQuc2V0VG8oKF9hID0ge30sIF9hW1BPU0lUSU9OX0tFWV0gPSBwb3NpdGlvbiwgX2EpLCBkdXJhdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBheGVzLnNldFRvKChfYiA9IHt9LCBfYltQT1NJVElPTl9LRVldID0gcG9zaXRpb24sIF9iKSwgZHVyYXRpb24pO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBhbmltYXRpb25GaW5pc2hIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBheGVzLm9mZihFVkVOVC5IT0xELCBpbnRlcnJ1cHRpb25IYW5kbGVyKTtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfTtcbiAgICAgIHZhciBpbnRlcnJ1cHRpb25IYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBheGVzLm9mZihFVkVOVC5GSU5JU0gsIGFuaW1hdGlvbkZpbmlzaEhhbmRsZXIpO1xuICAgICAgICByZWplY3QobmV3IEZsaWNraW5nRXJyb3IoTUVTU0FHRS5BTklNQVRJT05fSU5URVJSVVBURUQsIENPREUuQU5JTUFUSU9OX0lOVEVSUlVQVEVEKSk7XG4gICAgICB9O1xuICAgICAgYXhlcy5vbmNlKEVWRU5ULkZJTklTSCwgYW5pbWF0aW9uRmluaXNoSGFuZGxlcik7XG4gICAgICBheGVzLm9uY2UoRVZFTlQuSE9MRCwgaW50ZXJydXB0aW9uSGFuZGxlcik7XG4gICAgICBhbmltYXRlKCk7XG4gICAgfSk7XG4gIH07XG4gIF9fcHJvdG8udXBkYXRlRGlyZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBmbGlja2luZyA9IGdldEZsaWNraW5nQXR0YWNoZWQodGhpcy5fZmxpY2tpbmcpO1xuICAgIHZhciBheGVzID0gdGhpcy5fYXhlcztcbiAgICB2YXIgcGFuSW5wdXQgPSB0aGlzLl9wYW5JbnB1dDtcbiAgICBheGVzLmRpc2Nvbm5lY3QocGFuSW5wdXQpO1xuICAgIGF4ZXMuY29ubmVjdChmbGlja2luZy5ob3Jpem9udGFsID8gW1BPU0lUSU9OX0tFWSwgXCJcIl0gOiBbXCJcIiwgUE9TSVRJT05fS0VZXSwgcGFuSW5wdXQpO1xuICAgIHBhbklucHV0Lm9wdGlvbnMuc2NhbGUgPSBmbGlja2luZy5ob3Jpem9udGFsID8gW2ZsaWNraW5nLmNhbWVyYS5wYW5lbE9yZGVyID09PSBPUkRFUi5SVEwgPyAxIDogLTEsIDBdIDogWzAsIC0xXTtcbiAgfTtcbiAgX19wcm90by5fcmVzZXRJbnRlcm5hbFZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9mbGlja2luZyA9IG51bGw7XG4gICAgdGhpcy5fYXhlcyA9IG51bGw7XG4gICAgdGhpcy5fcGFuSW5wdXQgPSBudWxsO1xuICAgIHRoaXMuX2FuaW1hdGluZ0NvbnRleHQgPSB7XG4gICAgICBzdGFydDogMCxcbiAgICAgIGVuZDogMCxcbiAgICAgIG9mZnNldDogMFxuICAgIH07XG4gICAgdGhpcy5fZHJhZ2dlZCA9IGZhbHNlO1xuICB9O1xuICByZXR1cm4gQXhlc0NvbnRyb2xsZXI7XG59KCk7XG5cbi8qKlxyXG4gKiBBIGNvbXBvbmVudCB0aGF0IG1hbmFnZXMgaW5wdXRzIGFuZCBhbmltYXRpb24gb2YgRmxpY2tpbmdcclxuICogQGtvIEZsaWNraW5n7J2YIOyeheugpSDsnqXsuZggJiDslaDri4jrqZTsnbTshZjsnYQg64u064u57ZWY64qUIOy7tO2PrOuEjO2KuFxyXG4gKi9cbnZhciBDb250cm9sID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqICovXG4gIGZ1bmN0aW9uIENvbnRyb2woKSB7XG4gICAgdGhpcy5fZmxpY2tpbmcgPSBudWxsO1xuICAgIHRoaXMuX2NvbnRyb2xsZXIgPSBuZXcgQXhlc0NvbnRyb2xsZXIoKTtcbiAgICB0aGlzLl9hY3RpdmVQYW5lbCA9IG51bGw7XG4gIH1cbiAgdmFyIF9fcHJvdG8gPSBDb250cm9sLnByb3RvdHlwZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwiY29udHJvbGxlclwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBBIGNvbnRyb2xsZXIgdGhhdCBoYW5kbGVzIHRoZSB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1heGVzLyBAZWdqcy9heGVzfSBldmVudHNcclxuICAgICAqIEBrbyB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1heGVzLyBAZWdqcy9heGVzfeydmCDsnbTrsqTtirjrpbwg7LKY66as7ZWY64qUIOy7qO2KuOuhpOufrCDsu7Ttj6zrhIztirhcclxuICAgICAqIEB0eXBlIHtBeGVzQ29udHJvbGxlcn1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY29udHJvbGxlcjtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwiYWN0aXZlSW5kZXhcIiwge1xuICAgIC8qKlxyXG4gICAgICogSW5kZXggbnVtYmVyIG9mIHRoZSB7QGxpbmsgRmxpY2tpbmcjY3VycmVudFBhbmVsIGN1cnJlbnRQYW5lbH1cclxuICAgICAqIEBrbyB7QGxpbmsgRmxpY2tpbmcjY3VycmVudFBhbmVsIGN1cnJlbnRQYW5lbH3snZgg7J24642x7IqkIOuyiO2YuFxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMuX2FjdGl2ZVBhbmVsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaW5kZXgpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IC0xO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJhY3RpdmVQYW5lbFwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBBbiBhY3RpdmUgcGFuZWxcclxuICAgICAqIEBrbyDtmITsnqwg7ISg7YOd65CcIO2MqOuEkFxyXG4gICAgICogQHR5cGUge1BhbmVsIHwgbnVsbH1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYWN0aXZlUGFuZWw7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcImFuaW1hdGluZ1wiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIEZsaWNraW5nJ3MgYW5pbWF0aW5nXHJcbiAgICAgKiBAa28g7ZiE7J6sIOyVoOuLiOuplOydtOyFmCDrj5nsnpEg7Jes67aAXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY29udHJvbGxlci5zdGF0ZS5hbmltYXRpbmc7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcImhvbGRpbmdcIiwge1xuICAgIC8qKlxyXG4gICAgICogV2hldGhlciB1c2VyIGlzIGNsaWNraW5nIG9yIHRvdWNoaW5nXHJcbiAgICAgKiBAa28g7ZiE7J6sIOyCrOyaqeyekOqwgCDtgbTrpq0v7YSw7LmY7KSR7J247KeAIOyXrOu2gFxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NvbnRyb2xsZXIuc3RhdGUuaG9sZGluZztcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgLyoqXHJcbiAgICogSW5pdGlhbGl6ZSBDb250cm9sXHJcbiAgICogQGtvIENvbnRyb2zsnYQg7LSI6riw7ZmU7ZWp64uI64ukXHJcbiAgICogQHBhcmFtIHtGbGlja2luZ30gZmxpY2tpbmcgQW4gaW5zdGFuY2Ugb2Yge0BsaW5rIEZsaWNraW5nfTxrbz5GbGlja2luZ+ydmCDsnbjsiqTthLTsiqQ8L2tvPlxyXG4gICAqIEBjaGFpbmFibGVcclxuICAgKiBAcmV0dXJuIHt0aGlzfVxyXG4gICAqL1xuICBfX3Byb3RvLmluaXQgPSBmdW5jdGlvbiAoZmxpY2tpbmcpIHtcbiAgICB0aGlzLl9mbGlja2luZyA9IGZsaWNraW5nO1xuICAgIHRoaXMuX2NvbnRyb2xsZXIuaW5pdChmbGlja2luZyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxyXG4gICAqIERlc3Ryb3kgQ29udHJvbCBhbmQgcmV0dXJuIHRvIGluaXRpYWwgc3RhdGVcclxuICAgKiBAa28gQ29udHJvbOydhCDstIjquLAg7IOB7YOc66GcIOuQmOuPjOumveuLiOuLpFxyXG4gICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICovXG4gIF9fcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9jb250cm9sbGVyLmRlc3Ryb3koKTtcbiAgICB0aGlzLl9mbGlja2luZyA9IG51bGw7XG4gICAgdGhpcy5fYWN0aXZlUGFuZWwgPSBudWxsO1xuICB9O1xuICAvKipcclxuICAgKiBFbmFibGUgaW5wdXQgZnJvbSB0aGUgdXNlciAobW91c2UvdG91Y2gpXHJcbiAgICogQGtvIOyCrOyaqeyekOydmCDsnoXroKUo66eI7Jqw7IqkL+2EsOy5mCnrpbwg7Zmc7ISx7ZmU7ZWp64uI64ukXHJcbiAgICogQGNoYWluYWJsZVxyXG4gICAqIEByZXR1cm4ge3RoaXN9XHJcbiAgICovXG4gIF9fcHJvdG8uZW5hYmxlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2NvbnRyb2xsZXIuZW5hYmxlKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxyXG4gICAqIERpc2FibGUgaW5wdXQgZnJvbSB0aGUgdXNlciAobW91c2UvdG91Y2gpXHJcbiAgICogQGtvIOyCrOyaqeyekOydmCDsnoXroKUo66eI7Jqw7IqkL+2EsOy5mCnrpbwg66eJ7Iq164uI64ukXHJcbiAgICogQGNoYWluYWJsZVxyXG4gICAqIEByZXR1cm4ge3RoaXN9XHJcbiAgICovXG4gIF9fcHJvdG8uZGlzYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9jb250cm9sbGVyLmRpc2FibGUoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXHJcbiAgICogUmVsZWFzZXMgb25nb2luZyB1c2VyIGlucHV0IChtb3VzZS90b3VjaClcclxuICAgKiBAa28g7IKs7Jqp7J6Q7J2YIO2YhOyerCDsnoXroKUo66eI7Jqw7IqkL+2EsOy5mCnrpbwg7KSR64uo7Iuc7YK164uI64ukXHJcbiAgICogQGNoYWluYWJsZVxyXG4gICAqIEByZXR1cm4ge3RoaXN9XHJcbiAgICovXG4gIF9fcHJvdG8ucmVsZWFzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9jb250cm9sbGVyLnJlbGVhc2UoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXHJcbiAgICogQ2hhbmdlIHRoZSBkZXN0aW5hdGlvbiBhbmQgZHVyYXRpb24gb2YgdGhlIGFuaW1hdGlvbiBjdXJyZW50bHkgcGxheWluZ1xyXG4gICAqIEBrbyDsnqzsg50g7KSR7J24IOyVoOuLiOuplOydtOyFmOydmCDrqqnsoIHsp4DsmYAg7J6s7IOdIOyLnOqwhOydhCDrs4Dqsr3tlanri4jri6RcclxuICAgKiBAcGFyYW0ge1BhbmVsfSBwYW5lbCBUaGUgdGFyZ2V0IHBhbmVsIHRvIG1vdmU8a28+7J2064+Z7ZWgIO2MqOuEkDwva28+XHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGR1cmF0aW9uIER1cmF0aW9uIG9mIHRoZSBhbmltYXRpb24gKHVuaXQ6IG1zKTxrbz7slaDri4jrqZTsnbTshZgg7KeE7ZaJIOyLnOqwhCAo64uo7JyEOiBtcyk8L2tvPlxyXG4gICAqIEBwYXJhbSB7RElSRUNUSU9OfSBkaXJlY3Rpb24gRGlyZWN0aW9uIHRvIG1vdmUsIG9ubHkgYXZhaWxhYmxlIGluIHRoZSB7QGxpbmsgRmxpY2tpbmcjY2lyY3VsYXIgY2lyY3VsYXJ9IG1vZGU8a28+7J2064+Z7ZWgIOuwqe2WpS4ge0BsaW5rIEZsaWNraW5nI2NpcmN1bGFyIGNpcmN1bGFyfSDsmLXshZgg7Zmc7ISx7ZmU7Iuc7JeQ66eMIOyCrOyaqSDqsIDriqXtlanri4jri6Q8L2tvPlxyXG4gICAqIEBjaGFpbmFibGVcclxuICAgKiBAdGhyb3dzIHtGbGlja2luZ0Vycm9yfVxyXG4gICAqIHtAbGluayBFUlJPUl9DT0RFIFBPU0lUSU9OX05PVF9SRUFDSEFCTEV9IFdoZW4gdGhlIGdpdmVuIHBhbmVsIGlzIGFscmVhZHkgcmVtb3ZlZCBvciBub3QgaW4gdGhlIENhbWVyYSdzIHtAbGluayBDYW1lcmEjcmFuZ2UgcmFuZ2V9XHJcbiAgICogPGtvPntAbGluayBFUlJPUl9DT0RFIFBPU0lUSU9OX05PVF9SRUFDSEFCTEV9IOyjvOyWtOynhCDtjKjrhJDsnbQg7KCc6rGw65CY7JeI6rGw64KYLCBDYW1lcmHsnZgge0BsaW5rIENhbWVyYSNyYW5nZSByYW5nZX0g67CW7JeQIOyeiOydhCDqsr3smrA8L2tvPlxyXG4gICAqIEByZXR1cm4ge3RoaXN9XHJcbiAgICovXG4gIF9fcHJvdG8udXBkYXRlQW5pbWF0aW9uID0gZnVuY3Rpb24gKHBhbmVsLCBkdXJhdGlvbiwgZGlyZWN0aW9uKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5fY29udHJvbGxlci5zdGF0ZTtcbiAgICB2YXIgcG9zaXRpb24gPSB0aGlzLl9nZXRQb3NpdGlvbihwYW5lbCwgZGlyZWN0aW9uICE9PSBudWxsICYmIGRpcmVjdGlvbiAhPT0gdm9pZCAwID8gZGlyZWN0aW9uIDogRElSRUNUSU9OLk5PTkUpO1xuICAgIHN0YXRlLnRhcmdldFBhbmVsID0gcGFuZWw7XG4gICAgdGhpcy5fY29udHJvbGxlci51cGRhdGVBbmltYXRpb24ocG9zaXRpb24sIGR1cmF0aW9uKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXHJcbiAgICogU3RvcHMgdGhlIGFuaW1hdGlvbiBjdXJyZW50bHkgcGxheWluZ1xyXG4gICAqIEBrbyDsnqzsg50g7KSR7J24IOyVoOuLiOuplOydtOyFmOydhCDspJHri6jsi5ztgrXri4jri6RcclxuICAgKiBAY2hhaW5hYmxlXHJcbiAgICogQHJldHVybiB7dGhpc31cclxuICAgKi9cbiAgX19wcm90by5zdG9wQW5pbWF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuX2NvbnRyb2xsZXIuc3RhdGU7XG4gICAgc3RhdGUudGFyZ2V0UGFuZWwgPSBudWxsO1xuICAgIHRoaXMuX2NvbnRyb2xsZXIuc3RvcEFuaW1hdGlvbigpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcclxuICAgKiBVcGRhdGUgcG9zaXRpb24gYWZ0ZXIgcmVzaXppbmdcclxuICAgKiBAa28gcmVzaXplIOydtO2bhOyXkCBwb3NpdGlvbuydhCDsl4XrjbDsnbTtirjtlanri4jri6RcclxuICAgKiBAcGFyYW0ge251bWJlcn0gcHJvZ3Jlc3NJblBhbmVsIFByZXZpb3VzIGNhbWVyYSdzIHByb2dyZXNzIGluIGFjdGl2ZSBwYW5lbCBiZWZvcmUgcmVzaXplPGtvPlJlc2l6ZSDsnbTsoIQg7ZiE7J6sIOyEoO2DneuQnCDtjKjrhJAg64K07JeQ7ISc7J2YIOy5tOuplOudvCBwcm9ncmVzcyDqsJI8L2tvPlxyXG4gICAqIEB0aHJvd3Mge0ZsaWNraW5nRXJyb3J9XHJcbiAgICoge0BsaW5rIEVSUk9SX0NPREUgTk9UX0FUVEFDSEVEX1RPX0ZMSUNLSU5HfSBXaGVuIHtAbGluayBDYW1lcmEjaW5pdCBpbml0fSBpcyBub3QgY2FsbGVkIGJlZm9yZVxyXG4gICAqIDxrbz57QGxpbmsgRVJST1JfQ09ERSBOT1RfQVRUQUNIRURfVE9fRkxJQ0tJTkd9IHtAbGluayBDYW1lcmEjaW5pdCBpbml0feydtCDsnbTsoITsl5Ag7Zi47Lac65CY7KeAIOyViuydgCDqsr3smrA8L2tvPlxyXG4gICAqIEBjaGFpbmFibGVcclxuICAgKiBAcmV0dXJuIHtQcm9taXNlPHZvaWQ+fVxyXG4gICAqL1xuICBfX3Byb3RvLnVwZGF0ZVBvc2l0aW9uID0gZnVuY3Rpb24gKHByb2dyZXNzSW5QYW5lbCkge1xuICAgIHZhciBmbGlja2luZyA9IGdldEZsaWNraW5nQXR0YWNoZWQodGhpcy5fZmxpY2tpbmcpO1xuICAgIHZhciBjYW1lcmEgPSBmbGlja2luZy5jYW1lcmE7XG4gICAgdmFyIGFjdGl2ZVBhbmVsID0gdGhpcy5fYWN0aXZlUGFuZWw7XG4gICAgaWYgKGFjdGl2ZVBhbmVsKSB7XG4gICAgICBjYW1lcmEubG9va0F0KGNhbWVyYS5jbGFtcFRvUmVhY2hhYmxlUG9zaXRpb24oYWN0aXZlUGFuZWwucG9zaXRpb24pKTtcbiAgICB9XG4gIH07XG4gIC8qKlxyXG4gICAqIFVwZGF0ZSB7QGxpbmsgQ29udHJvbCNjb250cm9sbGVyIGNvbnRyb2xsZXJ9J3Mgc3RhdGVcclxuICAgKiBAa28ge0BsaW5rIENvbnRyb2wjY29udHJvbGxlciBjb250cm9sbGVyfeydmCDrgrTrtoAg7IOB7YOc66W8IOqwseyLoO2VqeuLiOuLpFxyXG4gICAqIEBjaGFpbmFibGVcclxuICAgKiBAcmV0dXJuIHt0aGlzfVxyXG4gICAqL1xuICBfX3Byb3RvLnVwZGF0ZUlucHV0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBmbGlja2luZyA9IGdldEZsaWNraW5nQXR0YWNoZWQodGhpcy5fZmxpY2tpbmcpO1xuICAgIHZhciBjYW1lcmEgPSBmbGlja2luZy5jYW1lcmE7XG4gICAgdGhpcy5fY29udHJvbGxlci51cGRhdGUoY2FtZXJhLmNvbnRyb2xQYXJhbXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcclxuICAgKiBSZXNldCB7QGxpbmsgQ29udHJvbCNhY3RpdmVQYW5lbCBhY3RpdmVQYW5lbH0gdG8gYG51bGxgXHJcbiAgICogQGtvIHtAbGluayBDb250cm9sI2FjdGl2ZVBhbmVsIGFjdGl2ZVBhbmVsfeydhCBgbnVsbGDroZwg7LSI6riw7ZmU7ZWp64uI64ukXHJcbiAgICogQGNoYWluYWJsZVxyXG4gICAqIEByZXR1cm4ge3RoaXN9XHJcbiAgICovXG4gIF9fcHJvdG8ucmVzZXRBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fYWN0aXZlUGFuZWwgPSBudWxsO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcclxuICAgKiBNb3ZlIHtAbGluayBDYW1lcmF9IHRvIHRoZSBnaXZlbiBwYW5lbFxyXG4gICAqIEBrbyB7QGxpbmsgQ2FtZXJhfeulvCDtlbTri7kg7Yyo64SQIOychOuhnCDsnbTrj5ntlanri4jri6RcclxuICAgKiBAcGFyYW0ge1BhbmVsfSBwYW5lbCBUaGUgdGFyZ2V0IHBhbmVsIHRvIG1vdmU8a28+7J2064+Z7ZWgIO2MqOuEkDwva28+XHJcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgQW4gb3B0aW9ucyBvYmplY3Q8a28+7Ji17IWYIOyYpOu4jOygne2KuDwva28+XHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGR1cmF0aW9uIER1cmF0aW9uIG9mIHRoZSBhbmltYXRpb24gKHVuaXQ6IG1zKTxrbz7slaDri4jrqZTsnbTshZgg7KeE7ZaJIOyLnOqwhCAo64uo7JyEOiBtcyk8L2tvPlxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbYXhlc0V2ZW50XSB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1heGVzL3JlbGVhc2UvbGF0ZXN0L2RvYy9lZy5BeGVzLmh0bWwjZXZlbnQ6cmVsZWFzZSByZWxlYXNlfSBldmVudCBvZiB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1heGVzLyBBeGVzfVxyXG4gICAqIDxrbz57QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1heGVzLyBBeGVzfeydmCB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1heGVzL3JlbGVhc2UvbGF0ZXN0L2RvYy9lZy5BeGVzLmh0bWwjZXZlbnQ6cmVsZWFzZSByZWxlYXNlfSDsnbTrsqTtirg8L2tvPlxyXG4gICAqIEBwYXJhbSB7RElSRUNUSU9OfSBbZGlyZWN0aW9uPURJUkVDVElPTi5OT05FXSBEaXJlY3Rpb24gdG8gbW92ZSwgb25seSBhdmFpbGFibGUgaW4gdGhlIHtAbGluayBGbGlja2luZyNjaXJjdWxhciBjaXJjdWxhcn0gbW9kZTxrbz7snbTrj5ntlaAg67Cp7ZalLiB7QGxpbmsgRmxpY2tpbmcjY2lyY3VsYXIgY2lyY3VsYXJ9IOyYteyFmCDtmZzshLHtmZTsi5zsl5Drp4wg7IKs7JqpIOqwgOuKpe2VqeuLiOuLpDwva28+XHJcbiAgICogQGZpcmVzIEZsaWNraW5nI21vdmVTdGFydFxyXG4gICAqIEBmaXJlcyBGbGlja2luZyNtb3ZlXHJcbiAgICogQGZpcmVzIEZsaWNraW5nI21vdmVFbmRcclxuICAgKiBAZmlyZXMgRmxpY2tpbmcjd2lsbENoYW5nZVxyXG4gICAqIEBmaXJlcyBGbGlja2luZyNjaGFuZ2VkXHJcbiAgICogQGZpcmVzIEZsaWNraW5nI3dpbGxSZXN0b3JlXHJcbiAgICogQGZpcmVzIEZsaWNraW5nI3Jlc3RvcmVkXHJcbiAgICogQGZpcmVzIEZsaWNraW5nI25lZWRQYW5lbFxyXG4gICAqIEBmaXJlcyBGbGlja2luZyN2aXNpYmxlQ2hhbmdlXHJcbiAgICogQGZpcmVzIEZsaWNraW5nI3JlYWNoRWRnZVxyXG4gICAqIEB0aHJvd3Mge0ZsaWNraW5nRXJyb3J9XHJcbiAgICogfGNvZGV8Y29uZGl0aW9ufFxyXG4gICAqIHwtLS18LS0tfFxyXG4gICAqIHx7QGxpbmsgRVJST1JfQ09ERSBQT1NJVElPTl9OT1RfUkVBQ0hBQkxFfXxXaGVuIHRoZSBnaXZlbiBwYW5lbCBpcyBhbHJlYWR5IHJlbW92ZWQgb3Igbm90IGluIHRoZSBDYW1lcmEncyB7QGxpbmsgQ2FtZXJhI3JhbmdlIHJhbmdlfXxcclxuICAgKiB8e0BsaW5rIEVSUk9SX0NPREUgTk9UX0FUVEFDSEVEX1RPX0ZMSUNLSU5HfXxXaGVuIHtAbGluayBDb250cm9sI2luaXQgaW5pdH0gaXMgbm90IGNhbGxlZCBiZWZvcmV8XHJcbiAgICogfHtAbGluayBFUlJPUl9DT0RFIEFOSU1BVElPTl9JTlRFUlJVUFRFRH18V2hlbiB0aGUgYW5pbWF0aW9uIGlzIGludGVycnVwdGVkIGJ5IHVzZXIgaW5wdXR8XHJcbiAgICogfHtAbGluayBFUlJPUl9DT0RFIFNUT1BfQ0FMTEVEX0JZX1VTRVJ9fFdoZW4gdGhlIGFuaW1hdGlvbiBpcyBpbnRlcnJ1cHRlZCBieSB1c2VyIGlucHV0fFxyXG4gICAqIDxrbz5cclxuICAgKlxyXG4gICAqIHxjb2RlfGNvbmRpdGlvbnxcclxuICAgKiB8LS0tfC0tLXxcclxuICAgKiB8e0BsaW5rIEVSUk9SX0NPREUgUE9TSVRJT05fTk9UX1JFQUNIQUJMRX187KO87Ja07KeEIO2MqOuEkOydtCDsoJzqsbDrkJjsl4jqsbDrgpgsIENhbWVyYeydmCB7QGxpbmsgQ2FtZXJhI3JhbmdlIHJhbmdlfSDrsJbsl5Ag7J6I7J2EIOqyveyasHxcclxuICAgKiB8e0BsaW5rIEVSUk9SX0NPREUgTk9UX0FUVEFDSEVEX1RPX0ZMSUNLSU5HfXx7QGxpbmsgQ29udHJvbCNpbml0IGluaXR97J20IOydtOyghOyXkCDtmLjstpzrkJjsp4Ag7JWK7J2AIOqyveyasHxcclxuICAgKiB8e0BsaW5rIEVSUk9SX0NPREUgQU5JTUFUSU9OX0lOVEVSUlVQVEVEfXzsgqzsmqnsnpAg7J6F66Cl7JeQIOydmO2VtCDslaDri4jrqZTsnbTshZjsnbQg7KSR64uo65CcIOqyveyasHxcclxuICAgKiB8e0BsaW5rIEVSUk9SX0NPREUgU1RPUF9DQUxMRURfQllfVVNFUn1867Cc7IOd65CcIOydtOuypO2KuOuTpCDspJEg7ZWY64KY652864+EIGBzdG9wKClg7J20IO2YuOy2nOuQnCDqsr3smrB8XHJcbiAgICpcclxuICAgKiA8L2tvPlxyXG4gICAqIEByZXR1cm4ge1Byb21pc2U8dm9pZD59IEEgUHJvbWlzZSB3aGljaCB3aWxsIGJlIHJlc29sdmVkIGFmdGVyIHJlYWNoaW5nIHRoZSB0YXJnZXQgcGFuZWw8a28+7ZW064u5IO2MqOuEkCDrj4Tri6zsi5zsl5AgcmVzb2x2ZeuQmOuKlCBQcm9taXNlPC9rbz5cclxuICAgKi9cbiAgX19wcm90by5tb3ZlVG9QYW5lbCA9IGZ1bmN0aW9uIChwYW5lbCwgX2EpIHtcbiAgICB2YXIgZHVyYXRpb24gPSBfYS5kdXJhdGlvbixcbiAgICAgIF9iID0gX2EuZGlyZWN0aW9uLFxuICAgICAgZGlyZWN0aW9uID0gX2IgPT09IHZvaWQgMCA/IERJUkVDVElPTi5OT05FIDogX2IsXG4gICAgICBheGVzRXZlbnQgPSBfYS5heGVzRXZlbnQ7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBvc2l0aW9uO1xuICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYykge1xuICAgICAgICBwb3NpdGlvbiA9IHRoaXMuX2dldFBvc2l0aW9uKHBhbmVsLCBkaXJlY3Rpb24pO1xuICAgICAgICB0aGlzLl90cmlnZ2VySW5kZXhDaGFuZ2VFdmVudChwYW5lbCwgcGFuZWwucG9zaXRpb24sIGF4ZXNFdmVudCwgZGlyZWN0aW9uKTtcbiAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuX2FuaW1hdGVUb1Bvc2l0aW9uKHtcbiAgICAgICAgICBwb3NpdGlvbjogcG9zaXRpb24sXG4gICAgICAgICAgZHVyYXRpb246IGR1cmF0aW9uLFxuICAgICAgICAgIG5ld0FjdGl2ZVBhbmVsOiBwYW5lbCxcbiAgICAgICAgICBheGVzRXZlbnQ6IGF4ZXNFdmVudFxuICAgICAgICB9KV07XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbiAgLyoqXHJcbiAgICogQGludGVybmFsXHJcbiAgICovXG4gIF9fcHJvdG8uc2V0QWN0aXZlID0gZnVuY3Rpb24gKG5ld0FjdGl2ZVBhbmVsLCBwcmV2QWN0aXZlUGFuZWwsIGlzVHJ1c3RlZCkge1xuICAgIHZhciBfYTtcbiAgICB2YXIgZmxpY2tpbmcgPSBnZXRGbGlja2luZ0F0dGFjaGVkKHRoaXMuX2ZsaWNraW5nKTtcbiAgICB0aGlzLl9hY3RpdmVQYW5lbCA9IG5ld0FjdGl2ZVBhbmVsO1xuICAgIHRoaXMuX25leHRQYW5lbCA9IG51bGw7XG4gICAgZmxpY2tpbmcuY2FtZXJhLnVwZGF0ZUFkYXB0aXZlSGVpZ2h0KCk7XG4gICAgaWYgKG5ld0FjdGl2ZVBhbmVsICE9PSBwcmV2QWN0aXZlUGFuZWwpIHtcbiAgICAgIGZsaWNraW5nLnRyaWdnZXIobmV3IENvbXBvbmVudEV2ZW50JDEoRVZFTlRTLkNIQU5HRUQsIHtcbiAgICAgICAgaW5kZXg6IG5ld0FjdGl2ZVBhbmVsLmluZGV4LFxuICAgICAgICBwYW5lbDogbmV3QWN0aXZlUGFuZWwsXG4gICAgICAgIHByZXZJbmRleDogKF9hID0gcHJldkFjdGl2ZVBhbmVsID09PSBudWxsIHx8IHByZXZBY3RpdmVQYW5lbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJldkFjdGl2ZVBhbmVsLmluZGV4KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAtMSxcbiAgICAgICAgcHJldlBhbmVsOiBwcmV2QWN0aXZlUGFuZWwsXG4gICAgICAgIGlzVHJ1c3RlZDogaXNUcnVzdGVkLFxuICAgICAgICBkaXJlY3Rpb246IHByZXZBY3RpdmVQYW5lbCA/IGdldERpcmVjdGlvbiQxKHByZXZBY3RpdmVQYW5lbC5wb3NpdGlvbiwgbmV3QWN0aXZlUGFuZWwucG9zaXRpb24pIDogRElSRUNUSU9OLk5PTkVcbiAgICAgIH0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmxpY2tpbmcudHJpZ2dlcihuZXcgQ29tcG9uZW50RXZlbnQkMShFVkVOVFMuUkVTVE9SRUQsIHtcbiAgICAgICAgaXNUcnVzdGVkOiBpc1RydXN0ZWRcbiAgICAgIH0pKTtcbiAgICB9XG4gIH07XG4gIC8qKlxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqL1xuICBfX3Byb3RvLmNvcHkgPSBmdW5jdGlvbiAoY29udHJvbCkge1xuICAgIHRoaXMuX2ZsaWNraW5nID0gY29udHJvbC5fZmxpY2tpbmc7XG4gICAgdGhpcy5fYWN0aXZlUGFuZWwgPSBjb250cm9sLl9hY3RpdmVQYW5lbDtcbiAgICB0aGlzLl9jb250cm9sbGVyID0gY29udHJvbC5fY29udHJvbGxlcjtcbiAgfTtcbiAgX19wcm90by5fdHJpZ2dlckluZGV4Q2hhbmdlRXZlbnQgPSBmdW5jdGlvbiAocGFuZWwsIHBvc2l0aW9uLCBheGVzRXZlbnQsIGRpcmVjdGlvbikge1xuICAgIHZhciBfYTtcbiAgICB2YXIgZmxpY2tpbmcgPSBnZXRGbGlja2luZ0F0dGFjaGVkKHRoaXMuX2ZsaWNraW5nKTtcbiAgICB2YXIgdHJpZ2dlcmluZ0V2ZW50ID0gcGFuZWwgIT09IHRoaXMuX2FjdGl2ZVBhbmVsID8gRVZFTlRTLldJTExfQ0hBTkdFIDogRVZFTlRTLldJTExfUkVTVE9SRTtcbiAgICB2YXIgY2FtZXJhID0gZmxpY2tpbmcuY2FtZXJhO1xuICAgIHZhciBhY3RpdmVQYW5lbCA9IHRoaXMuX2FjdGl2ZVBhbmVsO1xuICAgIHZhciBldmVudCA9IG5ldyBDb21wb25lbnRFdmVudCQxKHRyaWdnZXJpbmdFdmVudCwge1xuICAgICAgaW5kZXg6IHBhbmVsLmluZGV4LFxuICAgICAgcGFuZWw6IHBhbmVsLFxuICAgICAgaXNUcnVzdGVkOiAoYXhlc0V2ZW50ID09PSBudWxsIHx8IGF4ZXNFdmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogYXhlc0V2ZW50LmlzVHJ1c3RlZCkgfHwgZmFsc2UsXG4gICAgICBkaXJlY3Rpb246IGRpcmVjdGlvbiAhPT0gbnVsbCAmJiBkaXJlY3Rpb24gIT09IHZvaWQgMCA/IGRpcmVjdGlvbiA6IGdldERpcmVjdGlvbiQxKChfYSA9IGFjdGl2ZVBhbmVsID09PSBudWxsIHx8IGFjdGl2ZVBhbmVsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhY3RpdmVQYW5lbC5wb3NpdGlvbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY2FtZXJhLnBvc2l0aW9uLCBwb3NpdGlvbilcbiAgICB9KTtcbiAgICB0aGlzLl9uZXh0UGFuZWwgPSBwYW5lbDtcbiAgICBmbGlja2luZy50cmlnZ2VyKGV2ZW50KTtcbiAgICBpZiAoZXZlbnQuaXNDYW5jZWxlZCgpKSB7XG4gICAgICB0aHJvdyBuZXcgRmxpY2tpbmdFcnJvcihNRVNTQUdFLlNUT1BfQ0FMTEVEX0JZX1VTRVIsIENPREUuU1RPUF9DQUxMRURfQllfVVNFUik7XG4gICAgfVxuICB9O1xuICBfX3Byb3RvLl9hbmltYXRlVG9Qb3NpdGlvbiA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBwb3NpdGlvbiA9IF9hLnBvc2l0aW9uLFxuICAgICAgZHVyYXRpb24gPSBfYS5kdXJhdGlvbixcbiAgICAgIG5ld0FjdGl2ZVBhbmVsID0gX2EubmV3QWN0aXZlUGFuZWwsXG4gICAgICBheGVzRXZlbnQgPSBfYS5heGVzRXZlbnQ7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGZsaWNraW5nLCBhbmltYXRlLCBzdGF0ZTtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgIGZsaWNraW5nID0gZ2V0RmxpY2tpbmdBdHRhY2hlZCh0aGlzLl9mbGlja2luZyk7XG4gICAgICAgIGFuaW1hdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLl9jb250cm9sbGVyLmFuaW1hdGVUbyhwb3NpdGlvbiwgZHVyYXRpb24sIGF4ZXNFdmVudCk7XG4gICAgICAgIH07XG4gICAgICAgIHN0YXRlID0gdGhpcy5fY29udHJvbGxlci5zdGF0ZTtcbiAgICAgICAgc3RhdGUudGFyZ2V0UGFuZWwgPSBuZXdBY3RpdmVQYW5lbDtcbiAgICAgICAgaWYgKGR1cmF0aW9uIDw9IDApIHtcbiAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgYW5pbWF0ZSgpXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgYW5pbWF0ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZmxpY2tpbmcucmVuZGVyZXIucmVuZGVyKCldO1xuICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgaWYgKGF4ZXNFdmVudCAmJiBlcnIgaW5zdGFuY2VvZiBGbGlja2luZ0Vycm9yICYmIGVyci5jb2RlID09PSBDT0RFLkFOSU1BVElPTl9JTlRFUlJVUFRFRCkgcmV0dXJuO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH0pXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgX19wcm90by5fZ2V0UG9zaXRpb24gPSBmdW5jdGlvbiAocGFuZWwsIGRpcmVjdGlvbikge1xuICAgIGlmIChkaXJlY3Rpb24gPT09IHZvaWQgMCkge1xuICAgICAgZGlyZWN0aW9uID0gRElSRUNUSU9OLk5PTkU7XG4gICAgfVxuICAgIHZhciBmbGlja2luZyA9IGdldEZsaWNraW5nQXR0YWNoZWQodGhpcy5fZmxpY2tpbmcpO1xuICAgIHZhciBjYW1lcmEgPSBmbGlja2luZy5jYW1lcmE7XG4gICAgdmFyIHBvc2l0aW9uID0gcGFuZWwucG9zaXRpb247XG4gICAgdmFyIG5lYXJlc3RBbmNob3IgPSBjYW1lcmEuZmluZE5lYXJlc3RBbmNob3IocG9zaXRpb24pO1xuICAgIGlmIChwYW5lbC5yZW1vdmVkIHx8ICFuZWFyZXN0QW5jaG9yKSB7XG4gICAgICB0aHJvdyBuZXcgRmxpY2tpbmdFcnJvcihNRVNTQUdFLlBPU0lUSU9OX05PVF9SRUFDSEFCTEUocGFuZWwucG9zaXRpb24pLCBDT0RFLlBPU0lUSU9OX05PVF9SRUFDSEFCTEUpO1xuICAgIH1cbiAgICBpZiAoIWNhbWVyYS5jYW5SZWFjaChwYW5lbCkpIHtcbiAgICAgIC8vIE92ZXJyaWRlIHBvc2l0aW9uICYgcGFuZWwgaWYgdGhhdCBwYW5lbCBpcyBub3QgcmVhY2hhYmxlXG4gICAgICBwb3NpdGlvbiA9IG5lYXJlc3RBbmNob3IucG9zaXRpb247XG4gICAgICBwYW5lbCA9IG5lYXJlc3RBbmNob3IucGFuZWw7XG4gICAgfSBlbHNlIGlmIChmbGlja2luZy5jaXJjdWxhckVuYWJsZWQpIHtcbiAgICAgIC8vIENpcmN1bGFyIG1vZGUgaXMgZW5hYmxlZCwgZmluZCBuZWFyZXN0IGRpc3RhbmNlIHRvIHBhbmVsXG4gICAgICB2YXIgY2FtUG9zXzEgPSB0aGlzLl9jb250cm9sbGVyLnBvc2l0aW9uOyAvLyBBY3R1YWwgcG9zaXRpb24gb2YgdGhlIEF4ZXNcbiAgICAgIHZhciBjYW1SYW5nZURpZmYgPSBjYW1lcmEucmFuZ2VEaWZmO1xuICAgICAgdmFyIHBvc3NpYmxlUG9zaXRpb25zID0gW3Bvc2l0aW9uLCBwb3NpdGlvbiArIGNhbVJhbmdlRGlmZiwgcG9zaXRpb24gLSBjYW1SYW5nZURpZmZdLmZpbHRlcihmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgIGlmIChkaXJlY3Rpb24gPT09IERJUkVDVElPTi5OT05FKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGRpcmVjdGlvbiA9PT0gRElSRUNUSU9OLlBSRVYgPyBwb3MgPD0gY2FtUG9zXzEgOiBwb3MgPj0gY2FtUG9zXzE7XG4gICAgICB9KTtcbiAgICAgIHBvc2l0aW9uID0gcG9zc2libGVQb3NpdGlvbnMucmVkdWNlKGZ1bmN0aW9uIChuZWFyZXN0UG9zaXRpb24sIHBvcykge1xuICAgICAgICBpZiAoTWF0aC5hYnMoY2FtUG9zXzEgLSBwb3MpIDwgTWF0aC5hYnMoY2FtUG9zXzEgLSBuZWFyZXN0UG9zaXRpb24pKSB7XG4gICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbmVhcmVzdFBvc2l0aW9uO1xuICAgICAgICB9XG4gICAgICB9LCBJbmZpbml0eSk7XG4gICAgfVxuICAgIHJldHVybiBwb3NpdGlvbjtcbiAgfTtcbiAgcmV0dXJuIENvbnRyb2w7XG59KCk7XG5cbi8qKlxyXG4gKiBBIGRhdGEgY29tcG9uZW50IHRoYXQgaGFzIGFjdHVhbCBwb3NpdGlvbiB3aGVyZSB0aGUgY2FtZXJhIHNob3VsZCBiZSBzdG9wcGVkIGF0XHJcbiAqIEBrbyDsubTrqZTrnbzqsIAg7KCV7KeA7ZW07JW87ZWY64qUIOyLpOygnCDsnITsuZjrpbwg64u06rOgIOyeiOuKlCDrjbDsnbTthLAg7Lu07Y+s64SM7Yq4XHJcbiAqL1xudmFyIEFuY2hvclBvaW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgQW4gb3B0aW9ucyBvYmplY3Q8a28+7Ji17IWYIOqwneyytDwva28+XHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmluZGV4XSBJbmRleCBvZiBBbmNob3JQb2ludDxrbz5BbmNob3JQb2ludOydmCDsnbjrjbHsiqQ8L2tvPlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5wb3NpdGlvbl0gUG9zaXRpb24gb2YgQW5jaG9yUG9pbnQ8a28+QW5jaG9yUG9pbnTsnZgg7KKM7ZGcPC9rbz5cclxuICAgKiBAcGFyYW0ge1BhbmVsfSBbb3B0aW9ucy5wYW5lbF0gQSB7QGxpbmsgUGFuZWx9IGluc3RhbmNlIEFuY2hvclBvaW50IGlzIHJlZmVyZW5jaW5nIHRvPGtvPkFuY2hvclBvaW506rCAIOywuOyhsO2VmOqzoCDsnojripQge0BsaW5rIFBhbmVsfTwva28+XHJcbiAgICovXG4gIGZ1bmN0aW9uIEFuY2hvclBvaW50KF9hKSB7XG4gICAgdmFyIGluZGV4ID0gX2EuaW5kZXgsXG4gICAgICBwb3NpdGlvbiA9IF9hLnBvc2l0aW9uLFxuICAgICAgcGFuZWwgPSBfYS5wYW5lbDtcbiAgICB0aGlzLl9pbmRleCA9IGluZGV4O1xuICAgIHRoaXMuX3BvcyA9IHBvc2l0aW9uO1xuICAgIHRoaXMuX3BhbmVsID0gcGFuZWw7XG4gIH1cbiAgdmFyIF9fcHJvdG8gPSBBbmNob3JQb2ludC5wcm90b3R5cGU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcImluZGV4XCIsIHtcbiAgICAvKipcclxuICAgICAqIEluZGV4IG9mIEFuY2hvclBvaW50XHJcbiAgICAgKiBAa28gQW5jaG9yUG9pbnTsnZgg7J24642x7IqkXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pbmRleDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwicG9zaXRpb25cIiwge1xuICAgIC8qKlxyXG4gICAgICogUG9zaXRpb24gb2YgQW5jaG9yUG9pbnRcclxuICAgICAqIEBrbyBBbmNob3JQb2ludOydmCDsooztkZxcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3BvcztcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwicGFuZWxcIiwge1xuICAgIC8qKlxyXG4gICAgICogQSB7QGxpbmsgUGFuZWx9IGluc3RhbmNlIEFuY2hvclBvaW50IGlzIHJlZmVyZW5jaW5nIHRvXHJcbiAgICAgKiBAa28gQW5jaG9yUG9pbnTqsIAg7LC47KGw7ZWY6rOgIOyeiOuKlCB7QGxpbmsgUGFuZWx9XHJcbiAgICAgKiBAdHlwZSB7UGFuZWx9XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3BhbmVsO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICByZXR1cm4gQW5jaG9yUG9pbnQ7XG59KCk7XG5cbi8qKlxyXG4gKiBBIHtAbGluayBDb250cm9sfSB0aGF0IHVzZXMgYSByZWxlYXNlIG1vbWVudHVtIHRvIGNob29zZSBkZXN0aW5hdGlvbiBwYW5lbFxyXG4gKiBAa28g7J6F66Cl7J2EIOykkeuLqO2VnCDsi5zsoJDsnZgg6rCA7IaN64+E7JeQIOyYge2Wpeuwm+yVhCDrj4Tri6ztlaAg7Yyo64SQ7J2EIOqzhOyCsO2VmOuKlCDsnbTrj5kg67Cp7Iud7J2EIOyCrOyaqe2VmOuKlCB7QGxpbmsgQ29udHJvbH1cclxuICovXG52YXIgU25hcENvbnRyb2wgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMkMyhTbmFwQ29udHJvbCwgX3N1cGVyKTtcbiAgLyoqICovXG4gIGZ1bmN0aW9uIFNuYXBDb250cm9sKF9hKSB7XG4gICAgdmFyIF9iID0gKF9hID09PSB2b2lkIDAgPyB7fSA6IF9hKS5jb3VudCxcbiAgICAgIGNvdW50ID0gX2IgPT09IHZvaWQgMCA/IEluZmluaXR5IDogX2I7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICBfdGhpcy5fY291bnQgPSBjb3VudDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgdmFyIF9fcHJvdG8gPSBTbmFwQ29udHJvbC5wcm90b3R5cGU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcImNvdW50XCIsIHtcbiAgICAvKipcclxuICAgICAqIE1heGltdW0gbnVtYmVyIG9mIHBhbmVscyBjYW4gZ28gYWZ0ZXIgcmVsZWFzZVxyXG4gICAgICogQGtvIOyeheugpSDspJHri6gg7J207ZuEIO2GteqzvO2VmOyXrCDsnbTrj5ntlaAg7IiYIOyeiOuKlCDtjKjrhJDsnZgg7LWc64yAIOqwr+yImFxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IEluZmluaXR5XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jb3VudDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgdGhpcy5fY291bnQgPSB2YWw7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIC8qKlxyXG4gICAqIE1vdmUge0BsaW5rIENhbWVyYX0gdG8gdGhlIGdpdmVuIHBvc2l0aW9uXHJcbiAgICogQGtvIHtAbGluayBDYW1lcmF966W8IOyjvOyWtOynhCDsooztkZzroZwg7J2064+Z7ZWp64uI64ukXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHBvc2l0aW9uIFRoZSB0YXJnZXQgcG9zaXRpb24gdG8gbW92ZTxrbz7snbTrj5ntlaAg7KKM7ZGcPC9rbz5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gZHVyYXRpb24gRHVyYXRpb24gb2YgdGhlIHBhbmVsIG1vdmVtZW50IGFuaW1hdGlvbiAodW5pdDogbXMpLjxrbz7tjKjrhJAg7J2064+ZIOyVoOuLiOuplOydtOyFmCDsp4Ttlokg7Iuc6rCEICjri6jsnIQ6IG1zKTwva28+XHJcbiAgICogQHBhcmFtIHtvYmplY3R9IFtheGVzRXZlbnRdIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWF4ZXMvcmVsZWFzZS9sYXRlc3QvZG9jL2VnLkF4ZXMuaHRtbCNldmVudDpyZWxlYXNlIHJlbGVhc2V9IGV2ZW50IG9mIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWF4ZXMvIEF4ZXN9XHJcbiAgICogPGtvPntAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWF4ZXMvIEF4ZXN97J2YIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWF4ZXMvcmVsZWFzZS9sYXRlc3QvZG9jL2VnLkF4ZXMuaHRtbCNldmVudDpyZWxlYXNlIHJlbGVhc2V9IOydtOuypO2KuDwva28+XHJcbiAgICogQGZpcmVzIEZsaWNraW5nI21vdmVTdGFydFxyXG4gICAqIEBmaXJlcyBGbGlja2luZyNtb3ZlXHJcbiAgICogQGZpcmVzIEZsaWNraW5nI21vdmVFbmRcclxuICAgKiBAZmlyZXMgRmxpY2tpbmcjd2lsbENoYW5nZVxyXG4gICAqIEBmaXJlcyBGbGlja2luZyNjaGFuZ2VkXHJcbiAgICogQGZpcmVzIEZsaWNraW5nI3dpbGxSZXN0b3JlXHJcbiAgICogQGZpcmVzIEZsaWNraW5nI3Jlc3RvcmVkXHJcbiAgICogQGZpcmVzIEZsaWNraW5nI25lZWRQYW5lbFxyXG4gICAqIEBmaXJlcyBGbGlja2luZyN2aXNpYmxlQ2hhbmdlXHJcbiAgICogQGZpcmVzIEZsaWNraW5nI3JlYWNoRWRnZVxyXG4gICAqIEB0aHJvd3Mge0ZsaWNraW5nRXJyb3J9XHJcbiAgICogfGNvZGV8Y29uZGl0aW9ufFxyXG4gICAqIHwtLS18LS0tfFxyXG4gICAqIHx7QGxpbmsgRVJST1JfQ09ERSBQT1NJVElPTl9OT1RfUkVBQ0hBQkxFfXxXaGVuIHRoZSBnaXZlbiBwYW5lbCBpcyBhbHJlYWR5IHJlbW92ZWQgb3Igbm90IGluIHRoZSBDYW1lcmEncyB7QGxpbmsgQ2FtZXJhI3JhbmdlIHJhbmdlfXxcclxuICAgKiB8e0BsaW5rIEVSUk9SX0NPREUgTk9UX0FUVEFDSEVEX1RPX0ZMSUNLSU5HfXxXaGVuIHtAbGluayBDb250cm9sI2luaXQgaW5pdH0gaXMgbm90IGNhbGxlZCBiZWZvcmV8XHJcbiAgICogfHtAbGluayBFUlJPUl9DT0RFIEFOSU1BVElPTl9JTlRFUlJVUFRFRH18V2hlbiB0aGUgYW5pbWF0aW9uIGlzIGludGVycnVwdGVkIGJ5IHVzZXIgaW5wdXR8XHJcbiAgICogfHtAbGluayBFUlJPUl9DT0RFIFNUT1BfQ0FMTEVEX0JZX1VTRVJ9fFdoZW4gdGhlIGFuaW1hdGlvbiBpcyBpbnRlcnJ1cHRlZCBieSB1c2VyIGlucHV0fFxyXG4gICAqIDxrbz5cclxuICAgKlxyXG4gICAqIHxjb2RlfGNvbmRpdGlvbnxcclxuICAgKiB8LS0tfC0tLXxcclxuICAgKiB8e0BsaW5rIEVSUk9SX0NPREUgUE9TSVRJT05fTk9UX1JFQUNIQUJMRX187KO87Ja07KeEIO2MqOuEkOydtCDsoJzqsbDrkJjsl4jqsbDrgpgsIENhbWVyYeydmCB7QGxpbmsgQ2FtZXJhI3JhbmdlIHJhbmdlfSDrsJbsl5Ag7J6I7J2EIOqyveyasHxcclxuICAgKiB8e0BsaW5rIEVSUk9SX0NPREUgTk9UX0FUVEFDSEVEX1RPX0ZMSUNLSU5HfXx7QGxpbmsgQ29udHJvbCNpbml0IGluaXR97J20IOydtOyghOyXkCDtmLjstpzrkJjsp4Ag7JWK7J2AIOqyveyasHxcclxuICAgKiB8e0BsaW5rIEVSUk9SX0NPREUgQU5JTUFUSU9OX0lOVEVSUlVQVEVEfXzsgqzsmqnsnpAg7J6F66Cl7JeQIOydmO2VtCDslaDri4jrqZTsnbTshZjsnbQg7KSR64uo65CcIOqyveyasHxcclxuICAgKiB8e0BsaW5rIEVSUk9SX0NPREUgU1RPUF9DQUxMRURfQllfVVNFUn1867Cc7IOd65CcIOydtOuypO2KuOuTpCDspJEg7ZWY64KY652864+EIGBzdG9wKClg7J20IO2YuOy2nOuQnCDqsr3smrB8XHJcbiAgICpcclxuICAgKiA8L2tvPlxyXG4gICAqIEByZXR1cm4ge1Byb21pc2U8dm9pZD59IEEgUHJvbWlzZSB3aGljaCB3aWxsIGJlIHJlc29sdmVkIGFmdGVyIHJlYWNoaW5nIHRoZSB0YXJnZXQgcG9zaXRpb248a28+7ZW064u5IOyijO2RnCDrj4Tri6zsi5zsl5AgcmVzb2x2ZeuQmOuKlCBQcm9taXNlPC9rbz5cclxuICAgKi9cbiAgX19wcm90by5tb3ZlVG9Qb3NpdGlvbiA9IGZ1bmN0aW9uIChwb3NpdGlvbiwgZHVyYXRpb24sIGF4ZXNFdmVudCkge1xuICAgIHZhciBmbGlja2luZyA9IGdldEZsaWNraW5nQXR0YWNoZWQodGhpcy5fZmxpY2tpbmcpO1xuICAgIHZhciBjYW1lcmEgPSBmbGlja2luZy5jYW1lcmE7XG4gICAgdmFyIGFjdGl2ZUFuY2hvciA9IGNhbWVyYS5maW5kQWN0aXZlQW5jaG9yKCk7XG4gICAgdmFyIGFuY2hvckF0Q2FtZXJhID0gY2FtZXJhLmZpbmROZWFyZXN0QW5jaG9yKGNhbWVyYS5wb3NpdGlvbik7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5fY29udHJvbGxlci5zdGF0ZTtcbiAgICBpZiAoIWFjdGl2ZUFuY2hvciB8fCAhYW5jaG9yQXRDYW1lcmEpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRmxpY2tpbmdFcnJvcihNRVNTQUdFLlBPU0lUSU9OX05PVF9SRUFDSEFCTEUocG9zaXRpb24pLCBDT0RFLlBPU0lUSU9OX05PVF9SRUFDSEFCTEUpKTtcbiAgICB9XG4gICAgdmFyIHNuYXBUaHJlc2hvbGQgPSB0aGlzLl9jYWxjU25hcFRocmVzaG9sZChmbGlja2luZy50aHJlc2hvbGQsIHBvc2l0aW9uLCBhY3RpdmVBbmNob3IpO1xuICAgIHZhciBwb3NEZWx0YSA9IGZsaWNraW5nLmFuaW1hdGluZyA/IHN0YXRlLmRlbHRhIDogcG9zaXRpb24gLSBjYW1lcmEucG9zaXRpb247XG4gICAgdmFyIGFic1Bvc0RlbHRhID0gTWF0aC5hYnMocG9zRGVsdGEpO1xuICAgIHZhciBzbmFwRGVsdGEgPSBheGVzRXZlbnQgJiYgYXhlc0V2ZW50LmRlbHRhW1BPU0lUSU9OX0tFWV0gIT09IDAgPyBNYXRoLmFicyhheGVzRXZlbnQuZGVsdGFbUE9TSVRJT05fS0VZXSkgOiBhYnNQb3NEZWx0YTtcbiAgICB2YXIgdGFyZ2V0QW5jaG9yO1xuICAgIGlmIChzbmFwRGVsdGEgPj0gc25hcFRocmVzaG9sZCAmJiBzbmFwRGVsdGEgPiAwKSB7XG4gICAgICAvLyBNb3ZlIHRvIGFuY2hvciBhdCBwb3NpdGlvblxuICAgICAgdGFyZ2V0QW5jaG9yID0gdGhpcy5fZmluZFNuYXBwZWRBbmNob3IocG9zaXRpb24sIGFuY2hvckF0Q2FtZXJhKTtcbiAgICB9IGVsc2UgaWYgKGFic1Bvc0RlbHRhID49IGZsaWNraW5nLnRocmVzaG9sZCAmJiBhYnNQb3NEZWx0YSA+IDApIHtcbiAgICAgIC8vIE1vdmUgdG8gdGhlIGFkamFjZW50IHBhbmVsXG4gICAgICB0YXJnZXRBbmNob3IgPSB0aGlzLl9maW5kQWRqYWNlbnRBbmNob3IocG9zaXRpb24sIHBvc0RlbHRhLCBhbmNob3JBdENhbWVyYSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZhbGxiYWNrIHRvIG5lYXJlc3QgcGFuZWwgZnJvbSBjdXJyZW50IGNhbWVyYVxuICAgICAgcmV0dXJuIHRoaXMubW92ZVRvUGFuZWwoYW5jaG9yQXRDYW1lcmEucGFuZWwsIHtcbiAgICAgICAgZHVyYXRpb246IGR1cmF0aW9uLFxuICAgICAgICBheGVzRXZlbnQ6IGF4ZXNFdmVudFxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuX3RyaWdnZXJJbmRleENoYW5nZUV2ZW50KHRhcmdldEFuY2hvci5wYW5lbCwgcG9zaXRpb24sIGF4ZXNFdmVudCk7XG4gICAgcmV0dXJuIHRoaXMuX2FuaW1hdGVUb1Bvc2l0aW9uKHtcbiAgICAgIHBvc2l0aW9uOiBjYW1lcmEuY2xhbXBUb1JlYWNoYWJsZVBvc2l0aW9uKHRhcmdldEFuY2hvci5wb3NpdGlvbiksXG4gICAgICBkdXJhdGlvbjogZHVyYXRpb24sXG4gICAgICBuZXdBY3RpdmVQYW5lbDogdGFyZ2V0QW5jaG9yLnBhbmVsLFxuICAgICAgYXhlc0V2ZW50OiBheGVzRXZlbnRcbiAgICB9KTtcbiAgfTtcbiAgX19wcm90by5fZmluZFNuYXBwZWRBbmNob3IgPSBmdW5jdGlvbiAocG9zaXRpb24sIGFuY2hvckF0Q2FtZXJhKSB7XG4gICAgdmFyIGZsaWNraW5nID0gZ2V0RmxpY2tpbmdBdHRhY2hlZCh0aGlzLl9mbGlja2luZyk7XG4gICAgdmFyIGNhbWVyYSA9IGZsaWNraW5nLmNhbWVyYTtcbiAgICB2YXIgY291bnQgPSB0aGlzLl9jb3VudDtcbiAgICB2YXIgY3VycmVudFBvcyA9IGNhbWVyYS5wb3NpdGlvbjtcbiAgICB2YXIgY2xhbXBlZFBvc2l0aW9uID0gY2FtZXJhLmNsYW1wVG9SZWFjaGFibGVQb3NpdGlvbihwb3NpdGlvbik7XG4gICAgdmFyIGFuY2hvckF0UG9zaXRpb24gPSBjYW1lcmEuZmluZEFuY2hvckluY2x1ZGVQb3NpdGlvbihjbGFtcGVkUG9zaXRpb24pO1xuICAgIGlmICghYW5jaG9yQXRDYW1lcmEgfHwgIWFuY2hvckF0UG9zaXRpb24pIHtcbiAgICAgIHRocm93IG5ldyBGbGlja2luZ0Vycm9yKE1FU1NBR0UuUE9TSVRJT05fTk9UX1JFQUNIQUJMRShwb3NpdGlvbiksIENPREUuUE9TSVRJT05fTk9UX1JFQUNIQUJMRSk7XG4gICAgfVxuICAgIGlmICghaXNGaW5pdGUoY291bnQpKSB7XG4gICAgICByZXR1cm4gYW5jaG9yQXRQb3NpdGlvbjtcbiAgICB9XG4gICAgdmFyIHBhbmVsQ291bnQgPSBmbGlja2luZy5wYW5lbENvdW50O1xuICAgIHZhciBhbmNob3JzID0gY2FtZXJhLmFuY2hvclBvaW50cztcbiAgICB2YXIgbG9vcENvdW50ID0gTWF0aC5zaWduKHBvc2l0aW9uIC0gY3VycmVudFBvcykgKiBNYXRoLmZsb29yKE1hdGguYWJzKHBvc2l0aW9uIC0gY3VycmVudFBvcykgLyBjYW1lcmEucmFuZ2VEaWZmKTtcbiAgICBpZiAocG9zaXRpb24gPiBjdXJyZW50UG9zICYmIGFuY2hvckF0UG9zaXRpb24uaW5kZXggPCBhbmNob3JBdENhbWVyYS5pbmRleCB8fCBhbmNob3JBdFBvc2l0aW9uLnBvc2l0aW9uID4gYW5jaG9yQXRDYW1lcmEucG9zaXRpb24gJiYgYW5jaG9yQXRQb3NpdGlvbi5pbmRleCA9PT0gYW5jaG9yQXRDYW1lcmEuaW5kZXgpIHtcbiAgICAgIGxvb3BDb3VudCArPSAxO1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPCBjdXJyZW50UG9zICYmIGFuY2hvckF0UG9zaXRpb24uaW5kZXggPiBhbmNob3JBdENhbWVyYS5pbmRleCB8fCBhbmNob3JBdFBvc2l0aW9uLnBvc2l0aW9uIDwgYW5jaG9yQXRDYW1lcmEucG9zaXRpb24gJiYgYW5jaG9yQXRQb3NpdGlvbi5pbmRleCA9PT0gYW5jaG9yQXRDYW1lcmEuaW5kZXgpIHtcbiAgICAgIGxvb3BDb3VudCAtPSAxO1xuICAgIH1cbiAgICB2YXIgY2lyY3VsYXJJbmRleE9mZnNldCA9IGxvb3BDb3VudCAqIHBhbmVsQ291bnQ7XG4gICAgdmFyIGFuY2hvckF0UG9zaXRpb25JbmRleCA9IGFuY2hvckF0UG9zaXRpb24uaW5kZXggKyBjaXJjdWxhckluZGV4T2Zmc2V0O1xuICAgIGlmIChNYXRoLmFicyhhbmNob3JBdFBvc2l0aW9uSW5kZXggLSBhbmNob3JBdENhbWVyYS5pbmRleCkgPD0gY291bnQpIHtcbiAgICAgIHZhciBhbmNob3IgPSBhbmNob3JzW2FuY2hvckF0UG9zaXRpb24uaW5kZXhdO1xuICAgICAgcmV0dXJuIG5ldyBBbmNob3JQb2ludCh7XG4gICAgICAgIGluZGV4OiBhbmNob3IuaW5kZXgsXG4gICAgICAgIHBvc2l0aW9uOiBhbmNob3IucG9zaXRpb24gKyBsb29wQ291bnQgKiBjYW1lcmEucmFuZ2VEaWZmLFxuICAgICAgICBwYW5lbDogYW5jaG9yLnBhbmVsXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGZsaWNraW5nLmNpcmN1bGFyRW5hYmxlZCkge1xuICAgICAgdmFyIHRhcmdldEFuY2hvciA9IGFuY2hvcnNbY2lyY3VsYXRlSW5kZXgoYW5jaG9yQXRDYW1lcmEuaW5kZXggKyBNYXRoLnNpZ24ocG9zaXRpb24gLSBjdXJyZW50UG9zKSAqIGNvdW50LCBwYW5lbENvdW50KV07XG4gICAgICB2YXIgbG9vcCA9IE1hdGguZmxvb3IoY291bnQgLyBwYW5lbENvdW50KTtcbiAgICAgIGlmIChwb3NpdGlvbiA+IGN1cnJlbnRQb3MgJiYgdGFyZ2V0QW5jaG9yLmluZGV4IDwgYW5jaG9yQXRDYW1lcmEuaW5kZXgpIHtcbiAgICAgICAgbG9vcCArPSAxO1xuICAgICAgfSBlbHNlIGlmIChwb3NpdGlvbiA8IGN1cnJlbnRQb3MgJiYgdGFyZ2V0QW5jaG9yLmluZGV4ID4gYW5jaG9yQXRDYW1lcmEuaW5kZXgpIHtcbiAgICAgICAgbG9vcCAtPSAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBBbmNob3JQb2ludCh7XG4gICAgICAgIGluZGV4OiB0YXJnZXRBbmNob3IuaW5kZXgsXG4gICAgICAgIHBvc2l0aW9uOiB0YXJnZXRBbmNob3IucG9zaXRpb24gKyBsb29wICogY2FtZXJhLnJhbmdlRGlmZixcbiAgICAgICAgcGFuZWw6IHRhcmdldEFuY2hvci5wYW5lbFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBhbmNob3JzW2NsYW1wJDEoYW5jaG9yQXRDYW1lcmEuaW5kZXggKyBNYXRoLnNpZ24ocG9zaXRpb24gLSBjdXJyZW50UG9zKSAqIGNvdW50LCAwLCBhbmNob3JzLmxlbmd0aCAtIDEpXTtcbiAgICB9XG4gIH07XG4gIF9fcHJvdG8uX2ZpbmRBZGphY2VudEFuY2hvciA9IGZ1bmN0aW9uIChwb3NpdGlvbiwgcG9zRGVsdGEsIGFuY2hvckF0Q2FtZXJhKSB7XG4gICAgdmFyIF9hO1xuICAgIHZhciBmbGlja2luZyA9IGdldEZsaWNraW5nQXR0YWNoZWQodGhpcy5fZmxpY2tpbmcpO1xuICAgIHZhciBjYW1lcmEgPSBmbGlja2luZy5jYW1lcmE7XG4gICAgaWYgKGNhbWVyYS5jaXJjdWxhckVuYWJsZWQpIHtcbiAgICAgIHZhciBhbmNob3JJbmNsdWRlUG9zaXRpb24gPSBjYW1lcmEuZmluZEFuY2hvckluY2x1ZGVQb3NpdGlvbihwb3NpdGlvbik7XG4gICAgICBpZiAoYW5jaG9ySW5jbHVkZVBvc2l0aW9uICYmIGFuY2hvckluY2x1ZGVQb3NpdGlvbi5wb3NpdGlvbiAhPT0gYW5jaG9yQXRDYW1lcmEucG9zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGFuY2hvckluY2x1ZGVQb3NpdGlvbjtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGFkamFjZW50QW5jaG9yID0gKF9hID0gcG9zRGVsdGEgPiAwID8gY2FtZXJhLmdldE5leHRBbmNob3IoYW5jaG9yQXRDYW1lcmEpIDogY2FtZXJhLmdldFByZXZBbmNob3IoYW5jaG9yQXRDYW1lcmEpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBhbmNob3JBdENhbWVyYTtcbiAgICByZXR1cm4gYWRqYWNlbnRBbmNob3I7XG4gIH07XG4gIF9fcHJvdG8uX2NhbGNTbmFwVGhyZXNob2xkID0gZnVuY3Rpb24gKHRocmVzaG9sZCwgcG9zaXRpb24sIGFjdGl2ZUFuY2hvcikge1xuICAgIHZhciBpc05leHREaXJlY3Rpb24gPSBwb3NpdGlvbiA+IGFjdGl2ZUFuY2hvci5wb3NpdGlvbjtcbiAgICB2YXIgcGFuZWwgPSBhY3RpdmVBbmNob3IucGFuZWw7XG4gICAgdmFyIHBhbmVsU2l6ZSA9IHBhbmVsLnNpemU7XG4gICAgdmFyIGFsaWduUG9zID0gcGFuZWwuYWxpZ25Qb3NpdGlvbjtcbiAgICAvLyBNaW5pbXVtIGRpc3RhbmNlIG5lZWRlZCB0byBkZWNpZGUgcHJldi9uZXh0IHBhbmVsIGFzIG5lYXJlc3RcbiAgICAvKlxyXG4gICAgICogfCAgUHJldiAgfCAgICAgTmV4dCAgICAgfFxyXG4gICAgICogfDwtLS0tLS0+fDwtLS0tLS0tLS0tLS0+fFxyXG4gICAgICogWyAgICAgICAgfDwtQW5jaG9yICAgICAgXVxyXG4gICAgICovXG4gICAgcmV0dXJuIE1hdGgubWF4KHRocmVzaG9sZCwgaXNOZXh0RGlyZWN0aW9uID8gcGFuZWxTaXplIC0gYWxpZ25Qb3MgKyBwYW5lbC5tYXJnaW4ubmV4dCA6IGFsaWduUG9zICsgcGFuZWwubWFyZ2luLnByZXYpO1xuICB9O1xuICByZXR1cm4gU25hcENvbnRyb2w7XG59KENvbnRyb2wpO1xuXG4vKipcclxuICogQSB7QGxpbmsgQ29udHJvbH0gdGhhdCBjYW4gYmUgc2Nyb2xsZWQgZnJlZWx5IHdpdGhvdXQgYWxpZ25tZW50XHJcbiAqIEBrbyDtjKjrhJDsnbQg7KCV7ZW07KeEIOyngOygkOyXkCDsoJXroKzrkJjsp4Ag7JWK6rOgLCDsnpDsnKDroa3qsowg7Iqk7YGs66Gk7ZWgIOyImCDsnojripQg7J2064+ZIOuwqeyLneydhCDsgqzsmqntlZjripQge0BsaW5rIENvbnRyb2x9XHJcbiAqL1xudmFyIEZyZWVDb250cm9sID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzJDMoRnJlZUNvbnRyb2wsIF9zdXBlcik7XG4gIC8qKiAqL1xuICBmdW5jdGlvbiBGcmVlQ29udHJvbChfYSkge1xuICAgIHZhciBfYiA9IChfYSA9PT0gdm9pZCAwID8ge30gOiBfYSkuc3RvcEF0RWRnZSxcbiAgICAgIHN0b3BBdEVkZ2UgPSBfYiA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9iO1xuICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgX3RoaXMuX3N0b3BBdEVkZ2UgPSBzdG9wQXRFZGdlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICB2YXIgX19wcm90byA9IEZyZWVDb250cm9sLnByb3RvdHlwZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwic3RvcEF0RWRnZVwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBNYWtlIHNjcm9sbCBhbmltYXRpb24gdG8gc3RvcCBhdCB0aGUgc3RhcnQvZW5kIG9mIHRoZSBzY3JvbGwgYXJlYSwgbm90IGdvaW5nIG91dCB0aGUgYm91bmNlIGFyZWFcclxuICAgICAqIEBrbyDsiqTtgazroaQg7JWg64uI66mU7J207IWY7J2EIOyKpO2BrOuhpCDsmIHsl63snZgg7Iuc7J6R6rO8IOuBneu2gOu2hOyXkOyEnCDrqYjstpTrj4TroZ0g7ZWY7JesLCDrsJTsmrTsiqQg7JiB7Jet7J2EIOuEmOyWtOqwgOyngCDslYrrj4TroZ0g7ZWp64uI64ukXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqIEBkZWZhdWx0IHRydWVcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N0b3BBdEVkZ2U7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHRoaXMuX3N0b3BBdEVkZ2UgPSB2YWw7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIC8qKlxyXG4gICAqIFVwZGF0ZSBwb3NpdGlvbiBhZnRlciByZXNpemluZ1xyXG4gICAqIEBrbyByZXNpemUg7J207ZuE7JeQIHBvc2l0aW9u7J2EIOyXheuNsOydtO2KuO2VqeuLiOuLpFxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwcm9ncmVzc0luUGFuZWwgUHJldmlvdXMgY2FtZXJhJ3MgcHJvZ3Jlc3MgaW4gYWN0aXZlIHBhbmVsIGJlZm9yZSByZXNpemU8a28+UmVzaXplIOydtOyghCDtmITsnqwg7ISg7YOd65CcIO2MqOuEkCDrgrTsl5DshJzsnZgg7Lm066mU6528IHByb2dyZXNzIOqwkjwva28+XHJcbiAgICogQHRocm93cyB7RmxpY2tpbmdFcnJvcn1cclxuICAgKiB7QGxpbmsgRVJST1JfQ09ERSBOT1RfQVRUQUNIRURfVE9fRkxJQ0tJTkd9IFdoZW4ge0BsaW5rIENhbWVyYSNpbml0IGluaXR9IGlzIG5vdCBjYWxsZWQgYmVmb3JlXHJcbiAgICogPGtvPntAbGluayBFUlJPUl9DT0RFIE5PVF9BVFRBQ0hFRF9UT19GTElDS0lOR30ge0BsaW5rIENhbWVyYSNpbml0IGluaXR97J20IOydtOyghOyXkCDtmLjstpzrkJjsp4Ag7JWK7J2AIOqyveyasDwva28+XHJcbiAgICogQGNoYWluYWJsZVxyXG4gICAqIEByZXR1cm4ge1Byb21pc2U8dm9pZD59XHJcbiAgICovXG4gIF9fcHJvdG8udXBkYXRlUG9zaXRpb24gPSBmdW5jdGlvbiAocHJvZ3Jlc3NJblBhbmVsKSB7XG4gICAgdmFyIGZsaWNraW5nID0gZ2V0RmxpY2tpbmdBdHRhY2hlZCh0aGlzLl9mbGlja2luZyk7XG4gICAgdmFyIGNhbWVyYSA9IGZsaWNraW5nLmNhbWVyYTtcbiAgICB2YXIgYWN0aXZlUGFuZWwgPSB0aGlzLl9hY3RpdmVQYW5lbDtcbiAgICBpZiAoYWN0aXZlUGFuZWwpIHtcbiAgICAgIHZhciBwYW5lbFJhbmdlID0gYWN0aXZlUGFuZWwucmFuZ2U7XG4gICAgICB2YXIgbmV3UG9zaXRpb24gPSBwYW5lbFJhbmdlLm1pbiArIChwYW5lbFJhbmdlLm1heCAtIHBhbmVsUmFuZ2UubWluKSAqIHByb2dyZXNzSW5QYW5lbDtcbiAgICAgIGNhbWVyYS5sb29rQXQoY2FtZXJhLmNsYW1wVG9SZWFjaGFibGVQb3NpdGlvbihuZXdQb3NpdGlvbikpO1xuICAgIH1cbiAgfTtcbiAgLyoqXHJcbiAgICogTW92ZSB7QGxpbmsgQ2FtZXJhfSB0byB0aGUgZ2l2ZW4gcG9zaXRpb25cclxuICAgKiBAa28ge0BsaW5rIENhbWVyYX3rpbwg7KO87Ja07KeEIOyijO2RnOuhnCDsnbTrj5ntlanri4jri6RcclxuICAgKiBAcGFyYW0ge251bWJlcn0gcG9zaXRpb24gVGhlIHRhcmdldCBwb3NpdGlvbiB0byBtb3ZlPGtvPuydtOuPme2VoCDsooztkZw8L2tvPlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkdXJhdGlvbiBEdXJhdGlvbiBvZiB0aGUgcGFuZWwgbW92ZW1lbnQgYW5pbWF0aW9uICh1bml0OiBtcykuPGtvPu2MqOuEkCDsnbTrj5kg7JWg64uI66mU7J207IWYIOynhO2WiSDsi5zqsIQgKOuLqOychDogbXMpPC9rbz5cclxuICAgKiBAcGFyYW0ge29iamVjdH0gW2F4ZXNFdmVudF0ge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtYXhlcy9yZWxlYXNlL2xhdGVzdC9kb2MvZWcuQXhlcy5odG1sI2V2ZW50OnJlbGVhc2UgcmVsZWFzZX0gZXZlbnQgb2Yge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtYXhlcy8gQXhlc31cclxuICAgKiA8a28+e0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtYXhlcy8gQXhlc33snZgge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtYXhlcy9yZWxlYXNlL2xhdGVzdC9kb2MvZWcuQXhlcy5odG1sI2V2ZW50OnJlbGVhc2UgcmVsZWFzZX0g7J2067Kk7Yq4PC9rbz5cclxuICAgKiBAZmlyZXMgRmxpY2tpbmcjbW92ZVN0YXJ0XHJcbiAgICogQGZpcmVzIEZsaWNraW5nI21vdmVcclxuICAgKiBAZmlyZXMgRmxpY2tpbmcjbW92ZUVuZFxyXG4gICAqIEBmaXJlcyBGbGlja2luZyN3aWxsQ2hhbmdlXHJcbiAgICogQGZpcmVzIEZsaWNraW5nI2NoYW5nZWRcclxuICAgKiBAZmlyZXMgRmxpY2tpbmcjd2lsbFJlc3RvcmVcclxuICAgKiBAZmlyZXMgRmxpY2tpbmcjcmVzdG9yZWRcclxuICAgKiBAZmlyZXMgRmxpY2tpbmcjbmVlZFBhbmVsXHJcbiAgICogQGZpcmVzIEZsaWNraW5nI3Zpc2libGVDaGFuZ2VcclxuICAgKiBAZmlyZXMgRmxpY2tpbmcjcmVhY2hFZGdlXHJcbiAgICogQHRocm93cyB7RmxpY2tpbmdFcnJvcn1cclxuICAgKiB8Y29kZXxjb25kaXRpb258XHJcbiAgICogfC0tLXwtLS18XHJcbiAgICogfHtAbGluayBFUlJPUl9DT0RFIFBPU0lUSU9OX05PVF9SRUFDSEFCTEV9fFdoZW4gdGhlIGdpdmVuIHBhbmVsIGlzIGFscmVhZHkgcmVtb3ZlZCBvciBub3QgaW4gdGhlIENhbWVyYSdzIHtAbGluayBDYW1lcmEjcmFuZ2UgcmFuZ2V9fFxyXG4gICAqIHx7QGxpbmsgRVJST1JfQ09ERSBOT1RfQVRUQUNIRURfVE9fRkxJQ0tJTkd9fFdoZW4ge0BsaW5rIENvbnRyb2wjaW5pdCBpbml0fSBpcyBub3QgY2FsbGVkIGJlZm9yZXxcclxuICAgKiB8e0BsaW5rIEVSUk9SX0NPREUgQU5JTUFUSU9OX0lOVEVSUlVQVEVEfXxXaGVuIHRoZSBhbmltYXRpb24gaXMgaW50ZXJydXB0ZWQgYnkgdXNlciBpbnB1dHxcclxuICAgKiB8e0BsaW5rIEVSUk9SX0NPREUgU1RPUF9DQUxMRURfQllfVVNFUn18V2hlbiB0aGUgYW5pbWF0aW9uIGlzIGludGVycnVwdGVkIGJ5IHVzZXIgaW5wdXR8XHJcbiAgICogPGtvPlxyXG4gICAqXHJcbiAgICogfGNvZGV8Y29uZGl0aW9ufFxyXG4gICAqIHwtLS18LS0tfFxyXG4gICAqIHx7QGxpbmsgRVJST1JfQ09ERSBQT1NJVElPTl9OT1RfUkVBQ0hBQkxFfXzso7zslrTsp4Qg7Yyo64SQ7J20IOygnOqxsOuQmOyXiOqxsOuCmCwgQ2FtZXJh7J2YIHtAbGluayBDYW1lcmEjcmFuZ2UgcmFuZ2V9IOuwluyXkCDsnojsnYQg6rK97JqwfFxyXG4gICAqIHx7QGxpbmsgRVJST1JfQ09ERSBOT1RfQVRUQUNIRURfVE9fRkxJQ0tJTkd9fHtAbGluayBDb250cm9sI2luaXQgaW5pdH3snbQg7J207KCE7JeQIO2YuOy2nOuQmOyngCDslYrsnYAg6rK97JqwfFxyXG4gICAqIHx7QGxpbmsgRVJST1JfQ09ERSBBTklNQVRJT05fSU5URVJSVVBURUR9fOyCrOyaqeyekCDsnoXroKXsl5Ag7J2Y7ZW0IOyVoOuLiOuplOydtOyFmOydtCDspJHri6jrkJwg6rK97JqwfFxyXG4gICAqIHx7QGxpbmsgRVJST1JfQ09ERSBTVE9QX0NBTExFRF9CWV9VU0VSfXzrsJzsg53rkJwg7J2067Kk7Yq465OkIOykkSDtlZjrgpjrnbzrj4QgYHN0b3AoKWDsnbQg7Zi47Lac65CcIOqyveyasHxcclxuICAgKlxyXG4gICAqIDwva28+XHJcbiAgICogQHJldHVybiB7UHJvbWlzZTx2b2lkPn0gQSBQcm9taXNlIHdoaWNoIHdpbGwgYmUgcmVzb2x2ZWQgYWZ0ZXIgcmVhY2hpbmcgdGhlIHRhcmdldCBwb3NpdGlvbjxrbz7tlbTri7kg7KKM7ZGcIOuPhOuLrOyLnOyXkCByZXNvbHZl65CY64qUIFByb21pc2U8L2tvPlxyXG4gICAqL1xuICBfX3Byb3RvLm1vdmVUb1Bvc2l0aW9uID0gZnVuY3Rpb24gKHBvc2l0aW9uLCBkdXJhdGlvbiwgYXhlc0V2ZW50KSB7XG4gICAgdmFyIGZsaWNraW5nID0gZ2V0RmxpY2tpbmdBdHRhY2hlZCh0aGlzLl9mbGlja2luZyk7XG4gICAgdmFyIGNhbWVyYSA9IGZsaWNraW5nLmNhbWVyYTtcbiAgICB2YXIgdGFyZ2V0UG9zID0gY2FtZXJhLmNsYW1wVG9SZWFjaGFibGVQb3NpdGlvbihwb3NpdGlvbik7XG4gICAgdmFyIGFuY2hvckF0UG9zaXRpb24gPSBjYW1lcmEuZmluZEFuY2hvckluY2x1ZGVQb3NpdGlvbih0YXJnZXRQb3MpO1xuICAgIGlmICghYW5jaG9yQXRQb3NpdGlvbikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBGbGlja2luZ0Vycm9yKE1FU1NBR0UuUE9TSVRJT05fTk9UX1JFQUNIQUJMRShwb3NpdGlvbiksIENPREUuUE9TSVRJT05fTk9UX1JFQUNIQUJMRSkpO1xuICAgIH1cbiAgICB2YXIgdGFyZ2V0UGFuZWwgPSBhbmNob3JBdFBvc2l0aW9uLnBhbmVsO1xuICAgIC8vIFRyaWdnZXIgb25seSBjaGFuZ2UgZXZlbnRcbiAgICBpZiAodGFyZ2V0UGFuZWwgIT09IHRoaXMuX2FjdGl2ZVBhbmVsKSB7XG4gICAgICB0aGlzLl90cmlnZ2VySW5kZXhDaGFuZ2VFdmVudCh0YXJnZXRQYW5lbCwgcG9zaXRpb24sIGF4ZXNFdmVudCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9hbmltYXRlVG9Qb3NpdGlvbih7XG4gICAgICBwb3NpdGlvbjogdGhpcy5fc3RvcEF0RWRnZSA/IHRhcmdldFBvcyA6IHBvc2l0aW9uLFxuICAgICAgZHVyYXRpb246IGR1cmF0aW9uLFxuICAgICAgbmV3QWN0aXZlUGFuZWw6IHRhcmdldFBhbmVsLFxuICAgICAgYXhlc0V2ZW50OiBheGVzRXZlbnRcbiAgICB9KTtcbiAgfTtcbiAgcmV0dXJuIEZyZWVDb250cm9sO1xufShDb250cm9sKTtcblxuLyoqXHJcbiAqIEEge0BsaW5rIENvbnRyb2x9IHRoYXQgYWxsb3cgeW91IHRvIHNlbGVjdCB0aGUgbWF4aW11bSBudW1iZXIgb2YgcGFuZWxzIHRvIG1vdmUgYXQgYSB0aW1lXHJcbiAqIEBrbyDtlZzrsojsl5Ag7LWc64yA66GcIOydtOuPme2VoCDtjKjrhJDsnZgg6rCc7IiY66W8IOyEoO2DnSDqsIDriqXtlZwge0BsaW5rIENvbnRyb2x9XHJcbiAqL1xudmFyIFN0cmljdENvbnRyb2wgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMkMyhTdHJpY3RDb250cm9sLCBfc3VwZXIpO1xuICAvKiogKi9cbiAgZnVuY3Rpb24gU3RyaWN0Q29udHJvbChfYSkge1xuICAgIHZhciBfYiA9IChfYSA9PT0gdm9pZCAwID8ge30gOiBfYSkuY291bnQsXG4gICAgICBjb3VudCA9IF9iID09PSB2b2lkIDAgPyAxIDogX2I7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICBfdGhpcy5zZXRBY3RpdmUgPSBmdW5jdGlvbiAobmV3QWN0aXZlUGFuZWwsIHByZXZBY3RpdmVQYW5lbCwgaXNUcnVzdGVkKSB7XG4gICAgICBfc3VwZXIucHJvdG90eXBlLnNldEFjdGl2ZS5jYWxsKF90aGlzLCBuZXdBY3RpdmVQYW5lbCwgcHJldkFjdGl2ZVBhbmVsLCBpc1RydXN0ZWQpO1xuICAgICAgX3RoaXMudXBkYXRlSW5wdXQoKTtcbiAgICB9O1xuICAgIF90aGlzLl9jb3VudCA9IGNvdW50O1xuICAgIF90aGlzLl9yZXNldEluZGV4UmFuZ2UoKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgdmFyIF9fcHJvdG8gPSBTdHJpY3RDb250cm9sLnByb3RvdHlwZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwiY291bnRcIiwge1xuICAgIC8qKlxyXG4gICAgICogTWF4aW11bSBudW1iZXIgb2YgcGFuZWxzIHRoYXQgY2FuIGJlIG1vdmVkIGF0IGEgdGltZVxyXG4gICAgICogQGtvIOy1nOuMgOuhnCDsm4Dsp4Hsnbwg7IiYIOyeiOuKlCDtjKjrhJDsnZgg6rCc7IiYXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgMVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY291bnQ7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHRoaXMuX2NvdW50ID0gdmFsO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICAvKipcclxuICAgKiBEZXN0cm95IENvbnRyb2wgYW5kIHJldHVybiB0byBpbml0aWFsIHN0YXRlXHJcbiAgICogQGtvIENvbnRyb2zsnYQg7LSI6riwIOyDge2DnOuhnCDrkJjrj4zrpr3ri4jri6RcclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xuICBfX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgX3N1cGVyLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gICAgdGhpcy5fcmVzZXRJbmRleFJhbmdlKCk7XG4gIH07XG4gIC8qKlxyXG4gICAqIFVwZGF0ZSB7QGxpbmsgQ29udHJvbCNjb250cm9sbGVyIGNvbnRyb2xsZXJ9J3Mgc3RhdGVcclxuICAgKiBAa28ge0BsaW5rIENvbnRyb2wjY29udHJvbGxlciBjb250cm9sbGVyfeydmCDrgrTrtoAg7IOB7YOc66W8IOqwseyLoO2VqeuLiOuLpFxyXG4gICAqIEBjaGFpbmFibGVcclxuICAgKiBAcmV0dXJuIHt0aGlzfVxyXG4gICAqL1xuICBfX3Byb3RvLnVwZGF0ZUlucHV0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfYTtcbiAgICB2YXIgZmxpY2tpbmcgPSBnZXRGbGlja2luZ0F0dGFjaGVkKHRoaXMuX2ZsaWNraW5nKTtcbiAgICB2YXIgY2FtZXJhID0gZmxpY2tpbmcuY2FtZXJhO1xuICAgIHZhciByZW5kZXJlciA9IGZsaWNraW5nLnJlbmRlcmVyO1xuICAgIHZhciBjb250cm9sbGVyID0gdGhpcy5fY29udHJvbGxlcjtcbiAgICB2YXIgY29udHJvbFBhcmFtcyA9IGNhbWVyYS5jb250cm9sUGFyYW1zO1xuICAgIHZhciBjb3VudCA9IHRoaXMuX2NvdW50O1xuICAgIHZhciBhY3RpdmVQYW5lbCA9IGNvbnRyb2xsZXIuc3RhdGUuYW5pbWF0aW5nID8gKF9hID0gY2FtZXJhLmZpbmROZWFyZXN0QW5jaG9yKGNhbWVyYS5wb3NpdGlvbikpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wYW5lbCA6IHRoaXMuX2FjdGl2ZVBhbmVsO1xuICAgIGlmICghYWN0aXZlUGFuZWwpIHtcbiAgICAgIGNvbnRyb2xsZXIudXBkYXRlKGNvbnRyb2xQYXJhbXMpO1xuICAgICAgdGhpcy5fcmVzZXRJbmRleFJhbmdlKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdmFyIGNhbWVyYVJhbmdlID0gY29udHJvbFBhcmFtcy5yYW5nZTtcbiAgICB2YXIgY3VycmVudFBvcyA9IGFjdGl2ZVBhbmVsLnBvc2l0aW9uO1xuICAgIHZhciBjdXJyZW50SW5kZXggPSBhY3RpdmVQYW5lbC5pbmRleDtcbiAgICB2YXIgcGFuZWxDb3VudCA9IHJlbmRlcmVyLnBhbmVsQ291bnQ7XG4gICAgdmFyIHByZXZQYW5lbEluZGV4ID0gY3VycmVudEluZGV4IC0gY291bnQ7XG4gICAgdmFyIG5leHRQYW5lbEluZGV4ID0gY3VycmVudEluZGV4ICsgY291bnQ7XG4gICAgaWYgKHByZXZQYW5lbEluZGV4IDwgMCkge1xuICAgICAgcHJldlBhbmVsSW5kZXggPSBmbGlja2luZy5jaXJjdWxhckVuYWJsZWQgPyBnZXRNaW51c0NvbXBlbnNhdGVkSW5kZXgoKHByZXZQYW5lbEluZGV4ICsgMSkgJSBwYW5lbENvdW50IC0gMSwgcGFuZWxDb3VudCkgOiBjbGFtcCQxKHByZXZQYW5lbEluZGV4LCAwLCBwYW5lbENvdW50IC0gMSk7XG4gICAgfVxuICAgIGlmIChuZXh0UGFuZWxJbmRleCA+PSBwYW5lbENvdW50KSB7XG4gICAgICBuZXh0UGFuZWxJbmRleCA9IGZsaWNraW5nLmNpcmN1bGFyRW5hYmxlZCA/IG5leHRQYW5lbEluZGV4ICUgcGFuZWxDb3VudCA6IGNsYW1wJDEobmV4dFBhbmVsSW5kZXgsIDAsIHBhbmVsQ291bnQgLSAxKTtcbiAgICB9XG4gICAgdmFyIHByZXZQYW5lbCA9IHJlbmRlcmVyLnBhbmVsc1twcmV2UGFuZWxJbmRleF07XG4gICAgdmFyIG5leHRQYW5lbCA9IHJlbmRlcmVyLnBhbmVsc1tuZXh0UGFuZWxJbmRleF07XG4gICAgdmFyIHByZXZQb3MgPSBNYXRoLm1heChwcmV2UGFuZWwucG9zaXRpb24sIGNhbWVyYVJhbmdlLm1pbik7XG4gICAgdmFyIG5leHRQb3MgPSBNYXRoLm1pbihuZXh0UGFuZWwucG9zaXRpb24sIGNhbWVyYVJhbmdlLm1heCk7XG4gICAgaWYgKHByZXZQb3MgPiBjdXJyZW50UG9zKSB7XG4gICAgICBwcmV2UG9zIC09IGNhbWVyYS5yYW5nZURpZmY7XG4gICAgfVxuICAgIGlmIChuZXh0UG9zIDwgY3VycmVudFBvcykge1xuICAgICAgbmV4dFBvcyArPSBjYW1lcmEucmFuZ2VEaWZmO1xuICAgIH1cbiAgICBjb250cm9sUGFyYW1zLnJhbmdlID0ge1xuICAgICAgbWluOiBwcmV2UG9zLFxuICAgICAgbWF4OiBuZXh0UG9zXG4gICAgfTtcbiAgICBpZiAoY29udHJvbFBhcmFtcy5jaXJjdWxhcikge1xuICAgICAgaWYgKGNvbnRyb2xQYXJhbXMucG9zaXRpb24gPCBwcmV2UG9zKSB7XG4gICAgICAgIGNvbnRyb2xQYXJhbXMucG9zaXRpb24gKz0gY2FtZXJhLnJhbmdlRGlmZjtcbiAgICAgIH1cbiAgICAgIGlmIChjb250cm9sUGFyYW1zLnBvc2l0aW9uID4gbmV4dFBvcykge1xuICAgICAgICBjb250cm9sUGFyYW1zLnBvc2l0aW9uIC09IGNhbWVyYS5yYW5nZURpZmY7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnRyb2xQYXJhbXMuY2lyY3VsYXIgPSBmYWxzZTtcbiAgICBjb250cm9sbGVyLnVwZGF0ZShjb250cm9sUGFyYW1zKTtcbiAgICB0aGlzLl9pbmRleFJhbmdlID0ge1xuICAgICAgbWluOiBwcmV2UGFuZWwuaW5kZXgsXG4gICAgICBtYXg6IG5leHRQYW5lbC5pbmRleFxuICAgIH07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIF9fcHJvdG8ubW92ZVRvUGFuZWwgPSBmdW5jdGlvbiAocGFuZWwsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZmxpY2tpbmcsIGNhbWVyYSwgY29udHJvbGxlcjtcbiAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgZmxpY2tpbmcgPSBnZXRGbGlja2luZ0F0dGFjaGVkKHRoaXMuX2ZsaWNraW5nKTtcbiAgICAgICAgY2FtZXJhID0gZmxpY2tpbmcuY2FtZXJhO1xuICAgICAgICBjb250cm9sbGVyID0gdGhpcy5fY29udHJvbGxlcjtcbiAgICAgICAgY29udHJvbGxlci51cGRhdGUoY2FtZXJhLmNvbnRyb2xQYXJhbXMpO1xuICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgX3N1cGVyLnByb3RvdHlwZS5tb3ZlVG9QYW5lbC5jYWxsKHRoaXMsIHBhbmVsLCBvcHRpb25zKV07XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbiAgLyoqXHJcbiAgICogTW92ZSB7QGxpbmsgQ2FtZXJhfSB0byB0aGUgZ2l2ZW4gcG9zaXRpb25cclxuICAgKiBAa28ge0BsaW5rIENhbWVyYX3rpbwg7KO87Ja07KeEIOyijO2RnOuhnCDsnbTrj5ntlanri4jri6RcclxuICAgKiBAcGFyYW0ge251bWJlcn0gcG9zaXRpb24gVGhlIHRhcmdldCBwb3NpdGlvbiB0byBtb3ZlPGtvPuydtOuPme2VoCDsooztkZw8L2tvPlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkdXJhdGlvbiBEdXJhdGlvbiBvZiB0aGUgcGFuZWwgbW92ZW1lbnQgYW5pbWF0aW9uICh1bml0OiBtcykuPGtvPu2MqOuEkCDsnbTrj5kg7JWg64uI66mU7J207IWYIOynhO2WiSDsi5zqsIQgKOuLqOychDogbXMpPC9rbz5cclxuICAgKiBAcGFyYW0ge29iamVjdH0gW2F4ZXNFdmVudF0ge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtYXhlcy9yZWxlYXNlL2xhdGVzdC9kb2MvZWcuQXhlcy5odG1sI2V2ZW50OnJlbGVhc2UgcmVsZWFzZX0gZXZlbnQgb2Yge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtYXhlcy8gQXhlc31cclxuICAgKiA8a28+e0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtYXhlcy8gQXhlc33snZgge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtYXhlcy9yZWxlYXNlL2xhdGVzdC9kb2MvZWcuQXhlcy5odG1sI2V2ZW50OnJlbGVhc2UgcmVsZWFzZX0g7J2067Kk7Yq4PC9rbz5cclxuICAgKiBAZmlyZXMgRmxpY2tpbmcjbW92ZVN0YXJ0XHJcbiAgICogQGZpcmVzIEZsaWNraW5nI21vdmVcclxuICAgKiBAZmlyZXMgRmxpY2tpbmcjbW92ZUVuZFxyXG4gICAqIEBmaXJlcyBGbGlja2luZyN3aWxsQ2hhbmdlXHJcbiAgICogQGZpcmVzIEZsaWNraW5nI2NoYW5nZWRcclxuICAgKiBAZmlyZXMgRmxpY2tpbmcjd2lsbFJlc3RvcmVcclxuICAgKiBAZmlyZXMgRmxpY2tpbmcjcmVzdG9yZWRcclxuICAgKiBAZmlyZXMgRmxpY2tpbmcjbmVlZFBhbmVsXHJcbiAgICogQGZpcmVzIEZsaWNraW5nI3Zpc2libGVDaGFuZ2VcclxuICAgKiBAZmlyZXMgRmxpY2tpbmcjcmVhY2hFZGdlXHJcbiAgICogQHRocm93cyB7RmxpY2tpbmdFcnJvcn1cclxuICAgKiB8Y29kZXxjb25kaXRpb258XHJcbiAgICogfC0tLXwtLS18XHJcbiAgICogfHtAbGluayBFUlJPUl9DT0RFIFBPU0lUSU9OX05PVF9SRUFDSEFCTEV9fFdoZW4gdGhlIGdpdmVuIHBhbmVsIGlzIGFscmVhZHkgcmVtb3ZlZCBvciBub3QgaW4gdGhlIENhbWVyYSdzIHtAbGluayBDYW1lcmEjcmFuZ2UgcmFuZ2V9fFxyXG4gICAqIHx7QGxpbmsgRVJST1JfQ09ERSBOT1RfQVRUQUNIRURfVE9fRkxJQ0tJTkd9fFdoZW4ge0BsaW5rIENvbnRyb2wjaW5pdCBpbml0fSBpcyBub3QgY2FsbGVkIGJlZm9yZXxcclxuICAgKiB8e0BsaW5rIEVSUk9SX0NPREUgQU5JTUFUSU9OX0lOVEVSUlVQVEVEfXxXaGVuIHRoZSBhbmltYXRpb24gaXMgaW50ZXJydXB0ZWQgYnkgdXNlciBpbnB1dHxcclxuICAgKiB8e0BsaW5rIEVSUk9SX0NPREUgU1RPUF9DQUxMRURfQllfVVNFUn18V2hlbiB0aGUgYW5pbWF0aW9uIGlzIGludGVycnVwdGVkIGJ5IHVzZXIgaW5wdXR8XHJcbiAgICogPGtvPlxyXG4gICAqXHJcbiAgICogfGNvZGV8Y29uZGl0aW9ufFxyXG4gICAqIHwtLS18LS0tfFxyXG4gICAqIHx7QGxpbmsgRVJST1JfQ09ERSBQT1NJVElPTl9OT1RfUkVBQ0hBQkxFfXzso7zslrTsp4Qg7Yyo64SQ7J20IOygnOqxsOuQmOyXiOqxsOuCmCwgQ2FtZXJh7J2YIHtAbGluayBDYW1lcmEjcmFuZ2UgcmFuZ2V9IOuwluyXkCDsnojsnYQg6rK97JqwfFxyXG4gICAqIHx7QGxpbmsgRVJST1JfQ09ERSBOT1RfQVRUQUNIRURfVE9fRkxJQ0tJTkd9fHtAbGluayBDb250cm9sI2luaXQgaW5pdH3snbQg7J207KCE7JeQIO2YuOy2nOuQmOyngCDslYrsnYAg6rK97JqwfFxyXG4gICAqIHx7QGxpbmsgRVJST1JfQ09ERSBBTklNQVRJT05fSU5URVJSVVBURUR9fOyCrOyaqeyekCDsnoXroKXsl5Ag7J2Y7ZW0IOyVoOuLiOuplOydtOyFmOydtCDspJHri6jrkJwg6rK97JqwfFxyXG4gICAqIHx7QGxpbmsgRVJST1JfQ09ERSBTVE9QX0NBTExFRF9CWV9VU0VSfXzrsJzsg53rkJwg7J2067Kk7Yq465OkIOykkSDtlZjrgpjrnbzrj4QgYHN0b3AoKWDsnbQg7Zi47Lac65CcIOqyveyasHxcclxuICAgKlxyXG4gICAqIDwva28+XHJcbiAgICogQHJldHVybiB7UHJvbWlzZTx2b2lkPn0gQSBQcm9taXNlIHdoaWNoIHdpbGwgYmUgcmVzb2x2ZWQgYWZ0ZXIgcmVhY2hpbmcgdGhlIHRhcmdldCBwb3NpdGlvbjxrbz7tlbTri7kg7KKM7ZGcIOuPhOuLrOyLnOyXkCByZXNvbHZl65CY64qUIFByb21pc2U8L2tvPlxyXG4gICAqL1xuICBfX3Byb3RvLm1vdmVUb1Bvc2l0aW9uID0gZnVuY3Rpb24gKHBvc2l0aW9uLCBkdXJhdGlvbiwgYXhlc0V2ZW50KSB7XG4gICAgdmFyIF9hO1xuICAgIHZhciBmbGlja2luZyA9IGdldEZsaWNraW5nQXR0YWNoZWQodGhpcy5fZmxpY2tpbmcpO1xuICAgIHZhciBjYW1lcmEgPSBmbGlja2luZy5jYW1lcmE7XG4gICAgdmFyIGN1cnJlbnRQYW5lbCA9IChfYSA9IHRoaXMuX25leHRQYW5lbCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdGhpcy5fYWN0aXZlUGFuZWw7XG4gICAgdmFyIGF4ZXNSYW5nZSA9IHRoaXMuX2NvbnRyb2xsZXIucmFuZ2U7XG4gICAgdmFyIGluZGV4UmFuZ2UgPSB0aGlzLl9pbmRleFJhbmdlO1xuICAgIHZhciBjYW1lcmFSYW5nZSA9IGNhbWVyYS5yYW5nZTtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLl9jb250cm9sbGVyLnN0YXRlO1xuICAgIHZhciBjbGFtcGVkUG9zaXRpb24gPSBjbGFtcCQxKGNhbWVyYS5jbGFtcFRvUmVhY2hhYmxlUG9zaXRpb24ocG9zaXRpb24pLCBheGVzUmFuZ2VbMF0sIGF4ZXNSYW5nZVsxXSk7XG4gICAgdmFyIGFuY2hvckF0UG9zaXRpb24gPSBjYW1lcmEuZmluZEFuY2hvckluY2x1ZGVQb3NpdGlvbihjbGFtcGVkUG9zaXRpb24pO1xuICAgIGlmICghYW5jaG9yQXRQb3NpdGlvbiB8fCAhY3VycmVudFBhbmVsKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEZsaWNraW5nRXJyb3IoTUVTU0FHRS5QT1NJVElPTl9OT1RfUkVBQ0hBQkxFKHBvc2l0aW9uKSwgQ09ERS5QT1NJVElPTl9OT1RfUkVBQ0hBQkxFKSk7XG4gICAgfVxuICAgIHZhciBwcmV2UG9zID0gY3VycmVudFBhbmVsLnBvc2l0aW9uO1xuICAgIHZhciBwb3NEZWx0YSA9IGZsaWNraW5nLmFuaW1hdGluZyA/IHN0YXRlLmRlbHRhIDogcG9zaXRpb24gLSBjYW1lcmEucG9zaXRpb247XG4gICAgdmFyIGlzT3ZlclRocmVzaG9sZCA9IE1hdGguYWJzKHBvc0RlbHRhKSA+PSBmbGlja2luZy50aHJlc2hvbGQ7XG4gICAgdmFyIGFkamFjZW50QW5jaG9yID0gcG9zaXRpb24gPiBwcmV2UG9zID8gY2FtZXJhLmdldE5leHRBbmNob3IoYW5jaG9yQXRQb3NpdGlvbikgOiBjYW1lcmEuZ2V0UHJldkFuY2hvcihhbmNob3JBdFBvc2l0aW9uKTtcbiAgICB2YXIgdGFyZ2V0UG9zO1xuICAgIHZhciB0YXJnZXRQYW5lbDtcbiAgICB2YXIgYW5jaG9ycyA9IGNhbWVyYS5hbmNob3JQb2ludHM7XG4gICAgdmFyIGZpcnN0QW5jaG9yID0gYW5jaG9yc1swXTtcbiAgICB2YXIgbGFzdEFuY2hvciA9IGFuY2hvcnNbYW5jaG9ycy5sZW5ndGggLSAxXTtcbiAgICB2YXIgc2hvdWxkQm91bmNlVG9GaXJzdCA9IHBvc2l0aW9uIDw9IGNhbWVyYVJhbmdlLm1pbiAmJiBpc0JldHdlZW4oZmlyc3RBbmNob3IucGFuZWwuaW5kZXgsIGluZGV4UmFuZ2UubWluLCBpbmRleFJhbmdlLm1heCk7XG4gICAgdmFyIHNob3VsZEJvdW5jZVRvTGFzdCA9IHBvc2l0aW9uID49IGNhbWVyYVJhbmdlLm1heCAmJiBpc0JldHdlZW4obGFzdEFuY2hvci5wYW5lbC5pbmRleCwgaW5kZXhSYW5nZS5taW4sIGluZGV4UmFuZ2UubWF4KTtcbiAgICB2YXIgaXNBZGphY2VudCA9IGFkamFjZW50QW5jaG9yICYmIChpbmRleFJhbmdlLm1pbiA8PSBpbmRleFJhbmdlLm1heCA/IGlzQmV0d2VlbihhZGphY2VudEFuY2hvci5pbmRleCwgaW5kZXhSYW5nZS5taW4sIGluZGV4UmFuZ2UubWF4KSA6IGFkamFjZW50QW5jaG9yLmluZGV4ID49IGluZGV4UmFuZ2UubWluIHx8IGFkamFjZW50QW5jaG9yLmluZGV4IDw9IGluZGV4UmFuZ2UubWF4KTtcbiAgICBpZiAoc2hvdWxkQm91bmNlVG9GaXJzdCB8fCBzaG91bGRCb3VuY2VUb0xhc3QpIHtcbiAgICAgIC8vIEluIGJvdW5jZSBhcmVhXG4gICAgICB2YXIgdGFyZ2V0QW5jaG9yID0gcG9zaXRpb24gPCBjYW1lcmFSYW5nZS5taW4gPyBmaXJzdEFuY2hvciA6IGxhc3RBbmNob3I7XG4gICAgICB0YXJnZXRQYW5lbCA9IHRhcmdldEFuY2hvci5wYW5lbDtcbiAgICAgIHRhcmdldFBvcyA9IHRhcmdldEFuY2hvci5wb3NpdGlvbjtcbiAgICB9IGVsc2UgaWYgKGlzT3ZlclRocmVzaG9sZCAmJiBhbmNob3JBdFBvc2l0aW9uLnBvc2l0aW9uICE9PSBjdXJyZW50UGFuZWwucG9zaXRpb24pIHtcbiAgICAgIC8vIE1vdmUgdG8gYW5jaG9yIGF0IHBvc2l0aW9uXG4gICAgICB0YXJnZXRQYW5lbCA9IGFuY2hvckF0UG9zaXRpb24ucGFuZWw7XG4gICAgICB0YXJnZXRQb3MgPSBhbmNob3JBdFBvc2l0aW9uLnBvc2l0aW9uO1xuICAgIH0gZWxzZSBpZiAoaXNPdmVyVGhyZXNob2xkICYmIGlzQWRqYWNlbnQpIHtcbiAgICAgIC8vIE1vdmUgdG8gYWRqYWNlbnQgYW5jaG9yXG4gICAgICB0YXJnZXRQYW5lbCA9IGFkamFjZW50QW5jaG9yLnBhbmVsO1xuICAgICAgdGFyZ2V0UG9zID0gYWRqYWNlbnRBbmNob3IucG9zaXRpb247XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZhbGxiYWNrIHRvIG5lYXJlc3QgcGFuZWwgZnJvbSBjdXJyZW50IGNhbWVyYVxuICAgICAgdmFyIGFuY2hvckF0Q2FtZXJhID0gY2FtZXJhLmZpbmROZWFyZXN0QW5jaG9yKGNhbWVyYS5wb3NpdGlvbik7XG4gICAgICBpZiAoIWFuY2hvckF0Q2FtZXJhKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRmxpY2tpbmdFcnJvcihNRVNTQUdFLlBPU0lUSU9OX05PVF9SRUFDSEFCTEUocG9zaXRpb24pLCBDT0RFLlBPU0lUSU9OX05PVF9SRUFDSEFCTEUpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLm1vdmVUb1BhbmVsKGFuY2hvckF0Q2FtZXJhLnBhbmVsLCB7XG4gICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbixcbiAgICAgICAgYXhlc0V2ZW50OiBheGVzRXZlbnRcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl90cmlnZ2VySW5kZXhDaGFuZ2VFdmVudCh0YXJnZXRQYW5lbCwgcG9zaXRpb24sIGF4ZXNFdmVudCk7XG4gICAgcmV0dXJuIHRoaXMuX2FuaW1hdGVUb1Bvc2l0aW9uKHtcbiAgICAgIHBvc2l0aW9uOiB0YXJnZXRQb3MsXG4gICAgICBkdXJhdGlvbjogZHVyYXRpb24sXG4gICAgICBuZXdBY3RpdmVQYW5lbDogdGFyZ2V0UGFuZWwsXG4gICAgICBheGVzRXZlbnQ6IGF4ZXNFdmVudFxuICAgIH0pO1xuICB9O1xuICBfX3Byb3RvLl9yZXNldEluZGV4UmFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5faW5kZXhSYW5nZSA9IHtcbiAgICAgIG1pbjogMCxcbiAgICAgIG1heDogMFxuICAgIH07XG4gIH07XG4gIHJldHVybiBTdHJpY3RDb250cm9sO1xufShDb250cm9sKTtcblxuLyoqXHJcbiAqIEEgbW9kZSBvZiBjYW1lcmFcclxuICovXG52YXIgQ2FtZXJhTW9kZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKiAqL1xuICBmdW5jdGlvbiBDYW1lcmFNb2RlKGZsaWNraW5nKSB7XG4gICAgdGhpcy5fZmxpY2tpbmcgPSBmbGlja2luZztcbiAgfVxuICB2YXIgX19wcm90byA9IENhbWVyYU1vZGUucHJvdG90eXBlO1xuICBfX3Byb3RvLmdldEFuY2hvcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBhbmVscyA9IHRoaXMuX2ZsaWNraW5nLnJlbmRlcmVyLnBhbmVscztcbiAgICByZXR1cm4gcGFuZWxzLm1hcChmdW5jdGlvbiAocGFuZWwsIGluZGV4KSB7XG4gICAgICByZXR1cm4gbmV3IEFuY2hvclBvaW50KHtcbiAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICBwb3NpdGlvbjogcGFuZWwucG9zaXRpb24sXG4gICAgICAgIHBhbmVsOiBwYW5lbFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG4gIF9fcHJvdG8uZmluZEFuY2hvckluY2x1ZGVQb3NpdGlvbiA9IGZ1bmN0aW9uIChwb3NpdGlvbikge1xuICAgIHZhciBhbmNob3JzID0gdGhpcy5fZmxpY2tpbmcuY2FtZXJhLmFuY2hvclBvaW50cztcbiAgICB2YXIgYW5jaG9yc0luY2x1ZGluZ1Bvc2l0aW9uID0gYW5jaG9ycy5maWx0ZXIoZnVuY3Rpb24gKGFuY2hvcikge1xuICAgICAgcmV0dXJuIGFuY2hvci5wYW5lbC5pbmNsdWRlUG9zaXRpb24ocG9zaXRpb24sIHRydWUpO1xuICAgIH0pO1xuICAgIHJldHVybiBhbmNob3JzSW5jbHVkaW5nUG9zaXRpb24ucmVkdWNlKGZ1bmN0aW9uIChuZWFyZXN0LCBhbmNob3IpIHtcbiAgICAgIGlmICghbmVhcmVzdCkgcmV0dXJuIGFuY2hvcjtcbiAgICAgIHJldHVybiBNYXRoLmFicyhuZWFyZXN0LnBvc2l0aW9uIC0gcG9zaXRpb24pIDwgTWF0aC5hYnMoYW5jaG9yLnBvc2l0aW9uIC0gcG9zaXRpb24pID8gbmVhcmVzdCA6IGFuY2hvcjtcbiAgICB9LCBudWxsKTtcbiAgfTtcbiAgX19wcm90by5maW5kTmVhcmVzdEFuY2hvciA9IGZ1bmN0aW9uIChwb3NpdGlvbikge1xuICAgIHZhciBhbmNob3JzID0gdGhpcy5fZmxpY2tpbmcuY2FtZXJhLmFuY2hvclBvaW50cztcbiAgICBpZiAoYW5jaG9ycy5sZW5ndGggPD0gMCkgcmV0dXJuIG51bGw7XG4gICAgdmFyIHByZXZEaXN0ID0gSW5maW5pdHk7XG4gICAgZm9yICh2YXIgYW5jaG9ySWR4ID0gMDsgYW5jaG9ySWR4IDwgYW5jaG9ycy5sZW5ndGg7IGFuY2hvcklkeCsrKSB7XG4gICAgICB2YXIgYW5jaG9yID0gYW5jaG9yc1thbmNob3JJZHhdO1xuICAgICAgdmFyIGRpc3QgPSBNYXRoLmFicyhhbmNob3IucG9zaXRpb24gLSBwb3NpdGlvbik7XG4gICAgICBpZiAoZGlzdCA+IHByZXZEaXN0KSB7XG4gICAgICAgIC8vIFJldHVybiBwcmV2aW91cyBhbmNob3JcbiAgICAgICAgcmV0dXJuIGFuY2hvcnNbYW5jaG9ySWR4IC0gMV07XG4gICAgICB9XG4gICAgICBwcmV2RGlzdCA9IGRpc3Q7XG4gICAgfVxuICAgIC8vIFJldHVybiBsYXN0IGFuY2hvclxuICAgIHJldHVybiBhbmNob3JzW2FuY2hvcnMubGVuZ3RoIC0gMV07XG4gIH07XG4gIF9fcHJvdG8uY2xhbXBUb1JlYWNoYWJsZVBvc2l0aW9uID0gZnVuY3Rpb24gKHBvc2l0aW9uKSB7XG4gICAgdmFyIGNhbWVyYSA9IHRoaXMuX2ZsaWNraW5nLmNhbWVyYTtcbiAgICB2YXIgcmFuZ2UgPSBjYW1lcmEucmFuZ2U7XG4gICAgcmV0dXJuIGNsYW1wJDEocG9zaXRpb24sIHJhbmdlLm1pbiwgcmFuZ2UubWF4KTtcbiAgfTtcbiAgX19wcm90by5nZXRDaXJjdWxhck9mZnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gMDtcbiAgfTtcbiAgX19wcm90by5jYW5SZWFjaCA9IGZ1bmN0aW9uIChwYW5lbCkge1xuICAgIHZhciBjYW1lcmEgPSB0aGlzLl9mbGlja2luZy5jYW1lcmE7XG4gICAgdmFyIHJhbmdlID0gY2FtZXJhLnJhbmdlO1xuICAgIGlmIChwYW5lbC5yZW1vdmVkKSByZXR1cm4gZmFsc2U7XG4gICAgdmFyIHBhbmVsUG9zID0gcGFuZWwucG9zaXRpb247XG4gICAgcmV0dXJuIHBhbmVsUG9zID49IHJhbmdlLm1pbiAmJiBwYW5lbFBvcyA8PSByYW5nZS5tYXg7XG4gIH07XG4gIF9fcHJvdG8uY2FuU2VlID0gZnVuY3Rpb24gKHBhbmVsKSB7XG4gICAgdmFyIGNhbWVyYSA9IHRoaXMuX2ZsaWNraW5nLmNhbWVyYTtcbiAgICB2YXIgdmlzaWJsZVJhbmdlID0gY2FtZXJhLnZpc2libGVSYW5nZTtcbiAgICAvLyBTaG91bGQgbm90IGluY2x1ZGUgbWFyZ2luLCBhcyB3ZSBkb24ndCBkZWNsYXJlIHdoYXQgdGhlIG1hcmdpbiBpcyB2aXNpYmxlIGFzIHdoYXQgdGhlIHBhbmVsIGlzIHZpc2libGUuXG4gICAgcmV0dXJuIHBhbmVsLmlzVmlzaWJsZU9uUmFuZ2UodmlzaWJsZVJhbmdlLm1pbiwgdmlzaWJsZVJhbmdlLm1heCk7XG4gIH07XG4gIHJldHVybiBDYW1lcmFNb2RlO1xufSgpO1xuXG52YXIgTGluZWFyQ2FtZXJhTW9kZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyQzKExpbmVhckNhbWVyYU1vZGUsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIExpbmVhckNhbWVyYU1vZGUoKSB7XG4gICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG4gIHZhciBfX3Byb3RvID0gTGluZWFyQ2FtZXJhTW9kZS5wcm90b3R5cGU7XG4gIF9fcHJvdG8uY2hlY2tBdmFpbGFiaWxpdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gSXQncyBhbHdheXMgYXZhaWxhYmxlXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG4gIF9fcHJvdG8uZ2V0UmFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLl9mbGlja2luZy5yZW5kZXJlcjtcbiAgICB2YXIgZmlyc3RQYW5lbCA9IHJlbmRlcmVyLmdldFBhbmVsKDApO1xuICAgIHZhciBsYXN0UGFuZWwgPSByZW5kZXJlci5nZXRQYW5lbChyZW5kZXJlci5wYW5lbENvdW50IC0gMSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1pbjogKF9hID0gZmlyc3RQYW5lbCA9PT0gbnVsbCB8fCBmaXJzdFBhbmVsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmaXJzdFBhbmVsLnBvc2l0aW9uKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwLFxuICAgICAgbWF4OiAoX2IgPSBsYXN0UGFuZWwgPT09IG51bGwgfHwgbGFzdFBhbmVsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsYXN0UGFuZWwucG9zaXRpb24pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDBcbiAgICB9O1xuICB9O1xuICByZXR1cm4gTGluZWFyQ2FtZXJhTW9kZTtcbn0oQ2FtZXJhTW9kZSk7XG5cbi8qKlxyXG4gKiBBIHtAbGluayBDYW1lcmF9IG1vZGUgdGhhdCBjb25uZWN0cyB0aGUgbGFzdCBwYW5lbCBhbmQgdGhlIGZpcnN0IHBhbmVsLCBlbmFibGluZyBjb250aW51b3VzIGxvb3BcclxuICogQGtvIOyyq+uyiOynuCDtjKjrhJDqs7wg66eI7KeA66eJIO2MqOuEkOydtCDsnbTslrTsp4Qg7IOB7YOc66GcLCDrrLTtlZztnogg7ZqM7KCE7ZWgIOyImCDsnojripQg7KKF66WY7J2YIHtAbGluayBDYW1lcmF9IOuqqOuTnFxyXG4gKi9cbnZhciBDaXJjdWxhckNhbWVyYU1vZGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMkMyhDaXJjdWxhckNhbWVyYU1vZGUsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIENpcmN1bGFyQ2FtZXJhTW9kZSgpIHtcbiAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cbiAgdmFyIF9fcHJvdG8gPSBDaXJjdWxhckNhbWVyYU1vZGUucHJvdG90eXBlO1xuICBfX3Byb3RvLmNoZWNrQXZhaWxhYmlsaXR5ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBmbGlja2luZyA9IHRoaXMuX2ZsaWNraW5nO1xuICAgIHZhciByZW5kZXJlciA9IGZsaWNraW5nLnJlbmRlcmVyO1xuICAgIHZhciBwYW5lbHMgPSByZW5kZXJlci5wYW5lbHM7XG4gICAgaWYgKHBhbmVscy5sZW5ndGggPD0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgZmlyc3RQYW5lbCA9IHBhbmVsc1swXTtcbiAgICB2YXIgbGFzdFBhbmVsID0gcGFuZWxzW3BhbmVscy5sZW5ndGggLSAxXTtcbiAgICB2YXIgZmlyc3RQYW5lbFByZXYgPSBmaXJzdFBhbmVsLnJhbmdlLm1pbiAtIGZpcnN0UGFuZWwubWFyZ2luLnByZXY7XG4gICAgdmFyIGxhc3RQYW5lbE5leHQgPSBsYXN0UGFuZWwucmFuZ2UubWF4ICsgbGFzdFBhbmVsLm1hcmdpbi5uZXh0O1xuICAgIHZhciB2aXNpYmxlU2l6ZSA9IGZsaWNraW5nLmNhbWVyYS5zaXplO1xuICAgIHZhciBwYW5lbFNpemVTdW0gPSBsYXN0UGFuZWxOZXh0IC0gZmlyc3RQYW5lbFByZXY7XG4gICAgdmFyIGNhblNldENpcmN1bGFyTW9kZSA9IHBhbmVscy5ldmVyeShmdW5jdGlvbiAocGFuZWwpIHtcbiAgICAgIHJldHVybiBwYW5lbFNpemVTdW0gLSBwYW5lbC5zaXplID49IHZpc2libGVTaXplO1xuICAgIH0pO1xuICAgIHJldHVybiBjYW5TZXRDaXJjdWxhck1vZGU7XG4gIH07XG4gIF9fcHJvdG8uZ2V0UmFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZsaWNraW5nID0gdGhpcy5fZmxpY2tpbmc7XG4gICAgdmFyIHBhbmVscyA9IGZsaWNraW5nLnJlbmRlcmVyLnBhbmVscztcbiAgICBpZiAocGFuZWxzLmxlbmd0aCA8PSAwKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtaW46IDAsXG4gICAgICAgIG1heDogMFxuICAgICAgfTtcbiAgICB9XG4gICAgdmFyIGZpcnN0UGFuZWwgPSBwYW5lbHNbMF07XG4gICAgdmFyIGxhc3RQYW5lbCA9IHBhbmVsc1twYW5lbHMubGVuZ3RoIC0gMV07XG4gICAgdmFyIGZpcnN0UGFuZWxQcmV2ID0gZmlyc3RQYW5lbC5yYW5nZS5taW4gLSBmaXJzdFBhbmVsLm1hcmdpbi5wcmV2O1xuICAgIHZhciBsYXN0UGFuZWxOZXh0ID0gbGFzdFBhbmVsLnJhbmdlLm1heCArIGxhc3RQYW5lbC5tYXJnaW4ubmV4dDtcbiAgICByZXR1cm4ge1xuICAgICAgbWluOiBmaXJzdFBhbmVsUHJldixcbiAgICAgIG1heDogbGFzdFBhbmVsTmV4dFxuICAgIH07XG4gIH07XG4gIF9fcHJvdG8uZ2V0QW5jaG9ycyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZmxpY2tpbmcgPSB0aGlzLl9mbGlja2luZztcbiAgICB2YXIgcGFuZWxzID0gZmxpY2tpbmcucmVuZGVyZXIucGFuZWxzO1xuICAgIHJldHVybiBwYW5lbHMubWFwKGZ1bmN0aW9uIChwYW5lbCwgaW5kZXgpIHtcbiAgICAgIHJldHVybiBuZXcgQW5jaG9yUG9pbnQoe1xuICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgIHBvc2l0aW9uOiBwYW5lbC5wb3NpdGlvbixcbiAgICAgICAgcGFuZWw6IHBhbmVsXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbiAgX19wcm90by5maW5kTmVhcmVzdEFuY2hvciA9IGZ1bmN0aW9uIChwb3NpdGlvbikge1xuICAgIHZhciBjYW1lcmEgPSB0aGlzLl9mbGlja2luZy5jYW1lcmE7XG4gICAgdmFyIGFuY2hvcnMgPSBjYW1lcmEuYW5jaG9yUG9pbnRzO1xuICAgIGlmIChhbmNob3JzLmxlbmd0aCA8PSAwKSByZXR1cm4gbnVsbDtcbiAgICB2YXIgY2FtUmFuZ2UgPSBjYW1lcmEucmFuZ2U7XG4gICAgdmFyIG1pbkRpc3QgPSBJbmZpbml0eTtcbiAgICB2YXIgbWluRGlzdEluZGV4ID0gLTE7XG4gICAgZm9yICh2YXIgYW5jaG9ySWR4ID0gMDsgYW5jaG9ySWR4IDwgYW5jaG9ycy5sZW5ndGg7IGFuY2hvcklkeCsrKSB7XG4gICAgICB2YXIgYW5jaG9yID0gYW5jaG9yc1thbmNob3JJZHhdO1xuICAgICAgdmFyIGRpc3QgPSBNYXRoLm1pbihNYXRoLmFicyhhbmNob3IucG9zaXRpb24gLSBwb3NpdGlvbiksIE1hdGguYWJzKGFuY2hvci5wb3NpdGlvbiAtIGNhbVJhbmdlLm1pbiArIGNhbVJhbmdlLm1heCAtIHBvc2l0aW9uKSwgTWF0aC5hYnMocG9zaXRpb24gLSBjYW1SYW5nZS5taW4gKyBjYW1SYW5nZS5tYXggLSBhbmNob3IucG9zaXRpb24pKTtcbiAgICAgIGlmIChkaXN0IDwgbWluRGlzdCkge1xuICAgICAgICBtaW5EaXN0ID0gZGlzdDtcbiAgICAgICAgbWluRGlzdEluZGV4ID0gYW5jaG9ySWR4O1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBSZXR1cm4gbGFzdCBhbmNob3JcbiAgICByZXR1cm4gYW5jaG9yc1ttaW5EaXN0SW5kZXhdO1xuICB9O1xuICBfX3Byb3RvLmZpbmRBbmNob3JJbmNsdWRlUG9zaXRpb24gPSBmdW5jdGlvbiAocG9zaXRpb24pIHtcbiAgICB2YXIgY2FtZXJhID0gdGhpcy5fZmxpY2tpbmcuY2FtZXJhO1xuICAgIHZhciByYW5nZSA9IGNhbWVyYS5yYW5nZTtcbiAgICB2YXIgYW5jaG9ycyA9IGNhbWVyYS5hbmNob3JQb2ludHM7XG4gICAgdmFyIHJhbmdlRGlmZiA9IGNhbWVyYS5yYW5nZURpZmY7XG4gICAgdmFyIGFuY2hvckNvdW50ID0gYW5jaG9ycy5sZW5ndGg7XG4gICAgdmFyIHBvc2l0aW9uSW5SYW5nZSA9IGNpcmN1bGF0ZVBvc2l0aW9uKHBvc2l0aW9uLCByYW5nZS5taW4sIHJhbmdlLm1heCk7XG4gICAgdmFyIGFuY2hvckluUmFuZ2UgPSBfc3VwZXIucHJvdG90eXBlLmZpbmRBbmNob3JJbmNsdWRlUG9zaXRpb24uY2FsbCh0aGlzLCBwb3NpdGlvbkluUmFuZ2UpO1xuICAgIGlmIChhbmNob3JDb3VudCA+IDAgJiYgKHBvc2l0aW9uID09PSByYW5nZS5taW4gfHwgcG9zaXRpb24gPT09IHJhbmdlLm1heCkpIHtcbiAgICAgIHZhciBwb3NzaWJsZUFuY2hvcnMgPSBbYW5jaG9ySW5SYW5nZSwgbmV3IEFuY2hvclBvaW50KHtcbiAgICAgICAgaW5kZXg6IDAsXG4gICAgICAgIHBvc2l0aW9uOiBhbmNob3JzWzBdLnBvc2l0aW9uICsgcmFuZ2VEaWZmLFxuICAgICAgICBwYW5lbDogYW5jaG9yc1swXS5wYW5lbFxuICAgICAgfSksIG5ldyBBbmNob3JQb2ludCh7XG4gICAgICAgIGluZGV4OiBhbmNob3JDb3VudCAtIDEsXG4gICAgICAgIHBvc2l0aW9uOiBhbmNob3JzW2FuY2hvckNvdW50IC0gMV0ucG9zaXRpb24gLSByYW5nZURpZmYsXG4gICAgICAgIHBhbmVsOiBhbmNob3JzW2FuY2hvckNvdW50IC0gMV0ucGFuZWxcbiAgICAgIH0pXS5maWx0ZXIoZnVuY3Rpb24gKGFuY2hvcikge1xuICAgICAgICByZXR1cm4gISFhbmNob3I7XG4gICAgICB9KTtcbiAgICAgIGFuY2hvckluUmFuZ2UgPSBwb3NzaWJsZUFuY2hvcnMucmVkdWNlKGZ1bmN0aW9uIChuZWFyZXN0LCBhbmNob3IpIHtcbiAgICAgICAgaWYgKCFuZWFyZXN0KSByZXR1cm4gYW5jaG9yO1xuICAgICAgICByZXR1cm4gTWF0aC5hYnMobmVhcmVzdC5wb3NpdGlvbiAtIHBvc2l0aW9uKSA8IE1hdGguYWJzKGFuY2hvci5wb3NpdGlvbiAtIHBvc2l0aW9uKSA/IG5lYXJlc3QgOiBhbmNob3I7XG4gICAgICB9LCBudWxsKTtcbiAgICB9XG4gICAgaWYgKCFhbmNob3JJblJhbmdlKSByZXR1cm4gbnVsbDtcbiAgICBpZiAocG9zaXRpb24gPCByYW5nZS5taW4pIHtcbiAgICAgIHZhciBsb29wQ291bnQgPSAtTWF0aC5mbG9vcigocmFuZ2UubWluIC0gcG9zaXRpb24pIC8gcmFuZ2VEaWZmKSAtIDE7XG4gICAgICByZXR1cm4gbmV3IEFuY2hvclBvaW50KHtcbiAgICAgICAgaW5kZXg6IGFuY2hvckluUmFuZ2UuaW5kZXgsXG4gICAgICAgIHBvc2l0aW9uOiBhbmNob3JJblJhbmdlLnBvc2l0aW9uICsgcmFuZ2VEaWZmICogbG9vcENvdW50LFxuICAgICAgICBwYW5lbDogYW5jaG9ySW5SYW5nZS5wYW5lbFxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA+IHJhbmdlLm1heCkge1xuICAgICAgdmFyIGxvb3BDb3VudCA9IE1hdGguZmxvb3IoKHBvc2l0aW9uIC0gcmFuZ2UubWF4KSAvIHJhbmdlRGlmZikgKyAxO1xuICAgICAgcmV0dXJuIG5ldyBBbmNob3JQb2ludCh7XG4gICAgICAgIGluZGV4OiBhbmNob3JJblJhbmdlLmluZGV4LFxuICAgICAgICBwb3NpdGlvbjogYW5jaG9ySW5SYW5nZS5wb3NpdGlvbiArIHJhbmdlRGlmZiAqIGxvb3BDb3VudCxcbiAgICAgICAgcGFuZWw6IGFuY2hvckluUmFuZ2UucGFuZWxcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYW5jaG9ySW5SYW5nZTtcbiAgfTtcbiAgX19wcm90by5nZXRDaXJjdWxhck9mZnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZmxpY2tpbmcgPSB0aGlzLl9mbGlja2luZztcbiAgICB2YXIgY2FtZXJhID0gZmxpY2tpbmcuY2FtZXJhO1xuICAgIGlmICghY2FtZXJhLmNpcmN1bGFyRW5hYmxlZCkgcmV0dXJuIDA7XG4gICAgdmFyIHRvZ2dsZWQgPSBmbGlja2luZy5wYW5lbHMuZmlsdGVyKGZ1bmN0aW9uIChwYW5lbCkge1xuICAgICAgcmV0dXJuIHBhbmVsLnRvZ2dsZWQ7XG4gICAgfSk7XG4gICAgdmFyIHRvZ2dsZWRQcmV2ID0gdG9nZ2xlZC5maWx0ZXIoZnVuY3Rpb24gKHBhbmVsKSB7XG4gICAgICByZXR1cm4gcGFuZWwudG9nZ2xlRGlyZWN0aW9uID09PSBESVJFQ1RJT04uUFJFVjtcbiAgICB9KTtcbiAgICB2YXIgdG9nZ2xlZE5leHQgPSB0b2dnbGVkLmZpbHRlcihmdW5jdGlvbiAocGFuZWwpIHtcbiAgICAgIHJldHVybiBwYW5lbC50b2dnbGVEaXJlY3Rpb24gPT09IERJUkVDVElPTi5ORVhUO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLl9jYWxjUGFuZWxBcmVhU3VtKHRvZ2dsZWRQcmV2KSAtIHRoaXMuX2NhbGNQYW5lbEFyZWFTdW0odG9nZ2xlZE5leHQpO1xuICB9O1xuICBfX3Byb3RvLmNsYW1wVG9SZWFjaGFibGVQb3NpdGlvbiA9IGZ1bmN0aW9uIChwb3NpdGlvbikge1xuICAgIC8vIEJhc2ljYWxseSBhbGwgcG9zaXRpb24gaXMgcmVhY2hhYmxlIGZvciBjaXJjdWxhciBjYW1lcmFcbiAgICByZXR1cm4gcG9zaXRpb247XG4gIH07XG4gIF9fcHJvdG8uY2FuUmVhY2ggPSBmdW5jdGlvbiAocGFuZWwpIHtcbiAgICBpZiAocGFuZWwucmVtb3ZlZCkgcmV0dXJuIGZhbHNlO1xuICAgIC8vIEFsd2F5cyByZWFjaGFibGUgb24gY2lyY3VsYXIgbW9kZVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuICBfX3Byb3RvLmNhblNlZSA9IGZ1bmN0aW9uIChwYW5lbCkge1xuICAgIHZhciBjYW1lcmEgPSB0aGlzLl9mbGlja2luZy5jYW1lcmE7XG4gICAgdmFyIHJhbmdlID0gY2FtZXJhLnJhbmdlO1xuICAgIHZhciByYW5nZURpZmYgPSBjYW1lcmEucmFuZ2VEaWZmO1xuICAgIHZhciB2aXNpYmxlUmFuZ2UgPSBjYW1lcmEudmlzaWJsZVJhbmdlO1xuICAgIHZhciB2aXNpYmxlSW5DdXJyZW50UmFuZ2UgPSBfc3VwZXIucHJvdG90eXBlLmNhblNlZS5jYWxsKHRoaXMsIHBhbmVsKTtcbiAgICAvLyBDaGVjayBsb29wZWQgdmlzaWJsZSBhcmVhIGZvciBjaXJjdWxhciBjYXNlXG4gICAgaWYgKHZpc2libGVSYW5nZS5taW4gPCByYW5nZS5taW4pIHtcbiAgICAgIHJldHVybiB2aXNpYmxlSW5DdXJyZW50UmFuZ2UgfHwgcGFuZWwuaXNWaXNpYmxlT25SYW5nZSh2aXNpYmxlUmFuZ2UubWluICsgcmFuZ2VEaWZmLCB2aXNpYmxlUmFuZ2UubWF4ICsgcmFuZ2VEaWZmKTtcbiAgICB9IGVsc2UgaWYgKHZpc2libGVSYW5nZS5tYXggPiByYW5nZS5tYXgpIHtcbiAgICAgIHJldHVybiB2aXNpYmxlSW5DdXJyZW50UmFuZ2UgfHwgcGFuZWwuaXNWaXNpYmxlT25SYW5nZSh2aXNpYmxlUmFuZ2UubWluIC0gcmFuZ2VEaWZmLCB2aXNpYmxlUmFuZ2UubWF4IC0gcmFuZ2VEaWZmKTtcbiAgICB9XG4gICAgcmV0dXJuIHZpc2libGVJbkN1cnJlbnRSYW5nZTtcbiAgfTtcbiAgX19wcm90by5fY2FsY1BhbmVsQXJlYVN1bSA9IGZ1bmN0aW9uIChwYW5lbHMpIHtcbiAgICByZXR1cm4gcGFuZWxzLnJlZHVjZShmdW5jdGlvbiAoc3VtLCBwYW5lbCkge1xuICAgICAgcmV0dXJuIHN1bSArIHBhbmVsLnNpemVJbmNsdWRpbmdNYXJnaW47XG4gICAgfSwgMCk7XG4gIH07XG4gIHJldHVybiBDaXJjdWxhckNhbWVyYU1vZGU7XG59KENhbWVyYU1vZGUpO1xuXG52YXIgQm91bmRDYW1lcmFNb2RlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzJDMoQm91bmRDYW1lcmFNb2RlLCBfc3VwZXIpO1xuICBmdW5jdGlvbiBCb3VuZENhbWVyYU1vZGUoKSB7XG4gICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG4gIHZhciBfX3Byb3RvID0gQm91bmRDYW1lcmFNb2RlLnByb3RvdHlwZTtcbiAgX19wcm90by5jaGVja0F2YWlsYWJpbGl0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZmxpY2tpbmcgPSB0aGlzLl9mbGlja2luZztcbiAgICB2YXIgcmVuZGVyZXIgPSBmbGlja2luZy5yZW5kZXJlcjtcbiAgICB2YXIgZmlyc3RQYW5lbCA9IHJlbmRlcmVyLmdldFBhbmVsKDApO1xuICAgIHZhciBsYXN0UGFuZWwgPSByZW5kZXJlci5nZXRQYW5lbChyZW5kZXJlci5wYW5lbENvdW50IC0gMSk7XG4gICAgaWYgKCFmaXJzdFBhbmVsIHx8ICFsYXN0UGFuZWwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIHZpZXdwb3J0U2l6ZSA9IGZsaWNraW5nLmNhbWVyYS5zaXplO1xuICAgIHZhciBmaXJzdFBhbmVsUHJldiA9IGZpcnN0UGFuZWwucmFuZ2UubWluO1xuICAgIHZhciBsYXN0UGFuZWxOZXh0ID0gbGFzdFBhbmVsLnJhbmdlLm1heDtcbiAgICB2YXIgcGFuZWxBcmVhU2l6ZSA9IGxhc3RQYW5lbE5leHQgLSBmaXJzdFBhbmVsUHJldjtcbiAgICB2YXIgaXNCaWdnZXJUaGFuVmlld3BvcnQgPSB2aWV3cG9ydFNpemUgPCBwYW5lbEFyZWFTaXplO1xuICAgIHJldHVybiBpc0JpZ2dlclRoYW5WaWV3cG9ydDtcbiAgfTtcbiAgX19wcm90by5nZXRSYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZmxpY2tpbmcgPSB0aGlzLl9mbGlja2luZztcbiAgICB2YXIgcmVuZGVyZXIgPSBmbGlja2luZy5yZW5kZXJlcjtcbiAgICB2YXIgYWxpZ25Qb3MgPSBmbGlja2luZy5jYW1lcmEuYWxpZ25Qb3NpdGlvbjtcbiAgICB2YXIgZmlyc3RQYW5lbCA9IHJlbmRlcmVyLmdldFBhbmVsKDApO1xuICAgIHZhciBsYXN0UGFuZWwgPSByZW5kZXJlci5nZXRQYW5lbChyZW5kZXJlci5wYW5lbENvdW50IC0gMSk7XG4gICAgaWYgKCFmaXJzdFBhbmVsIHx8ICFsYXN0UGFuZWwpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1pbjogMCxcbiAgICAgICAgbWF4OiAwXG4gICAgICB9O1xuICAgIH1cbiAgICB2YXIgdmlld3BvcnRTaXplID0gZmxpY2tpbmcuY2FtZXJhLnNpemU7XG4gICAgdmFyIGZpcnN0UGFuZWxQcmV2ID0gZmlyc3RQYW5lbC5yYW5nZS5taW47XG4gICAgdmFyIGxhc3RQYW5lbE5leHQgPSBsYXN0UGFuZWwucmFuZ2UubWF4O1xuICAgIHZhciBwYW5lbEFyZWFTaXplID0gbGFzdFBhbmVsTmV4dCAtIGZpcnN0UGFuZWxQcmV2O1xuICAgIHZhciBpc0JpZ2dlclRoYW5WaWV3cG9ydCA9IHZpZXdwb3J0U2l6ZSA8IHBhbmVsQXJlYVNpemU7XG4gICAgdmFyIGZpcnN0UG9zID0gZmlyc3RQYW5lbFByZXYgKyBhbGlnblBvcztcbiAgICB2YXIgbGFzdFBvcyA9IGxhc3RQYW5lbE5leHQgLSB2aWV3cG9ydFNpemUgKyBhbGlnblBvcztcbiAgICBpZiAoaXNCaWdnZXJUaGFuVmlld3BvcnQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1pbjogZmlyc3RQb3MsXG4gICAgICAgIG1heDogbGFzdFBvc1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFsaWduID0gZmxpY2tpbmcuY2FtZXJhLmFsaWduO1xuICAgICAgdmFyIGFsaWduVmFsID0gdHlwZW9mIGFsaWduID09PSBcIm9iamVjdFwiID8gYWxpZ24uY2FtZXJhIDogYWxpZ247XG4gICAgICB2YXIgcG9zID0gZmlyc3RQb3MgKyBwYXJzZUFsaWduJDEoYWxpZ25WYWwsIGxhc3RQb3MgLSBmaXJzdFBvcyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtaW46IHBvcyxcbiAgICAgICAgbWF4OiBwb3NcbiAgICAgIH07XG4gICAgfVxuICB9O1xuICBfX3Byb3RvLmdldEFuY2hvcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZsaWNraW5nID0gdGhpcy5fZmxpY2tpbmc7XG4gICAgdmFyIGNhbWVyYSA9IGZsaWNraW5nLmNhbWVyYTtcbiAgICB2YXIgcGFuZWxzID0gZmxpY2tpbmcucmVuZGVyZXIucGFuZWxzO1xuICAgIGlmIChwYW5lbHMubGVuZ3RoIDw9IDApIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgdmFyIHJhbmdlID0gZmxpY2tpbmcuY2FtZXJhLnJhbmdlO1xuICAgIHZhciByZWFjaGFibGVQYW5lbHMgPSBwYW5lbHMuZmlsdGVyKGZ1bmN0aW9uIChwYW5lbCkge1xuICAgICAgcmV0dXJuIGNhbWVyYS5jYW5SZWFjaChwYW5lbCk7XG4gICAgfSk7XG4gICAgaWYgKHJlYWNoYWJsZVBhbmVscy5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgc2hvdWxkUHJlcGVuZEJvdW5kQW5jaG9yID0gcmVhY2hhYmxlUGFuZWxzWzBdLnBvc2l0aW9uICE9PSByYW5nZS5taW47XG4gICAgICB2YXIgc2hvdWxkQXBwZW5kQm91bmRBbmNob3IgPSByZWFjaGFibGVQYW5lbHNbcmVhY2hhYmxlUGFuZWxzLmxlbmd0aCAtIDFdLnBvc2l0aW9uICE9PSByYW5nZS5tYXg7XG4gICAgICB2YXIgaW5kZXhPZmZzZXRfMSA9IHNob3VsZFByZXBlbmRCb3VuZEFuY2hvciA/IDEgOiAwO1xuICAgICAgdmFyIG5ld0FuY2hvcnMgPSByZWFjaGFibGVQYW5lbHMubWFwKGZ1bmN0aW9uIChwYW5lbCwgaWR4KSB7XG4gICAgICAgIHJldHVybiBuZXcgQW5jaG9yUG9pbnQoe1xuICAgICAgICAgIGluZGV4OiBpZHggKyBpbmRleE9mZnNldF8xLFxuICAgICAgICAgIHBvc2l0aW9uOiBwYW5lbC5wb3NpdGlvbixcbiAgICAgICAgICBwYW5lbDogcGFuZWxcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIGlmIChzaG91bGRQcmVwZW5kQm91bmRBbmNob3IpIHtcbiAgICAgICAgbmV3QW5jaG9ycy5zcGxpY2UoMCwgMCwgbmV3IEFuY2hvclBvaW50KHtcbiAgICAgICAgICBpbmRleDogMCxcbiAgICAgICAgICBwb3NpdGlvbjogcmFuZ2UubWluLFxuICAgICAgICAgIHBhbmVsOiBwYW5lbHNbcmVhY2hhYmxlUGFuZWxzWzBdLmluZGV4IC0gMV1cbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgICAgaWYgKHNob3VsZEFwcGVuZEJvdW5kQW5jaG9yKSB7XG4gICAgICAgIG5ld0FuY2hvcnMucHVzaChuZXcgQW5jaG9yUG9pbnQoe1xuICAgICAgICAgIGluZGV4OiBuZXdBbmNob3JzLmxlbmd0aCxcbiAgICAgICAgICBwb3NpdGlvbjogcmFuZ2UubWF4LFxuICAgICAgICAgIHBhbmVsOiBwYW5lbHNbcmVhY2hhYmxlUGFuZWxzW3JlYWNoYWJsZVBhbmVscy5sZW5ndGggLSAxXS5pbmRleCArIDFdXG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdBbmNob3JzO1xuICAgIH0gZWxzZSBpZiAocmFuZ2UubWluICE9PSByYW5nZS5tYXgpIHtcbiAgICAgIC8vIFRoZXJlJ3JlIG1vcmUgdGhhbiAyIHBhbmVsc1xuICAgICAgdmFyIG5lYXJlc3RQYW5lbEF0TWluID0gdGhpcy5fZmluZE5lYXJlc3RQYW5lbChyYW5nZS5taW4sIHBhbmVscyk7XG4gICAgICB2YXIgcGFuZWxBdE1pbiA9IG5lYXJlc3RQYW5lbEF0TWluLmluZGV4ID09PSBwYW5lbHMubGVuZ3RoIC0gMSA/IG5lYXJlc3RQYW5lbEF0TWluLnByZXYoKSA6IG5lYXJlc3RQYW5lbEF0TWluO1xuICAgICAgdmFyIHBhbmVsQXRNYXggPSBwYW5lbEF0TWluLm5leHQoKTtcbiAgICAgIHJldHVybiBbbmV3IEFuY2hvclBvaW50KHtcbiAgICAgICAgaW5kZXg6IDAsXG4gICAgICAgIHBvc2l0aW9uOiByYW5nZS5taW4sXG4gICAgICAgIHBhbmVsOiBwYW5lbEF0TWluXG4gICAgICB9KSwgbmV3IEFuY2hvclBvaW50KHtcbiAgICAgICAgaW5kZXg6IDEsXG4gICAgICAgIHBvc2l0aW9uOiByYW5nZS5tYXgsXG4gICAgICAgIHBhbmVsOiBwYW5lbEF0TWF4XG4gICAgICB9KV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBbbmV3IEFuY2hvclBvaW50KHtcbiAgICAgICAgaW5kZXg6IDAsXG4gICAgICAgIHBvc2l0aW9uOiByYW5nZS5taW4sXG4gICAgICAgIHBhbmVsOiB0aGlzLl9maW5kTmVhcmVzdFBhbmVsKHJhbmdlLm1pbiwgcGFuZWxzKVxuICAgICAgfSldO1xuICAgIH1cbiAgfTtcbiAgX19wcm90by5maW5kQW5jaG9ySW5jbHVkZVBvc2l0aW9uID0gZnVuY3Rpb24gKHBvc2l0aW9uKSB7XG4gICAgdmFyIGNhbWVyYSA9IHRoaXMuX2ZsaWNraW5nLmNhbWVyYTtcbiAgICB2YXIgcmFuZ2UgPSBjYW1lcmEucmFuZ2U7XG4gICAgdmFyIGFuY2hvcnMgPSBjYW1lcmEuYW5jaG9yUG9pbnRzO1xuICAgIGlmIChhbmNob3JzLmxlbmd0aCA8PSAwKSByZXR1cm4gbnVsbDtcbiAgICBpZiAocG9zaXRpb24gPD0gcmFuZ2UubWluKSB7XG4gICAgICByZXR1cm4gYW5jaG9yc1swXTtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID49IHJhbmdlLm1heCkge1xuICAgICAgcmV0dXJuIGFuY2hvcnNbYW5jaG9ycy5sZW5ndGggLSAxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuZmluZEFuY2hvckluY2x1ZGVQb3NpdGlvbi5jYWxsKHRoaXMsIHBvc2l0aW9uKTtcbiAgICB9XG4gIH07XG4gIF9fcHJvdG8uX2ZpbmROZWFyZXN0UGFuZWwgPSBmdW5jdGlvbiAocG9zLCBwYW5lbHMpIHtcbiAgICB2YXIgcHJldkRpc3QgPSBJbmZpbml0eTtcbiAgICBmb3IgKHZhciBwYW5lbElkeCA9IDA7IHBhbmVsSWR4IDwgcGFuZWxzLmxlbmd0aDsgcGFuZWxJZHgrKykge1xuICAgICAgdmFyIHBhbmVsID0gcGFuZWxzW3BhbmVsSWR4XTtcbiAgICAgIHZhciBkaXN0ID0gTWF0aC5hYnMocGFuZWwucG9zaXRpb24gLSBwb3MpO1xuICAgICAgaWYgKGRpc3QgPiBwcmV2RGlzdCkge1xuICAgICAgICAvLyBSZXR1cm4gcHJldmlvdXMgYW5jaG9yXG4gICAgICAgIHJldHVybiBwYW5lbHNbcGFuZWxJZHggLSAxXTtcbiAgICAgIH1cbiAgICAgIHByZXZEaXN0ID0gZGlzdDtcbiAgICB9XG4gICAgLy8gUmV0dXJuIGxhc3QgYW5jaG9yXG4gICAgcmV0dXJuIHBhbmVsc1twYW5lbHMubGVuZ3RoIC0gMV07XG4gIH07XG4gIHJldHVybiBCb3VuZENhbWVyYU1vZGU7XG59KENhbWVyYU1vZGUpO1xuXG4vKipcclxuICogQSBjb21wb25lbnQgdGhhdCBtYW5hZ2VzIGFjdHVhbCBtb3ZlbWVudCBpbnNpZGUgdGhlIHZpZXdwb3J0XHJcbiAqIEBrbyDrt7Dtj6ztirgg64K07JeQ7ISc7J2YIOyLpOygnCDsm4Dsp4HsnoTsnYQg64u064u57ZWY64qUIOy7tO2PrOuEjO2KuFxyXG4gKi9cbnZhciBDYW1lcmEgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKiogKi9cbiAgZnVuY3Rpb24gQ2FtZXJhKGZsaWNraW5nLCBfYSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIF9iID0gKF9hID09PSB2b2lkIDAgPyB7fSA6IF9hKS5hbGlnbixcbiAgICAgIGFsaWduID0gX2IgPT09IHZvaWQgMCA/IEFMSUdOLkNFTlRFUiA6IF9iO1xuICAgIHRoaXMuX2NoZWNrVHJhbnNsYXRlU3VwcG9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBlXzEsIF9hO1xuICAgICAgdmFyIHRyYW5zZm9ybXMgPSBbXCJ3ZWJraXRUcmFuc2Zvcm1cIiwgXCJtc1RyYW5zZm9ybVwiLCBcIk1velRyYW5zZm9ybVwiLCBcIk9UcmFuc2Zvcm1cIiwgXCJ0cmFuc2Zvcm1cIl07XG4gICAgICB2YXIgc3VwcG9ydGVkU3R5bGUgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGU7XG4gICAgICB2YXIgdHJhbnNmb3JtTmFtZSA9IFwiXCI7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciB0cmFuc2Zvcm1zXzEgPSBfX3ZhbHVlcyQxKHRyYW5zZm9ybXMpLCB0cmFuc2Zvcm1zXzFfMSA9IHRyYW5zZm9ybXNfMS5uZXh0KCk7ICF0cmFuc2Zvcm1zXzFfMS5kb25lOyB0cmFuc2Zvcm1zXzFfMSA9IHRyYW5zZm9ybXNfMS5uZXh0KCkpIHtcbiAgICAgICAgICB2YXIgcHJlZml4ZWRUcmFuc2Zvcm0gPSB0cmFuc2Zvcm1zXzFfMS52YWx1ZTtcbiAgICAgICAgICBpZiAocHJlZml4ZWRUcmFuc2Zvcm0gaW4gc3VwcG9ydGVkU3R5bGUpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybU5hbWUgPSBwcmVmaXhlZFRyYW5zZm9ybTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVfMV8xKSB7XG4gICAgICAgIGVfMSA9IHtcbiAgICAgICAgICBlcnJvcjogZV8xXzFcbiAgICAgICAgfTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKHRyYW5zZm9ybXNfMV8xICYmICF0cmFuc2Zvcm1zXzFfMS5kb25lICYmIChfYSA9IHRyYW5zZm9ybXNfMS5yZXR1cm4pKSBfYS5jYWxsKHRyYW5zZm9ybXNfMSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIXRyYW5zZm9ybU5hbWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZsaWNraW5nRXJyb3IoTUVTU0FHRS5UUkFOU0ZPUk1fTk9UX1NVUFBPUlRFRCwgQ09ERS5UUkFOU0ZPUk1fTk9UX1NVUFBPUlRFRCk7XG4gICAgICB9XG4gICAgICBfdGhpcy5fdHJhbnNmb3JtID0gdHJhbnNmb3JtTmFtZTtcbiAgICB9O1xuICAgIHRoaXMuX2ZsaWNraW5nID0gZmxpY2tpbmc7XG4gICAgdGhpcy5fcmVzZXRJbnRlcm5hbFZhbHVlcygpO1xuICAgIC8vIE9wdGlvbnNcbiAgICB0aGlzLl9hbGlnbiA9IGFsaWduO1xuICB9XG4gIHZhciBfX3Byb3RvID0gQ2FtZXJhLnByb3RvdHlwZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwiZWxlbWVudFwiLCB7XG4gICAgLy8gSW50ZXJuYWwgc3RhdGVzIGdldHRlclxuICAgIC8qKlxyXG4gICAgICogVGhlIGNhbWVyYSBlbGVtZW50KGAuZmxpY2tpbmctY2FtZXJhYClcclxuICAgICAqIEBrbyDsubTrqZTrnbwg7JeY66as66i87Yq4KGAuZmxpY2tpbmctY2FtZXJhYClcclxuICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZWw7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcImNoaWxkcmVuXCIsIHtcbiAgICAvKipcclxuICAgICAqIEFuIGFycmF5IG9mIHRoZSBjaGlsZCBlbGVtZW50cyBvZiB0aGUgY2FtZXJhIGVsZW1lbnQoYC5mbGlja2luZy1jYW1lcmFgKVxyXG4gICAgICogQGtvIOy5tOuplOudvCDsl5jrpqzrqLztirgoYC5mbGlja2luZy1jYW1lcmFgKeydmCDsnpDsi50g7JeY66as66i87Yq4IOuwsOyXtFxyXG4gICAgICogQHR5cGUge0hUTUxFbGVtZW50W119XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRvQXJyYXkkMih0aGlzLl9lbC5jaGlsZHJlbik7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcInBvc2l0aW9uXCIsIHtcbiAgICAvKipcclxuICAgICAqIEN1cnJlbnQgcG9zaXRpb24gb2YgdGhlIGNhbWVyYVxyXG4gICAgICogQGtvIENhbWVyYeydmCDtmITsnqwg7KKM7ZGcXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wb3NpdGlvbjtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwiYWxpZ25Qb3NpdGlvblwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBBbGlnbiBwb3NpdGlvbiBpbnNpZGUgdGhlIHZpZXdwb3J0IHdoZXJlIHtAbGluayBQYW5lbH0ncyB7QGxpbmsgUGFuZWwjYWxpZ25Qb3NpdGlvbiBhbGlnblBvc2l0aW9ufSBzaG91bGQgYmUgbG9jYXRlZCBhdFxyXG4gICAgICogQGtvIO2MqOuEkOydmCDsoJXroKwg6riw7KSAIOychOy5mC4g67ew7Y+s7Yq4IOuCtOyXkOyEnCB7QGxpbmsgUGFuZWx97J2YIHtAbGluayBQYW5lbCNhbGlnblBvc2l0aW9uIGFsaWduUG9zaXRpb2597J20IOychOy5mO2VtOyVvCDtlZjripQg6rOz7J6F64uI64ukXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9hbGlnblBvcztcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwib2Zmc2V0XCIsIHtcbiAgICAvKipcclxuICAgICAqIFBvc2l0aW9uIG9mZnNldCwgdXNlZCBmb3IgdGhlIHtAbGluayBGbGlja2luZyNyZW5kZXJPbmx5VmlzaWJsZSByZW5kZXJPbmx5VmlzaWJsZX0gb3B0aW9uXHJcbiAgICAgKiBAa28gQ2FtZXJh7J2YIOyijO2RnCDsmKTtlITshYsuIHtAbGluayBGbGlja2luZyNyZW5kZXJPbmx5VmlzaWJsZSByZW5kZXJPbmx5VmlzaWJsZX0g7Ji17IWY7J2EIOychO2VtCDsgqzsmqnrkKnri4jri6QuXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgMFxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9vZmZzZXQgLSB0aGlzLl9jaXJjdWxhck9mZnNldDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwiY2lyY3VsYXJFbmFibGVkXCIsIHtcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgdGhlIGBjaXJjdWxhcmAgb3B0aW9uIGlzIGVuYWJsZWQuXHJcbiAgICAgKiBUaGUge0BsaW5rIEZsaWNraW5nI2NpcmN1bGFyIGNpcmN1bGFyfSBvcHRpb24gY2FuJ3QgYmUgZW5hYmxlZCB3aGVuIHN1bSBvZiB0aGUgcGFuZWwgc2l6ZXMgYXJlIHRvbyBzbWFsbC5cclxuICAgICAqIEBrbyB7QGxpbmsgRmxpY2tpbmcjY2lyY3VsYXIgY2lyY3VsYXJ9IOyYteyFmOydtCDtmZzshLHtmZTrkJjsl4jripTsp4Ag7Jes67aA66W8IOuCmO2DgOuCtOuKlCDrqaTrsoQg67OA7IiYLlxyXG4gICAgICoge0BsaW5rIEZsaWNraW5nI2NpcmN1bGFyIGNpcmN1bGFyfSDsmLXshZjsnYAg7Yyo64SQ7J2YIO2BrOq4sOydmCDtlansnbQg7Lap67aE7ZWY7KeAIOyViuydhCDqsr3smrAg67mE7Zmc7ISx7ZmU65Cp64uI64ukLlxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jaXJjdWxhckVuYWJsZWQ7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcIm1vZGVcIiwge1xuICAgIC8qKlxyXG4gICAgICogQSBjdXJyZW50IGNhbWVyYSBtb2RlXHJcbiAgICAgKiBAdHlwZSB7Q2FtZXJhTW9kZX1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbW9kZTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwicmFuZ2VcIiwge1xuICAgIC8qKlxyXG4gICAgICogQSByYW5nZSB0aGF0IENhbWVyYSdzIHtAbGluayBDYW1lcmEjcG9zaXRpb24gcG9zaXRpb259IGNhbiByZWFjaFxyXG4gICAgICogQGtvIENhbWVyYeydmCB7QGxpbmsgQ2FtZXJhI3Bvc2l0aW9uIHBvc2l0aW9ufeydtCDrj4Tri6wg6rCA64ql7ZWcIOuylOychFxyXG4gICAgICogQHR5cGUge29iamVjdH1cclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtaW4gQSBtaW5pbXVtIHBvc2l0aW9uPGtvPuy1nOyGjCDsnITsuZg8L2tvPlxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG1heCBBIG1heGltdW0gcG9zaXRpb248a28+7LWc64yAIOychOy5mDwva28+XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3JhbmdlO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJyYW5nZURpZmZcIiwge1xuICAgIC8qKlxyXG4gICAgICogQSBkaWZmZXJlbmNlIGJldHdlZW4gQ2FtZXJhJ3MgbWluaW11bSBhbmQgbWF4aW11bSBwb3NpdGlvbiB0aGF0IGNhbiByZWFjaFxyXG4gICAgICogQGtvIENhbWVyYeqwgCDrj4Tri6wg6rCA64ql7ZWcIOy1nOyGjC/stZzrjIAg7KKM7ZGc7J2YIOywqOydtFxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmFuZ2UubWF4IC0gdGhpcy5fcmFuZ2UubWluO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJ2aXNpYmxlUGFuZWxzXCIsIHtcbiAgICAvKipcclxuICAgICAqIEFuIGFycmF5IG9mIHZpc2libGUgcGFuZWxzIGZyb20gdGhlIGN1cnJlbnQgcG9zaXRpb25cclxuICAgICAqIEBrbyDtmITsnqwg67O07J2064qUIO2MqOuEkOuTpOydmCDrsLDsl7RcclxuICAgICAqIEB0eXBlIHtQYW5lbFtdfVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl92aXNpYmxlUGFuZWxzO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJ2aXNpYmxlUmFuZ2VcIiwge1xuICAgIC8qKlxyXG4gICAgICogQSByYW5nZSBvZiB0aGUgdmlzaWJsZSBhcmVhIGZyb20gdGhlIGN1cnJlbnQgcG9zaXRpb25cclxuICAgICAqIEBrbyDtmITsnqwg7JyE7LmY7JeQ7IScIOuztOydtOuKlCDrspTsnIRcclxuICAgICAqIEB0eXBlIHtvYmplY3R9XHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbWluIEEgbWluaW11bSBwb3NpdGlvbjxrbz7stZzshowg7JyE7LmYPC9rbz5cclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtaW4gQSBtYXhpbXVtIHBvc2l0aW9uPGtvPuy1nOuMgCDsnITsuZg8L2tvPlxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1pbjogdGhpcy5fcG9zaXRpb24gLSB0aGlzLl9hbGlnblBvcyxcbiAgICAgICAgbWF4OiB0aGlzLl9wb3NpdGlvbiAtIHRoaXMuX2FsaWduUG9zICsgdGhpcy5zaXplXG4gICAgICB9O1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJhbmNob3JQb2ludHNcIiwge1xuICAgIC8qKlxyXG4gICAgICogQW4gYXJyYXkgb2Yge0BsaW5rIEFuY2hvclBvaW50fXMgdGhhdCBDYW1lcmEgY2FuIGJlIHN0b3BwZWQgYXRcclxuICAgICAqIEBrbyDsubTrqZTrnbzqsIAg64+E64usIOqwgOuKpe2VnCB7QGxpbmsgQW5jaG9yUG9pbnR97J2YIOuqqeuhnVxyXG4gICAgICogQHR5cGUge0FuY2hvclBvaW50W119XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2FuY2hvcnM7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcImNvbnRyb2xQYXJhbXNcIiwge1xuICAgIC8qKlxyXG4gICAgICogQSBjdXJyZW50IHBhcmFtZXRlcnMgb2YgdGhlIENhbWVyYSBmb3IgdXBkYXRpbmcge0BsaW5rIEF4ZXNDb250cm9sbGVyfVxyXG4gICAgICogQGtvIHtAbGluayBBeGVzQ29udHJvbGxlcn3rpbwg7JeF642w7J207Yq47ZWY6riwIOychO2VnCDtmITsnqwgQ2FtZXJhIO2MqOufrOuvuO2EsOuTpFxyXG4gICAgICogQHR5cGUge0NvbnRyb2xQYXJhbXN9XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmFuZ2U6IHRoaXMuX3JhbmdlLFxuICAgICAgICBwb3NpdGlvbjogdGhpcy5fcG9zaXRpb24sXG4gICAgICAgIGNpcmN1bGFyOiB0aGlzLl9jaXJjdWxhckVuYWJsZWRcbiAgICAgIH07XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcImF0RWRnZVwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBBIEJvb2xlYW4gdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIENhbWVyYSdzIG92ZXIgdGhlIG1pbmltdW0gb3IgbWF4aW11bSBwb3NpdGlvbiByZWFjaGFibGVcclxuICAgICAqIEBrbyDtmITsnqwg7Lm066mU65286rCAIOuPhOuLrCDqsIDriqXtlZwg67KU7JyE7J2YIOy1nOyGjCDtmLnsnYAg7LWc64yA7KCQ7J2EIOuEmOyWtOyEsOuKlOyngOulvCDrgpjtg4Drg4Xri4jri6RcclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wb3NpdGlvbiA8PSB0aGlzLl9yYW5nZS5taW4gfHwgdGhpcy5fcG9zaXRpb24gPj0gdGhpcy5fcmFuZ2UubWF4O1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJzaXplXCIsIHtcbiAgICAvKipcclxuICAgICAqIFJldHVybiB0aGUgc2l6ZSBvZiB0aGUgdmlld3BvcnRcclxuICAgICAqIEBrbyDrt7Dtj6ztirgg7YGs6riw66W8IOuwmO2ZmO2VqeuLiOuLpFxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZmxpY2tpbmcgPSB0aGlzLl9mbGlja2luZztcbiAgICAgIHJldHVybiBmbGlja2luZyA/IGZsaWNraW5nLmhvcml6b250YWwgPyBmbGlja2luZy52aWV3cG9ydC53aWR0aCA6IGZsaWNraW5nLnZpZXdwb3J0LmhlaWdodCA6IDA7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcInByb2dyZXNzXCIsIHtcbiAgICAvKipcclxuICAgICAqIFJldHVybiB0aGUgY2FtZXJhJ3MgcG9zaXRpb24gcHJvZ3Jlc3MgZnJvbSB0aGUgZmlyc3QgcGFuZWwgdG8gbGFzdCBwYW5lbFxyXG4gICAgICogUmFuZ2UgaXMgZnJvbSAwIHRvIGxhc3QgcGFuZWwncyBpbmRleFxyXG4gICAgICogQGtvIOyyq+uyiOynuCDtjKjrhJDroZzrtoDthLAg66eI7KeA66eJIO2MqOuEkOq5jOyngOydmCDsubTrqZTrnbwg7JyE7LmY7J2YIOynhO2WieuPhOulvCDrsJjtmZjtlanri4jri6RcclxuICAgICAqIOuylOychOuKlCAw67aA7YSwIOuniOyngOuniSDtjKjrhJDsnZgg7J24642x7Iqk6rmM7KeA7J6F64uI64ukXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBmbGlja2luZyA9IHRoaXMuX2ZsaWNraW5nO1xuICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5fcG9zaXRpb24gKyB0aGlzLl9vZmZzZXQ7XG4gICAgICB2YXIgbmVhcmVzdEFuY2hvciA9IHRoaXMuZmluZE5lYXJlc3RBbmNob3IodGhpcy5fcG9zaXRpb24pO1xuICAgICAgaWYgKCFmbGlja2luZyB8fCAhbmVhcmVzdEFuY2hvcikge1xuICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgfVxuICAgICAgdmFyIG5lYXJlc3RQYW5lbCA9IG5lYXJlc3RBbmNob3IucGFuZWw7XG4gICAgICB2YXIgcGFuZWxQb3MgPSBuZWFyZXN0UGFuZWwucG9zaXRpb24gKyBuZWFyZXN0UGFuZWwub2Zmc2V0O1xuICAgICAgdmFyIGJvdW5jZVNpemUgPSBmbGlja2luZy5jb250cm9sLmNvbnRyb2xsZXIuYm91bmNlO1xuICAgICAgdmFyIF9hID0gdGhpcy5yYW5nZSxcbiAgICAgICAgcHJldlJhbmdlID0gX2EubWluLFxuICAgICAgICBuZXh0UmFuZ2UgPSBfYS5tYXg7XG4gICAgICB2YXIgcmFuZ2VEaWZmID0gdGhpcy5yYW5nZURpZmY7XG4gICAgICBpZiAocG9zaXRpb24gPT09IHBhbmVsUG9zKSB7XG4gICAgICAgIHJldHVybiBuZWFyZXN0UGFuZWwuaW5kZXg7XG4gICAgICB9XG4gICAgICBpZiAocG9zaXRpb24gPCBwYW5lbFBvcykge1xuICAgICAgICB2YXIgcHJldlBhbmVsID0gbmVhcmVzdFBhbmVsLnByZXYoKTtcbiAgICAgICAgdmFyIHByZXZQb3NpdGlvbiA9IHByZXZQYW5lbCA/IHByZXZQYW5lbC5wb3NpdGlvbiArIHByZXZQYW5lbC5vZmZzZXQgOiBwcmV2UmFuZ2UgLSBib3VuY2VTaXplWzBdO1xuICAgICAgICAvLyBMb29wZWRcbiAgICAgICAgaWYgKHByZXZQb3NpdGlvbiA+IHBhbmVsUG9zKSB7XG4gICAgICAgICAgcHJldlBvc2l0aW9uIC09IHJhbmdlRGlmZjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmVhcmVzdFBhbmVsLmluZGV4IC0gMSArIGdldFByb2dyZXNzKHBvc2l0aW9uLCBwcmV2UG9zaXRpb24sIHBhbmVsUG9zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBuZXh0UGFuZWwgPSBuZWFyZXN0UGFuZWwubmV4dCgpO1xuICAgICAgICB2YXIgbmV4dFBvc2l0aW9uID0gbmV4dFBhbmVsID8gbmV4dFBhbmVsLnBvc2l0aW9uICsgbmV4dFBhbmVsLm9mZnNldCA6IG5leHRSYW5nZSArIGJvdW5jZVNpemVbMV07XG4gICAgICAgIC8vIExvb3BlZFxuICAgICAgICBpZiAobmV4dFBvc2l0aW9uIDwgcGFuZWxQb3MpIHtcbiAgICAgICAgICBuZXh0UG9zaXRpb24gKz0gcmFuZ2VEaWZmO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZWFyZXN0UGFuZWwuaW5kZXggKyBnZXRQcm9ncmVzcyhwb3NpdGlvbiwgcGFuZWxQb3MsIG5leHRQb3NpdGlvbik7XG4gICAgICB9XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcInBhbmVsT3JkZXJcIiwge1xuICAgIC8qKlxyXG4gICAgICoge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9kaXJlY3Rpb24gZGlyZWN0aW9ufSBDU1MgcHJvcGVydHkgYXBwbGllZCB0byB0aGUgY2FtZXJhIGVsZW1lbnQoYC5mbGlja2luZy1jYW1lcmFgKVxyXG4gICAgICogQGtvIOy5tOuplOudvCDsl5jrpqzrqLztirgoYC5mbGlja2luZy1jYW1lcmFgKeyXkCDsoIHsmqnrkJwge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9kaXJlY3Rpb24gZGlyZWN0aW9ufSBDU1Mg7IaN7ISxXHJcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wYW5lbE9yZGVyO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJhbGlnblwiLCB7XG4gICAgLy8gT3B0aW9ucyBHZXR0ZXJcbiAgICAvKipcclxuICAgICAqIEEgdmFsdWUgaW5kaWNhdGluZyB3aGVyZSB0aGUge0BsaW5rIENhbWVyYSNhbGlnblBvc2l0aW9uIGFsaWduUG9zaXRpb259IHNob3VsZCBiZSBsb2NhdGVkIGF0IGluc2lkZSB0aGUgdmlld3BvcnQgZWxlbWVudFxyXG4gICAgICogQGtvIHtAbGluayBDYW1lcmEjYWxpZ25Qb3NpdGlvbiBhbGlnblBvc2l0aW9ufeydtCDrt7Dtj6ztirgg7JeY66as66i87Yq4IOuCtOydmCDslrTrlJTsl5Ag7JyE7LmY7ZW07JW8IO2VmOuKlOyngOulvCDrgpjtg4DrgrTripQg6rCSXHJcbiAgICAgKiBAdHlwZSB7QUxJR04gfCBzdHJpbmcgfCBudW1iZXJ9XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9hbGlnbjtcbiAgICB9LFxuICAgIC8vIE9wdGlvbnMgU2V0dGVyXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICB0aGlzLl9hbGlnbiA9IHZhbDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgLyoqXHJcbiAgICogSW5pdGlhbGl6ZSBDYW1lcmFcclxuICAgKiBAa28gQ2FtZXJh66W8IOy0iOq4sO2ZlO2VqeuLiOuLpFxyXG4gICAqIEB0aHJvd3Mge0ZsaWNraW5nRXJyb3J9XHJcbiAgICoge0BsaW5rIEVSUk9SX0NPREUgVkFMX01VU1RfTk9UX05VTEx9IElmIHRoZSBjYW1lcmEgZWxlbWVudChgLmZsaWNraW5nLWNhbWVyYWApIGRvZXMgbm90IGV4aXN0IGluc2lkZSB2aWV3cG9ydCBlbGVtZW50XHJcbiAgICogPGtvPntAbGluayBFUlJPUl9DT0RFIFZBTF9NVVNUX05PVF9OVUxMfSDrt7Dtj6ztirgg7JeY66as66i87Yq4IOuCtOu2gOyXkCDsubTrqZTrnbwg7JeY66as66i87Yq4KGAuZmxpY2tpbmctY2FtZXJhYCnqsIAg7KG07J6s7ZWY7KeAIOyViuydhCDqsr3smrA8L2tvPlxyXG4gICAqIEByZXR1cm4ge3RoaXN9XHJcbiAgICovXG4gIF9fcHJvdG8uaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdmlld3BvcnRFbCA9IHRoaXMuX2ZsaWNraW5nLnZpZXdwb3J0LmVsZW1lbnQ7XG4gICAgY2hlY2tFeGlzdGVuY2Uodmlld3BvcnRFbC5maXJzdEVsZW1lbnRDaGlsZCwgXCJGaXJzdCBlbGVtZW50IGNoaWxkIG9mIHRoZSB2aWV3cG9ydCBlbGVtZW50XCIpO1xuICAgIHRoaXMuX2VsID0gdmlld3BvcnRFbC5maXJzdEVsZW1lbnRDaGlsZDtcbiAgICB0aGlzLl9jaGVja1RyYW5zbGF0ZVN1cHBvcnQoKTtcbiAgICB0aGlzLl91cGRhdGVNb2RlKCk7XG4gICAgdGhpcy51cGRhdGVQYW5lbE9yZGVyKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxyXG4gICAqIERlc3Ryb3kgQ2FtZXJhIGFuZCByZXR1cm4gdG8gaW5pdGlhbCBzdGF0ZVxyXG4gICAqIEBrbyBDYW1lcmHrpbwg7LSI6riwIOyDge2DnOuhnCDrkJjrj4zrpr3ri4jri6RcclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xuICBfX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fcmVzZXRJbnRlcm5hbFZhbHVlcygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcclxuICAgKiBNb3ZlIHRvIHRoZSBnaXZlbiBwb3NpdGlvbiBhbmQgYXBwbHkgQ1NTIHRyYW5zZm9ybVxyXG4gICAqIEBrbyDtlbTri7kg7KKM7ZGc66GcIOydtOuPme2VmOqzoCwgQ1NTIHRyYW5zZm9ybeydhCDsoIHsmqntlanri4jri6RcclxuICAgKiBAcGFyYW0ge251bWJlcn0gcG9zIEEgbmV3IHBvc2l0aW9uPGtvPuybgOyngeydvCDsnITsuZg8L2tvPlxyXG4gICAqIEB0aHJvd3Mge0ZsaWNraW5nRXJyb3J9XHJcbiAgICoge0BsaW5rIEVSUk9SX0NPREUgTk9UX0FUVEFDSEVEX1RPX0ZMSUNLSU5HfSBXaGVuIHtAbGluayBDYW1lcmEjaW5pdCBpbml0fSBpcyBub3QgY2FsbGVkIGJlZm9yZVxyXG4gICAqIDxrbz57QGxpbmsgRVJST1JfQ09ERSBOT1RfQVRUQUNIRURfVE9fRkxJQ0tJTkd9IHtAbGluayBDYW1lcmEjaW5pdCBpbml0feydtCDsnbTsoITsl5Ag7Zi47Lac65CY7KeAIOyViuydgCDqsr3smrA8L2tvPlxyXG4gICAqIEByZXR1cm4ge3RoaXN9XHJcbiAgICovXG4gIF9fcHJvdG8ubG9va0F0ID0gZnVuY3Rpb24gKHBvcykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIGZsaWNraW5nID0gZ2V0RmxpY2tpbmdBdHRhY2hlZCh0aGlzLl9mbGlja2luZyk7XG4gICAgdmFyIHByZXZQb3MgPSB0aGlzLl9wb3NpdGlvbjtcbiAgICB0aGlzLl9wb3NpdGlvbiA9IHBvcztcbiAgICB2YXIgdG9nZ2xlZCA9IHRoaXMuX3RvZ2dsZVBhbmVscyhwcmV2UG9zLCBwb3MpO1xuICAgIHRoaXMuX3JlZnJlc2hWaXNpYmxlUGFuZWxzKCk7XG4gICAgdGhpcy5fY2hlY2tOZWVkUGFuZWwoKTtcbiAgICB0aGlzLl9jaGVja1JlYWNoRW5kKHByZXZQb3MsIHBvcyk7XG4gICAgaWYgKHRvZ2dsZWQpIHtcbiAgICAgIHZvaWQgZmxpY2tpbmcucmVuZGVyZXIucmVuZGVyKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLnVwZGF0ZU9mZnNldCgpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXBwbHlUcmFuc2Zvcm0oKTtcbiAgICB9XG4gIH07XG4gIC8qKlxyXG4gICAqIFJldHVybiBhIHByZXZpb3VzIHtAbGluayBBbmNob3JQb2ludH0gb2YgZ2l2ZW4ge0BsaW5rIEFuY2hvclBvaW50fVxyXG4gICAqIElmIGl0IGRvZXMgbm90IGV4aXN0LCByZXR1cm4gYG51bGxgIGluc3RlYWRcclxuICAgKiBAa28g7KO87Ja07KeEIHtAbGluayBBbmNob3JQb2ludH3snZgg7J207KCEIHtAbGluayBBbmNob3JQb2ludH3rpbwg67CY7ZmY7ZWp64uI64ukXHJcbiAgICog7KG07J6s7ZWY7KeAIOyViuydhCDqsr3smrAgYG51bGxg7J2EIOuwmO2ZmO2VqeuLiOuLpFxyXG4gICAqIEBwYXJhbSB7QW5jaG9yUG9pbnR9IGFuY2hvciBBIHJlZmVyZW5jZSB7QGxpbmsgQW5jaG9yUG9pbnR9PGtvPuq4sOykgCB7QGxpbmsgQW5jaG9yUG9pbnR9PC9rbz5cclxuICAgKiBAcmV0dXJuIHtBbmNob3JQb2ludCB8IG51bGx9IFRoZSBwcmV2aW91cyB7QGxpbmsgQW5jaG9yUG9pbnR9PGtvPuydtOyghCB7QGxpbmsgQW5jaG9yUG9pbnR9PC9rbz5cclxuICAgKi9cbiAgX19wcm90by5nZXRQcmV2QW5jaG9yID0gZnVuY3Rpb24gKGFuY2hvcikge1xuICAgIGlmICghdGhpcy5fY2lyY3VsYXJFbmFibGVkIHx8IGFuY2hvci5pbmRleCAhPT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2FuY2hvcnNbYW5jaG9yLmluZGV4IC0gMV0gfHwgbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFuY2hvcnMgPSB0aGlzLl9hbmNob3JzO1xuICAgICAgdmFyIHJhbmdlRGlmZiA9IHRoaXMucmFuZ2VEaWZmO1xuICAgICAgdmFyIGxhc3RBbmNob3IgPSBhbmNob3JzW2FuY2hvcnMubGVuZ3RoIC0gMV07XG4gICAgICByZXR1cm4gbmV3IEFuY2hvclBvaW50KHtcbiAgICAgICAgaW5kZXg6IGxhc3RBbmNob3IuaW5kZXgsXG4gICAgICAgIHBvc2l0aW9uOiBsYXN0QW5jaG9yLnBvc2l0aW9uIC0gcmFuZ2VEaWZmLFxuICAgICAgICBwYW5lbDogbGFzdEFuY2hvci5wYW5lbFxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICAvKipcclxuICAgKiBSZXR1cm4gYSBuZXh0IHtAbGluayBBbmNob3JQb2ludH0gb2YgZ2l2ZW4ge0BsaW5rIEFuY2hvclBvaW50fVxyXG4gICAqIElmIGl0IGRvZXMgbm90IGV4aXN0LCByZXR1cm4gYG51bGxgIGluc3RlYWRcclxuICAgKiBAa28g7KO87Ja07KeEIHtAbGluayBBbmNob3JQb2ludH3snZgg64uk7J2MIHtAbGluayBBbmNob3JQb2ludH3rpbwg67CY7ZmY7ZWp64uI64ukXHJcbiAgICog7KG07J6s7ZWY7KeAIOyViuydhCDqsr3smrAgYG51bGxg7J2EIOuwmO2ZmO2VqeuLiOuLpFxyXG4gICAqIEBwYXJhbSB7QW5jaG9yUG9pbnR9IGFuY2hvciBBIHJlZmVyZW5jZSB7QGxpbmsgQW5jaG9yUG9pbnR9PGtvPuq4sOykgCB7QGxpbmsgQW5jaG9yUG9pbnR9PC9rbz5cclxuICAgKiBAcmV0dXJuIHtBbmNob3JQb2ludCB8IG51bGx9IFRoZSBuZXh0IHtAbGluayBBbmNob3JQb2ludH08a28+64uk7J2MIHtAbGluayBBbmNob3JQb2ludH08L2tvPlxyXG4gICAqL1xuICBfX3Byb3RvLmdldE5leHRBbmNob3IgPSBmdW5jdGlvbiAoYW5jaG9yKSB7XG4gICAgdmFyIGFuY2hvcnMgPSB0aGlzLl9hbmNob3JzO1xuICAgIGlmICghdGhpcy5fY2lyY3VsYXJFbmFibGVkIHx8IGFuY2hvci5pbmRleCAhPT0gYW5jaG9ycy5sZW5ndGggLSAxKSB7XG4gICAgICByZXR1cm4gYW5jaG9yc1thbmNob3IuaW5kZXggKyAxXSB8fCBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcmFuZ2VEaWZmID0gdGhpcy5yYW5nZURpZmY7XG4gICAgICB2YXIgZmlyc3RBbmNob3IgPSBhbmNob3JzWzBdO1xuICAgICAgcmV0dXJuIG5ldyBBbmNob3JQb2ludCh7XG4gICAgICAgIGluZGV4OiBmaXJzdEFuY2hvci5pbmRleCxcbiAgICAgICAgcG9zaXRpb246IGZpcnN0QW5jaG9yLnBvc2l0aW9uICsgcmFuZ2VEaWZmLFxuICAgICAgICBwYW5lbDogZmlyc3RBbmNob3IucGFuZWxcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgLyoqXHJcbiAgICogUmV0dXJuIHRoZSBjYW1lcmEncyBwb3NpdGlvbiBwcm9ncmVzcyBpbiB0aGUgcGFuZWwgYmVsb3dcclxuICAgKiBWYWx1ZSBpcyBmcm9tIDAgdG8gMSB3aGVuIHRoZSBjYW1lcmEncyBpbnNpZGUgcGFuZWxcclxuICAgKiBWYWx1ZSBjYW4gYmUgbG93ZXIgdGhhbiAwIG9yIGJpZ2dlciB0aGFuIDEgd2hlbiBpdCdzIGluIHRoZSBtYXJnaW4gYXJlYVxyXG4gICAqIEBrbyDtmITsnqwg7Lm066mU6528IOyVhOuemCDtjKjrhJDsl5DshJzsnZgg7JyE7LmYIOynhO2WieuPhOulvCDrsJjtmZjtlanri4jri6RcclxuICAgKiDrsJjtmZjqsJLsnYAg7Lm066mU65286rCAIO2MqOuEkCDrgrTrtoDsl5Ag7J6I7J2EIOqyveyasCAw67aA7YSwIDHquYzsp4DsnZgg6rCS7J2EIOqwluyKteuLiOuLpFxyXG4gICAqIO2MqOuEkOydmCBtYXJnaW4g7JiB7Jet7JeQIOyeiOydhCDqsr3smrAgMOuztOuLpCDsnpHqsbDrgpggMeuztOuLpCDtgbAg6rCS7J2EIOuwmO2ZmO2VoCDsiJgg7J6I7Iq164uI64ukXHJcbiAgICovXG4gIF9fcHJvdG8uZ2V0UHJvZ3Jlc3NJblBhbmVsID0gZnVuY3Rpb24gKHBhbmVsKSB7XG4gICAgdmFyIHBhbmVsUmFuZ2UgPSBwYW5lbC5yYW5nZTtcbiAgICByZXR1cm4gKHRoaXMuX3Bvc2l0aW9uIC0gcGFuZWxSYW5nZS5taW4pIC8gKHBhbmVsUmFuZ2UubWF4IC0gcGFuZWxSYW5nZS5taW4pO1xuICB9O1xuICAvKipcclxuICAgKiBSZXR1cm4ge0BsaW5rIEFuY2hvclBvaW50fSB0aGF0IGluY2x1ZGVzIGdpdmVuIHBvc2l0aW9uXHJcbiAgICogSWYgdGhlcmUncyBubyB7QGxpbmsgQW5jaG9yUG9pbnR9IHRoYXQgaW5jbHVkZXMgdGhlIGdpdmVuIHBvc2l0aW9uLCByZXR1cm4gYG51bGxgIGluc3RlYWRcclxuICAgKiBAa28g7KO87Ja07KeEIOyijO2RnOulvCDtj6ztlajtlZjripQge0BsaW5rIEFuY2hvclBvaW50feulvCDrsJjtmZjtlanri4jri6RcclxuICAgKiDso7zslrTsp4Qg7KKM7ZGc66W8IO2PrO2VqO2VmOuKlCB7QGxpbmsgQW5jaG9yUG9pbnR96rCAIOyXhuydhCDqsr3smrAgYG51bGxg7J2EIOuwmO2ZmO2VqeuLiOuLpFxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwb3NpdGlvbiBBIHBvc2l0aW9uIHRvIGNoZWNrPGtvPu2ZleyduO2VoCDsooztkZw8L2tvPlxyXG4gICAqIEByZXR1cm4ge0FuY2hvclBvaW50IHwgbnVsbH0gVGhlIHtAbGluayBBbmNob3JQb2ludH0gdGhhdCBpbmNsdWRlcyB0aGUgZ2l2ZW4gcG9zaXRpb248a28+7ZW064u5IOyijO2RnOulvCDtj6ztlajtlZjripQge0BsaW5rIEFuY2hvclBvaW50fTwva28+XHJcbiAgICovXG4gIF9fcHJvdG8uZmluZEFuY2hvckluY2x1ZGVQb3NpdGlvbiA9IGZ1bmN0aW9uIChwb3NpdGlvbikge1xuICAgIHJldHVybiB0aGlzLl9tb2RlLmZpbmRBbmNob3JJbmNsdWRlUG9zaXRpb24ocG9zaXRpb24pO1xuICB9O1xuICAvKipcclxuICAgKiBSZXR1cm4ge0BsaW5rIEFuY2hvclBvaW50fSBuZWFyZXN0IHRvIGdpdmVuIHBvc2l0aW9uXHJcbiAgICogSWYgdGhlcmUncmUgbm8ge0BsaW5rIEFuY2hvclBvaW50fXMsIHJldHVybiBgbnVsbGAgaW5zdGVhZFxyXG4gICAqIEBrbyDtlbTri7kg7KKM7ZGc7JeQ7IScIOqwgOyepSDqsIDquYzsmrQge0BsaW5rIEFuY2hvclBvaW50feulvCDrsJjtmZjtlanri4jri6RcclxuICAgKiB7QGxpbmsgQW5jaG9yUG9pbnR96rCAIO2VmOuCmOuPhCDsl4bsnYQg6rK97JqwIGBudWxsYOydhCDrsJjtmZjtlanri4jri6RcclxuICAgKiBAcGFyYW0ge251bWJlcn0gcG9zaXRpb24gQSBwb3NpdGlvbiB0byBjaGVjazxrbz7tmZXsnbjtlaAg7KKM7ZGcPC9rbz5cclxuICAgKiBAcmV0dXJuIHtBbmNob3JQb2ludCB8IG51bGx9IFRoZSB7QGxpbmsgQW5jaG9yUG9pbnR9IG5lYXJlc3QgdG8gdGhlIGdpdmVuIHBvc2l0aW9uPGtvPu2VtOuLuSDsooztkZzsl5Ag6rCA7J6lIOyduOygke2VnCB7QGxpbmsgQW5jaG9yUG9pbnR9PC9rbz5cclxuICAgKi9cbiAgX19wcm90by5maW5kTmVhcmVzdEFuY2hvciA9IGZ1bmN0aW9uIChwb3NpdGlvbikge1xuICAgIHJldHVybiB0aGlzLl9tb2RlLmZpbmROZWFyZXN0QW5jaG9yKHBvc2l0aW9uKTtcbiAgfTtcbiAgLyoqXHJcbiAgICogUmV0dXJuIHtAbGluayBBbmNob3JQb2ludH0gdGhhdCBtYXRjaGVzIHtAbGluayBGbGlja2luZyNjdXJyZW50UGFuZWx9XHJcbiAgICogQGtvIO2YhOyerCB7QGxpbmsgRmxpY2tpbmcjY3VycmVudFBhbmVsfeyXkCDtlbTri7ntlZjripQge0BsaW5rIEFuY2hvclBvaW50feulvCDrsJjtmZjtlanri4jri6RcclxuICAgKiBAcmV0dXJuIHtBbmNob3JQb2ludCB8IG51bGx9XHJcbiAgICovXG4gIF9fcHJvdG8uZmluZEFjdGl2ZUFuY2hvciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX2E7XG4gICAgdmFyIGZsaWNraW5nID0gZ2V0RmxpY2tpbmdBdHRhY2hlZCh0aGlzLl9mbGlja2luZyk7XG4gICAgdmFyIGFjdGl2ZVBhbmVsID0gZmxpY2tpbmcuY29udHJvbC5hY3RpdmVQYW5lbDtcbiAgICBpZiAoIWFjdGl2ZVBhbmVsKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gKF9hID0gZmluZCQxKHRoaXMuX2FuY2hvcnMsIGZ1bmN0aW9uIChhbmNob3IpIHtcbiAgICAgIHJldHVybiBhbmNob3IucGFuZWwuaW5kZXggPT09IGFjdGl2ZVBhbmVsLmluZGV4O1xuICAgIH0pKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLmZpbmROZWFyZXN0QW5jaG9yKGFjdGl2ZVBhbmVsLnBvc2l0aW9uKTtcbiAgfTtcbiAgLyoqXHJcbiAgICogQ2xhbXAgdGhlIGdpdmVuIHBvc2l0aW9uIGJldHdlZW4gY2FtZXJhJ3MgcmFuZ2VcclxuICAgKiBAa28g7KO87Ja07KeEIOyijO2RnOulvCBDYW1lcmHqsIAg64+E64usIOqwgOuKpe2VnCDrspTsnIQg7IKs7J207J2YIOqwkuycvOuhnCDrp4zrk63ri4jri6RcclxuICAgKiBAcGFyYW0ge251bWJlcn0gcG9zaXRpb24gQSBwb3NpdGlvbiB0byBjbGFtcDxrbz7rspTsnITrpbwg7KCc7ZWc7ZWgIOyijO2RnDwva28+XHJcbiAgICogQHJldHVybiB7bnVtYmVyfSBBIGNsYW1wZWQgcG9zaXRpb248a28+67KU7JyEIOygnO2VnOuQnCDsooztkZw8L2tvPlxyXG4gICAqL1xuICBfX3Byb3RvLmNsYW1wVG9SZWFjaGFibGVQb3NpdGlvbiA9IGZ1bmN0aW9uIChwb3NpdGlvbikge1xuICAgIHJldHVybiB0aGlzLl9tb2RlLmNsYW1wVG9SZWFjaGFibGVQb3NpdGlvbihwb3NpdGlvbik7XG4gIH07XG4gIC8qKlxyXG4gICAqIENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHBhbmVsIGlzIGluc2lkZSBvZiB0aGUgQ2FtZXJhJ3MgcmFuZ2VcclxuICAgKiBAa28g7ZW064u5IHtAbGluayBQYW5lbH3snbQgQ2FtZXJh6rCAIOuPhOuLrCDqsIDriqXtlZwg67KU7JyEIOuCtOyXkCDsnojripTsp4Drpbwg67CY7ZmY7ZWp64uI64ukXHJcbiAgICogQHBhcmFtIHBhbmVsIEFuIGluc3RhbmNlIG9mIHtAbGluayBQYW5lbH0gdG8gY2hlY2s8a28+7ZmV7J247ZWgIHtAbGluayBQYW5lbH3snZgg7J247Iqk7YS07IqkPC9rbz5cclxuICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBwYW5lbCdzIGluc2lkZSBDYW1lcmEncyByYW5nZTxrbz7rj4Tri6wg6rCA64ql7ZWcIOuylOychCDrgrTsl5Ag7ZW064u5IO2MqOuEkOydtCDsobTsnqztlZjripTsp4Ag7Jes67aAPC9rbz5cclxuICAgKi9cbiAgX19wcm90by5jYW5SZWFjaCA9IGZ1bmN0aW9uIChwYW5lbCkge1xuICAgIHJldHVybiB0aGlzLl9tb2RlLmNhblJlYWNoKHBhbmVsKTtcbiAgfTtcbiAgLyoqXHJcbiAgICogQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gcGFuZWwgZWxlbWVudCBpcyB2aXNpYmxlIGF0IHRoZSBjdXJyZW50IHBvc2l0aW9uXHJcbiAgICogQGtvIO2YhOyerCDsooztkZzsl5DshJwg7ZW064u5IO2MqOuEkCDsl5jrpqzrqLztirjrpbwg67O8IOyImCDsnojripTsp4Ag7Jes67aA66W8IOuwmO2ZmO2VqeuLiOuLpFxyXG4gICAqIEBwYXJhbSBwYW5lbCBBbiBpbnN0YW5jZSBvZiB7QGxpbmsgUGFuZWx9IHRvIGNoZWNrPGtvPu2ZleyduO2VoCB7QGxpbmsgUGFuZWx97J2YIOyduOyKpO2EtOyKpDwva28+XHJcbiAgICogQHJldHVybiBXaGV0aGVyIHRoZSBwYW5lbCBlbGVtZW50IGlzIHZpc2libGUgYXQgdGhlIGN1cnJlbnQgcG9zaXRpb248a28+7ZiE7J6sIOychOy5mOyXkOyEnCDtlbTri7kg7Yyo64SQIOyXmOumrOuovO2KuOqwgCDrs7TsnbTripTsp4Ag7Jes67aAPC9rbz5cclxuICAgKi9cbiAgX19wcm90by5jYW5TZWUgPSBmdW5jdGlvbiAocGFuZWwpIHtcbiAgICByZXR1cm4gdGhpcy5fbW9kZS5jYW5TZWUocGFuZWwpO1xuICB9O1xuICAvKipcclxuICAgKiBVcGRhdGUge0BsaW5rIENhbWVyYSNyYW5nZSByYW5nZX0gb2YgQ2FtZXJhXHJcbiAgICogQGtvIENhbWVyYeydmCB7QGxpbmsgQ2FtZXJhI3JhbmdlIHJhbmdlfeulvCDsl4XrjbDsnbTtirjtlanri4jri6RcclxuICAgKiBAbWV0aG9kXHJcbiAgICogQGFic3RyYWN0XHJcbiAgICogQG1lbWJlcm9mIENhbWVyYVxyXG4gICAqIEBpbnN0YW5jZVxyXG4gICAqIEBuYW1lIHVwZGF0ZVJhbmdlXHJcbiAgICogQGNoYWluYWJsZVxyXG4gICAqIEB0aHJvd3Mge0ZsaWNraW5nRXJyb3J9XHJcbiAgICoge0BsaW5rIEVSUk9SX0NPREUgTk9UX0FUVEFDSEVEX1RPX0ZMSUNLSU5HfSBXaGVuIHtAbGluayBDYW1lcmEjaW5pdCBpbml0fSBpcyBub3QgY2FsbGVkIGJlZm9yZVxyXG4gICAqIDxrbz57QGxpbmsgRVJST1JfQ09ERSBOT1RfQVRUQUNIRURfVE9fRkxJQ0tJTkd9IHtAbGluayBDYW1lcmEjaW5pdCBpbml0feydtCDsnbTsoITsl5Ag7Zi47Lac65CY7KeAIOyViuydgCDqsr3smrA8L2tvPlxyXG4gICAqIEByZXR1cm4ge3RoaXN9XHJcbiAgICovXG4gIF9fcHJvdG8udXBkYXRlUmFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZsaWNraW5nID0gZ2V0RmxpY2tpbmdBdHRhY2hlZCh0aGlzLl9mbGlja2luZyk7XG4gICAgdmFyIHJlbmRlcmVyID0gZmxpY2tpbmcucmVuZGVyZXI7XG4gICAgdmFyIHBhbmVscyA9IHJlbmRlcmVyLnBhbmVscztcbiAgICB0aGlzLl91cGRhdGVNb2RlKCk7XG4gICAgdGhpcy5fcmFuZ2UgPSB0aGlzLl9tb2RlLmdldFJhbmdlKCk7XG4gICAgcGFuZWxzLmZvckVhY2goZnVuY3Rpb24gKHBhbmVsKSB7XG4gICAgICByZXR1cm4gcGFuZWwudXBkYXRlQ2lyY3VsYXJUb2dnbGVEaXJlY3Rpb24oKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXHJcbiAgICogVXBkYXRlIENhbWVyYSdzIHtAbGluayBDYW1lcmEjYWxpZ25Qb3NpdGlvbiBhbGlnblBvc2l0aW9ufVxyXG4gICAqIEBrbyBDYW1lcmHsnZgge0BsaW5rIENhbWVyYSNhbGlnblBvc2l0aW9uIGFsaWduUG9zaXRpb2597J2EIOyXheuNsOydtO2KuO2VqeuLiOuLpFxyXG4gICAqIEBjaGFpbmFibGVcclxuICAgKiBAcmV0dXJuIHt0aGlzfVxyXG4gICAqL1xuICBfX3Byb3RvLnVwZGF0ZUFsaWduUG9zID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhbGlnbiA9IHRoaXMuX2FsaWduO1xuICAgIHZhciBhbGlnblZhbCA9IHR5cGVvZiBhbGlnbiA9PT0gXCJvYmplY3RcIiA/IGFsaWduLmNhbWVyYSA6IGFsaWduO1xuICAgIHRoaXMuX2FsaWduUG9zID0gcGFyc2VBbGlnbiQxKGFsaWduVmFsLCB0aGlzLnNpemUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcclxuICAgKiBVcGRhdGUgQ2FtZXJhJ3Mge0BsaW5rIENhbWVyYSNhbmNob3JQb2ludHMgYW5jaG9yUG9pbnRzfVxyXG4gICAqIEBrbyBDYW1lcmHsnZgge0BsaW5rIENhbWVyYSNhbmNob3JQb2ludHMgYW5jaG9yUG9pbnRzfeulvCDsl4XrjbDsnbTtirjtlanri4jri6RcclxuICAgKiBAdGhyb3dzIHtGbGlja2luZ0Vycm9yfVxyXG4gICAqIHtAbGluayBFUlJPUl9DT0RFIE5PVF9BVFRBQ0hFRF9UT19GTElDS0lOR30gV2hlbiB7QGxpbmsgQ2FtZXJhI2luaXQgaW5pdH0gaXMgbm90IGNhbGxlZCBiZWZvcmVcclxuICAgKiA8a28+e0BsaW5rIEVSUk9SX0NPREUgTk9UX0FUVEFDSEVEX1RPX0ZMSUNLSU5HfSB7QGxpbmsgQ2FtZXJhI2luaXQgaW5pdH3snbQg7J207KCE7JeQIO2YuOy2nOuQmOyngCDslYrsnYAg6rK97JqwPC9rbz5cclxuICAgKiBAY2hhaW5hYmxlXHJcbiAgICogQHJldHVybiB7dGhpc31cclxuICAgKi9cbiAgX19wcm90by51cGRhdGVBbmNob3JzID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2FuY2hvcnMgPSB0aGlzLl9tb2RlLmdldEFuY2hvcnMoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXHJcbiAgICogVXBkYXRlIFZpZXdwb3J0J3MgaGVpZ2h0IHRvIGFjdGl2ZSBwYW5lbCdzIGhlaWdodFxyXG4gICAqIEBrbyDtmITsnqwg7ISg7YOd65CcIO2MqOuEkOydmCDrhpLsnbTsmYAg64+Z7J287ZWY64+E66GdIOu3sO2PrO2KuOydmCDrhpLsnbTrpbwg7JeF642w7J207Yq47ZWp64uI64ukXHJcbiAgICogQHRocm93cyB7RmxpY2tpbmdFcnJvcn1cclxuICAgKiB7QGxpbmsgRVJST1JfQ09ERSBOT1RfQVRUQUNIRURfVE9fRkxJQ0tJTkd9IFdoZW4ge0BsaW5rIENhbWVyYSNpbml0IGluaXR9IGlzIG5vdCBjYWxsZWQgYmVmb3JlXHJcbiAgICogPGtvPntAbGluayBFUlJPUl9DT0RFIE5PVF9BVFRBQ0hFRF9UT19GTElDS0lOR30ge0BsaW5rIENhbWVyYSNpbml0IGluaXR97J20IOydtOyghOyXkCDtmLjstpzrkJjsp4Ag7JWK7J2AIOqyveyasDwva28+XHJcbiAgICogQGNoYWluYWJsZVxyXG4gICAqIEByZXR1cm4ge3RoaXN9XHJcbiAgICovXG4gIF9fcHJvdG8udXBkYXRlQWRhcHRpdmVIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZsaWNraW5nID0gZ2V0RmxpY2tpbmdBdHRhY2hlZCh0aGlzLl9mbGlja2luZyk7XG4gICAgdmFyIGFjdGl2ZVBhbmVsID0gZmxpY2tpbmcuY29udHJvbC5hY3RpdmVQYW5lbDtcbiAgICBpZiAoIWZsaWNraW5nLmhvcml6b250YWwgfHwgIWZsaWNraW5nLmFkYXB0aXZlIHx8ICFhY3RpdmVQYW5lbCkgcmV0dXJuO1xuICAgIGZsaWNraW5nLnZpZXdwb3J0LnNldFNpemUoe1xuICAgICAgaGVpZ2h0OiBhY3RpdmVQYW5lbC5oZWlnaHRcbiAgICB9KTtcbiAgfTtcbiAgLyoqXHJcbiAgICogVXBkYXRlIGN1cnJlbnQgb2Zmc2V0IG9mIHRoZSBjYW1lcmFcclxuICAgKiBAa28g7ZiE7J6sIOy5tOuplOudvOydmCDsmKTtlITshYvsnYQg7JeF642w7J207Yq47ZWp64uI64ukXHJcbiAgICogQGNoYWluYWJsZVxyXG4gICAqIEByZXR1cm4ge3RoaXN9XHJcbiAgICovXG4gIF9fcHJvdG8udXBkYXRlT2Zmc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBmbGlja2luZyA9IGdldEZsaWNraW5nQXR0YWNoZWQodGhpcy5fZmxpY2tpbmcpO1xuICAgIHZhciBwb3NpdGlvbiA9IHRoaXMuX3Bvc2l0aW9uO1xuICAgIHZhciB1blJlbmRlcmVkUGFuZWxzID0gZmxpY2tpbmcucGFuZWxzLmZpbHRlcihmdW5jdGlvbiAocGFuZWwpIHtcbiAgICAgIHJldHVybiAhcGFuZWwucmVuZGVyZWQ7XG4gICAgfSk7XG4gICAgdGhpcy5fb2Zmc2V0ID0gdW5SZW5kZXJlZFBhbmVscy5maWx0ZXIoZnVuY3Rpb24gKHBhbmVsKSB7XG4gICAgICByZXR1cm4gcGFuZWwucG9zaXRpb24gKyBwYW5lbC5vZmZzZXQgPCBwb3NpdGlvbjtcbiAgICB9KS5yZWR1Y2UoZnVuY3Rpb24gKG9mZnNldCwgcGFuZWwpIHtcbiAgICAgIHJldHVybiBvZmZzZXQgKyBwYW5lbC5zaXplSW5jbHVkaW5nTWFyZ2luO1xuICAgIH0sIDApO1xuICAgIHRoaXMuX2NpcmN1bGFyT2Zmc2V0ID0gdGhpcy5fbW9kZS5nZXRDaXJjdWxhck9mZnNldCgpO1xuICAgIHRoaXMuYXBwbHlUcmFuc2Zvcm0oKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXHJcbiAgICogVXBkYXRlIGRpcmVjdGlvbiB0byBtYXRjaCB0aGUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9kaXJlY3Rpb24gZGlyZWN0aW9ufSBDU1MgcHJvcGVydHkgYXBwbGllZCB0byB0aGUgY2FtZXJhIGVsZW1lbnRcclxuICAgKiBAa28g7Lm066mU6528IOyXmOumrOuovO2KuOyXkCDsoIHsmqnrkJwge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9kaXJlY3Rpb24gZGlyZWN0aW9ufSBDU1Mg7IaN7ISx7JeQIOunnuqyjCDrsKntlqXsnYQg7JeF642w7J207Yq47ZWp64uI64ukXHJcbiAgICogQHJldHVybiB7dGhpc31cclxuICAgKi9cbiAgX19wcm90by51cGRhdGVQYW5lbE9yZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBmbGlja2luZyA9IGdldEZsaWNraW5nQXR0YWNoZWQodGhpcy5fZmxpY2tpbmcpO1xuICAgIGlmICghZmxpY2tpbmcuaG9yaXpvbnRhbCkgcmV0dXJuIHRoaXM7XG4gICAgdmFyIGVsID0gdGhpcy5fZWw7XG4gICAgdmFyIGRpcmVjdGlvbiA9IGdldFN0eWxlKGVsKS5kaXJlY3Rpb247XG4gICAgaWYgKGRpcmVjdGlvbiAhPT0gdGhpcy5fcGFuZWxPcmRlcikge1xuICAgICAgdGhpcy5fcGFuZWxPcmRlciA9IGRpcmVjdGlvbiA9PT0gT1JERVIuUlRMID8gT1JERVIuUlRMIDogT1JERVIuTFRSO1xuICAgICAgaWYgKGZsaWNraW5nLmluaXRpYWxpemVkKSB7XG4gICAgICAgIGZsaWNraW5nLmNvbnRyb2wuY29udHJvbGxlci51cGRhdGVEaXJlY3Rpb24oKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxyXG4gICAqIFJlc2V0IHRoZSBoaXN0b3J5IG9mIHtAbGluayBGbGlja2luZyNldmVudDpuZWVkUGFuZWwgbmVlZFBhbmVsfSBldmVudHMgc28gaXQgY2FuIGJlIHRyaWdnZXJlZCBhZ2FpblxyXG4gICAqIEBrbyDrsJzsg53tlZwge0BsaW5rIEZsaWNraW5nI2V2ZW50Om5lZWRQYW5lbCBuZWVkUGFuZWx9IOydtOuypO2KuOuTpOydhCDstIjquLDtmZTtlZjsl6wg64uk7IucIOuwnOyDne2VoCDsiJgg7J6I64+E66GdIO2VqeuLiOuLpFxyXG4gICAqIEBjaGFpbmFibGVcclxuICAgKiBAcmV0dXJuIHt0aGlzfVxyXG4gICAqL1xuICBfX3Byb3RvLnJlc2V0TmVlZFBhbmVsSGlzdG9yeSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9uZWVkUGFuZWxUcmlnZ2VyZWQgPSB7XG4gICAgICBwcmV2OiBmYWxzZSxcbiAgICAgIG5leHQ6IGZhbHNlXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXHJcbiAgICogQXBwbHkgXCJ0cmFuc2Zvcm1cIiBzdHlsZSB3aXRoIHRoZSBjdXJyZW50IHBvc2l0aW9uIHRvIGNhbWVyYSBlbGVtZW50XHJcbiAgICogQGtvIO2YhOyerCDsnITsuZjrpbwg6riw7KSA7Jy866Gc7ZWcIHRyYW5zZm9ybSDsiqTtg4DsnbzsnYQg7Lm066mU6528IOyXmOumrOuovO2KuOyXkCDsoIHsmqntlanri4jri6QuXHJcbiAgICogQHJldHVybiB7dGhpc31cclxuICAgKi9cbiAgX19wcm90by5hcHBseVRyYW5zZm9ybSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZWwgPSB0aGlzLl9lbDtcbiAgICB2YXIgZmxpY2tpbmcgPSBnZXRGbGlja2luZ0F0dGFjaGVkKHRoaXMuX2ZsaWNraW5nKTtcbiAgICB2YXIgcmVuZGVyZXIgPSBmbGlja2luZy5yZW5kZXJlcjtcbiAgICBpZiAocmVuZGVyZXIucmVuZGVyaW5nIHx8ICFmbGlja2luZy5pbml0aWFsaXplZCkgcmV0dXJuIHRoaXM7XG4gICAgdmFyIGFjdHVhbFBvc2l0aW9uID0gdGhpcy5fcG9zaXRpb24gLSB0aGlzLl9hbGlnblBvcyAtIHRoaXMuX29mZnNldCArIHRoaXMuX2NpcmN1bGFyT2Zmc2V0O1xuICAgIGVsLnN0eWxlW3RoaXMuX3RyYW5zZm9ybV0gPSBmbGlja2luZy5ob3Jpem9udGFsID8gXCJ0cmFuc2xhdGUoXCIgKyAodGhpcy5fcGFuZWxPcmRlciA9PT0gT1JERVIuUlRMID8gYWN0dWFsUG9zaXRpb24gOiAtYWN0dWFsUG9zaXRpb24pICsgXCJweClcIiA6IFwidHJhbnNsYXRlKDAsIFwiICsgLWFjdHVhbFBvc2l0aW9uICsgXCJweClcIjtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgX19wcm90by5fcmVzZXRJbnRlcm5hbFZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9wb3NpdGlvbiA9IDA7XG4gICAgdGhpcy5fYWxpZ25Qb3MgPSAwO1xuICAgIHRoaXMuX29mZnNldCA9IDA7XG4gICAgdGhpcy5fY2lyY3VsYXJPZmZzZXQgPSAwO1xuICAgIHRoaXMuX2NpcmN1bGFyRW5hYmxlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JhbmdlID0ge1xuICAgICAgbWluOiAwLFxuICAgICAgbWF4OiAwXG4gICAgfTtcbiAgICB0aGlzLl92aXNpYmxlUGFuZWxzID0gW107XG4gICAgdGhpcy5fYW5jaG9ycyA9IFtdO1xuICAgIHRoaXMuX25lZWRQYW5lbFRyaWdnZXJlZCA9IHtcbiAgICAgIHByZXY6IGZhbHNlLFxuICAgICAgbmV4dDogZmFsc2VcbiAgICB9O1xuICB9O1xuICBfX3Byb3RvLl9yZWZyZXNoVmlzaWJsZVBhbmVscyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHZhciBmbGlja2luZyA9IGdldEZsaWNraW5nQXR0YWNoZWQodGhpcy5fZmxpY2tpbmcpO1xuICAgIHZhciBwYW5lbHMgPSBmbGlja2luZy5yZW5kZXJlci5wYW5lbHM7XG4gICAgdmFyIG5ld1Zpc2libGVQYW5lbHMgPSBwYW5lbHMuZmlsdGVyKGZ1bmN0aW9uIChwYW5lbCkge1xuICAgICAgcmV0dXJuIF90aGlzLmNhblNlZShwYW5lbCk7XG4gICAgfSk7XG4gICAgdmFyIHByZXZWaXNpYmxlUGFuZWxzID0gdGhpcy5fdmlzaWJsZVBhbmVscztcbiAgICB0aGlzLl92aXNpYmxlUGFuZWxzID0gbmV3VmlzaWJsZVBhbmVscztcbiAgICB2YXIgYWRkZWQgPSBuZXdWaXNpYmxlUGFuZWxzLmZpbHRlcihmdW5jdGlvbiAocGFuZWwpIHtcbiAgICAgIHJldHVybiAhaW5jbHVkZXMocHJldlZpc2libGVQYW5lbHMsIHBhbmVsKTtcbiAgICB9KTtcbiAgICB2YXIgcmVtb3ZlZCA9IHByZXZWaXNpYmxlUGFuZWxzLmZpbHRlcihmdW5jdGlvbiAocGFuZWwpIHtcbiAgICAgIHJldHVybiAhaW5jbHVkZXMobmV3VmlzaWJsZVBhbmVscywgcGFuZWwpO1xuICAgIH0pO1xuICAgIGlmIChhZGRlZC5sZW5ndGggPiAwIHx8IHJlbW92ZWQubGVuZ3RoID4gMCkge1xuICAgICAgdm9pZCBmbGlja2luZy5yZW5kZXJlci5yZW5kZXIoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZmxpY2tpbmcudHJpZ2dlcihuZXcgQ29tcG9uZW50RXZlbnQkMShFVkVOVFMuVklTSUJMRV9DSEFOR0UsIHtcbiAgICAgICAgICBhZGRlZDogYWRkZWQsXG4gICAgICAgICAgcmVtb3ZlZDogcmVtb3ZlZCxcbiAgICAgICAgICB2aXNpYmxlUGFuZWxzOiBuZXdWaXNpYmxlUGFuZWxzXG4gICAgICAgIH0pKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgX19wcm90by5fY2hlY2tOZWVkUGFuZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG5lZWRQYW5lbFRyaWdnZXJlZCA9IHRoaXMuX25lZWRQYW5lbFRyaWdnZXJlZDtcbiAgICBpZiAobmVlZFBhbmVsVHJpZ2dlcmVkLnByZXYgJiYgbmVlZFBhbmVsVHJpZ2dlcmVkLm5leHQpIHJldHVybjtcbiAgICB2YXIgZmxpY2tpbmcgPSBnZXRGbGlja2luZ0F0dGFjaGVkKHRoaXMuX2ZsaWNraW5nKTtcbiAgICB2YXIgcGFuZWxzID0gZmxpY2tpbmcucmVuZGVyZXIucGFuZWxzO1xuICAgIGlmIChwYW5lbHMubGVuZ3RoIDw9IDApIHtcbiAgICAgIGlmICghbmVlZFBhbmVsVHJpZ2dlcmVkLnByZXYpIHtcbiAgICAgICAgZmxpY2tpbmcudHJpZ2dlcihuZXcgQ29tcG9uZW50RXZlbnQkMShFVkVOVFMuTkVFRF9QQU5FTCwge1xuICAgICAgICAgIGRpcmVjdGlvbjogRElSRUNUSU9OLlBSRVZcbiAgICAgICAgfSkpO1xuICAgICAgICBuZWVkUGFuZWxUcmlnZ2VyZWQucHJldiA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoIW5lZWRQYW5lbFRyaWdnZXJlZC5uZXh0KSB7XG4gICAgICAgIGZsaWNraW5nLnRyaWdnZXIobmV3IENvbXBvbmVudEV2ZW50JDEoRVZFTlRTLk5FRURfUEFORUwsIHtcbiAgICAgICAgICBkaXJlY3Rpb246IERJUkVDVElPTi5ORVhUXG4gICAgICAgIH0pKTtcbiAgICAgICAgbmVlZFBhbmVsVHJpZ2dlcmVkLm5leHQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgY2FtZXJhUG9zaXRpb24gPSB0aGlzLl9wb3NpdGlvbjtcbiAgICB2YXIgY2FtZXJhU2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICB2YXIgY2FtZXJhUmFuZ2UgPSB0aGlzLl9yYW5nZTtcbiAgICB2YXIgbmVlZFBhbmVsVGhyZXNob2xkID0gZmxpY2tpbmcubmVlZFBhbmVsVGhyZXNob2xkO1xuICAgIHZhciBjYW1lcmFQcmV2ID0gY2FtZXJhUG9zaXRpb24gLSB0aGlzLl9hbGlnblBvcztcbiAgICB2YXIgY2FtZXJhTmV4dCA9IGNhbWVyYVByZXYgKyBjYW1lcmFTaXplO1xuICAgIHZhciBmaXJzdFBhbmVsID0gcGFuZWxzWzBdO1xuICAgIHZhciBsYXN0UGFuZWwgPSBwYW5lbHNbcGFuZWxzLmxlbmd0aCAtIDFdO1xuICAgIGlmICghbmVlZFBhbmVsVHJpZ2dlcmVkLnByZXYpIHtcbiAgICAgIHZhciBmaXJzdFBhbmVsUHJldiA9IGZpcnN0UGFuZWwucmFuZ2UubWluO1xuICAgICAgaWYgKGNhbWVyYVByZXYgPD0gZmlyc3RQYW5lbFByZXYgKyBuZWVkUGFuZWxUaHJlc2hvbGQgfHwgY2FtZXJhUG9zaXRpb24gPD0gY2FtZXJhUmFuZ2UubWluICsgbmVlZFBhbmVsVGhyZXNob2xkKSB7XG4gICAgICAgIGZsaWNraW5nLnRyaWdnZXIobmV3IENvbXBvbmVudEV2ZW50JDEoRVZFTlRTLk5FRURfUEFORUwsIHtcbiAgICAgICAgICBkaXJlY3Rpb246IERJUkVDVElPTi5QUkVWXG4gICAgICAgIH0pKTtcbiAgICAgICAgbmVlZFBhbmVsVHJpZ2dlcmVkLnByZXYgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIW5lZWRQYW5lbFRyaWdnZXJlZC5uZXh0KSB7XG4gICAgICB2YXIgbGFzdFBhbmVsTmV4dCA9IGxhc3RQYW5lbC5yYW5nZS5tYXg7XG4gICAgICBpZiAoY2FtZXJhTmV4dCA+PSBsYXN0UGFuZWxOZXh0IC0gbmVlZFBhbmVsVGhyZXNob2xkIHx8IGNhbWVyYVBvc2l0aW9uID49IGNhbWVyYVJhbmdlLm1heCAtIG5lZWRQYW5lbFRocmVzaG9sZCkge1xuICAgICAgICBmbGlja2luZy50cmlnZ2VyKG5ldyBDb21wb25lbnRFdmVudCQxKEVWRU5UUy5ORUVEX1BBTkVMLCB7XG4gICAgICAgICAgZGlyZWN0aW9uOiBESVJFQ1RJT04uTkVYVFxuICAgICAgICB9KSk7XG4gICAgICAgIG5lZWRQYW5lbFRyaWdnZXJlZC5uZXh0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIF9fcHJvdG8uX2NoZWNrUmVhY2hFbmQgPSBmdW5jdGlvbiAocHJldlBvcywgbmV3UG9zKSB7XG4gICAgdmFyIGZsaWNraW5nID0gZ2V0RmxpY2tpbmdBdHRhY2hlZCh0aGlzLl9mbGlja2luZyk7XG4gICAgdmFyIHJhbmdlID0gdGhpcy5fcmFuZ2U7XG4gICAgdmFyIHdhc0JldHdlZW5SYW5nZSA9IHByZXZQb3MgPiByYW5nZS5taW4gJiYgcHJldlBvcyA8IHJhbmdlLm1heDtcbiAgICB2YXIgaXNCZXR3ZWVuUmFuZ2UgPSBuZXdQb3MgPiByYW5nZS5taW4gJiYgbmV3UG9zIDwgcmFuZ2UubWF4O1xuICAgIGlmICghd2FzQmV0d2VlblJhbmdlIHx8IGlzQmV0d2VlblJhbmdlKSByZXR1cm47XG4gICAgdmFyIGRpcmVjdGlvbiA9IG5ld1BvcyA8PSByYW5nZS5taW4gPyBESVJFQ1RJT04uUFJFViA6IERJUkVDVElPTi5ORVhUO1xuICAgIGZsaWNraW5nLnRyaWdnZXIobmV3IENvbXBvbmVudEV2ZW50JDEoRVZFTlRTLlJFQUNIX0VER0UsIHtcbiAgICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uXG4gICAgfSkpO1xuICB9O1xuICBfX3Byb3RvLl91cGRhdGVNb2RlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBmbGlja2luZyA9IGdldEZsaWNraW5nQXR0YWNoZWQodGhpcy5fZmxpY2tpbmcpO1xuICAgIGlmIChmbGlja2luZy5jaXJjdWxhcikge1xuICAgICAgdmFyIGNpcmN1bGFyTW9kZSA9IG5ldyBDaXJjdWxhckNhbWVyYU1vZGUoZmxpY2tpbmcpO1xuICAgICAgdmFyIGNhblNldENpcmN1bGFyTW9kZSA9IGNpcmN1bGFyTW9kZS5jaGVja0F2YWlsYWJpbGl0eSgpO1xuICAgICAgaWYgKGNhblNldENpcmN1bGFyTW9kZSkge1xuICAgICAgICB0aGlzLl9tb2RlID0gY2lyY3VsYXJNb2RlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGZhbGxiYWNrTW9kZSA9IGZsaWNraW5nLmNpcmN1bGFyRmFsbGJhY2s7XG4gICAgICAgIHRoaXMuX21vZGUgPSBmYWxsYmFja01vZGUgPT09IENJUkNVTEFSX0ZBTExCQUNLLkJPVU5EID8gbmV3IEJvdW5kQ2FtZXJhTW9kZShmbGlja2luZykgOiBuZXcgTGluZWFyQ2FtZXJhTW9kZShmbGlja2luZyk7XG4gICAgICB9XG4gICAgICB0aGlzLl9jaXJjdWxhckVuYWJsZWQgPSBjYW5TZXRDaXJjdWxhck1vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX21vZGUgPSBmbGlja2luZy5ib3VuZCA/IG5ldyBCb3VuZENhbWVyYU1vZGUoZmxpY2tpbmcpIDogbmV3IExpbmVhckNhbWVyYU1vZGUoZmxpY2tpbmcpO1xuICAgICAgdGhpcy5fY2lyY3VsYXJFbmFibGVkID0gZmFsc2U7XG4gICAgfVxuICB9O1xuICBfX3Byb3RvLl90b2dnbGVQYW5lbHMgPSBmdW5jdGlvbiAocHJldlBvcywgcG9zKSB7XG4gICAgaWYgKHBvcyA9PT0gcHJldlBvcykgcmV0dXJuIGZhbHNlO1xuICAgIHZhciBmbGlja2luZyA9IGdldEZsaWNraW5nQXR0YWNoZWQodGhpcy5fZmxpY2tpbmcpO1xuICAgIHZhciBwYW5lbHMgPSBmbGlja2luZy5yZW5kZXJlci5wYW5lbHM7XG4gICAgdmFyIHRvZ2dsZWQgPSBwYW5lbHMubWFwKGZ1bmN0aW9uIChwYW5lbCkge1xuICAgICAgcmV0dXJuIHBhbmVsLnRvZ2dsZShwcmV2UG9zLCBwb3MpO1xuICAgIH0pO1xuICAgIHJldHVybiB0b2dnbGVkLnNvbWUoZnVuY3Rpb24gKGlzVG9nZ2xlZCkge1xuICAgICAgcmV0dXJuIGlzVG9nZ2xlZDtcbiAgICB9KTtcbiAgfTtcbiAgcmV0dXJuIENhbWVyYTtcbn0oKTtcblxuLyoqXHJcbiAqIEEgY29tcG9uZW50IHRoYXQgbWFuYWdlcyB7QGxpbmsgUGFuZWx9IGFuZCBpdHMgZWxlbWVudHNcclxuICogQGtvIHtAbGluayBQYW5lbH3qs7wg6re4IOyXmOumrOuovO2KuOuTpOydhCDqtIDrpqztlZjripQg7Lu07Y+s64SM7Yq4XHJcbiAqL1xudmFyIFJlbmRlcmVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgQW4gb3B0aW9ucyBvYmplY3Q8a28+7Ji17IWYIOyYpOu4jOygne2KuDwva28+XHJcbiAgICogQHBhcmFtIHtDb25zdGFudHMuQUxJR04gfCBzdHJpbmcgfCBudW1iZXJ9IFtvcHRpb25zLmFsaWduPVwiY2VudGVyXCJdIEFuIHtAbGluayBGbGlja2luZyNhbGlnbiBhbGlnbn0gdmFsdWUgdGhhdCB3aWxsIGJlIGFwcGxpZWQgdG8gYWxsIHBhbmVsczxrbz7soITssrQg7Yyo64SQ7JeQIOyggeyaqeuQoCB7QGxpbmsgRmxpY2tpbmcjYWxpZ24gYWxpZ259IOqwkjwva28+XHJcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLnN0cmF0ZWd5XSBBbiBpbnN0YW5jZSBvZiBSZW5kZXJpbmdTdHJhdGVneShpbnRlcm5hbCBtb2R1bGUpPGtvPlJlbmRlcmluZ1N0cmF0ZWd57J2YIOyduOyKpO2EtOyKpCjrgrTrtoAg66qo65OIKTwva28+XHJcbiAgICovXG4gIGZ1bmN0aW9uIFJlbmRlcmVyKF9hKSB7XG4gICAgdmFyIF9iID0gX2EuYWxpZ24sXG4gICAgICBhbGlnbiA9IF9iID09PSB2b2lkIDAgPyBBTElHTi5DRU5URVIgOiBfYixcbiAgICAgIHN0cmF0ZWd5ID0gX2Euc3RyYXRlZ3k7XG4gICAgdGhpcy5fZmxpY2tpbmcgPSBudWxsO1xuICAgIHRoaXMuX3BhbmVscyA9IFtdO1xuICAgIHRoaXMuX3JlbmRlcmluZyA9IGZhbHNlO1xuICAgIC8vIEJpbmQgb3B0aW9uc1xuICAgIHRoaXMuX2FsaWduID0gYWxpZ247XG4gICAgdGhpcy5fc3RyYXRlZ3kgPSBzdHJhdGVneTtcbiAgfVxuICB2YXIgX19wcm90byA9IFJlbmRlcmVyLnByb3RvdHlwZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwicGFuZWxzXCIsIHtcbiAgICAvLyBJbnRlcm5hbCBzdGF0ZXMgR2V0dGVyXG4gICAgLyoqXHJcbiAgICAgKiBBcnJheSBvZiBwYW5lbHNcclxuICAgICAqIEBrbyDsoITssrQg7Yyo64SQ65Ok7J2YIOuwsOyXtFxyXG4gICAgICogQHR5cGUge1BhbmVsW119XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqIEBzZWUgUGFuZWxcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3BhbmVscztcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwicmVuZGVyaW5nXCIsIHtcbiAgICAvKipcclxuICAgICAqIEEgYm9vbGVhbiB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgcmVuZGVyaW5nIGlzIGluIHByb2dyZXNzXHJcbiAgICAgKiBAa28g7ZiE7J6sIOugjOuNlOungeydtCDsi5zsnpHrkJjslrQg64Gd64KY6riwIOyghOq5jOyngOydmCDsg4Htg5zsnbjsp4DsnZgg7Jes67aAXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJpbmc7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcInBhbmVsQ291bnRcIiwge1xuICAgIC8qKlxyXG4gICAgICogQ291bnQgb2YgcGFuZWxzXHJcbiAgICAgKiBAa28g7KCE7LK0IO2MqOuEkOydmCDqsJzsiJhcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3BhbmVscy5sZW5ndGg7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcInN0cmF0ZWd5XCIsIHtcbiAgICAvKipcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3RyYXRlZ3k7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcImFsaWduXCIsIHtcbiAgICAvLyBPcHRpb25zIEdldHRlclxuICAgIC8qKlxyXG4gICAgICogQSB7QGxpbmsgUGFuZWx9J3Mge0BsaW5rIFBhbmVsI2FsaWduIGFsaWdufSB2YWx1ZSB0aGF0IGFwcGxpZWQgdG8gYWxsIHBhbmVsc1xyXG4gICAgICogQGtvIHtAbGluayBQYW5lbH3sl5Ag6rO17Ya17KCB7Jy866GcIOyggeyaqe2VoCB7QGxpbmsgUGFuZWwjYWxpZ24gYWxpZ259IOqwklxyXG4gICAgICogQHR5cGUge0NvbnN0YW50cy5BTElHTiB8IHN0cmluZyB8IG51bWJlcn1cclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2FsaWduO1xuICAgIH0sXG4gICAgLy8gT3B0aW9ucyBTZXR0ZXJcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHRoaXMuX2FsaWduID0gdmFsO1xuICAgICAgdmFyIHBhbmVsQWxpZ24gPSBwYXJzZVBhbmVsQWxpZ24odmFsKTtcbiAgICAgIHRoaXMuX3BhbmVscy5mb3JFYWNoKGZ1bmN0aW9uIChwYW5lbCkge1xuICAgICAgICBwYW5lbC5hbGlnbiA9IHBhbmVsQWxpZ247XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgLyoqXHJcbiAgICogSW5pdGlhbGl6ZSBSZW5kZXJlclxyXG4gICAqIEBrbyBSZW5kZXJlcuulvCDstIjquLDtmZTtlanri4jri6RcclxuICAgKiBAcGFyYW0ge0ZsaWNraW5nfSBmbGlja2luZyBBbiBpbnN0YW5jZSBvZiB7QGxpbmsgRmxpY2tpbmd9PGtvPkZsaWNraW5n7J2YIOyduOyKpO2EtOyKpDwva28+XHJcbiAgICogQGNoYWluYWJsZVxyXG4gICAqIEByZXR1cm4ge3RoaXN9XHJcbiAgICovXG4gIF9fcHJvdG8uaW5pdCA9IGZ1bmN0aW9uIChmbGlja2luZykge1xuICAgIHRoaXMuX2ZsaWNraW5nID0gZmxpY2tpbmc7XG4gICAgdGhpcy5fY29sbGVjdFBhbmVscygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcclxuICAgKiBEZXN0cm95IFJlbmRlcmVyIGFuZCByZXR1cm4gdG8gaW5pdGlhbCBzdGF0ZVxyXG4gICAqIEBrbyBSZW5kZXJlcuulvCDstIjquLAg7IOB7YOc66GcIOuQmOuPjOumveuLiOuLpFxyXG4gICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICovXG4gIF9fcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9mbGlja2luZyA9IG51bGw7XG4gICAgdGhpcy5fcGFuZWxzID0gW107XG4gIH07XG4gIC8qKlxyXG4gICAqIFJldHVybiB0aGUge0BsaW5rIFBhbmVsfSBhdCB0aGUgZ2l2ZW4gaW5kZXguIGBudWxsYCBpZiBpdCBkb2Vzbid0IGV4aXN0cy5cclxuICAgKiBAa28g7KO87Ja07KeEIOyduOuNseyKpOyXkCDtlbTri7ntlZjripQge0BsaW5rIFBhbmVsfeydhCDrsJjtmZjtlanri4jri6QuIOyjvOyWtOynhCDsnbjrjbHsiqTsl5Ag7ZW064u57ZWY64qUIO2MqOuEkOydtCDsobTsnqztlZjsp4Ag7JWK7J2EIOqyveyasCBgbnVsbGDsnYQg67CY7ZmY7ZWp64uI64ukLlxyXG4gICAqIEByZXR1cm4ge1BhbmVsIHwgbnVsbH0gUGFuZWwgYXQgdGhlIGdpdmVuIGluZGV4PGtvPuyjvOyWtOynhCDsnbjrjbHsiqTsl5Ag7ZW064u57ZWY64qUIO2MqOuEkDwva28+XHJcbiAgICogQHNlZSBQYW5lbFxyXG4gICAqL1xuICBfX3Byb3RvLmdldFBhbmVsID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhbmVsc1tpbmRleF0gfHwgbnVsbDtcbiAgfTtcbiAgX19wcm90by5mb3JjZVJlbmRlckFsbFBhbmVscyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9wYW5lbHMuZm9yRWFjaChmdW5jdGlvbiAocGFuZWwpIHtcbiAgICAgIHJldHVybiBwYW5lbC5tYXJrRm9yU2hvdygpO1xuICAgIH0pO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfTtcbiAgLyoqXHJcbiAgICogVXBkYXRlIGFsbCBwYW5lbCBzaXplc1xyXG4gICAqIEBrbyDrqqjrk6Ag7Yyo64SQ7J2YIO2BrOq4sOulvCDsl4XrjbDsnbTtirjtlanri4jri6RcclxuICAgKiBAY2hhaW5hYmxlXHJcbiAgICogQHJldHVybiB7dGhpc31cclxuICAgKi9cbiAgX19wcm90by51cGRhdGVQYW5lbFNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZsaWNraW5nID0gZ2V0RmxpY2tpbmdBdHRhY2hlZCh0aGlzLl9mbGlja2luZyk7XG4gICAgdmFyIHBhbmVscyA9IHRoaXMuX3BhbmVscztcbiAgICBpZiAocGFuZWxzLmxlbmd0aCA8PSAwKSByZXR1cm4gdGhpcztcbiAgICBpZiAoZmxpY2tpbmcucGFuZWxzUGVyVmlldyA+IDApIHtcbiAgICAgIHZhciBmaXJzdFBhbmVsID0gcGFuZWxzWzBdO1xuICAgICAgZmlyc3RQYW5lbC5yZXNpemUoKTtcbiAgICAgIHRoaXMuX3VwZGF0ZVBhbmVsU2l6ZUJ5R3JpZChmaXJzdFBhbmVsLCBwYW5lbHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmbGlja2luZy5wYW5lbHMuZm9yRWFjaChmdW5jdGlvbiAocGFuZWwpIHtcbiAgICAgICAgcmV0dXJuIHBhbmVsLnJlc2l6ZSgpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcclxuICAgKiBJbnNlcnQgbmV3IHBhbmVscyBhdCBnaXZlbiBpbmRleFxyXG4gICAqIFRoaXMgd2lsbCBpbmNyZWFzZSBpbmRleCBvZiBwYW5lbHMgYWZ0ZXIgYnkgdGhlIG51bWJlciBvZiBwYW5lbHMgYWRkZWRcclxuICAgKiBAa28g7KO87Ja07KeEIOyduOuNseyKpOyXkCDsg4jroZzsmrQg7Yyo64SQ65Ok7J2EIOy2lOqwgO2VqeuLiOuLpFxyXG4gICAqIO2VtOuLuSDsnbjrjbHsiqTrs7Tri6Qg6rCZ6rGw64KYIO2BsCDsnbjrjbHsiqTrpbwg6rCA7KeEIOq4sOyhtCDtjKjrhJDrk6TsnYAg7LaU6rCA7ZWcIO2MqOuEkOydmCDqsJzsiJjrp4ztgbwg7J24642x7Iqk6rCAIOymneqwgO2VqeuLiOuLpC5cclxuICAgKiBAcGFyYW0ge0FycmF5PG9iamVjdD59IGl0ZW1zIEFuIGFycmF5IG9mIGl0ZW1zIHRvIGluc2VydDxrbz7stpTqsIDtlaAg7JWE7J207YWc65Ok7J2YIOuwsOyXtDwva28+XHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtpdGVtcy5pbmRleF0gSW5kZXggdG8gaW5zZXJ0IG5ldyBwYW5lbHMgYXQ8a28+7IOI66GcIO2MqOuEkOuTpOydhCDstpTqsIDtlaAg7J24642x7IqkPC9rbz5cclxuICAgKiBAcGFyYW0ge2FueVtdfSBbaXRlbXMuZWxlbWVudHNdIEFuIGFycmF5IG9mIGVsZW1lbnQgb3IgZnJhbWV3b3JrIGNvbXBvbmVudCB3aXRoIGVsZW1lbnQgaW4gaXQ8a28+7JeY66as66i87Yq47J2YIOuwsOyXtCDtmLnsnYAg7ZSE66CI7J6E7JuM7YGs7JeQ7IScIOyXmOumrOuovO2KuOulvCDtj6ztlajtlZwg7Lu07Y+s64SM7Yq465Ok7J2YIOuwsOyXtDwva28+XHJcbiAgICogQHBhcmFtIHtib29sZWFufSBbaXRlbXMuaGFzRE9NSW5FbGVtZW50c10gV2hldGhlciBpdCBjb250YWlucyBhY3R1YWwgRE9NIGVsZW1lbnRzLiBJZiBzZXQgdG8gdHJ1ZSwgcmVuZGVyZXIgd2lsbCBhZGQgdGhlbSB0byB0aGUgY2FtZXJhIGVsZW1lbnQ8a28+64K067aA7JeQIOyLpOygnCBET00g7JeY66as66i87Yq465Ok7J2EIO2PrO2VqO2VmOqzoCDsnojripTsp4Ag7Jes67aALiB0cnVl66GcIOyEpOygle2VoCDqsr3smrAsIOugjOuNlOufrOuKlCDtlbTri7kg7JeY66as66i87Yq465Ok7J2EIOy5tOuplOudvCDsl5jrpqzrqLztirgg64K067aA7JeQIOy2lOqwgO2VqeuLiOuLpDwva28+XHJcbiAgICogQHJldHVybiB7UGFuZWxbXX0gQW4gYXJyYXkgb2YgcHJlcGVuZGVkIHBhbmVsczxrbz7stpTqsIDrkJwg7Yyo64SQ65Ok7J2YIOuwsOyXtDwva28+XHJcbiAgICovXG4gIF9fcHJvdG8uYmF0Y2hJbnNlcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGl0ZW1zID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIGl0ZW1zW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciBhbGxQYW5lbHNJbnNlcnRlZCA9IHRoaXMuYmF0Y2hJbnNlcnREZWZlci5hcHBseSh0aGlzLCBfX3NwcmVhZCQxKGl0ZW1zKSk7XG4gICAgaWYgKGFsbFBhbmVsc0luc2VydGVkLmxlbmd0aCA8PSAwKSByZXR1cm4gW107XG4gICAgdGhpcy51cGRhdGVBZnRlclBhbmVsQ2hhbmdlKGFsbFBhbmVsc0luc2VydGVkLCBbXSk7XG4gICAgcmV0dXJuIGFsbFBhbmVsc0luc2VydGVkO1xuICB9O1xuICAvKipcclxuICAgKiBEZWZlcnMgdXBkYXRlXHJcbiAgICogY2FtZXJhIHBvc2l0aW9uICYgb3RoZXJzIHdpbGwgYmUgdXBkYXRlZCBhZnRlciBjYWxsaW5nIHVwZGF0ZUFmdGVyUGFuZWxDaGFuZ2VcclxuICAgKiBAaW50ZXJuYWxcclxuICAgKi9cbiAgX19wcm90by5iYXRjaEluc2VydERlZmVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIGl0ZW1zID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIGl0ZW1zW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciBwYW5lbHMgPSB0aGlzLl9wYW5lbHM7XG4gICAgdmFyIGZsaWNraW5nID0gZ2V0RmxpY2tpbmdBdHRhY2hlZCh0aGlzLl9mbGlja2luZyk7XG4gICAgdmFyIHByZXZGaXJzdFBhbmVsID0gcGFuZWxzWzBdO1xuICAgIHZhciBhbGlnbiA9IHBhcnNlUGFuZWxBbGlnbih0aGlzLl9hbGlnbik7XG4gICAgdmFyIGFsbFBhbmVsc0luc2VydGVkID0gaXRlbXMucmVkdWNlKGZ1bmN0aW9uIChhZGRlZFBhbmVscywgaXRlbSkge1xuICAgICAgdmFyIF9hO1xuICAgICAgdmFyIGluc2VydGluZ0lkeCA9IGdldE1pbnVzQ29tcGVuc2F0ZWRJbmRleChpdGVtLmluZGV4LCBwYW5lbHMubGVuZ3RoKTtcbiAgICAgIHZhciBwYW5lbHNQdXNoZWQgPSBwYW5lbHMuc2xpY2UoaW5zZXJ0aW5nSWR4KTtcbiAgICAgIHZhciBwYW5lbHNJbnNlcnRlZCA9IGl0ZW0uZWxlbWVudHMubWFwKGZ1bmN0aW9uIChlbCwgaWR4KSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5fY3JlYXRlUGFuZWwoZWwsIHtcbiAgICAgICAgICBpbmRleDogaW5zZXJ0aW5nSWR4ICsgaWR4LFxuICAgICAgICAgIGFsaWduOiBhbGlnbixcbiAgICAgICAgICBmbGlja2luZzogZmxpY2tpbmdcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHBhbmVscy5zcGxpY2UuYXBwbHkocGFuZWxzLCBfX3NwcmVhZCQxKFtpbnNlcnRpbmdJZHgsIDBdLCBwYW5lbHNJbnNlcnRlZCkpO1xuICAgICAgaWYgKGl0ZW0uaGFzRE9NSW5FbGVtZW50cykge1xuICAgICAgICAvLyBJbnNlcnQgdGhlIGFjdHVhbCBlbGVtZW50cyBhcyBjYW1lcmEgZWxlbWVudCdzIGNoaWxkcmVuXG4gICAgICAgIF90aGlzLl9pbnNlcnRQYW5lbEVsZW1lbnRzKHBhbmVsc0luc2VydGVkLCAoX2EgPSBwYW5lbHNQdXNoZWRbMF0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG51bGwpO1xuICAgICAgfVxuICAgICAgLy8gUmVzaXplIHRoZSBuZXdseSBhZGRlZCBwYW5lbHNcbiAgICAgIGlmIChmbGlja2luZy5wYW5lbHNQZXJWaWV3ID4gMCkge1xuICAgICAgICB2YXIgZmlyc3RQYW5lbCA9IHByZXZGaXJzdFBhbmVsIHx8IHBhbmVsc0luc2VydGVkWzBdLnJlc2l6ZSgpO1xuICAgICAgICBfdGhpcy5fdXBkYXRlUGFuZWxTaXplQnlHcmlkKGZpcnN0UGFuZWwsIHBhbmVsc0luc2VydGVkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhbmVsc0luc2VydGVkLmZvckVhY2goZnVuY3Rpb24gKHBhbmVsKSB7XG4gICAgICAgICAgcmV0dXJuIHBhbmVsLnJlc2l6ZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIC8vIFVwZGF0ZSBwYW5lbCBpbmRleGVzICYgcG9zaXRpb25zXG4gICAgICBwYW5lbHNQdXNoZWQuZm9yRWFjaChmdW5jdGlvbiAocGFuZWwpIHtcbiAgICAgICAgcGFuZWwuaW5jcmVhc2VJbmRleChwYW5lbHNJbnNlcnRlZC5sZW5ndGgpO1xuICAgICAgICBwYW5lbC51cGRhdGVQb3NpdGlvbigpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gX19zcHJlYWQkMShhZGRlZFBhbmVscywgcGFuZWxzSW5zZXJ0ZWQpO1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gYWxsUGFuZWxzSW5zZXJ0ZWQ7XG4gIH07XG4gIC8qKlxyXG4gICAqIFJlbW92ZSB0aGUgcGFuZWwgYXQgdGhlIGdpdmVuIGluZGV4XHJcbiAgICogVGhpcyB3aWxsIGRlY3JlYXNlIGluZGV4IG9mIHBhbmVscyBhZnRlciBieSB0aGUgbnVtYmVyIG9mIHBhbmVscyByZW1vdmVkXHJcbiAgICogQGtvIOyjvOyWtOynhCDsnbjrjbHsiqTsnZgg7Yyo64SQ7J2EIOygnOqxsO2VqeuLiOuLpFxyXG4gICAqIO2VtOuLuSDsnbjrjbHsiqTrs7Tri6Qg7YGwIOyduOuNseyKpOulvCDqsIDsp4Qg6riw7KG0IO2MqOuEkOuTpOydgCDsoJzqsbDtlZwg7Yyo64SQ7J2YIOqwnOyImOunjO2BvCDsnbjrjbHsiqTqsIAg6rCQ7IaM7ZWp64uI64ukXHJcbiAgICogQHBhcmFtIHtBcnJheTxvYmplY3Q+fSBpdGVtcyBBbiBhcnJheSBvZiBpdGVtcyB0byByZW1vdmU8a28+7KCc6rGw7ZWgIOyVhOydtO2FnOuTpOydmCDrsLDsl7Q8L2tvPlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbaXRlbXMuaW5kZXhdIEluZGV4IG9mIHBhbmVsIHRvIHJlbW92ZTxrbz7soJzqsbDtlaAg7Yyo64SQ7J2YIOyduOuNseyKpDwva28+XHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtpdGVtcy5kZWxldGVDb3VudD0xXSBOdW1iZXIgb2YgcGFuZWxzIHRvIHJlbW92ZSBmcm9tIGluZGV4PGtvPmBpbmRleGAg7J207ZuE66GcIOygnOqxsO2VoCDtjKjrhJDsnZgg6rCc7IiYPC9rbz5cclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpdGVtcy5oYXNET01JbkVsZW1lbnRzPTFdIFdoZXRoZXIgaXQgY29udGFpbnMgYWN0dWFsIERPTSBlbGVtZW50cy4gSWYgc2V0IHRvIHRydWUsIHJlbmRlcmVyIHdpbGwgcmVtb3ZlIHRoZW0gZnJvbSB0aGUgY2FtZXJhIGVsZW1lbnQ8a28+64K067aA7JeQIOyLpOygnCBET00g7JeY66as66i87Yq465Ok7J2EIO2PrO2VqO2VmOqzoCDsnojripTsp4Ag7Jes67aALiB0cnVl66GcIOyEpOygle2VoCDqsr3smrAsIOugjOuNlOufrOuKlCDtlbTri7kg7JeY66as66i87Yq465Ok7J2EIOy5tOuplOudvCDsl5jrpqzrqLztirgg64K067aA7JeQ7IScIOygnOqxsO2VqeuLiOuLpDwva28+XHJcbiAgICogQHJldHVybiBBbiBhcnJheSBvZiByZW1vdmVkIHBhbmVsczxrbz7soJzqsbDrkJwg7Yyo64SQ65Ok7J2YIOuwsOyXtDwva28+XHJcbiAgICovXG4gIF9fcHJvdG8uYmF0Y2hSZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGl0ZW1zID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIGl0ZW1zW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciBhbGxQYW5lbHNSZW1vdmVkID0gdGhpcy5iYXRjaFJlbW92ZURlZmVyLmFwcGx5KHRoaXMsIF9fc3ByZWFkJDEoaXRlbXMpKTtcbiAgICBpZiAoYWxsUGFuZWxzUmVtb3ZlZC5sZW5ndGggPD0gMCkgcmV0dXJuIFtdO1xuICAgIHRoaXMudXBkYXRlQWZ0ZXJQYW5lbENoYW5nZShbXSwgYWxsUGFuZWxzUmVtb3ZlZCk7XG4gICAgcmV0dXJuIGFsbFBhbmVsc1JlbW92ZWQ7XG4gIH07XG4gIC8qKlxyXG4gICAqIERlZmVycyB1cGRhdGVcclxuICAgKiBjYW1lcmEgcG9zaXRpb24gJiBvdGhlcnMgd2lsbCBiZSB1cGRhdGVkIGFmdGVyIGNhbGxpbmcgdXBkYXRlQWZ0ZXJQYW5lbENoYW5nZVxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqL1xuICBfX3Byb3RvLmJhdGNoUmVtb3ZlRGVmZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgaXRlbXNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgdmFyIHBhbmVscyA9IHRoaXMuX3BhbmVscztcbiAgICB2YXIgZmxpY2tpbmcgPSBnZXRGbGlja2luZ0F0dGFjaGVkKHRoaXMuX2ZsaWNraW5nKTtcbiAgICB2YXIgY29udHJvbCA9IGZsaWNraW5nLmNvbnRyb2w7XG4gICAgdmFyIGFjdGl2ZVBhbmVsID0gY29udHJvbC5hY3RpdmVQYW5lbDtcbiAgICB2YXIgYWxsUGFuZWxzUmVtb3ZlZCA9IGl0ZW1zLnJlZHVjZShmdW5jdGlvbiAocmVtb3ZlZCwgaXRlbSkge1xuICAgICAgdmFyIGluZGV4ID0gaXRlbS5pbmRleCxcbiAgICAgICAgZGVsZXRlQ291bnQgPSBpdGVtLmRlbGV0ZUNvdW50O1xuICAgICAgdmFyIHJlbW92aW5nSWR4ID0gZ2V0TWludXNDb21wZW5zYXRlZEluZGV4KGluZGV4LCBwYW5lbHMubGVuZ3RoKTtcbiAgICAgIHZhciBwYW5lbHNQdWxsZWQgPSBwYW5lbHMuc2xpY2UocmVtb3ZpbmdJZHggKyBkZWxldGVDb3VudCk7XG4gICAgICB2YXIgcGFuZWxzUmVtb3ZlZCA9IHBhbmVscy5zcGxpY2UocmVtb3ZpbmdJZHgsIGRlbGV0ZUNvdW50KTtcbiAgICAgIGlmIChwYW5lbHNSZW1vdmVkLmxlbmd0aCA8PSAwKSByZXR1cm4gW107XG4gICAgICAvLyBVcGRhdGUgcGFuZWwgaW5kZXhlcyAmIHBvc2l0aW9uc1xuICAgICAgcGFuZWxzUHVsbGVkLmZvckVhY2goZnVuY3Rpb24gKHBhbmVsKSB7XG4gICAgICAgIHBhbmVsLmRlY3JlYXNlSW5kZXgocGFuZWxzUmVtb3ZlZC5sZW5ndGgpO1xuICAgICAgICBwYW5lbC51cGRhdGVQb3NpdGlvbigpO1xuICAgICAgfSk7XG4gICAgICBpZiAoaXRlbS5oYXNET01JbkVsZW1lbnRzKSB7XG4gICAgICAgIF90aGlzLl9yZW1vdmVQYW5lbEVsZW1lbnRzKHBhbmVsc1JlbW92ZWQpO1xuICAgICAgfVxuICAgICAgLy8gUmVtb3ZlIHBhbmVsIGVsZW1lbnRzXG4gICAgICBwYW5lbHNSZW1vdmVkLmZvckVhY2goZnVuY3Rpb24gKHBhbmVsKSB7XG4gICAgICAgIHJldHVybiBwYW5lbC5kZXN0cm95KCk7XG4gICAgICB9KTtcbiAgICAgIGlmIChpbmNsdWRlcyhwYW5lbHNSZW1vdmVkLCBhY3RpdmVQYW5lbCkpIHtcbiAgICAgICAgY29udHJvbC5yZXNldEFjdGl2ZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9fc3ByZWFkJDEocmVtb3ZlZCwgcGFuZWxzUmVtb3ZlZCk7XG4gICAgfSwgW10pO1xuICAgIHJldHVybiBhbGxQYW5lbHNSZW1vdmVkO1xuICB9O1xuICAvKipcclxuICAgKiBAaW50ZXJuYWxcclxuICAgKi9cbiAgX19wcm90by51cGRhdGVBZnRlclBhbmVsQ2hhbmdlID0gZnVuY3Rpb24gKHBhbmVsc0FkZGVkLCBwYW5lbHNSZW1vdmVkKSB7XG4gICAgdmFyIF9hO1xuICAgIHZhciBmbGlja2luZyA9IGdldEZsaWNraW5nQXR0YWNoZWQodGhpcy5fZmxpY2tpbmcpO1xuICAgIHZhciBjYW1lcmEgPSBmbGlja2luZy5jYW1lcmEsXG4gICAgICBjb250cm9sID0gZmxpY2tpbmcuY29udHJvbDtcbiAgICB2YXIgcGFuZWxzID0gdGhpcy5fcGFuZWxzO1xuICAgIHZhciBhY3RpdmVQYW5lbCA9IGNvbnRyb2wuYWN0aXZlUGFuZWw7XG4gICAgLy8gVXBkYXRlIGNhbWVyYSAmIGNvbnRyb2xcbiAgICB0aGlzLl91cGRhdGVDYW1lcmFBbmRDb250cm9sKCk7XG4gICAgdm9pZCB0aGlzLnJlbmRlcigpO1xuICAgIGlmICghZmxpY2tpbmcuYW5pbWF0aW5nKSB7XG4gICAgICBpZiAoIWFjdGl2ZVBhbmVsIHx8IGFjdGl2ZVBhbmVsLnJlbW92ZWQpIHtcbiAgICAgICAgaWYgKHBhbmVscy5sZW5ndGggPD0gMCkge1xuICAgICAgICAgIC8vIEFsbCBwYW5lbHMgcmVtb3ZlZFxuICAgICAgICAgIGNhbWVyYS5sb29rQXQoMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHRhcmdldEluZGV4ID0gKF9hID0gYWN0aXZlUGFuZWwgPT09IG51bGwgfHwgYWN0aXZlUGFuZWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFjdGl2ZVBhbmVsLmluZGV4KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICAgIGlmICh0YXJnZXRJbmRleCA+IHBhbmVscy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICB0YXJnZXRJbmRleCA9IHBhbmVscy5sZW5ndGggLSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2b2lkIGNvbnRyb2wubW92ZVRvUGFuZWwocGFuZWxzW3RhcmdldEluZGV4XSwge1xuICAgICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2b2lkIGNvbnRyb2wubW92ZVRvUGFuZWwoYWN0aXZlUGFuZWwsIHtcbiAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZsaWNraW5nLmNhbWVyYS51cGRhdGVPZmZzZXQoKTtcbiAgICBpZiAocGFuZWxzQWRkZWQubGVuZ3RoID4gMCB8fCBwYW5lbHNSZW1vdmVkLmxlbmd0aCA+IDApIHtcbiAgICAgIGZsaWNraW5nLnRyaWdnZXIobmV3IENvbXBvbmVudEV2ZW50JDEoRVZFTlRTLlBBTkVMX0NIQU5HRSwge1xuICAgICAgICBhZGRlZDogcGFuZWxzQWRkZWQsXG4gICAgICAgIHJlbW92ZWQ6IHBhbmVsc1JlbW92ZWRcbiAgICAgIH0pKTtcbiAgICAgIHRoaXMuY2hlY2tQYW5lbENvbnRlbnRzUmVhZHkoX19zcHJlYWQkMShwYW5lbHNBZGRlZCwgcGFuZWxzUmVtb3ZlZCkpO1xuICAgIH1cbiAgfTtcbiAgLyoqXHJcbiAgICogQGludGVybmFsXHJcbiAgICovXG4gIF9fcHJvdG8uY2hlY2tQYW5lbENvbnRlbnRzUmVhZHkgPSBmdW5jdGlvbiAoY2hlY2tpbmdQYW5lbHMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHZhciBmbGlja2luZyA9IGdldEZsaWNraW5nQXR0YWNoZWQodGhpcy5fZmxpY2tpbmcpO1xuICAgIHZhciByZXNpemVPbkNvbnRlbnRzUmVhZHkgPSBmbGlja2luZy5yZXNpemVPbkNvbnRlbnRzUmVhZHk7XG4gICAgdmFyIHBhbmVscyA9IHRoaXMuX3BhbmVscztcbiAgICBpZiAoIXJlc2l6ZU9uQ29udGVudHNSZWFkeSB8fCBmbGlja2luZy52aXJ0dWFsRW5hYmxlZCkgcmV0dXJuO1xuICAgIHZhciBoYXNDb250ZW50cyA9IGZ1bmN0aW9uIChwYW5lbCkge1xuICAgICAgcmV0dXJuIHBhbmVsLmVsZW1lbnQgJiYgISFwYW5lbC5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoXCJpbWcsIHZpZGVvXCIpO1xuICAgIH07XG4gICAgY2hlY2tpbmdQYW5lbHMgPSBjaGVja2luZ1BhbmVscy5maWx0ZXIoZnVuY3Rpb24gKHBhbmVsKSB7XG4gICAgICByZXR1cm4gaGFzQ29udGVudHMocGFuZWwpO1xuICAgIH0pO1xuICAgIGlmIChjaGVja2luZ1BhbmVscy5sZW5ndGggPD0gMCkgcmV0dXJuO1xuICAgIHZhciBjb250ZW50c1JlYWR5Q2hlY2tlciA9IG5ldyBJbVJlYWR5KCk7XG4gICAgY2hlY2tpbmdQYW5lbHMuZm9yRWFjaChmdW5jdGlvbiAocGFuZWwpIHtcbiAgICAgIHBhbmVsLmxvYWRpbmcgPSB0cnVlO1xuICAgIH0pO1xuICAgIGNvbnRlbnRzUmVhZHlDaGVja2VyLm9uKFwicmVhZHlFbGVtZW50XCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoIV90aGlzLl9mbGlja2luZykge1xuICAgICAgICAvLyBSZW5kZXJlcidzIGRlc3Ryb3koKSBpcyBjYWxsZWQgYmVmb3JlXG4gICAgICAgIGNvbnRlbnRzUmVhZHlDaGVja2VyLmRlc3Ryb3koKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHBhbmVsID0gY2hlY2tpbmdQYW5lbHNbZS5pbmRleF07XG4gICAgICB2YXIgY2FtZXJhID0gZmxpY2tpbmcuY2FtZXJhO1xuICAgICAgdmFyIGNvbnRyb2wgPSBmbGlja2luZy5jb250cm9sO1xuICAgICAgdmFyIHByZXZQcm9ncmVzc0luUGFuZWwgPSBjb250cm9sLmFjdGl2ZVBhbmVsID8gY2FtZXJhLmdldFByb2dyZXNzSW5QYW5lbChjb250cm9sLmFjdGl2ZVBhbmVsKSA6IDA7XG4gICAgICBwYW5lbC5sb2FkaW5nID0gZmFsc2U7XG4gICAgICBwYW5lbC5yZXNpemUoKTtcbiAgICAgIHBhbmVscy5zbGljZShwYW5lbC5pbmRleCArIDEpLmZvckVhY2goZnVuY3Rpb24gKHBhbmVsQmVoaW5kKSB7XG4gICAgICAgIHJldHVybiBwYW5lbEJlaGluZC51cGRhdGVQb3NpdGlvbigpO1xuICAgICAgfSk7XG4gICAgICBpZiAoIWZsaWNraW5nLmluaXRpYWxpemVkKSByZXR1cm47XG4gICAgICBjYW1lcmEudXBkYXRlUmFuZ2UoKTtcbiAgICAgIGNhbWVyYS51cGRhdGVPZmZzZXQoKTtcbiAgICAgIGNhbWVyYS51cGRhdGVBbmNob3JzKCk7XG4gICAgICBpZiAoY29udHJvbC5hbmltYXRpbmcpIDsgZWxzZSB7XG4gICAgICAgIGNvbnRyb2wudXBkYXRlUG9zaXRpb24ocHJldlByb2dyZXNzSW5QYW5lbCk7XG4gICAgICAgIGNvbnRyb2wudXBkYXRlSW5wdXQoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb250ZW50c1JlYWR5Q2hlY2tlci5vbihcInByZVJlYWR5XCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoX3RoaXMuX2ZsaWNraW5nKSB7XG4gICAgICAgIHZvaWQgX3RoaXMucmVuZGVyKCk7XG4gICAgICB9XG4gICAgICBpZiAoZS5yZWFkeUNvdW50ID09PSBlLnRvdGFsQ291bnQpIHtcbiAgICAgICAgY29udGVudHNSZWFkeUNoZWNrZXIuZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnRlbnRzUmVhZHlDaGVja2VyLm9uKFwicmVhZHlcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKF90aGlzLl9mbGlja2luZykge1xuICAgICAgICB2b2lkIF90aGlzLnJlbmRlcigpO1xuICAgICAgfVxuICAgICAgY29udGVudHNSZWFkeUNoZWNrZXIuZGVzdHJveSgpO1xuICAgIH0pO1xuICAgIGNvbnRlbnRzUmVhZHlDaGVja2VyLmNoZWNrKGNoZWNraW5nUGFuZWxzLm1hcChmdW5jdGlvbiAocGFuZWwpIHtcbiAgICAgIHJldHVybiBwYW5lbC5lbGVtZW50O1xuICAgIH0pKTtcbiAgfTtcbiAgX19wcm90by5fdXBkYXRlQ2FtZXJhQW5kQ29udHJvbCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZmxpY2tpbmcgPSBnZXRGbGlja2luZ0F0dGFjaGVkKHRoaXMuX2ZsaWNraW5nKTtcbiAgICB2YXIgY2FtZXJhID0gZmxpY2tpbmcuY2FtZXJhLFxuICAgICAgY29udHJvbCA9IGZsaWNraW5nLmNvbnRyb2w7XG4gICAgY2FtZXJhLnVwZGF0ZVJhbmdlKCk7XG4gICAgY2FtZXJhLnVwZGF0ZU9mZnNldCgpO1xuICAgIGNhbWVyYS51cGRhdGVBbmNob3JzKCk7XG4gICAgY2FtZXJhLnJlc2V0TmVlZFBhbmVsSGlzdG9yeSgpO1xuICAgIGNvbnRyb2wudXBkYXRlSW5wdXQoKTtcbiAgfTtcbiAgX19wcm90by5fc2hvd09ubHlWaXNpYmxlUGFuZWxzID0gZnVuY3Rpb24gKGZsaWNraW5nKSB7XG4gICAgdmFyIHBhbmVscyA9IGZsaWNraW5nLnJlbmRlcmVyLnBhbmVscztcbiAgICB2YXIgY2FtZXJhID0gZmxpY2tpbmcuY2FtZXJhO1xuICAgIHZhciB2aXNpYmxlSW5kZXhlcyA9IGNhbWVyYS52aXNpYmxlUGFuZWxzLnJlZHVjZShmdW5jdGlvbiAodmlzaWJsZXMsIHBhbmVsKSB7XG4gICAgICB2aXNpYmxlc1twYW5lbC5pbmRleF0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHZpc2libGVzO1xuICAgIH0sIHt9KTtcbiAgICBwYW5lbHMuZm9yRWFjaChmdW5jdGlvbiAocGFuZWwpIHtcbiAgICAgIGlmIChwYW5lbC5pbmRleCBpbiB2aXNpYmxlSW5kZXhlcyB8fCBwYW5lbC5sb2FkaW5nKSB7XG4gICAgICAgIHBhbmVsLm1hcmtGb3JTaG93KCk7XG4gICAgICB9IGVsc2UgaWYgKCFmbGlja2luZy5ob2xkaW5nKSB7XG4gICAgICAgIC8vIER1cmluZyB0aGUgaW5wdXQgc2VxdWVuY2UsXG4gICAgICAgIC8vIERvIG5vdCByZW1vdmUgcGFuZWwgZWxlbWVudHMgYXMgaXQgd29uJ3QgdHJpZ2dlciB0b3VjaGVuZCBldmVudC5cbiAgICAgICAgcGFuZWwubWFya0ZvckhpZGUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgX19wcm90by5fdXBkYXRlUGFuZWxTaXplQnlHcmlkID0gZnVuY3Rpb24gKHJlZmVyZW5jZVBhbmVsLCBwYW5lbHMpIHtcbiAgICB2YXIgZmxpY2tpbmcgPSBnZXRGbGlja2luZ0F0dGFjaGVkKHRoaXMuX2ZsaWNraW5nKTtcbiAgICB2YXIgcGFuZWxzUGVyVmlldyA9IGZsaWNraW5nLnBhbmVsc1BlclZpZXc7XG4gICAgaWYgKHBhbmVsc1BlclZpZXcgPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IEZsaWNraW5nRXJyb3IoTUVTU0FHRS5XUk9OR19PUFRJT04oXCJwYW5lbHNQZXJWaWV3XCIsIHBhbmVsc1BlclZpZXcpLCBDT0RFLldST05HX09QVElPTik7XG4gICAgfVxuICAgIGlmIChwYW5lbHMubGVuZ3RoIDw9IDApIHJldHVybjtcbiAgICB2YXIgdmlld3BvcnRTaXplID0gZmxpY2tpbmcuY2FtZXJhLnNpemU7XG4gICAgdmFyIGdhcCA9IHJlZmVyZW5jZVBhbmVsLm1hcmdpbi5wcmV2ICsgcmVmZXJlbmNlUGFuZWwubWFyZ2luLm5leHQ7XG4gICAgdmFyIHBhbmVsU2l6ZSA9ICh2aWV3cG9ydFNpemUgLSBnYXAgKiAocGFuZWxzUGVyVmlldyAtIDEpKSAvIHBhbmVsc1BlclZpZXc7XG4gICAgdmFyIHBhbmVsU2l6ZU9iaiA9IGZsaWNraW5nLmhvcml6b250YWwgPyB7XG4gICAgICB3aWR0aDogcGFuZWxTaXplXG4gICAgfSA6IHtcbiAgICAgIGhlaWdodDogcGFuZWxTaXplXG4gICAgfTtcbiAgICB2YXIgZmlyc3RQYW5lbFNpemVPYmogPSBfX2Fzc2lnbiQyKHtcbiAgICAgIHNpemU6IHBhbmVsU2l6ZSxcbiAgICAgIG1hcmdpbjogcmVmZXJlbmNlUGFuZWwubWFyZ2luXG4gICAgfSwgIWZsaWNraW5nLmhvcml6b250YWwgJiYge1xuICAgICAgaGVpZ2h0OiByZWZlcmVuY2VQYW5lbC5oZWlnaHRcbiAgICB9KTtcbiAgICBpZiAoIWZsaWNraW5nLm5vUGFuZWxTdHlsZU92ZXJyaWRlKSB7XG4gICAgICB0aGlzLl9zdHJhdGVneS51cGRhdGVQYW5lbFNpemVzKGZsaWNraW5nLCBwYW5lbFNpemVPYmopO1xuICAgIH1cbiAgICBmbGlja2luZy5wYW5lbHMuZm9yRWFjaChmdW5jdGlvbiAocGFuZWwpIHtcbiAgICAgIHJldHVybiBwYW5lbC5yZXNpemUoZmlyc3RQYW5lbFNpemVPYmopO1xuICAgIH0pO1xuICB9O1xuICBfX3Byb3RvLl9yZW1vdmVBbGxDaGlsZHNGcm9tQ2FtZXJhID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBmbGlja2luZyA9IGdldEZsaWNraW5nQXR0YWNoZWQodGhpcy5fZmxpY2tpbmcpO1xuICAgIHZhciBjYW1lcmFFbGVtZW50ID0gZmxpY2tpbmcuY2FtZXJhLmVsZW1lbnQ7XG4gICAgLy8gUmVtb3ZlIG90aGVyIGVsZW1lbnRzXG4gICAgd2hpbGUgKGNhbWVyYUVsZW1lbnQuZmlyc3RDaGlsZCkge1xuICAgICAgY2FtZXJhRWxlbWVudC5yZW1vdmVDaGlsZChjYW1lcmFFbGVtZW50LmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgfTtcbiAgX19wcm90by5faW5zZXJ0UGFuZWxFbGVtZW50cyA9IGZ1bmN0aW9uIChwYW5lbHMsIG5leHRTaWJsaW5nKSB7XG4gICAgaWYgKG5leHRTaWJsaW5nID09PSB2b2lkIDApIHtcbiAgICAgIG5leHRTaWJsaW5nID0gbnVsbDtcbiAgICB9XG4gICAgdmFyIGZsaWNraW5nID0gZ2V0RmxpY2tpbmdBdHRhY2hlZCh0aGlzLl9mbGlja2luZyk7XG4gICAgdmFyIGNhbWVyYSA9IGZsaWNraW5nLmNhbWVyYTtcbiAgICB2YXIgY2FtZXJhRWxlbWVudCA9IGNhbWVyYS5lbGVtZW50O1xuICAgIHZhciBuZXh0U2libGluZ0VsZW1lbnQgPSAobmV4dFNpYmxpbmcgPT09IG51bGwgfHwgbmV4dFNpYmxpbmcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5leHRTaWJsaW5nLmVsZW1lbnQpIHx8IG51bGw7XG4gICAgdmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgIHBhbmVscy5mb3JFYWNoKGZ1bmN0aW9uIChwYW5lbCkge1xuICAgICAgcmV0dXJuIGZyYWdtZW50LmFwcGVuZENoaWxkKHBhbmVsLmVsZW1lbnQpO1xuICAgIH0pO1xuICAgIGNhbWVyYUVsZW1lbnQuaW5zZXJ0QmVmb3JlKGZyYWdtZW50LCBuZXh0U2libGluZ0VsZW1lbnQpO1xuICB9O1xuICBfX3Byb3RvLl9yZW1vdmVQYW5lbEVsZW1lbnRzID0gZnVuY3Rpb24gKHBhbmVscykge1xuICAgIHZhciBmbGlja2luZyA9IGdldEZsaWNraW5nQXR0YWNoZWQodGhpcy5fZmxpY2tpbmcpO1xuICAgIHZhciBjYW1lcmFFbGVtZW50ID0gZmxpY2tpbmcuY2FtZXJhLmVsZW1lbnQ7XG4gICAgcGFuZWxzLmZvckVhY2goZnVuY3Rpb24gKHBhbmVsKSB7XG4gICAgICBjYW1lcmFFbGVtZW50LnJlbW92ZUNoaWxkKHBhbmVsLmVsZW1lbnQpO1xuICAgIH0pO1xuICB9O1xuICBfX3Byb3RvLl9hZnRlclJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZmxpY2tpbmcgPSBnZXRGbGlja2luZ0F0dGFjaGVkKHRoaXMuX2ZsaWNraW5nKTtcbiAgICBmbGlja2luZy5jYW1lcmEuYXBwbHlUcmFuc2Zvcm0oKTtcbiAgfTtcbiAgcmV0dXJuIFJlbmRlcmVyO1xufSgpO1xuXG4vKipcclxuICpcclxuICovXG52YXIgVmFuaWxsYVJlbmRlcmVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzJDMoVmFuaWxsYVJlbmRlcmVyLCBfc3VwZXIpO1xuICBmdW5jdGlvbiBWYW5pbGxhUmVuZGVyZXIoKSB7XG4gICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcmVxdWlyZS1hd2FpdFxuICB2YXIgX19wcm90byA9IFZhbmlsbGFSZW5kZXJlci5wcm90b3R5cGU7XG4gIF9fcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBmbGlja2luZywgc3RyYXRlZ3k7XG4gICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIGZsaWNraW5nID0gZ2V0RmxpY2tpbmdBdHRhY2hlZCh0aGlzLl9mbGlja2luZyk7XG4gICAgICAgIHN0cmF0ZWd5ID0gdGhpcy5fc3RyYXRlZ3k7XG4gICAgICAgIHN0cmF0ZWd5LnVwZGF0ZVJlbmRlcmluZ1BhbmVscyhmbGlja2luZyk7XG4gICAgICAgIHN0cmF0ZWd5LnJlbmRlclBhbmVscyhmbGlja2luZyk7XG4gICAgICAgIHRoaXMuX3Jlc2V0UGFuZWxFbGVtZW50T3JkZXIoKTtcbiAgICAgICAgdGhpcy5fYWZ0ZXJSZW5kZXIoKTtcbiAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgX19wcm90by5fY29sbGVjdFBhbmVscyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZmxpY2tpbmcgPSBnZXRGbGlja2luZ0F0dGFjaGVkKHRoaXMuX2ZsaWNraW5nKTtcbiAgICB2YXIgY2FtZXJhID0gZmxpY2tpbmcuY2FtZXJhO1xuICAgIHRoaXMuX3JlbW92ZUFsbFRleHROb2RlcygpO1xuICAgIHRoaXMuX3BhbmVscyA9IHRoaXMuX3N0cmF0ZWd5LmNvbGxlY3RQYW5lbHMoZmxpY2tpbmcsIGNhbWVyYS5jaGlsZHJlbik7XG4gIH07XG4gIF9fcHJvdG8uX2NyZWF0ZVBhbmVsID0gZnVuY3Rpb24gKGVsLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0cmF0ZWd5LmNyZWF0ZVBhbmVsKGVsLCBvcHRpb25zKTtcbiAgfTtcbiAgX19wcm90by5fcmVzZXRQYW5lbEVsZW1lbnRPcmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZmxpY2tpbmcgPSBnZXRGbGlja2luZ0F0dGFjaGVkKHRoaXMuX2ZsaWNraW5nKTtcbiAgICB2YXIgY2FtZXJhRWwgPSBmbGlja2luZy5jYW1lcmEuZWxlbWVudDtcbiAgICAvLyBXZSdyZSB1c2luZyByZXZlcnNlZCBwYW5lbHMgaGVyZSBhcyBsYXN0IHBhbmVsIHNob3VsZCBiZSB0aGUgbGFzdCBlbGVtZW50IG9mIGNhbWVyYSBlbGVtZW50XG4gICAgdmFyIHJldmVyc2VkRWxlbWVudHMgPSB0aGlzLl9zdHJhdGVneS5nZXRSZW5kZXJpbmdFbGVtZW50c0J5T3JkZXIoZmxpY2tpbmcpLnJldmVyc2UoKTtcbiAgICByZXZlcnNlZEVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVsLCBpZHgpIHtcbiAgICAgIHZhciBuZXh0RWwgPSByZXZlcnNlZEVsZW1lbnRzW2lkeCAtIDFdID8gcmV2ZXJzZWRFbGVtZW50c1tpZHggLSAxXSA6IG51bGw7XG4gICAgICBpZiAoZWwubmV4dEVsZW1lbnRTaWJsaW5nICE9PSBuZXh0RWwpIHtcbiAgICAgICAgY2FtZXJhRWwuaW5zZXJ0QmVmb3JlKGVsLCBuZXh0RWwpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICBfX3Byb3RvLl9yZW1vdmVBbGxUZXh0Tm9kZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZsaWNraW5nID0gZ2V0RmxpY2tpbmdBdHRhY2hlZCh0aGlzLl9mbGlja2luZyk7XG4gICAgdmFyIGNhbWVyYUVsZW1lbnQgPSBmbGlja2luZy5jYW1lcmEuZWxlbWVudDtcbiAgICAvLyBSZW1vdmUgYWxsIHRleHQgbm9kZXMgaW4gdGhlIGNhbWVyYSBlbGVtZW50XG4gICAgdG9BcnJheSQyKGNhbWVyYUVsZW1lbnQuY2hpbGROb2RlcykuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICAgIGNhbWVyYUVsZW1lbnQucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIHJldHVybiBWYW5pbGxhUmVuZGVyZXI7XG59KFJlbmRlcmVyKTtcblxuLyoqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cbnZhciBFeHRlcm5hbFJlbmRlcmVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzJDMoRXh0ZXJuYWxSZW5kZXJlciwgX3N1cGVyKTtcbiAgZnVuY3Rpb24gRXh0ZXJuYWxSZW5kZXJlcigpIHtcbiAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cbiAgLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzICovXG4gIHZhciBfX3Byb3RvID0gRXh0ZXJuYWxSZW5kZXJlci5wcm90b3R5cGU7XG4gIF9fcHJvdG8uX3JlbW92ZVBhbmVsRWxlbWVudHMgPSBmdW5jdGlvbiAocGFuZWxzKSB7XG4gICAgLy8gRE8gTk9USElORywgb3ZlcnJpZGVkIHRvIHByZXZlbnQgYW4gdW5leHBlY3RlZCBlcnJvclxuICB9O1xuICBfX3Byb3RvLl9yZW1vdmVBbGxDaGlsZHNGcm9tQ2FtZXJhID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIERPIE5PVEhJTkcsIG92ZXJyaWRlZCB0byBwcmV2ZW50IGFuIHVuZXhwZWN0ZWQgZXJyb3JcbiAgfTtcbiAgcmV0dXJuIEV4dGVybmFsUmVuZGVyZXI7XG59KFJlbmRlcmVyKTtcblxuLyoqXHJcbiAqIEEgc2xpZGUgZGF0YSBjb21wb25lbnQgdGhhdCBob2xkcyBpbmZvcm1hdGlvbiBvZiBhIHNpbmdsZSBIVE1MRWxlbWVudFxyXG4gKiBAa28g7Iqs65287J2065OcIOuNsOydtO2EsCDsu7Ttj6zrhIztirjroZwsIOuLqOydvCBIVE1MRWxlbWVudOydmCDsoJXrs7Trpbwg6rCW6rOgIOyeiOyKteuLiOuLpFxyXG4gKi9cbnZhciBQYW5lbCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIEFuIG9wdGlvbnMgb2JqZWN0PGtvPuyYteyFmCDsmKTruIzsoJ3tirg8L2tvPlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5pbmRleF0gQW4gaW5pdGlhbCBpbmRleCBvZiB0aGUgcGFuZWw8a28+7Yyo64SQ7J2YIOy0iOq4sCDsnbjrjbHsiqQ8L2tvPlxyXG4gICAqIEBwYXJhbSB7Q29uc3RhbnRzLkFMSUdOIHwgc3RyaW5nIHwgbnVtYmVyfSBbb3B0aW9ucy5hbGlnbl0gQW4gaW5pdGlhbCB7QGxpbmsgRmxpY2tpbmcjYWxpZ24gYWxpZ259IHZhbHVlIG9mIHRoZSBwYW5lbDxrbz7tjKjrhJDsnZgg7LSI6riwIHtAbGluayBGbGlja2luZyNhbGlnbiBhbGlnbn3qsJI8L2tvPlxyXG4gICAqIEBwYXJhbSB7RmxpY2tpbmd9IFtvcHRpb25zLmZsaWNraW5nXSBBIEZsaWNraW5nIGluc3RhbmNlIHBhbmVsJ3MgcmVmZXJlbmNpbmc8a28+7Yyo64SQ7J20IOywuOyhsO2VmOuKlCB7QGxpbmsgRmxpY2tpbmd9IOyduOyKpO2EtOyKpDwva28+XHJcbiAgICogQHBhcmFtIHtGbGlja2luZ30gW29wdGlvbnMuZWxlbWVudFByb3ZpZGVyXSBBIHByb3ZpZGVyIGluc3RhbmNlIHRoYXQgcmVkaXJlY3RzIGVsZW1lbnRzPGtvPuyLpOygnCDsl5jrpqzrqLztirjrpbwg67CY7ZmY7ZWY64qUIOyXmOumrOuovO2KuCDqs7XquInsnpDsnZgg7J247Iqk7YS07IqkPC9rbz5cclxuICAgKi9cbiAgZnVuY3Rpb24gUGFuZWwoX2EpIHtcbiAgICB2YXIgaW5kZXggPSBfYS5pbmRleCxcbiAgICAgIGFsaWduID0gX2EuYWxpZ24sXG4gICAgICBmbGlja2luZyA9IF9hLmZsaWNraW5nLFxuICAgICAgZWxlbWVudFByb3ZpZGVyID0gX2EuZWxlbWVudFByb3ZpZGVyO1xuICAgIHRoaXMuX2luZGV4ID0gaW5kZXg7XG4gICAgdGhpcy5fZmxpY2tpbmcgPSBmbGlja2luZztcbiAgICB0aGlzLl9lbFByb3ZpZGVyID0gZWxlbWVudFByb3ZpZGVyO1xuICAgIHRoaXMuX2FsaWduID0gYWxpZ247XG4gICAgdGhpcy5fcmVtb3ZlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JlbmRlcmVkID0gdHJ1ZTtcbiAgICB0aGlzLl9sb2FkaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fcmVzZXRJbnRlcm5hbFN0YXRlcygpO1xuICB9XG4gIHZhciBfX3Byb3RvID0gUGFuZWwucHJvdG90eXBlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJlbGVtZW50XCIsIHtcbiAgICAvLyBJbnRlcm5hbCBTdGF0ZXMgR2V0dGVyXG4gICAgLyoqXHJcbiAgICAgKiBgSFRNTEVsZW1lbnRgIHRoYXQgcGFuZWwncyByZWZlcmVuY2luZ1xyXG4gICAgICogQGtvIO2MqOuEkOydtCDssLjsobDtlZjqs6Ag7J6I64qUIGBIVE1MRWxlbWVudGBcclxuICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZWxQcm92aWRlci5lbGVtZW50O1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJlbGVtZW50UHJvdmlkZXJcIiwge1xuICAgIC8qKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2VsUHJvdmlkZXI7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcImluZGV4XCIsIHtcbiAgICAvKipcclxuICAgICAqIEluZGV4IG9mIHRoZSBwYW5lbFxyXG4gICAgICogQGtvIO2MqOuEkOydmCDsnbjrjbHsiqRcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2luZGV4O1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJwb3NpdGlvblwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBQb3NpdGlvbiBvZiB0aGUgcGFuZWwsIGluY2x1ZGluZyB7QGxpbmsgUGFuZWwjYWxpZ25Qb3NpdGlvbiBhbGlnblBvc2l0aW9ufVxyXG4gICAgICogQGtvIO2MqOuEkOydmCDtmITsnqwg7KKM7ZGcLCB7QGxpbmsgUGFuZWwjYWxpZ25Qb3NpdGlvbiBhbGlnblBvc2l0aW9ufeydhCDtj6ztlajtlZjqs6Ag7J6I7Iq164uI64ukXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wb3MgKyB0aGlzLl9hbGlnblBvcztcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwic2l6ZVwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBDYWNoZWQgc2l6ZSBvZiB0aGUgcGFuZWwgZWxlbWVudFxyXG4gICAgICogVGhpcyBpcyBlcXVhbCB0byB7QGxpbmsgUGFuZWwjZWxlbWVudCBlbGVtZW50fSdzIGBvZmZzZXRXaWR0aGAgaWYge0BsaW5rIEZsaWNraW5nI2hvcml6b250YWwgaG9yaXpvbnRhbH0gaXMgYHRydWVgLCBhbmQgYG9mZnNldEhlaWdodGAgZWxzZVxyXG4gICAgICogQGtvIO2MqOuEkCDsl5jrpqzrqLztirjsnZgg7LqQ7Iuc65CcIO2BrOq4sFxyXG4gICAgICog7J20IOqwkuydgCB7QGxpbmsgRmxpY2tpbmcjaG9yaXpvbnRhbCBob3Jpem9udGFsfeydtCBgdHJ1ZWDsnbwg6rK97JqwIHtAbGluayBQYW5lbCNlbGVtZW50IGVsZW1lbnR97J2YIGBvZmZzZXRXaWR0aGDsmYAg64+Z7J287ZWY6rOgLCBgZmFsc2Vg7J28IOqyveyasCBgb2Zmc2V0SGVpZ2h0YOyZgCDrj5nsnbztlanri4jri6RcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NpemU7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcInNpemVJbmNsdWRpbmdNYXJnaW5cIiwge1xuICAgIC8qKlxyXG4gICAgICogUGFuZWwncyBzaXplIGluY2x1ZGluZyBDU1MgYG1hcmdpbmBcclxuICAgICAqIFRoaXMgdmFsdWUgaW5jbHVkZXMge0BsaW5rIFBhbmVsI2VsZW1lbnQgZWxlbWVudH0ncyBtYXJnaW4gbGVmdC9yaWdodCBpZiB7QGxpbmsgRmxpY2tpbmcjaG9yaXpvbnRhbCBob3Jpem9udGFsfSBpcyBgdHJ1ZWAsIGFuZCBtYXJnaW4gdG9wL2JvdHRvbSBlbHNlXHJcbiAgICAgKiBAa28gQ1NTIGBtYXJnaW5g7J2EIO2PrO2VqO2VnCDtjKjrhJDsnZgg7YGs6riwXHJcbiAgICAgKiDsnbQg6rCS7J2AIHtAbGluayBGbGlja2luZyNob3Jpem9udGFsIGhvcml6b250YWx97J20IGB0cnVlYOydvCDqsr3smrAgbWFyZ2luIGxlZnQvcmlnaHTsnYQg7Y+s7ZWo7ZWY6rOgLCBgZmFsc2Vg7J28IOqyveyasCBtYXJnaW4gdG9wL2JvdHRvbeydhCDtj6ztlajtlanri4jri6RcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NpemUgKyB0aGlzLl9tYXJnaW4ucHJldiArIHRoaXMuX21hcmdpbi5uZXh0O1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJoZWlnaHRcIiwge1xuICAgIC8qKlxyXG4gICAgICogSGVpZ2h0IG9mIHRoZSBwYW5lbCBlbGVtZW50XHJcbiAgICAgKiBAa28g7Yyo64SQIOyXmOumrOuovO2KuOydmCDrhpLsnbRcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2hlaWdodDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwibWFyZ2luXCIsIHtcbiAgICAvKipcclxuICAgICAqIENhY2hlZCBDU1MgYG1hcmdpbmAgdmFsdWUgb2YgdGhlIHBhbmVsIGVsZW1lbnRcclxuICAgICAqIEBrbyDtjKjrhJAg7JeY66as66i87Yq47J2YIENTUyBgbWFyZ2luYCDqsJJcclxuICAgICAqIEB0eXBlIHtvYmplY3R9XHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gcHJldiBDU1MgYG1hcmdpbi1sZWZ0YCB3aGVuIHRoZSB7QGxpbmsgRmxpY2tpbmcjaG9yaXpvbnRhbCBob3Jpem9udGFsfSBpcyBgdHJ1ZWAsIGFuZCBgbWFyZ2luLXRvcGAgZWxzZVxyXG4gICAgICogPGtvPntAbGluayBGbGlja2luZyNob3Jpem9udGFsIGhvcml6b250YWx97J20IGB0cnVlYOydvCDqsr3smrAgYG1hcmdpbi1sZWZ0YCwgYGZhbHNlYOydvCDqsr3smrAgYG1hcmdpbi10b3Bg7JeQIO2VtOuLue2VmOuKlCDqsJI8L2tvPlxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG5leHQgQ1NTIGBtYXJnaW4tcmlnaHRgIHdoZW4gdGhlIHtAbGluayBGbGlja2luZyNob3Jpem9udGFsIGhvcml6b250YWx9IGlzIGB0cnVlYCwgYW5kIGBtYXJnaW4tYm90dG9tYCBlbHNlXHJcbiAgICAgKiA8a28+e0BsaW5rIEZsaWNraW5nI2hvcml6b250YWwgaG9yaXpvbnRhbH3snbQgYHRydWVg7J28IOqyveyasCBgbWFyZ2luLXJpZ2h0YCwgYGZhbHNlYOydvCDqsr3smrAgYG1hcmdpbi1ib3R0b21g7JeQIO2VtOuLue2VmOuKlCDqsJI8L2tvPlxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tYXJnaW47XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcImFsaWduUG9zaXRpb25cIiwge1xuICAgIC8qKlxyXG4gICAgICogQWxpZ24gcG9zaXRpb24gaW5zaWRlIHRoZSBwYW5lbCB3aGVyZSB7QGxpbmsgQ2FtZXJhfSdzIHtAbGluayBDYW1lcmEjYWxpZ25Qb3NpdGlvbiBhbGlnblBvc2l0aW9ufSBpbnNpZGUgdmlld3BvcnQgc2hvdWxkIGJlIGxvY2F0ZWQgYXRcclxuICAgICAqIEBrbyDtjKjrhJDsnZgg7KCV66CsIOq4sOykgCDsnITsuZguIHtAbGluayBDYW1lcmF97J2YIOu3sO2PrO2KuCDrgrTsl5DshJzsnZgge0BsaW5rIENhbWVyYSNhbGlnblBvc2l0aW9uIGFsaWduUG9zaXRpb2597J20IOychOy5mO2VtOyVvCDtlZjripQg6rOz7J6F64uI64ukXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9hbGlnblBvcztcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwicmVtb3ZlZFwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBBIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciB0aGUgcGFuZWwncyB7QGxpbmsgRmxpY2tpbmcjcmVtb3ZlIHJlbW92ZX1kXHJcbiAgICAgKiBAa28g7Yyo64SQ7J20IHtAbGluayBGbGlja2luZyNyZW1vdmUgcmVtb3ZlfeuQmOyXiOuKlOyngCDsl6zrtoDrpbwg64KY7YOA64K064qUIOqwklxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlbW92ZWQ7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcInJlbmRlcmVkXCIsIHtcbiAgICAvKipcclxuICAgICAqIEEgdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBwYW5lbCdzIGVsZW1lbnQgaXMgYmVpbmcgcmVuZGVyZWQgb24gdGhlIHNjcmVlblxyXG4gICAgICogQGtvIO2MqOuEkOydmCDsl5jrpqzrqLztirjqsIAg7ZmU66m07IOB7JeQIOugjOuNlOungeuQmOqzoOyeiOuKlOyngCDsl6zrtoDrpbwg64KY7YOA64K064qUIOqwklxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlcmVkO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJsb2FkaW5nXCIsIHtcbiAgICAvKipcclxuICAgICAqIEEgdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBwYW5lbCdzIGltYWdlL3ZpZGVvIGlzIG5vdCBsb2FkZWQgYW5kIHdhaXRpbmcgZm9yIHJlc2l6ZVxyXG4gICAgICogQGtvIO2MqOuEkCDrgrTrtoDsnZgg7J2066+47KeAL+u5hOuUlOyYpOqwgCDslYTsp4Eg66Gc65Oc65CY7KeAIOyViuyVhCB7QGxpbmsgUGFuZWwjcmVzaXplIHJlc2l6ZX3rkKAg6rKD7J247KeA66W8IOuCmO2DgOuCtOuKlCDqsJJcclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9sb2FkaW5nO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICB0aGlzLl9sb2FkaW5nID0gdmFsO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJyYW5nZVwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBQYW5lbCBlbGVtZW50J3MgcmFuZ2Ugb2YgdGhlIGJvdW5kaW5nIGJveFxyXG4gICAgICogQGtvIO2MqOuEkCDsl5jrpqzrqLztirjsnZggQm91bmRpbmcgYm94IOuylOychFxyXG4gICAgICogQHR5cGUge29iamVjdH1cclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWluXSBCb3VuZGluZyBib3gncyBsZWZ0KHtAbGluayBGbGlja2luZyNob3Jpem9udGFsIGhvcml6b250YWx9OiB0cnVlKSAvIHRvcCh7QGxpbmsgRmxpY2tpbmcjaG9yaXpvbnRhbCBob3Jpem9udGFsfTogZmFsc2UpXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gW21heF0gQm91bmRpbmcgYm94J3MgcmlnaHQoe0BsaW5rIEZsaWNraW5nI2hvcml6b250YWwgaG9yaXpvbnRhbH06IHRydWUpIC8gYm90dG9tKHtAbGluayBGbGlja2luZyNob3Jpem9udGFsIGhvcml6b250YWx9OiBmYWxzZSlcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtaW46IHRoaXMuX3BvcyxcbiAgICAgICAgbWF4OiB0aGlzLl9wb3MgKyB0aGlzLl9zaXplXG4gICAgICB9O1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJ0b2dnbGVkXCIsIHtcbiAgICAvKipcclxuICAgICAqIEEgdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBwYW5lbCdzIHBvc2l0aW9uIGlzIHRvZ2dsZWQgYnkgY2lyY3VsYXIgYmVoYXZpb3JcclxuICAgICAqIEBrbyDtjKjrhJDsnZgg7JyE7LmY6rCAIGNpcmN1bGFyIOuPmeyekeyXkCDsnZjtlbQg7Yag6riA65CY7JeI64qU7KeAIOyXrOu2gOulvCDrgpjtg4DrgrTripQg6rCSXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdG9nZ2xlZDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwidG9nZ2xlRGlyZWN0aW9uXCIsIHtcbiAgICAvKipcclxuICAgICAqIEEgZGlyZWN0aW9uIHdoZXJlIHRoZSBwYW5lbCdzIHBvc2l0aW9uIGlzIHRvZ2dsZWRcclxuICAgICAqIEBrbyDtjKjrhJDsnZgg7JyE7LmY6rCAIGNpcmN1bGFyIOuPmeyekeyXkCDsnZjtlbQg7Yag6riA65CY64qUIOuwqe2WpVxyXG4gICAgICogQHR5cGUge0RJUkVDVElPTn1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdG9nZ2xlRGlyZWN0aW9uO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJvZmZzZXRcIiwge1xuICAgIC8qKlxyXG4gICAgICogQWN0dWFsIHBvc2l0aW9uIG9mZnNldCBkZXRlcm1pbmVkIGJ5IHtAbGluayBQYW5lbCNvcmRlcn1cclxuICAgICAqIEBrbyB7QGxpbmsgUGFuZWwjb3JkZXJ97JeQIOydmO2VnCDsi6TsoJwg7JyE7LmYIOuzgOqyveqwklxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdG9nZ2xlRGlyZWN0aW9uID0gdGhpcy5fdG9nZ2xlRGlyZWN0aW9uO1xuICAgICAgdmFyIGNhbWVyYVJhbmdlRGlmZiA9IHRoaXMuX2ZsaWNraW5nLmNhbWVyYS5yYW5nZURpZmY7XG4gICAgICByZXR1cm4gdG9nZ2xlRGlyZWN0aW9uID09PSBESVJFQ1RJT04uTk9ORSB8fCAhdGhpcy5fdG9nZ2xlZCA/IDAgOiB0b2dnbGVEaXJlY3Rpb24gPT09IERJUkVDVElPTi5QUkVWID8gLWNhbWVyYVJhbmdlRGlmZiA6IGNhbWVyYVJhbmdlRGlmZjtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwicHJvZ3Jlc3NcIiwge1xuICAgIC8qKlxyXG4gICAgICogUHJvZ3Jlc3Mgb2YgbW92ZW1lbnQgYmV0d2VlbiBwcmV2aW91cyBvciBuZXh0IHBhbmVsIHJlbGF0aXZlIHRvIGN1cnJlbnQgcGFuZWxcclxuICAgICAqIEBrbyDsnbQg7Yyo64SQ66Gc67aA7YSwIOydtOyghC/ri6TsnYwg7Yyo64SQ7Jy866Gc7J2YIOydtOuPmSDsp4TtlonrpaBcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGZsaWNraW5nID0gdGhpcy5fZmxpY2tpbmc7XG4gICAgICByZXR1cm4gdGhpcy5pbmRleCAtIGZsaWNraW5nLmNhbWVyYS5wcm9ncmVzcztcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwib3V0c2V0UHJvZ3Jlc3NcIiwge1xuICAgIC8qKlxyXG4gICAgICogUHJvZ3Jlc3Mgb2YgbW92ZW1lbnQgYmV0d2VlbiBwb2ludHMgdGhhdCBwYW5lbCBpcyBjb21wbGV0ZWx5IGludmlzaWJsZSBvdXRzaWRlIG9mIHZpZXdwb3J0KHByZXYgZGlyZWN0aW9uOiAtMSwgc2VsZWN0ZWQgcG9pbnQ6IDAsIG5leHQgZGlyZWN0aW9uOiAxKVxyXG4gICAgICogQGtvIO2YhOyerCDtjKjrhJDsnbQg67ew7Y+s7Yq4IOyYgeyXrSDrsJbsnLzroZwg7JmE7KCE7Z6IIOyCrOudvOyngOuKlCDsp4DsoJDsnYQg6riw7KSA7Jy866GcIO2VmOuKlCDsp4Ttlonrj4QocHJlduuwqe2WpTogLTEsIOyEoO2DnSDsp4DsoJA6IDAsIG5leHTrsKntlqU6IDEpXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMucG9zaXRpb24gKyB0aGlzLm9mZnNldDtcbiAgICAgIHZhciBhbGlnblBvc2l0aW9uID0gdGhpcy5fYWxpZ25Qb3M7XG4gICAgICB2YXIgY2FtZXJhID0gdGhpcy5fZmxpY2tpbmcuY2FtZXJhO1xuICAgICAgdmFyIGNhbVBvcyA9IGNhbWVyYS5wb3NpdGlvbjtcbiAgICAgIGlmIChjYW1Qb3MgPT09IHBvc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgaWYgKGNhbVBvcyA8IHBvc2l0aW9uKSB7XG4gICAgICAgIHZhciBkaXNhcHBlYXJQb3NOZXh0ID0gcG9zaXRpb24gKyAoY2FtZXJhLnNpemUgLSBjYW1lcmEuYWxpZ25Qb3NpdGlvbikgKyBhbGlnblBvc2l0aW9uO1xuICAgICAgICByZXR1cm4gLWdldFByb2dyZXNzKGNhbVBvcywgcG9zaXRpb24sIGRpc2FwcGVhclBvc05leHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGRpc2FwcGVhclBvc1ByZXYgPSBwb3NpdGlvbiAtIChjYW1lcmEuYWxpZ25Qb3NpdGlvbiArIHRoaXMuX3NpemUgLSBhbGlnblBvc2l0aW9uKTtcbiAgICAgICAgcmV0dXJuIDEgLSBnZXRQcm9ncmVzcyhjYW1Qb3MsIGRpc2FwcGVhclBvc1ByZXYsIHBvc2l0aW9uKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwidmlzaWJsZVJhdGlvXCIsIHtcbiAgICAvKipcclxuICAgICAqIFBlcmNlbnRhZ2Ugb2YgYXJlYSB3aGVyZSBwYW5lbCBpcyB2aXNpYmxlIGluIHRoZSB2aWV3cG9ydFxyXG4gICAgICogQGtvIOu3sO2PrO2KuCDslYjsl5DshJwg7Yyo64SQ7J20IOuztOydtOuKlCDsmIHsl63snZgg67mE7JyoXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciByYW5nZSA9IHRoaXMucmFuZ2U7XG4gICAgICB2YXIgc2l6ZSA9IHRoaXMuX3NpemU7XG4gICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICB2YXIgdmlzaWJsZVJhbmdlID0gdGhpcy5fZmxpY2tpbmcuY2FtZXJhLnZpc2libGVSYW5nZTtcbiAgICAgIHZhciBjaGVja2luZ1JhbmdlID0ge1xuICAgICAgICBtaW46IHJhbmdlLm1pbiArIG9mZnNldCxcbiAgICAgICAgbWF4OiByYW5nZS5tYXggKyBvZmZzZXRcbiAgICAgIH07XG4gICAgICBpZiAoY2hlY2tpbmdSYW5nZS5tYXggPD0gdmlzaWJsZVJhbmdlLm1pbiB8fCBjaGVja2luZ1JhbmdlLm1pbiA+PSB2aXNpYmxlUmFuZ2UubWF4KSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgdmFyIHZpc2libGVTaXplID0gc2l6ZTtcbiAgICAgIGlmICh2aXNpYmxlUmFuZ2UubWluID4gY2hlY2tpbmdSYW5nZS5taW4pIHtcbiAgICAgICAgdmlzaWJsZVNpemUgLT0gdmlzaWJsZVJhbmdlLm1pbiAtIGNoZWNraW5nUmFuZ2UubWluO1xuICAgICAgfVxuICAgICAgaWYgKHZpc2libGVSYW5nZS5tYXggPCBjaGVja2luZ1JhbmdlLm1heCkge1xuICAgICAgICB2aXNpYmxlU2l6ZSAtPSBjaGVja2luZ1JhbmdlLm1heCAtIHZpc2libGVSYW5nZS5tYXg7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmlzaWJsZVNpemUgLyBzaXplO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJhbGlnblwiLCB7XG4gICAgLy8gT3B0aW9ucyBHZXR0ZXJcbiAgICAvKipcclxuICAgICAqIEEgdmFsdWUgaW5kaWNhdGluZyB3aGVyZSB0aGUge0BsaW5rIFBhbmVsI2FsaWduUG9zaXRpb24gYWxpZ25Qb3NpdGlvbn0gc2hvdWxkIGJlIGxvY2F0ZWQgYXQgaW5zaWRlIHRoZSBwYW5lbCBlbGVtZW50XHJcbiAgICAgKiBAa28ge0BsaW5rIFBhbmVsI2FsaWduUG9zaXRpb24gYWxpZ25Qb3NpdGlvbn3snbQg7Yyo64SQIOuCtOydmCDslrTrlJTsl5Ag7JyE7LmY7ZW07JW8IO2VmOuKlOyngOulvCDrgpjtg4DrgrTripQg6rCSXHJcbiAgICAgKiBAdHlwZSB7Q29uc3RhbnRzLkFMSUdOIHwgc3RyaW5nIHwgbnVtYmVyfVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYWxpZ247XG4gICAgfSxcbiAgICAvLyBPcHRpb25zIFNldHRlclxuICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgdGhpcy5fYWxpZ24gPSB2YWw7XG4gICAgICB0aGlzLl91cGRhdGVBbGlnblBvcygpO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICAvKipcclxuICAgKiBNYXJrIHBhbmVsIGVsZW1lbnQgdG8gYmUgYXBwZW5kZWQgb24gdGhlIGNhbWVyYSBlbGVtZW50XHJcbiAgICogQGludGVybmFsXHJcbiAgICovXG4gIF9fcHJvdG8ubWFya0ZvclNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fcmVuZGVyZWQgPSB0cnVlO1xuICAgIHRoaXMuX2VsUHJvdmlkZXIuc2hvdyh0aGlzLl9mbGlja2luZyk7XG4gIH07XG4gIC8qKlxyXG4gICAqIE1hcmsgcGFuZWwgZWxlbWVudCB0byBiZSByZW1vdmVkIGZyb20gdGhlIGNhbWVyYSBlbGVtZW50XHJcbiAgICogQGludGVybmFsXHJcbiAgICovXG4gIF9fcHJvdG8ubWFya0ZvckhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fcmVuZGVyZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9lbFByb3ZpZGVyLmhpZGUodGhpcy5fZmxpY2tpbmcpO1xuICB9O1xuICAvKipcclxuICAgKiBVcGRhdGUgc2l6ZSBvZiB0aGUgcGFuZWxcclxuICAgKiBAa28g7Yyo64SQ7J2YIO2BrOq4sOulvCDqsLHsi6Dtlanri4jri6RcclxuICAgKiBAcGFyYW0ge29iamVjdH0gY2FjaGVkIFByZWRlZmluZWQgY2FjaGVkIHNpemUgb2YgdGhlIHBhbmVsPGtvPuyCrOyghOyXkCDsupDsi5zrkJwg7Yyo64SQ7J2YIO2BrOq4sCDsoJXrs7Q8L2tvPlxyXG4gICAqIEBjaGFpbmFibGVcclxuICAgKiBAcmV0dXJuIHt0aGlzfVxyXG4gICAqL1xuICBfX3Byb3RvLnJlc2l6ZSA9IGZ1bmN0aW9uIChjYWNoZWQpIHtcbiAgICB2YXIgX2E7XG4gICAgdmFyIGVsID0gdGhpcy5lbGVtZW50O1xuICAgIHZhciBmbGlja2luZyA9IHRoaXMuX2ZsaWNraW5nO1xuICAgIHZhciBob3Jpem9udGFsID0gZmxpY2tpbmcuaG9yaXpvbnRhbCxcbiAgICAgIHVzZUZyYWN0aW9uYWxTaXplID0gZmxpY2tpbmcudXNlRnJhY3Rpb25hbFNpemU7XG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgdGhpcy5fc2l6ZSA9IGNhY2hlZC5zaXplO1xuICAgICAgdGhpcy5fbWFyZ2luID0gX19hc3NpZ24kMih7fSwgY2FjaGVkLm1hcmdpbik7XG4gICAgICB0aGlzLl9oZWlnaHQgPSAoX2EgPSBjYWNoZWQuaGVpZ2h0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBnZXRFbGVtZW50U2l6ZSh7XG4gICAgICAgIGVsOiBlbCxcbiAgICAgICAgaG9yaXpvbnRhbDogZmFsc2UsXG4gICAgICAgIHVzZUZyYWN0aW9uYWxTaXplOiB1c2VGcmFjdGlvbmFsU2l6ZSxcbiAgICAgICAgdXNlT2Zmc2V0OiB0cnVlLFxuICAgICAgICBzdHlsZTogZ2V0U3R5bGUoZWwpXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGVsU3R5bGUgPSBnZXRTdHlsZShlbCk7XG4gICAgICB0aGlzLl9zaXplID0gZ2V0RWxlbWVudFNpemUoe1xuICAgICAgICBlbDogZWwsXG4gICAgICAgIGhvcml6b250YWw6IGhvcml6b250YWwsXG4gICAgICAgIHVzZUZyYWN0aW9uYWxTaXplOiB1c2VGcmFjdGlvbmFsU2l6ZSxcbiAgICAgICAgdXNlT2Zmc2V0OiB0cnVlLFxuICAgICAgICBzdHlsZTogZWxTdHlsZVxuICAgICAgfSk7XG4gICAgICB0aGlzLl9tYXJnaW4gPSBob3Jpem9udGFsID8ge1xuICAgICAgICBwcmV2OiBwYXJzZUZsb2F0KGVsU3R5bGUubWFyZ2luTGVmdCB8fCBcIjBcIiksXG4gICAgICAgIG5leHQ6IHBhcnNlRmxvYXQoZWxTdHlsZS5tYXJnaW5SaWdodCB8fCBcIjBcIilcbiAgICAgIH0gOiB7XG4gICAgICAgIHByZXY6IHBhcnNlRmxvYXQoZWxTdHlsZS5tYXJnaW5Ub3AgfHwgXCIwXCIpLFxuICAgICAgICBuZXh0OiBwYXJzZUZsb2F0KGVsU3R5bGUubWFyZ2luQm90dG9tIHx8IFwiMFwiKVxuICAgICAgfTtcbiAgICAgIHRoaXMuX2hlaWdodCA9IGhvcml6b250YWwgPyBnZXRFbGVtZW50U2l6ZSh7XG4gICAgICAgIGVsOiBlbCxcbiAgICAgICAgaG9yaXpvbnRhbDogZmFsc2UsXG4gICAgICAgIHVzZUZyYWN0aW9uYWxTaXplOiB1c2VGcmFjdGlvbmFsU2l6ZSxcbiAgICAgICAgdXNlT2Zmc2V0OiB0cnVlLFxuICAgICAgICBzdHlsZTogZWxTdHlsZVxuICAgICAgfSkgOiB0aGlzLl9zaXplO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZVBvc2l0aW9uKCk7XG4gICAgdGhpcy5fdXBkYXRlQWxpZ25Qb3MoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXHJcbiAgICogQ2hhbmdlIHBhbmVsJ3Mgc2l6ZS4gVGhpcyB3aWxsIGNoYW5nZSB0aGUgYWN0dWFsIHNpemUgb2YgdGhlIHBhbmVsIGVsZW1lbnQgYnkgY2hhbmdpbmcgaXRzIENTUyB3aWR0aC9oZWlnaHQgcHJvcGVydHlcclxuICAgKiBAa28g7Yyo64SQIO2BrOq4sOulvCDrs4Dqsr3tlanri4jri6QuIO2MqOuEkCDsl5jrpqzrqLztirjsl5Ag7ZW064u5IO2BrOq4sOydmCBDU1Mgd2lkdGgvaGVpZ2h066W8IOyggeyaqe2VqeuLiOuLpFxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbc2l6ZV0gTmV3IHBhbmVsIHNpemU8a28+7IOIIO2MqOuEkCDtgazquLA8L2tvPlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW3NpemUud2lkdGhdIENTUyBzdHJpbmcgb3IgbnVtYmVyKGluIHB4KTxrbz5DU1Mg66y47J6Q7Je0IOuYkOuKlCDsiKvsnpAocHgpPC9rbz5cclxuICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtzaXplLmhlaWdodF0gQ1NTIHN0cmluZyBvciBudW1iZXIoaW4gcHgpPGtvPkNTUyDrrLjsnpDsl7Qg65iQ64qUIOyIq+yekChweCk8L2tvPlxyXG4gICAqIEBjaGFpbmFibGVcclxuICAgKiBAcmV0dXJuIHt0aGlzfVxyXG4gICAqL1xuICBfX3Byb3RvLnNldFNpemUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICAgIHNldFNpemUodGhpcy5lbGVtZW50LCBzaXplKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXHJcbiAgICogQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gZWxlbWVudCBpcyBpbnNpZGUgb2YgdGhpcyBwYW5lbCdzIHtAbGluayBQYW5lbCNlbGVtZW50IGVsZW1lbnR9XHJcbiAgICogQGtvIO2VtOuLuSDsl5jrpqzrqLztirjqsIAg7J20IO2MqOuEkOydmCB7QGxpbmsgUGFuZWwjZWxlbWVudCBlbGVtZW50fSDrgrTsl5Ag7Y+s7ZWo65CY7Ja0IOyeiOuKlOyngOulvCDrsJjtmZjtlanri4jri6RcclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IFRoZSBIVE1MRWxlbWVudCB0byBjaGVjazxrbz7tmZXsnbjtlZjqs6DsnpAg7ZWY64qUIEhUTUxFbGVtZW50PC9rbz5cclxuICAgKiBAcmV0dXJuIHtib29sZWFufSBBIEJvb2xlYW4gdmFsdWUgaW5kaWNhdGluZyB0aGUgZWxlbWVudCBpcyBpbnNpZGUgb2YgdGhpcyBwYW5lbCB7QGxpbmsgUGFuZWwjZWxlbWVudCBlbGVtZW50fTxrbz7tjKjrhJDsnZgge0BsaW5rIFBhbmVsI2VsZW1lbnQgZWxlbWVudH3rgrTsl5Ag7ZW064u5IOyXmOumrOuovO2KuCDtj6ztlagg7Jes67aAPC9rbz5cclxuICAgKi9cbiAgX19wcm90by5jb250YWlucyA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAhISgoX2EgPSB0aGlzLmVsZW1lbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb250YWlucyhlbGVtZW50KSk7XG4gIH07XG4gIC8qKlxyXG4gICAqIFJlc2V0IGludGVybmFsIHN0YXRlIGFuZCBzZXQge0BsaW5rIFBhbmVsI3JlbW92ZWQgcmVtb3ZlZH0gdG8gYHRydWVgXHJcbiAgICogQGtvIOuCtOu2gCDsg4Htg5zrpbwg7LSI6riw7ZmU7ZWY6rOgIHtAbGluayBQYW5lbCNyZW1vdmVkIHJlbW92ZWR966W8IGB0cnVlYOuhnCDshKTsoJXtlanri4jri6QuXHJcbiAgICogQHJldHVybiB7dm9pZH1cclxuICAgKi9cbiAgX19wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3Jlc2V0SW50ZXJuYWxTdGF0ZXMoKTtcbiAgICB0aGlzLl9yZW1vdmVkID0gdHJ1ZTtcbiAgfTtcbiAgLyoqXHJcbiAgICogQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gcG9zaXRpb24gaXMgaW5zaWRlIG9mIHRoaXMgcGFuZWwncyB7QGxpbmsgUGFuZWwjcmFuZ2UgcmFuZ2V9XHJcbiAgICogQGtvIOyjvOyWtOynhCDsooztkZzqsIAg7ZiE7J6sIO2MqOuEkOydmCB7QGxpbmsgUGFuZWwjcmFuZ2UgcmFuZ2V964K07JeQIOyGje2VtOyeiOuKlOyngOulvCDrsJjtmZjtlanri4jri6QuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHBvcyBBIHBvc2l0aW9uIHRvIGNoZWNrPGtvPu2ZleyduO2VmOqzoOyekCDtlZjripQg7KKM7ZGcPC9rbz5cclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbmNsdWRlTWFyZ2luPWZhbHNlXSBJbmNsdWRlIHtAbGluayBQYW5lbCNtYXJnaW4gbWFyZ2lufSB0byB0aGUgcmFuZ2U8a28+7Yyo64SQIOyYgeyXreyXkCB7QGxpbmsgUGFuZWwjbWFyZ2luIG1hcmdpbn3qsJLsnYQg7Y+s7ZWo7Iuc7YK164uI64ukPC9rbz5cclxuICAgKiBAcmV0dXJuIHtib29sZWFufSBBIEJvb2xlYW4gdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBnaXZlbiBwb3NpdGlvbiBpcyBpbmNsdWRlZCBpbiB0aGUgcGFuZWwgcmFuZ2U8a28+7ZW064u5IOyijO2RnOqwgCDtjKjrhJAg7JiB7JetIOuCtOyXkCDsho3tlbTsnojripTsp4Ag7Jes67aAPC9rbz5cclxuICAgKi9cbiAgX19wcm90by5pbmNsdWRlUG9zaXRpb24gPSBmdW5jdGlvbiAocG9zLCBpbmNsdWRlTWFyZ2luKSB7XG4gICAgaWYgKGluY2x1ZGVNYXJnaW4gPT09IHZvaWQgMCkge1xuICAgICAgaW5jbHVkZU1hcmdpbiA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5pbmNsdWRlUmFuZ2UocG9zLCBwb3MsIGluY2x1ZGVNYXJnaW4pO1xuICB9O1xuICAvKipcclxuICAgKiBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiByYW5nZSBpcyBmdWxseSBpbmNsdWRlZCBpbiB0aGlzIHBhbmVsJ3MgYXJlYSAoaW5jbHVzaXZlKVxyXG4gICAqIEBrbyDso7zslrTsp4Qg67KU7JyE6rCAIOydtCDtjKjrhJAg64K067aA7JeQIOyZhOyghO2eiCDtj6ztlajrkJjripTsp4Drpbwg67CY7ZmY7ZWp64uI64ukXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG1pbiBNaW5pbXVtIHZhbHVlIG9mIHRoZSByYW5nZSB0byBjaGVjazxrbz7tmZXsnbjtlZjqs6DsnpAg7ZWY64qUIOy1nOyGjCDrspTsnIQ8L2tvPlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtYXggTWF4aW11bSB2YWx1ZSBvZiB0aGUgcmFuZ2UgdG8gY2hlY2s8a28+7ZmV7J247ZWY6rOg7J6QIO2VmOuKlCDstZzrjIAg67KU7JyEPC9rbz5cclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbmNsdWRlTWFyZ2luPWZhbHNlXSBJbmNsdWRlIHtAbGluayBQYW5lbCNtYXJnaW4gbWFyZ2lufSB0byB0aGUgcmFuZ2U8a28+7Yyo64SQIOyYgeyXreyXkCB7QGxpbmsgUGFuZWwjbWFyZ2luIG1hcmdpbn3qsJLsnYQg7Y+s7ZWo7Iuc7YK164uI64ukPC9rbz5cclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gQSBCb29sZWFuIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciB0aGUgZ2l2ZW4gcmFuZ2UgaXMgZnVsbHkgaW5jbHVkZWQgaW4gdGhlIHBhbmVsIHJhbmdlPGtvPu2VtOuLuSDrspTsnITqsIAg7Yyo64SQIOyYgeyXrSDrgrTsl5Ag7JmE7KCE7Z6IIOyGje2VtOyeiOuKlOyngCDsl6zrtoA8L2tvPlxyXG4gICAqL1xuICBfX3Byb3RvLmluY2x1ZGVSYW5nZSA9IGZ1bmN0aW9uIChtaW4sIG1heCwgaW5jbHVkZU1hcmdpbikge1xuICAgIGlmIChpbmNsdWRlTWFyZ2luID09PSB2b2lkIDApIHtcbiAgICAgIGluY2x1ZGVNYXJnaW4gPSBmYWxzZTtcbiAgICB9XG4gICAgdmFyIG1hcmdpbiA9IHRoaXMuX21hcmdpbjtcbiAgICB2YXIgcGFuZWxSYW5nZSA9IHRoaXMucmFuZ2U7XG4gICAgaWYgKGluY2x1ZGVNYXJnaW4pIHtcbiAgICAgIHBhbmVsUmFuZ2UubWluIC09IG1hcmdpbi5wcmV2O1xuICAgICAgcGFuZWxSYW5nZS5tYXggKz0gbWFyZ2luLm5leHQ7XG4gICAgfVxuICAgIHJldHVybiBtYXggPj0gcGFuZWxSYW5nZS5taW4gJiYgbWluIDw9IHBhbmVsUmFuZ2UubWF4O1xuICB9O1xuICAvKipcclxuICAgKiBDaGVjayB3aGV0aGVyIHRoZSBwYW5lbCBpcyB2aXNibGUgaW4gdGhlIGdpdmVuIHJhbmdlIChleGNsdXNpdmUpXHJcbiAgICogQGtvIOyjvOyWtOynhCDrspTsnIQg64K07JeQ7IScIOydtCDtjKjrhJDsnZgg7J2867aA6rCAIOuztOyXrOyngOuKlOyngOulvCDrsJjtmZjtlanri4jri6RcclxuICAgKiBAcGFyYW0ge251bWJlcn0gbWluIE1pbmltdW0gdmFsdWUgb2YgdGhlIHJhbmdlIHRvIGNoZWNrPGtvPu2ZleyduO2VmOqzoOyekCDtlZjripQg7LWc7IaMIOuylOychDwva28+XHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG1heCBNYXhpbXVtIHZhbHVlIG9mIHRoZSByYW5nZSB0byBjaGVjazxrbz7tmZXsnbjtlZjqs6DsnpAg7ZWY64qUIOy1nOuMgCDrspTsnIQ8L2tvPlxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBBIEJvb2xlYW4gdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBwYW5lbCBpcyB2aXNpYmxlPGtvPu2VtOuLuSDrspTsnIQg64K07JeQ7IScIO2MqOuEkOydhCDrs7wg7IiYIOyeiOuKlOyngCDsl6zrtoA8L2tvPlxyXG4gICAqL1xuICBfX3Byb3RvLmlzVmlzaWJsZU9uUmFuZ2UgPSBmdW5jdGlvbiAobWluLCBtYXgpIHtcbiAgICB2YXIgcGFuZWxSYW5nZSA9IHRoaXMucmFuZ2U7XG4gICAgcmV0dXJuIG1heCA+IHBhbmVsUmFuZ2UubWluICYmIG1pbiA8IHBhbmVsUmFuZ2UubWF4O1xuICB9O1xuICAvKipcclxuICAgKiBNb3ZlIHtAbGluayBDYW1lcmF9IHRvIHRoaXMgcGFuZWxcclxuICAgKiBAa28ge0BsaW5rIENhbWVyYX3rpbwg7J20IO2MqOuEkOuhnCDsnbTrj5ntlanri4jri6RcclxuICAgKiBAcGFyYW0ge251bWJlcn0gW2R1cmF0aW9uXSBEdXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uICh1bml0OiBtcyk8a28+7JWg64uI66mU7J207IWYIOynhO2WiSDsi5zqsIQgKOuLqOychDogbXMpPC9rbz5cclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn0gQSBQcm9taXNlIHdoaWNoIHdpbGwgYmUgcmVzb2x2ZWQgYWZ0ZXIgcmVhY2hpbmcgdGhlIHBhbmVsPGtvPu2MqOuEkCDrj4Tri6zsi5zsl5AgcmVzb2x2ZeuQmOuKlCBQcm9taXNlPC9rbz5cclxuICAgKi9cbiAgX19wcm90by5mb2N1cyA9IGZ1bmN0aW9uIChkdXJhdGlvbikge1xuICAgIHJldHVybiB0aGlzLl9mbGlja2luZy5tb3ZlVG8odGhpcy5faW5kZXgsIGR1cmF0aW9uKTtcbiAgfTtcbiAgLyoqXHJcbiAgICogR2V0IHByZXZpb3VzKGBpbmRleCAtIDFgKSBwYW5lbC4gV2hlbiB0aGUgcHJldmlvdXMgcGFuZWwgZG9lcyBub3QgZXhpc3QsIHRoaXMgd2lsbCByZXR1cm4gYG51bGxgIGluc3RlYWRcclxuICAgKiBJZiB0aGUge0BsaW5rIEZsaWNraW5nI2NpcmN1bGFyRW5hYmxlZCBjaXJjdWxhcn0gaXMgZW5hYmxlZCwgdGhpcyB3aWxsIHJldHVybiB0aGUgbGFzdCBwYW5lbCBpZiBjYWxsZWQgZnJvbSB0aGUgZmlyc3QgcGFuZWxcclxuICAgKiBAa28g7J207KCEKGBpbmRleCAtIDFgKSDtjKjrhJDsnYQg67CY7ZmY7ZWp64uI64ukLiDsnbTsoIQg7Yyo64SQ7J20IOyXhuydhCDqsr3smrAgYG51bGxg7J2EIOuwmO2ZmO2VqeuLiOuLpFxyXG4gICAqIHtAbGluayBGbGlja2luZyNjaXJjdWxhckVuYWJsZWQgY2lyY3VsYXJ9IOuqqOuTnOqwgCDtmZzshLHtmZTrkJjsl4jsnYQg65WMIOyyq+uyiOynuCDtjKjrhJDsl5DshJwg7J20IOuplOyGjOuTnOulvCDtmLjstpztlaAg6rK97JqwIOuniOyngOuniSDtjKjrhJDsnYQg67CY7ZmY7ZWp64uI64ukXHJcbiAgICogQHJldHVybnMge1BhbmVsIHwgbnVsbH0gVGhlIHByZXZpb3VzIHBhbmVsPGtvPuydtOyghCDtjKjrhJA8L2tvPlxyXG4gICAqL1xuICBfX3Byb3RvLnByZXYgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5faW5kZXg7XG4gICAgdmFyIGZsaWNraW5nID0gdGhpcy5fZmxpY2tpbmc7XG4gICAgdmFyIHJlbmRlcmVyID0gZmxpY2tpbmcucmVuZGVyZXI7XG4gICAgdmFyIHBhbmVsQ291bnQgPSByZW5kZXJlci5wYW5lbENvdW50O1xuICAgIGlmIChwYW5lbENvdW50ID09PSAxKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gZmxpY2tpbmcuY2lyY3VsYXJFbmFibGVkID8gcmVuZGVyZXIuZ2V0UGFuZWwoaW5kZXggPT09IDAgPyBwYW5lbENvdW50IC0gMSA6IGluZGV4IC0gMSkgOiByZW5kZXJlci5nZXRQYW5lbChpbmRleCAtIDEpO1xuICB9O1xuICAvKipcclxuICAgKiBHZXQgbmV4dChgaW5kZXggKyAxYCkgcGFuZWwuIFdoZW4gdGhlIG5leHQgcGFuZWwgZG9lcyBub3QgZXhpc3QsIHRoaXMgd2lsbCByZXR1cm4gYG51bGxgIGluc3RlYWRcclxuICAgKiBJZiB0aGUge0BsaW5rIEZsaWNraW5nI2NpcmN1bGFyRW5hYmxlZCBjaXJjdWxhcn0gaXMgZW5hYmxlZCwgdGhpcyB3aWxsIHJldHVybiB0aGUgZmlyc3QgcGFuZWwgaWYgY2FsbGVkIGZyb20gdGhlIGxhc3QgcGFuZWxcclxuICAgKiBAa28g64uk7J2MKGBpbmRleCArIDFgKSDtjKjrhJDsnYQg67CY7ZmY7ZWp64uI64ukLiDri6TsnYwg7Yyo64SQ7J20IOyXhuydhCDqsr3smrAgYG51bGxg7J2EIOuwmO2ZmO2VqeuLiOuLpFxyXG4gICAqIHtAbGluayBGbGlja2luZyNjaXJjdWxhckVuYWJsZWQgY2lyY3VsYXJ9IOuqqOuTnOqwgCDtmZzshLHtmZTrkJjsl4jsnYQg65WMIOuniOyngOuniSDtjKjrhJDsl5DshJwg7J20IOuplOyGjOuTnOulvCDtmLjstpztlaAg6rK97JqwIOyyq+uyiOynuCDtjKjrhJDsnYQg67CY7ZmY7ZWp64uI64ukXHJcbiAgICogQHJldHVybnMge1BhbmVsIHwgbnVsbH0gVGhlIHByZXZpb3VzIHBhbmVsPGtvPuuLpOydjCDtjKjrhJA8L2tvPlxyXG4gICAqL1xuICBfX3Byb3RvLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5faW5kZXg7XG4gICAgdmFyIGZsaWNraW5nID0gdGhpcy5fZmxpY2tpbmc7XG4gICAgdmFyIHJlbmRlcmVyID0gZmxpY2tpbmcucmVuZGVyZXI7XG4gICAgdmFyIHBhbmVsQ291bnQgPSByZW5kZXJlci5wYW5lbENvdW50O1xuICAgIGlmIChwYW5lbENvdW50ID09PSAxKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gZmxpY2tpbmcuY2lyY3VsYXJFbmFibGVkID8gcmVuZGVyZXIuZ2V0UGFuZWwoaW5kZXggPT09IHBhbmVsQ291bnQgLSAxID8gMCA6IGluZGV4ICsgMSkgOiByZW5kZXJlci5nZXRQYW5lbChpbmRleCArIDEpO1xuICB9O1xuICAvKipcclxuICAgKiBJbmNyZWFzZSBwYW5lbCdzIGluZGV4IGJ5IHRoZSBnaXZlbiB2YWx1ZVxyXG4gICAqIEBrbyDtjKjrhJDsnZgg7J24642x7Iqk66W8IOyjvOyWtOynhCDqsJLrp4ztgbwg7Kad6rCA7Iuc7YK164uI64ukXHJcbiAgICogQGludGVybmFsXHJcbiAgICogQGNoYWluYWJsZVxyXG4gICAqIEBwYXJhbSB2YWwgQW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMDxrbz4w67O064ukIOqwmeqxsOuCmCDtgbAg7KCV7IiYPC9rbz5cclxuICAgKiBAcmV0dXJucyB7dGhpc31cclxuICAgKi9cbiAgX19wcm90by5pbmNyZWFzZUluZGV4ID0gZnVuY3Rpb24gKHZhbCkge1xuICAgIHRoaXMuX2luZGV4ICs9IE1hdGgubWF4KHZhbCwgMCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxyXG4gICAqIERlY3JlYXNlIHBhbmVsJ3MgaW5kZXggYnkgdGhlIGdpdmVuIHZhbHVlXHJcbiAgICogQGtvIO2MqOuEkOydmCDsnbjrjbHsiqTrpbwg7KO87Ja07KeEIOqwkuunjO2BvCDqsJDshozsi5ztgrXri4jri6RcclxuICAgKiBAaW50ZXJuYWxcclxuICAgKiBAY2hhaW5hYmxlXHJcbiAgICogQHBhcmFtIHZhbCBBbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAwPGtvPjDrs7Tri6Qg6rCZ6rGw64KYIO2BsCDsoJXsiJg8L2tvPlxyXG4gICAqIEByZXR1cm5zIHt0aGlzfVxyXG4gICAqL1xuICBfX3Byb3RvLmRlY3JlYXNlSW5kZXggPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgdGhpcy5faW5kZXggLT0gTWF0aC5tYXgodmFsLCAwKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXHJcbiAgICogQGludGVybmFsXHJcbiAgICovXG4gIF9fcHJvdG8udXBkYXRlUG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByZXZQYW5lbCA9IHRoaXMuX2ZsaWNraW5nLnJlbmRlcmVyLnBhbmVsc1t0aGlzLl9pbmRleCAtIDFdO1xuICAgIHRoaXMuX3BvcyA9IHByZXZQYW5lbCA/IHByZXZQYW5lbC5yYW5nZS5tYXggKyBwcmV2UGFuZWwubWFyZ2luLm5leHQgKyB0aGlzLl9tYXJnaW4ucHJldiA6IHRoaXMuX21hcmdpbi5wcmV2O1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcclxuICAgKiBAaW50ZXJuYWxcclxuICAgKiBAcmV0dXJuIHtib29sZWFufSB0b2dnbGVkXHJcbiAgICovXG4gIF9fcHJvdG8udG9nZ2xlID0gZnVuY3Rpb24gKHByZXZQb3MsIG5ld1Bvcykge1xuICAgIHZhciB0b2dnbGVEaXJlY3Rpb24gPSB0aGlzLl90b2dnbGVEaXJlY3Rpb247XG4gICAgdmFyIHRvZ2dsZVBvc2l0aW9uID0gdGhpcy5fdG9nZ2xlUG9zaXRpb247XG4gICAgaWYgKHRvZ2dsZURpcmVjdGlvbiA9PT0gRElSRUNUSU9OLk5PTkUgfHwgbmV3UG9zID09PSBwcmV2UG9zKSByZXR1cm4gZmFsc2U7XG4gICAgdmFyIHByZXZUb2dnbGVkID0gdGhpcy5fdG9nZ2xlZDtcbiAgICBpZiAobmV3UG9zID4gcHJldlBvcykge1xuICAgICAgaWYgKHRvZ2dsZVBvc2l0aW9uID49IHByZXZQb3MgJiYgdG9nZ2xlUG9zaXRpb24gPD0gbmV3UG9zKSB7XG4gICAgICAgIHRoaXMuX3RvZ2dsZWQgPSB0b2dnbGVEaXJlY3Rpb24gPT09IERJUkVDVElPTi5ORVhUO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodG9nZ2xlUG9zaXRpb24gPD0gcHJldlBvcyAmJiB0b2dnbGVQb3NpdGlvbiA+PSBuZXdQb3MpIHtcbiAgICAgICAgdGhpcy5fdG9nZ2xlZCA9IHRvZ2dsZURpcmVjdGlvbiAhPT0gRElSRUNUSU9OLk5FWFQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwcmV2VG9nZ2xlZCAhPT0gdGhpcy5fdG9nZ2xlZDtcbiAgfTtcbiAgLyoqXHJcbiAgICogQGludGVybmFsXHJcbiAgICovXG4gIF9fcHJvdG8udXBkYXRlQ2lyY3VsYXJUb2dnbGVEaXJlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZsaWNraW5nID0gdGhpcy5fZmxpY2tpbmc7XG4gICAgaWYgKCFmbGlja2luZy5jaXJjdWxhckVuYWJsZWQpIHtcbiAgICAgIHRoaXMuX3RvZ2dsZURpcmVjdGlvbiA9IERJUkVDVElPTi5OT05FO1xuICAgICAgdGhpcy5fdG9nZ2xlUG9zaXRpb24gPSAwO1xuICAgICAgdGhpcy5fdG9nZ2xlZCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHZhciBjYW1lcmEgPSBmbGlja2luZy5jYW1lcmE7XG4gICAgdmFyIGNhbVJhbmdlID0gY2FtZXJhLnJhbmdlO1xuICAgIHZhciBjYW1BbGlnblBvc2l0aW9uID0gY2FtZXJhLmFsaWduUG9zaXRpb247XG4gICAgdmFyIGNhbVZpc2libGVSYW5nZSA9IGNhbWVyYS52aXNpYmxlUmFuZ2U7XG4gICAgdmFyIGNhbVZpc2libGVTaXplID0gY2FtVmlzaWJsZVJhbmdlLm1heCAtIGNhbVZpc2libGVSYW5nZS5taW47XG4gICAgdmFyIG1pbmltdW1WaXNpYmxlID0gY2FtUmFuZ2UubWluIC0gY2FtQWxpZ25Qb3NpdGlvbjtcbiAgICB2YXIgbWF4aW11bVZpc2libGUgPSBjYW1SYW5nZS5tYXggLSBjYW1BbGlnblBvc2l0aW9uICsgY2FtVmlzaWJsZVNpemU7XG4gICAgdmFyIHNob3VsZEJlVmlzaWJsZUF0TWluID0gdGhpcy5pbmNsdWRlUmFuZ2UobWF4aW11bVZpc2libGUgLSBjYW1WaXNpYmxlU2l6ZSwgbWF4aW11bVZpc2libGUsIGZhbHNlKTtcbiAgICB2YXIgc2hvdWxkQmVWaXNpYmxlQXRNYXggPSB0aGlzLmluY2x1ZGVSYW5nZShtaW5pbXVtVmlzaWJsZSwgbWluaW11bVZpc2libGUgKyBjYW1WaXNpYmxlU2l6ZSwgZmFsc2UpO1xuICAgIHRoaXMuX3RvZ2dsZWQgPSBmYWxzZTtcbiAgICBpZiAoc2hvdWxkQmVWaXNpYmxlQXRNaW4pIHtcbiAgICAgIHRoaXMuX3RvZ2dsZURpcmVjdGlvbiA9IERJUkVDVElPTi5QUkVWO1xuICAgICAgdGhpcy5fdG9nZ2xlUG9zaXRpb24gPSB0aGlzLnJhbmdlLm1heCArIGNhbVJhbmdlLm1pbiAtIGNhbVJhbmdlLm1heCArIGNhbUFsaWduUG9zaXRpb247XG4gICAgICB0aGlzLnRvZ2dsZShJbmZpbml0eSwgY2FtZXJhLnBvc2l0aW9uKTtcbiAgICB9IGVsc2UgaWYgKHNob3VsZEJlVmlzaWJsZUF0TWF4KSB7XG4gICAgICB0aGlzLl90b2dnbGVEaXJlY3Rpb24gPSBESVJFQ1RJT04uTkVYVDtcbiAgICAgIHRoaXMuX3RvZ2dsZVBvc2l0aW9uID0gdGhpcy5yYW5nZS5taW4gKyBjYW1SYW5nZS5tYXggLSBjYW1WaXNpYmxlU2l6ZSArIGNhbUFsaWduUG9zaXRpb247XG4gICAgICB0aGlzLnRvZ2dsZSgtSW5maW5pdHksIGNhbWVyYS5wb3NpdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3RvZ2dsZURpcmVjdGlvbiA9IERJUkVDVElPTi5OT05FO1xuICAgICAgdGhpcy5fdG9nZ2xlUG9zaXRpb24gPSAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgX19wcm90by5fdXBkYXRlQWxpZ25Qb3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fYWxpZ25Qb3MgPSBwYXJzZUFsaWduJDEodGhpcy5fYWxpZ24sIHRoaXMuX3NpemUpO1xuICB9O1xuICBfX3Byb3RvLl9yZXNldEludGVybmFsU3RhdGVzID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3NpemUgPSAwO1xuICAgIHRoaXMuX3BvcyA9IDA7XG4gICAgdGhpcy5fbWFyZ2luID0ge1xuICAgICAgcHJldjogMCxcbiAgICAgIG5leHQ6IDBcbiAgICB9O1xuICAgIHRoaXMuX2hlaWdodCA9IDA7XG4gICAgdGhpcy5fYWxpZ25Qb3MgPSAwO1xuICAgIHRoaXMuX3RvZ2dsZWQgPSBmYWxzZTtcbiAgICB0aGlzLl90b2dnbGVQb3NpdGlvbiA9IDA7XG4gICAgdGhpcy5fdG9nZ2xlRGlyZWN0aW9uID0gRElSRUNUSU9OLk5PTkU7XG4gIH07XG4gIHJldHVybiBQYW5lbDtcbn0oKTtcblxudmFyIE5vcm1hbFJlbmRlcmluZ1N0cmF0ZWd5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTm9ybWFsUmVuZGVyaW5nU3RyYXRlZ3koX2EpIHtcbiAgICB2YXIgcHJvdmlkZXJDdG9yID0gX2EucHJvdmlkZXJDdG9yO1xuICAgIHRoaXMuX3Byb3ZpZGVyQ3RvciA9IHByb3ZpZGVyQ3RvcjtcbiAgfVxuICB2YXIgX19wcm90byA9IE5vcm1hbFJlbmRlcmluZ1N0cmF0ZWd5LnByb3RvdHlwZTtcbiAgX19wcm90by5yZW5kZXJQYW5lbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gRE9fTk9USElOR1xuICB9O1xuICBfX3Byb3RvLmdldFJlbmRlcmluZ0luZGV4ZXNCeU9yZGVyID0gZnVuY3Rpb24gKGZsaWNraW5nKSB7XG4gICAgdmFyIHJlbmRlcmVkUGFuZWxzID0gZmxpY2tpbmcucmVuZGVyZXIucGFuZWxzLmZpbHRlcihmdW5jdGlvbiAocGFuZWwpIHtcbiAgICAgIHJldHVybiBwYW5lbC5yZW5kZXJlZDtcbiAgICB9KTtcbiAgICB2YXIgdG9nZ2xlZFByZXYgPSByZW5kZXJlZFBhbmVscy5maWx0ZXIoZnVuY3Rpb24gKHBhbmVsKSB7XG4gICAgICByZXR1cm4gcGFuZWwudG9nZ2xlZCAmJiBwYW5lbC50b2dnbGVEaXJlY3Rpb24gPT09IERJUkVDVElPTi5QUkVWO1xuICAgIH0pO1xuICAgIHZhciB0b2dnbGVkTmV4dCA9IHJlbmRlcmVkUGFuZWxzLmZpbHRlcihmdW5jdGlvbiAocGFuZWwpIHtcbiAgICAgIHJldHVybiBwYW5lbC50b2dnbGVkICYmIHBhbmVsLnRvZ2dsZURpcmVjdGlvbiA9PT0gRElSRUNUSU9OLk5FWFQ7XG4gICAgfSk7XG4gICAgdmFyIG5vdFRvZ2dsZWQgPSByZW5kZXJlZFBhbmVscy5maWx0ZXIoZnVuY3Rpb24gKHBhbmVsKSB7XG4gICAgICByZXR1cm4gIXBhbmVsLnRvZ2dsZWQ7XG4gICAgfSk7XG4gICAgcmV0dXJuIF9fc3ByZWFkJDEodG9nZ2xlZFByZXYsIG5vdFRvZ2dsZWQsIHRvZ2dsZWROZXh0KS5tYXAoZnVuY3Rpb24gKHBhbmVsKSB7XG4gICAgICByZXR1cm4gcGFuZWwuaW5kZXg7XG4gICAgfSk7XG4gIH07XG4gIF9fcHJvdG8uZ2V0UmVuZGVyaW5nRWxlbWVudHNCeU9yZGVyID0gZnVuY3Rpb24gKGZsaWNraW5nKSB7XG4gICAgdmFyIHBhbmVscyA9IGZsaWNraW5nLnBhbmVscztcbiAgICByZXR1cm4gdGhpcy5nZXRSZW5kZXJpbmdJbmRleGVzQnlPcmRlcihmbGlja2luZykubWFwKGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgcmV0dXJuIHBhbmVsc1tpbmRleF0uZWxlbWVudDtcbiAgICB9KTtcbiAgfTtcbiAgX19wcm90by51cGRhdGVSZW5kZXJpbmdQYW5lbHMgPSBmdW5jdGlvbiAoZmxpY2tpbmcpIHtcbiAgICBpZiAoZmxpY2tpbmcucmVuZGVyT25seVZpc2libGUpIHtcbiAgICAgIHRoaXMuX3Nob3dPbmx5VmlzaWJsZVBhbmVscyhmbGlja2luZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZsaWNraW5nLnBhbmVscy5mb3JFYWNoKGZ1bmN0aW9uIChwYW5lbCkge1xuICAgICAgICByZXR1cm4gcGFuZWwubWFya0ZvclNob3coKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgX19wcm90by5jb2xsZWN0UGFuZWxzID0gZnVuY3Rpb24gKGZsaWNraW5nLCBlbGVtZW50cykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIGFsaWduID0gcGFyc2VQYW5lbEFsaWduKGZsaWNraW5nLnJlbmRlcmVyLmFsaWduKTtcbiAgICByZXR1cm4gZWxlbWVudHMubWFwKGZ1bmN0aW9uIChlbCwgaW5kZXgpIHtcbiAgICAgIHJldHVybiBuZXcgUGFuZWwoe1xuICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgIGVsZW1lbnRQcm92aWRlcjogbmV3IF90aGlzLl9wcm92aWRlckN0b3IoZWwpLFxuICAgICAgICBhbGlnbjogYWxpZ24sXG4gICAgICAgIGZsaWNraW5nOiBmbGlja2luZ1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG4gIF9fcHJvdG8uY3JlYXRlUGFuZWwgPSBmdW5jdGlvbiAoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgUGFuZWwoX19hc3NpZ24kMihfX2Fzc2lnbiQyKHt9LCBvcHRpb25zKSwge1xuICAgICAgZWxlbWVudFByb3ZpZGVyOiBuZXcgdGhpcy5fcHJvdmlkZXJDdG9yKGVsZW1lbnQpXG4gICAgfSkpO1xuICB9O1xuICBfX3Byb3RvLnVwZGF0ZVBhbmVsU2l6ZXMgPSBmdW5jdGlvbiAoZmxpY2tpbmcsIHNpemUpIHtcbiAgICBmbGlja2luZy5wYW5lbHMuZm9yRWFjaChmdW5jdGlvbiAocGFuZWwpIHtcbiAgICAgIHJldHVybiBwYW5lbC5zZXRTaXplKHNpemUpO1xuICAgIH0pO1xuICB9O1xuICBfX3Byb3RvLl9zaG93T25seVZpc2libGVQYW5lbHMgPSBmdW5jdGlvbiAoZmxpY2tpbmcpIHtcbiAgICB2YXIgcGFuZWxzID0gZmxpY2tpbmcucmVuZGVyZXIucGFuZWxzO1xuICAgIHZhciBjYW1lcmEgPSBmbGlja2luZy5jYW1lcmE7XG4gICAgdmFyIHZpc2libGVJbmRleGVzID0gY2FtZXJhLnZpc2libGVQYW5lbHMucmVkdWNlKGZ1bmN0aW9uICh2aXNpYmxlcywgcGFuZWwpIHtcbiAgICAgIHZpc2libGVzW3BhbmVsLmluZGV4XSA9IHRydWU7XG4gICAgICByZXR1cm4gdmlzaWJsZXM7XG4gICAgfSwge30pO1xuICAgIHBhbmVscy5mb3JFYWNoKGZ1bmN0aW9uIChwYW5lbCkge1xuICAgICAgaWYgKHBhbmVsLmluZGV4IGluIHZpc2libGVJbmRleGVzIHx8IHBhbmVsLmxvYWRpbmcpIHtcbiAgICAgICAgcGFuZWwubWFya0ZvclNob3coKTtcbiAgICAgIH0gZWxzZSBpZiAoIWZsaWNraW5nLmhvbGRpbmcpIHtcbiAgICAgICAgLy8gRHVyaW5nIHRoZSBpbnB1dCBzZXF1ZW5jZSxcbiAgICAgICAgLy8gRG8gbm90IHJlbW92ZSBwYW5lbCBlbGVtZW50cyBhcyBpdCB3b24ndCB0cmlnZ2VyIHRvdWNoZW5kIGV2ZW50LlxuICAgICAgICBwYW5lbC5tYXJrRm9ySGlkZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNhbWVyYS51cGRhdGVPZmZzZXQoKTtcbiAgfTtcbiAgcmV0dXJuIE5vcm1hbFJlbmRlcmluZ1N0cmF0ZWd5O1xufSgpO1xuXG4vKipcclxuICogQW4gc2xpZGUgZGF0YSBjb21wb25lbnQgdGhhdCBob2xkcyBpbmZvcm1hdGlvbiBvZiBhIHNpbmdsZSBIVE1MRWxlbWVudFxyXG4gKiBAa28g7Iqs65287J2065OcIOuNsOydtO2EsCDsu7Ttj6zrhIztirjroZwsIOuLqOydvCBIVE1MRWxlbWVudOydmCDsoJXrs7Trpbwg6rCW6rOgIOyeiOyKteuLiOuLpFxyXG4gKi9cbnZhciBWaXJ0dWFsUGFuZWwgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMkMyhWaXJ0dWFsUGFuZWwsIF9zdXBlcik7XG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIEFuIG9wdGlvbnMgb2JqZWN0PGtvPuyYteyFmCDsmKTruIzsoJ3tirg8L2tvPlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5pbmRleF0gQW4gaW5pdGlhbCBpbmRleCBvZiB0aGUgcGFuZWw8a28+7Yyo64SQ7J2YIOy0iOq4sCDsnbjrjbHsiqQ8L2tvPlxyXG4gICAqIEBwYXJhbSB7Q29uc3RhbnRzLkFMSUdOIHwgc3RyaW5nIHwgbnVtYmVyfSBbb3B0aW9ucy5hbGlnbl0gQW4gaW5pdGlhbCB7QGxpbmsgRmxpY2tpbmcjYWxpZ24gYWxpZ259IHZhbHVlIG9mIHRoZSBwYW5lbDxrbz7tjKjrhJDsnZgg7LSI6riwIHtAbGluayBGbGlja2luZyNhbGlnbiBhbGlnbn3qsJI8L2tvPlxyXG4gICAqIEBwYXJhbSB7RmxpY2tpbmd9IFtvcHRpb25zLmZsaWNraW5nXSBBIEZsaWNraW5nIGluc3RhbmNlIHBhbmVsJ3MgcmVmZXJlbmNpbmc8a28+7Yyo64SQ7J20IOywuOyhsO2VmOuKlCB7QGxpbmsgRmxpY2tpbmd9IOyduOyKpO2EtOyKpDwva28+XHJcbiAgICovXG4gIGZ1bmN0aW9uIFZpcnR1YWxQYW5lbChvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9ucykgfHwgdGhpcztcbiAgICBvcHRpb25zLmVsZW1lbnRQcm92aWRlci5pbml0KF90aGlzKTtcbiAgICBfdGhpcy5fZWxQcm92aWRlciA9IG9wdGlvbnMuZWxlbWVudFByb3ZpZGVyO1xuICAgIF90aGlzLl9jYWNoZWRJbm5lckhUTUwgPSBudWxsO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICB2YXIgX19wcm90byA9IFZpcnR1YWxQYW5lbC5wcm90b3R5cGU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcImVsZW1lbnRcIiwge1xuICAgIC8qKlxyXG4gICAgICogYEhUTUxFbGVtZW50YCB0aGF0IHBhbmVsJ3MgcmVmZXJlbmNpbmdcclxuICAgICAqIEBrbyDtjKjrhJDsnbQg7LC47KGw7ZWY6rOgIOyeiOuKlCBgSFRNTEVsZW1lbnRgXHJcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2VsUHJvdmlkZXIuZWxlbWVudDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwiY2FjaGVkSW5uZXJIVE1MXCIsIHtcbiAgICAvKipcclxuICAgICAqIENhY2hlZCBpbm5lckhUTUwgYnkgdGhlIHByZXZpb3VzIHJlbmRlciBmdW5jdGlvblxyXG4gICAgICogQGtvIOydtOyghCDroIzrjZTrp4Hsl5DshJwg7LqQ7Iuc65CcIGlubmVySFRNTCDsoJXrs7RcclxuICAgICAqIEB0eXBlIHtzdHJpbmd8bnVsbH1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2FjaGVkSW5uZXJIVE1MO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJlbGVtZW50SW5kZXhcIiwge1xuICAgIC8qKlxyXG4gICAgICogQW4gbnVtYmVyIGZvciBpbmRleGluZyB3aGljaCBlbGVtZW50IGl0IHdpbGwgYmUgcmVuZGVyZWQgb25cclxuICAgICAqIEBrbyDrqocg67KI7Ke4IOyXmOumrOuovO2KuOyXkCDroIzrjZTrp4HrkKAg6rKD7J247KeA66W8IOuCmO2DgOuCtOuKlCDsiKvsnpBcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGZsaWNraW5nID0gdGhpcy5fZmxpY2tpbmc7XG4gICAgICB2YXIgdmlydHVhbEVsQ291bnQgPSBmbGlja2luZy5wYW5lbHNQZXJWaWV3ICsgMTtcbiAgICAgIHZhciBwYW5lbENvdW50ID0gZmxpY2tpbmcucGFuZWxDb3VudDtcbiAgICAgIHZhciBpbmRleCA9IHRoaXMuX2luZGV4O1xuICAgICAgaWYgKHRoaXMuX3RvZ2dsZWQpIHtcbiAgICAgICAgLy8gVG8gcHJldmVudCBlbGVtZW50IGR1cGxpY2F0aW9uXG4gICAgICAgIGluZGV4ID0gdGhpcy5fdG9nZ2xlRGlyZWN0aW9uID09PSBESVJFQ1RJT04uTkVYVCA/IGluZGV4ICsgcGFuZWxDb3VudCA6IGluZGV4IC0gcGFuZWxDb3VudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjaXJjdWxhdGVJbmRleChpbmRleCwgdmlydHVhbEVsQ291bnQpO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBfX3Byb3RvLmNhY2hlUmVuZGVyUmVzdWx0ID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgIHRoaXMuX2NhY2hlZElubmVySFRNTCA9IHJlc3VsdDtcbiAgfTtcbiAgX19wcm90by51bmNhY2hlUmVuZGVyUmVzdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2NhY2hlZElubmVySFRNTCA9IG51bGw7XG4gIH07XG4gIF9fcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBmbGlja2luZyA9IHRoaXMuX2ZsaWNraW5nO1xuICAgIHZhciBfYSA9IGZsaWNraW5nLnZpcnR1YWwsXG4gICAgICByZW5kZXJQYW5lbCA9IF9hLnJlbmRlclBhbmVsLFxuICAgICAgY2FjaGUgPSBfYS5jYWNoZTtcbiAgICB2YXIgZWxlbWVudCA9IHRoaXMuX2VsUHJvdmlkZXIuZWxlbWVudDtcbiAgICB2YXIgbmV3SW5uZXJIVE1MID0gdGhpcy5fY2FjaGVkSW5uZXJIVE1MIHx8IHJlbmRlclBhbmVsKHRoaXMsIHRoaXMuX2luZGV4KTtcbiAgICBpZiAobmV3SW5uZXJIVE1MID09PSBlbGVtZW50LmlubmVySFRNTCkgcmV0dXJuO1xuICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gbmV3SW5uZXJIVE1MO1xuICAgIGlmIChjYWNoZSkge1xuICAgICAgdGhpcy5jYWNoZVJlbmRlclJlc3VsdChuZXdJbm5lckhUTUwpO1xuICAgIH1cbiAgfTtcbiAgX19wcm90by5pbmNyZWFzZUluZGV4ID0gZnVuY3Rpb24gKHZhbCkge1xuICAgIHRoaXMudW5jYWNoZVJlbmRlclJlc3VsdCgpO1xuICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmluY3JlYXNlSW5kZXguY2FsbCh0aGlzLCB2YWwpO1xuICB9O1xuICBfX3Byb3RvLmRlY3JlYXNlSW5kZXggPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgdGhpcy51bmNhY2hlUmVuZGVyUmVzdWx0KCk7XG4gICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuZGVjcmVhc2VJbmRleC5jYWxsKHRoaXMsIHZhbCk7XG4gIH07XG4gIHJldHVybiBWaXJ0dWFsUGFuZWw7XG59KFBhbmVsKTtcblxudmFyIFZpcnR1YWxSZW5kZXJpbmdTdHJhdGVneSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFZpcnR1YWxSZW5kZXJpbmdTdHJhdGVneSgpIHt9XG4gIHZhciBfX3Byb3RvID0gVmlydHVhbFJlbmRlcmluZ1N0cmF0ZWd5LnByb3RvdHlwZTtcbiAgX19wcm90by5yZW5kZXJQYW5lbHMgPSBmdW5jdGlvbiAoZmxpY2tpbmcpIHtcbiAgICB2YXIgdmlydHVhbE1hbmFnZXIgPSBmbGlja2luZy52aXJ0dWFsO1xuICAgIHZhciB2aXNpYmxlUGFuZWxzID0gZmxpY2tpbmcudmlzaWJsZVBhbmVscztcbiAgICB2YXIgaW52aXNpYmxlSW5kZXhlcyA9IHJhbmdlKGZsaWNraW5nLnBhbmVsc1BlclZpZXcgKyAxKTtcbiAgICB2aXNpYmxlUGFuZWxzLmZvckVhY2goZnVuY3Rpb24gKHBhbmVsKSB7XG4gICAgICB2YXIgZWxlbWVudEluZGV4ID0gcGFuZWwuZWxlbWVudEluZGV4O1xuICAgICAgcGFuZWwucmVuZGVyKCk7XG4gICAgICB2aXJ0dWFsTWFuYWdlci5zaG93KGVsZW1lbnRJbmRleCk7XG4gICAgICBpbnZpc2libGVJbmRleGVzW2VsZW1lbnRJbmRleF0gPSAtMTtcbiAgICB9KTtcbiAgICBpbnZpc2libGVJbmRleGVzLmZpbHRlcihmdW5jdGlvbiAodmFsKSB7XG4gICAgICByZXR1cm4gdmFsID49IDA7XG4gICAgfSkuZm9yRWFjaChmdW5jdGlvbiAoaWR4KSB7XG4gICAgICB2aXJ0dWFsTWFuYWdlci5oaWRlKGlkeCk7XG4gICAgfSk7XG4gIH07XG4gIF9fcHJvdG8uZ2V0UmVuZGVyaW5nSW5kZXhlc0J5T3JkZXIgPSBmdW5jdGlvbiAoZmxpY2tpbmcpIHtcbiAgICB2YXIgdmlydHVhbE1hbmFnZXIgPSBmbGlja2luZy52aXJ0dWFsO1xuICAgIHZhciB2aXNpYmxlUGFuZWxzID0gX19zcHJlYWQkMShmbGlja2luZy52aXNpYmxlUGFuZWxzKS5maWx0ZXIoZnVuY3Rpb24gKHBhbmVsKSB7XG4gICAgICByZXR1cm4gcGFuZWwucmVuZGVyZWQ7XG4gICAgfSkuc29ydChmdW5jdGlvbiAocGFuZWwxLCBwYW5lbDIpIHtcbiAgICAgIHJldHVybiBwYW5lbDEucG9zaXRpb24gKyBwYW5lbDEub2Zmc2V0IC0gKHBhbmVsMi5wb3NpdGlvbiArIHBhbmVsMi5vZmZzZXQpO1xuICAgIH0pO1xuICAgIGlmICh2aXNpYmxlUGFuZWxzLmxlbmd0aCA8PSAwKSByZXR1cm4gdmlydHVhbE1hbmFnZXIuZWxlbWVudHMubWFwKGZ1bmN0aW9uIChfLCBpZHgpIHtcbiAgICAgIHJldHVybiBpZHg7XG4gICAgfSk7XG4gICAgdmFyIHZpc2libGVJbmRleGVzID0gdmlzaWJsZVBhbmVscy5tYXAoZnVuY3Rpb24gKHBhbmVsKSB7XG4gICAgICByZXR1cm4gcGFuZWwuZWxlbWVudEluZGV4O1xuICAgIH0pO1xuICAgIHZhciBpbnZpc2libGVJbmRleGVzID0gdmlydHVhbE1hbmFnZXIuZWxlbWVudHMubWFwKGZ1bmN0aW9uIChlbCwgaWR4KSB7XG4gICAgICByZXR1cm4gX19hc3NpZ24kMihfX2Fzc2lnbiQyKHt9LCBlbCksIHtcbiAgICAgICAgaWR4OiBpZHhcbiAgICAgIH0pO1xuICAgIH0pLmZpbHRlcihmdW5jdGlvbiAoZWwpIHtcbiAgICAgIHJldHVybiAhZWwudmlzaWJsZTtcbiAgICB9KS5tYXAoZnVuY3Rpb24gKGVsKSB7XG4gICAgICByZXR1cm4gZWwuaWR4O1xuICAgIH0pO1xuICAgIHJldHVybiBfX3NwcmVhZCQxKHZpc2libGVJbmRleGVzLCBpbnZpc2libGVJbmRleGVzKTtcbiAgfTtcbiAgX19wcm90by5nZXRSZW5kZXJpbmdFbGVtZW50c0J5T3JkZXIgPSBmdW5jdGlvbiAoZmxpY2tpbmcpIHtcbiAgICB2YXIgdmlydHVhbE1hbmFnZXIgPSBmbGlja2luZy52aXJ0dWFsO1xuICAgIHZhciBlbGVtZW50cyA9IHZpcnR1YWxNYW5hZ2VyLmVsZW1lbnRzO1xuICAgIHJldHVybiB0aGlzLmdldFJlbmRlcmluZ0luZGV4ZXNCeU9yZGVyKGZsaWNraW5nKS5tYXAoZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICByZXR1cm4gZWxlbWVudHNbaW5kZXhdLm5hdGl2ZUVsZW1lbnQ7XG4gICAgfSk7XG4gIH07XG4gIF9fcHJvdG8udXBkYXRlUmVuZGVyaW5nUGFuZWxzID0gZnVuY3Rpb24gKGZsaWNraW5nKSB7XG4gICAgdmFyIHBhbmVscyA9IGZsaWNraW5nLnJlbmRlcmVyLnBhbmVscztcbiAgICB2YXIgY2FtZXJhID0gZmxpY2tpbmcuY2FtZXJhO1xuICAgIHZhciB2aXNpYmxlSW5kZXhlcyA9IGNhbWVyYS52aXNpYmxlUGFuZWxzLnJlZHVjZShmdW5jdGlvbiAodmlzaWJsZXMsIHBhbmVsKSB7XG4gICAgICB2aXNpYmxlc1twYW5lbC5pbmRleF0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHZpc2libGVzO1xuICAgIH0sIHt9KTtcbiAgICBwYW5lbHMuZm9yRWFjaChmdW5jdGlvbiAocGFuZWwpIHtcbiAgICAgIGlmIChwYW5lbC5pbmRleCBpbiB2aXNpYmxlSW5kZXhlcyB8fCBwYW5lbC5sb2FkaW5nKSB7XG4gICAgICAgIHBhbmVsLm1hcmtGb3JTaG93KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYW5lbC5tYXJrRm9ySGlkZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNhbWVyYS51cGRhdGVPZmZzZXQoKTtcbiAgfTtcbiAgX19wcm90by5jb2xsZWN0UGFuZWxzID0gZnVuY3Rpb24gKGZsaWNraW5nKSB7XG4gICAgdmFyIGFsaWduID0gcGFyc2VQYW5lbEFsaWduKGZsaWNraW5nLnJlbmRlcmVyLmFsaWduKTtcbiAgICByZXR1cm4gcmFuZ2UoZmxpY2tpbmcudmlydHVhbC5pbml0aWFsUGFuZWxDb3VudCkubWFwKGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgcmV0dXJuIG5ldyBWaXJ0dWFsUGFuZWwoe1xuICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgIGVsZW1lbnRQcm92aWRlcjogbmV3IFZpcnR1YWxFbGVtZW50UHJvdmlkZXIoZmxpY2tpbmcpLFxuICAgICAgICBhbGlnbjogYWxpZ24sXG4gICAgICAgIGZsaWNraW5nOiBmbGlja2luZ1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG4gIF9fcHJvdG8uY3JlYXRlUGFuZWwgPSBmdW5jdGlvbiAoX2VsLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBWaXJ0dWFsUGFuZWwoX19hc3NpZ24kMihfX2Fzc2lnbiQyKHt9LCBvcHRpb25zKSwge1xuICAgICAgZWxlbWVudFByb3ZpZGVyOiBuZXcgVmlydHVhbEVsZW1lbnRQcm92aWRlcihvcHRpb25zLmZsaWNraW5nKVxuICAgIH0pKTtcbiAgfTtcbiAgX19wcm90by51cGRhdGVQYW5lbFNpemVzID0gZnVuY3Rpb24gKGZsaWNraW5nLCBzaXplKSB7XG4gICAgZmxpY2tpbmcudmlydHVhbC5lbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgc2V0U2l6ZShlbC5uYXRpdmVFbGVtZW50LCBzaXplKTtcbiAgICB9KTtcbiAgICBmbGlja2luZy5wYW5lbHMuZm9yRWFjaChmdW5jdGlvbiAocGFuZWwpIHtcbiAgICAgIHJldHVybiBwYW5lbC5zZXRTaXplKHNpemUpO1xuICAgIH0pO1xuICB9O1xuICByZXR1cm4gVmlydHVhbFJlbmRlcmluZ1N0cmF0ZWd5O1xufSgpO1xuXG4vKipcclxuICogQGV4dGVuZHMgQ29tcG9uZW50XHJcbiAqIEBzdXBwb3J0IHtcImllXCI6IFwiOSsod2l0aCBwb2x5ZmlsbClcIiwgXCJjaFwiIDogXCJsYXRlc3RcIiwgXCJmZlwiIDogXCJsYXRlc3RcIiwgIFwic2ZcIiA6IFwibGF0ZXN0XCIsIFwiZWRnZVwiIDogXCJsYXRlc3RcIiwgXCJpb3NcIiA6IFwiNytcIiwgXCJhblwiIDogXCI0LlgrXCJ9XHJcbiAqIEByZXF1aXJlcyB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL25hdmVyL2VnanMtY29tcG9uZW50fEBlZ2pzL2NvbXBvbmVudH1cclxuICogQHJlcXVpcmVzIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vbmF2ZXIvZWdqcy1heGVzfEBlZ2pzL2F4ZXN9XHJcbiAqL1xudmFyIEZsaWNraW5nID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzJDMoRmxpY2tpbmcsIF9zdXBlcik7XG4gIC8qKlxyXG4gICAqIEBwYXJhbSByb290IEEgcm9vdCBIVE1MRWxlbWVudCB0byBpbml0aWFsaXplIEZsaWNraW5nIG9uIGl0LiBXaGVuIGl0J3MgYSB0eXBlb2YgYHN0cmluZ2AsIGl0IHNob3VsZCBiZSBhIGNzcyBzZWxlY3RvciBzdHJpbmdcclxuICAgKiA8a28+RmxpY2tpbmfsnYQg7LSI6riw7ZmU7ZWgIEhUTUxFbGVtZW5066GcLCBgc3RyaW5nYCDtg4DsnoXsnLzroZwg7KeA7KCV7IucIGNzcyDshKDtg53snpAg66y47J6Q7Je07J2EIOyngOygle2VtOyVvCDtlanri4jri6QuPC9rbz5cclxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnM9e31dIEFuIG9wdGlvbnMgb2JqZWN0IGZvciBGbGlja2luZy48a28+RmxpY2tpbmfsl5Ag7KCB7Jqp7ZWgIOyYteyFmCDsmKTruIzsoJ3tirg8L2tvPlxyXG4gICAqIEB0aHJvd3Mge0ZsaWNraW5nRXJyb3J9XHJcbiAgICogfGNvZGV8Y29uZGl0aW9ufFxyXG4gICAqIHwtLS18LS0tfFxyXG4gICAqIHx7QGxpbmsgRVJST1JfQ09ERSBXUk9OR19UWVBFfXxXaGVuIHRoZSByb290IGlzIG5vdCBlaXRoZXIgc3RyaW5nIG9yIEhUTUxFbGVtZW50fFxyXG4gICAqIHx7QGxpbmsgRVJST1JfQ09ERSBFTEVNRU5UX05PVF9GT1VORH18V2hlbiB0aGUgZWxlbWVudCB3aXRoIGdpdmVuIENTUyBzZWxlY3RvciBkb2VzIG5vdCBleGlzdHxcclxuICAgKiA8a28+XHJcbiAgICpcclxuICAgKiB8Y29kZXzsobDqsbR8XHJcbiAgICogfC0tLXwtLS18XHJcbiAgICogfHtAbGluayBFUlJPUl9DT0RFIFdST05HX1RZUEV9fOujqO2KuCDsl5jrpqzrqLztirjqsIAgc3RyaW5n7J2064KYIEhUTUxFbGVtZW506rCAIOyVhOuLkCDqsr3smrB8XHJcbiAgICogfHtAbGluayBFUlJPUl9DT0RFIEVMRU1FTlRfTk9UX0ZPVU5EfXzso7zslrTsp4QgQ1NTIHNlbGVjdG9y66GcIOyXmOumrOuovO2KuOulvCDssL7sp4Ag66q77ZaI7J2EIOqyveyasHxcclxuICAgKlxyXG4gICAqIDwva28+XHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBgYGB0c1xyXG4gICAqIGltcG9ydCBGbGlja2luZyBmcm9tIFwiQGVnanMvZmxpY2tpbmdcIjtcclxuICAgKlxyXG4gICAqIC8vIENyZWF0aW5nIG5ldyBpbnN0YW5jZSBvZiBGbGlja2luZyB3aXRoIEhUTUxFbGVtZW50XHJcbiAgICogY29uc3QgZmxpY2tpbmcgPSBuZXcgRmxpY2tpbmcoZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi5mbGlja2luZy12aWV3cG9ydFwiKSwgeyBjaXJjdWxhcjogdHJ1ZSB9KTtcclxuICAgKlxyXG4gICAqIC8vIENyZWF0aW5nIG5ldyBpbnN0YW5jZSBvZiBGbGlja2luZyB3aXRoIENTUyBzZWxlY3RvclxyXG4gICAqIGNvbnN0IGZsaWNraW5nMiA9IG5ldyBGbGlja2luZyhcIi5mbGlja2luZy12aWV3cG9ydFwiLCB7IGNpcmN1bGFyOiB0cnVlIH0pO1xyXG4gICAqIGBgYFxyXG4gICAqL1xuICBmdW5jdGlvbiBGbGlja2luZyhyb290LCBfYSkge1xuICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLFxuICAgICAgX2MgPSBfYi5hbGlnbixcbiAgICAgIGFsaWduID0gX2MgPT09IHZvaWQgMCA/IEFMSUdOLkNFTlRFUiA6IF9jLFxuICAgICAgX2QgPSBfYi5kZWZhdWx0SW5kZXgsXG4gICAgICBkZWZhdWx0SW5kZXggPSBfZCA9PT0gdm9pZCAwID8gMCA6IF9kLFxuICAgICAgX2UgPSBfYi5ob3Jpem9udGFsLFxuICAgICAgaG9yaXpvbnRhbCA9IF9lID09PSB2b2lkIDAgPyB0cnVlIDogX2UsXG4gICAgICBfZiA9IF9iLmNpcmN1bGFyLFxuICAgICAgY2lyY3VsYXIgPSBfZiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfZixcbiAgICAgIF9nID0gX2IuY2lyY3VsYXJGYWxsYmFjayxcbiAgICAgIGNpcmN1bGFyRmFsbGJhY2sgPSBfZyA9PT0gdm9pZCAwID8gQ0lSQ1VMQVJfRkFMTEJBQ0suTElORUFSIDogX2csXG4gICAgICBfaCA9IF9iLmJvdW5kLFxuICAgICAgYm91bmQgPSBfaCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfaCxcbiAgICAgIF9qID0gX2IuYWRhcHRpdmUsXG4gICAgICBhZGFwdGl2ZSA9IF9qID09PSB2b2lkIDAgPyBmYWxzZSA6IF9qLFxuICAgICAgX2sgPSBfYi5wYW5lbHNQZXJWaWV3LFxuICAgICAgcGFuZWxzUGVyVmlldyA9IF9rID09PSB2b2lkIDAgPyAtMSA6IF9rLFxuICAgICAgX2wgPSBfYi5ub1BhbmVsU3R5bGVPdmVycmlkZSxcbiAgICAgIG5vUGFuZWxTdHlsZU92ZXJyaWRlID0gX2wgPT09IHZvaWQgMCA/IGZhbHNlIDogX2wsXG4gICAgICBfbSA9IF9iLnJlc2l6ZU9uQ29udGVudHNSZWFkeSxcbiAgICAgIHJlc2l6ZU9uQ29udGVudHNSZWFkeSA9IF9tID09PSB2b2lkIDAgPyBmYWxzZSA6IF9tLFxuICAgICAgX28gPSBfYi5uZXN0ZWQsXG4gICAgICBuZXN0ZWQgPSBfbyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfbyxcbiAgICAgIF9wID0gX2IubmVlZFBhbmVsVGhyZXNob2xkLFxuICAgICAgbmVlZFBhbmVsVGhyZXNob2xkID0gX3AgPT09IHZvaWQgMCA/IDAgOiBfcCxcbiAgICAgIF9xID0gX2IucHJldmVudEV2ZW50c0JlZm9yZUluaXQsXG4gICAgICBwcmV2ZW50RXZlbnRzQmVmb3JlSW5pdCA9IF9xID09PSB2b2lkIDAgPyB0cnVlIDogX3EsXG4gICAgICBfciA9IF9iLmRlY2VsZXJhdGlvbixcbiAgICAgIGRlY2VsZXJhdGlvbiA9IF9yID09PSB2b2lkIDAgPyAwLjAwNzUgOiBfcixcbiAgICAgIF9zID0gX2IuZHVyYXRpb24sXG4gICAgICBkdXJhdGlvbiA9IF9zID09PSB2b2lkIDAgPyA1MDAgOiBfcyxcbiAgICAgIF90ID0gX2IuZWFzaW5nLFxuICAgICAgZWFzaW5nID0gX3QgPT09IHZvaWQgMCA/IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiAxIC0gTWF0aC5wb3coMSAtIHgsIDMpO1xuICAgICAgfSA6IF90LFxuICAgICAgX3UgPSBfYi5pbnB1dFR5cGUsXG4gICAgICBpbnB1dFR5cGUgPSBfdSA9PT0gdm9pZCAwID8gW1wibW91c2VcIiwgXCJ0b3VjaFwiXSA6IF91LFxuICAgICAgX3YgPSBfYi5tb3ZlVHlwZSxcbiAgICAgIG1vdmVUeXBlID0gX3YgPT09IHZvaWQgMCA/IFwic25hcFwiIDogX3YsXG4gICAgICBfdyA9IF9iLnRocmVzaG9sZCxcbiAgICAgIHRocmVzaG9sZCA9IF93ID09PSB2b2lkIDAgPyA0MCA6IF93LFxuICAgICAgX3ggPSBfYi5pbnRlcnJ1cHRhYmxlLFxuICAgICAgaW50ZXJydXB0YWJsZSA9IF94ID09PSB2b2lkIDAgPyB0cnVlIDogX3gsXG4gICAgICBfeSA9IF9iLmJvdW5jZSxcbiAgICAgIGJvdW5jZSA9IF95ID09PSB2b2lkIDAgPyBcIjIwJVwiIDogX3ksXG4gICAgICBfeiA9IF9iLmlPU0VkZ2VTd2lwZVRocmVzaG9sZCxcbiAgICAgIGlPU0VkZ2VTd2lwZVRocmVzaG9sZCA9IF96ID09PSB2b2lkIDAgPyAzMCA6IF96LFxuICAgICAgXzAgPSBfYi5wcmV2ZW50Q2xpY2tPbkRyYWcsXG4gICAgICBwcmV2ZW50Q2xpY2tPbkRyYWcgPSBfMCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF8wLFxuICAgICAgXzEgPSBfYi5wcmV2ZW50RGVmYXVsdE9uRHJhZyxcbiAgICAgIHByZXZlbnREZWZhdWx0T25EcmFnID0gXzEgPT09IHZvaWQgMCA/IGZhbHNlIDogXzEsXG4gICAgICBfMiA9IF9iLmRpc2FibGVPbkluaXQsXG4gICAgICBkaXNhYmxlT25Jbml0ID0gXzIgPT09IHZvaWQgMCA/IGZhbHNlIDogXzIsXG4gICAgICBfMyA9IF9iLmNoYW5nZU9uSG9sZCxcbiAgICAgIGNoYW5nZU9uSG9sZCA9IF8zID09PSB2b2lkIDAgPyBmYWxzZSA6IF8zLFxuICAgICAgXzQgPSBfYi5yZW5kZXJPbmx5VmlzaWJsZSxcbiAgICAgIHJlbmRlck9ubHlWaXNpYmxlID0gXzQgPT09IHZvaWQgMCA/IGZhbHNlIDogXzQsXG4gICAgICBfNSA9IF9iLnZpcnR1YWwsXG4gICAgICB2aXJ0dWFsID0gXzUgPT09IHZvaWQgMCA/IG51bGwgOiBfNSxcbiAgICAgIF82ID0gX2IuYXV0b0luaXQsXG4gICAgICBhdXRvSW5pdCA9IF82ID09PSB2b2lkIDAgPyB0cnVlIDogXzYsXG4gICAgICBfNyA9IF9iLmF1dG9SZXNpemUsXG4gICAgICBhdXRvUmVzaXplID0gXzcgPT09IHZvaWQgMCA/IHRydWUgOiBfNyxcbiAgICAgIF84ID0gX2IudXNlUmVzaXplT2JzZXJ2ZXIsXG4gICAgICB1c2VSZXNpemVPYnNlcnZlciA9IF84ID09PSB2b2lkIDAgPyB0cnVlIDogXzgsXG4gICAgICBfOSA9IF9iLnJlc2l6ZURlYm91bmNlLFxuICAgICAgcmVzaXplRGVib3VuY2UgPSBfOSA9PT0gdm9pZCAwID8gMCA6IF85LFxuICAgICAgXzEwID0gX2IubWF4UmVzaXplRGVib3VuY2UsXG4gICAgICBtYXhSZXNpemVEZWJvdW5jZSA9IF8xMCA9PT0gdm9pZCAwID8gMTAwIDogXzEwLFxuICAgICAgXzExID0gX2IudXNlRnJhY3Rpb25hbFNpemUsXG4gICAgICB1c2VGcmFjdGlvbmFsU2l6ZSA9IF8xMSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfMTEsXG4gICAgICBfMTIgPSBfYi5leHRlcm5hbFJlbmRlcmVyLFxuICAgICAgZXh0ZXJuYWxSZW5kZXJlciA9IF8xMiA9PT0gdm9pZCAwID8gbnVsbCA6IF8xMixcbiAgICAgIF8xMyA9IF9iLnJlbmRlckV4dGVybmFsLFxuICAgICAgcmVuZGVyRXh0ZXJuYWwgPSBfMTMgPT09IHZvaWQgMCA/IG51bGwgOiBfMTM7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAvLyBJbnRlcm5hbCBzdGF0ZXNcbiAgICBfdGhpcy5faW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICBfdGhpcy5fcGx1Z2lucyA9IFtdO1xuICAgIC8vIEJpbmQgb3B0aW9uc1xuICAgIF90aGlzLl9hbGlnbiA9IGFsaWduO1xuICAgIF90aGlzLl9kZWZhdWx0SW5kZXggPSBkZWZhdWx0SW5kZXg7XG4gICAgX3RoaXMuX2hvcml6b250YWwgPSBob3Jpem9udGFsO1xuICAgIF90aGlzLl9jaXJjdWxhciA9IGNpcmN1bGFyO1xuICAgIF90aGlzLl9jaXJjdWxhckZhbGxiYWNrID0gY2lyY3VsYXJGYWxsYmFjaztcbiAgICBfdGhpcy5fYm91bmQgPSBib3VuZDtcbiAgICBfdGhpcy5fYWRhcHRpdmUgPSBhZGFwdGl2ZTtcbiAgICBfdGhpcy5fcGFuZWxzUGVyVmlldyA9IHBhbmVsc1BlclZpZXc7XG4gICAgX3RoaXMuX25vUGFuZWxTdHlsZU92ZXJyaWRlID0gbm9QYW5lbFN0eWxlT3ZlcnJpZGU7XG4gICAgX3RoaXMuX3Jlc2l6ZU9uQ29udGVudHNSZWFkeSA9IHJlc2l6ZU9uQ29udGVudHNSZWFkeTtcbiAgICBfdGhpcy5fbmVzdGVkID0gbmVzdGVkO1xuICAgIF90aGlzLl92aXJ0dWFsID0gdmlydHVhbDtcbiAgICBfdGhpcy5fbmVlZFBhbmVsVGhyZXNob2xkID0gbmVlZFBhbmVsVGhyZXNob2xkO1xuICAgIF90aGlzLl9wcmV2ZW50RXZlbnRzQmVmb3JlSW5pdCA9IHByZXZlbnRFdmVudHNCZWZvcmVJbml0O1xuICAgIF90aGlzLl9kZWNlbGVyYXRpb24gPSBkZWNlbGVyYXRpb247XG4gICAgX3RoaXMuX2R1cmF0aW9uID0gZHVyYXRpb247XG4gICAgX3RoaXMuX2Vhc2luZyA9IGVhc2luZztcbiAgICBfdGhpcy5faW5wdXRUeXBlID0gaW5wdXRUeXBlO1xuICAgIF90aGlzLl9tb3ZlVHlwZSA9IG1vdmVUeXBlO1xuICAgIF90aGlzLl90aHJlc2hvbGQgPSB0aHJlc2hvbGQ7XG4gICAgX3RoaXMuX2ludGVycnVwdGFibGUgPSBpbnRlcnJ1cHRhYmxlO1xuICAgIF90aGlzLl9ib3VuY2UgPSBib3VuY2U7XG4gICAgX3RoaXMuX2lPU0VkZ2VTd2lwZVRocmVzaG9sZCA9IGlPU0VkZ2VTd2lwZVRocmVzaG9sZDtcbiAgICBfdGhpcy5fcHJldmVudENsaWNrT25EcmFnID0gcHJldmVudENsaWNrT25EcmFnO1xuICAgIF90aGlzLl9wcmV2ZW50RGVmYXVsdE9uRHJhZyA9IHByZXZlbnREZWZhdWx0T25EcmFnO1xuICAgIF90aGlzLl9kaXNhYmxlT25Jbml0ID0gZGlzYWJsZU9uSW5pdDtcbiAgICBfdGhpcy5fY2hhbmdlT25Ib2xkID0gY2hhbmdlT25Ib2xkO1xuICAgIF90aGlzLl9yZW5kZXJPbmx5VmlzaWJsZSA9IHJlbmRlck9ubHlWaXNpYmxlO1xuICAgIF90aGlzLl9hdXRvSW5pdCA9IGF1dG9Jbml0O1xuICAgIF90aGlzLl9hdXRvUmVzaXplID0gYXV0b1Jlc2l6ZTtcbiAgICBfdGhpcy5fdXNlUmVzaXplT2JzZXJ2ZXIgPSB1c2VSZXNpemVPYnNlcnZlcjtcbiAgICBfdGhpcy5fcmVzaXplRGVib3VuY2UgPSByZXNpemVEZWJvdW5jZTtcbiAgICBfdGhpcy5fbWF4UmVzaXplRGVib3VuY2UgPSBtYXhSZXNpemVEZWJvdW5jZTtcbiAgICBfdGhpcy5fdXNlRnJhY3Rpb25hbFNpemUgPSB1c2VGcmFjdGlvbmFsU2l6ZTtcbiAgICBfdGhpcy5fZXh0ZXJuYWxSZW5kZXJlciA9IGV4dGVybmFsUmVuZGVyZXI7XG4gICAgX3RoaXMuX3JlbmRlckV4dGVybmFsID0gcmVuZGVyRXh0ZXJuYWw7XG4gICAgLy8gQ3JlYXRlIGNvcmUgY29tcG9uZW50c1xuICAgIF90aGlzLl92aWV3cG9ydCA9IG5ldyBWaWV3cG9ydChfdGhpcywgZ2V0RWxlbWVudChyb290KSk7XG4gICAgX3RoaXMuX2F1dG9SZXNpemVyID0gbmV3IEF1dG9SZXNpemVyKF90aGlzKTtcbiAgICBfdGhpcy5fcmVuZGVyZXIgPSBfdGhpcy5fY3JlYXRlUmVuZGVyZXIoKTtcbiAgICBfdGhpcy5fY2FtZXJhID0gX3RoaXMuX2NyZWF0ZUNhbWVyYSgpO1xuICAgIF90aGlzLl9jb250cm9sID0gX3RoaXMuX2NyZWF0ZUNvbnRyb2woKTtcbiAgICBfdGhpcy5fdmlydHVhbE1hbmFnZXIgPSBuZXcgVmlydHVhbE1hbmFnZXIoX3RoaXMsIHZpcnR1YWwpO1xuICAgIGlmIChfdGhpcy5fYXV0b0luaXQpIHtcbiAgICAgIHZvaWQgX3RoaXMuaW5pdCgpO1xuICAgIH1cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgdmFyIF9fcHJvdG8gPSBGbGlja2luZy5wcm90b3R5cGU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcImNvbnRyb2xcIiwge1xuICAgIC8vIENvbXBvbmVudHNcbiAgICAvKipcclxuICAgICAqIHtAbGluayBDb250cm9sfSBpbnN0YW5jZSBvZiB0aGUgRmxpY2tpbmdcclxuICAgICAqIEBrbyDtmITsnqwgRmxpY2tpbmfsl5Ag7Zmc7ISx7ZmU65CcIHtAbGluayBDb250cm9sfSDsnbjsiqTthLTsiqRcclxuICAgICAqIEB0eXBlIHtDb250cm9sfVxyXG4gICAgICogQGRlZmF1bHQgU25hcENvbnRyb2xcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQHNlZSBDb250cm9sXHJcbiAgICAgKiBAc2VlIFNuYXBDb250cm9sXHJcbiAgICAgKiBAc2VlIEZyZWVDb250cm9sXHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jb250cm9sO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJjYW1lcmFcIiwge1xuICAgIC8qKlxyXG4gICAgICoge0BsaW5rIENhbWVyYX0gaW5zdGFuY2Ugb2YgdGhlIEZsaWNraW5nXHJcbiAgICAgKiBAa28g7ZiE7J6sIEZsaWNraW5n7JeQIO2ZnOyEse2ZlOuQnCB7QGxpbmsgQ2FtZXJhfSDsnbjsiqTthLTsiqRcclxuICAgICAqIEB0eXBlIHtDYW1lcmF9XHJcbiAgICAgKiBAZGVmYXVsdCBMaW5lYXJDYW1lcmFcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQHNlZSBDYW1lcmFcclxuICAgICAqIEBzZWUgTGluZWFyQ2FtZXJhXHJcbiAgICAgKiBAc2VlIEJvdW5kQ2FtZXJhXHJcbiAgICAgKiBAc2VlIENpcmN1bGFyQ2FtZXJhXHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jYW1lcmE7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcInJlbmRlcmVyXCIsIHtcbiAgICAvKipcclxuICAgICAqIHtAbGluayBSZW5kZXJlcn0gaW5zdGFuY2Ugb2YgdGhlIEZsaWNraW5nXHJcbiAgICAgKiBAa28g7ZiE7J6sIEZsaWNraW5n7JeQIO2ZnOyEse2ZlOuQnCB7QGxpbmsgUmVuZGVyZXJ9IOyduOyKpO2EtOyKpFxyXG4gICAgICogQHR5cGUge1JlbmRlcmVyfVxyXG4gICAgICogQGRlZmF1bHQgVmFuaWxsYVJlbmRlcmVyXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqIEBzZWUgUmVuZGVyZXJcclxuICAgICAqIEBzZWUgVmFuaWxsYVJlbmRlcmVyXHJcbiAgICAgKiBAc2VlIEV4dGVybmFsUmVuZGVyZXJcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlcmVyO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJ2aWV3cG9ydFwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBBIGNvbXBvbmVudCB0aGF0IG1hbmFnZXMgdmlld3BvcnQgc2l6ZVxyXG4gICAgICogQGtvIOu3sO2PrO2KuCDtgazquLAg7KCV67O066W8IOuLtOuLue2VmOuKlCDsu7Ttj6zrhIztirhcclxuICAgICAqIEB0eXBlIHtWaWV3cG9ydH1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQHNlZSBWaWV3cG9ydFxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdmlld3BvcnQ7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcImluaXRpYWxpemVkXCIsIHtcbiAgICAvLyBJbnRlcm5hbCBTdGF0ZXNcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgRmxpY2tpbmcncyB7QGxpbmsgRmxpY2tpbmcjaW5pdCBpbml0KCl9IGlzIGNhbGxlZC5cclxuICAgICAqIFRoaXMgaXMgYHRydWVgIHdoZW4ge0BsaW5rIEZsaWNraW5nI2luaXQgaW5pdCgpfSBpcyBjYWxsZWQsIGFuZCBpcyBgZmFsc2VgIGFmdGVyIGNhbGxpbmcge0BsaW5rIEZsaWNraW5nI2Rlc3Ryb3kgZGVzdHJveSgpfS5cclxuICAgICAqIEBrbyBGbGlja2luZ+ydmCB7QGxpbmsgRmxpY2tpbmcjaW5pdCBpbml0KCl97J20IO2YuOy2nOuQmOyXiOuKlOyngOulvCDrgpjtg4DrgrTripQg66mk67KEIOuzgOyImC5cclxuICAgICAqIOydtCDqsJLsnYAge0BsaW5rIEZsaWNraW5nI2luaXQgaW5pdCgpfeydtCDtmLjstpzrkJjsl4jsnLzrqbQgYHRydWVg66GcIOuzgO2VmOqzoCwge0BsaW5rIEZsaWNraW5nI2Rlc3Ryb3kgZGVzdHJveSgpfe2YuOy2nCDsnbTtm4Tsl5Ag64uk7IucIGBmYWxzZWDroZwg67OA6rK965Cp64uI64ukLlxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pbml0aWFsaXplZDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwiY2lyY3VsYXJFbmFibGVkXCIsIHtcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgdGhlIGBjaXJjdWxhcmAgb3B0aW9uIGlzIGVuYWJsZWQuXHJcbiAgICAgKiBUaGUge0BsaW5rIEZsaWNraW5nI2NpcmN1bGFyIGNpcmN1bGFyfSBvcHRpb24gY2FuJ3QgYmUgZW5hYmxlZCB3aGVuIHN1bSBvZiB0aGUgcGFuZWwgc2l6ZXMgYXJlIHRvbyBzbWFsbC5cclxuICAgICAqIEBrbyB7QGxpbmsgRmxpY2tpbmcjY2lyY3VsYXIgY2lyY3VsYXJ9IOyYteyFmOydtCDtmZzshLHtmZTrkJjsl4jripTsp4Ag7Jes67aA66W8IOuCmO2DgOuCtOuKlCDrqaTrsoQg67OA7IiYLlxyXG4gICAgICoge0BsaW5rIEZsaWNraW5nI2NpcmN1bGFyIGNpcmN1bGFyfSDsmLXshZjsnYAg7Yyo64SQ7J2YIO2BrOq4sOydmCDtlansnbQg7Lap67aE7ZWY7KeAIOyViuydhCDqsr3smrAg67mE7Zmc7ISx7ZmU65Cp64uI64ukLlxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jYW1lcmEuY2lyY3VsYXJFbmFibGVkO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJ2aXJ0dWFsRW5hYmxlZFwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHRoZSBgdmlydHVhbGAgb3B0aW9uIGlzIGVuYWJsZWQuXHJcbiAgICAgKiBUaGUge0BsaW5rIEZsaWNraW5nI3ZpcnR1YWwgdmlydHVhbH0gb3B0aW9uIGNhbid0IGJlIGVuYWJsZWQgd2hlbiAge0BsaW5rIEZsaWNraW5nI3BhbmVsc1BlclZpZXcgcGFuZWxzUGVyVmlld30gaXMgbGVzcyBvciBlcXVhbCB0aGFuIHplcm8uXHJcbiAgICAgKiBAa28ge0BsaW5rIEZsaWNraW5nI3ZpcnR1YWwgdmlydHVhbH0g7Ji17IWY7J20IO2ZnOyEse2ZlOuQmOyXiOuKlOyngCDsl6zrtoDrpbwg64KY7YOA64K064qUIOuppOuyhCDrs4DsiJguXHJcbiAgICAgKiB7QGxpbmsgRmxpY2tpbmcjdmlydHVhbCB2aXJ0dWFsfSDsmLXshZjsnYAge0BsaW5rIEZsaWNraW5nI3BhbmVsc1BlclZpZXcgcGFuZWxzUGVyVmlld30g7Ji17IWY7J2YIOqwkuydtCAw67O064ukIOqwmeqxsOuCmCDsnpHsnLzrqbQg67mE7Zmc7ISx7ZmU65Cp64uI64ukLlxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wYW5lbHNQZXJWaWV3ID4gMCAmJiB0aGlzLl92aXJ0dWFsICE9IG51bGw7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcImluZGV4XCIsIHtcbiAgICAvKipcclxuICAgICAqIEluZGV4IG51bWJlciBvZiB0aGUge0BsaW5rIEZsaWNraW5nI2N1cnJlbnRQYW5lbCBjdXJyZW50UGFuZWx9XHJcbiAgICAgKiBAa28ge0BsaW5rIEZsaWNraW5nI2N1cnJlbnRQYW5lbCBjdXJyZW50UGFuZWx97J2YIOyduOuNseyKpCDrsojtmLhcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NvbnRyb2wuYWN0aXZlSW5kZXg7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcImVsZW1lbnRcIiwge1xuICAgIC8qKlxyXG4gICAgICogVGhlIHJvb3QoYC5mbGlja2luZy12aWV3cG9ydGApIGVsZW1lbnRcclxuICAgICAqIEBrbyByb290KGAuZmxpY2tpbmctdmlld3BvcnRgKSDsl5jrpqzrqLztirhcclxuICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdmlld3BvcnQuZWxlbWVudDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwiY3VycmVudFBhbmVsXCIsIHtcbiAgICAvKipcclxuICAgICAqIEN1cnJlbnRseSBhY3RpdmUgcGFuZWxcclxuICAgICAqIEBrbyDtmITsnqwg7ISg7YOd65CcIO2MqOuEkFxyXG4gICAgICogQHR5cGUge1BhbmVsfVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKiBAc2VlIFBhbmVsXHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jb250cm9sLmFjdGl2ZVBhbmVsO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJwYW5lbHNcIiwge1xuICAgIC8qKlxyXG4gICAgICogQXJyYXkgb2YgcGFuZWxzXHJcbiAgICAgKiBAa28g7KCE7LK0IO2MqOuEkOuTpOydmCDrsLDsl7RcclxuICAgICAqIEB0eXBlIHtQYW5lbFtdfVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKiBAc2VlIFBhbmVsXHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJlci5wYW5lbHM7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcInBhbmVsQ291bnRcIiwge1xuICAgIC8qKlxyXG4gICAgICogQ291bnQgb2YgcGFuZWxzXHJcbiAgICAgKiBAa28g7KCE7LK0IO2MqOuEkOydmCDqsJzsiJhcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlcmVyLnBhbmVsQ291bnQ7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcInZpc2libGVQYW5lbHNcIiwge1xuICAgIC8qKlxyXG4gICAgICogQXJyYXkgb2YgcGFuZWxzIHRoYXQgaXMgdmlzaWJsZSBhdCB0aGUgY3VycmVudCBwb3NpdGlvblxyXG4gICAgICogQGtvIO2YhOyerCDrs7TsnbTripQg7Yyo64SQ7J2YIOuwsOyXtFxyXG4gICAgICogQHR5cGUge1BhbmVsW119XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqIEBzZWUgUGFuZWxcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NhbWVyYS52aXNpYmxlUGFuZWxzO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJhbmltYXRpbmdcIiwge1xuICAgIC8qKlxyXG4gICAgICogV2hldGhlciBGbGlja2luZydzIGFuaW1hdGluZ1xyXG4gICAgICogQGtvIO2YhOyerCDslaDri4jrqZTsnbTshZgg64+Z7J6RIOyXrOu2gFxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NvbnRyb2wuYW5pbWF0aW5nO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJob2xkaW5nXCIsIHtcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgdXNlciBpcyBjbGlja2luZyBvciB0b3VjaGluZ1xyXG4gICAgICogQGtvIO2YhOyerCDsgqzsmqnsnpDqsIAg7YG066atL+2EsOy5mOykkeyduOyngCDsl6zrtoBcclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jb250cm9sLmhvbGRpbmc7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcImFjdGl2ZVBsdWdpbnNcIiwge1xuICAgIC8qKlxyXG4gICAgICogQSBjdXJyZW50IGxpc3Qgb2YgYWN0aXZhdGVkIHBsdWdpbnNcclxuICAgICAqIEBrbyDtmITsnqwg7Zmc7ISx7ZmU65CcIO2UjOufrOq3uOyduCDrqqnroZ1cclxuICAgICAqIEB0eXBlIHtQbHVnaW5bXX1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcGx1Z2lucztcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwiYWxpZ25cIiwge1xuICAgIC8vIE9wdGlvbnMgR2V0dGVyXG4gICAgLy8gVUkgLyBMQVlPVVRcbiAgICAvKipcclxuICAgICAqIEFsaWduIHBvc2l0aW9uIG9mIHRoZSBwYW5lbHMgd2l0aGluIHZpZXdwb3J0LiBZb3UgY2FuIHNldCBkaWZmZXJlbnQgdmFsdWVzIGVhY2ggZm9yIHRoZSBwYW5lbCBhbmQgY2FtZXJhXHJcbiAgICAgKiBAa28g67ew7Y+s7Yq4IOuCtOyXkOyEnCDtjKjrhJAg7KCV66Cs67Cp7Iud7J2EIOyEpOygle2VmOuKlCDsmLXshZguIOy5tOuplOudvOyZgCDtjKjrhJAg6rCc67OE66GcIOyYteyFmOydhCDshKTsoJXtlaAg7IiY64+EIOyeiOyKteuLiOuLpFxyXG4gICAgICogQHR5cGUge0FMSUdOIHwgc3RyaW5nIHwgbnVtYmVyIHwgeyBwYW5lbDogc3RyaW5nIHwgbnVtYmVyLCBjYW1lcmE6IHN0cmluZyB8IG51bWJlciB9fVxyXG4gICAgICogQHByb3BlcnR5IHtBTElHTiB8IHN0cmluZyB8IG51bWJlcn0gcGFuZWwgVGhlIGFsaWduIHZhbHVlIGZvciBlYWNoIHtAbGluayBQYW5lbH1zPGtvPuqwnOqwnOydmCB7QGxpbmsgUGFuZWx97JeQIOyggeyaqe2VoCDqsJI8L2tvPlxyXG4gICAgICogQHByb3BlcnR5IHtBTElHTiB8IHN0cmluZyB8IG51bWJlcn0gY2FtZXJhIFRoZSBhbGlnbiB2YWx1ZSBmb3Ige0BsaW5rIENhbWVyYX08a28+e0BsaW5rIENhbWVyYX3sl5Ag7KCB7Jqp7ZWgIOqwkjwva28+XHJcbiAgICAgKiBAZGVmYXVsdCBcImNlbnRlclwiXHJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWZsaWNraW5nL09wdGlvbnMjYWxpZ24gYWxpZ24gKCBPcHRpb25zICl9XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYGBgdHNcclxuICAgICAqIGNvbnN0IHBvc3NpYmxlT3B0aW9ucyA9IFtcclxuICAgICAqICAgLy8gTGl0ZXJhbCBzdHJpbmdzXHJcbiAgICAgKiAgIFwicHJldlwiLCBcImNlbnRlclwiLCBcIm5leHRcIixcclxuICAgICAqICAgLy8gJSB2YWx1ZXMsIGFwcGxpZWQgdG8gYm90aCBwYW5lbCAmIGNhbWVyYVxyXG4gICAgICogICBcIjAlXCIsIFwiMjUlXCIsIFwiNDIlXCIsXHJcbiAgICAgKiAgIC8vIHB4IHZhbHVlcywgYXJpdGhtZXRpYyBjYWxjdWxhdGlvbiB3aXRoICgrLy0pIGlzIGFsc28gYWxsb3dlZC5cclxuICAgICAqICAgXCIwcHhcIiwgXCIxMDBweFwiLCBcIjUwJSAtIDI1cHhcIixcclxuICAgICAqICAgLy8gbnVtYmVycywgc2FtZSB0byBudW1iZXIgKyBweCAoXCIwcHhcIiwgXCIxMDBweFwiKVxyXG4gICAgICogICAwLCAxMDAsIDEwMDAsXHJcbiAgICAgKiAgIC8vIFNldHRpbmcgYSBkaWZmZXJlbnQgdmFsdWUgZm9yIHBhbmVsICYgY2FtZXJhXHJcbiAgICAgKiAgIHsgcGFuZWw6IFwiMTAlXCIsIGNhbWVyYTogXCIyNSVcIiB9XHJcbiAgICAgKiBdO1xyXG4gICAgICpcclxuICAgICAqIHBvc3NpYmxlT3B0aW9ucy5mb3JFYWNoKGFsaWduID0+IHtcclxuICAgICAqICAgbmV3IEZsaWNraW5nKFwiI2VsXCIsIHsgYWxpZ24gfSk7XHJcbiAgICAgKiB9KTtcclxuICAgICAqIGBgYFxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYWxpZ247XG4gICAgfSxcbiAgICAvLyBPcHRpb25zIFNldHRlclxuICAgIC8vIFVJIC8gTEFZT1VUXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICB0aGlzLl9hbGlnbiA9IHZhbDtcbiAgICAgIHRoaXMuX3JlbmRlcmVyLmFsaWduID0gdmFsO1xuICAgICAgdGhpcy5fY2FtZXJhLmFsaWduID0gdmFsO1xuICAgICAgdm9pZCB0aGlzLnJlc2l6ZSgpO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJkZWZhdWx0SW5kZXhcIiwge1xuICAgIC8qKlxyXG4gICAgICogSW5kZXggb2YgdGhlIHBhbmVsIHRvIG1vdmUgd2hlbiBGbGlja2luZydzIHtAbGluayBGbGlja2luZyNpbml0IGluaXQoKX0gaXMgY2FsbGVkLiBBIHplcm8tYmFzZWQgaW50ZWdlclxyXG4gICAgICogQGtvIEZsaWNraW5n7J2YIHtAbGluayBGbGlja2luZyNpbml0IGluaXQoKX3snbQg7Zi47Lac65CgIOuVjCDsnbTrj5ntlaAg65SU7Y+07Yq4IO2MqOuEkOydmCDsnbjrjbHsiqTroZwsIDDrtoDthLAg7Iuc7J6R7ZWY64qUIOygleyImOyeheuLiOuLpFxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtZmxpY2tpbmcvT3B0aW9ucyNkZWZhdWx0aW5kZXggZGVmYXVsdEluZGV4ICggT3B0aW9ucyApfVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGVmYXVsdEluZGV4O1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICB0aGlzLl9kZWZhdWx0SW5kZXggPSB2YWw7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcImhvcml6b250YWxcIiwge1xuICAgIC8qKlxyXG4gICAgICogRGlyZWN0aW9uIG9mIHBhbmVsIG1vdmVtZW50ICh0cnVlOiBob3Jpem9udGFsLCBmYWxzZTogdmVydGljYWwpXHJcbiAgICAgKiBAa28g7Yyo64SQIOydtOuPmSDrsKntlqUgKHRydWU6IOqwgOuhnOuwqe2WpSwgZmFsc2U6IOyEuOuhnOuwqe2WpSlcclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICogQGRlZmF1bHQgdHJ1ZVxyXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1mbGlja2luZy9PcHRpb25zI2hvcml6b250YWwgaG9yaXpvbnRhbCAoIE9wdGlvbnMgKX1cclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2hvcml6b250YWw7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHRoaXMuX2hvcml6b250YWwgPSB2YWw7XG4gICAgICB0aGlzLl9jb250cm9sLmNvbnRyb2xsZXIudXBkYXRlRGlyZWN0aW9uKCk7XG4gICAgICB2b2lkIHRoaXMucmVzaXplKCk7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcImNpcmN1bGFyXCIsIHtcbiAgICAvKipcclxuICAgICAqIEVuYWJsZXMgY2lyY3VsYXIoY29udGludW91cyBsb29wKSBtb2RlLCB3aGljaCBjb25uZWN0cyBmaXJzdC9sYXN0IHBhbmVsIGZvciBjb250aW51b3VzIHNjcm9sbGluZy5cclxuICAgICAqIEBrbyDsiJztmZgg66qo65Oc66W8IO2ZnOyEse2ZlO2VqeuLiOuLpC4g7Iic7ZmYIOuqqOuTnOyXkOyEnOuKlCDslpEg64Gd7J2YIO2MqOuEkOydtCDshJzroZwg7Jew6rKw65CY7Ja0IOuBiuq5gOyXhuuKlCDsiqTtgazroaTsnbQg6rCA64ql7ZWp64uI64ukLlxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1mbGlja2luZy9PcHRpb25zI2NpcmN1bGFyIGNpcmN1bGFyICggT3B0aW9ucyApfVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2lyY3VsYXI7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHRoaXMuX2NpcmN1bGFyID0gdmFsO1xuICAgICAgdm9pZCB0aGlzLnJlc2l6ZSgpO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJjaXJjdWxhckZhbGxiYWNrXCIsIHtcbiAgICAvKipcclxuICAgICAqIFNldCBwYW5lbCBjb250cm9sIG1vZGUgZm9yIHRoZSBjYXNlIHdoZW4gY2lyY3VsYXIgY2Fubm90IGJlIGVuYWJsZWQuXHJcbiAgICAgKiBcImxpbmVhclwiIHdpbGwgc2V0IHRoZSB2aWV3J3MgcmFuZ2UgZnJvbSB0aGUgdG9wIG9mIHRoZSBmaXJzdCBwYW5lbCB0byB0aGUgdG9wIG9mIHRoZSBsYXN0IHBhbmVsLlxyXG4gICAgICogXCJib3VuZFwiIHdpbGwgcHJldmVudCB0aGUgdmlldyBmcm9tIGdvaW5nIG91dCBvZiB0aGUgZmlyc3QvbGFzdCBwYW5lbCwgc28gaXQgd29uJ3Qgc2hvdyBlbXB0eSBzcGFjZXMgYmVmb3JlL2FmdGVyIHRoZSBmaXJzdC9sYXN0IHBhbmVsLlxyXG4gICAgICogQGtvIOyInO2ZmCDrqqjrk5wg7IKs7JqpIOu2iOqwgOuKpeyLnCDsgqzsmqntlaAg7Yyo64SQIOyhsOyekSDrspTsnIQg7ISk7KCVIOuwqeyLneydhCDrs4Dqsr3tlanri4jri6QuXHJcbiAgICAgKiBcImxpbmVhclwiIOyCrOyaqeyLnCDsi5zsoJDsnbQg7LKr67KI7Ke4IOyXmOumrOuovO2KuCDsnITsl5DshJzrtoDthLAg66eI7KeA66eJIOyXmOumrOuovO2KuCDsnITquYzsp4Ag7JuA7KeB7J28IOyImCDsnojrj4TroZ0g7ISk7KCV7ZWp64uI64ukLlxyXG4gICAgICogXCJib3VuZFwiIOyCrOyaqeyLnCDsi5zsoJDsnbQg7LKr67KI7Ke4IOyXmOumrOuovO2KuOyZgCDrp4jsp4Drp4kg7JeY66as66i87Yq47J2YIOuBneqzvCDrgZ0g7IKs7J207JeQ7IScIOybgOyngeydvCDsiJgg7J6I64+E66GdIOyEpOygle2VqeuLiOuLpC5cclxuICAgICAqIEBzZWUgQ0lSQ1VMQVJfRkFMTEJBQ0tcclxuICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgKiBAZGVmYXVsdCBcImxpbmVhclwiXHJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWZsaWNraW5nL09wdGlvbnMjY2lyY3VsYXJmYWxsYmFjayBjaXJjdWxhckZhbGxiYWNrICggT3B0aW9ucyApfVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2lyY3VsYXJGYWxsYmFjaztcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwiYm91bmRcIiwge1xuICAgIC8qKlxyXG4gICAgICogUHJldmVudCB0aGUgdmlldyhjYW1lcmEgZWxlbWVudCkgZnJvbSBnb2luZyBvdXQgb2YgdGhlIGZpcnN0L2xhc3QgcGFuZWwsIHNvIGl0IHdvbid0IHNob3cgZW1wdHkgc3BhY2VzIGJlZm9yZS9hZnRlciB0aGUgZmlyc3QvbGFzdCBwYW5lbFxyXG4gICAgICogT25seSBjYW4gYmUgZW5hYmxlZCB3aGVuIGBjaXJjdWxhcj1mYWxzZWBcclxuICAgICAqIEBrbyDrt7Ao7Lm066mU6528IOyXmOumrOuovO2KuCnqsIAg7LKr67KI7Ke47JmAIOuniOyngOuniSDtjKjrhJAg67CW7Jy866GcIOuEmOyWtOqwgOyngCDrqrvtlZjqsowg7ZWY7JesLCDssqvrsojsp7gv66eI7KeA66eJIO2MqOuEkCDsoIQv7ZuE7J2YIOu5iCDqs7XqsITsnYQg67O07J207KeAIOyViuuPhOuhnSDtlZjripQg7Ji17IWY7J6F64uI64ukXHJcbiAgICAgKiBgY2lyY3VsYXI9ZmFsc2Vg7J24IOqyveyasOyXkOunjCDsgqzsmqntlaAg7IiYIOyeiOyKteuLiOuLpFxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1mbGlja2luZy9PcHRpb25zI2JvdW5kIGJvdW5kICggT3B0aW9ucyApfVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYm91bmQ7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHRoaXMuX2JvdW5kID0gdmFsO1xuICAgICAgdm9pZCB0aGlzLnJlc2l6ZSgpO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJhZGFwdGl2ZVwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGUgaGVpZ2h0IG9mIHRoZSB2aWV3cG9ydCBlbGVtZW50IGFmdGVyIG1vdmVtZW50IHNhbWUgdG8gdGhlIGhlaWdodCBvZiB0aGUgcGFuZWwgYmVsb3cuIFRoaXMgY2FuIGJlIG9ubHkgZW5hYmxlZCB3aGVuIGBob3Jpem9udGFsPXRydWVgXHJcbiAgICAgKiBAa28g7J2064+Z7ZWcIO2bhCDrt7Dtj6ztirgg7JeY66as66i87Yq47J2YIO2BrOq4sOulvCDtmITsnqwg7Yyo64SQ7J2YIOuGkuydtOyZgCDrj5nsnbztlZjqsowg7ISk7KCV7ZWp64uI64ukLiBgaG9yaXpvbnRhbD10cnVlYOyduCDqsr3smrDsl5Drp4wg7IKs7Jqp7ZWgIOyImCDsnojsirXri4jri6QuXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqIEBkZWZhdWx0IGZhbHNlXHJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWZsaWNraW5nL09wdGlvbnMjYWRhcHRpdmUgYWRhcHRpdmUgKCBPcHRpb25zICl9XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9hZGFwdGl2ZTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgdGhpcy5fYWRhcHRpdmUgPSB2YWw7XG4gICAgICB2b2lkIHRoaXMucmVzaXplKCk7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcInBhbmVsc1BlclZpZXdcIiwge1xuICAgIC8qKlxyXG4gICAgICogQSB2aXNpYmxlIG51bWJlciBvZiBwYW5lbHMgb24gdmlld3BvcnQuIEVuYWJsaW5nIHRoaXMgb3B0aW9uIHdpbGwgYXV0b21hdGljYWxseSByZXNpemUgcGFuZWwgc2l6ZVxyXG4gICAgICogQGtvIO2VnCDtmZTrqbTsl5Ag67O07J2064qUIO2MqOuEkOydmCDqsJzsiJguIOydtCDsmLXshZjsnYQg7Zmc7ISx7ZmU7ZWgIOqyveyasCDtjKjrhJDsnZgg7YGs6riw66W8IOqwleygnOuhnCDsnqzsobDsoJXtlanri4jri6RcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCAtMVxyXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1mbGlja2luZy9PcHRpb25zI3BhbmVsc3BlcnZpZXcgcGFuZWxzUGVyVmlldyAoIE9wdGlvbnMgKX1cclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3BhbmVsc1BlclZpZXc7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHRoaXMuX3BhbmVsc1BlclZpZXcgPSB2YWw7XG4gICAgICB2b2lkIHRoaXMucmVzaXplKCk7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcIm5vUGFuZWxTdHlsZU92ZXJyaWRlXCIsIHtcbiAgICAvKipcclxuICAgICAqIEVuYWJsaW5nIHRoaXMgb3B0aW9uIHdpbGwgbm90IGNoYW5nZSBgd2lkdGgvaGVpZ2h0YCBzdHlsZSBvZiB0aGUgcGFuZWxzIGlmIHtAbGluayBGbGlja2luZyNwYW5lbHNQZXJWaWV3fSBpcyBlbmFibGVkLlxyXG4gICAgICogVGhpcyBiZWhhdmlvciBjYW4gYmUgdXNlZnVsIGluIHRlcm1zIG9mIHBlcmZvcm1hbmNlIHdoZW4geW91J3JlIG1hbnVhbGx5IG1hbmFnaW5nIGFsbCBwYW5lbCBzaXplc1xyXG4gICAgICogQGtvIOydtCDsmLXshZjsnYQg7Zmc7ISx7ZmU7ZWgIOqyveyasCwge0BsaW5rIEZsaWNraW5nI3BhbmVsc1BlclZpZXd9IOyYteyFmOydtCDtmZzshLHtmZTrkJjsl4jsnYQg65WMIO2MqOuEkOydmCBgd2lkdGgvaGVpZ2h0YCDsiqTtg4DsnbzsnYQg67OA6rK97ZWY7KeAIOyViuuPhOuhnSDshKTsoJXtlanri4jri6QuXHJcbiAgICAgKiDrqqjrk6Ag7Yyo64SQ65Ok7J2YIO2BrOq4sOulvCDsp4HsoJEg6rSA66as7ZWY6rOgIOyeiOydhCDqsr3smrAsIOydtCDsmLXshZjsnYQg7Zmc7ISx7ZmU7ZWY66m0IOyEseuKpeuptOyXkOyEnCDsnKDrpqztlaAg7IiYIOyeiOyKteuLiOuLpFxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbm9QYW5lbFN0eWxlT3ZlcnJpZGU7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHRoaXMuX25vUGFuZWxTdHlsZU92ZXJyaWRlID0gdmFsO1xuICAgICAgdm9pZCB0aGlzLnJlc2l6ZSgpO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJyZXNpemVPbkNvbnRlbnRzUmVhZHlcIiwge1xuICAgIC8qKlxyXG4gICAgICogRW5hYmxpbmcgdGhpcyBvcHRpb24gd2lsbCBhdXRvbWF0aWNhbGx5IGNhbGwge0BsaW5rIEZsaWNraW5nI3Jlc2l6ZX0gd2hlbiBhbGwgaW1hZ2UvdmlkZW8gaW5zaWRlIHBhbmVscyBhcmUgbG9hZGVkLlxyXG4gICAgICogVGhpcyBjYW4gYmUgdXNlZnVsIHdoZW4geW91IGhhdmUgY29udGVudHMgaW5zaWRlIEZsaWNraW5nIHRoYXQgY2hhbmdlcyBpdHMgc2l6ZSB3aGVuIGl0J3MgbG9hZGVkXHJcbiAgICAgKiBAa28g7J20IOyYteyFmOydhCDtmZzshLHtmZTtlaAg6rK97JqwLCBGbGlja2luZyDtjKjrhJAg64K067aA7J2YIOydtOuvuOyngC/ruYTrlJTsmKTrk6TsnbQg66Gc65Oc65CY7JeI7J2EIOuVjCDsnpDrj5nsnLzroZwge0BsaW5rIEZsaWNraW5nI3Jlc2l6ZX3rpbwg7Zi47Lac7ZWp64uI64ukLlxyXG4gICAgICog7J20IOuPmeyekeydgCBGbGlja2luZyDrgrTrtoDsl5Ag66Gc65OcIOyghC/tm4TroZwg7YGs6riw6rCAIOuzgO2VmOuKlCDsvZjthZDsuKDrpbwg7Y+s7ZWo7ZWY6rOgIOyeiOydhCDrlYwg7Jyg7Jqp7ZWY6rKMIOyCrOyaqe2VmOyLpCDsiJgg7J6I7Iq164uI64ukLlxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1mbGlja2luZy9PcHRpb25zI3Jlc2l6ZU9uQ29udGVudHNSZWFkeSByZXNpemVPbkNvbnRlbnRzUmVhZHkgKCBPcHRpb25zICl9XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXNpemVPbkNvbnRlbnRzUmVhZHk7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHRoaXMuX3Jlc2l6ZU9uQ29udGVudHNSZWFkeSA9IHZhbDtcbiAgICAgIGlmICh2YWwpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuY2hlY2tQYW5lbENvbnRlbnRzUmVhZHkodGhpcy5fcmVuZGVyZXIucGFuZWxzKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwibmVzdGVkXCIsIHtcbiAgICAvKipcclxuICAgICAqIElmIHlvdSBlbmFibGUgdGhpcyBvcHRpb24gb24gY2hpbGQgRmxpY2tpbmcgd2hlbiB0aGUgRmxpY2tpbmcgaXMgcGxhY2VkIGluc2lkZSB0aGUgRmxpY2tpbmcsIHRoZSBwYXJlbnQgRmxpY2tpbmcgd2lsbCBtb3ZlIGluIHRoZSBzYW1lIGRpcmVjdGlvbiBhZnRlciB0aGUgY2hpbGQgRmxpY2tpbmcgcmVhY2hlcyB0aGUgZmlyc3QvbGFzdCBwYW5lbC5cclxuICAgICAqIElmIHRoZSBwYXJlbnQgRmxpY2tpbmcgYW5kIGNoaWxkIEZsaWNraW5nIGhhdmUgZGlmZmVyZW50IGhvcml6b250YWwgb3B0aW9uLCB5b3UgZG8gbm90IG5lZWQgdG8gc2V0IHRoaXMgb3B0aW9uLlxyXG4gICAgICogQGtvIEZsaWNraW5nIOuCtOu2gOyXkCBGbGlja2luZ+ydtCDrsLDsuZjrkKAg65WMIO2VmOychCBGbGlja2luZ+yXkOyEnCDsnbQg7Ji17IWY7J2EIO2ZnOyEse2ZlO2VmOuptCDtlZjsnIQgRmxpY2tpbmfsnbQg7LKrL+uniOyngOuniSDtjKjrhJDsl5Ag64+E64us7ZWcIOuSpOu2gO2EsCDqsJnsnYAg67Cp7Zal7Jy866GcIOyDgeychCBGbGlja2luZ+ydtCDsm4Dsp4HsnoXri4jri6QuXHJcbiAgICAgKiDrp4zslb0g7IOB7JyEIEZsaWNraW5n6rO8IO2VmOychCBGbGlja2luZ+ydtCDshJzroZwg64uk66W4IGhvcml6b250YWwg7Ji17IWY7J2EIOqwgOyngOqzoCDsnojri6TrqbQg7J20IOyYteyFmOydhCDshKTsoJXtlaAg7ZWE7JqU6rCAIOyXhuyKteuLiOuLpC5cclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICogQGRlZmF1bHQgZmFsc2VcclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtZmxpY2tpbmcvT3B0aW9ucyNuZXN0ZWQgbmVzdGVkICggT3B0aW9ucyApfVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbmVzdGVkO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICB0aGlzLl9uZXN0ZWQgPSB2YWw7XG4gICAgICB2YXIgYXhlcyA9IHRoaXMuX2NvbnRyb2wuY29udHJvbGxlci5heGVzO1xuICAgICAgaWYgKGF4ZXMpIHtcbiAgICAgICAgYXhlcy5vcHRpb25zLm5lc3RlZCA9IHZhbDtcbiAgICAgIH1cbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwibmVlZFBhbmVsVGhyZXNob2xkXCIsIHtcbiAgICAvLyBFVkVOVFNcbiAgICAvKipcclxuICAgICAqIEEgVGhyZXNob2xkIGZyb20gdmlld3BvcnQgZWRnZSBiZWZvcmUgdHJpZ2dlcmluZyBgbmVlZFBhbmVsYCBldmVudFxyXG4gICAgICogQGtvIGBuZWVkUGFuZWxg7J2067Kk7Yq46rCAIOuwnOyDne2VmOq4sCDsnITtlZwg67ew7Y+s7Yq4IOuBneycvOuhnOu2gO2EsOydmCDstZzrjIAg6rGw66asXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgMFxyXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1mbGlja2luZy9PcHRpb25zI25lZWRwYW5lbHRocmVzaG9sZCBuZWVkUGFuZWxUaHJlc2hvbGQgKCBPcHRpb25zICl9XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9uZWVkUGFuZWxUaHJlc2hvbGQ7XG4gICAgfSxcbiAgICAvLyBFVkVOVFNcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHRoaXMuX25lZWRQYW5lbFRocmVzaG9sZCA9IHZhbDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwicHJldmVudEV2ZW50c0JlZm9yZUluaXRcIiwge1xuICAgIC8qKlxyXG4gICAgICogV2hlbiBlbmFibGVkLCBldmVudHMgYXJlIG5vdCB0cmlnZ2VyZWQgYmVmb3JlIGByZWFkeWAgd2hlbiBpbml0aWFsaXppbmdcclxuICAgICAqIEBrbyDtmZzshLHtmZTtlaAg6rK97JqwIOy0iOq4sO2ZlOyLnCBgcmVhZHlgIOydtOuypO2KuCDsnbTsoITsnZgg7J2067Kk7Yq46rCAIOuwnOyDne2VmOyngCDslYrsirXri4jri6QuXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqIEBkZWZhdWx0IHRydWVcclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtZmxpY2tpbmcvT3B0aW9ucyNwcmV2ZW50ZXZlbnRzYmVmb3JlaW5pdCBwcmV2ZW50RXZlbnRzQmVmb3JlSW5pdCAoIE9wdGlvbnMgKX1cclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3ByZXZlbnRFdmVudHNCZWZvcmVJbml0O1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICB0aGlzLl9wcmV2ZW50RXZlbnRzQmVmb3JlSW5pdCA9IHZhbDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwiZGVjZWxlcmF0aW9uXCIsIHtcbiAgICAvLyBBTklNQVRJT05cbiAgICAvKipcclxuICAgICAqIERlY2VsZXJhdGlvbiB2YWx1ZSBmb3IgcGFuZWwgbW92ZW1lbnQgYW5pbWF0aW9uIHdoaWNoIGlzIHRyaWdnZXJlZCBieSB1c2VyIGlucHV0LiBBIGhpZ2hlciB2YWx1ZSBtZWFucyBhIHNob3J0ZXIgYW5pbWF0aW9uIHRpbWVcclxuICAgICAqIEBrbyDsgqzsmqnsnpDsnZgg64+Z7J6R7Jy866GcIOqwgOyGjeuPhOqwgCDsoIHsmqnrkJwg7Yyo64SQIOydtOuPmSDslaDri4jrqZTsnbTshZjsnZgg6rCQ7IaN64+ELiDqsJLsnbQg64aS7J2E7IiY66GdIOyVoOuLiOuplOydtOyFmCDsi6Ttlokg7Iuc6rCE7J20IOynp+yVhOynkeuLiOuLpFxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDAuMDA3NVxyXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1mbGlja2luZy9PcHRpb25zI2RlY2VsZXJhdGlvbiBkZWNlbGVyYXRpb24gKCBPcHRpb25zICl9XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kZWNlbGVyYXRpb247XG4gICAgfSxcbiAgICAvLyBBTklNQVRJT05cbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHRoaXMuX2RlY2VsZXJhdGlvbiA9IHZhbDtcbiAgICAgIHZhciBheGVzID0gdGhpcy5fY29udHJvbC5jb250cm9sbGVyLmF4ZXM7XG4gICAgICBpZiAoYXhlcykge1xuICAgICAgICBheGVzLm9wdGlvbnMuZGVjZWxlcmF0aW9uID0gdmFsO1xuICAgICAgfVxuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJlYXNpbmdcIiwge1xuICAgIC8qKlxyXG4gICAgICogQW4gZWFzaW5nIGZ1bmN0aW9uIGFwcGxpZWQgdG8gdGhlIHBhbmVsIG1vdmVtZW50IGFuaW1hdGlvbi4gRGVmYXVsdCB2YWx1ZSBpcyBgZWFzZU91dEN1YmljYFxyXG4gICAgICogQGtvIO2MqOuEkCDsnbTrj5kg7JWg64uI66mU7J207IWY7JeQIOyggeyaqe2VoCBlYXNpbmcg7ZWo7IiYLiDquLDrs7jqsJLsnYAgYGVhc2VPdXRDdWJpY2DsnbTri6RcclxuICAgICAqIEB0eXBlIHtmdW5jdGlvbn1cclxuICAgICAqIEBkZWZhdWx0IHggPT4gMSAtIE1hdGgucG93KDEgLSB4LCAzKVxyXG4gICAgICogQHNlZSBFYXNpbmcgRnVuY3Rpb25zIENoZWF0IFNoZWV0IHtAbGluayBodHRwOi8vZWFzaW5ncy5uZXQvfSA8a28+7J207KeVIO2VqOyImCBDaGVhdCBTaGVldCB7QGxpbmsgaHR0cDovL2Vhc2luZ3MubmV0L308L2tvPlxyXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1mbGlja2luZy9PcHRpb25zI2Vhc2luZyBFYXNpbmcgKCBPcHRpb25zICl9XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9lYXNpbmc7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHRoaXMuX2Vhc2luZyA9IHZhbDtcbiAgICAgIHZhciBheGVzID0gdGhpcy5fY29udHJvbC5jb250cm9sbGVyLmF4ZXM7XG4gICAgICBpZiAoYXhlcykge1xuICAgICAgICBheGVzLm9wdGlvbnMuZWFzaW5nID0gdmFsO1xuICAgICAgfVxuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJkdXJhdGlvblwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBEZWZhdWx0IGR1cmF0aW9uIG9mIHRoZSBhbmltYXRpb24gKG1zKVxyXG4gICAgICogQGtvIOuUlO2PtO2KuCDslaDri4jrqZTsnbTshZgg7J6s7IOdIOyLnOqwhCAobXMpXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgNTAwXHJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWZsaWNraW5nL09wdGlvbnMjZHVyYXRpb24gZHVyYXRpb24gKCBPcHRpb25zICl9XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kdXJhdGlvbjtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgdGhpcy5fZHVyYXRpb24gPSB2YWw7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcImlucHV0VHlwZVwiLCB7XG4gICAgLy8gSU5QVVRcbiAgICAvKipcclxuICAgICAqIFR5cGVzIG9mIGlucHV0IGRldmljZXMgdG8gZW5hYmxlXHJcbiAgICAgKiBAa28g7Zmc7ISx7ZmU7ZWgIOyeheugpSDsnqXsuZgg7KKF66WYXHJcbiAgICAgKiBAdHlwZSB7c3RyaW5nW119XHJcbiAgICAgKiBAZGVmYXVsdCBbXCJ0b3VjaFwiLCBcIm1vdXNlXCJdXHJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWF4ZXMvT3B0aW9ucyNwYW5pbnB1dC1vcHRpb25zIFBvc3NpYmxlIHZhbHVlcyAoUGFuSW5wdXRPcHRpb24jaW5wdXRUeXBlKX1cclxuICAgICAqIDxrbz57QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1heGVzL09wdGlvbnMjcGFuaW5wdXQtb3B0aW9ucyDqsIDriqXtlZwg6rCS65OkIChQYW5JbnB1dE9wdGlvbiNpbnB1dFR5cGUpfTwva28+XHJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWZsaWNraW5nL09wdGlvbnMjaW5wdXR0eXBlIGlucHV0VHlwZSAoIE9wdGlvbnMgKX1cclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2lucHV0VHlwZTtcbiAgICB9LFxuICAgIC8vIElOUFVUXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICB0aGlzLl9pbnB1dFR5cGUgPSB2YWw7XG4gICAgICB2YXIgcGFuSW5wdXQgPSB0aGlzLl9jb250cm9sLmNvbnRyb2xsZXIucGFuSW5wdXQ7XG4gICAgICBpZiAocGFuSW5wdXQpIHtcbiAgICAgICAgcGFuSW5wdXQub3B0aW9ucy5pbnB1dFR5cGUgPSB2YWw7XG4gICAgICB9XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcIm1vdmVUeXBlXCIsIHtcbiAgICAvKipcclxuICAgICAqIE1vdmVtZW50IHN0eWxlIGJ5IHVzZXIgaW5wdXQuIFRoaXMgd2lsbCBjaGFuZ2UgaW5zdGFuY2UgdHlwZSBvZiB7QGxpbmsgRmxpY2tpbmcjY29udHJvbH1cclxuICAgICAqIFlvdSBjYW4gdXNlIHRoZSB2YWx1ZXMgb2YgdGhlIGNvbnN0YW50IHtAbGluayBNT1ZFX1RZUEV9XHJcbiAgICAgKiBAa28g7IKs7Jqp7J6QIOyeheugpeyXkCDsnZjtlZwg7J2064+ZIOuwqeyLnS4g7J20IOqwkuyXkCDrlLDrnbwge0BsaW5rIEZsaWNraW5nI2NvbnRyb2x97J2YIOyduOyKpO2EtOyKpCDtg4DsnoXsnbQg6rKw7KCV65Cp64uI64ukXHJcbiAgICAgKiDsg4HsiJgge0BsaW5rIE1PVkVfVFlQRX3sl5Ag7KCV7J2Y65CcIOqwkuuTpOydhCDsnbTsmqntlaAg7IiYIOyeiOyKteuLiOuLpFxyXG4gICAgICogQHR5cGUge01PVkVfVFlQRSB8IFBhaXI8c3RyaW5nLCBvYmplY3Q+fVxyXG4gICAgICogQGRlZmF1bHQgXCJzbmFwXCJcclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtZmxpY2tpbmcvT3B0aW9ucyNtb3ZldHlwZSBtb3ZlVHlwZSAoIE9wdGlvbnMgKX1cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiB8bW92ZVR5cGV8Y29udHJvbHxvcHRpb25zfFxyXG4gICAgICogfDotLS06fDotLS06fDotLS06fFxyXG4gICAgICogfFwic25hcFwifHtAbGluayBTbmFwQ29udHJvbH18fFxyXG4gICAgICogfFwiZnJlZVNjcm9sbFwifHtAbGluayBGcmVlQ29udHJvbH18e0BsaW5rIEZyZWVDb250cm9sT3B0aW9uc318XHJcbiAgICAgKlxyXG4gICAgICogYGBgdHNcclxuICAgICAqIGltcG9ydCBGbGlja2luZywgeyBNT1ZFX1RZUEUgfSBmcm9tIFwiQGVnanMvZmxpY2tpbmdcIjtcclxuICAgICAqXHJcbiAgICAgKiBjb25zdCBmbGlja2luZyA9IG5ldyBGbGlja2luZyh7XHJcbiAgICAgKiAgIG1vdmVUeXBlOiBNT1ZFX1RZUEUuU05BUFxyXG4gICAgICogfSk7XHJcbiAgICAgKiBgYGBcclxuICAgICAqXHJcbiAgICAgKiBgYGB0c1xyXG4gICAgICogY29uc3QgZmxpY2tpbmcgPSBuZXcgRmxpY2tpbmcoe1xyXG4gICAgICogICAvLyBJZiB5b3Ugd2FudCBtb3JlIHNwZWNpZmljIHNldHRpbmdzIGZvciB0aGUgbW92ZVR5cGVcclxuICAgICAqICAgLy8gW21vdmVUeXBlLCBvcHRpb25zIGZvciB0aGF0IG1vdmVUeXBlXVxyXG4gICAgICogICAvLyBJbiB0aGlzIGNhc2UsIGl0J3MgW1wiZnJlZVNjcm9sbFwiLCBGcmVlQ29udHJvbE9wdGlvbnNdXHJcbiAgICAgKiAgIG1vdmVUeXBlOiBbTU9WRV9UWVBFLkZSRUVfU0NST0xMLCB7IHN0b3BBdEVkZ2U6IHRydWUgfV1cclxuICAgICAqIH0pO1xyXG4gICAgICogYGBgXHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tb3ZlVHlwZTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgdGhpcy5fbW92ZVR5cGUgPSB2YWw7XG4gICAgICB2YXIgcHJldkNvbnRyb2wgPSB0aGlzLl9jb250cm9sO1xuICAgICAgdmFyIG5ld0NvbnRyb2wgPSB0aGlzLl9jcmVhdGVDb250cm9sKCk7XG4gICAgICB2YXIgYWN0aXZlUGFuZWwgPSBwcmV2Q29udHJvbC5hY3RpdmVQYW5lbDtcbiAgICAgIG5ld0NvbnRyb2wuY29weShwcmV2Q29udHJvbCk7XG4gICAgICB2YXIgcHJldlByb2dyZXNzSW5QYW5lbCA9IGFjdGl2ZVBhbmVsID8gdGhpcy5fY2FtZXJhLmdldFByb2dyZXNzSW5QYW5lbChhY3RpdmVQYW5lbCkgOiAwO1xuICAgICAgdGhpcy5fY29udHJvbCA9IG5ld0NvbnRyb2w7XG4gICAgICB0aGlzLl9jb250cm9sLnVwZGF0ZVBvc2l0aW9uKHByZXZQcm9ncmVzc0luUGFuZWwpO1xuICAgICAgdGhpcy5fY29udHJvbC51cGRhdGVJbnB1dCgpO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJ0aHJlc2hvbGRcIiwge1xuICAgIC8qKlxyXG4gICAgICogTW92ZW1lbnQgdGhyZXNob2xkIHRvIGNoYW5nZSBwYW5lbCAodW5pdDogcHgpLiBJdCBzaG91bGQgYmUgZHJhZ2dlZCBhYm92ZSB0aGUgdGhyZXNob2xkIHRvIGNoYW5nZSB0aGUgY3VycmVudCBwYW5lbC5cclxuICAgICAqIEBrbyDtjKjrhJAg67OA6rK97J2EIOychO2VnCDsnbTrj5kg7J6E6rOE6rCSICjri6jsnIQ6IHB4KS4g7KO87Ja07KeEIOqwkiDsnbTsg4HsnLzroZwg7Iqk7YGs66Gk7ZW07JW866eMIO2MqOuEkCDrs4Dqsr3snbQg6rCA64ql7ZWY64ukLlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDQwXHJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWZsaWNraW5nL09wdGlvbnMjdGhyZXNob2xkIFRocmVzaG9sZCAoIE9wdGlvbnMgKX1cclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3RocmVzaG9sZDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgdGhpcy5fdGhyZXNob2xkID0gdmFsO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJpbnRlcnJ1cHRhYmxlXCIsIHtcbiAgICAvKipcclxuICAgICAqIFNldCBhbmltYXRpb24gdG8gYmUgaW50ZXJydXB0YWJsZSBieSBjbGljay90b3VjaC5cclxuICAgICAqIEBrbyDsgqzsmqnsnpDsnZgg7YG066atL+2EsOy5mOuhnCDsnbjtlbQg7JWg64uI66mU7J207IWY7J2EIOuPhOykkeyXkCDrqYjstpwg7IiYIOyeiOuPhOuhnSDshKTsoJXtlanri4jri6QuXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqIEBkZWZhdWx0IHRydWVcclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtZmxpY2tpbmcvT3B0aW9ucyNpbnRlcnJ1cHRhYmxlIEludGVycnVwdGFibGUgKCBPcHRpb25zICl9XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pbnRlcnJ1cHRhYmxlO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICB0aGlzLl9pbnRlcnJ1cHRhYmxlID0gdmFsO1xuICAgICAgdmFyIGF4ZXMgPSB0aGlzLl9jb250cm9sLmNvbnRyb2xsZXIuYXhlcztcbiAgICAgIGlmIChheGVzKSB7XG4gICAgICAgIGF4ZXMub3B0aW9ucy5pbnRlcnJ1cHRhYmxlID0gdmFsO1xuICAgICAgfVxuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJib3VuY2VcIiwge1xuICAgIC8qKlxyXG4gICAgICogVGhlIHNpemUgdmFsdWUgb2YgdGhlIGJvdW5jZSBhcmVhLiBPbmx5IGNhbiBiZSBlbmFibGVkIHdoZW4gYGNpcmN1bGFyPWZhbHNlYC5cclxuICAgICAqIFlvdSBjYW4gc2V0IGRpZmZlcmVudCBib3VuY2UgdmFsdWUgZm9yIHByZXYvbmV4dCBkaXJlY3Rpb24gYnkgdXNpbmcgYXJyYXkuXHJcbiAgICAgKiBgbnVtYmVyYCBmb3IgcHggdmFsdWUsIGFuZCBgc3RyaW5nYCBmb3IgcHgsIGFuZCAlIHZhbHVlIHJlbGF0aXZlIHRvIHZpZXdwb3J0IHNpemUuXHJcbiAgICAgKiBZb3UgaGF2ZSB0byBjYWxsIHtAbGluayBDb250cm9sI3VwZGF0ZUlucHV0fSBhZnRlciBjaGFuZ2luZyB0aGlzIHRvIHRha2UgZWZmZWN0LlxyXG4gICAgICogQGtvIEZsaWNraW5n7J20IOy1nOuMgCDsmIHsl63snYQg64SY7Ja07IScIOqwiCDsiJgg7J6I64qUIOy1nOuMgCDtgazquLAuIGBjaXJjdWxhcj1mYWxzZWDsnbgg6rK97Jqw7JeQ66eMIOyCrOyaqe2VoCDsiJgg7J6I7Iq164uI64ukLlxyXG4gICAgICog67Cw7Je07J2EIO2Gte2VtCBwcmV2L25leHQg67Cp7Zal7JeQIOuMgO2VtCDshJzroZwg64uk66W4IOuwlOyatOyKpCDqsJLsnYQg7KeA7KCV7ZWgIOyImCDsnojsirXri4jri6QuXHJcbiAgICAgKiBgbnVtYmVyYOulvCDthrXtlbQgcHjqsJLsnYQsIGBzdGlybmdg7J2EIO2Gte2VtCBweCDtmLnsnYAg67ew7Y+s7Yq4IO2BrOq4sCDrjIDruYQgJeqwkuydhCDsgqzsmqntlaAg7IiYIOyeiOyKteuLiOuLpC5cclxuICAgICAqIOydtCDqsJLsnYQg67OA6rK97IucIHtAbGluayBDb250cm9sI3VwZGF0ZUlucHV0feulvCDtmLjstpztlbTslbwg7ZWp64uI64ukLlxyXG4gICAgICogQHR5cGUge3N0cmluZyB8IG51bWJlciB8IEFycmF5PHN0cmluZyB8IG51bWJlcj59XHJcbiAgICAgKiBAZGVmYXVsdCBcIjIwJVwiXHJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWZsaWNraW5nL09wdGlvbnMjYm91bmNlIGJvdW5jZSAoIE9wdGlvbnMgKX1cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBgYGB0c1xyXG4gICAgICogY29uc3QgcG9zc2libGVPcHRpb25zID0gW1xyXG4gICAgICogICAvLyAlIHZhbHVlcywgcmVsYXRpdmUgdG8gdmlld3BvcnQgZWxlbWVudChcIi5mbGlja2luZy12aWV3cG9ydFwiKSdzIHNpemVcclxuICAgICAqICAgXCIwJVwiLCBcIjI1JVwiLCBcIjQyJVwiLFxyXG4gICAgICogICAvLyBweCB2YWx1ZXMsIGFyaXRobWV0aWMgY2FsY3VsYXRpb24gd2l0aCAoKy8tKSBpcyBhbHNvIGFsbG93ZWQuXHJcbiAgICAgKiAgIFwiMHB4XCIsIFwiMTAwcHhcIiwgXCI1MCUgLSAyNXB4XCIsXHJcbiAgICAgKiAgIC8vIG51bWJlcnMsIHNhbWUgdG8gbnVtYmVyICsgcHggKFwiMHB4XCIsIFwiMTAwcHhcIilcclxuICAgICAqICAgMCwgMTAwLCAxMDAwXHJcbiAgICAgKiBdO1xyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGBgYHRzXHJcbiAgICAgKiBjb25zdCBmbGlja2luZyA9IG5ldyBGbGlja2luZyhcIiNlbFwiLCB7IGJvdW5jZTogXCIyMCVcIiB9KTtcclxuICAgICAqXHJcbiAgICAgKiBmbGlja2luZy5ib3VuY2UgPSBcIjEwMCVcIjtcclxuICAgICAqIGZsaWNraW5nLmNvbnRyb2wudXBkYXRlSW5wdXQoKTsgLy8gQ2FsbCB0aGlzIHRvIHVwZGF0ZSFcclxuICAgICAqIGBgYFxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYm91bmNlO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICB0aGlzLl9ib3VuY2UgPSB2YWw7XG4gICAgICB0aGlzLl9jb250cm9sLnVwZGF0ZUlucHV0KCk7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcImlPU0VkZ2VTd2lwZVRocmVzaG9sZFwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBTaXplIG9mIHRoZSBhcmVhIGZyb20gdGhlIHJpZ2h0IGVkZ2UgaW4gaU9TIHNhZmFyaSAoaW4gcHgpIHdoaWNoIGVuYWJsZXMgc3dpcGUtYmFjayBvciBzd2lwZS1mb3J3YXJkXHJcbiAgICAgKiBAa28gaU9TIFNhZmFyaeyXkOyEnCBzd2lwZeulvCDthrXtlZwg65Kk66Gc6rCA6riwL+yVnuycvOuhnOqwgOq4sOulvCDtmZzshLHtmZTtlZjripQg7Jik66W47Kq9IOuBneycvOuhnOu2gO2EsOydmCDsmIHsl63snZgg7YGs6riwIChweClcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCAzMFxyXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1mbGlja2luZy9PcHRpb25zI2lvc2VkZ2Vzd2lwZXRocmVzaG9sZCBpT1NFZGdlU3dpcGVUaHJlc2hvbGQgKCBPcHRpb25zICl9XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pT1NFZGdlU3dpcGVUaHJlc2hvbGQ7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHRoaXMuX2lPU0VkZ2VTd2lwZVRocmVzaG9sZCA9IHZhbDtcbiAgICAgIHZhciBwYW5JbnB1dCA9IHRoaXMuX2NvbnRyb2wuY29udHJvbGxlci5wYW5JbnB1dDtcbiAgICAgIGlmIChwYW5JbnB1dCkge1xuICAgICAgICBwYW5JbnB1dC5vcHRpb25zLmlPU0VkZ2VTd2lwZVRocmVzaG9sZCA9IHZhbDtcbiAgICAgIH1cbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwicHJldmVudENsaWNrT25EcmFnXCIsIHtcbiAgICAvKipcclxuICAgICAqIEF1dG9tYXRpY2FsbHkgcHJldmVudCBgY2xpY2tgIGV2ZW50IGlmIHRoZSB1c2VyIGhhcyBkcmFnZ2VkIGF0IGxlYXN0IGEgc2luZ2xlIHBpeGVsIG9uIHRoZSB2aWV3cG9ydCBlbGVtZW50XHJcbiAgICAgKiBAa28g7IKs7Jqp7J6Q6rCAIOu3sO2PrO2KuCDsmIHsl63snYQgMe2UveyFgOydtOudvOuPhCDrk5zrnpjqt7jtlojsnYQg6rK97JqwIOyekOuPmeycvOuhnCB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcva28vZG9jcy9XZWIvQVBJL0VsZW1lbnQvY2xpY2tfZXZlbnQgY2xpY2t9IOydtOuypO2KuOulvCDst6jshoztlanri4jri6RcclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICogQGRlZmF1bHQgdHJ1ZVxyXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1mbGlja2luZy9PcHRpb25zI3ByZXZlbnRjbGlja29uZHJhZyBwcmV2ZW50Q2xpY2tPbkRyYWcgKCBPcHRpb25zICl9XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcmV2ZW50Q2xpY2tPbkRyYWc7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHZhciBwcmV2VmFsID0gdGhpcy5fcHJldmVudENsaWNrT25EcmFnO1xuICAgICAgaWYgKHZhbCA9PT0gcHJldlZhbCkgcmV0dXJuO1xuICAgICAgdmFyIGNvbnRyb2xsZXIgPSB0aGlzLl9jb250cm9sLmNvbnRyb2xsZXI7XG4gICAgICBpZiAodmFsKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuYWRkUHJldmVudENsaWNrSGFuZGxlcigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udHJvbGxlci5yZW1vdmVQcmV2ZW50Q2xpY2tIYW5kbGVyKCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9wcmV2ZW50Q2xpY2tPbkRyYWcgPSB2YWw7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcInByZXZlbnREZWZhdWx0T25EcmFnXCIsIHtcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgdG8gdXNlIHRoZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcva28vZG9jcy9XZWIvQVBJL0V2ZW50L3ByZXZlbnREZWZhdWx0IHByZXZlbnREZWZhdWx0fSB3aGVuIHRoZSB1c2VyIHN0YXJ0cyBkcmFnZ2luZ1xyXG4gICAgICogQGtvIOyCrOyaqeyekOqwgCDrk5zrnpjqt7jrpbwg7Iuc7J6R7ZWgIOuVjCB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcva28vZG9jcy9XZWIvQVBJL0V2ZW50L3ByZXZlbnREZWZhdWx0IHByZXZlbnREZWZhdWx0fSDsi6Ttlokg7Jes67aAXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqIEBkZWZhdWx0IGZhbHNlXHJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWZsaWNraW5nL09wdGlvbnMjcHJldmVudERlZmF1bHRPbkRyYWcgcHJldmVudERlZmF1bHRPbkRyYWcgKCBPcHRpb25zICl9XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcmV2ZW50RGVmYXVsdE9uRHJhZztcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgdGhpcy5fcHJldmVudERlZmF1bHRPbkRyYWcgPSB2YWw7XG4gICAgICB2YXIgcGFuSW5wdXQgPSB0aGlzLl9jb250cm9sLmNvbnRyb2xsZXIucGFuSW5wdXQ7XG4gICAgICBpZiAocGFuSW5wdXQpIHtcbiAgICAgICAgcGFuSW5wdXQub3B0aW9ucy5wcmV2ZW50RGVmYXVsdE9uRHJhZyA9IHZhbDtcbiAgICAgIH1cbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwiZGlzYWJsZU9uSW5pdFwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBBdXRvbWF0aWNhbGx5IGNhbGwge0BsaW5rIEZsaWNraW5nI2Rpc2FibGVJbnB1dCBkaXNhYmxlSW5wdXQoKX0gb24gaW5pdGlhbGl6YXRpb25cclxuICAgICAqIEBrbyBGbGlja2luZyBpbml07Iuc7JeQIHtAbGluayBGbGlja2luZyNkaXNhYmxlSW5wdXQgZGlzYWJsZUlucHV0KCl97J2EIOuwlOuhnCDtmLjstpztlanri4jri6RcclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICogQGRlZmF1bHQgZmFsc2VcclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtZmxpY2tpbmcvT3B0aW9ucyNkaXNhYmxlb25pbml0IGRpc2FibGVPbkluaXQgKCBPcHRpb25zICl9XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kaXNhYmxlT25Jbml0O1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICB0aGlzLl9kaXNhYmxlT25Jbml0ID0gdmFsO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJjaGFuZ2VPbkhvbGRcIiwge1xuICAgIC8qKlxyXG4gICAgICogQ2hhbmdlIGFjdGl2ZSBwYW5lbCBpbmRleCBvbiBtb3VzZS90b3VjaCBob2xkIHdoaWxlIGFuaW1hdGluZy5cclxuICAgICAqIGBpbmRleGAgb2YgdGhlIGB3aWxsQ2hhbmdlYC9gd2lsbFJlc3RvcmVgIGV2ZW50IHdpbGwgYmUgdXNlZCBhcyBuZXcgaW5kZXguXHJcbiAgICAgKiBAa28g7JWg64uI66mU7J207IWYIOuPhOykkSDrp4jsmrDsiqQv7YSw7LmYIOyeheugpeyLnCDtmITsnqwg7Zmc7ISx7ZmU65CcIO2MqOuEkOydmCDsnbjrjbHsiqTrpbwg67OA6rK97ZWp64uI64ukLlxyXG4gICAgICogYHdpbGxDaGFuZ2VgL2B3aWxsUmVzdG9yZWAg7J2067Kk7Yq47J2YIGBpbmRleGDqsJLsnbQg7IOI66Gc7Jq0IOyduOuNseyKpOuhnCDsgqzsmqnrkKAg6rKD7J6F64uI64ukLlxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1mbGlja2luZy9PcHRpb25zI2NoYW5nZW9uaG9sZCBjaGFuZ2VPbkhvbGQgKCBPcHRpb25zICl9XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jaGFuZ2VPbkhvbGQ7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHRoaXMuX2NoYW5nZU9uSG9sZCA9IHZhbDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwicmVuZGVyT25seVZpc2libGVcIiwge1xuICAgIC8vIFBFUkZPUk1BTkNFXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHRvIHJlbmRlciB2aXNpYmxlIHBhbmVscyBvbmx5LiBUaGlzIGNhbiBkcmFtYXRpY2FsbHkgaW5jcmVhc2UgcGVyZm9ybWFuY2Ugd2hlbiB0aGVyZSdyZSBtYW55IHBhbmVsc1xyXG4gICAgICogQGtvIOuztOydtOuKlCDtjKjrhJDrp4wg66CM642U66eB7ZWg7KeAIOyXrOu2gOulvCDshKTsoJXtlanri4jri6QuIO2MqOuEkOydtCDrp47snYQg6rK97Jqw7JeQIO2NvO2PrOuovOyKpOulvCDtgazqsowg7Zal7IOB7Iuc7YKsIOyImCDsnojsirXri4jri6RcclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICogQGRlZmF1bHQgZmFsc2VcclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtZmxpY2tpbmcvT3B0aW9ucyNyZW5kZXJvbmx5dmlzaWJsZSByZW5kZXJPbmx5VmlzaWJsZSAoIE9wdGlvbnMgKX1cclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlck9ubHlWaXNpYmxlO1xuICAgIH0sXG4gICAgLy8gUEVSRk9STUFOQ0VcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHRoaXMuX3JlbmRlck9ubHlWaXNpYmxlID0gdmFsO1xuICAgICAgdm9pZCB0aGlzLl9yZW5kZXJlci5yZW5kZXIoKTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwidmlydHVhbFwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBCeSBlbmFibGluZyB0aGlzIG9wdGlvbiwgaXQgd2lsbCByZWR1Y2UgbWVtb3J5IGNvbnN1bXB0aW9uIGJ5IHJlc3RyaWN0aW5nIHRoZSBudW1iZXIgb2YgRE9NIGVsZW1lbnRzIHRvIGBwYW5lbHNQZXJWaWV3ICsgMWBcclxuICAgICAqIE11c3QgYmUgdXNlZCB3aXRoIGBwYW5lbHNQZXJ2aWV3YC5cclxuICAgICAqIEFmdGVyIEZsaWNraW5nJ3MgaW5pdGlhbGl6ZWQsIHRoaXMgcHJvcGVydHkgY2FuIGJlIHVzZWQgdG8gYWRkL3JlbW92ZSB0aGUgcGFuZWwgY291bnQuXHJcbiAgICAgKiBAa28g7J20IOyYteyFmOydhCDtmZzshLHtmZTtlaAg6rK97JqwIO2MqOuEkCDsl5jrpqzrqLztirjsnZgg6rCc7IiY66W8IGBwYW5lbHNQZXJWaWV3ICsgMWAg6rCc66GcIOqzoOygle2VqOycvOuhnOyNqCwg66mU66qo66asIOyCrOyaqeufieydhCDspITsnbwg7IiYIOyeiOyKteuLiOuLpC5cclxuICAgICAqIGBwYW5lbHNQZXJWaWV3YCDsmLXshZjqs7wg7ZWo6ruYIOyCrOyaqeuQmOyWtOyVvOunjCDtlanri4jri6QuXHJcbiAgICAgKiBGbGlja2luZyDstIjquLDtmZQg7J207ZuE7JeQLCDsnbQg7ZSE66Gc7Y287Yuw64qUIOugjOuNlOunge2VmOuKlCDtjKjrhJDsnZgg6rCc7IiY66W8IOy2lOqwgC/soJzqsbDtlZjquLAg7JyE7ZW0IOyCrOyaqeuQoCDsiJgg7J6I7Iq164uI64ukLlxyXG4gICAgICogQHR5cGUge1ZpcnR1YWxNYW5hZ2VyfVxyXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gcmVuZGVyUGFuZWwgQSByZW5kZXJpbmcgZnVuY3Rpb24gZm9yIHRoZSBwYW5lbCBlbGVtZW50J3MgaW5uZXJIVE1MPGtvPu2MqOuEkCDsl5jrpqzrqLztirjsnZggaW5uZXJIVE1M7J2EIOugjOuNlOunge2VmOuKlCDtlajsiJg8L2tvPlxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGluaXRpYWxQYW5lbENvdW50IEluaXRpYWwgcGFuZWwgY291bnQgdG8gcmVuZGVyPGtvPuy1nOy0iOuhnCDroIzrjZTrp4HtlaAg7Yyo64SQ7J2YIOqwnOyImDwva28+XHJcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtjYWNoZT1mYWxzZV0gV2hldGhlciB0byBjYWNoZSByZW5kZXJlZCBwYW5lbCdzIGlubmVySFRNTDxrbz7roIzrjZTrp4HrkJwg7Yyo64SQ7J2YIGlubmVySFRNTCDsoJXrs7Trpbwg7LqQ7Iuc7ZWg7KeAIOyXrOu2gDwva28+XHJcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3BhbmVsQ2xhc3M9XCJmbGlja2luZy1wYW5lbFwiXSBUaGUgY2xhc3MgbmFtZSB0aGF0IHdpbGwgYmUgYXBwbGllZCB0byByZW5kZXJlZCBwYW5lbCBlbGVtZW50czxrbz7roIzrjZTrp4HrkJjripQg7Yyo64SQIOyXmOumrOuovO2KuOyXkCDsoIHsmqnrkKAg7YG0656Y7IqkIOydtOumhDwva28+XHJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWZsaWNraW5nL09wdGlvbnMjdmlydHVhbCB2aXJ0dWFsICggT3B0aW9ucyApfVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGBgYHRzXHJcbiAgICAgKiBpbXBvcnQgRmxpY2tpbmcsIHsgVmlydHVhbFBhbmVsIH0gZnJvbSBcIkBlZ2pzL2ZsaWNraW5nXCI7XHJcbiAgICAgKlxyXG4gICAgICogY29uc3QgZmxpY2tpbmcgPSBuZXcgRmxpY2tpbmcoXCIjc29tZV9lbFwiLCB7XHJcbiAgICAgKiAgIHBhbmVsc1BlclZpZXc6IDMsXHJcbiAgICAgKiAgIHZpcnR1YWw6IHtcclxuICAgICAqICAgICByZW5kZXJQYW5lbDogKHBhbmVsOiBWaXJ0dWFsUGFuZWwsIGluZGV4OiBudW1iZXIpID0+IGBQYW5lbCAke2luZGV4fWAsXHJcbiAgICAgKiAgICAgaW5pdGlhbFBhbmVsQ291bnQ6IDEwMFxyXG4gICAgICogICB9XHJcbiAgICAgKiB9KTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBBZGQgMTAwIHZpcnR1YWwgcGFuZWxzIChhdCB0aGUgZW5kKVxyXG4gICAgICogZmxpY2tpbmcudmlydHVhbC5hcHBlbmQoMTAwKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBSZW1vdmUgMTAwIHZpcnR1YWwgcGFuZWxzIGZyb20gMCB0byAxMDBcclxuICAgICAqIGZsaWNraW5nLnZpcnR1YWwucmVtb3ZlKDAsIDEwMCk7XHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3ZpcnR1YWxNYW5hZ2VyO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJhdXRvSW5pdFwiLCB7XG4gICAgLy8gT1RIRVJTXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsIHtAbGluayBGbGlja2luZyNpbml0IGluaXQoKX0gYXV0b21hdGljYWxseSB3aGVuIGNyZWF0aW5nIEZsaWNraW5nJ3MgaW5zdGFuY2VcclxuICAgICAqIEBrbyBGbGlja2luZyDsnbjsiqTthLTsiqTrpbwg7IOd7ISx7ZWgIOuVjCDsnpDrj5nsnLzroZwge0BsaW5rIEZsaWNraW5nI2luaXQgaW5pdCgpfeulvCDtmLjstpztlanri4jri6RcclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICogQGRlZmF1bHQgdHJ1ZVxyXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1mbGlja2luZy9PcHRpb25zI2F1dG9pbml0IGF1dG9Jbml0ICggT3B0aW9ucyApfVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9hdXRvSW5pdDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwiYXV0b1Jlc2l6ZVwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHRvIGF1dG9tYXRpY2FsbHkgY2FsbCB7QGxpbmsgRmxpY2tpbmcjcmVzaXplIHJlc2l6ZSgpfSB3aGVuIHRoZSB2aWV3cG9ydCBlbGVtZW50KC5mbGlja2luZy12aWV3cG9ydCkncyBzaXplIGlzIGNoYW5nZWRcclxuICAgICAqIEBrbyDrt7Dtj6ztirgg7JeY66as66i87Yq4KC5mbGlja2luZy12aWV3cG9ydCnsnZgg7YGs6riwIOuzgOqyveyLnCB7QGxpbmsgRmxpY2tpbmcjcmVzaXplIHJlc2l6ZSgpfSDrqZTshozrk5zrpbwg7J6Q64+Z7Jy866GcIO2YuOy2nO2VoOyngCDsl6zrtoDrpbwg7ISk7KCV7ZWp64uI64ukXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqIEBkZWZhdWx0IHRydWVcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2F1dG9SZXNpemU7XG4gICAgfSxcbiAgICAvLyBPVEhFUlNcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHRoaXMuX2F1dG9SZXNpemUgPSB2YWw7XG4gICAgICBpZiAodmFsKSB7XG4gICAgICAgIHRoaXMuX2F1dG9SZXNpemVyLmVuYWJsZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fYXV0b1Jlc2l6ZXIuZGlzYWJsZSgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJ1c2VSZXNpemVPYnNlcnZlclwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHRvIGxpc3RlbiB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1Jlc2l6ZU9ic2VydmVyIFJlc2l6ZU9ic2VydmVyfSdzIGV2ZW50IGluc3RlYWQgb2YgV2luZG93J3Mge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2tvL2RvY3MvV2ViL0FQSS9XaW5kb3cvcmVzaXplX2V2ZW50IHJlc2l6ZX0gZXZlbnQgd2hlbiB1c2luZyB0aGUgYGF1dG9SZXNpemVgIG9wdGlvblxyXG4gICAgICogQGtvIGF1dG9SZXNpemUg7Ji17IWYIOyCrOyaqeyLnCB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1Jlc2l6ZU9ic2VydmVyIFJlc2l6ZU9ic2VydmVyfeydmCDsnbTrsqTtirjrpbwgV2luZG936rCd7LK07J2YIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9rby9kb2NzL1dlYi9BUEkvV2luZG93L3Jlc2l6ZV9ldmVudCByZXNpemV9IOydtOuypO2KuCDrjIDsi6Ag7IiY7Iug7ZWg7KeAIOyXrOu2gOulvCDshKTsoJXtlanri4jri6RcclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICogQGRlZmF1bHQgdHJ1ZVxyXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vZWdqcy1mbGlja2luZy9PcHRpb25zI3VzZXJlc2l6ZW9ic2VydmVyIHVzZVJlc2l6ZU9ic2VydmVyICggT3B0aW9ucyApfVxyXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdXNlUmVzaXplT2JzZXJ2ZXI7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHRoaXMuX3VzZVJlc2l6ZU9ic2VydmVyID0gdmFsO1xuICAgICAgaWYgKHRoaXMuX2F1dG9SZXNpemUpIHtcbiAgICAgICAgdGhpcy5fYXV0b1Jlc2l6ZXIuZW5hYmxlKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcInJlc2l6ZURlYm91bmNlXCIsIHtcbiAgICAvKipcclxuICAgICAqIERlbGF5cyBzaXplIHJlY2FsY3VsYXRpb24gZnJvbSBgYXV0b1Jlc2l6ZWAgYnkgdGhlIGdpdmVuIHRpbWUgaW4gbWlsaXNlY29uZC5cclxuICAgICAqIElmIHRoZSBzaXplIGlzIGNoYW5nZWQgYWdhaW4gd2hpbGUgYmVpbmcgZGVsYXllZCwgaXQgY2FuY2VscyB0aGUgcHJldmlvdXMgb25lIGFuZCBkZWxheXMgZnJvbSB0aGUgYmVnaW5uaW5nIGFnYWluLlxyXG4gICAgICogVGhpcyBjYW4gaW5jcmVhc2UgcGVyZm9ybWFuY2UgYnkgcHJldmVudGluZyBgcmVzaXplYCBiZWluZyBjYWxsZWQgdG9vIG9mdGVuLlxyXG4gICAgICogQGtvIGBhdXRvUmVzaXplYCDshKTsoJXsi5zsl5Ag7Zi47Lac65CY64qUIO2BrOq4sCDsnqzqs4TsgrDsnYQg7KO87Ja07KeEIOyLnOqwhCjri6jsnIQ6IG1zKeunjO2BvCDsp4Dsl7Dsi5ztgrXri4jri6QuXHJcbiAgICAgKiDsp4Dsl7Dsi5ztgqTripQg64+E7KSRIO2BrOq4sOqwgCDri6Tsi5wg67OA6rK965CY7JeI7J2EIOqyveyasCwg7J207KCEIOqyg+ydhCDst6jshoztlZjqs6Ag7KO87Ja07KeEIOyLnOqwhOunjO2BvCDri6Tsi5wg7KeA7Jew7Iuc7YK164uI64ukLlxyXG4gICAgICog7J2066W8IO2Gte2VtCBgcmVzaXplYOqwgCDrhIjrrLQg66eO7J20IO2YuOy2nOuQmOuKlCDqsoPsnYQg67Cp7KeA7ZWY7JesIOyEseuKpeydhCDtlqXsg4Hsi5ztgqwg7IiYIOyeiOyKteuLiOuLpC5cclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWZsaWNraW5nL09wdGlvbnMjcmVzaXplZGVib3VuY2UgcmVzaXplRGVib3VuY2UgKCBPcHRpb25zICl9XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXNpemVEZWJvdW5jZTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwibWF4UmVzaXplRGVib3VuY2VcIiwge1xuICAgIC8qKlxyXG4gICAgICogVGhlIG1heGltdW0gdGltZSBmb3Igc2l6ZSByZWNhbGN1bGF0aW9uIGRlbGF5IHdoZW4gdXNpbmcgYHJlc2l6ZURlYm91bmNlYCwgaW4gbWlsaXNlY29uZC5cclxuICAgICAqIFRoaXMgZ3VhcmFudGVlcyB0aGF0IHNpemUgcmVjYWxjdWxhdGlvbiBpcyBwZXJmb3JtZWQgYXQgbGVhc3Qgb25jZSBldmVyeSAobiltcy5cclxuICAgICAqIEBrbyBgcmVzaXplRGVib3VuY2VgIOyCrOyaqeyLnOyXkCDtgazquLAg7J6s6rOE7IKw7J20IOyngOyXsOuQmOuKlCDstZzrjIAg7Iuc6rCE7J2EIOyngOygle2VqeuLiOuLpC4gKOuLqOychDogbXMpXHJcbiAgICAgKiDsnbTrpbwg7Ya17ZW0LCDsoIHslrTrj4QgKG4pbXPsl5Ag7ZWc67KI7J2AIO2BrOq4sCDsnqzqs4TsgrDsnYQg7IiY7ZaJ7ZWY64qUIOqyg+ydhCDrs7TsnqXtlaAg7IiYIOyeiOyKteuLiOuLpC5cclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCAxMDBcclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2VnanMtZmxpY2tpbmcvT3B0aW9ucyNtYXhyZXNpemVkZWJvdW5jZSBtYXhSZXNpemVEZWJvdW5jZSAoIE9wdGlvbnMgKX1cclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX21heFJlc2l6ZURlYm91bmNlO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJ1c2VGcmFjdGlvbmFsU2l6ZVwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBCeSBlbmFibGluZyB0aGlzLCBGbGlja2luZyB3aWxsIGNhbGN1bGF0ZSBhbGwgaW50ZXJuYWwgc2l6ZSB3aXRoIENTUyB3aWR0aCBjb21wdXRlZCB3aXRoIGdldENvbXB1dGVkU3R5bGUuXHJcbiAgICAgKiBUaGlzIGNhbiBwcmV2ZW50IDFweCBvZmZzZXQgaXNzdWUgaW4gc29tZSBjYXNlcyB3aGVyZSBwYW5lbCBzaXplIGhhcyB0aGUgZnJhY3Rpb25hbCBwYXJ0LlxyXG4gICAgICogQWxsIHNpemVzIHdpbGwgaGF2ZSB0aGUgb3JpZ2luYWwgc2l6ZSBiZWZvcmUgQ1NTIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvdHJhbnNmb3JtIHRyYW5zZm9ybX0gaXMgYXBwbGllZCBvbiB0aGUgZWxlbWVudC5cclxuICAgICAqIEBrbyDsnbQg7Ji17IWY7J2EIO2ZnOyEse2ZlO2VoCDqsr3smrAsIEZsaWNraW5n7J2AIOuCtOu2gOydmCDrqqjrk6Ag7YGs6riw66W8IHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudC9nZXRCb3VuZGluZ0NsaWVudFJlY3QgZ2V0Qm91bmRpbmdDbGllbnRSZWN0feulvCDsnbTsmqntlZjsl6wg6rOE7IKw7ZWp64uI64ukLlxyXG4gICAgICog7J2066W8IO2Gte2VtCwg7Yyo64SQIO2BrOq4sOyXkCDshozsiJjsoJDsnYQg7Y+s7ZWo7ZWgIOqyveyasOyXkCDrsJzsg53tlaAg7IiYIOyeiOuKlCDsnbzrtoAgMXB4IOyYpO2UhOyFiyDsnbTsiojrpbwg7ZW06rKwIOqwgOuKpe2VqeuLiOuLpC5cclxuICAgICAqIOuqqOuToCDtgazquLDripQgQ1NTIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvdHJhbnNmb3JtIHRyYW5zZm9ybX3snbQg7JeY66as66i87Yq47JeQIOyggeyaqeuQmOq4sCDsnbTsoITsnZgg7YGs6riw66W8IOyCrOyaqe2VoCDqsoPsnoXri4jri6QuXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqIEBkZWZhdWx0IGZhbHNlXHJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL25hdmVyLmdpdGh1Yi5pby9lZ2pzLWZsaWNraW5nL09wdGlvbnMjdXNlZnJhY3Rpb25hbHNpemUgdXNlRnJhY3Rpb25hbFNpemUgKCBPcHRpb25zICl9XHJcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl91c2VGcmFjdGlvbmFsU2l6ZTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwiZXh0ZXJuYWxSZW5kZXJlclwiLCB7XG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGlzIGFuIG9wdGlvbiBmb3IgdGhlIGZyYW1ld29ya3MoUmVhY3QsIFZ1ZSwgQW5ndWxhciwgLi4uKS4gRG9uJ3Qgc2V0IGl0IGFzIGl0J3MgYXV0b21hdGljYWxseSBtYW5hZ2VkIGJ5IEZsaWNraW5nLlxyXG4gICAgICogQGtvIO2UhOugiOyehOybjO2BrChSZWFjdCwgVnVlLCBBbmd1bGFyLCAuLi4p7JeQ7ISc66eMIOyCrOyaqe2VmOuKlCDsmLXshZjsnLzroZwsIOyekOuPmeycvOuhnCDshKTsoJXrkJjrr4DroZwg65Sw66GcIOyCrOyaqe2VmOyLpCDtlYTsmpQg7JeG7Iq164uI64ukIVxyXG4gICAgICogQGRlZmF1bHQgbnVsbFxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2V4dGVybmFsUmVuZGVyZXI7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcInJlbmRlckV4dGVybmFsXCIsIHtcbiAgICAvKipcclxuICAgICAqIFRoaXMgaXMgYW4gb3B0aW9uIGZvciB0aGUgZnJhbWV3b3JrcyhSZWFjdCwgVnVlLCBBbmd1bGFyLCAuLi4pLiBEb24ndCBzZXQgaXQgYXMgaXQncyBhdXRvbWF0aWNhbGx5IG1hbmFnZWQgYnkgRmxpY2tpbmcuXHJcbiAgICAgKiBAa28g7ZSE66CI7J6E7JuM7YGsKFJlYWN0LCBWdWUsIEFuZ3VsYXIsIC4uLinsl5DshJzrp4wg7IKs7Jqp7ZWY64qUIOyYteyFmOycvOuhnCwg7J6Q64+Z7Jy866GcIOyEpOygleuQmOuvgOuhnCDrlLDroZwg7IKs7Jqp7ZWY7IukIO2VhOyalCDsl4bsirXri4jri6QhXHJcbiAgICAgKiBAZGVmYXVsdCBudWxsXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQGRlcHJlY2F0ZWRcclxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlckV4dGVybmFsO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICAvKipcclxuICAgKiBJbml0aWFsaXplIEZsaWNraW5nIGFuZCBtb3ZlIHRvIHRoZSBkZWZhdWx0IGluZGV4XHJcbiAgICogVGhpcyBpcyBhdXRvbWF0aWNhbGx5IGNhbGxlZCBvbiBGbGlja2luZydzIGNvbnN0cnVjdG9yIHdoZW4gYGF1dG9Jbml0YCBpcyB0cnVlKGRlZmF1bHQpXHJcbiAgICogQGtvIEZsaWNraW5n7J2EIOy0iOq4sO2ZlO2VmOqzoCwg65SU7Y+07Yq4IOyduOuNseyKpOuhnCDsnbTrj5ntlanri4jri6RcclxuICAgKiDsnbQg66mU7IaM65Oc64qUIGBhdXRvSW5pdGAg7Ji17IWY7J20IHRydWUoZGVmYXVsdCnsnbwg6rK97JqwIEZsaWNraW5n7J20IOyDneyEseuQoCDrlYwg7J6Q64+Z7Jy866GcIO2YuOy2nOuQqeuLiOuLpFxyXG4gICAqIEBmaXJlcyBGbGlja2luZyNyZWFkeVxyXG4gICAqIEByZXR1cm4ge1Byb21pc2U8dm9pZD59XHJcbiAgICovXG4gIF9fcHJvdG8uaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIGlmICh0aGlzLl9pbml0aWFsaXplZCkgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIHZhciBjYW1lcmEgPSB0aGlzLl9jYW1lcmE7XG4gICAgdmFyIHJlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXI7XG4gICAgdmFyIGNvbnRyb2wgPSB0aGlzLl9jb250cm9sO1xuICAgIHZhciB2aXJ0dWFsTWFuYWdlciA9IHRoaXMuX3ZpcnR1YWxNYW5hZ2VyO1xuICAgIHZhciBvcmlnaW5hbFRyaWdnZXIgPSB0aGlzLnRyaWdnZXI7XG4gICAgdmFyIHByZXZlbnRFdmVudHNCZWZvcmVJbml0ID0gdGhpcy5fcHJldmVudEV2ZW50c0JlZm9yZUluaXQ7XG4gICAgY2FtZXJhLmluaXQoKTtcbiAgICB2aXJ0dWFsTWFuYWdlci5pbml0KCk7XG4gICAgcmVuZGVyZXIuaW5pdCh0aGlzKTtcbiAgICBjb250cm9sLmluaXQodGhpcyk7XG4gICAgaWYgKHByZXZlbnRFdmVudHNCZWZvcmVJbml0KSB7XG4gICAgICB0aGlzLnRyaWdnZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgIH07XG4gICAgfVxuICAgIHRoaXMuX2luaXRpYWxSZXNpemUoKTtcbiAgICAvLyBMb29rIGF0IGluaXRpYWwgcGFuZWxcbiAgICB0aGlzLl9tb3ZlVG9Jbml0aWFsUGFuZWwoKTtcbiAgICBpZiAodGhpcy5fYXV0b1Jlc2l6ZSkge1xuICAgICAgdGhpcy5fYXV0b1Jlc2l6ZXIuZW5hYmxlKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9wcmV2ZW50Q2xpY2tPbkRyYWcpIHtcbiAgICAgIGNvbnRyb2wuY29udHJvbGxlci5hZGRQcmV2ZW50Q2xpY2tIYW5kbGVyKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9kaXNhYmxlT25Jbml0KSB7XG4gICAgICB0aGlzLmRpc2FibGVJbnB1dCgpO1xuICAgIH1cbiAgICByZW5kZXJlci5jaGVja1BhbmVsQ29udGVudHNSZWFkeShyZW5kZXJlci5wYW5lbHMpO1xuICAgIHRoaXMuX2luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICByZXR1cm4gcmVuZGVyZXIucmVuZGVyKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBEb25lIGluaXRpYWxpemluZyAmIGVtaXQgcmVhZHkgZXZlbnRcbiAgICAgIF90aGlzLl9wbHVnaW5zLmZvckVhY2goZnVuY3Rpb24gKHBsdWdpbikge1xuICAgICAgICByZXR1cm4gcGx1Z2luLmluaXQoX3RoaXMpO1xuICAgICAgfSk7XG4gICAgICBpZiAocHJldmVudEV2ZW50c0JlZm9yZUluaXQpIHtcbiAgICAgICAgX3RoaXMudHJpZ2dlciA9IG9yaWdpbmFsVHJpZ2dlcjtcbiAgICAgIH1cbiAgICAgIF90aGlzLnRyaWdnZXIobmV3IENvbXBvbmVudEV2ZW50JDEoRVZFTlRTLlJFQURZKSk7XG4gICAgfSk7XG4gIH07XG4gIC8qKlxyXG4gICAqIERlc3Ryb3kgRmxpY2tpbmcgYW5kIHJlbW92ZSBhbGwgZXZlbnQgaGFuZGxlcnNcclxuICAgKiBAa28gRmxpY2tpbmfqs7wg7ZWY7JyEIOy7tO2PrOuEjO2KuOuTpOydhCDstIjquLAg7IOB7YOc66GcIOuQmOuPjOumrOqzoCwg67aA7LCp65CcIOuqqOuToCDsnbTrsqTtirgg7ZW465Ok65+s66W8IOygnOqxsO2VqeuLiOuLpFxyXG4gICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICovXG4gIF9fcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLm9mZigpO1xuICAgIHRoaXMuX2F1dG9SZXNpemVyLmRpc2FibGUoKTtcbiAgICB0aGlzLl9jb250cm9sLmRlc3Ryb3koKTtcbiAgICB0aGlzLl9jYW1lcmEuZGVzdHJveSgpO1xuICAgIHRoaXMuX3JlbmRlcmVyLmRlc3Ryb3koKTtcbiAgICB0aGlzLl9wbHVnaW5zLmZvckVhY2goZnVuY3Rpb24gKHBsdWdpbikge1xuICAgICAgcmV0dXJuIHBsdWdpbi5kZXN0cm95KCk7XG4gICAgfSk7XG4gICAgdGhpcy5faW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgfTtcbiAgLyoqXHJcbiAgICogTW92ZSB0byB0aGUgcHJldmlvdXMgcGFuZWwgKGN1cnJlbnQgaW5kZXggLSAxKVxyXG4gICAqIEBrbyDsnbTsoIQg7Yyo64SQ66GcIOydtOuPme2VqeuLiOuLpCAo7ZiE7J6sIOyduOuNseyKpCAtIDEpXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtkdXJhdGlvbj17QGxpbmsgRmxpY2tpbmcjZHVyYXRpb24gb3B0aW9ucy5kdXJhdGlvbn1dIER1cmF0aW9uIG9mIHRoZSBwYW5lbCBtb3ZlbWVudCBhbmltYXRpb24gKHVuaXQ6IG1zKTxrbz7tjKjrhJAg7J2064+ZIOyVoOuLiOuplOydtOyFmCDsp4Ttlokg7Iuc6rCEICjri6jsnIQ6IG1zKTwva28+XHJcbiAgICogQGFzeW5jXHJcbiAgICogQGZpcmVzIEZsaWNraW5nI21vdmVTdGFydFxyXG4gICAqIEBmaXJlcyBGbGlja2luZyNtb3ZlXHJcbiAgICogQGZpcmVzIEZsaWNraW5nI21vdmVFbmRcclxuICAgKiBAZmlyZXMgRmxpY2tpbmcjd2lsbENoYW5nZVxyXG4gICAqIEBmaXJlcyBGbGlja2luZyNjaGFuZ2VkXHJcbiAgICogQGZpcmVzIEZsaWNraW5nI3dpbGxSZXN0b3JlXHJcbiAgICogQGZpcmVzIEZsaWNraW5nI3Jlc3RvcmVkXHJcbiAgICogQGZpcmVzIEZsaWNraW5nI25lZWRQYW5lbFxyXG4gICAqIEBmaXJlcyBGbGlja2luZyN2aXNpYmxlQ2hhbmdlXHJcbiAgICogQGZpcmVzIEZsaWNraW5nI3JlYWNoRWRnZVxyXG4gICAqIEB0aHJvd3Mge0ZsaWNraW5nRXJyb3J9XHJcbiAgICogfGNvZGV8Y29uZGl0aW9ufFxyXG4gICAqIHwtLS18LS0tfFxyXG4gICAqIHx7QGxpbmsgRVJST1JfQ09ERSBJTkRFWF9PVVRfT0ZfUkFOR0V9fFdoZW4gdGhlIHByZXZpb3VzIHBhbmVsIGRvZXMgbm90IGV4aXN0fFxyXG4gICAqIHx7QGxpbmsgRVJST1JfQ09ERSBBTklNQVRJT05fQUxSRUFEWV9QTEFZSU5HfXxXaGVuIHRoZSBhbmltYXRpb24gaXMgYWxyZWFkeSBwbGF5aW5nfFxyXG4gICAqIHx7QGxpbmsgRVJST1JfQ09ERSBBTklNQVRJT05fSU5URVJSVVBURUR9fFdoZW4gdGhlIGFuaW1hdGlvbiBpcyBpbnRlcnJ1cHRlZCBieSB1c2VyIGlucHV0fFxyXG4gICAqIHx7QGxpbmsgRVJST1JfQ09ERSBTVE9QX0NBTExFRF9CWV9VU0VSfXxXaGVuIHRoZSBhbnkgb2YgdGhlIGV2ZW50J3MgYHN0b3AoKWAgaXMgY2FsbGVkfFxyXG4gICAqIDxrbz5cclxuICAgKlxyXG4gICAqIHxjb2RlfGNvbmRpdGlvbnxcclxuICAgKiB8LS0tfC0tLXxcclxuICAgKiB8e0BsaW5rIEVSUk9SX0NPREUgSU5ERVhfT1VUX09GX1JBTkdFfXzsnbTsoIQg7Yyo64SQ7J20IOyhtOyerO2VmOyngCDslYrsnYQg6rK97JqwfFxyXG4gICAqIHx7QGxpbmsgRVJST1JfQ09ERSBBTklNQVRJT05fQUxSRUFEWV9QTEFZSU5HfXzslaDri4jrqZTsnbTshZjsnbQg7J2066+4IOynhO2WieykkeyduCDqsr3smrB8XHJcbiAgICogfHtAbGluayBFUlJPUl9DT0RFIEFOSU1BVElPTl9JTlRFUlJVUFRFRH187IKs7Jqp7J6QIOyeheugpeyXkCDsnZjtlbQg7JWg64uI66mU7J207IWY7J20IOykkeuLqOuQnCDqsr3smrB8XHJcbiAgICogfHtAbGluayBFUlJPUl9DT0RFIFNUT1BfQ0FMTEVEX0JZX1VTRVJ9fOuwnOyDneuQnCDsnbTrsqTtirjrk6Qg7KSRIO2VmOuCmOudvOuPhCBgc3RvcCgpYOydtCDtmLjstpzrkJwg6rK97JqwfFxyXG4gICAqIDwva28+XHJcbiAgICogQHJldHVybiB7UHJvbWlzZTx2b2lkPn0gQSBQcm9taXNlIHdoaWNoIHdpbGwgYmUgcmVzb2x2ZWQgYWZ0ZXIgcmVhY2hpbmcgdGhlIHByZXZpb3VzIHBhbmVsPGtvPuydtOyghCDtjKjrhJAg64+E64us7Iuc7JeQIHJlc29sdmXrkJjripQgUHJvbWlzZTwva28+XHJcbiAgICovXG4gIF9fcHJvdG8ucHJldiA9IGZ1bmN0aW9uIChkdXJhdGlvbikge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIGlmIChkdXJhdGlvbiA9PT0gdm9pZCAwKSB7XG4gICAgICBkdXJhdGlvbiA9IHRoaXMuX2R1cmF0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5tb3ZlVG8oKF9jID0gKF9iID0gKF9hID0gdGhpcy5fY29udHJvbC5hY3RpdmVQYW5lbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnByZXYoKSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmluZGV4KSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAtMSwgZHVyYXRpb24sIERJUkVDVElPTi5QUkVWKTtcbiAgfTtcbiAgLyoqXHJcbiAgICogTW92ZSB0byB0aGUgbmV4dCBwYW5lbCAoY3VycmVudCBpbmRleCArIDEpXHJcbiAgICogQGtvIOuLpOydjCDtjKjrhJDroZwg7J2064+Z7ZWp64uI64ukICjtmITsnqwg7J24642x7IqkICsgMSlcclxuICAgKiBAcGFyYW0ge251bWJlcn0gW2R1cmF0aW9uPXtAbGluayBGbGlja2luZyNkdXJhdGlvbiBvcHRpb25zLmR1cmF0aW9ufV0gRHVyYXRpb24gb2YgdGhlIHBhbmVsIG1vdmVtZW50IGFuaW1hdGlvbiAodW5pdDogbXMpLjxrbz7tjKjrhJAg7J2064+ZIOyVoOuLiOuplOydtOyFmCDsp4Ttlokg7Iuc6rCEICjri6jsnIQ6IG1zKTwva28+XHJcbiAgICogQGFzeW5jXHJcbiAgICogQGZpcmVzIEZsaWNraW5nI21vdmVTdGFydFxyXG4gICAqIEBmaXJlcyBGbGlja2luZyNtb3ZlXHJcbiAgICogQGZpcmVzIEZsaWNraW5nI21vdmVFbmRcclxuICAgKiBAZmlyZXMgRmxpY2tpbmcjd2lsbENoYW5nZVxyXG4gICAqIEBmaXJlcyBGbGlja2luZyNjaGFuZ2VkXHJcbiAgICogQGZpcmVzIEZsaWNraW5nI3dpbGxSZXN0b3JlXHJcbiAgICogQGZpcmVzIEZsaWNraW5nI3Jlc3RvcmVkXHJcbiAgICogQGZpcmVzIEZsaWNraW5nI25lZWRQYW5lbFxyXG4gICAqIEBmaXJlcyBGbGlja2luZyN2aXNpYmxlQ2hhbmdlXHJcbiAgICogQGZpcmVzIEZsaWNraW5nI3JlYWNoRWRnZVxyXG4gICAqIEB0aHJvd3Mge0ZsaWNraW5nRXJyb3J9XHJcbiAgICogfGNvZGV8Y29uZGl0aW9ufFxyXG4gICAqIHwtLS18LS0tfFxyXG4gICAqIHx7QGxpbmsgRVJST1JfQ09ERSBJTkRFWF9PVVRfT0ZfUkFOR0V9fFdoZW4gdGhlIG5leHQgcGFuZWwgZG9lcyBub3QgZXhpc3R8XHJcbiAgICogfHtAbGluayBFUlJPUl9DT0RFIEFOSU1BVElPTl9BTFJFQURZX1BMQVlJTkd9fFdoZW4gdGhlIGFuaW1hdGlvbiBpcyBhbHJlYWR5IHBsYXlpbmd8XHJcbiAgICogfHtAbGluayBFUlJPUl9DT0RFIEFOSU1BVElPTl9JTlRFUlJVUFRFRH18V2hlbiB0aGUgYW5pbWF0aW9uIGlzIGludGVycnVwdGVkIGJ5IHVzZXIgaW5wdXR8XHJcbiAgICogfHtAbGluayBFUlJPUl9DT0RFIFNUT1BfQ0FMTEVEX0JZX1VTRVJ9fFdoZW4gdGhlIGFueSBvZiB0aGUgZXZlbnQncyBgc3RvcCgpYCBpcyBjYWxsZWR8XHJcbiAgICogPGtvPlxyXG4gICAqXHJcbiAgICogfGNvZGV8Y29uZGl0aW9ufFxyXG4gICAqIHwtLS18LS0tfFxyXG4gICAqIHx7QGxpbmsgRVJST1JfQ09ERSBJTkRFWF9PVVRfT0ZfUkFOR0V9fOuLpOydjCDtjKjrhJDsnbQg7KG07J6s7ZWY7KeAIOyViuydhCDqsr3smrB8XHJcbiAgICogfHtAbGluayBFUlJPUl9DT0RFIEFOSU1BVElPTl9BTFJFQURZX1BMQVlJTkd9fOyVoOuLiOuplOydtOyFmOydtCDsnbTrr7gg7KeE7ZaJ7KSR7J24IOqyveyasHxcclxuICAgKiB8e0BsaW5rIEVSUk9SX0NPREUgQU5JTUFUSU9OX0lOVEVSUlVQVEVEfXzsgqzsmqnsnpAg7J6F66Cl7JeQIOydmO2VtCDslaDri4jrqZTsnbTshZjsnbQg7KSR64uo65CcIOqyveyasHxcclxuICAgKiB8e0BsaW5rIEVSUk9SX0NPREUgU1RPUF9DQUxMRURfQllfVVNFUn1867Cc7IOd65CcIOydtOuypO2KuOuTpCDspJEg7ZWY64KY652864+EIGBzdG9wKClg7J20IO2YuOy2nOuQnCDqsr3smrB8XHJcbiAgICpcclxuICAgKiA8L2tvPlxyXG4gICAqIEByZXR1cm4ge1Byb21pc2U8dm9pZD59IEEgUHJvbWlzZSB3aGljaCB3aWxsIGJlIHJlc29sdmVkIGFmdGVyIHJlYWNoaW5nIHRoZSBuZXh0IHBhbmVsPGtvPuuLpOydjCDtjKjrhJAg64+E64us7Iuc7JeQIHJlc29sdmXrkJjripQgUHJvbWlzZTwva28+XHJcbiAgICovXG4gIF9fcHJvdG8ubmV4dCA9IGZ1bmN0aW9uIChkdXJhdGlvbikge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIGlmIChkdXJhdGlvbiA9PT0gdm9pZCAwKSB7XG4gICAgICBkdXJhdGlvbiA9IHRoaXMuX2R1cmF0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5tb3ZlVG8oKF9jID0gKF9iID0gKF9hID0gdGhpcy5fY29udHJvbC5hY3RpdmVQYW5lbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5leHQoKSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmluZGV4KSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiB0aGlzLl9yZW5kZXJlci5wYW5lbENvdW50LCBkdXJhdGlvbiwgRElSRUNUSU9OLk5FWFQpO1xuICB9O1xuICAvKipcclxuICAgKiBNb3ZlIHRvIHRoZSBwYW5lbCB3aXRoIGdpdmVuIGluZGV4XHJcbiAgICogQGtvIOyjvOyWtOynhCDsnbjrjbHsiqTsl5Ag7ZW064u57ZWY64qUIO2MqOuEkOuhnCDsnbTrj5ntlanri4jri6RcclxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBwYW5lbCB0byBtb3ZlPGtvPuydtOuPme2VoCDtjKjrhJDsnZgg7J24642x7IqkPC9rbz5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gW2R1cmF0aW9uPXtAbGluayBGbGlja2luZyNkdXJhdGlvbiBvcHRpb25zLmR1cmF0aW9ufV0gRHVyYXRpb24gb2YgdGhlIGFuaW1hdGlvbiAodW5pdDogbXMpPGtvPuyVoOuLiOuplOydtOyFmCDsp4Ttlokg7Iuc6rCEICjri6jsnIQ6IG1zKTwva28+XHJcbiAgICogQHBhcmFtIHtESVJFQ1RJT059IFtkaXJlY3Rpb249RElSRUNUSU9OLk5PTkVdIERpcmVjdGlvbiB0byBtb3ZlLCBvbmx5IGF2YWlsYWJsZSBpbiB0aGUge0BsaW5rIEZsaWNraW5nI2NpcmN1bGFyIGNpcmN1bGFyfSBtb2RlPGtvPuydtOuPme2VoCDrsKntlqUuIHtAbGluayBGbGlja2luZyNjaXJjdWxhciBjaXJjdWxhcn0g7Ji17IWYIO2ZnOyEse2ZlOyLnOyXkOunjCDsgqzsmqkg6rCA64ql7ZWp64uI64ukPC9rbz5cclxuICAgKiBAYXN5bmNcclxuICAgKiBAZmlyZXMgRmxpY2tpbmcjbW92ZVN0YXJ0XHJcbiAgICogQGZpcmVzIEZsaWNraW5nI21vdmVcclxuICAgKiBAZmlyZXMgRmxpY2tpbmcjbW92ZUVuZFxyXG4gICAqIEBmaXJlcyBGbGlja2luZyN3aWxsQ2hhbmdlXHJcbiAgICogQGZpcmVzIEZsaWNraW5nI2NoYW5nZWRcclxuICAgKiBAZmlyZXMgRmxpY2tpbmcjd2lsbFJlc3RvcmVcclxuICAgKiBAZmlyZXMgRmxpY2tpbmcjcmVzdG9yZWRcclxuICAgKiBAZmlyZXMgRmxpY2tpbmcjbmVlZFBhbmVsXHJcbiAgICogQGZpcmVzIEZsaWNraW5nI3Zpc2libGVDaGFuZ2VcclxuICAgKiBAZmlyZXMgRmxpY2tpbmcjcmVhY2hFZGdlXHJcbiAgICogQHRocm93cyB7RmxpY2tpbmdFcnJvcn1cclxuICAgKiB8Y29kZXxjb25kaXRpb258XHJcbiAgICogfC0tLXwtLS18XHJcbiAgICogfHtAbGluayBFUlJPUl9DT0RFIElOREVYX09VVF9PRl9SQU5HRX18V2hlbiB0aGUgcm9vdCBpcyBub3QgZWl0aGVyIHN0cmluZyBvciBIVE1MRWxlbWVudHxcclxuICAgKiB8e0BsaW5rIEVSUk9SX0NPREUgQU5JTUFUSU9OX0FMUkVBRFlfUExBWUlOR318V2hlbiB0aGUgYW5pbWF0aW9uIGlzIGFscmVhZHkgcGxheWluZ3xcclxuICAgKiB8e0BsaW5rIEVSUk9SX0NPREUgQU5JTUFUSU9OX0lOVEVSUlVQVEVEfXxXaGVuIHRoZSBhbmltYXRpb24gaXMgaW50ZXJydXB0ZWQgYnkgdXNlciBpbnB1dHxcclxuICAgKiB8e0BsaW5rIEVSUk9SX0NPREUgU1RPUF9DQUxMRURfQllfVVNFUn18V2hlbiB0aGUgYW55IG9mIHRoZSBldmVudCdzIGBzdG9wKClgIGlzIGNhbGxlZHxcclxuICAgKiA8a28+XHJcbiAgICpcclxuICAgKiB8Y29kZXxjb25kaXRpb258XHJcbiAgICogfC0tLXwtLS18XHJcbiAgICogfHtAbGluayBFUlJPUl9DT0RFIElOREVYX09VVF9PRl9SQU5HRX187ZW064u5IOyduOuNseyKpOulvCDqsIDsp4Qg7Yyo64SQ7J20IOyhtOyerO2VmOyngCDslYrsnYQg6rK97JqwfFxyXG4gICAqIHx7QGxpbmsgRVJST1JfQ09ERSBBTklNQVRJT05fQUxSRUFEWV9QTEFZSU5HfXzslaDri4jrqZTsnbTshZjsnbQg7J2066+4IOynhO2WieykkeyduCDqsr3smrB8XHJcbiAgICogfHtAbGluayBFUlJPUl9DT0RFIEFOSU1BVElPTl9JTlRFUlJVUFRFRH187IKs7Jqp7J6QIOyeheugpeyXkCDsnZjtlbQg7JWg64uI66mU7J207IWY7J20IOykkeuLqOuQnCDqsr3smrB8XHJcbiAgICogfHtAbGluayBFUlJPUl9DT0RFIFNUT1BfQ0FMTEVEX0JZX1VTRVJ9fOuwnOyDneuQnCDsnbTrsqTtirjrk6Qg7KSRIO2VmOuCmOudvOuPhCBgc3RvcCgpYOydtCDtmLjstpzrkJwg6rK97JqwfFxyXG4gICAqXHJcbiAgICogPC9rbz5cclxuICAgKiBAcmV0dXJuIHtQcm9taXNlPHZvaWQ+fSBBIFByb21pc2Ugd2hpY2ggd2lsbCBiZSByZXNvbHZlZCBhZnRlciByZWFjaGluZyB0aGUgdGFyZ2V0IHBhbmVsPGtvPu2VtOuLuSDtjKjrhJAg64+E64us7Iuc7JeQIHJlc29sdmXrkJjripQgUHJvbWlzZTwva28+XHJcbiAgICovXG4gIF9fcHJvdG8ubW92ZVRvID0gZnVuY3Rpb24gKGluZGV4LCBkdXJhdGlvbiwgZGlyZWN0aW9uKSB7XG4gICAgaWYgKGR1cmF0aW9uID09PSB2b2lkIDApIHtcbiAgICAgIGR1cmF0aW9uID0gdGhpcy5fZHVyYXRpb247XG4gICAgfVxuICAgIGlmIChkaXJlY3Rpb24gPT09IHZvaWQgMCkge1xuICAgICAgZGlyZWN0aW9uID0gRElSRUNUSU9OLk5PTkU7XG4gICAgfVxuICAgIHZhciByZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVyO1xuICAgIHZhciBwYW5lbENvdW50ID0gcmVuZGVyZXIucGFuZWxDb3VudDtcbiAgICB2YXIgcGFuZWwgPSByZW5kZXJlci5nZXRQYW5lbChpbmRleCk7XG4gICAgaWYgKCFwYW5lbCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBGbGlja2luZ0Vycm9yKE1FU1NBR0UuSU5ERVhfT1VUX09GX1JBTkdFKGluZGV4LCAwLCBwYW5lbENvdW50IC0gMSksIENPREUuSU5ERVhfT1VUX09GX1JBTkdFKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9jb250cm9sLmFuaW1hdGluZykge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBGbGlja2luZ0Vycm9yKE1FU1NBR0UuQU5JTUFUSU9OX0FMUkVBRFlfUExBWUlORywgQ09ERS5BTklNQVRJT05fQUxSRUFEWV9QTEFZSU5HKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9jb250cm9sLmhvbGRpbmcpIHtcbiAgICAgIHRoaXMuX2NvbnRyb2wuY29udHJvbGxlci5yZWxlYXNlKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jb250cm9sLm1vdmVUb1BhbmVsKHBhbmVsLCB7XG4gICAgICBkdXJhdGlvbjogZHVyYXRpb24sXG4gICAgICBkaXJlY3Rpb246IGRpcmVjdGlvblxuICAgIH0pO1xuICB9O1xuICAvKipcclxuICAgKiBDaGFuZ2UgdGhlIGRlc3RpbmF0aW9uIGFuZCBkdXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uIGN1cnJlbnRseSBwbGF5aW5nXHJcbiAgICogQGtvIOyerOyDnSDspJHsnbgg7JWg64uI66mU7J207IWY7J2YIOuqqeyggeyngOyZgCDsnqzsg50g7Iuc6rCE7J2EIOuzgOqyve2VqeuLiOuLpFxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIHBhbmVsIHRvIG1vdmU8a28+7J2064+Z7ZWgIO2MqOuEkOydmCDsnbjrjbHsiqQ8L2tvPlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkdXJhdGlvbiBEdXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uICh1bml0OiBtcyk8a28+7JWg64uI66mU7J207IWYIOynhO2WiSDsi5zqsIQgKOuLqOychDogbXMpPC9rbz5cclxuICAgKiBAcGFyYW0ge0RJUkVDVElPTn0gZGlyZWN0aW9uIERpcmVjdGlvbiB0byBtb3ZlLCBvbmx5IGF2YWlsYWJsZSBpbiB0aGUge0BsaW5rIEZsaWNraW5nI2NpcmN1bGFyIGNpcmN1bGFyfSBtb2RlPGtvPuydtOuPme2VoCDrsKntlqUuIHtAbGluayBGbGlja2luZyNjaXJjdWxhciBjaXJjdWxhcn0g7Ji17IWYIO2ZnOyEse2ZlOyLnOyXkOunjCDsgqzsmqkg6rCA64ql7ZWp64uI64ukPC9rbz5cclxuICAgKiBAdGhyb3dzIHtGbGlja2luZ0Vycm9yfVxyXG4gICAqIHtAbGluayBFUlJPUl9DT0RFIElOREVYX09VVF9PRl9SQU5HRX0gV2hlbiB0aGUgcm9vdCBpcyBub3QgZWl0aGVyIHN0cmluZyBvciBIVE1MRWxlbWVudFxyXG4gICAqIDxrbz57QGxpbmsgRVJST1JfQ09ERSBJTkRFWF9PVVRfT0ZfUkFOR0V9IO2VtOuLuSDsnbjrjbHsiqTrpbwg6rCA7KeEIO2MqOuEkOydtCDsobTsnqztlZjsp4Ag7JWK7J2EIOqyveyasDwva28+XHJcbiAgICogQHJldHVybiB7dm9pZH1cclxuICAgKi9cbiAgX19wcm90by51cGRhdGVBbmltYXRpb24gPSBmdW5jdGlvbiAoaW5kZXgsIGR1cmF0aW9uLCBkaXJlY3Rpb24pIHtcbiAgICBpZiAoIXRoaXMuX2NvbnRyb2wuYW5pbWF0aW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciByZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVyO1xuICAgIHZhciBwYW5lbENvdW50ID0gcmVuZGVyZXIucGFuZWxDb3VudDtcbiAgICB2YXIgcGFuZWwgPSByZW5kZXJlci5nZXRQYW5lbChpbmRleCk7XG4gICAgaWYgKCFwYW5lbCkge1xuICAgICAgdGhyb3cgbmV3IEZsaWNraW5nRXJyb3IoTUVTU0FHRS5JTkRFWF9PVVRfT0ZfUkFOR0UoaW5kZXgsIDAsIHBhbmVsQ291bnQgLSAxKSwgQ09ERS5JTkRFWF9PVVRfT0ZfUkFOR0UpO1xuICAgIH1cbiAgICB0aGlzLl9jb250cm9sLnVwZGF0ZUFuaW1hdGlvbihwYW5lbCwgZHVyYXRpb24sIGRpcmVjdGlvbik7XG4gIH07XG4gIC8qKlxyXG4gICAqIFN0b3BzIHRoZSBhbmltYXRpb24gY3VycmVudGx5IHBsYXlpbmdcclxuICAgKiBAa28g7J6s7IOdIOykkeyduCDslaDri4jrqZTsnbTshZjsnYQg7KSR64uo7Iuc7YK164uI64ukXHJcbiAgICogQGZpcmVzIEZsaWNraW5nI21vdmVFbmRcclxuICAgKiBAcmV0dXJuIHt2b2lkfVxyXG4gICAqL1xuICBfX3Byb3RvLnN0b3BBbmltYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLl9jb250cm9sLmFuaW1hdGluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9jb250cm9sLnN0b3BBbmltYXRpb24oKTtcbiAgfTtcbiAgLyoqXHJcbiAgICogUmV0dXJuIHRoZSB7QGxpbmsgUGFuZWx9IGF0IHRoZSBnaXZlbiBpbmRleC4gYG51bGxgIGlmIGl0IGRvZXNuJ3QgZXhpc3RzLlxyXG4gICAqIEBrbyDso7zslrTsp4Qg7J24642x7Iqk7JeQIO2VtOuLue2VmOuKlCB7QGxpbmsgUGFuZWx97J2EIOuwmO2ZmO2VqeuLiOuLpC4g7KO87Ja07KeEIOyduOuNseyKpOyXkCDtlbTri7ntlZjripQg7Yyo64SQ7J20IOyhtOyerO2VmOyngCDslYrsnYQg6rK97JqwIGBudWxsYOydhCDrsJjtmZjtlanri4jri6QuXHJcbiAgICogQHJldHVybiB7UGFuZWwgfCBudWxsfSBQYW5lbCBhdCB0aGUgZ2l2ZW4gaW5kZXg8a28+7KO87Ja07KeEIOyduOuNseyKpOyXkCDtlbTri7ntlZjripQg7Yyo64SQPC9rbz5cclxuICAgKiBAc2VlIFBhbmVsXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBgYGB0c1xyXG4gICAqIGNvbnN0IHBhbmVsID0gZmxpY2tpbmcuZ2V0UGFuZWwoMCk7XHJcbiAgICogLy8gV2hpY2ggaXMgYSBzaG9ydGhhbmQgdG8uLi5cclxuICAgKiBjb25zdCBzYW1lUGFuZWwgPSBmbGlja2luZy5wYW5lbHNbMF07XHJcbiAgICogYGBgXHJcbiAgICovXG4gIF9fcHJvdG8uZ2V0UGFuZWwgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVuZGVyZXIuZ2V0UGFuZWwoaW5kZXgpO1xuICB9O1xuICAvKipcclxuICAgKiBFbmFibGUgaW5wdXQgZnJvbSB0aGUgdXNlciAobW91c2UvdG91Y2gpXHJcbiAgICogQGtvIOyCrOyaqeyekOydmCDsnoXroKUo66eI7Jqw7IqkL+2EsOy5mCnrpbwg7Zmc7ISx7ZmU7ZWp64uI64ukXHJcbiAgICogQHJldHVybiB7dGhpc31cclxuICAgKi9cbiAgX19wcm90by5lbmFibGVJbnB1dCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9jb250cm9sLmVuYWJsZSgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcclxuICAgKiBEaXNhYmxlIGlucHV0IGZyb20gdGhlIHVzZXIgKG1vdXNlL3RvdWNoKVxyXG4gICAqIEBrbyDsgqzsmqnsnpDsnZgg7J6F66ClKOuniOyasOyKpC/thLDsuZgp66W8IOunieyKteuLiOuLpFxyXG4gICAqIEByZXR1cm4ge3RoaXN9XHJcbiAgICovXG4gIF9fcHJvdG8uZGlzYWJsZUlucHV0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2NvbnRyb2wuZGlzYWJsZSgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcclxuICAgKiBHZXQgY3VycmVudCBmbGlja2luZyBzdGF0dXMuIFlvdSBjYW4gcmVzdG9yZSBjdXJyZW50IHN0YXRlIGJ5IGdpdmluZyByZXR1cm5lZCB2YWx1ZSB0byB7QGxpbmsgRmxpY2tpbmcjc2V0U3RhdHVzIHNldFN0YXR1cygpfVxyXG4gICAqIEBrbyDtmITsnqwg7IOB7YOc66W8IOuwmO2ZmO2VqeuLiOuLpC4g67CY7ZmY67Cb7J2AIOqwkuydhCB7QGxpbmsgRmxpY2tpbmcjc2V0U3RhdHVzIHNldFN0YXR1cygpfSDrqZTshozrk5zsnZgg7J247J6Q66GcIOyngOygle2VmOuptCDtmITsnqwg7IOB7YOc66W8IOuzteybkO2VoCDsiJgg7J6I7Iq164uI64ukXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgU3RhdHVzIHJldHJpZXZpbmcgb3B0aW9uczxrbz5TdGF0dXMg67CY7ZmYIOyYteyFmDwva28+XHJcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5pbmRleD10cnVlXSBJbmNsdWRlIGN1cnJlbnQgcGFuZWwgaW5kZXggdG8gdGhlIHJldHVybmluZyBzdGF0dXMuIENhbWVyYSB3aWxsIGF1dG9tYXRpY2FsbHkgbW92ZSB0byB0aGUgZ2l2ZW4gaW5kZXggd2hlbiB0aGUge0BsaW5rIEZsaWNraW5nI3NldFN0YXR1cyBzZXRTdGF0dXN9IGlzIGNhbGxlZDxrbz7tmITsnqwg7Yyo64SQIOyduOuNseyKpOulvCDrsJjtmZjqsJLsl5Ag7Y+s7ZWo7Iuc7YK164uI64ukLiB7QGxpbmsgRmxpY2tpbmcjc2V0U3RhdHVzIHNldFN0YXR1c30g7Zi47Lac7IucIOyekOuPmeycvOuhnCDtlbTri7kg7J24642x7Iqk66GcIOy5tOuplOudvOulvCDsm4Dsp4HsnoXri4jri6Q8L2tvPlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucG9zaXRpb249dHJ1ZV0gSW5jbHVkZSBjYW1lcmEgcG9zaXRpb24gdG8gdGhlIHJldHVybmluZyBzdGF0dXMuIFRoaXMgd29ya3Mgb25seSB3aGVuIHRoZSB7QGxpbmsgRmxpY2tpbmcjbW92ZVR5cGUgbW92ZVR5cGV9IGlzIGBmcmVlU2Nyb2xsYDxrbz7subTrqZTrnbzsnZgg7ZiE7J6sIOychOy5mOulvCDrsJjtmZjqsJLsl5Ag7Y+s7ZWo7Iuc7YK164uI64ukLiDsnbQg7Ji17IWY7J2AIHtAbGluayBGbGlja2luZyNtb3ZlVHlwZSBtb3ZlVHlwZX3snbQgYGZyZWVTY3JvbGxg7J28IOqyveyasOyXkOunjCDrj5nsnpHtlanri4jri6Q8L2tvPlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuaW5jbHVkZVBhbmVsSFRNTD1mYWxzZV0gSW5jbHVkZSBwYW5lbCdzIGBvdXRlckhUTUxgIHRvIHRoZSByZXR1cm5pbmcgc3RhdHVzPGtvPu2MqOuEkOydmCBgb3V0ZXJIVE1MYOydhCDrsJjtmZjqsJLsl5Ag7Y+s7ZWo7Iuc7YK164uI64ukPC9rbz5cclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnZpc2libGVQYW5lbHNPbmx5PWZhbHNlXSBJbmNsdWRlIG9ubHkge0BsaW5rIEZsaWNraW5nI3Zpc2libGVQYW5lbCB2aXNpYmxlUGFuZWx9J3MgSFRNTC4gVGhpcyBvcHRpb24gaXMgYXZhaWxhYmxlIG9ubHkgd2hlbiB0aGUgYGluY2x1ZGVQYW5lbEhUTUxgIGlzIHRydWVcclxuICAgKiA8a28+7ZiE7J6sIOuztOydtOuKlCDtjKjrhJAoe0BsaW5rIEZsaWNraW5nI3Zpc2libGVQYW5lbCB2aXNpYmxlUGFuZWx9KeydmCBIVE1M66eMIOuwmO2ZmO2VqeuLiOuLpC4gYGluY2x1ZGVQYW5lbEhUTUxg7J20IGB0cnVlYOydvCDqsr3smrDsl5Drp4wg64+Z7J6R7ZWp64uI64ukLjwva28+XHJcbiAgICogQHJldHVybiB7U3RhdHVzfSBBbiBvYmplY3Qgd2l0aCBjdXJyZW50IHN0YXR1cyB2YWx1ZSBpbmZvcm1hdGlvbjxrbz7tmITsnqwg7IOB7YOc6rCSIOygleuztOulvCDqsIDsp4Qg6rCd7LK0Ljwva28+XHJcbiAgICovXG4gIF9fcHJvdG8uZ2V0U3RhdHVzID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIF9iLCBfYztcbiAgICB2YXIgX2QgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSxcbiAgICAgIF9lID0gX2QuaW5kZXgsXG4gICAgICBpbmRleCA9IF9lID09PSB2b2lkIDAgPyB0cnVlIDogX2UsXG4gICAgICBfZiA9IF9kLnBvc2l0aW9uLFxuICAgICAgcG9zaXRpb24gPSBfZiA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9mLFxuICAgICAgX2cgPSBfZC5pbmNsdWRlUGFuZWxIVE1MLFxuICAgICAgaW5jbHVkZVBhbmVsSFRNTCA9IF9nID09PSB2b2lkIDAgPyBmYWxzZSA6IF9nLFxuICAgICAgX2ggPSBfZC52aXNpYmxlUGFuZWxzT25seSxcbiAgICAgIHZpc2libGVQYW5lbHNPbmx5ID0gX2ggPT09IHZvaWQgMCA/IGZhbHNlIDogX2g7XG4gICAgdmFyIGNhbWVyYSA9IHRoaXMuX2NhbWVyYTtcbiAgICB2YXIgcGFuZWxzID0gdmlzaWJsZVBhbmVsc09ubHkgPyB0aGlzLnZpc2libGVQYW5lbHMgOiB0aGlzLnBhbmVscztcbiAgICB2YXIgc3RhdHVzID0ge1xuICAgICAgcGFuZWxzOiBwYW5lbHMubWFwKGZ1bmN0aW9uIChwYW5lbCkge1xuICAgICAgICB2YXIgcGFuZWxJbmZvID0ge1xuICAgICAgICAgIGluZGV4OiBwYW5lbC5pbmRleFxuICAgICAgICB9O1xuICAgICAgICBpZiAoaW5jbHVkZVBhbmVsSFRNTCkge1xuICAgICAgICAgIHBhbmVsSW5mby5odG1sID0gcGFuZWwuZWxlbWVudC5vdXRlckhUTUw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhbmVsSW5mbztcbiAgICAgIH0pXG4gICAgfTtcbiAgICBpZiAoaW5kZXgpIHtcbiAgICAgIHN0YXR1cy5pbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgfVxuICAgIGlmIChwb3NpdGlvbikge1xuICAgICAgdmFyIG5lYXJlc3RBbmNob3IgPSBjYW1lcmEuZmluZE5lYXJlc3RBbmNob3IoY2FtZXJhLnBvc2l0aW9uKTtcbiAgICAgIGlmIChuZWFyZXN0QW5jaG9yKSB7XG4gICAgICAgIHN0YXR1cy5wb3NpdGlvbiA9IHtcbiAgICAgICAgICBwYW5lbDogbmVhcmVzdEFuY2hvci5wYW5lbC5pbmRleCxcbiAgICAgICAgICBwcm9ncmVzc0luUGFuZWw6IGNhbWVyYS5nZXRQcm9ncmVzc0luUGFuZWwobmVhcmVzdEFuY2hvci5wYW5lbClcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHZpc2libGVQYW5lbHNPbmx5KSB7XG4gICAgICB2YXIgdmlzaWJsZVBhbmVscyA9IHRoaXMudmlzaWJsZVBhbmVscztcbiAgICAgIHN0YXR1cy52aXNpYmxlT2Zmc2V0ID0gKF9jID0gKF9iID0gdmlzaWJsZVBhbmVsc1swXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmluZGV4KSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAwO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdHVzO1xuICB9O1xuICAvKipcclxuICAgKiBSZXN0b3JlIHRvIHRoZSBzdGF0ZSBvZiB0aGUgZ2l2ZW4ge0BsaW5rIFN0YXR1c31cclxuICAgKiBAa28g7KO87Ja07KeEIHtAbGluayBTdGF0dXN97J2YIOyDge2DnOuhnCDrs7Xsm5Dtlanri4jri6RcclxuICAgKiBAcGFyYW0ge1BhcnRpYWw8U3RhdHVzPn0gc3RhdHVzIFN0YXR1cyB2YWx1ZSB0byBiZSByZXN0b3JlZC4gWW91IHNob3VsZCB1c2UgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUge0BsaW5rIEZsaWNraW5nI2dldFN0YXR1cyBnZXRTdGF0dXMoKX0gbWV0aG9kPGtvPuuzteybkO2VoCDsg4Htg5wg6rCSLiB7QGxpbmsgRmxpY2tpbmcjZ2V0U3RhdHVzIGdldFN0YXR1cygpfSDrqZTshJzrk5zsnZgg67CY7ZmY6rCS7J2EIOyngOygle2VmOuptCDrkKnri4jri6Q8L2tvPlxyXG4gICAqIEByZXR1cm4ge3ZvaWR9XHJcbiAgICovXG4gIF9fcHJvdG8uc2V0U3RhdHVzID0gZnVuY3Rpb24gKHN0YXR1cykge1xuICAgIHZhciBfYTtcbiAgICBpZiAoIXRoaXMuX2luaXRpYWxpemVkKSB7XG4gICAgICB0aHJvdyBuZXcgRmxpY2tpbmdFcnJvcihNRVNTQUdFLk5PVF9JTklUSUFMSVpFRCwgQ09ERS5OT1RfSU5JVElBTElaRUQpO1xuICAgIH1cbiAgICB2YXIgaW5kZXggPSBzdGF0dXMuaW5kZXgsXG4gICAgICBwb3NpdGlvbiA9IHN0YXR1cy5wb3NpdGlvbixcbiAgICAgIHZpc2libGVPZmZzZXQgPSBzdGF0dXMudmlzaWJsZU9mZnNldCxcbiAgICAgIHBhbmVscyA9IHN0YXR1cy5wYW5lbHM7XG4gICAgdmFyIHJlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXI7XG4gICAgdmFyIGNvbnRyb2wgPSB0aGlzLl9jb250cm9sO1xuICAgIC8vIENhbid0IGFkZC9yZW1vdmUgcGFuZWxzIG9uIGV4dGVybmFsIHJlbmRlcmluZ1xuICAgIGlmICgoKF9hID0gcGFuZWxzWzBdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHRtbCkgJiYgIXRoaXMuX3JlbmRlckV4dGVybmFsKSB7XG4gICAgICByZW5kZXJlci5iYXRjaFJlbW92ZSh7XG4gICAgICAgIGluZGV4OiAwLFxuICAgICAgICBkZWxldGVDb3VudDogdGhpcy5wYW5lbHMubGVuZ3RoLFxuICAgICAgICBoYXNET01JbkVsZW1lbnRzOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHJlbmRlcmVyLmJhdGNoSW5zZXJ0KHtcbiAgICAgICAgaW5kZXg6IDAsXG4gICAgICAgIGVsZW1lbnRzOiBwYXJzZUVsZW1lbnQocGFuZWxzLm1hcChmdW5jdGlvbiAocGFuZWwpIHtcbiAgICAgICAgICByZXR1cm4gcGFuZWwuaHRtbDtcbiAgICAgICAgfSkpLFxuICAgICAgICBoYXNET01JbkVsZW1lbnRzOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGluZGV4ICE9IG51bGwpIHtcbiAgICAgIHZhciBwYW5lbEluZGV4ID0gdmlzaWJsZU9mZnNldCA/IGluZGV4IC0gdmlzaWJsZU9mZnNldCA6IGluZGV4O1xuICAgICAgdm9pZCB0aGlzLm1vdmVUbyhwYW5lbEluZGV4LCAwKS5jYXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHBvc2l0aW9uICYmIHRoaXMuX21vdmVUeXBlID09PSBNT1ZFX1RZUEUuRlJFRV9TQ1JPTEwpIHtcbiAgICAgIHZhciBwYW5lbCA9IHBvc2l0aW9uLnBhbmVsLFxuICAgICAgICBwcm9ncmVzc0luUGFuZWwgPSBwb3NpdGlvbi5wcm9ncmVzc0luUGFuZWw7XG4gICAgICB2YXIgcGFuZWxJbmRleCA9IHZpc2libGVPZmZzZXQgPyBwYW5lbCAtIHZpc2libGVPZmZzZXQgOiBwYW5lbDtcbiAgICAgIHZhciBwYW5lbFJhbmdlID0gcmVuZGVyZXIucGFuZWxzW3BhbmVsSW5kZXhdLnJhbmdlO1xuICAgICAgdmFyIG5ld0NhbWVyYVBvcyA9IHBhbmVsUmFuZ2UubWluICsgKHBhbmVsUmFuZ2UubWF4IC0gcGFuZWxSYW5nZS5taW4pICogcHJvZ3Jlc3NJblBhbmVsO1xuICAgICAgdm9pZCBjb250cm9sLm1vdmVUb1Bvc2l0aW9uKG5ld0NhbWVyYVBvcywgMCkuY2F0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICAvKipcclxuICAgKiBBZGQgcGx1Z2lucyB0aGF0IGNhbiBoYXZlIGRpZmZlcmVudCBlZmZlY3RzIG9uIEZsaWNraW5nXHJcbiAgICogQGtvIO2UjOumrO2CueyXkCDri6TslpHtlZwg7Zqo6rO866W8IOu2gOyXrO2VoCDsiJgg7J6I64qUIO2UjOufrOq3uOyduOydhCDstpTqsIDtlanri4jri6RcclxuICAgKiBAcGFyYW0gey4uLlBsdWdpbn0gcGx1Z2lucyBUaGUgcGx1Z2luKHMpIHRvIGFkZDxrbz7stpTqsIDtlaAg7ZSM65+s6re47J24KOuTpCk8L2tvPlxyXG4gICAqIEByZXR1cm4ge3RoaXN9XHJcbiAgICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vbmF2ZXIvZWdqcy1mbGlja2luZy1wbHVnaW5zXHJcbiAgICovXG4gIF9fcHJvdG8uYWRkUGx1Z2lucyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX2E7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB2YXIgcGx1Z2lucyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICBwbHVnaW5zW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIGlmICh0aGlzLl9pbml0aWFsaXplZCkge1xuICAgICAgcGx1Z2lucy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtLmluaXQoX3RoaXMpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIChfYSA9IHRoaXMuX3BsdWdpbnMpLnB1c2guYXBwbHkoX2EsIF9fc3ByZWFkJDEocGx1Z2lucykpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcclxuICAgKiBSZW1vdmUgcGx1Z2lucyBmcm9tIEZsaWNraW5nLlxyXG4gICAqIEBrbyDtlIzrpqztgrnsnLzroZzrtoDthLAg7ZSM65+s6re47J2465Ok7J2EIOygnOqxsO2VqeuLiOuLpC5cclxuICAgKiBAcGFyYW0gey4uLlBsdWdpbn0gcGx1Z2luIFRoZSBwbHVnaW4ocykgdG8gcmVtb3ZlLjxrbz7soJzqsbAg7ZSM65+s6re47J24KOuTpCkuPC9rbz5cclxuICAgKiBAcmV0dXJuIHt0aGlzfVxyXG4gICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL25hdmVyL2VnanMtZmxpY2tpbmctcGx1Z2luc1xyXG4gICAqL1xuICBfX3Byb3RvLnJlbW92ZVBsdWdpbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB2YXIgcGx1Z2lucyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICBwbHVnaW5zW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHBsdWdpbnMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgdmFyIGZvdW5kSW5kZXggPSBmaW5kSW5kZXgoX3RoaXMuX3BsdWdpbnMsIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHZhbCA9PT0gaXRlbTtcbiAgICAgIH0pO1xuICAgICAgaWYgKGZvdW5kSW5kZXggPj0gMCkge1xuICAgICAgICBpdGVtLmRlc3Ryb3koKTtcbiAgICAgICAgX3RoaXMuX3BsdWdpbnMuc3BsaWNlKGZvdW5kSW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcclxuICAgKiBVcGRhdGUgdmlld3BvcnQvcGFuZWwgc2l6ZXNcclxuICAgKiBAa28g7Yyo64SQIOuwjyDrt7Dtj6ztirjsnZgg7YGs6riw66W8IOqwseyLoO2VqeuLiOuLpFxyXG4gICAqIEBtZXRob2RcclxuICAgKiBAZmlyZXMgRmxpY2tpbmcjYmVmb3JlUmVzaXplXHJcbiAgICogQGZpcmVzIEZsaWNraW5nI2FmdGVyUmVzaXplXHJcbiAgICogQHJldHVybiB7dGhpc31cclxuICAgKi9cbiAgX19wcm90by5yZXNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHZpZXdwb3J0LCByZW5kZXJlciwgY2FtZXJhLCBjb250cm9sLCBhY3RpdmVQYW5lbCwgcHJldldpZHRoLCBwcmV2SGVpZ2h0LCBwcmV2UHJvZ3Jlc3NJblBhbmVsLCBuZXdXaWR0aCwgbmV3SGVpZ2h0LCBzaXplQ2hhbmdlZDtcbiAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHZpZXdwb3J0ID0gdGhpcy5fdmlld3BvcnQ7XG4gICAgICAgICAgICByZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVyO1xuICAgICAgICAgICAgY2FtZXJhID0gdGhpcy5fY2FtZXJhO1xuICAgICAgICAgICAgY29udHJvbCA9IHRoaXMuX2NvbnRyb2w7XG4gICAgICAgICAgICBhY3RpdmVQYW5lbCA9IGNvbnRyb2wuYWN0aXZlUGFuZWw7XG4gICAgICAgICAgICBwcmV2V2lkdGggPSB2aWV3cG9ydC53aWR0aDtcbiAgICAgICAgICAgIHByZXZIZWlnaHQgPSB2aWV3cG9ydC5oZWlnaHQ7XG4gICAgICAgICAgICBwcmV2UHJvZ3Jlc3NJblBhbmVsID0gYWN0aXZlUGFuZWwgPyBjYW1lcmEuZ2V0UHJvZ3Jlc3NJblBhbmVsKGFjdGl2ZVBhbmVsKSA6IDA7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIobmV3IENvbXBvbmVudEV2ZW50JDEoRVZFTlRTLkJFRk9SRV9SRVNJWkUsIHtcbiAgICAgICAgICAgICAgd2lkdGg6IHByZXZXaWR0aCxcbiAgICAgICAgICAgICAgaGVpZ2h0OiBwcmV2SGVpZ2h0LFxuICAgICAgICAgICAgICBlbGVtZW50OiB2aWV3cG9ydC5lbGVtZW50XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB2aWV3cG9ydC5yZXNpemUoKTtcbiAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHJlbmRlcmVyLmZvcmNlUmVuZGVyQWxsUGFuZWxzKCldO1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIF9hLnNlbnQoKTsgLy8gUmVuZGVyIGFsbCBwYW5lbCBlbGVtZW50cywgdG8gdXBkYXRlIHNpemVzXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2luaXRpYWxpemVkKSB7XG4gICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVuZGVyZXIudXBkYXRlUGFuZWxTaXplKCk7XG4gICAgICAgICAgICBjYW1lcmEudXBkYXRlQWxpZ25Qb3MoKTtcbiAgICAgICAgICAgIGNhbWVyYS51cGRhdGVSYW5nZSgpO1xuICAgICAgICAgICAgY2FtZXJhLnVwZGF0ZUFuY2hvcnMoKTtcbiAgICAgICAgICAgIGNhbWVyYS51cGRhdGVBZGFwdGl2ZUhlaWdodCgpO1xuICAgICAgICAgICAgY2FtZXJhLnVwZGF0ZVBhbmVsT3JkZXIoKTtcbiAgICAgICAgICAgIGNhbWVyYS51cGRhdGVPZmZzZXQoKTtcbiAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHJlbmRlcmVyLnJlbmRlcigpXTtcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2luaXRpYWxpemVkKSB7XG4gICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNvbnRyb2wuYW5pbWF0aW5nKSA7IGVsc2Uge1xuICAgICAgICAgICAgICBjb250cm9sLnVwZGF0ZVBvc2l0aW9uKHByZXZQcm9ncmVzc0luUGFuZWwpO1xuICAgICAgICAgICAgICBjb250cm9sLnVwZGF0ZUlucHV0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdXaWR0aCA9IHZpZXdwb3J0LndpZHRoO1xuICAgICAgICAgICAgbmV3SGVpZ2h0ID0gdmlld3BvcnQuaGVpZ2h0O1xuICAgICAgICAgICAgc2l6ZUNoYW5nZWQgPSBuZXdXaWR0aCAhPT0gcHJldldpZHRoIHx8IG5ld0hlaWdodCAhPT0gcHJldkhlaWdodDtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcihuZXcgQ29tcG9uZW50RXZlbnQkMShFVkVOVFMuQUZURVJfUkVTSVpFLCB7XG4gICAgICAgICAgICAgIHdpZHRoOiB2aWV3cG9ydC53aWR0aCxcbiAgICAgICAgICAgICAgaGVpZ2h0OiB2aWV3cG9ydC5oZWlnaHQsXG4gICAgICAgICAgICAgIHByZXY6IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogcHJldldpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogcHJldkhlaWdodFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzaXplQ2hhbmdlZDogc2l6ZUNoYW5nZWQsXG4gICAgICAgICAgICAgIGVsZW1lbnQ6IHZpZXdwb3J0LmVsZW1lbnRcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG4gIC8qKlxyXG4gICAqIEFkZCBuZXcgcGFuZWxzIGFmdGVyIHRoZSBsYXN0IHBhbmVsXHJcbiAgICogQGtvIO2MqOuEkCDrqqnroZ3snZgg7KCc7J28IOuBneyXkCDsg4jroZzsmrQg7Yyo64SQ65Ok7J2EIOy2lOqwgO2VqeuLiOuLpFxyXG4gICAqIEBwYXJhbSB7RWxlbWVudExpa2UgfCBFbGVtZW50TGlrZVtdfSBlbGVtZW50IEEgbmV3IEhUTUxFbGVtZW50LCBhIG91dGVySFRNTCBvZiBlbGVtZW50LCBvciBhbiBhcnJheSBvZiBib3RoXHJcbiAgICogPGtvPuyDiOuhnOyatCBIVE1MRWxlbWVudCwg7Zi57J2AIOyXmOumrOuovO2KuOydmCBvdXRlckhUTUwsIO2YueydgCDqt7jqsoPrk6TsnZgg67Cw7Je0PC9rbz5cclxuICAgKiBAcmV0dXJuIHtQYW5lbFtdfSBBbiBhcnJheSBvZiBhcHBlbmRlZCBwYW5lbHM8a28+7LaU6rCA65CcIO2MqOuEkOuTpOydmCDrsLDsl7Q8L2tvPlxyXG4gICAqIEBzZWUgUGFuZWxcclxuICAgKiBAc2VlIEVsZW1lbnRMaWtlXHJcbiAgICogQHRocm93cyB7RmxpY2tpbmdFcnJvcn0ge0BsaW5rIEVSUk9SX0NPREUgRVJST1JfQ09ERS5OT1RfQUxMT1dFRF9JTl9GUkFNRVdPUkt9IGlmIGNhbGxlZCBvbiBmcmFtZXdvcmtzIChSZWFjdCwgQW5ndWxhciwgVnVlLi4uKVxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogYGBgdHNcclxuICAgKiBjb25zdCBmbGlja2luZyA9IG5ldyBGbGlja2luZyhcIiNmbGlja1wiKTtcclxuICAgKiAvLyBUaGVzZSBhcmUgcG9zc2libGUgcGFyYW1ldGVyc1xyXG4gICAqIGZsaWNraW5nLmFwcGVuZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKTtcclxuICAgKiBmbGlja2luZy5hcHBlbmQoXCJcXDxkaXZcXD5QYW5lbFxcPC9kaXZcXD5cIik7XHJcbiAgICogZmxpY2tpbmcuYXBwZW5kKFtcIlxcPGRpdlxcPlBhbmVsXFw8L2RpdlxcPlwiLCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpXSk7XHJcbiAgICogLy8gRXZlbiB0aGlzIGlzIHBvc3NpYmxlXHJcbiAgICogZmxpY2tpbmcuYXBwZW5kKFwiXFw8ZGl2XFw+UGFuZWwgMVxcPC9kaXZcXD5cXDxkaXZcXD5QYW5lbCAyXFw8L2RpdlxcPlwiKTtcclxuICAgKiBgYGBcclxuICAgKi9cbiAgX19wcm90by5hcHBlbmQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIHJldHVybiB0aGlzLmluc2VydCh0aGlzLl9yZW5kZXJlci5wYW5lbENvdW50LCBlbGVtZW50KTtcbiAgfTtcbiAgLyoqXHJcbiAgICogQWRkIG5ldyBwYW5lbHMgYmVmb3JlIHRoZSBmaXJzdCBwYW5lbFxyXG4gICAqIFRoaXMgd2lsbCBpbmNyZWFzZSBpbmRleCBvZiBwYW5lbHMgYWZ0ZXIgYnkgdGhlIG51bWJlciBvZiBwYW5lbHMgYWRkZWRcclxuICAgKiBAa28g7Yyo64SQIOuqqeuhneydmCDsoJzsnbwg7JWeKGluZGV4IDAp7JeQIOyDiOuhnOyatCDtjKjrhJDrk6TsnYQg7LaU6rCA7ZWp64uI64ukXHJcbiAgICog7LaU6rCA7ZWcIO2MqOuEkOydmCDqsJzsiJjrp4ztgbwg6riw7KG0IO2MqOuEkOuTpOydmCDsnbjrjbHsiqTqsIAg7Kad6rCA7ZWp64uI64ukLlxyXG4gICAqIEBwYXJhbSB7RWxlbWVudExpa2UgfCBFbGVtZW50TGlrZVtdfSBlbGVtZW50IEEgbmV3IEhUTUxFbGVtZW50LCBhIG91dGVySFRNTCBvZiBlbGVtZW50LCBvciBhbiBhcnJheSBvZiBib3RoXHJcbiAgICogPGtvPuyDiOuhnOyatCBIVE1MRWxlbWVudCwg7Zi57J2AIOyXmOumrOuovO2KuOydmCBvdXRlckhUTUwsIO2YueydgCDqt7jqsoPrk6TsnZgg67Cw7Je0PC9rbz5cclxuICAgKiBAcmV0dXJuIHtQYW5lbFtdfSBBbiBhcnJheSBvZiBwcmVwZW5kZWQgcGFuZWxzPGtvPuy2lOqwgOuQnCDtjKjrhJDrk6TsnZgg67Cw7Je0PC9rbz5cclxuICAgKiBAc2VlIFBhbmVsXHJcbiAgICogQHNlZSBFbGVtZW50TGlrZVxyXG4gICAqIEB0aHJvd3Mge0ZsaWNraW5nRXJyb3J9IHtAbGluayBFUlJPUl9DT0RFIEVSUk9SX0NPREUuTk9UX0FMTE9XRURfSU5fRlJBTUVXT1JLfSBpZiBjYWxsZWQgb24gZnJhbWV3b3JrcyAoUmVhY3QsIEFuZ3VsYXIsIFZ1ZS4uLilcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGBgYHRzXHJcbiAgICogY29uc3QgZmxpY2tpbmcgPSBuZXcgZWcuRmxpY2tpbmcoXCIjZmxpY2tcIik7XHJcbiAgICogZmxpY2tpbmcucHJlcGVuZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKTtcclxuICAgKiBmbGlja2luZy5wcmVwZW5kKFwiXFw8ZGl2XFw+UGFuZWxcXDwvZGl2XFw+XCIpO1xyXG4gICAqIGZsaWNraW5nLnByZXBlbmQoW1wiXFw8ZGl2XFw+UGFuZWxcXDwvZGl2XFw+XCIsIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIildKTtcclxuICAgKiAvLyBFdmVuIHRoaXMgaXMgcG9zc2libGVcclxuICAgKiBmbGlja2luZy5wcmVwZW5kKFwiXFw8ZGl2XFw+UGFuZWwgMVxcPC9kaXZcXD5cXDxkaXZcXD5QYW5lbCAyXFw8L2RpdlxcPlwiKTtcclxuICAgKiBgYGBcclxuICAgKi9cbiAgX19wcm90by5wcmVwZW5kID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gdGhpcy5pbnNlcnQoMCwgZWxlbWVudCk7XG4gIH07XG4gIC8qKlxyXG4gICAqIEluc2VydCBuZXcgcGFuZWxzIGF0IGdpdmVuIGluZGV4XHJcbiAgICogVGhpcyB3aWxsIGluY3JlYXNlIGluZGV4IG9mIHBhbmVscyBhZnRlciBieSB0aGUgbnVtYmVyIG9mIHBhbmVscyBhZGRlZFxyXG4gICAqIEBrbyDso7zslrTsp4Qg7J24642x7Iqk7JeQIOyDiOuhnOyatCDtjKjrhJDrk6TsnYQg7LaU6rCA7ZWp64uI64ukXHJcbiAgICog7ZW064u5IOyduOuNseyKpOuztOuLpCDqsJnqsbDrgpgg7YGwIOyduOuNseyKpOulvCDqsIDsp4Qg6riw7KG0IO2MqOuEkOuTpOydgCDstpTqsIDtlZwg7Yyo64SQ7J2YIOqwnOyImOunjO2BvCDsnbjrjbHsiqTqsIAg7Kad6rCA7ZWp64uI64ukLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCB0byBpbnNlcnQgbmV3IHBhbmVscyBhdDxrbz7sg4jroZwg7Yyo64SQ65Ok7J2EIOy2lOqwgO2VoCDsnbjrjbHsiqQ8L2tvPlxyXG4gICAqIEBwYXJhbSB7RWxlbWVudExpa2UgfCBFbGVtZW50TGlrZVtdfSBlbGVtZW50IEEgbmV3IEhUTUxFbGVtZW50LCBhIG91dGVySFRNTCBvZiBlbGVtZW50LCBvciBhbiBhcnJheSBvZiBib3RoXHJcbiAgICogPGtvPuyDiOuhnOyatCBIVE1MRWxlbWVudCwg7Zi57J2AIOyXmOumrOuovO2KuOydmCBvdXRlckhUTUwsIO2YueydgCDqt7jqsoPrk6TsnZgg67Cw7Je0PC9rbz5cclxuICAgKiBAcmV0dXJuIHtQYW5lbFtdfSBBbiBhcnJheSBvZiBwcmVwZW5kZWQgcGFuZWxzPGtvPuy2lOqwgOuQnCDtjKjrhJDrk6TsnZgg67Cw7Je0PC9rbz5cclxuICAgKiBAdGhyb3dzIHtGbGlja2luZ0Vycm9yfSB7QGxpbmsgRVJST1JfQ09ERSBFUlJPUl9DT0RFLk5PVF9BTExPV0VEX0lOX0ZSQU1FV09SS30gaWYgY2FsbGVkIG9uIGZyYW1ld29ya3MgKFJlYWN0LCBBbmd1bGFyLCBWdWUuLi4pXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBgYGB0c1xyXG4gICAqIGNvbnN0IGZsaWNraW5nID0gbmV3IGVnLkZsaWNraW5nKFwiI2ZsaWNrXCIpO1xyXG4gICAqIGZsaWNraW5nLmluc2VydCgwLCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKTtcclxuICAgKiBmbGlja2luZy5pbnNlcnQoMiwgXCJcXDxkaXZcXD5QYW5lbFxcPC9kaXZcXD5cIik7XHJcbiAgICogZmxpY2tpbmcuaW5zZXJ0KDEsIFtcIlxcPGRpdlxcPlBhbmVsXFw8L2RpdlxcPlwiLCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpXSk7XHJcbiAgICogLy8gRXZlbiB0aGlzIGlzIHBvc3NpYmxlXHJcbiAgICogZmxpY2tpbmcuaW5zZXJ0KDMsIFwiXFw8ZGl2XFw+UGFuZWwgMVxcPC9kaXZcXD5cXDxkaXZcXD5QYW5lbCAyXFw8L2RpdlxcPlwiKTtcclxuICAgKiBgYGBcclxuICAgKi9cbiAgX19wcm90by5pbnNlcnQgPSBmdW5jdGlvbiAoaW5kZXgsIGVsZW1lbnQpIHtcbiAgICBpZiAodGhpcy5fcmVuZGVyRXh0ZXJuYWwpIHtcbiAgICAgIHRocm93IG5ldyBGbGlja2luZ0Vycm9yKE1FU1NBR0UuTk9UX0FMTE9XRURfSU5fRlJBTUVXT1JLLCBDT0RFLk5PVF9BTExPV0VEX0lOX0ZSQU1FV09SSyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yZW5kZXJlci5iYXRjaEluc2VydCh7XG4gICAgICBpbmRleDogaW5kZXgsXG4gICAgICBlbGVtZW50czogcGFyc2VFbGVtZW50KGVsZW1lbnQpLFxuICAgICAgaGFzRE9NSW5FbGVtZW50czogdHJ1ZVxuICAgIH0pO1xuICB9O1xuICAvKipcclxuICAgKiBSZW1vdmUgdGhlIHBhbmVsIGF0IHRoZSBnaXZlbiBpbmRleFxyXG4gICAqIFRoaXMgd2lsbCBkZWNyZWFzZSBpbmRleCBvZiBwYW5lbHMgYWZ0ZXIgYnkgdGhlIG51bWJlciBvZiBwYW5lbHMgcmVtb3ZlZFxyXG4gICAqIEBrbyDso7zslrTsp4Qg7J24642x7Iqk7J2YIO2MqOuEkOydhCDsoJzqsbDtlanri4jri6RcclxuICAgKiDtlbTri7kg7J24642x7Iqk67O064ukIO2BsCDsnbjrjbHsiqTrpbwg6rCA7KeEIOq4sOyhtCDtjKjrhJDrk6TsnYAg7KCc6rGw7ZWcIO2MqOuEkOydmCDqsJzsiJjrp4ztgbwg7J24642x7Iqk6rCAIOqwkOyGjO2VqeuLiOuLpFxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCBvZiBwYW5lbCB0byByZW1vdmU8a28+7KCc6rGw7ZWgIO2MqOuEkOydmCDsnbjrjbHsiqQ8L2tvPlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZGVsZXRlQ291bnQ9MV0gTnVtYmVyIG9mIHBhbmVscyB0byByZW1vdmUgZnJvbSBpbmRleDxrbz5gaW5kZXhgIOydtO2bhOuhnCDsoJzqsbDtlaAg7Yyo64SQ7J2YIOqwnOyImDwva28+XHJcbiAgICogQHJldHVybiB7UGFuZWxbXX0gQW4gYXJyYXkgb2YgcmVtb3ZlZCBwYW5lbHM8a28+7KCc6rGw65CcIO2MqOuEkOuTpOydmCDrsLDsl7Q8L2tvPlxyXG4gICAqL1xuICBfX3Byb3RvLnJlbW92ZSA9IGZ1bmN0aW9uIChpbmRleCwgZGVsZXRlQ291bnQpIHtcbiAgICBpZiAoZGVsZXRlQ291bnQgPT09IHZvaWQgMCkge1xuICAgICAgZGVsZXRlQ291bnQgPSAxO1xuICAgIH1cbiAgICBpZiAodGhpcy5fcmVuZGVyRXh0ZXJuYWwpIHtcbiAgICAgIHRocm93IG5ldyBGbGlja2luZ0Vycm9yKE1FU1NBR0UuTk9UX0FMTE9XRURfSU5fRlJBTUVXT1JLLCBDT0RFLk5PVF9BTExPV0VEX0lOX0ZSQU1FV09SSyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yZW5kZXJlci5iYXRjaFJlbW92ZSh7XG4gICAgICBpbmRleDogaW5kZXgsXG4gICAgICBkZWxldGVDb3VudDogZGVsZXRlQ291bnQsXG4gICAgICBoYXNET01JbkVsZW1lbnRzOiB0cnVlXG4gICAgfSk7XG4gIH07XG4gIF9fcHJvdG8uX2NyZWF0ZUNvbnRyb2wgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9hO1xuICAgIHZhciBtb3ZlVHlwZSA9IHRoaXMuX21vdmVUeXBlO1xuICAgIHZhciBtb3ZlVHlwZXMgPSBPYmplY3Qua2V5cyhNT1ZFX1RZUEUpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4gTU9WRV9UWVBFW2tleV07XG4gICAgfSk7XG4gICAgdmFyIG1vdmVUeXBlU3RyID0gQXJyYXkuaXNBcnJheShtb3ZlVHlwZSkgPyBtb3ZlVHlwZVswXSA6IG1vdmVUeXBlO1xuICAgIHZhciBtb3ZlVHlwZU9wdGlvbnMgPSBBcnJheS5pc0FycmF5KG1vdmVUeXBlKSA/IChfYSA9IG1vdmVUeXBlWzFdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB7fSA6IHt9O1xuICAgIGlmICghaW5jbHVkZXMobW92ZVR5cGVzLCBtb3ZlVHlwZVN0cikpIHtcbiAgICAgIHRocm93IG5ldyBGbGlja2luZ0Vycm9yKE1FU1NBR0UuV1JPTkdfT1BUSU9OKFwibW92ZVR5cGVcIiwgSlNPTi5zdHJpbmdpZnkobW92ZVR5cGUpKSwgQ09ERS5XUk9OR19PUFRJT04pO1xuICAgIH1cbiAgICBzd2l0Y2ggKG1vdmVUeXBlU3RyKSB7XG4gICAgICBjYXNlIE1PVkVfVFlQRS5TTkFQOlxuICAgICAgICByZXR1cm4gbmV3IFNuYXBDb250cm9sKG1vdmVUeXBlT3B0aW9ucyk7XG4gICAgICBjYXNlIE1PVkVfVFlQRS5GUkVFX1NDUk9MTDpcbiAgICAgICAgcmV0dXJuIG5ldyBGcmVlQ29udHJvbChtb3ZlVHlwZU9wdGlvbnMpO1xuICAgICAgY2FzZSBNT1ZFX1RZUEUuU1RSSUNUOlxuICAgICAgICByZXR1cm4gbmV3IFN0cmljdENvbnRyb2wobW92ZVR5cGVPcHRpb25zKTtcbiAgICB9XG4gIH07XG4gIF9fcHJvdG8uX2NyZWF0ZUNhbWVyYSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fY2lyY3VsYXIgJiYgdGhpcy5fYm91bmQpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlLndhcm4oXCJcXFwiY2lyY3VsYXJcXFwiIGFuZCBcXFwiYm91bmRcXFwiIG9wdGlvbiBjYW5ub3QgYmUgdXNlZCB0b2dldGhlciwgaWdub3JpbmcgYm91bmQuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IENhbWVyYSh0aGlzLCB7XG4gICAgICBhbGlnbjogdGhpcy5fYWxpZ25cbiAgICB9KTtcbiAgfTtcbiAgX19wcm90by5fY3JlYXRlUmVuZGVyZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVybmFsUmVuZGVyZXIgPSB0aGlzLl9leHRlcm5hbFJlbmRlcmVyO1xuICAgIGlmICh0aGlzLl92aXJ0dWFsICYmIHRoaXMuX3BhbmVsc1BlclZpZXcgPD0gMCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUud2FybihcIlxcXCJ2aXJ0dWFsXFxcIiBhbmQgXFxcInBhbmVsc1BlclZpZXdcXFwiIG9wdGlvbiBzaG91bGQgYmUgdXNlZCB0b2dldGhlciwgaWdub3JpbmcgdmlydHVhbC5cIik7XG4gICAgfVxuICAgIHJldHVybiBleHRlcm5hbFJlbmRlcmVyID8gZXh0ZXJuYWxSZW5kZXJlciA6IHRoaXMuX3JlbmRlckV4dGVybmFsID8gdGhpcy5fY3JlYXRlRXh0ZXJuYWxSZW5kZXJlcigpIDogdGhpcy5fY3JlYXRlVmFuaWxsYVJlbmRlcmVyKCk7XG4gIH07XG4gIF9fcHJvdG8uX2NyZWF0ZUV4dGVybmFsUmVuZGVyZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9hID0gdGhpcy5fcmVuZGVyRXh0ZXJuYWwsXG4gICAgICByZW5kZXJlciA9IF9hLnJlbmRlcmVyLFxuICAgICAgcmVuZGVyZXJPcHRpb25zID0gX2EucmVuZGVyZXJPcHRpb25zO1xuICAgIHJldHVybiBuZXcgcmVuZGVyZXIoX19hc3NpZ24kMih7XG4gICAgICBhbGlnbjogdGhpcy5fYWxpZ25cbiAgICB9LCByZW5kZXJlck9wdGlvbnMpKTtcbiAgfTtcbiAgX19wcm90by5fY3JlYXRlVmFuaWxsYVJlbmRlcmVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2aXJ0dWFsID0gdGhpcy52aXJ0dWFsRW5hYmxlZDtcbiAgICByZXR1cm4gbmV3IFZhbmlsbGFSZW5kZXJlcih7XG4gICAgICBhbGlnbjogdGhpcy5fYWxpZ24sXG4gICAgICBzdHJhdGVneTogdmlydHVhbCA/IG5ldyBWaXJ0dWFsUmVuZGVyaW5nU3RyYXRlZ3koKSA6IG5ldyBOb3JtYWxSZW5kZXJpbmdTdHJhdGVneSh7XG4gICAgICAgIHByb3ZpZGVyQ3RvcjogVmFuaWxsYUVsZW1lbnRQcm92aWRlclxuICAgICAgfSlcbiAgICB9KTtcbiAgfTtcbiAgX19wcm90by5fbW92ZVRvSW5pdGlhbFBhbmVsID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVyO1xuICAgIHZhciBjb250cm9sID0gdGhpcy5fY29udHJvbDtcbiAgICB2YXIgY2FtZXJhID0gdGhpcy5fY2FtZXJhO1xuICAgIHZhciBkZWZhdWx0UGFuZWwgPSByZW5kZXJlci5nZXRQYW5lbCh0aGlzLl9kZWZhdWx0SW5kZXgpIHx8IHJlbmRlcmVyLmdldFBhbmVsKDApO1xuICAgIGlmICghZGVmYXVsdFBhbmVsKSByZXR1cm47XG4gICAgdmFyIG5lYXJlc3RBbmNob3IgPSBjYW1lcmEuZmluZE5lYXJlc3RBbmNob3IoZGVmYXVsdFBhbmVsLnBvc2l0aW9uKTtcbiAgICB2YXIgaW5pdGlhbFBhbmVsID0gbmVhcmVzdEFuY2hvciAmJiBkZWZhdWx0UGFuZWwuaW5kZXggIT09IG5lYXJlc3RBbmNob3IucGFuZWwuaW5kZXggPyBuZWFyZXN0QW5jaG9yLnBhbmVsIDogZGVmYXVsdFBhbmVsO1xuICAgIGNvbnRyb2wuc2V0QWN0aXZlKGluaXRpYWxQYW5lbCwgbnVsbCwgZmFsc2UpO1xuICAgIGlmICghbmVhcmVzdEFuY2hvcikge1xuICAgICAgdGhyb3cgbmV3IEZsaWNraW5nRXJyb3IoTUVTU0FHRS5QT1NJVElPTl9OT1RfUkVBQ0hBQkxFKGluaXRpYWxQYW5lbC5wb3NpdGlvbiksIENPREUuUE9TSVRJT05fTk9UX1JFQUNIQUJMRSk7XG4gICAgfVxuICAgIHZhciBwb3NpdGlvbiA9IGluaXRpYWxQYW5lbC5wb3NpdGlvbjtcbiAgICBpZiAoIWNhbWVyYS5jYW5SZWFjaChpbml0aWFsUGFuZWwpKSB7XG4gICAgICBwb3NpdGlvbiA9IG5lYXJlc3RBbmNob3IucG9zaXRpb247XG4gICAgfVxuICAgIGNhbWVyYS5sb29rQXQocG9zaXRpb24pO1xuICAgIGNvbnRyb2wudXBkYXRlSW5wdXQoKTtcbiAgICBjYW1lcmEudXBkYXRlT2Zmc2V0KCk7XG4gIH07XG4gIF9fcHJvdG8uX2luaXRpYWxSZXNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZpZXdwb3J0ID0gdGhpcy5fdmlld3BvcnQ7XG4gICAgdmFyIHJlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXI7XG4gICAgdmFyIGNhbWVyYSA9IHRoaXMuX2NhbWVyYTtcbiAgICB2YXIgY29udHJvbCA9IHRoaXMuX2NvbnRyb2w7XG4gICAgdGhpcy50cmlnZ2VyKG5ldyBDb21wb25lbnRFdmVudCQxKEVWRU5UUy5CRUZPUkVfUkVTSVpFLCB7XG4gICAgICB3aWR0aDogMCxcbiAgICAgIGhlaWdodDogMCxcbiAgICAgIGVsZW1lbnQ6IHZpZXdwb3J0LmVsZW1lbnRcbiAgICB9KSk7XG4gICAgdmlld3BvcnQucmVzaXplKCk7XG4gICAgcmVuZGVyZXIudXBkYXRlUGFuZWxTaXplKCk7XG4gICAgY2FtZXJhLnVwZGF0ZUFsaWduUG9zKCk7XG4gICAgY2FtZXJhLnVwZGF0ZVJhbmdlKCk7XG4gICAgY2FtZXJhLnVwZGF0ZUFuY2hvcnMoKTtcbiAgICBjYW1lcmEudXBkYXRlT2Zmc2V0KCk7XG4gICAgY29udHJvbC51cGRhdGVJbnB1dCgpO1xuICAgIHZhciBuZXdXaWR0aCA9IHZpZXdwb3J0LndpZHRoO1xuICAgIHZhciBuZXdIZWlnaHQgPSB2aWV3cG9ydC5oZWlnaHQ7XG4gICAgdmFyIHNpemVDaGFuZ2VkID0gbmV3V2lkdGggIT09IDAgfHwgbmV3SGVpZ2h0ICE9PSAwO1xuICAgIHRoaXMudHJpZ2dlcihuZXcgQ29tcG9uZW50RXZlbnQkMShFVkVOVFMuQUZURVJfUkVTSVpFLCB7XG4gICAgICB3aWR0aDogdmlld3BvcnQud2lkdGgsXG4gICAgICBoZWlnaHQ6IHZpZXdwb3J0LmhlaWdodCxcbiAgICAgIHByZXY6IHtcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIGhlaWdodDogMFxuICAgICAgfSxcbiAgICAgIHNpemVDaGFuZ2VkOiBzaXplQ2hhbmdlZCxcbiAgICAgIGVsZW1lbnQ6IHZpZXdwb3J0LmVsZW1lbnRcbiAgICB9KSk7XG4gIH07XG4gIC8qKlxyXG4gICAqIFZlcnNpb24gaW5mbyBzdHJpbmdcclxuICAgKiBAa28g67KE7KCE7KCV67O0IOusuOyekOyXtFxyXG4gICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBgYGB0c1xyXG4gICAqIEZsaWNraW5nLlZFUlNJT047ICAvLyBleCkgNC4wLjBcclxuICAgKiBgYGBcclxuICAgKi9cbiAgRmxpY2tpbmcuVkVSU0lPTiA9IFwiNC4xMS40XCI7XG4gIHJldHVybiBGbGlja2luZztcbn0oQ29tcG9uZW50KTtcblxuLyoqXHJcbiAqIERlY29yYXRvciB0aGF0IG1ha2VzIHRoZSBtZXRob2Qgb2YgZmxpY2tpbmcgYXZhaWxhYmxlIGluIHRoZSBmcmFtZXdvcmsuXHJcbiAqIEBrbyDtlITroIjsnoTsm4ztgazsl5DshJwg7ZSM66as7YK57J2YIOuplOyGjOuTnOulvCDsgqzsmqntlaAg7IiYIOyeiOqyjCDtlZjripQg642w7L2U66CI7J207YSwLlxyXG4gKiBAbWVtYmVyb2YgZWcuRmxpY2tpbmdcclxuICogQHByaXZhdGVcclxuICogQGV4YW1wbGVcclxuICogYGBganNcclxuICogaW1wb3J0IEZsaWNraW5nLCB7IHdpdGhGbGlja2luZ01ldGhvZHMgfSBmcm9tIFwiQGVnanMvZmxpY2tpbmdcIjtcclxuICpcclxuICogY2xhc3MgRmxpY2tpbmcgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8UGFydGlhbDxGbGlja2luZ1Byb3BzICYgRmxpY2tpbmdPcHRpb25zPj4ge1xyXG4gKiAgICYjNjQ7d2l0aEZsaWNraW5nTWV0aG9kc1xyXG4gKiAgIHByaXZhdGUgZmxpY2tpbmc6IEZsaWNraW5nO1xyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKi9cbnZhciB3aXRoRmxpY2tpbmdNZXRob2RzID0gZnVuY3Rpb24gKHByb3RvdHlwZSwgZmxpY2tpbmdOYW1lKSB7XG4gIFtDb21wb25lbnQucHJvdG90eXBlLCBGbGlja2luZy5wcm90b3R5cGVdLmZvckVhY2goZnVuY3Rpb24gKHByb3RvKSB7XG4gICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvdG8pLmZpbHRlcihmdW5jdGlvbiAobmFtZSkge1xuICAgICAgcmV0dXJuICFwcm90b3R5cGVbbmFtZV0gJiYgbmFtZS5pbmRleE9mKFwiX1wiKSAhPT0gMCAmJiBuYW1lICE9PSBcImNvbnN0cnVjdG9yXCI7XG4gICAgfSkuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgdmFyIGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHByb3RvLCBuYW1lKTtcbiAgICAgIGlmIChkZXNjcmlwdG9yLnZhbHVlKSB7XG4gICAgICAgIC8vIFB1YmxpYyBGdW5jdGlvblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG90eXBlLCBuYW1lLCB7XG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKF9hID0gZGVzY3JpcHRvci52YWx1ZSkuY2FsbC5hcHBseShfYSwgX19zcHJlYWQkMShbdGhpc1tmbGlja2luZ05hbWVdXSwgYXJncykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZ2V0dGVyRGVzY3JpcHRvciA9IHt9O1xuICAgICAgICBpZiAoZGVzY3JpcHRvci5nZXQpIHtcbiAgICAgICAgICBnZXR0ZXJEZXNjcmlwdG9yLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHZhciBmbGlja2luZyA9IHRoaXNbZmxpY2tpbmdOYW1lXTtcbiAgICAgICAgICAgIHJldHVybiBmbGlja2luZyAmJiAoKF9hID0gZGVzY3JpcHRvci5nZXQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGZsaWNraW5nKSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVzY3JpcHRvci5zZXQpIHtcbiAgICAgICAgICBnZXR0ZXJEZXNjcmlwdG9yLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKF9hID0gZGVzY3JpcHRvci5zZXQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsLmFwcGx5KF9hLCBfX3NwcmVhZCQxKFt0aGlzW2ZsaWNraW5nTmFtZV1dLCBhcmdzKSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG90eXBlLCBuYW1lLCBnZXR0ZXJEZXNjcmlwdG9yKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59O1xuXG52YXIgc3luYyA9IChmdW5jdGlvbiAoZmxpY2tpbmcsIGRpZmZSZXN1bHQsIHJlbmRlcmVkKSB7XG4gIHZhciByZW5kZXJlciA9IGZsaWNraW5nLnJlbmRlcmVyO1xuICB2YXIgcGFuZWxzID0gcmVuZGVyZXIucGFuZWxzO1xuICB2YXIgcHJldkxpc3QgPSBfX3NwcmVhZCQxKGRpZmZSZXN1bHQucHJldkxpc3QpO1xuICB2YXIgYWRkZWQgPSBbXTtcbiAgdmFyIHJlbW92ZWQgPSBbXTtcbiAgaWYgKGRpZmZSZXN1bHQucmVtb3ZlZC5sZW5ndGggPiAwKSB7XG4gICAgdmFyIGVuZElkeF8xID0gLTE7XG4gICAgdmFyIHByZXZJZHhfMSA9IC0xO1xuICAgIGRpZmZSZXN1bHQucmVtb3ZlZC5mb3JFYWNoKGZ1bmN0aW9uIChyZW1vdmVkSWR4KSB7XG4gICAgICBpZiAoZW5kSWR4XzEgPCAwKSB7XG4gICAgICAgIGVuZElkeF8xID0gcmVtb3ZlZElkeDtcbiAgICAgIH1cbiAgICAgIGlmIChwcmV2SWR4XzEgPj0gMCAmJiByZW1vdmVkSWR4ICE9PSBwcmV2SWR4XzEgLSAxKSB7XG4gICAgICAgIHJlbW92ZWQucHVzaC5hcHBseShyZW1vdmVkLCBfX3NwcmVhZCQxKGJhdGNoUmVtb3ZlKHJlbmRlcmVyLCBwcmV2SWR4XzEsIGVuZElkeF8xICsgMSkpKTtcbiAgICAgICAgZW5kSWR4XzEgPSByZW1vdmVkSWR4O1xuICAgICAgICBwcmV2SWR4XzEgPSByZW1vdmVkSWR4O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJldklkeF8xID0gcmVtb3ZlZElkeDtcbiAgICAgIH1cbiAgICAgIHByZXZMaXN0LnNwbGljZShyZW1vdmVkSWR4LCAxKTtcbiAgICB9KTtcbiAgICByZW1vdmVkLnB1c2guYXBwbHkocmVtb3ZlZCwgX19zcHJlYWQkMShiYXRjaFJlbW92ZShyZW5kZXJlciwgcHJldklkeF8xLCBlbmRJZHhfMSArIDEpKSk7XG4gIH1cbiAgZGlmZlJlc3VsdC5vcmRlcmVkLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIF9iID0gX19yZWFkJDEoX2EsIDIpLFxuICAgICAgZnJvbSA9IF9iWzBdLFxuICAgICAgdG8gPSBfYlsxXTtcbiAgICB2YXIgcHJldlBhbmVsID0gcGFuZWxzLnNwbGljZShmcm9tLCAxKVswXTtcbiAgICBwYW5lbHMuc3BsaWNlKHRvLCAwLCBwcmV2UGFuZWwpO1xuICB9KTtcbiAgaWYgKGRpZmZSZXN1bHQub3JkZXJlZC5sZW5ndGggPiAwKSB7XG4gICAgcGFuZWxzLmZvckVhY2goZnVuY3Rpb24gKHBhbmVsLCBpZHgpIHtcbiAgICAgIHZhciBpbmRleERpZmYgPSBpZHggLSBwYW5lbC5pbmRleDtcbiAgICAgIGlmIChpbmRleERpZmYgPiAwKSB7XG4gICAgICAgIHBhbmVsLmluY3JlYXNlSW5kZXgoaW5kZXhEaWZmKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhbmVsLmRlY3JlYXNlSW5kZXgoLWluZGV4RGlmZik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcGFuZWxzLnNvcnQoZnVuY3Rpb24gKHBhbmVsMSwgcGFuZWwyKSB7XG4gICAgICByZXR1cm4gcGFuZWwxLmluZGV4IC0gcGFuZWwyLmluZGV4O1xuICAgIH0pO1xuICAgIHBhbmVscy5mb3JFYWNoKGZ1bmN0aW9uIChwYW5lbCkge1xuICAgICAgcGFuZWwudXBkYXRlUG9zaXRpb24oKTtcbiAgICB9KTtcbiAgfVxuICBpZiAoZGlmZlJlc3VsdC5hZGRlZC5sZW5ndGggPiAwKSB7XG4gICAgdmFyIHN0YXJ0SWR4XzEgPSAtMTtcbiAgICB2YXIgcHJldklkeF8yID0gLTE7XG4gICAgdmFyIGFkZGVkRWxlbWVudHNfMSA9IHJlbmRlcmVkLnNsaWNlKHByZXZMaXN0Lmxlbmd0aCk7XG4gICAgZGlmZlJlc3VsdC5hZGRlZC5mb3JFYWNoKGZ1bmN0aW9uIChhZGRlZElkeCwgaWR4KSB7XG4gICAgICBpZiAoc3RhcnRJZHhfMSA8IDApIHtcbiAgICAgICAgc3RhcnRJZHhfMSA9IGlkeDtcbiAgICAgIH1cbiAgICAgIGlmIChwcmV2SWR4XzIgPj0gMCAmJiBhZGRlZElkeCAhPT0gcHJldklkeF8yICsgMSkge1xuICAgICAgICBhZGRlZC5wdXNoLmFwcGx5KGFkZGVkLCBfX3NwcmVhZCQxKGJhdGNoSW5zZXJ0KHJlbmRlcmVyLCBkaWZmUmVzdWx0LCBhZGRlZEVsZW1lbnRzXzEsIHN0YXJ0SWR4XzEsIGlkeCArIDEpKSk7XG4gICAgICAgIHN0YXJ0SWR4XzEgPSAtMTtcbiAgICAgICAgcHJldklkeF8yID0gLTE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcmV2SWR4XzIgPSBhZGRlZElkeDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoc3RhcnRJZHhfMSA+PSAwKSB7XG4gICAgICBhZGRlZC5wdXNoLmFwcGx5KGFkZGVkLCBfX3NwcmVhZCQxKGJhdGNoSW5zZXJ0KHJlbmRlcmVyLCBkaWZmUmVzdWx0LCBhZGRlZEVsZW1lbnRzXzEsIHN0YXJ0SWR4XzEpKSk7XG4gICAgfVxuICB9XG4gIGlmIChkaWZmUmVzdWx0LmFkZGVkLmxlbmd0aCA+IDAgfHwgZGlmZlJlc3VsdC5yZW1vdmVkLmxlbmd0aCA+IDApIHtcbiAgICByZW5kZXJlci51cGRhdGVBZnRlclBhbmVsQ2hhbmdlKGFkZGVkLCByZW1vdmVkKTtcbiAgfVxufSk7XG52YXIgYmF0Y2hJbnNlcnQgPSBmdW5jdGlvbiAocmVuZGVyZXIsIGRpZmZSZXN1bHQsIGFkZGVkRWxlbWVudHMsIHN0YXJ0SWR4LCBlbmRJZHgpIHtcbiAgcmV0dXJuIHJlbmRlcmVyLmJhdGNoSW5zZXJ0RGVmZXIuYXBwbHkocmVuZGVyZXIsIF9fc3ByZWFkJDEoZGlmZlJlc3VsdC5hZGRlZC5zbGljZShzdGFydElkeCwgZW5kSWR4KS5tYXAoZnVuY3Rpb24gKGluZGV4LCBlbElkeCkge1xuICAgIHJldHVybiB7XG4gICAgICBpbmRleDogaW5kZXgsXG4gICAgICBlbGVtZW50czogW2FkZGVkRWxlbWVudHNbZWxJZHhdXSxcbiAgICAgIGhhc0RPTUluRWxlbWVudHM6IGZhbHNlXG4gICAgfTtcbiAgfSkpKTtcbn07XG52YXIgYmF0Y2hSZW1vdmUgPSBmdW5jdGlvbiAocmVuZGVyZXIsIHN0YXJ0SWR4LCBlbmRJZHgpIHtcbiAgdmFyIHJlbW92ZWQgPSByZW5kZXJlci5wYW5lbHMuc2xpY2Uoc3RhcnRJZHgsIGVuZElkeCk7XG4gIHJldHVybiByZW5kZXJlci5iYXRjaFJlbW92ZURlZmVyKHtcbiAgICBpbmRleDogc3RhcnRJZHgsXG4gICAgZGVsZXRlQ291bnQ6IHJlbW92ZWQubGVuZ3RoLFxuICAgIGhhc0RPTUluRWxlbWVudHM6IGZhbHNlXG4gIH0pO1xufTtcblxudmFyIGdldFJlbmRlcmluZ1BhbmVscyA9IChmdW5jdGlvbiAoZmxpY2tpbmcsIGRpZmZSZXN1bHQpIHtcbiAgdmFyIHJlbW92ZWRQYW5lbHMgPSBkaWZmUmVzdWx0LnJlbW92ZWQucmVkdWNlKGZ1bmN0aW9uIChtYXAsIGlkeCkge1xuICAgIG1hcFtpZHhdID0gdHJ1ZTtcbiAgICByZXR1cm4gbWFwO1xuICB9LCB7fSk7XG4gIHZhciBtYWludGFpbmVkTWFwID0gZGlmZlJlc3VsdC5tYWludGFpbmVkLnJlZHVjZShmdW5jdGlvbiAobWFwLCBfYSkge1xuICAgIHZhciBfYiA9IF9fcmVhZCQxKF9hLCAyKSxcbiAgICAgIHByZXYgPSBfYlswXSxcbiAgICAgIGN1cnJlbnQgPSBfYlsxXTtcbiAgICBtYXBbcHJldl0gPSBjdXJyZW50O1xuICAgIHJldHVybiBtYXA7XG4gIH0sIHt9KTtcbiAgcmV0dXJuIF9fc3ByZWFkJDEoZmxpY2tpbmcucGFuZWxzLmZpbHRlcihmdW5jdGlvbiAocGFuZWwpIHtcbiAgICByZXR1cm4gIXJlbW92ZWRQYW5lbHNbcGFuZWwuaW5kZXhdO1xuICB9KVxuICAvLyBTb3J0IHBhbmVscyBieSBwb3NpdGlvblxuICAuc29ydChmdW5jdGlvbiAocGFuZWwxLCBwYW5lbDIpIHtcbiAgICByZXR1cm4gcGFuZWwxLnBvc2l0aW9uICsgcGFuZWwxLm9mZnNldCAtIChwYW5lbDIucG9zaXRpb24gKyBwYW5lbDIub2Zmc2V0KTtcbiAgfSkubWFwKGZ1bmN0aW9uIChwYW5lbCkge1xuICAgIHJldHVybiBkaWZmUmVzdWx0Lmxpc3RbbWFpbnRhaW5lZE1hcFtwYW5lbC5pbmRleF1dO1xuICB9KSwgZGlmZlJlc3VsdC5hZGRlZC5tYXAoZnVuY3Rpb24gKGlkeCkge1xuICAgIHJldHVybiBkaWZmUmVzdWx0Lmxpc3RbaWR4XTtcbiAgfSkpO1xufSk7XG5cbnZhciBnZXREZWZhdWx0Q2FtZXJhVHJhbnNmb3JtID0gKGZ1bmN0aW9uIChhbGlnbiwgaG9yaXpvbnRhbCwgZmlyc3RQYW5lbFNpemUpIHtcbiAgaWYgKGFsaWduID09PSB2b2lkIDApIHtcbiAgICBhbGlnbiA9IEFMSUdOLkNFTlRFUjtcbiAgfVxuICBpZiAoaG9yaXpvbnRhbCA9PT0gdm9pZCAwKSB7XG4gICAgaG9yaXpvbnRhbCA9IHRydWU7XG4gIH1cbiAgdmFyIGNhbWVyYUFsaWduID0gZ2V0Q2FtZXJhQWxpZ24oYWxpZ24pO1xuICB2YXIgcGFuZWxBbGlnbiA9IGdldFBhbmVsQWxpZ24oYWxpZ24pO1xuICBpZiAocGFuZWxBbGlnbiA9PSBudWxsKSByZXR1cm4gXCJcIjtcbiAgdmFyIGNhbVBvc2l0aW9uID0gXCJjYWxjKFwiICsgY2FtZXJhQWxpZ24gKyBcIiAtIChcIiArIChmaXJzdFBhbmVsU2l6ZSB8fCBcIjBweFwiKSArIFwiICogXCIgKyBwYW5lbEFsaWduLnBlcmNlbnRhZ2UgKyBcIikgLSBcIiArIHBhbmVsQWxpZ24uYWJzb2x1dGUgKyBcInB4KVwiO1xuICByZXR1cm4gaG9yaXpvbnRhbCA/IFwidHJhbnNsYXRlKFwiICsgY2FtUG9zaXRpb24gKyBcIilcIiA6IFwidHJhbnNsYXRlKDAsIFwiICsgY2FtUG9zaXRpb24gKyBcIilcIjtcbn0pO1xudmFyIGdldENhbWVyYUFsaWduID0gZnVuY3Rpb24gKGFsaWduKSB7XG4gIHZhciBhbGlnblZhbCA9IHR5cGVvZiBhbGlnbiA9PT0gXCJvYmplY3RcIiA/IGFsaWduLmNhbWVyYSA6IGFsaWduO1xuICByZXR1cm4gcGFyc2VBbGlnbihhbGlnblZhbCk7XG59O1xudmFyIGdldFBhbmVsQWxpZ24gPSBmdW5jdGlvbiAoYWxpZ24pIHtcbiAgdmFyIGFsaWduVmFsID0gdHlwZW9mIGFsaWduID09PSBcIm9iamVjdFwiID8gYWxpZ24ucGFuZWwgOiBhbGlnbjtcbiAgcmV0dXJuIHBhcnNlQXJpdGhtZXRpY0V4cHJlc3Npb24ocGFyc2VBbGlnbihhbGlnblZhbCkpO1xufTtcbnZhciBwYXJzZUFsaWduID0gZnVuY3Rpb24gKGFsaWduVmFsKSB7XG4gIGlmICh0eXBlb2YgYWxpZ25WYWwgPT09IFwibnVtYmVyXCIpIHtcbiAgICByZXR1cm4gYWxpZ25WYWwgKyBcInB4XCI7XG4gIH1cbiAgc3dpdGNoIChhbGlnblZhbCkge1xuICAgIGNhc2UgQUxJR04uQ0VOVEVSOlxuICAgICAgcmV0dXJuIFwiNTAlXCI7XG4gICAgY2FzZSBBTElHTi5ORVhUOlxuICAgICAgcmV0dXJuIFwiMTAwJVwiO1xuICAgIGNhc2UgQUxJR04uUFJFVjpcbiAgICAgIHJldHVybiBcIjAlXCI7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBhbGlnblZhbDtcbiAgfVxufTtcblxuLypcbkNvcHlyaWdodCAoYykgMjAxNS1wcmVzZW50IE5BVkVSIENvcnAuXG5uYW1lOiBAZWdqcy9yZWFjdC1mbGlja2luZ1xubGljZW5zZTogTUlUXG5hdXRob3I6IE5BVkVSIENvcnAuXG5yZXBvc2l0b3J5OiBodHRwczovL2dpdGh1Yi5jb20vbmF2ZXIvZWdqcy1mbGlja2luZy90cmVlL21hc3Rlci9wYWNrYWdlcy9yZWFjdC1mbGlja2luZ1xudmVyc2lvbjogNC4xMS40XG4qL1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXG5cbnZhciBleHRlbmRTdGF0aWNzJDQgPSBmdW5jdGlvbiAoZCwgYikge1xuICBleHRlbmRTdGF0aWNzJDQgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwge1xuICAgIF9fcHJvdG9fXzogW11cbiAgfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZC5fX3Byb3RvX18gPSBiO1xuICB9IHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTtcbiAgfTtcbiAgcmV0dXJuIGV4dGVuZFN0YXRpY3MkNChkLCBiKTtcbn07XG5mdW5jdGlvbiBfX2V4dGVuZHMkNChkLCBiKSB7XG4gIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgZXh0ZW5kU3RhdGljcyQ0KGQsIGIpO1xuICBmdW5jdGlvbiBfXygpIHtcbiAgICB0aGlzLmNvbnN0cnVjdG9yID0gZDtcbiAgfVxuICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59XG52YXIgX19hc3NpZ24kMyA9IGZ1bmN0aW9uICgpIHtcbiAgX19hc3NpZ24kMyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xuICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XG4gICAgfVxuICAgIHJldHVybiB0O1xuICB9O1xuICByZXR1cm4gX19hc3NpZ24kMy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbmZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XG4gIHZhciB0ID0ge307XG4gIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKSB0W3BdID0gc1twXTtcbiAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKSBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKSB0W3BbaV1dID0gc1twW2ldXTtcbiAgfVxuICByZXR1cm4gdDtcbn1cbmZ1bmN0aW9uIF9fZGVjb3JhdGUkMShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsXG4gICAgZDtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufVxuZnVuY3Rpb24gX19hd2FpdGVyJDEodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHtcbiAgICAgIHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpO1xuICAgIH1cbiAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gX19nZW5lcmF0b3IkMSh0aGlzQXJnLCBib2R5KSB7XG4gIHZhciBfID0ge1xuICAgICAgbGFiZWw6IDAsXG4gICAgICBzZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTtcbiAgICAgICAgcmV0dXJuIHRbMV07XG4gICAgICB9LFxuICAgICAgdHJ5czogW10sXG4gICAgICBvcHM6IFtdXG4gICAgfSxcbiAgICBmLFxuICAgIHksXG4gICAgdCxcbiAgICBnO1xuICByZXR1cm4gZyA9IHtcbiAgICBuZXh0OiB2ZXJiKDApLFxuICAgIFwidGhyb3dcIjogdmVyYigxKSxcbiAgICBcInJldHVyblwiOiB2ZXJiKDIpXG4gIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9KSwgZztcbiAgZnVuY3Rpb24gdmVyYihuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh2KSB7XG4gICAgICByZXR1cm4gc3RlcChbbiwgdl0pO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICB3aGlsZSAoZyAmJiAoZyA9IDAsIG9wWzBdICYmIChfID0gMCkpLCBfKSB0cnkge1xuICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICB0ID0gb3A7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBfLmxhYmVsKys7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiBvcFsxXSxcbiAgICAgICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICAgICAgfTtcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIF8ubGFiZWwrKztcbiAgICAgICAgICB5ID0gb3BbMV07XG4gICAgICAgICAgb3AgPSBbMF07XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNhc2UgNzpcbiAgICAgICAgICBvcCA9IF8ub3BzLnBvcCgpO1xuICAgICAgICAgIF8udHJ5cy5wb3AoKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkge1xuICAgICAgICAgICAgXyA9IDA7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCBvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkge1xuICAgICAgICAgICAgXy5sYWJlbCA9IG9wWzFdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkge1xuICAgICAgICAgICAgXy5sYWJlbCA9IHRbMV07XG4gICAgICAgICAgICB0ID0gb3A7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHtcbiAgICAgICAgICAgIF8ubGFiZWwgPSB0WzJdO1xuICAgICAgICAgICAgXy5vcHMucHVzaChvcCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgIF8udHJ5cy5wb3AoKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIG9wID0gWzYsIGVdO1xuICAgICAgeSA9IDA7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGYgPSB0ID0gMDtcbiAgICB9XG4gICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLFxuICAgICAgZG9uZTogdHJ1ZVxuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIF9fc3ByZWFkQXJyYXkodG8sIGZyb20sIHBhY2spIHtcbiAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XG4gICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xuICAgICAgYXJbaV0gPSBmcm9tW2ldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcbn1cblxudmFyIERFRkFVTFRfUFJPUFMgPSB7XG4gIHZpZXdwb3J0VGFnOiBcImRpdlwiLFxuICBjYW1lcmFUYWc6IFwiZGl2XCIsXG4gIGNhbWVyYUNsYXNzOiBcIlwiLFxuICByZW5kZXJPblNhbWVLZXk6IGZhbHNlLFxuICBwbHVnaW5zOiBbXSxcbiAgdXNlRmluZERPTU5vZGU6IGZhbHNlLFxuICBoaWRlQmVmb3JlSW5pdDogZmFsc2UsXG4gIG9uUmVhZHk6IGZ1bmN0aW9uIChlKSB7fSxcbiAgb25CZWZvcmVSZXNpemU6IGZ1bmN0aW9uIChlKSB7fSxcbiAgb25BZnRlclJlc2l6ZTogZnVuY3Rpb24gKGUpIHt9LFxuICBvbkhvbGRTdGFydDogZnVuY3Rpb24gKGUpIHt9LFxuICBvbkhvbGRFbmQ6IGZ1bmN0aW9uIChlKSB7fSxcbiAgb25Nb3ZlU3RhcnQ6IGZ1bmN0aW9uIChlKSB7fSxcbiAgb25Nb3ZlOiBmdW5jdGlvbiAoZSkge30sXG4gIG9uTW92ZUVuZDogZnVuY3Rpb24gKGUpIHt9LFxuICBvbldpbGxDaGFuZ2U6IGZ1bmN0aW9uIChlKSB7fSxcbiAgb25DaGFuZ2VkOiBmdW5jdGlvbiAoZSkge30sXG4gIG9uV2lsbFJlc3RvcmU6IGZ1bmN0aW9uIChlKSB7fSxcbiAgb25SZXN0b3JlZDogZnVuY3Rpb24gKGUpIHt9LFxuICBvblNlbGVjdDogZnVuY3Rpb24gKGUpIHt9LFxuICBvbk5lZWRQYW5lbDogZnVuY3Rpb24gKGUpIHt9LFxuICBvblZpc2libGVDaGFuZ2U6IGZ1bmN0aW9uIChlKSB7fSxcbiAgb25SZWFjaEVkZ2U6IGZ1bmN0aW9uIChlKSB7fSxcbiAgb25QYW5lbENoYW5nZTogZnVuY3Rpb24gKGUpIHt9XG59O1xuXG52YXIgUmVhY3RSZW5kZXJlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyQ0KFJlYWN0UmVuZGVyZXIsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIFJlYWN0UmVuZGVyZXIob3B0aW9ucykge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMpIHx8IHRoaXM7XG4gICAgX3RoaXMuX3JlYWN0RmxpY2tpbmcgPSBvcHRpb25zLnJlYWN0RmxpY2tpbmc7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcmVxdWlyZS1hd2FpdFxuICB2YXIgX19wcm90byA9IFJlYWN0UmVuZGVyZXIucHJvdG90eXBlO1xuICBfX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBmbGlja2luZywgcmVhY3RGbGlja2luZywgc3RyYXRlZ3k7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yJDEodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIGZsaWNraW5nID0gZ2V0RmxpY2tpbmdBdHRhY2hlZCh0aGlzLl9mbGlja2luZyk7XG4gICAgICAgIHJlYWN0RmxpY2tpbmcgPSB0aGlzLl9yZWFjdEZsaWNraW5nO1xuICAgICAgICBzdHJhdGVneSA9IHRoaXMuX3N0cmF0ZWd5O1xuICAgICAgICB0aGlzLl9yZW5kZXJpbmcgPSB0cnVlO1xuICAgICAgICBzdHJhdGVneS51cGRhdGVSZW5kZXJpbmdQYW5lbHMoZmxpY2tpbmcpO1xuICAgICAgICBzdHJhdGVneS5yZW5kZXJQYW5lbHMoZmxpY2tpbmcpO1xuICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICByZWFjdEZsaWNraW5nLnJlbmRlckVtaXR0ZXIub25jZShcInJlbmRlclwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5fcmVuZGVyaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBfdGhpcy5fYWZ0ZXJSZW5kZXIoKTtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZWFjdEZsaWNraW5nLmZvcmNlVXBkYXRlKCk7XG4gICAgICAgIH0pXTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuICBfX3Byb3RvLmZvcmNlUmVuZGVyQWxsUGFuZWxzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIkMSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHJlYWN0RmxpY2tpbmc7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yJDEodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICByZWFjdEZsaWNraW5nID0gdGhpcy5fcmVhY3RGbGlja2luZztcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmluZyA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBfc3VwZXIucHJvdG90eXBlLmZvcmNlUmVuZGVyQWxsUGFuZWxzLmNhbGwodGhpcyldO1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgICByZWFjdEZsaWNraW5nLnJlbmRlckVtaXR0ZXIub25jZShcInJlbmRlclwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3JlbmRlcmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJlYWN0RmxpY2tpbmcuZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgICAgIH0pXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG4gIF9fcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICBfc3VwZXIucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgICB0aGlzLl9yZWFjdEZsaWNraW5nLnJlbmRlckVtaXR0ZXIub2ZmKFwicmVuZGVyXCIpO1xuICB9O1xuICBfX3Byb3RvLl9jb2xsZWN0UGFuZWxzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBmbGlja2luZyA9IGdldEZsaWNraW5nQXR0YWNoZWQodGhpcy5fZmxpY2tpbmcpO1xuICAgIHZhciByZWFjdEZsaWNraW5nID0gdGhpcy5fcmVhY3RGbGlja2luZztcbiAgICB2YXIgcmVhY3RQYW5lbHMgPSByZWFjdEZsaWNraW5nLnJlYWN0UGFuZWxzO1xuICAgIHRoaXMuX3BhbmVscyA9IHRoaXMuX3N0cmF0ZWd5LmNvbGxlY3RQYW5lbHMoZmxpY2tpbmcsIHJlYWN0UGFuZWxzKTtcbiAgfTtcbiAgX19wcm90by5fY3JlYXRlUGFuZWwgPSBmdW5jdGlvbiAoZXh0ZXJuYWxDb21wb25lbnQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RyYXRlZ3kuY3JlYXRlUGFuZWwoZXh0ZXJuYWxDb21wb25lbnQsIG9wdGlvbnMpO1xuICB9O1xuICByZXR1cm4gUmVhY3RSZW5kZXJlcjtcbn0oRXh0ZXJuYWxSZW5kZXJlcik7XG5cbnZhciBTdHJpY3RQYW5lbCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyQ0KFN0cmljdFBhbmVsLCBfc3VwZXIpO1xuICBmdW5jdGlvbiBTdHJpY3RQYW5lbCgpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICBfdGhpcy5faGlkZSA9IGZhbHNlO1xuICAgIF90aGlzLl9lbFJlZiA9IGNyZWF0ZVJlZigpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICB2YXIgX19wcm90byA9IFN0cmljdFBhbmVsLnByb3RvdHlwZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwibmF0aXZlRWxlbWVudFwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZWxSZWYuY3VycmVudDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwicmVuZGVyZWRcIiwge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICF0aGlzLl9oaWRlO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBfX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5faGlkZSA/IGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIG51bGwpIDogdGhpcy5fZ2V0RWxlbWVudCgpO1xuICB9O1xuICBfX3Byb3RvLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5faGlkZSA9IGZhbHNlO1xuICB9O1xuICBfX3Byb3RvLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5faGlkZSA9IHRydWU7XG4gIH07XG4gIF9fcHJvdG8uX2dldEVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHJuKGskMS5vbmx5KHRoaXMucHJvcHMuY2hpbGRyZW4pLCB7XG4gICAgICByZWY6IHRoaXMuX2VsUmVmXG4gICAgfSk7XG4gIH07XG4gIHJldHVybiBTdHJpY3RQYW5lbDtcbn0oQ29tcG9uZW50JDEpO1xuXG52YXIgTm9uU3RyaWN0UGFuZWwgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMkNChOb25TdHJpY3RQYW5lbCwgX3N1cGVyKTtcbiAgZnVuY3Rpb24gTm9uU3RyaWN0UGFuZWwoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgX3RoaXMuX2hpZGUgPSBmYWxzZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgdmFyIF9fcHJvdG8gPSBOb25TdHJpY3RQYW5lbC5wcm90b3R5cGU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3Byb3RvLCBcIm5hdGl2ZUVsZW1lbnRcIiwge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG9uKHRoaXMpO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJyZW5kZXJlZFwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gIXRoaXMuX2hpZGU7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIF9fcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9oaWRlID8gY3JlYXRlRWxlbWVudChGcmFnbWVudCwgbnVsbCkgOiB0aGlzLnByb3BzLmNoaWxkcmVuO1xuICB9O1xuICBfX3Byb3RvLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5faGlkZSA9IGZhbHNlO1xuICB9O1xuICBfX3Byb3RvLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5faGlkZSA9IHRydWU7XG4gIH07XG4gIHJldHVybiBOb25TdHJpY3RQYW5lbDtcbn0oQ29tcG9uZW50JDEpO1xuXG4vKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IE5BVkVSIENvcnAuXG4gKiBlZ2pzIHByb2plY3RzIGFyZSBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xudmFyIFZpZXdwb3J0U2xvdCA9IFJlYWN0X19kZWZhdWx0Lm1lbW8oZnVuY3Rpb24gKHByb3BzKSB7XG4gIHJldHVybiBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFJlYWN0X19kZWZhdWx0LkZyYWdtZW50LCBudWxsLCBwcm9wcy5jaGlsZHJlbik7XG59KTtcblxudmFyIFJlYWN0RWxlbWVudFByb3ZpZGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUmVhY3RFbGVtZW50UHJvdmlkZXIoZWwpIHtcbiAgICB0aGlzLl9lbCA9IGVsO1xuICB9XG4gIHZhciBfX3Byb3RvID0gUmVhY3RFbGVtZW50UHJvdmlkZXIucHJvdG90eXBlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJlbGVtZW50XCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9lbC5uYXRpdmVFbGVtZW50O1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJyZW5kZXJlZFwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZWwucmVuZGVyZWQ7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIF9fcHJvdG8uc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9lbC5zaG93KCk7XG4gIH07XG4gIF9fcHJvdG8uaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9lbC5oaWRlKCk7XG4gIH07XG4gIHJldHVybiBSZWFjdEVsZW1lbnRQcm92aWRlcjtcbn0oKTtcblxudmFyIEZsaWNraW5nJDEgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMkNChGbGlja2luZyQxLCBfc3VwZXIpO1xuICBmdW5jdGlvbiBGbGlja2luZyQxKHByb3BzKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcHJvcHMpIHx8IHRoaXM7XG4gICAgX3RoaXMuX3BhbmVscyA9IFtdO1xuICAgIF90aGlzLl9yZW5kZXJFbWl0dGVyID0gbmV3IENvbXBvbmVudCgpO1xuICAgIHZhciBjaGlsZHJlbiA9IF90aGlzLl9nZXRDaGlsZHJlbigpO1xuICAgIF90aGlzLl9wYW5lbHMgPSBfdGhpcy5fY3JlYXRlUGFuZWxSZWZzKHByb3BzLCBjaGlsZHJlbik7XG4gICAgX3RoaXMuX3ByZXZDaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICB2YXIgX19wcm90byA9IEZsaWNraW5nJDEucHJvdG90eXBlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX19wcm90bywgXCJyZWFjdFBhbmVsc1wiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcGFuZWxzLm1hcChmdW5jdGlvbiAocGFuZWwpIHtcbiAgICAgICAgcmV0dXJuIHBhbmVsLmN1cnJlbnQ7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fcHJvdG8sIFwicmVuZGVyRW1pdHRlclwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVuZGVyRW1pdHRlcjtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgX19wcm90by5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciByZW5kZXJlck9wdGlvbnMgPSB7XG4gICAgICByZWFjdEZsaWNraW5nOiB0aGlzLFxuICAgICAgYWxpZ246IHByb3BzLmFsaWduLFxuICAgICAgc3RyYXRlZ3k6IHByb3BzLnZpcnR1YWwgJiYgcHJvcHMucGFuZWxzUGVyVmlldyA+IDAgPyBuZXcgVmlydHVhbFJlbmRlcmluZ1N0cmF0ZWd5KCkgOiBuZXcgTm9ybWFsUmVuZGVyaW5nU3RyYXRlZ3koe1xuICAgICAgICBwcm92aWRlckN0b3I6IFJlYWN0RWxlbWVudFByb3ZpZGVyXG4gICAgICB9KVxuICAgIH07XG4gICAgdmFyIGZsaWNraW5nID0gbmV3IEZsaWNraW5nKHRoaXMuX3ZpZXdwb3J0RWxlbWVudCwgX19hc3NpZ24kMyhfX2Fzc2lnbiQzKHt9LCBwcm9wcyksIHtcbiAgICAgIGV4dGVybmFsUmVuZGVyZXI6IG5ldyBSZWFjdFJlbmRlcmVyKHJlbmRlcmVyT3B0aW9ucylcbiAgICB9KSk7XG4gICAgdGhpcy5fdmFuaWxsYUZsaWNraW5nID0gZmxpY2tpbmc7XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fZ2V0Q2hpbGRyZW4oKTtcbiAgICB0aGlzLl9qc3hEaWZmZXIgPSBuZXcgTGlzdERpZmZlcihjaGlsZHJlbiwgZnVuY3Rpb24gKHBhbmVsKSB7XG4gICAgICByZXR1cm4gcGFuZWwua2V5O1xuICAgIH0pO1xuICAgIHRoaXMuX3BsdWdpbnNEaWZmZXIgPSBuZXcgTGlzdERpZmZlcigpO1xuICAgIHRoaXMuX3ByZXZDaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgIHRoaXMuX2JpbmRFdmVudHMoKTtcbiAgICB0aGlzLl9jaGVja1BsdWdpbnMoKTtcbiAgICBpZiAocHJvcHMuc3RhdHVzKSB7XG4gICAgICBmbGlja2luZy5zZXRTdGF0dXMocHJvcHMuc3RhdHVzKTtcbiAgICB9XG4gIH07XG4gIF9fcHJvdG8uY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9hO1xuICAgIChfYSA9IHRoaXMuX3ZhbmlsbGFGbGlja2luZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRlc3Ryb3koKTtcbiAgfTtcbiAgX19wcm90by5zaG91bGRDb21wb25lbnRVcGRhdGUgPSBmdW5jdGlvbiAobmV4dFByb3BzKSB7XG4gICAgdmFyIHZhbmlsbGFGbGlja2luZyA9IHRoaXMuX3ZhbmlsbGFGbGlja2luZztcbiAgICB2YXIgcHJldlByb3BzID0gdGhpcy5wcm9wcztcbiAgICBpZiAoIXZhbmlsbGFGbGlja2luZyB8fCAhdmFuaWxsYUZsaWNraW5nLmluaXRpYWxpemVkKSByZXR1cm4gZmFsc2U7XG4gICAgdmFyIGNoaWxkcmVuID0gbmV4dFByb3BzLmNoaWxkcmVuLFxuICAgICAgcmVzdFByb3BzID0gX19yZXN0KG5leHRQcm9wcywgW1wiY2hpbGRyZW5cIl0pO1xuICAgIGZvciAodmFyIGtleSBpbiByZXN0UHJvcHMpIHtcbiAgICAgIGlmIChwcmV2UHJvcHNba2V5XSAhPT0gbmV4dFByb3BzW2tleV0pIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBwcmV2Q2hpbGRyZW4gPSB0aGlzLl9wcmV2Q2hpbGRyZW47XG4gICAgdmFyIG5leHRDaGlsZHJlbiA9IHRoaXMuX2dldENoaWxkcmVuKGNoaWxkcmVuKTtcbiAgICBpZiAobmV4dFByb3BzLnJlbmRlck9uU2FtZUtleSB8fCAhdGhpcy5faGFzU2FtZUNoaWxkcmVuKHByZXZDaGlsZHJlbiwgbmV4dENoaWxkcmVuKSkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICBfX3Byb3RvLmJlZm9yZVJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdmFuaWxsYUZsaWNraW5nID0gdGhpcy5fdmFuaWxsYUZsaWNraW5nO1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHByZXZDaGlsZHJlbiA9IHRoaXMuX3ByZXZDaGlsZHJlbjtcbiAgICAvLyBJZ25vcmUgdXBkYXRlcyBiZWZvcmUgaW5pdCwgdGhleSB3aWxsIGJlIHVwZGF0ZWQgYWZ0ZXIgXCJyZWFkeVwiIGV2ZW50J3MgZm9yY2UgdXBkYXRlXG4gICAgLy8gQWxzbywgcHJldmVudCB1cGRhdGVzIHdoZW4gYW5vdGhlciB1cGRhdGUgaXMgYWxyZWFkeSBxdWV1ZWQuXG4gICAgLy8gVGhpcyB1c3VhbGx5IGhhcHBlbnMgd2hlbiByZW5kZXIoKSBjYWxsZWQgdHdpY2Ugd2l0aG91dCBjYWxsaW5nIGNvbXBvbmVudERpZE1vdW50LCBsaWtlIGluIHRoZSBjYXNlIG9mIFJlYWN0LlN0cmljdE1vZGUuXG4gICAgaWYgKCF2YW5pbGxhRmxpY2tpbmcgfHwgIXZhbmlsbGFGbGlja2luZy5pbml0aWFsaXplZCB8fCB0aGlzLl9kaWZmUmVzdWx0KSByZXR1cm47XG4gICAgdmFyIG5leHRDaGlsZHJlbiA9IHRoaXMuX2dldENoaWxkcmVuKHByb3BzLmNoaWxkcmVuKTtcbiAgICBpZiAocHJvcHMucmVuZGVyT25TYW1lS2V5IHx8ICF0aGlzLl9oYXNTYW1lQ2hpbGRyZW4ocHJldkNoaWxkcmVuLCBuZXh0Q2hpbGRyZW4pKSB7XG4gICAgICB0aGlzLl9wYW5lbHMgPSB0aGlzLl9jcmVhdGVQYW5lbFJlZnMocHJvcHMsIG5leHRDaGlsZHJlbik7XG4gICAgICB0aGlzLl9kaWZmUmVzdWx0ID0gdGhpcy5fanN4RGlmZmVyLnVwZGF0ZShuZXh0Q2hpbGRyZW4pO1xuICAgICAgdGhpcy5fcHJldkNoaWxkcmVuID0gbmV4dENoaWxkcmVuO1xuICAgIH1cbiAgfTtcbiAgX19wcm90by5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZsaWNraW5nID0gdGhpcy5fdmFuaWxsYUZsaWNraW5nO1xuICAgIHZhciByZW5kZXJFbWl0dGVyID0gdGhpcy5fcmVuZGVyRW1pdHRlcjtcbiAgICB2YXIgZGlmZlJlc3VsdCA9IHRoaXMuX2RpZmZSZXN1bHQ7XG4gICAgdGhpcy5fY2hlY2tQbHVnaW5zKCk7XG4gICAgcmVuZGVyRW1pdHRlci50cmlnZ2VyKFwicmVuZGVyXCIpO1xuICAgIGZsaWNraW5nLmNhbWVyYS51cGRhdGVPZmZzZXQoKTtcbiAgICAvLyBPbWl0ICd2aXJ0dWFsJywgYXMgaXQgY2FuJ3QgaGF2ZSBhbnkgc2V0dGVyXG4gICAgdmFyIF9hID0gdGhpcy5wcm9wcztcbiAgICAgIF9hLnZpcnR1YWw7XG4gICAgICB2YXIgcHJvcHMgPSBfX3Jlc3QoX2EsIFtcInZpcnR1YWxcIl0pO1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgaWYgKGtleSBpbiBmbGlja2luZyAmJiBmbGlja2luZ1trZXldICE9PSBwcm9wc1trZXldKSB7XG4gICAgICAgIGZsaWNraW5nW2tleV0gPSBwcm9wc1trZXldO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWRpZmZSZXN1bHQgfHwgIWZsaWNraW5nLmluaXRpYWxpemVkKSByZXR1cm47XG4gICAgc3luYyhmbGlja2luZywgZGlmZlJlc3VsdCwgdGhpcy5yZWFjdFBhbmVscyk7XG4gICAgdGhpcy5fZGlmZlJlc3VsdCA9IG51bGw7XG4gIH07XG4gIF9fcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIF9hLCBfYjtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBWaWV3cG9ydCA9IHByb3BzLnZpZXdwb3J0VGFnO1xuICAgIHZhciBDYW1lcmEgPSBwcm9wcy5jYW1lcmFUYWc7XG4gICAgdmFyIGF0dHJpYnV0ZXMgPSB7fTtcbiAgICB2YXIgZmxpY2tpbmcgPSB0aGlzLl92YW5pbGxhRmxpY2tpbmc7XG4gICAgdGhpcy5iZWZvcmVSZW5kZXIoKTtcbiAgICBmb3IgKHZhciBuYW1lIGluIHByb3BzKSB7XG4gICAgICBpZiAoIShuYW1lIGluIERFRkFVTFRfUFJPUFMpICYmICEobmFtZSBpbiBGbGlja2luZy5wcm90b3R5cGUpKSB7XG4gICAgICAgIGF0dHJpYnV0ZXNbbmFtZV0gPSBwcm9wc1tuYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGluaXRpYWxpemVkID0gZmxpY2tpbmcgJiYgZmxpY2tpbmcuaW5pdGlhbGl6ZWQ7XG4gICAgdmFyIHZpZXdwb3J0Q2xhc3NlcyA9IFtcImZsaWNraW5nLXZpZXdwb3J0XCJdO1xuICAgIHZhciBjYW1lcmFDbGFzc2VzID0gW1wiZmxpY2tpbmctY2FtZXJhXCJdO1xuICAgIHZhciBpc0hvcml6b250YWwgPSBmbGlja2luZyA/IGZsaWNraW5nLmhvcml6b250YWwgOiAoX2EgPSBwcm9wcy5ob3Jpem9udGFsKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0cnVlO1xuICAgIGlmICghaXNIb3Jpem9udGFsKSB7XG4gICAgICB2aWV3cG9ydENsYXNzZXMucHVzaChcInZlcnRpY2FsXCIpO1xuICAgIH1cbiAgICBpZiAocHJvcHMuaGlkZUJlZm9yZUluaXQgJiYgIWluaXRpYWxpemVkKSB7XG4gICAgICB2aWV3cG9ydENsYXNzZXMucHVzaChcImZsaWNraW5nLWhpZGRlblwiKTtcbiAgICB9XG4gICAgaWYgKGF0dHJpYnV0ZXMuY2xhc3NOYW1lKSB7XG4gICAgICB2aWV3cG9ydENsYXNzZXMucHVzaChhdHRyaWJ1dGVzLmNsYXNzTmFtZSk7XG4gICAgfVxuICAgIGlmIChwcm9wcy5jYW1lcmFDbGFzcykge1xuICAgICAgY2FtZXJhQ2xhc3Nlcy5wdXNoKHByb3BzLmNhbWVyYUNsYXNzKTtcbiAgICB9XG4gICAgdmFyIGNhbWVyYVByb3BzID0gIWluaXRpYWxpemVkICYmIHByb3BzLmZpcnN0UGFuZWxTaXplID8ge1xuICAgICAgc3R5bGU6IHtcbiAgICAgICAgdHJhbnNmb3JtOiBnZXREZWZhdWx0Q2FtZXJhVHJhbnNmb3JtKHRoaXMucHJvcHMuYWxpZ24sIHRoaXMucHJvcHMuaG9yaXpvbnRhbCwgdGhpcy5wcm9wcy5maXJzdFBhbmVsU2l6ZSlcbiAgICAgIH1cbiAgICB9IDoge307XG4gICAgdmFyIHBhbmVscyA9ICEhcHJvcHMudmlydHVhbCAmJiAoKF9iID0gcHJvcHMucGFuZWxzUGVyVmlldykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogLTEpID4gMCA/IHRoaXMuX2dldFZpcnR1YWxQYW5lbHMoKSA6IHRoaXMuX2dldFBhbmVscygpO1xuICAgIHJldHVybiBjcmVhdGVFbGVtZW50KFZpZXdwb3J0LCBfX2Fzc2lnbiQzKHt9LCBhdHRyaWJ1dGVzLCB7XG4gICAgICBjbGFzc05hbWU6IHZpZXdwb3J0Q2xhc3Nlcy5qb2luKFwiIFwiKSxcbiAgICAgIHJlZjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZSAmJiAoX3RoaXMuX3ZpZXdwb3J0RWxlbWVudCA9IGUpO1xuICAgICAgfVxuICAgIH0pLCBjcmVhdGVFbGVtZW50KENhbWVyYSwgX19hc3NpZ24kMyh7XG4gICAgICBjbGFzc05hbWU6IGNhbWVyYUNsYXNzZXMuam9pbihcIiBcIilcbiAgICB9LCBjYW1lcmFQcm9wcyksIHBhbmVscyksIHRoaXMuX2dldFZpZXdwb3J0U2xvdCgpKTtcbiAgfTtcbiAgX19wcm90by5fY3JlYXRlUGFuZWxSZWZzID0gZnVuY3Rpb24gKHByb3BzLCBjaGlsZHJlbikge1xuICAgIHZhciBfYTtcbiAgICB2YXIgcGFuZWxzUGVyVmlldyA9IChfYSA9IHByb3BzLnBhbmVsc1BlclZpZXcpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IC0xO1xuICAgIHJldHVybiBwYW5lbHNQZXJWaWV3ID4gMCAmJiAhIXByb3BzLnZpcnR1YWwgPyByYW5nZShwYW5lbHNQZXJWaWV3ICsgMSkubWFwKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBjcmVhdGVSZWYoKTtcbiAgICB9KSA6IGNoaWxkcmVuLm1hcChmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gY3JlYXRlUmVmKCk7XG4gICAgfSk7XG4gIH07XG4gIF9fcHJvdG8uX2JpbmRFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB2YXIgZmxpY2tpbmcgPSB0aGlzLl92YW5pbGxhRmxpY2tpbmc7XG4gICAgT2JqZWN0LmtleXMoRVZFTlRTKS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudEtleSkge1xuICAgICAgdmFyIGV2ZW50TmFtZSA9IEVWRU5UU1tldmVudEtleV07XG4gICAgICB2YXIgcHJvcE5hbWUgPSBcIm9uXCIuY29uY2F0KGV2ZW50TmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGV2ZW50TmFtZS5zbGljZSgxKSk7XG4gICAgICBmbGlja2luZy5vbihldmVudE5hbWUsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUuY3VycmVudFRhcmdldCA9IF90aGlzO1xuICAgICAgICB2YXIgZXZ0SGFuZGxlciA9IF90aGlzLnByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgZXZ0SGFuZGxlcihlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGZsaWNraW5nLm9uY2UoRVZFTlRTLlJFQURZLCBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5mb3JjZVVwZGF0ZSgpO1xuICAgIH0pO1xuICB9O1xuICBfX3Byb3RvLl9jaGVja1BsdWdpbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZsaWNraW5nID0gdGhpcy5fdmFuaWxsYUZsaWNraW5nO1xuICAgIHZhciBfYSA9IHRoaXMuX3BsdWdpbnNEaWZmZXIudXBkYXRlKHRoaXMucHJvcHMucGx1Z2lucyksXG4gICAgICBsaXN0ID0gX2EubGlzdCxcbiAgICAgIGFkZGVkID0gX2EuYWRkZWQsXG4gICAgICByZW1vdmVkID0gX2EucmVtb3ZlZCxcbiAgICAgIHByZXZMaXN0ID0gX2EucHJldkxpc3Q7XG4gICAgZmxpY2tpbmcuYWRkUGx1Z2lucy5hcHBseShmbGlja2luZywgYWRkZWQubWFwKGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgcmV0dXJuIGxpc3RbaW5kZXhdO1xuICAgIH0pKTtcbiAgICBmbGlja2luZy5yZW1vdmVQbHVnaW5zLmFwcGx5KGZsaWNraW5nLCByZW1vdmVkLm1hcChmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgIHJldHVybiBwcmV2TGlzdFtpbmRleF07XG4gICAgfSkpO1xuICB9O1xuICBfX3Byb3RvLl9oYXNTYW1lQ2hpbGRyZW4gPSBmdW5jdGlvbiAocHJldkNoaWxkcmVuLCBuZXh0Q2hpbGRyZW4pIHtcbiAgICBpZiAocHJldkNoaWxkcmVuLmxlbmd0aCAhPT0gbmV4dENoaWxkcmVuLmxlbmd0aCB8fCBwcmV2Q2hpbGRyZW4ubGVuZ3RoID09PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgdmFyIHNhbWUgPSBwcmV2Q2hpbGRyZW4uZXZlcnkoZnVuY3Rpb24gKGNoaWxkLCBpZHgpIHtcbiAgICAgIHZhciBuZXh0Q2hpbGQgPSBuZXh0Q2hpbGRyZW5baWR4XTtcbiAgICAgIGlmIChjaGlsZC5rZXkgJiYgbmV4dENoaWxkLmtleSkge1xuICAgICAgICByZXR1cm4gY2hpbGQua2V5ID09PSBuZXh0Q2hpbGQua2V5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkID09PSBuZXh0Q2hpbGQ7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHNhbWU7XG4gIH07XG4gIF9fcHJvdG8uX2dldENoaWxkcmVuID0gZnVuY3Rpb24gKGNoaWxkcmVuKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBpZiAoY2hpbGRyZW4gPT09IHZvaWQgMCkge1xuICAgICAgY2hpbGRyZW4gPSB0aGlzLnByb3BzLmNoaWxkcmVuO1xuICAgIH1cbiAgICByZXR1cm4gayQxLnRvQXJyYXkoY2hpbGRyZW4pLmZpbHRlcihmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgIHJldHVybiBjaGlsZC50eXBlICE9PSBWaWV3cG9ydFNsb3Q7XG4gICAgfSkucmVkdWNlKGZ1bmN0aW9uIChhbGwsIGNoaWxkKSB7XG4gICAgICByZXR1cm4gX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBhbGwsIHRydWUpLCBfdGhpcy5fdW5wYWNrRnJhZ21lbnQoY2hpbGQpLCB0cnVlKTtcbiAgICB9LCBbXSk7XG4gIH07XG4gIF9fcHJvdG8uX2dldFZpZXdwb3J0U2xvdCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gayQxLnRvQXJyYXkodGhpcy5wcm9wcy5jaGlsZHJlbikuZmlsdGVyKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgcmV0dXJuIGNoaWxkLnR5cGUgPT09IFZpZXdwb3J0U2xvdDtcbiAgICB9KTtcbiAgfTtcbiAgX19wcm90by5fdW5wYWNrRnJhZ21lbnQgPSBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHJldHVybiB0aGlzLl9pc0ZyYWdtZW50KGNoaWxkKSA/IGskMS50b0FycmF5KGNoaWxkLnByb3BzLmNoaWxkcmVuKS5yZWR1Y2UoZnVuY3Rpb24gKGFsbENoaWxkcywgZnJhZ0NoaWxkKSB7XG4gICAgICByZXR1cm4gX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBhbGxDaGlsZHMsIHRydWUpLCBfdGhpcy5fdW5wYWNrRnJhZ21lbnQoZnJhZ0NoaWxkKSwgdHJ1ZSk7XG4gICAgfSwgW10pIDogW2NoaWxkXTtcbiAgfTtcbiAgX19wcm90by5fZ2V0VmlydHVhbFBhbmVscyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHZhciBfYSA9IHRoaXMucHJvcHMudmlydHVhbC5wYW5lbENsYXNzLFxuICAgICAgcGFuZWxDbGFzcyA9IF9hID09PSB2b2lkIDAgPyBcImZsaWNraW5nLXBhbmVsXCIgOiBfYTtcbiAgICB2YXIgcGFuZWxzUGVyVmlldyA9IHRoaXMucHJvcHMucGFuZWxzUGVyVmlldztcbiAgICB2YXIgZmxpY2tpbmcgPSB0aGlzLl92YW5pbGxhRmxpY2tpbmc7XG4gICAgdmFyIGluaXRpYWxpemVkID0gZmxpY2tpbmcgJiYgZmxpY2tpbmcuaW5pdGlhbGl6ZWQ7XG4gICAgdmFyIHJlbmRlcmluZ0luZGV4ZXMgPSBpbml0aWFsaXplZCA/IGZsaWNraW5nLnJlbmRlcmVyLnN0cmF0ZWd5LmdldFJlbmRlcmluZ0luZGV4ZXNCeU9yZGVyKGZsaWNraW5nKSA6IHJhbmdlKHBhbmVsc1BlclZpZXcgKyAxKTtcbiAgICB2YXIgZmlyc3RQYW5lbCA9IGZsaWNraW5nICYmIGZsaWNraW5nLnBhbmVsc1swXTtcbiAgICB2YXIgc2l6ZSA9IGZpcnN0UGFuZWwgPyBmbGlja2luZy5ob3Jpem9udGFsID8ge1xuICAgICAgd2lkdGg6IGZpcnN0UGFuZWwuc2l6ZVxuICAgIH0gOiB7XG4gICAgICBoZWlnaHQ6IGZpcnN0UGFuZWwuc2l6ZVxuICAgIH0gOiB7fTtcbiAgICByZXR1cm4gcmVuZGVyaW5nSW5kZXhlcy5tYXAoZnVuY3Rpb24gKGlkeCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICBrZXk6IGlkeCxcbiAgICAgICAgXCJkYXRhLWVsZW1lbnQtaW5kZXhcIjogaWR4LFxuICAgICAgICByZWY6IF90aGlzLl9wYW5lbHNbaWR4XSxcbiAgICAgICAgY2xhc3NOYW1lOiBwYW5lbENsYXNzLFxuICAgICAgICBzdHlsZTogc2l6ZVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG4gIF9fcHJvdG8uX2dldFBhbmVscyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHZhciBvcmlnQ2hpbGRyZW4gPSB0aGlzLl9nZXRDaGlsZHJlbigpO1xuICAgIHZhciB2YW5pbGxhRmxpY2tpbmcgPSB0aGlzLl92YW5pbGxhRmxpY2tpbmc7XG4gICAgdmFyIGRpZmZSZXN1bHQgPSB0aGlzLl9kaWZmUmVzdWx0O1xuICAgIHZhciBjaGlsZHJlbiA9IHZhbmlsbGFGbGlja2luZyAmJiB2YW5pbGxhRmxpY2tpbmcuaW5pdGlhbGl6ZWQgPyBkaWZmUmVzdWx0ID8gZ2V0UmVuZGVyaW5nUGFuZWxzKHZhbmlsbGFGbGlja2luZywgZGlmZlJlc3VsdCkgOiBnZXRSZW5kZXJpbmdQYW5lbHModmFuaWxsYUZsaWNraW5nLCBkaWZmKG9yaWdDaGlsZHJlbiwgb3JpZ0NoaWxkcmVuKSkgOiBvcmlnQ2hpbGRyZW47XG4gICAgcmV0dXJuIHRoaXMucHJvcHMudXNlRmluZERPTU5vZGUgPyBjaGlsZHJlbi5tYXAoZnVuY3Rpb24gKGNoaWxkLCBpZHgpIHtcbiAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KE5vblN0cmljdFBhbmVsLCB7XG4gICAgICAgIGtleTogY2hpbGQua2V5LFxuICAgICAgICByZWY6IF90aGlzLl9wYW5lbHNbaWR4XVxuICAgICAgfSwgY2hpbGQpO1xuICAgIH0pIDogY2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChjaGlsZCwgaWR4KSB7XG4gICAgICByZXR1cm4gY3JlYXRlRWxlbWVudChTdHJpY3RQYW5lbCwge1xuICAgICAgICBrZXk6IGNoaWxkLmtleSxcbiAgICAgICAgcmVmOiBfdGhpcy5fcGFuZWxzW2lkeF1cbiAgICAgIH0sIGNoaWxkKTtcbiAgICB9KTtcbiAgfTtcbiAgX19wcm90by5faXNGcmFnbWVudCA9IGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIGlmIChjaGlsZC50eXBlKSB7XG4gICAgICByZXR1cm4gY2hpbGQudHlwZSA9PT0gRnJhZ21lbnQ7XG4gICAgfVxuICAgIHJldHVybiBjaGlsZCA9PT0gRnJhZ21lbnQ7XG4gIH07XG4gIEZsaWNraW5nJDEuZGVmYXVsdFByb3BzID0gREVGQVVMVF9QUk9QUztcbiAgX19kZWNvcmF0ZSQxKFt3aXRoRmxpY2tpbmdNZXRob2RzXSwgRmxpY2tpbmckMS5wcm90b3R5cGUsIFwiX3ZhbmlsbGFGbGlja2luZ1wiLCB2b2lkIDApO1xuICByZXR1cm4gRmxpY2tpbmckMTtcbn0oQ29tcG9uZW50JDEpO1xuXG5leHBvcnQgZGVmYXVsdCBGbGlja2luZyQxO1xuZXhwb3J0IHsgQUxJR04sIEFuY2hvclBvaW50LCBBbmltYXRpbmdTdGF0ZSwgQXhlc0NvbnRyb2xsZXIsIEJvdW5kQ2FtZXJhTW9kZSwgQ0lSQ1VMQVJfRkFMTEJBQ0ssIENMQVNTLCBDYW1lcmEsIENpcmN1bGFyQ2FtZXJhTW9kZSwgQ29udHJvbCwgRElSRUNUSU9OLCBEaXNhYmxlZFN0YXRlLCBEcmFnZ2luZ1N0YXRlLCBDT0RFIGFzIEVSUk9SX0NPREUsIEVWRU5UUywgRXh0ZXJuYWxSZW5kZXJlciwgRmxpY2tpbmdFcnJvciwgRnJlZUNvbnRyb2wsIEhvbGRpbmdTdGF0ZSwgSWRsZVN0YXRlLCBMaW5lYXJDYW1lcmFNb2RlLCBNT1ZFX1RZUEUsIE5vcm1hbFJlbmRlcmluZ1N0cmF0ZWd5LCBPUkRFUiwgUGFuZWwsIFJlbmRlcmVyLCBTbmFwQ29udHJvbCwgU3RhdGUsIFN0YXRlTWFjaGluZSwgU3RyaWN0Q29udHJvbCwgVmFuaWxsYUVsZW1lbnRQcm92aWRlciwgVmFuaWxsYVJlbmRlcmVyLCBWaWV3cG9ydCwgVmlld3BvcnRTbG90LCBWaXJ0dWFsRWxlbWVudFByb3ZpZGVyLCBWaXJ0dWFsTWFuYWdlciwgVmlydHVhbFBhbmVsLCBWaXJ0dWFsUmVuZGVyaW5nU3RyYXRlZ3ksIGNoZWNrRXhpc3RlbmNlLCBjaXJjdWxhdGVJbmRleCwgY2lyY3VsYXRlUG9zaXRpb24sIGNsYW1wJDEgYXMgY2xhbXAsIGZpbmQkMSBhcyBmaW5kLCBmaW5kSW5kZXgsIGZpbmRSaWdodCwgZ2V0RGVmYXVsdENhbWVyYVRyYW5zZm9ybSwgZ2V0RGlyZWN0aW9uJDEgYXMgZ2V0RGlyZWN0aW9uLCBnZXRFbGVtZW50LCBnZXRFbGVtZW50U2l6ZSwgZ2V0RmxpY2tpbmdBdHRhY2hlZCwgZ2V0TWludXNDb21wZW5zYXRlZEluZGV4LCBnZXRQcm9ncmVzcywgZ2V0UmVuZGVyaW5nUGFuZWxzLCBnZXRTdHlsZSwgaW5jbHVkZXMsIGlzQmV0d2VlbiwgaXNTdHJpbmcsIG1lcmdlLCBwYXJzZUFsaWduJDEgYXMgcGFyc2VBbGlnbiwgcGFyc2VBcml0aG1ldGljRXhwcmVzc2lvbiwgcGFyc2VBcml0aG1ldGljU2l6ZSwgcGFyc2VCb3VuY2UsIHBhcnNlQ1NTU2l6ZVZhbHVlLCBwYXJzZUVsZW1lbnQsIHBhcnNlUGFuZWxBbGlnbiwgcmFuZ2UsIHNldFByb3RvdHlwZU9mLCBzZXRTaXplLCBzeW5jLCB0b0FycmF5JDIgYXMgdG9BcnJheSwgd2l0aEZsaWNraW5nTWV0aG9kcyB9O1xuIiwiLy8gSW1wb3J0c1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18gZnJvbSBcIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9zb3VyY2VNYXBzLmpzXCI7XG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fIGZyb20gXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCI7XG5pbXBvcnQgX19fQ1NTX0xPQURFUl9HRVRfVVJMX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2dldFVybC5qc1wiO1xudmFyIF9fX0NTU19MT0FERVJfVVJMX0lNUE9SVF8wX19fID0gbmV3IFVSTChcIi4uL2Fzc2V0cy9tb2JpbGUvaWNvbi1oYW1idXJnZXIuc3ZnXCIsIGltcG9ydC5tZXRhLnVybCk7XG52YXIgX19fQ1NTX0xPQURFUl9VUkxfSU1QT1JUXzFfX18gPSBuZXcgVVJMKFwiLi4vYXNzZXRzL21vYmlsZS9pY29uLWNyb3NzLnN2Z1wiLCBpbXBvcnQubWV0YS51cmwpO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18pO1xudmFyIF9fX0NTU19MT0FERVJfVVJMX1JFUExBQ0VNRU5UXzBfX18gPSBfX19DU1NfTE9BREVSX0dFVF9VUkxfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfVVJMX0lNUE9SVF8wX19fKTtcbnZhciBfX19DU1NfTE9BREVSX1VSTF9SRVBMQUNFTUVOVF8xX19fID0gX19fQ1NTX0xPQURFUl9HRVRfVVJMX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX1VSTF9JTVBPUlRfMV9fXyk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgYC8qXG4hIHRhaWx3aW5kY3NzIHYzLjQuNyB8IE1JVCBMaWNlbnNlIHwgaHR0cHM6Ly90YWlsd2luZGNzcy5jb21cbiovLypcbjEuIFByZXZlbnQgcGFkZGluZyBhbmQgYm9yZGVyIGZyb20gYWZmZWN0aW5nIGVsZW1lbnQgd2lkdGguIChodHRwczovL2dpdGh1Yi5jb20vbW96ZGV2cy9jc3NyZW1lZHkvaXNzdWVzLzQpXG4yLiBBbGxvdyBhZGRpbmcgYSBib3JkZXIgdG8gYW4gZWxlbWVudCBieSBqdXN0IGFkZGluZyBhIGJvcmRlci13aWR0aC4gKGh0dHBzOi8vZ2l0aHViLmNvbS90YWlsd2luZGNzcy90YWlsd2luZGNzcy9wdWxsLzExNilcbiovXG5cbiosXG46OmJlZm9yZSxcbjo6YWZ0ZXIge1xuICBib3gtc2l6aW5nOiBib3JkZXItYm94OyAvKiAxICovXG4gIGJvcmRlci13aWR0aDogMDsgLyogMiAqL1xuICBib3JkZXItc3R5bGU6IHNvbGlkOyAvKiAyICovXG4gIGJvcmRlci1jb2xvcjogI2U1ZTdlYjsgLyogMiAqL1xufVxuXG46OmJlZm9yZSxcbjo6YWZ0ZXIge1xuICAtLXR3LWNvbnRlbnQ6ICcnO1xufVxuXG4vKlxuMS4gVXNlIGEgY29uc2lzdGVudCBzZW5zaWJsZSBsaW5lLWhlaWdodCBpbiBhbGwgYnJvd3NlcnMuXG4yLiBQcmV2ZW50IGFkanVzdG1lbnRzIG9mIGZvbnQgc2l6ZSBhZnRlciBvcmllbnRhdGlvbiBjaGFuZ2VzIGluIGlPUy5cbjMuIFVzZSBhIG1vcmUgcmVhZGFibGUgdGFiIHNpemUuXG40LiBVc2UgdGhlIHVzZXIncyBjb25maWd1cmVkIFxcYHNhbnNcXGAgZm9udC1mYW1pbHkgYnkgZGVmYXVsdC5cbjUuIFVzZSB0aGUgdXNlcidzIGNvbmZpZ3VyZWQgXFxgc2Fuc1xcYCBmb250LWZlYXR1cmUtc2V0dGluZ3MgYnkgZGVmYXVsdC5cbjYuIFVzZSB0aGUgdXNlcidzIGNvbmZpZ3VyZWQgXFxgc2Fuc1xcYCBmb250LXZhcmlhdGlvbi1zZXR0aW5ncyBieSBkZWZhdWx0LlxuNy4gRGlzYWJsZSB0YXAgaGlnaGxpZ2h0cyBvbiBpT1NcbiovXG5cbmh0bWwsXG46aG9zdCB7XG4gIGxpbmUtaGVpZ2h0OiAxLjU7IC8qIDEgKi9cbiAgLXdlYmtpdC10ZXh0LXNpemUtYWRqdXN0OiAxMDAlOyAvKiAyICovXG4gIC1tb3otdGFiLXNpemU6IDQ7IC8qIDMgKi9cbiAgLW8tdGFiLXNpemU6IDQ7XG4gICAgIHRhYi1zaXplOiA0OyAvKiAzICovXG4gIGZvbnQtZmFtaWx5OiB1aS1zYW5zLXNlcmlmLCBzeXN0ZW0tdWksIHNhbnMtc2VyaWYsIFwiQXBwbGUgQ29sb3IgRW1vamlcIiwgXCJTZWdvZSBVSSBFbW9qaVwiLCBcIlNlZ29lIFVJIFN5bWJvbFwiLCBcIk5vdG8gQ29sb3IgRW1vamlcIjsgLyogNCAqL1xuICBmb250LWZlYXR1cmUtc2V0dGluZ3M6IG5vcm1hbDsgLyogNSAqL1xuICBmb250LXZhcmlhdGlvbi1zZXR0aW5nczogbm9ybWFsOyAvKiA2ICovXG4gIC13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjogdHJhbnNwYXJlbnQ7IC8qIDcgKi9cbn1cblxuLypcbjEuIFJlbW92ZSB0aGUgbWFyZ2luIGluIGFsbCBicm93c2Vycy5cbjIuIEluaGVyaXQgbGluZS1oZWlnaHQgZnJvbSBcXGBodG1sXFxgIHNvIHVzZXJzIGNhbiBzZXQgdGhlbSBhcyBhIGNsYXNzIGRpcmVjdGx5IG9uIHRoZSBcXGBodG1sXFxgIGVsZW1lbnQuXG4qL1xuXG5ib2R5IHtcbiAgbWFyZ2luOiAwOyAvKiAxICovXG4gIGxpbmUtaGVpZ2h0OiBpbmhlcml0OyAvKiAyICovXG59XG5cbi8qXG4xLiBBZGQgdGhlIGNvcnJlY3QgaGVpZ2h0IGluIEZpcmVmb3guXG4yLiBDb3JyZWN0IHRoZSBpbmhlcml0YW5jZSBvZiBib3JkZXIgY29sb3IgaW4gRmlyZWZveC4gKGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTE5MDY1NSlcbjMuIEVuc3VyZSBob3Jpem9udGFsIHJ1bGVzIGFyZSB2aXNpYmxlIGJ5IGRlZmF1bHQuXG4qL1xuXG5ociB7XG4gIGhlaWdodDogMDsgLyogMSAqL1xuICBjb2xvcjogaW5oZXJpdDsgLyogMiAqL1xuICBib3JkZXItdG9wLXdpZHRoOiAxcHg7IC8qIDMgKi9cbn1cblxuLypcbkFkZCB0aGUgY29ycmVjdCB0ZXh0IGRlY29yYXRpb24gaW4gQ2hyb21lLCBFZGdlLCBhbmQgU2FmYXJpLlxuKi9cblxuYWJicjp3aGVyZShbdGl0bGVdKSB7XG4gIC13ZWJraXQtdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmUgZG90dGVkO1xuICAgICAgICAgIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lIGRvdHRlZDtcbn1cblxuLypcblJlbW92ZSB0aGUgZGVmYXVsdCBmb250IHNpemUgYW5kIHdlaWdodCBmb3IgaGVhZGluZ3MuXG4qL1xuXG5oMSxcbmgyLFxuaDMsXG5oNCxcbmg1LFxuaDYge1xuICBmb250LXNpemU6IGluaGVyaXQ7XG4gIGZvbnQtd2VpZ2h0OiBpbmhlcml0O1xufVxuXG4vKlxuUmVzZXQgbGlua3MgdG8gb3B0aW1pemUgZm9yIG9wdC1pbiBzdHlsaW5nIGluc3RlYWQgb2Ygb3B0LW91dC5cbiovXG5cbmEge1xuICBjb2xvcjogaW5oZXJpdDtcbiAgdGV4dC1kZWNvcmF0aW9uOiBpbmhlcml0O1xufVxuXG4vKlxuQWRkIHRoZSBjb3JyZWN0IGZvbnQgd2VpZ2h0IGluIEVkZ2UgYW5kIFNhZmFyaS5cbiovXG5cbmIsXG5zdHJvbmcge1xuICBmb250LXdlaWdodDogYm9sZGVyO1xufVxuXG4vKlxuMS4gVXNlIHRoZSB1c2VyJ3MgY29uZmlndXJlZCBcXGBtb25vXFxgIGZvbnQtZmFtaWx5IGJ5IGRlZmF1bHQuXG4yLiBVc2UgdGhlIHVzZXIncyBjb25maWd1cmVkIFxcYG1vbm9cXGAgZm9udC1mZWF0dXJlLXNldHRpbmdzIGJ5IGRlZmF1bHQuXG4zLiBVc2UgdGhlIHVzZXIncyBjb25maWd1cmVkIFxcYG1vbm9cXGAgZm9udC12YXJpYXRpb24tc2V0dGluZ3MgYnkgZGVmYXVsdC5cbjQuIENvcnJlY3QgdGhlIG9kZCBcXGBlbVxcYCBmb250IHNpemluZyBpbiBhbGwgYnJvd3NlcnMuXG4qL1xuXG5jb2RlLFxua2JkLFxuc2FtcCxcbnByZSB7XG4gIGZvbnQtZmFtaWx5OiB1aS1tb25vc3BhY2UsIFNGTW9uby1SZWd1bGFyLCBNZW5sbywgTW9uYWNvLCBDb25zb2xhcywgXCJMaWJlcmF0aW9uIE1vbm9cIiwgXCJDb3VyaWVyIE5ld1wiLCBtb25vc3BhY2U7IC8qIDEgKi9cbiAgZm9udC1mZWF0dXJlLXNldHRpbmdzOiBub3JtYWw7IC8qIDIgKi9cbiAgZm9udC12YXJpYXRpb24tc2V0dGluZ3M6IG5vcm1hbDsgLyogMyAqL1xuICBmb250LXNpemU6IDFlbTsgLyogNCAqL1xufVxuXG4vKlxuQWRkIHRoZSBjb3JyZWN0IGZvbnQgc2l6ZSBpbiBhbGwgYnJvd3NlcnMuXG4qL1xuXG5zbWFsbCB7XG4gIGZvbnQtc2l6ZTogODAlO1xufVxuXG4vKlxuUHJldmVudCBcXGBzdWJcXGAgYW5kIFxcYHN1cFxcYCBlbGVtZW50cyBmcm9tIGFmZmVjdGluZyB0aGUgbGluZSBoZWlnaHQgaW4gYWxsIGJyb3dzZXJzLlxuKi9cblxuc3ViLFxuc3VwIHtcbiAgZm9udC1zaXplOiA3NSU7XG4gIGxpbmUtaGVpZ2h0OiAwO1xuICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gIHZlcnRpY2FsLWFsaWduOiBiYXNlbGluZTtcbn1cblxuc3ViIHtcbiAgYm90dG9tOiAtMC4yNWVtO1xufVxuXG5zdXAge1xuICB0b3A6IC0wLjVlbTtcbn1cblxuLypcbjEuIFJlbW92ZSB0ZXh0IGluZGVudGF0aW9uIGZyb20gdGFibGUgY29udGVudHMgaW4gQ2hyb21lIGFuZCBTYWZhcmkuIChodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD05OTkwODgsIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yMDEyOTcpXG4yLiBDb3JyZWN0IHRhYmxlIGJvcmRlciBjb2xvciBpbmhlcml0YW5jZSBpbiBhbGwgQ2hyb21lIGFuZCBTYWZhcmkuIChodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD05MzU3MjksIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xOTUwMTYpXG4zLiBSZW1vdmUgZ2FwcyBiZXR3ZWVuIHRhYmxlIGJvcmRlcnMgYnkgZGVmYXVsdC5cbiovXG5cbnRhYmxlIHtcbiAgdGV4dC1pbmRlbnQ6IDA7IC8qIDEgKi9cbiAgYm9yZGVyLWNvbG9yOiBpbmhlcml0OyAvKiAyICovXG4gIGJvcmRlci1jb2xsYXBzZTogY29sbGFwc2U7IC8qIDMgKi9cbn1cblxuLypcbjEuIENoYW5nZSB0aGUgZm9udCBzdHlsZXMgaW4gYWxsIGJyb3dzZXJzLlxuMi4gUmVtb3ZlIHRoZSBtYXJnaW4gaW4gRmlyZWZveCBhbmQgU2FmYXJpLlxuMy4gUmVtb3ZlIGRlZmF1bHQgcGFkZGluZyBpbiBhbGwgYnJvd3NlcnMuXG4qL1xuXG5idXR0b24sXG5pbnB1dCxcbm9wdGdyb3VwLFxuc2VsZWN0LFxudGV4dGFyZWEge1xuICBmb250LWZhbWlseTogaW5oZXJpdDsgLyogMSAqL1xuICBmb250LWZlYXR1cmUtc2V0dGluZ3M6IGluaGVyaXQ7IC8qIDEgKi9cbiAgZm9udC12YXJpYXRpb24tc2V0dGluZ3M6IGluaGVyaXQ7IC8qIDEgKi9cbiAgZm9udC1zaXplOiAxMDAlOyAvKiAxICovXG4gIGZvbnQtd2VpZ2h0OiBpbmhlcml0OyAvKiAxICovXG4gIGxpbmUtaGVpZ2h0OiBpbmhlcml0OyAvKiAxICovXG4gIGxldHRlci1zcGFjaW5nOiBpbmhlcml0OyAvKiAxICovXG4gIGNvbG9yOiBpbmhlcml0OyAvKiAxICovXG4gIG1hcmdpbjogMDsgLyogMiAqL1xuICBwYWRkaW5nOiAwOyAvKiAzICovXG59XG5cbi8qXG5SZW1vdmUgdGhlIGluaGVyaXRhbmNlIG9mIHRleHQgdHJhbnNmb3JtIGluIEVkZ2UgYW5kIEZpcmVmb3guXG4qL1xuXG5idXR0b24sXG5zZWxlY3Qge1xuICB0ZXh0LXRyYW5zZm9ybTogbm9uZTtcbn1cblxuLypcbjEuIENvcnJlY3QgdGhlIGluYWJpbGl0eSB0byBzdHlsZSBjbGlja2FibGUgdHlwZXMgaW4gaU9TIGFuZCBTYWZhcmkuXG4yLiBSZW1vdmUgZGVmYXVsdCBidXR0b24gc3R5bGVzLlxuKi9cblxuYnV0dG9uLFxuaW5wdXQ6d2hlcmUoW3R5cGU9J2J1dHRvbiddKSxcbmlucHV0OndoZXJlKFt0eXBlPSdyZXNldCddKSxcbmlucHV0OndoZXJlKFt0eXBlPSdzdWJtaXQnXSkge1xuICAtd2Via2l0LWFwcGVhcmFuY2U6IGJ1dHRvbjsgLyogMSAqL1xuICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDsgLyogMiAqL1xuICBiYWNrZ3JvdW5kLWltYWdlOiBub25lOyAvKiAyICovXG59XG5cbi8qXG5Vc2UgdGhlIG1vZGVybiBGaXJlZm94IGZvY3VzIHN0eWxlIGZvciBhbGwgZm9jdXNhYmxlIGVsZW1lbnRzLlxuKi9cblxuOi1tb3otZm9jdXNyaW5nIHtcbiAgb3V0bGluZTogYXV0bztcbn1cblxuLypcblJlbW92ZSB0aGUgYWRkaXRpb25hbCBcXGA6aW52YWxpZFxcYCBzdHlsZXMgaW4gRmlyZWZveC4gKGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL2dlY2tvLWRldi9ibG9iLzJmOWVhY2Q5ZDNkOTk1YzkzN2I0MjUxYTU1NTdkOTVkNDk0YzliZTEvbGF5b3V0L3N0eWxlL3Jlcy9mb3Jtcy5jc3MjTDcyOC1MNzM3KVxuKi9cblxuOi1tb3otdWktaW52YWxpZCB7XG4gIGJveC1zaGFkb3c6IG5vbmU7XG59XG5cbi8qXG5BZGQgdGhlIGNvcnJlY3QgdmVydGljYWwgYWxpZ25tZW50IGluIENocm9tZSBhbmQgRmlyZWZveC5cbiovXG5cbnByb2dyZXNzIHtcbiAgdmVydGljYWwtYWxpZ246IGJhc2VsaW5lO1xufVxuXG4vKlxuQ29ycmVjdCB0aGUgY3Vyc29yIHN0eWxlIG9mIGluY3JlbWVudCBhbmQgZGVjcmVtZW50IGJ1dHRvbnMgaW4gU2FmYXJpLlxuKi9cblxuOjotd2Via2l0LWlubmVyLXNwaW4tYnV0dG9uLFxuOjotd2Via2l0LW91dGVyLXNwaW4tYnV0dG9uIHtcbiAgaGVpZ2h0OiBhdXRvO1xufVxuXG4vKlxuMS4gQ29ycmVjdCB0aGUgb2RkIGFwcGVhcmFuY2UgaW4gQ2hyb21lIGFuZCBTYWZhcmkuXG4yLiBDb3JyZWN0IHRoZSBvdXRsaW5lIHN0eWxlIGluIFNhZmFyaS5cbiovXG5cblt0eXBlPSdzZWFyY2gnXSB7XG4gIC13ZWJraXQtYXBwZWFyYW5jZTogdGV4dGZpZWxkOyAvKiAxICovXG4gIG91dGxpbmUtb2Zmc2V0OiAtMnB4OyAvKiAyICovXG59XG5cbi8qXG5SZW1vdmUgdGhlIGlubmVyIHBhZGRpbmcgaW4gQ2hyb21lIGFuZCBTYWZhcmkgb24gbWFjT1MuXG4qL1xuXG46Oi13ZWJraXQtc2VhcmNoLWRlY29yYXRpb24ge1xuICAtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmU7XG59XG5cbi8qXG4xLiBDb3JyZWN0IHRoZSBpbmFiaWxpdHkgdG8gc3R5bGUgY2xpY2thYmxlIHR5cGVzIGluIGlPUyBhbmQgU2FmYXJpLlxuMi4gQ2hhbmdlIGZvbnQgcHJvcGVydGllcyB0byBcXGBpbmhlcml0XFxgIGluIFNhZmFyaS5cbiovXG5cbjo6LXdlYmtpdC1maWxlLXVwbG9hZC1idXR0b24ge1xuICAtd2Via2l0LWFwcGVhcmFuY2U6IGJ1dHRvbjsgLyogMSAqL1xuICBmb250OiBpbmhlcml0OyAvKiAyICovXG59XG5cbi8qXG5BZGQgdGhlIGNvcnJlY3QgZGlzcGxheSBpbiBDaHJvbWUgYW5kIFNhZmFyaS5cbiovXG5cbnN1bW1hcnkge1xuICBkaXNwbGF5OiBsaXN0LWl0ZW07XG59XG5cbi8qXG5SZW1vdmVzIHRoZSBkZWZhdWx0IHNwYWNpbmcgYW5kIGJvcmRlciBmb3IgYXBwcm9wcmlhdGUgZWxlbWVudHMuXG4qL1xuXG5ibG9ja3F1b3RlLFxuZGwsXG5kZCxcbmgxLFxuaDIsXG5oMyxcbmg0LFxuaDUsXG5oNixcbmhyLFxuZmlndXJlLFxucCxcbnByZSB7XG4gIG1hcmdpbjogMDtcbn1cblxuZmllbGRzZXQge1xuICBtYXJnaW46IDA7XG4gIHBhZGRpbmc6IDA7XG59XG5cbmxlZ2VuZCB7XG4gIHBhZGRpbmc6IDA7XG59XG5cbm9sLFxudWwsXG5tZW51IHtcbiAgbGlzdC1zdHlsZTogbm9uZTtcbiAgbWFyZ2luOiAwO1xuICBwYWRkaW5nOiAwO1xufVxuXG4vKlxuUmVzZXQgZGVmYXVsdCBzdHlsaW5nIGZvciBkaWFsb2dzLlxuKi9cbmRpYWxvZyB7XG4gIHBhZGRpbmc6IDA7XG59XG5cbi8qXG5QcmV2ZW50IHJlc2l6aW5nIHRleHRhcmVhcyBob3Jpem9udGFsbHkgYnkgZGVmYXVsdC5cbiovXG5cbnRleHRhcmVhIHtcbiAgcmVzaXplOiB2ZXJ0aWNhbDtcbn1cblxuLypcbjEuIFJlc2V0IHRoZSBkZWZhdWx0IHBsYWNlaG9sZGVyIG9wYWNpdHkgaW4gRmlyZWZveC4gKGh0dHBzOi8vZ2l0aHViLmNvbS90YWlsd2luZGxhYnMvdGFpbHdpbmRjc3MvaXNzdWVzLzMzMDApXG4yLiBTZXQgdGhlIGRlZmF1bHQgcGxhY2Vob2xkZXIgY29sb3IgdG8gdGhlIHVzZXIncyBjb25maWd1cmVkIGdyYXkgNDAwIGNvbG9yLlxuKi9cblxuaW5wdXQ6Oi1tb3otcGxhY2Vob2xkZXIsIHRleHRhcmVhOjotbW96LXBsYWNlaG9sZGVyIHtcbiAgb3BhY2l0eTogMTsgLyogMSAqL1xuICBjb2xvcjogIzljYTNhZjsgLyogMiAqL1xufVxuXG5pbnB1dDo6cGxhY2Vob2xkZXIsXG50ZXh0YXJlYTo6cGxhY2Vob2xkZXIge1xuICBvcGFjaXR5OiAxOyAvKiAxICovXG4gIGNvbG9yOiAjOWNhM2FmOyAvKiAyICovXG59XG5cbi8qXG5TZXQgdGhlIGRlZmF1bHQgY3Vyc29yIGZvciBidXR0b25zLlxuKi9cblxuYnV0dG9uLFxuW3JvbGU9XCJidXR0b25cIl0ge1xuICBjdXJzb3I6IHBvaW50ZXI7XG59XG5cbi8qXG5NYWtlIHN1cmUgZGlzYWJsZWQgYnV0dG9ucyBkb24ndCBnZXQgdGhlIHBvaW50ZXIgY3Vyc29yLlxuKi9cbjpkaXNhYmxlZCB7XG4gIGN1cnNvcjogZGVmYXVsdDtcbn1cblxuLypcbjEuIE1ha2UgcmVwbGFjZWQgZWxlbWVudHMgXFxgZGlzcGxheTogYmxvY2tcXGAgYnkgZGVmYXVsdC4gKGh0dHBzOi8vZ2l0aHViLmNvbS9tb3pkZXZzL2Nzc3JlbWVkeS9pc3N1ZXMvMTQpXG4yLiBBZGQgXFxgdmVydGljYWwtYWxpZ246IG1pZGRsZVxcYCB0byBhbGlnbiByZXBsYWNlZCBlbGVtZW50cyBtb3JlIHNlbnNpYmx5IGJ5IGRlZmF1bHQuIChodHRwczovL2dpdGh1Yi5jb20vamVuc2ltbW9ucy9jc3NyZW1lZHkvaXNzdWVzLzE0I2lzc3VlY29tbWVudC02MzQ5MzQyMTApXG4gICBUaGlzIGNhbiB0cmlnZ2VyIGEgcG9vcmx5IGNvbnNpZGVyZWQgbGludCBlcnJvciBpbiBzb21lIHRvb2xzIGJ1dCBpcyBpbmNsdWRlZCBieSBkZXNpZ24uXG4qL1xuXG5pbWcsXG5zdmcsXG52aWRlbyxcbmNhbnZhcyxcbmF1ZGlvLFxuaWZyYW1lLFxuZW1iZWQsXG5vYmplY3Qge1xuICBkaXNwbGF5OiBibG9jazsgLyogMSAqL1xuICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlOyAvKiAyICovXG59XG5cbi8qXG5Db25zdHJhaW4gaW1hZ2VzIGFuZCB2aWRlb3MgdG8gdGhlIHBhcmVudCB3aWR0aCBhbmQgcHJlc2VydmUgdGhlaXIgaW50cmluc2ljIGFzcGVjdCByYXRpby4gKGh0dHBzOi8vZ2l0aHViLmNvbS9tb3pkZXZzL2Nzc3JlbWVkeS9pc3N1ZXMvMTQpXG4qL1xuXG5pbWcsXG52aWRlbyB7XG4gIG1heC13aWR0aDogMTAwJTtcbiAgaGVpZ2h0OiBhdXRvO1xufVxuXG4vKiBNYWtlIGVsZW1lbnRzIHdpdGggdGhlIEhUTUwgaGlkZGVuIGF0dHJpYnV0ZSBzdGF5IGhpZGRlbiBieSBkZWZhdWx0ICovXG5baGlkZGVuXSB7XG4gIGRpc3BsYXk6IG5vbmU7XG59XG5cbiosIDo6YmVmb3JlLCA6OmFmdGVyIHtcbiAgLS10dy1ib3JkZXItc3BhY2luZy14OiAwO1xuICAtLXR3LWJvcmRlci1zcGFjaW5nLXk6IDA7XG4gIC0tdHctdHJhbnNsYXRlLXg6IDA7XG4gIC0tdHctdHJhbnNsYXRlLXk6IDA7XG4gIC0tdHctcm90YXRlOiAwO1xuICAtLXR3LXNrZXcteDogMDtcbiAgLS10dy1za2V3LXk6IDA7XG4gIC0tdHctc2NhbGUteDogMTtcbiAgLS10dy1zY2FsZS15OiAxO1xuICAtLXR3LXBhbi14OiAgO1xuICAtLXR3LXBhbi15OiAgO1xuICAtLXR3LXBpbmNoLXpvb206ICA7XG4gIC0tdHctc2Nyb2xsLXNuYXAtc3RyaWN0bmVzczogcHJveGltaXR5O1xuICAtLXR3LWdyYWRpZW50LWZyb20tcG9zaXRpb246ICA7XG4gIC0tdHctZ3JhZGllbnQtdmlhLXBvc2l0aW9uOiAgO1xuICAtLXR3LWdyYWRpZW50LXRvLXBvc2l0aW9uOiAgO1xuICAtLXR3LW9yZGluYWw6ICA7XG4gIC0tdHctc2xhc2hlZC16ZXJvOiAgO1xuICAtLXR3LW51bWVyaWMtZmlndXJlOiAgO1xuICAtLXR3LW51bWVyaWMtc3BhY2luZzogIDtcbiAgLS10dy1udW1lcmljLWZyYWN0aW9uOiAgO1xuICAtLXR3LXJpbmctaW5zZXQ6ICA7XG4gIC0tdHctcmluZy1vZmZzZXQtd2lkdGg6IDBweDtcbiAgLS10dy1yaW5nLW9mZnNldC1jb2xvcjogI2ZmZjtcbiAgLS10dy1yaW5nLWNvbG9yOiByZ2IoNTkgMTMwIDI0NiAvIDAuNSk7XG4gIC0tdHctcmluZy1vZmZzZXQtc2hhZG93OiAwIDAgIzAwMDA7XG4gIC0tdHctcmluZy1zaGFkb3c6IDAgMCAjMDAwMDtcbiAgLS10dy1zaGFkb3c6IDAgMCAjMDAwMDtcbiAgLS10dy1zaGFkb3ctY29sb3JlZDogMCAwICMwMDAwO1xuICAtLXR3LWJsdXI6ICA7XG4gIC0tdHctYnJpZ2h0bmVzczogIDtcbiAgLS10dy1jb250cmFzdDogIDtcbiAgLS10dy1ncmF5c2NhbGU6ICA7XG4gIC0tdHctaHVlLXJvdGF0ZTogIDtcbiAgLS10dy1pbnZlcnQ6ICA7XG4gIC0tdHctc2F0dXJhdGU6ICA7XG4gIC0tdHctc2VwaWE6ICA7XG4gIC0tdHctZHJvcC1zaGFkb3c6ICA7XG4gIC0tdHctYmFja2Ryb3AtYmx1cjogIDtcbiAgLS10dy1iYWNrZHJvcC1icmlnaHRuZXNzOiAgO1xuICAtLXR3LWJhY2tkcm9wLWNvbnRyYXN0OiAgO1xuICAtLXR3LWJhY2tkcm9wLWdyYXlzY2FsZTogIDtcbiAgLS10dy1iYWNrZHJvcC1odWUtcm90YXRlOiAgO1xuICAtLXR3LWJhY2tkcm9wLWludmVydDogIDtcbiAgLS10dy1iYWNrZHJvcC1vcGFjaXR5OiAgO1xuICAtLXR3LWJhY2tkcm9wLXNhdHVyYXRlOiAgO1xuICAtLXR3LWJhY2tkcm9wLXNlcGlhOiAgO1xuICAtLXR3LWNvbnRhaW4tc2l6ZTogIDtcbiAgLS10dy1jb250YWluLWxheW91dDogIDtcbiAgLS10dy1jb250YWluLXBhaW50OiAgO1xuICAtLXR3LWNvbnRhaW4tc3R5bGU6ICA7XG59XG5cbjo6YmFja2Ryb3Age1xuICAtLXR3LWJvcmRlci1zcGFjaW5nLXg6IDA7XG4gIC0tdHctYm9yZGVyLXNwYWNpbmcteTogMDtcbiAgLS10dy10cmFuc2xhdGUteDogMDtcbiAgLS10dy10cmFuc2xhdGUteTogMDtcbiAgLS10dy1yb3RhdGU6IDA7XG4gIC0tdHctc2tldy14OiAwO1xuICAtLXR3LXNrZXcteTogMDtcbiAgLS10dy1zY2FsZS14OiAxO1xuICAtLXR3LXNjYWxlLXk6IDE7XG4gIC0tdHctcGFuLXg6ICA7XG4gIC0tdHctcGFuLXk6ICA7XG4gIC0tdHctcGluY2gtem9vbTogIDtcbiAgLS10dy1zY3JvbGwtc25hcC1zdHJpY3RuZXNzOiBwcm94aW1pdHk7XG4gIC0tdHctZ3JhZGllbnQtZnJvbS1wb3NpdGlvbjogIDtcbiAgLS10dy1ncmFkaWVudC12aWEtcG9zaXRpb246ICA7XG4gIC0tdHctZ3JhZGllbnQtdG8tcG9zaXRpb246ICA7XG4gIC0tdHctb3JkaW5hbDogIDtcbiAgLS10dy1zbGFzaGVkLXplcm86ICA7XG4gIC0tdHctbnVtZXJpYy1maWd1cmU6ICA7XG4gIC0tdHctbnVtZXJpYy1zcGFjaW5nOiAgO1xuICAtLXR3LW51bWVyaWMtZnJhY3Rpb246ICA7XG4gIC0tdHctcmluZy1pbnNldDogIDtcbiAgLS10dy1yaW5nLW9mZnNldC13aWR0aDogMHB4O1xuICAtLXR3LXJpbmctb2Zmc2V0LWNvbG9yOiAjZmZmO1xuICAtLXR3LXJpbmctY29sb3I6IHJnYig1OSAxMzAgMjQ2IC8gMC41KTtcbiAgLS10dy1yaW5nLW9mZnNldC1zaGFkb3c6IDAgMCAjMDAwMDtcbiAgLS10dy1yaW5nLXNoYWRvdzogMCAwICMwMDAwO1xuICAtLXR3LXNoYWRvdzogMCAwICMwMDAwO1xuICAtLXR3LXNoYWRvdy1jb2xvcmVkOiAwIDAgIzAwMDA7XG4gIC0tdHctYmx1cjogIDtcbiAgLS10dy1icmlnaHRuZXNzOiAgO1xuICAtLXR3LWNvbnRyYXN0OiAgO1xuICAtLXR3LWdyYXlzY2FsZTogIDtcbiAgLS10dy1odWUtcm90YXRlOiAgO1xuICAtLXR3LWludmVydDogIDtcbiAgLS10dy1zYXR1cmF0ZTogIDtcbiAgLS10dy1zZXBpYTogIDtcbiAgLS10dy1kcm9wLXNoYWRvdzogIDtcbiAgLS10dy1iYWNrZHJvcC1ibHVyOiAgO1xuICAtLXR3LWJhY2tkcm9wLWJyaWdodG5lc3M6ICA7XG4gIC0tdHctYmFja2Ryb3AtY29udHJhc3Q6ICA7XG4gIC0tdHctYmFja2Ryb3AtZ3JheXNjYWxlOiAgO1xuICAtLXR3LWJhY2tkcm9wLWh1ZS1yb3RhdGU6ICA7XG4gIC0tdHctYmFja2Ryb3AtaW52ZXJ0OiAgO1xuICAtLXR3LWJhY2tkcm9wLW9wYWNpdHk6ICA7XG4gIC0tdHctYmFja2Ryb3Atc2F0dXJhdGU6ICA7XG4gIC0tdHctYmFja2Ryb3Atc2VwaWE6ICA7XG4gIC0tdHctY29udGFpbi1zaXplOiAgO1xuICAtLXR3LWNvbnRhaW4tbGF5b3V0OiAgO1xuICAtLXR3LWNvbnRhaW4tcGFpbnQ6ICA7XG4gIC0tdHctY29udGFpbi1zdHlsZTogIDtcbn1cclxuLnBvaW50ZXItZXZlbnRzLW5vbmUge1xuICBwb2ludGVyLWV2ZW50czogbm9uZTtcbn1cclxuLnZpc2libGUge1xuICB2aXNpYmlsaXR5OiB2aXNpYmxlO1xufVxyXG4uaW52aXNpYmxlIHtcbiAgdmlzaWJpbGl0eTogaGlkZGVuO1xufVxyXG4uY29sbGFwc2Uge1xuICB2aXNpYmlsaXR5OiBjb2xsYXBzZTtcbn1cclxuLnN0YXRpYyB7XG4gIHBvc2l0aW9uOiBzdGF0aWM7XG59XHJcbi5cXFxcIWZpeGVkIHtcbiAgcG9zaXRpb246IGZpeGVkICFpbXBvcnRhbnQ7XG59XHJcbi5maXhlZCB7XG4gIHBvc2l0aW9uOiBmaXhlZDtcbn1cclxuLmFic29sdXRlIHtcbiAgcG9zaXRpb246IGFic29sdXRlO1xufVxyXG4ucmVsYXRpdmUge1xuICBwb3NpdGlvbjogcmVsYXRpdmU7XG59XHJcbi5ib3R0b20tXFxcXFs2OHB4XFxcXF0ge1xuICBib3R0b206IDY4cHg7XG59XHJcbi5sZWZ0LTAge1xuICBsZWZ0OiAwcHg7XG59XHJcbi5sZWZ0LVxcXFxbLTMxcHhcXFxcXSB7XG4gIGxlZnQ6IC0zMXB4O1xufVxyXG4ucmlnaHQtMCB7XG4gIHJpZ2h0OiAwcHg7XG59XHJcbi5yaWdodC1cXFxcWy0zMXB4XFxcXF0ge1xuICByaWdodDogLTMxcHg7XG59XHJcbi5yaWdodC1cXFxcWzE1NHB4XFxcXF0ge1xuICByaWdodDogMTU0cHg7XG59XHJcbi5yaWdodC1cXFxcWzI0cHhcXFxcXSB7XG4gIHJpZ2h0OiAyNHB4O1xufVxyXG4ucmlnaHQtXFxcXFsyNnB4XFxcXF0ge1xuICByaWdodDogMjZweDtcbn1cclxuLnRvcC0wIHtcbiAgdG9wOiAwcHg7XG59XHJcbi50b3AtXFxcXFsxMTBweFxcXFxdIHtcbiAgdG9wOiAxMTBweDtcbn1cclxuLnRvcC1cXFxcWzEyNnB4XFxcXF0ge1xuICB0b3A6IDEyNnB4O1xufVxyXG4udG9wLVxcXFxbMjIwcHhcXFxcXSB7XG4gIHRvcDogMjIwcHg7XG59XHJcbi50b3AtXFxcXFstMTVweFxcXFxdIHtcbiAgdG9wOiAtMTVweDtcbn1cclxuLi16LTAge1xuICB6LWluZGV4OiAwO1xufVxyXG4uei0wIHtcbiAgei1pbmRleDogMDtcbn1cclxuLnotNDAge1xuICB6LWluZGV4OiA0MDtcbn1cclxuLnotXFxcXFsxXFxcXF0ge1xuICB6LWluZGV4OiAxO1xufVxyXG4uei1cXFxcWzJcXFxcXSB7XG4gIHotaW5kZXg6IDI7XG59XHJcbi5teC1hdXRvIHtcbiAgbWFyZ2luLWxlZnQ6IGF1dG87XG4gIG1hcmdpbi1yaWdodDogYXV0bztcbn1cclxuLm1iLVxcXFxbMTAxcHhcXFxcXSB7XG4gIG1hcmdpbi1ib3R0b206IDEwMXB4O1xufVxyXG4ubWItYXV0byB7XG4gIG1hcmdpbi1ib3R0b206IGF1dG87XG59XHJcbi5tbC1cXFxcWzU5cHhcXFxcXSB7XG4gIG1hcmdpbi1sZWZ0OiA1OXB4O1xufVxyXG4ubXQtMCB7XG4gIG1hcmdpbi10b3A6IDBweDtcbn1cclxuLm10LVxcXFxbLTEyMHB4XFxcXF0ge1xuICBtYXJnaW4tdG9wOiAtMTIwcHg7XG59XHJcbi5tdC1cXFxcWzEyMHB4XFxcXF0ge1xuICBtYXJnaW4tdG9wOiAxMjBweDtcbn1cclxuLm10LVxcXFxbNDRweFxcXFxdIHtcbiAgbWFyZ2luLXRvcDogNDRweDtcbn1cclxuLm10LVxcXFxbNzBweFxcXFxdIHtcbiAgbWFyZ2luLXRvcDogNzBweDtcbn1cclxuLm10LVxcXFxbNzdweFxcXFxdIHtcbiAgbWFyZ2luLXRvcDogNzdweDtcbn1cclxuLm10LVxcXFxbNTZweFxcXFxdIHtcbiAgbWFyZ2luLXRvcDogNTZweDtcbn1cclxuLm1iLVxcXFxbOTZweFxcXFxdIHtcbiAgbWFyZ2luLWJvdHRvbTogOTZweDtcbn1cclxuLm1iLTAge1xuICBtYXJnaW4tYm90dG9tOiAwcHg7XG59XHJcbi5ibG9jayB7XG4gIGRpc3BsYXk6IGJsb2NrO1xufVxyXG4uZmxleCB7XG4gIGRpc3BsYXk6IGZsZXg7XG59XHJcbi50YWJsZSB7XG4gIGRpc3BsYXk6IHRhYmxlO1xufVxyXG4uZ3JpZCB7XG4gIGRpc3BsYXk6IGdyaWQ7XG59XHJcbi5jb250ZW50cyB7XG4gIGRpc3BsYXk6IGNvbnRlbnRzO1xufVxyXG4uaGlkZGVuIHtcbiAgZGlzcGxheTogbm9uZTtcbn1cclxuLnNpemUtXFxcXFs0MHB4XFxcXF0ge1xuICB3aWR0aDogNDBweDtcbiAgaGVpZ2h0OiA0MHB4O1xufVxyXG4uc2l6ZS1mdWxsIHtcbiAgd2lkdGg6IDEwMCU7XG4gIGhlaWdodDogMTAwJTtcbn1cclxuLmgtXFxcXFsxMTBweFxcXFxdIHtcbiAgaGVpZ2h0OiAxMTBweDtcbn1cclxuLmgtXFxcXFsxOHB4XFxcXF0ge1xuICBoZWlnaHQ6IDE4cHg7XG59XHJcbi5oLVxcXFxbMjAwcHhcXFxcXSB7XG4gIGhlaWdodDogMjAwcHg7XG59XHJcbi5oLVxcXFxbMjBweFxcXFxdIHtcbiAgaGVpZ2h0OiAyMHB4O1xufVxyXG4uaC1cXFxcWzIzM3B4XFxcXF0ge1xuICBoZWlnaHQ6IDIzM3B4O1xufVxyXG4uaC1cXFxcWzI4cHhcXFxcXSB7XG4gIGhlaWdodDogMjhweDtcbn1cclxuLmgtXFxcXFsyOTJweFxcXFxdIHtcbiAgaGVpZ2h0OiAyOTJweDtcbn1cclxuLmgtXFxcXFszNTJweFxcXFxdIHtcbiAgaGVpZ2h0OiAzNTJweDtcbn1cclxuLmgtXFxcXFs0NzJweFxcXFxdIHtcbiAgaGVpZ2h0OiA0NzJweDtcbn1cclxuLmgtXFxcXFs1MzhweFxcXFxdIHtcbiAgaGVpZ2h0OiA1MzhweDtcbn1cclxuLmgtXFxcXFs2NDhweFxcXFxdIHtcbiAgaGVpZ2h0OiA2NDhweDtcbn1cclxuLmgtXFxcXFs2NHB4XFxcXF0ge1xuICBoZWlnaHQ6IDY0cHg7XG59XHJcbi5oLVxcXFxbNjU4cHhcXFxcXSB7XG4gIGhlaWdodDogNjU4cHg7XG59XHJcbi5oLVxcXFxbNzJweFxcXFxdIHtcbiAgaGVpZ2h0OiA3MnB4O1xufVxyXG4uaC1cXFxcWzc5N3B4XFxcXF0ge1xuICBoZWlnaHQ6IDc5N3B4O1xufVxyXG4uaC1maXQge1xuICBoZWlnaHQ6IC1tb3otZml0LWNvbnRlbnQ7XG4gIGhlaWdodDogZml0LWNvbnRlbnQ7XG59XHJcbi5oLWZ1bGwge1xuICBoZWlnaHQ6IDEwMCU7XG59XHJcbi5oLVxcXFxbNjA2cHhcXFxcXSB7XG4gIGhlaWdodDogNjA2cHg7XG59XHJcbi5oLVxcXFxbNjA4cHhcXFxcXSB7XG4gIGhlaWdodDogNjA4cHg7XG59XHJcbi5taW4taC1cXFxcWzQ3MnB4XFxcXF0ge1xuICBtaW4taGVpZ2h0OiA0NzJweDtcbn1cclxuLm1pbi1oLWR2aCB7XG4gIG1pbi1oZWlnaHQ6IDEwMGR2aDtcbn1cclxuLm1pbi1oLXNjcmVlbiB7XG4gIG1pbi1oZWlnaHQ6IDEwMHZoO1xufVxyXG4udy0xIHtcbiAgd2lkdGg6IDAuMjVyZW07XG59XHJcbi53LTFcXFxcLzIge1xuICB3aWR0aDogNTAlO1xufVxyXG4udy0zIHtcbiAgd2lkdGg6IDAuNzVyZW07XG59XHJcbi53LTNcXFxcLzUge1xuICB3aWR0aDogNjAlO1xufVxyXG4udy1cXFxcWzE0MDBweFxcXFxdIHtcbiAgd2lkdGg6IDE0MDBweDtcbn1cclxuLnctXFxcXFsxNzdweFxcXFxdIHtcbiAgd2lkdGg6IDE3N3B4O1xufVxyXG4udy1cXFxcWzE5OXB4XFxcXF0ge1xuICB3aWR0aDogMTk5cHg7XG59XHJcbi53LVxcXFxbMjBweFxcXFxdIHtcbiAgd2lkdGg6IDIwcHg7XG59XHJcbi53LVxcXFxbMjRweFxcXFxdIHtcbiAgd2lkdGg6IDI0cHg7XG59XHJcbi53LVxcXFxbMzU1cHhcXFxcXSB7XG4gIHdpZHRoOiAzNTVweDtcbn1cclxuLnctXFxcXFszOTBweFxcXFxdIHtcbiAgd2lkdGg6IDM5MHB4O1xufVxyXG4udy1cXFxcWzYycHhcXFxcXSB7XG4gIHdpZHRoOiA2MnB4O1xufVxyXG4udy1cXFxcWzczNXB4XFxcXF0ge1xuICB3aWR0aDogNzM1cHg7XG59XHJcbi53LWZpdCB7XG4gIHdpZHRoOiAtbW96LWZpdC1jb250ZW50O1xuICB3aWR0aDogZml0LWNvbnRlbnQ7XG59XHJcbi53LWZ1bGwge1xuICB3aWR0aDogMTAwJTtcbn1cclxuLm1pbi13LVxcXFxbMTQ3cHhcXFxcXSB7XG4gIG1pbi13aWR0aDogMTQ3cHg7XG59XHJcbi5tYXgtdy1cXFxcWzEzNDJweFxcXFxdIHtcbiAgbWF4LXdpZHRoOiAxMzQycHg7XG59XHJcbi5tYXgtdy1cXFxcWzE0NDBweFxcXFxdIHtcbiAgbWF4LXdpZHRoOiAxNDQwcHg7XG59XHJcbi5tYXgtdy1cXFxcWzE5MHB4XFxcXF0ge1xuICBtYXgtd2lkdGg6IDE5MHB4O1xufVxyXG4ubWF4LXctXFxcXFsyNTBweFxcXFxdIHtcbiAgbWF4LXdpZHRoOiAyNTBweDtcbn1cclxuLm1heC13LVxcXFxbMjUycHhcXFxcXSB7XG4gIG1heC13aWR0aDogMjUycHg7XG59XHJcbi5tYXgtdy1cXFxcWzI4MXB4XFxcXF0ge1xuICBtYXgtd2lkdGg6IDI4MXB4O1xufVxyXG4ubWF4LXctXFxcXFszOThweFxcXFxdIHtcbiAgbWF4LXdpZHRoOiAzOThweDtcbn1cclxuLm1heC13LVxcXFxbNDM4cHhcXFxcXSB7XG4gIG1heC13aWR0aDogNDM4cHg7XG59XHJcbi5tYXgtdy1cXFxcWzczMHB4XFxcXF0ge1xuICBtYXgtd2lkdGg6IDczMHB4O1xufVxyXG4ubWF4LXctXFxcXFs3MzVweFxcXFxdIHtcbiAgbWF4LXdpZHRoOiA3MzVweDtcbn1cclxuLm1heC13LVxcXFxbY2FsY1xcXFwoMTI3NXB4XFxcXCszOXB4XFxcXClcXFxcXSB7XG4gIG1heC13aWR0aDogY2FsYygxMjc1cHggKyAzOXB4KTtcbn1cclxuLm1heC13LWZ1bGwge1xuICBtYXgtd2lkdGg6IDEwMCU7XG59XHJcbi5mbGV4LXNocmluayB7XG4gIGZsZXgtc2hyaW5rOiAxO1xufVxyXG4uYm9yZGVyLWNvbGxhcHNlIHtcbiAgYm9yZGVyLWNvbGxhcHNlOiBjb2xsYXBzZTtcbn1cclxuLnRyYW5zbGF0ZS14LVxcXFxbMTUwXFxcXCVcXFxcXSB7XG4gIC0tdHctdHJhbnNsYXRlLXg6IDE1MCU7XG4gIHRyYW5zZm9ybTogdHJhbnNsYXRlKHZhcigtLXR3LXRyYW5zbGF0ZS14KSwgdmFyKC0tdHctdHJhbnNsYXRlLXkpKSByb3RhdGUodmFyKC0tdHctcm90YXRlKSkgc2tld1godmFyKC0tdHctc2tldy14KSkgc2tld1kodmFyKC0tdHctc2tldy15KSkgc2NhbGVYKHZhcigtLXR3LXNjYWxlLXgpKSBzY2FsZVkodmFyKC0tdHctc2NhbGUteSkpO1xufVxyXG4udHJhbnNsYXRlLXktXFxcXFswcHhcXFxcXSB7XG4gIC0tdHctdHJhbnNsYXRlLXk6IDBweDtcbiAgdHJhbnNmb3JtOiB0cmFuc2xhdGUodmFyKC0tdHctdHJhbnNsYXRlLXgpLCB2YXIoLS10dy10cmFuc2xhdGUteSkpIHJvdGF0ZSh2YXIoLS10dy1yb3RhdGUpKSBza2V3WCh2YXIoLS10dy1za2V3LXgpKSBza2V3WSh2YXIoLS10dy1za2V3LXkpKSBzY2FsZVgodmFyKC0tdHctc2NhbGUteCkpIHNjYWxlWSh2YXIoLS10dy1zY2FsZS15KSk7XG59XHJcbi5zY2FsZS0xMDUge1xuICAtLXR3LXNjYWxlLXg6IDEuMDU7XG4gIC0tdHctc2NhbGUteTogMS4wNTtcbiAgdHJhbnNmb3JtOiB0cmFuc2xhdGUodmFyKC0tdHctdHJhbnNsYXRlLXgpLCB2YXIoLS10dy10cmFuc2xhdGUteSkpIHJvdGF0ZSh2YXIoLS10dy1yb3RhdGUpKSBza2V3WCh2YXIoLS10dy1za2V3LXgpKSBza2V3WSh2YXIoLS10dy1za2V3LXkpKSBzY2FsZVgodmFyKC0tdHctc2NhbGUteCkpIHNjYWxlWSh2YXIoLS10dy1zY2FsZS15KSk7XG59XHJcbi50cmFuc2Zvcm0ge1xuICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSh2YXIoLS10dy10cmFuc2xhdGUteCksIHZhcigtLXR3LXRyYW5zbGF0ZS15KSkgcm90YXRlKHZhcigtLXR3LXJvdGF0ZSkpIHNrZXdYKHZhcigtLXR3LXNrZXcteCkpIHNrZXdZKHZhcigtLXR3LXNrZXcteSkpIHNjYWxlWCh2YXIoLS10dy1zY2FsZS14KSkgc2NhbGVZKHZhcigtLXR3LXNjYWxlLXkpKTtcbn1cclxuLnJlc2l6ZSB7XG4gIHJlc2l6ZTogYm90aDtcbn1cclxuLmZsZXgtcm93IHtcbiAgZmxleC1kaXJlY3Rpb246IHJvdztcbn1cclxuLmZsZXgtY29sIHtcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbn1cclxuLmZsZXgtY29sLXJldmVyc2Uge1xuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uLXJldmVyc2U7XG59XHJcbi5pdGVtcy1zdGFydCB7XG4gIGFsaWduLWl0ZW1zOiBmbGV4LXN0YXJ0O1xufVxyXG4uaXRlbXMtY2VudGVyIHtcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbn1cclxuLmp1c3RpZnktc3RhcnQge1xuICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtc3RhcnQ7XG59XHJcbi5qdXN0aWZ5LWVuZCB7XG4gIGp1c3RpZnktY29udGVudDogZmxleC1lbmQ7XG59XHJcbi5qdXN0aWZ5LWNlbnRlciB7XG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xufVxyXG4uanVzdGlmeS1iZXR3ZWVuIHtcbiAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xufVxyXG4uZ2FwLVxcXFxbMTZweFxcXFxdIHtcbiAgZ2FwOiAxNnB4O1xufVxyXG4uZ2FwLVxcXFxbMjRweFxcXFxdIHtcbiAgZ2FwOiAyNHB4O1xufVxyXG4uZ2FwLVxcXFxbMjhweFxcXFxdIHtcbiAgZ2FwOiAyOHB4O1xufVxyXG4uZ2FwLVxcXFxbMzJweFxcXFxdIHtcbiAgZ2FwOiAzMnB4O1xufVxyXG4uZ2FwLVxcXFxbMzlweFxcXFxdIHtcbiAgZ2FwOiAzOXB4O1xufVxyXG4uZ2FwLVxcXFxbNDBweFxcXFxdIHtcbiAgZ2FwOiA0MHB4O1xufVxyXG4uZ2FwLVxcXFxbNDhweFxcXFxdIHtcbiAgZ2FwOiA0OHB4O1xufVxyXG4uZ2FwLVxcXFxbNTFweFxcXFxdIHtcbiAgZ2FwOiA1MXB4O1xufVxyXG4uZ2FwLVxcXFxbMTVweFxcXFxdIHtcbiAgZ2FwOiAxNXB4O1xufVxyXG4uZ2FwLVxcXFxbMjBweFxcXFxdIHtcbiAgZ2FwOiAyMHB4O1xufVxyXG4uc2VsZi1hdXRvIHtcbiAgYWxpZ24tc2VsZjogYXV0bztcbn1cclxuLnNlbGYtc3RhcnQge1xuICBhbGlnbi1zZWxmOiBmbGV4LXN0YXJ0O1xufVxyXG4uc2VsZi1lbmQge1xuICBhbGlnbi1zZWxmOiBmbGV4LWVuZDtcbn1cclxuLm92ZXJmbG93LXgtY2xpcCB7XG4gIG92ZXJmbG93LXg6IGNsaXA7XG59XHJcbi5yb3VuZGVkIHtcbiAgYm9yZGVyLXJhZGl1czogMC4yNXJlbTtcbn1cclxuLmJvcmRlciB7XG4gIGJvcmRlci13aWR0aDogMXB4O1xufVxyXG4uYmctXFxcXFtcXFxcIzE5MTkyMVxcXFxdIHtcbiAgLS10dy1iZy1vcGFjaXR5OiAxO1xuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMjUgMjUgMzMgLyB2YXIoLS10dy1iZy1vcGFjaXR5KSk7XG59XHJcbi5iZy1cXFxcW1xcXFwjRjk0RjRGXFxcXF0ge1xuICAtLXR3LWJnLW9wYWNpdHk6IDE7XG4gIGJhY2tncm91bmQtY29sb3I6IHJnYigyNDkgNzkgNzkgLyB2YXIoLS10dy1iZy1vcGFjaXR5KSk7XG59XHJcbi5iZy1ibGFjayB7XG4gIC0tdHctYmctb3BhY2l0eTogMTtcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDAgMCAwIC8gdmFyKC0tdHctYmctb3BhY2l0eSkpO1xufVxyXG4uc3Ryb2tlLVxcXFxbXFxcXCNGOTRGNEZcXFxcXSB7XG4gIHN0cm9rZTogI0Y5NEY0Rjtcbn1cclxuLnN0cm9rZS1cXFxcW1xcXFwjRkY5MzkzXFxcXF0ge1xuICBzdHJva2U6ICNGRjkzOTM7XG59XHJcbi5vYmplY3QtY29udGFpbiB7XG4gIC1vLW9iamVjdC1maXQ6IGNvbnRhaW47XG4gICAgIG9iamVjdC1maXQ6IGNvbnRhaW47XG59XHJcbi5vYmplY3QtY292ZXIge1xuICAtby1vYmplY3QtZml0OiBjb3ZlcjtcbiAgICAgb2JqZWN0LWZpdDogY292ZXI7XG59XHJcbi5vYmplY3QtZmlsbCB7XG4gIC1vLW9iamVjdC1maXQ6IGZpbGw7XG4gICAgIG9iamVjdC1maXQ6IGZpbGw7XG59XHJcbi5vYmplY3Qtc2NhbGUtZG93biB7XG4gIC1vLW9iamVjdC1maXQ6IHNjYWxlLWRvd247XG4gICAgIG9iamVjdC1maXQ6IHNjYWxlLWRvd247XG59XHJcbi5vYmplY3QtXFxcXFsxMDBcXFxcJV8wXFxcXCVcXFxcXSB7XG4gIC1vLW9iamVjdC1wb3NpdGlvbjogMTAwJSAwJTtcbiAgICAgb2JqZWN0LXBvc2l0aW9uOiAxMDAlIDAlO1xufVxyXG4ub2JqZWN0LWNlbnRlciB7XG4gIC1vLW9iamVjdC1wb3NpdGlvbjogY2VudGVyO1xuICAgICBvYmplY3QtcG9zaXRpb246IGNlbnRlcjtcbn1cclxuLm9iamVjdC1yaWdodCB7XG4gIC1vLW9iamVjdC1wb3NpdGlvbjogcmlnaHQ7XG4gICAgIG9iamVjdC1wb3NpdGlvbjogcmlnaHQ7XG59XHJcbi5vYmplY3QtXFxcXFs3NVxcXFwlXFxcXF0ge1xuICAtby1vYmplY3QtcG9zaXRpb246IDc1JTtcbiAgICAgb2JqZWN0LXBvc2l0aW9uOiA3NSU7XG59XHJcbi5vYmplY3QtXFxcXFs3XFxcXCVcXFxcXSB7XG4gIC1vLW9iamVjdC1wb3NpdGlvbjogNyU7XG4gICAgIG9iamVjdC1wb3NpdGlvbjogNyU7XG59XHJcbi5vYmplY3QtXFxcXFtsZW5ndGhcXFxcOjUwXFxcXCVcXFxcXSB7XG4gIC1vLW9iamVjdC1wb3NpdGlvbjogNTAlO1xuICAgICBvYmplY3QtcG9zaXRpb246IDUwJTtcbn1cclxuLm9iamVjdC1cXFxcW2xlbmd0aFxcXFw6MzBcXFxcJVxcXFxdIHtcbiAgLW8tb2JqZWN0LXBvc2l0aW9uOiAzMCU7XG4gICAgIG9iamVjdC1wb3NpdGlvbjogMzAlO1xufVxyXG4ub2JqZWN0LVxcXFxbbGVuZ3RoXFxcXDozMFxcXFwlXzMwXFxcXCVcXFxcXSB7XG4gIC1vLW9iamVjdC1wb3NpdGlvbjogMzAlIDMwJTtcbiAgICAgb2JqZWN0LXBvc2l0aW9uOiAzMCUgMzAlO1xufVxyXG4ub2JqZWN0LXRvcCB7XG4gIC1vLW9iamVjdC1wb3NpdGlvbjogdG9wO1xuICAgICBvYmplY3QtcG9zaXRpb246IHRvcDtcbn1cclxuLm9iamVjdC1ib3R0b20ge1xuICAtby1vYmplY3QtcG9zaXRpb246IGJvdHRvbTtcbiAgICAgb2JqZWN0LXBvc2l0aW9uOiBib3R0b207XG59XHJcbi5weC0wIHtcbiAgcGFkZGluZy1sZWZ0OiAwcHg7XG4gIHBhZGRpbmctcmlnaHQ6IDBweDtcbn1cclxuLnB4LVxcXFxbMjRweFxcXFxdIHtcbiAgcGFkZGluZy1sZWZ0OiAyNHB4O1xuICBwYWRkaW5nLXJpZ2h0OiAyNHB4O1xufVxyXG4ucHgtXFxcXFs0MHB4XFxcXF0ge1xuICBwYWRkaW5nLWxlZnQ6IDQwcHg7XG4gIHBhZGRpbmctcmlnaHQ6IDQwcHg7XG59XHJcbi5weC1cXFxcWzI0XFxcXF0ge1xuICBwYWRkaW5nLWxlZnQ6IDI0O1xuICBwYWRkaW5nLXJpZ2h0OiAyNDtcbn1cclxuLnB5LVxcXFxbNzJweFxcXFxdIHtcbiAgcGFkZGluZy10b3A6IDcycHg7XG4gIHBhZGRpbmctYm90dG9tOiA3MnB4O1xufVxyXG4ucHktMCB7XG4gIHBhZGRpbmctdG9wOiAwcHg7XG4gIHBhZGRpbmctYm90dG9tOiAwcHg7XG59XHJcbi5wbC0wIHtcbiAgcGFkZGluZy1sZWZ0OiAwcHg7XG59XHJcbi5wbC1cXFxcWzMzcHhcXFxcXSB7XG4gIHBhZGRpbmctbGVmdDogMzNweDtcbn1cclxuLnBsLVxcXFxbMzlweFxcXFxdIHtcbiAgcGFkZGluZy1sZWZ0OiAzOXB4O1xufVxyXG4ucGwtXFxcXFs0MHB4XFxcXF0ge1xuICBwYWRkaW5nLWxlZnQ6IDQwcHg7XG59XHJcbi5wbC1cXFxcWzY5cHhcXFxcXSB7XG4gIHBhZGRpbmctbGVmdDogNjlweDtcbn1cclxuLnByLTAge1xuICBwYWRkaW5nLXJpZ2h0OiAwcHg7XG59XHJcbi5wci1cXFxcWzQwcHhcXFxcXSB7XG4gIHBhZGRpbmctcmlnaHQ6IDQwcHg7XG59XHJcbi5wdC1cXFxcWzMycHhcXFxcXSB7XG4gIHBhZGRpbmctdG9wOiAzMnB4O1xufVxyXG4udGV4dC1jZW50ZXIge1xuICB0ZXh0LWFsaWduOiBjZW50ZXI7XG59XHJcbi50ZXh0LXN0YXJ0IHtcbiAgdGV4dC1hbGlnbjogc3RhcnQ7XG59XHJcbi50ZXh0LWVuZCB7XG4gIHRleHQtYWxpZ246IGVuZDtcbn1cclxuLmZvbnQtY29tbWlzc2lvbmVyIHtcbiAgZm9udC1mYW1pbHk6IFwiQ29tbWlzc2lvbmVyXCIsIHNhbnMtc2VyaWY7XG59XHJcbi50ZXh0LVxcXFxbMTVweFxcXFxdIHtcbiAgZm9udC1zaXplOiAxNXB4O1xufVxyXG4udGV4dC1cXFxcWzE2cHhcXFxcXSB7XG4gIGZvbnQtc2l6ZTogMTZweDtcbn1cclxuLnRleHQtXFxcXFsxOHB4XFxcXF0ge1xuICBmb250LXNpemU6IDE4cHg7XG59XHJcbi50ZXh0LVxcXFxbMjBweFxcXFxdIHtcbiAgZm9udC1zaXplOiAyMHB4O1xufVxyXG4udGV4dC1cXFxcWzMycHhcXFxcXSB7XG4gIGZvbnQtc2l6ZTogMzJweDtcbn1cclxuLnRleHQtXFxcXFs0MHB4XFxcXF0ge1xuICBmb250LXNpemU6IDQwcHg7XG59XHJcbi50ZXh0LVxcXFxbODBweFxcXFxdIHtcbiAgZm9udC1zaXplOiA4MHB4O1xufVxyXG4uZm9udC1leHRyYWJvbGQge1xuICBmb250LXdlaWdodDogODAwO1xufVxyXG4ubGVhZGluZy1cXFxcWzI1cHhcXFxcXSB7XG4gIGxpbmUtaGVpZ2h0OiAyNXB4O1xufVxyXG4ubGVhZGluZy1cXFxcWzMycHhcXFxcXSB7XG4gIGxpbmUtaGVpZ2h0OiAzMnB4O1xufVxyXG4ubGVhZGluZy1cXFxcWzQwcHhcXFxcXSB7XG4gIGxpbmUtaGVpZ2h0OiA0MHB4O1xufVxyXG4ubGVhZGluZy1cXFxcWzg4cHhcXFxcXSB7XG4gIGxpbmUtaGVpZ2h0OiA4OHB4O1xufVxyXG4udGV4dC1cXFxcW1xcXFwjRjk0RjRGXFxcXF0ge1xuICAtLXR3LXRleHQtb3BhY2l0eTogMTtcbiAgY29sb3I6IHJnYigyNDkgNzkgNzkgLyB2YXIoLS10dy10ZXh0LW9wYWNpdHkpKTtcbn1cclxuLnRleHQtd2hpdGUge1xuICAtLXR3LXRleHQtb3BhY2l0eTogMTtcbiAgY29sb3I6IHJnYigyNTUgMjU1IDI1NSAvIHZhcigtLXR3LXRleHQtb3BhY2l0eSkpO1xufVxyXG4udGV4dC13aGl0ZVxcXFwvMjUge1xuICBjb2xvcjogcmdiKDI1NSAyNTUgMjU1IC8gMC4yNSk7XG59XHJcbi51bmRlcmxpbmUge1xuICB0ZXh0LWRlY29yYXRpb24tbGluZTogdW5kZXJsaW5lO1xufVxyXG4ub3ZlcmxpbmUge1xuICB0ZXh0LWRlY29yYXRpb24tbGluZTogb3ZlcmxpbmU7XG59XHJcbi51bmRlcmxpbmUtb2Zmc2V0LVxcXFxbMTJweFxcXFxdIHtcbiAgdGV4dC11bmRlcmxpbmUtb2Zmc2V0OiAxMnB4O1xufVxyXG4ub3BhY2l0eS0wIHtcbiAgb3BhY2l0eTogMDtcbn1cclxuLm91dGxpbmUge1xuICBvdXRsaW5lLXN0eWxlOiBzb2xpZDtcbn1cclxuLmZpbHRlciB7XG4gIGZpbHRlcjogdmFyKC0tdHctYmx1cikgdmFyKC0tdHctYnJpZ2h0bmVzcykgdmFyKC0tdHctY29udHJhc3QpIHZhcigtLXR3LWdyYXlzY2FsZSkgdmFyKC0tdHctaHVlLXJvdGF0ZSkgdmFyKC0tdHctaW52ZXJ0KSB2YXIoLS10dy1zYXR1cmF0ZSkgdmFyKC0tdHctc2VwaWEpIHZhcigtLXR3LWRyb3Atc2hhZG93KTtcbn1cclxuLnRyYW5zaXRpb24ge1xuICB0cmFuc2l0aW9uLXByb3BlcnR5OiBjb2xvciwgYmFja2dyb3VuZC1jb2xvciwgYm9yZGVyLWNvbG9yLCB0ZXh0LWRlY29yYXRpb24tY29sb3IsIGZpbGwsIHN0cm9rZSwgb3BhY2l0eSwgYm94LXNoYWRvdywgdHJhbnNmb3JtLCBmaWx0ZXIsIC13ZWJraXQtYmFja2Ryb3AtZmlsdGVyO1xuICB0cmFuc2l0aW9uLXByb3BlcnR5OiBjb2xvciwgYmFja2dyb3VuZC1jb2xvciwgYm9yZGVyLWNvbG9yLCB0ZXh0LWRlY29yYXRpb24tY29sb3IsIGZpbGwsIHN0cm9rZSwgb3BhY2l0eSwgYm94LXNoYWRvdywgdHJhbnNmb3JtLCBmaWx0ZXIsIGJhY2tkcm9wLWZpbHRlcjtcbiAgdHJhbnNpdGlvbi1wcm9wZXJ0eTogY29sb3IsIGJhY2tncm91bmQtY29sb3IsIGJvcmRlci1jb2xvciwgdGV4dC1kZWNvcmF0aW9uLWNvbG9yLCBmaWxsLCBzdHJva2UsIG9wYWNpdHksIGJveC1zaGFkb3csIHRyYW5zZm9ybSwgZmlsdGVyLCBiYWNrZHJvcC1maWx0ZXIsIC13ZWJraXQtYmFja2Ryb3AtZmlsdGVyO1xuICB0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbjogY3ViaWMtYmV6aWVyKDAuNCwgMCwgMC4yLCAxKTtcbiAgdHJhbnNpdGlvbi1kdXJhdGlvbjogMTUwbXM7XG59XHJcbi50cmFuc2l0aW9uLWFsbCB7XG4gIHRyYW5zaXRpb24tcHJvcGVydHk6IGFsbDtcbiAgdHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLjQsIDAsIDAuMiwgMSk7XG4gIHRyYW5zaXRpb24tZHVyYXRpb246IDE1MG1zO1xufVxyXG5cclxuaDEge1xuICBmb250LXNpemU6IDQwcHg7XG4gIGZvbnQtd2VpZ2h0OiA4MDA7XG4gIGxpbmUtaGVpZ2h0OiA0MHB4O1xufVxyXG5cclxuQG1lZGlhIChtaW4td2lkdGg6IDc2OHB4KSB7XG5cbiAgaDEge1xuICAgIGZvbnQtc2l6ZTogNTZweDtcbiAgICBsaW5lLWhlaWdodDogNTZweDtcbiAgfVxufVxyXG5cclxuQG1lZGlhIChtaW4td2lkdGg6IDEyODBweCkge1xuXG4gIGgxIHtcbiAgICBmb250LXNpemU6IDgwcHg7XG4gICAgbGluZS1oZWlnaHQ6IDg4cHg7XG4gIH1cbn1cclxuXHJcbmgyIHtcbiAgZm9udC1zaXplOiAzMnB4O1xuICBmb250LXdlaWdodDogODAwO1xuICBsaW5lLWhlaWdodDogNDBweDtcbn1cclxuXHJcbkBtZWRpYSAobWluLXdpZHRoOiAxMjgwcHgpIHtcblxuICBoMiB7XG4gICAgZm9udC1zaXplOiA1NnB4O1xuICAgIGxpbmUtaGVpZ2h0OiA2NHB4O1xuICB9XG59XHJcblxyXG5oMyB7XG4gIGZvbnQtc2l6ZTogMjBweDtcbiAgZm9udC13ZWlnaHQ6IDgwMDtcbiAgbGluZS1oZWlnaHQ6IDMycHg7XG59XHJcblxyXG5wIHtcbiAgZm9udC1zaXplOiAxNXB4O1xuICBsaW5lLWhlaWdodDogMjVweDtcbn1cclxuXHJcbkBtZWRpYSAobWluLXdpZHRoOiAxMjgwcHgpIHtcblxuICBwIHtcbiAgICBmb250LXNpemU6IDE4cHg7XG4gICAgbGluZS1oZWlnaHQ6IDMycHg7XG4gIH1cbn1cclxuXHJcbmEge1xuICBmb250LXNpemU6IDE1cHg7XG59XHJcblxyXG5AbWVkaWEgKG1pbi13aWR0aDogMTI4MHB4KSB7XG5cbiAgYSB7XG4gICAgZm9udC1zaXplOiAxNnB4O1xuICB9XG59XHJcblxyXG4ucHJldmlvdXMsXHJcbi5uZXh0IHtcbiAgc3Ryb2tlOiAjRjk0RjRGO1xuICB0cmFuc2l0aW9uLXByb3BlcnR5OiBhbGw7XG4gIHRyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uOiBjdWJpYy1iZXppZXIoMC40LCAwLCAwLjIsIDEpO1xuICB0cmFuc2l0aW9uLWR1cmF0aW9uOiAxNTBtcztcbn1cclxuLnByZXZpb3VzOmhvdmVyLFxyXG4ubmV4dDpob3ZlciB7XG4gIHN0cm9rZTogI0ZGOTM5Mztcbn1cclxuXHJcbi5wYW5lbCB7XHJcbiAgd2lkdGg6IDEwMCU7XHJcbiAgaGVpZ2h0OiAxMDAlO1xyXG4gIGRpc3BsYXk6IGZsZXg7XHJcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcclxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcclxuICBmb250LXNpemU6IDI0cHg7XHJcbn1cclxuXHJcbi5pbWFnZS1jb250YWluZXI6aG92ZXIge1xuICBjdXJzb3I6IGdyYWI7XG59XHJcblxyXG4uaW1hZ2UtY29udGFpbmVyOmFjdGl2ZSB7XG4gIGN1cnNvcjogZ3JhYmJpbmc7XG59XHJcblxyXG4uaW1hZ2UtY29udGFpbmVyIHtcclxuICBwb3NpdGlvbjogcmVsYXRpdmU7XHJcbn1cclxuXHJcbi5jYXJvdXNlbEltYWdlIHtcbiAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gIGhlaWdodDogNDcycHg7XG4gIHdpZHRoOiAxMDAlO1xuICAtby1vYmplY3QtZml0OiBjb3ZlcjtcbiAgICAgb2JqZWN0LWZpdDogY292ZXI7XG4gIC1vLW9iamVjdC1wb3NpdGlvbjogcmlnaHQ7XG4gICAgIG9iamVjdC1wb3NpdGlvbjogcmlnaHQ7XG59XHJcblxyXG5AbWVkaWEgKG1pbi13aWR0aDogMTI4MHB4KSB7XG5cbiAgLmNhcm91c2VsSW1hZ2Uge1xuICAgIGhlaWdodDogMTAwJTtcbiAgfVxufVxyXG5cclxuLmFuaW1hdGlvbkVsZW1lbnQge1xuICB0cmFuc2l0aW9uLXByb3BlcnR5OiB0cmFuc2Zvcm07XG4gIHRyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uOiBjdWJpYy1iZXppZXIoMC40LCAwLCAwLjIsIDEpO1xuICB0cmFuc2l0aW9uLWR1cmF0aW9uOiAxNTBtcztcbn1cclxuXHJcbi5hbmltYXRpb25FbGVtZW50LmFuaW1hdGVUcmFuc2l0aW9uIHtcbiAgLS10dy10cmFuc2xhdGUteTogMHB4O1xuICAtLXR3LXNjYWxlLXg6IDEuMDU7XG4gIC0tdHctc2NhbGUteTogMS4wNTtcbiAgdHJhbnNmb3JtOiB0cmFuc2xhdGUodmFyKC0tdHctdHJhbnNsYXRlLXgpLCB2YXIoLS10dy10cmFuc2xhdGUteSkpIHJvdGF0ZSh2YXIoLS10dy1yb3RhdGUpKSBza2V3WCh2YXIoLS10dy1za2V3LXgpKSBza2V3WSh2YXIoLS10dy1za2V3LXkpKSBzY2FsZVgodmFyKC0tdHctc2NhbGUteCkpIHNjYWxlWSh2YXIoLS10dy1zY2FsZS15KSk7XG59XHJcblxyXG4uYW5pbWF0aW9uRWxlbWVudCB7XG4gIHRyYW5zaXRpb24tZHVyYXRpb246IDUwMG1zO1xufVxyXG5cclxuLmltYWdlLWNvbnRhaW5lcjo6YWZ0ZXIge1xuICBoZWlnaHQ6IDIwMHB4O1xuICB3aWR0aDogMTAwJTtcclxuICBjb250ZW50OiAnJztcclxuICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbiAgYm90dG9tOiAwO1xyXG4gIGxlZnQ6IDA7XHJcbiAgYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KHRvIGJvdHRvbSwgcmdiYSgwLCAwLCAwLCAwKSAwJSwgcmdiYSgwLCAwLCAwLCAwLjUpIDEwMCUpO1xyXG4gIHBvaW50ZXItZXZlbnRzOiBub25lO1xufVxyXG5cclxuI21vYmlsZU5hdiB7XG4gIGhlaWdodDogMThweDtcbiAgd2lkdGg6IDI0cHg7XHJcbiAgYmFja2dyb3VuZC1pbWFnZTogdXJsKCR7X19fQ1NTX0xPQURFUl9VUkxfUkVQTEFDRU1FTlRfMF9fX30pO1xufVxyXG5cclxuI21hc2sge1xuICBwb2ludGVyLWV2ZW50czogbm9uZTtcbn1cclxuXHJcbiNtb2JpbGVOYXYub3BlbiB7XG4gIGhlaWdodDogMjBweDtcbiAgd2lkdGg6IDIwcHg7XHJcbiAgYmFja2dyb3VuZC1pbWFnZTogdXJsKCR7X19fQ1NTX0xPQURFUl9VUkxfUkVQTEFDRU1FTlRfMV9fX30pO1xufVxyXG5cclxuYm9keTpoYXMoI21vYmlsZU5hdi5vcGVuKSAjbW9iaWxlTWVudSB7XG4gIC0tdHctdHJhbnNsYXRlLXg6IDBweDtcbiAgdHJhbnNmb3JtOiB0cmFuc2xhdGUodmFyKC0tdHctdHJhbnNsYXRlLXgpLCB2YXIoLS10dy10cmFuc2xhdGUteSkpIHJvdGF0ZSh2YXIoLS10dy1yb3RhdGUpKSBza2V3WCh2YXIoLS10dy1za2V3LXgpKSBza2V3WSh2YXIoLS10dy1za2V3LXkpKSBzY2FsZVgodmFyKC0tdHctc2NhbGUteCkpIHNjYWxlWSh2YXIoLS10dy1zY2FsZS15KSk7XG59XHJcblxyXG4jbW9iaWxlTWVudSB7XHJcbiAgdHJhbnNpdGlvbjogYWxsIDAuNXMgZWFzZSAwcztcclxuICBkaXNwbGF5OiBmbGV4O1xyXG4gIC0tdHctdHJhbnNsYXRlLXg6IDE1MCU7XHJcbiAgdHJhbnNmb3JtOiB0cmFuc2xhdGUodmFyKC0tdHctdHJhbnNsYXRlLXgpLCB2YXIoLS10dy10cmFuc2xhdGUteSkpIHJvdGF0ZSh2YXIoLS10dy1yb3RhdGUpKSBza2V3WCh2YXIoLS10dy1za2V3LXgpKSBza2V3WSh2YXIoLS10dy1za2V3LXkpKSBzY2FsZVgodmFyKC0tdHctc2NhbGUteCkpIHNjYWxlWSh2YXIoLS10dy1zY2FsZS15KSk7XHJcbn1cclxuXHJcbkBtZWRpYSAobWluLXdpZHRoOiA3NjhweCkge1xuXG4gICNtb2JpbGVNZW51IHtcbiAgICBkaXNwbGF5OiBub25lO1xuICB9XG59XHJcblxyXG5AbWVkaWEgKG1heC13aWR0aDogNzY4cHgpIHtcclxuICBib2R5OmhhcygjbW9iaWxlTWVudS5vcGVuKSAjbW9iaWxlTWVudUxpc3Qge1xuICAgIHBvaW50ZXItZXZlbnRzOiBhdXRvO1xuICB9XHJcblxyXG4gIGJvZHk6aGFzKCNtb2JpbGVOYXYub3BlbikgI21hc2sge1xuICAgIHBvaW50ZXItZXZlbnRzOiBhdXRvO1xuICB9XHJcblxyXG4gIGJvZHk6aGFzKCNtb2JpbGVOYXYub3Blbikge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgbWluLWhlaWdodDogMTAwdmg7XG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgfVxyXG59XHJcblxyXG4uaG92ZXJcXFxcOmN1cnNvci1ncmFiOmhvdmVyIHtcbiAgY3Vyc29yOiBncmFiO1xufVxyXG5cclxuLmhvdmVyXFxcXDpiZy1cXFxcW1xcXFwjNDM0MzU2XFxcXF06aG92ZXIge1xuICAtLXR3LWJnLW9wYWNpdHk6IDE7XG4gIGJhY2tncm91bmQtY29sb3I6IHJnYig2NyA2NyA4NiAvIHZhcigtLXR3LWJnLW9wYWNpdHkpKTtcbn1cclxuXHJcbi5ob3ZlclxcXFw6YmctXFxcXFtcXFxcI0ZGOTM5M1xcXFxdOmhvdmVyIHtcbiAgLS10dy1iZy1vcGFjaXR5OiAxO1xuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMjU1IDE0NyAxNDcgLyB2YXIoLS10dy1iZy1vcGFjaXR5KSk7XG59XHJcblxyXG4uaG92ZXJcXFxcOmZvbnQtYm9sZDpob3ZlciB7XG4gIGZvbnQtd2VpZ2h0OiA3MDA7XG59XHJcblxyXG4uaG92ZXJcXFxcOnRleHQtXFxcXFtcXFxcI0ZGOTM5M1xcXFxdOmhvdmVyIHtcbiAgLS10dy10ZXh0LW9wYWNpdHk6IDE7XG4gIGNvbG9yOiByZ2IoMjU1IDE0NyAxNDcgLyB2YXIoLS10dy10ZXh0LW9wYWNpdHkpKTtcbn1cclxuXHJcbkBtZWRpYSAobWluLXdpZHRoOiA3NjhweCkge1xuXG4gIC5tZFxcXFw6YWJzb2x1dGUge1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgfVxuXG4gIC5tZFxcXFw6cmVsYXRpdmUge1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgfVxuXG4gIC5tZFxcXFw6bGVmdC1cXFxcWy0zMXB4XFxcXF0ge1xuICAgIGxlZnQ6IC0zMXB4O1xuICB9XG5cbiAgLm1kXFxcXDp0b3AtXFxcXFsyMjBweFxcXFxdIHtcbiAgICB0b3A6IDIyMHB4O1xuICB9XG5cbiAgLm1kXFxcXDptdC1cXFxcWzc3cHhcXFxcXSB7XG4gICAgbWFyZ2luLXRvcDogNzdweDtcbiAgfVxuXG4gIC5tZFxcXFw6bXQtXFxcXFstMTIwcHhcXFxcXSB7XG4gICAgbWFyZ2luLXRvcDogLTEyMHB4O1xuICB9XG5cbiAgLm1kXFxcXDptYi0wIHtcbiAgICBtYXJnaW4tYm90dG9tOiAwcHg7XG4gIH1cblxuICAubWRcXFxcOmZsZXgge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gIH1cblxuICAubWRcXFxcOmhpZGRlbiB7XG4gICAgZGlzcGxheTogbm9uZTtcbiAgfVxuXG4gIC5tZFxcXFw6aC1cXFxcWzE3OHB4XFxcXF0ge1xuICAgIGhlaWdodDogMTc4cHg7XG4gIH1cblxuICAubWRcXFxcOmgtXFxcXFs2MDZweFxcXFxdIHtcbiAgICBoZWlnaHQ6IDYwNnB4O1xuICB9XG5cbiAgLm1kXFxcXDpoLVxcXFxbNjA4cHhcXFxcXSB7XG4gICAgaGVpZ2h0OiA2MDhweDtcbiAgfVxuXG4gIC5tZFxcXFw6aC1cXFxcWzY1OHB4XFxcXF0ge1xuICAgIGhlaWdodDogNjU4cHg7XG4gIH1cblxuICAubWRcXFxcOmgtXFxcXFs2NDhweFxcXFxdIHtcbiAgICBoZWlnaHQ6IDY0OHB4O1xuICB9XG5cbiAgLm1kXFxcXDpoLVxcXFxbNTM4cHhcXFxcXSB7XG4gICAgaGVpZ2h0OiA1MzhweDtcbiAgfVxuXG4gIC5tZFxcXFw6bWluLWgtc2NyZWVuIHtcbiAgICBtaW4taGVpZ2h0OiAxMDB2aDtcbiAgfVxuXG4gIC5tZFxcXFw6dy1maXQge1xuICAgIHdpZHRoOiAtbW96LWZpdC1jb250ZW50O1xuICAgIHdpZHRoOiBmaXQtY29udGVudDtcbiAgfVxuXG4gIC5tZFxcXFw6dy1cXFxcWzczNXB4XFxcXF0ge1xuICAgIHdpZHRoOiA3MzVweDtcbiAgfVxuXG4gIC5tZFxcXFw6dy1mdWxsIHtcbiAgICB3aWR0aDogMTAwJTtcbiAgfVxuXG4gIC5tZFxcXFw6dy1cXFxcWzM5MHB4XFxcXF0ge1xuICAgIHdpZHRoOiAzOTBweDtcbiAgfVxuXG4gIC5tZFxcXFw6bWF4LXctXFxcXFszOThweFxcXFxdIHtcbiAgICBtYXgtd2lkdGg6IDM5OHB4O1xuICB9XG5cbiAgLm1kXFxcXDptYXgtdy1cXFxcWzI4MXB4XFxcXF0ge1xuICAgIG1heC13aWR0aDogMjgxcHg7XG4gIH1cblxuICAubWRcXFxcOm1heC13LVxcXFxbMjUwcHhcXFxcXSB7XG4gICAgbWF4LXdpZHRoOiAyNTBweDtcbiAgfVxuXG4gIC5tZFxcXFw6ZmxleC1yb3cge1xuICAgIGZsZXgtZGlyZWN0aW9uOiByb3c7XG4gIH1cblxuICAubWRcXFxcOml0ZW1zLXN0YXJ0IHtcbiAgICBhbGlnbi1pdGVtczogZmxleC1zdGFydDtcbiAgfVxuXG4gIC5tZFxcXFw6anVzdGlmeS1lbmQge1xuICAgIGp1c3RpZnktY29udGVudDogZmxleC1lbmQ7XG4gIH1cblxuICAubWRcXFxcOmdhcC1cXFxcWzM5cHhcXFxcXSB7XG4gICAgZ2FwOiAzOXB4O1xuICB9XG5cbiAgLm1kXFxcXDpnYXAtXFxcXFs0OHB4XFxcXF0ge1xuICAgIGdhcDogNDhweDtcbiAgfVxuXG4gIC5tZFxcXFw6c2VsZi1lbmQge1xuICAgIGFsaWduLXNlbGY6IGZsZXgtZW5kO1xuICB9XG5cbiAgLm1kXFxcXDpvYmplY3QtXFxcXFsxMDBcXFxcJV8wXFxcXCVcXFxcXSB7XG4gICAgLW8tb2JqZWN0LXBvc2l0aW9uOiAxMDAlIDAlO1xuICAgICAgIG9iamVjdC1wb3NpdGlvbjogMTAwJSAwJTtcbiAgfVxuXG4gIC5tZFxcXFw6cHgtMCB7XG4gICAgcGFkZGluZy1sZWZ0OiAwcHg7XG4gICAgcGFkZGluZy1yaWdodDogMHB4O1xuICB9XG5cbiAgLm1kXFxcXDpweS0wIHtcbiAgICBwYWRkaW5nLXRvcDogMHB4O1xuICAgIHBhZGRpbmctYm90dG9tOiAwcHg7XG4gIH1cblxuICAubWRcXFxcOnBsLVxcXFxbMzlweFxcXFxdIHtcbiAgICBwYWRkaW5nLWxlZnQ6IDM5cHg7XG4gIH1cblxuICAubWRcXFxcOnBsLVxcXFxbNjlweFxcXFxdIHtcbiAgICBwYWRkaW5nLWxlZnQ6IDY5cHg7XG4gIH1cblxuICAubWRcXFxcOnByLVxcXFxbNDBweFxcXFxdIHtcbiAgICBwYWRkaW5nLXJpZ2h0OiA0MHB4O1xuICB9XG5cbiAgLm1kXFxcXDp0ZXh0LXN0YXJ0IHtcbiAgICB0ZXh0LWFsaWduOiBzdGFydDtcbiAgfVxuXG4gIC5tZFxcXFw6dGV4dC1cXFxcWzU2cHhcXFxcXSB7XG4gICAgZm9udC1zaXplOiA1NnB4O1xuICB9XG5cbiAgLm1kXFxcXDpsZWFkaW5nLVxcXFxbNTZweFxcXFxdIHtcbiAgICBsaW5lLWhlaWdodDogNTZweDtcbiAgfVxuXG4gIC5tZFxcXFw6b3BhY2l0eS0wIHtcbiAgICBvcGFjaXR5OiAwO1xuICB9XG59XHJcblxyXG5AbWVkaWEgKG1pbi13aWR0aDogMTAyNHB4KSB7XG5cbiAgLmxnXFxcXDptdC0wIHtcbiAgICBtYXJnaW4tdG9wOiAwcHg7XG4gIH1cblxuICAubGdcXFxcOm10LVxcXFxbLTIwMHB4XFxcXF0ge1xuICAgIG1hcmdpbi10b3A6IC0yMDBweDtcbiAgfVxuXG4gIC5sZ1xcXFw6aC1cXFxcWzU2MHB4XFxcXF0ge1xuICAgIGhlaWdodDogNTYwcHg7XG4gIH1cblxuICAubGdcXFxcOmgtXFxcXFs3NTBweFxcXFxdIHtcbiAgICBoZWlnaHQ6IDc1MHB4O1xuICB9XG5cbiAgLmxnXFxcXDpoLVxcXFxbNjU4cHhcXFxcXSB7XG4gICAgaGVpZ2h0OiA2NThweDtcbiAgfVxuXG4gIC5sZ1xcXFw6dy1cXFxcWzUzMHB4XFxcXF0ge1xuICAgIHdpZHRoOiA1MzBweDtcbiAgfVxuXG4gIC5sZ1xcXFw6dy1cXFxcWzczNXB4XFxcXF0ge1xuICAgIHdpZHRoOiA3MzVweDtcbiAgfVxuXG4gIC5sZ1xcXFw6bWF4LXctXFxcXFs1MzBweFxcXFxdIHtcbiAgICBtYXgtd2lkdGg6IDUzMHB4O1xuICB9XG5cbiAgLmxnXFxcXDptYXgtdy1mdWxsIHtcbiAgICBtYXgtd2lkdGg6IDEwMCU7XG4gIH1cblxuICAubGdcXFxcOmdhcC1cXFxcWzUwcHhcXFxcXSB7XG4gICAgZ2FwOiA1MHB4O1xuICB9XG5cbiAgLmxnXFxcXDpvYmplY3QtY292ZXIge1xuICAgIC1vLW9iamVjdC1maXQ6IGNvdmVyO1xuICAgICAgIG9iamVjdC1maXQ6IGNvdmVyO1xuICB9XG5cbiAgLmxnXFxcXDpvYmplY3QtXFxcXFsxMDBcXFxcJV8wXFxcXCVcXFxcXSB7XG4gICAgLW8tb2JqZWN0LXBvc2l0aW9uOiAxMDAlIDAlO1xuICAgICAgIG9iamVjdC1wb3NpdGlvbjogMTAwJSAwJTtcbiAgfVxuXG4gIC5sZ1xcXFw6cHgtMCB7XG4gICAgcGFkZGluZy1sZWZ0OiAwcHg7XG4gICAgcGFkZGluZy1yaWdodDogMHB4O1xuICB9XG5cbiAgLmxnXFxcXDpwbC1cXFxcWzkwcHhcXFxcXSB7XG4gICAgcGFkZGluZy1sZWZ0OiA5MHB4O1xuICB9XG5cbiAgLmxnXFxcXDpwci1cXFxcWzIwcHhcXFxcXSB7XG4gICAgcGFkZGluZy1yaWdodDogMjBweDtcbiAgfVxuXG4gIC5sZ1xcXFw6cHItXFxcXFs2MHB4XFxcXF0ge1xuICAgIHBhZGRpbmctcmlnaHQ6IDYwcHg7XG4gIH1cbn1cclxuXHJcbkBtZWRpYSAobWluLXdpZHRoOiAxMjgwcHgpIHtcblxuICAueGxcXFxcOmxlZnQtXFxcXFstNjdweFxcXFxdIHtcbiAgICBsZWZ0OiAtNjdweDtcbiAgfVxuXG4gIC54bFxcXFw6cmlnaHQtXFxcXFstNjdweFxcXFxdIHtcbiAgICByaWdodDogLTY3cHg7XG4gIH1cblxuICAueGxcXFxcOnRvcC1cXFxcWzE4NnB4XFxcXF0ge1xuICAgIHRvcDogMTg2cHg7XG4gIH1cblxuICAueGxcXFxcOnRvcC1cXFxcWzIzNHB4XFxcXF0ge1xuICAgIHRvcDogMjM0cHg7XG4gIH1cblxuICAueGxcXFxcOm1iLVxcXFxbMTE1cHhcXFxcXSB7XG4gICAgbWFyZ2luLWJvdHRvbTogMTE1cHg7XG4gIH1cblxuICAueGxcXFxcOm1sLVxcXFxbLTY3cHhcXFxcXSB7XG4gICAgbWFyZ2luLWxlZnQ6IC02N3B4O1xuICB9XG5cbiAgLnhsXFxcXDptbC1cXFxcWzk4cHhcXFxcXSB7XG4gICAgbWFyZ2luLWxlZnQ6IDk4cHg7XG4gIH1cblxuICAueGxcXFxcOm1yLVxcXFxbLTE2MHB4XFxcXF0ge1xuICAgIG1hcmdpbi1yaWdodDogLTE2MHB4O1xuICB9XG5cbiAgLnhsXFxcXDptdC1cXFxcWzExMnB4XFxcXF0ge1xuICAgIG1hcmdpbi10b3A6IDExMnB4O1xuICB9XG5cbiAgLnhsXFxcXDptdC1cXFxcWzEyMHB4XFxcXF0ge1xuICAgIG1hcmdpbi10b3A6IDEyMHB4O1xuICB9XG5cbiAgLnhsXFxcXDptdC1cXFxcWzIwMHB4XFxcXF0ge1xuICAgIG1hcmdpbi10b3A6IDIwMHB4O1xuICB9XG5cbiAgLnhsXFxcXDpibG9jayB7XG4gICAgZGlzcGxheTogYmxvY2s7XG4gIH1cblxuICAueGxcXFxcOmgtXFxcXFsxMTAwcHhcXFxcXSB7XG4gICAgaGVpZ2h0OiAxMTAwcHg7XG4gIH1cblxuICAueGxcXFxcOmgtXFxcXFs1MjhweFxcXFxdIHtcbiAgICBoZWlnaHQ6IDUyOHB4O1xuICB9XG5cbiAgLnhsXFxcXDpoLVxcXFxbNjBweFxcXFxdIHtcbiAgICBoZWlnaHQ6IDYwcHg7XG4gIH1cblxuICAueGxcXFxcOmgtXFxcXFs2MXB4XFxcXF0ge1xuICAgIGhlaWdodDogNjFweDtcbiAgfVxuXG4gIC54bFxcXFw6aC1cXFxcWzcyOHB4XFxcXF0ge1xuICAgIGhlaWdodDogNzI4cHg7XG4gIH1cblxuICAueGxcXFxcOmgtXFxcXFs3ODRweFxcXFxdIHtcbiAgICBoZWlnaHQ6IDc4NHB4O1xuICB9XG5cbiAgLnhsXFxcXDpoLVxcXFxbODAwcHhcXFxcXSB7XG4gICAgaGVpZ2h0OiA4MDBweDtcbiAgfVxuXG4gIC54bFxcXFw6aC1cXFxcWzk4NHB4XFxcXF0ge1xuICAgIGhlaWdodDogOTg0cHg7XG4gIH1cblxuICAueGxcXFxcOmgtXFxcXFs2NThweFxcXFxdIHtcbiAgICBoZWlnaHQ6IDY1OHB4O1xuICB9XG5cbiAgLnhsXFxcXDptaW4taC1cXFxcWzcyOHB4XFxcXF0ge1xuICAgIG1pbi1oZWlnaHQ6IDcyOHB4O1xuICB9XG5cbiAgLnhsXFxcXDp3LVxcXFxbMTM0cHhcXFxcXSB7XG4gICAgd2lkdGg6IDEzNHB4O1xuICB9XG5cbiAgLnhsXFxcXDp3LVxcXFxbMTM1cHhcXFxcXSB7XG4gICAgd2lkdGg6IDEzNXB4O1xuICB9XG5cbiAgLnhsXFxcXDp3LVxcXFxbNDQ1cHhcXFxcXSB7XG4gICAgd2lkdGg6IDQ0NXB4O1xuICB9XG5cbiAgLnhsXFxcXDp3LVxcXFxbNTA0cHhcXFxcXSB7XG4gICAgd2lkdGg6IDUwNHB4O1xuICB9XG5cbiAgLnhsXFxcXDp3LVxcXFxbNzA1cHhcXFxcXSB7XG4gICAgd2lkdGg6IDcwNXB4O1xuICB9XG5cbiAgLnhsXFxcXDp3LVxcXFxbODk1cHhcXFxcXSB7XG4gICAgd2lkdGg6IDg5NXB4O1xuICB9XG5cbiAgLnhsXFxcXDp3LWZpdCB7XG4gICAgd2lkdGg6IC1tb3otZml0LWNvbnRlbnQ7XG4gICAgd2lkdGg6IGZpdC1jb250ZW50O1xuICB9XG5cbiAgLnhsXFxcXDp3LVxcXFxbNzM1cHhcXFxcXSB7XG4gICAgd2lkdGg6IDczNXB4O1xuICB9XG5cbiAgLnhsXFxcXDptaW4tdy1cXFxcWzE5OXB4XFxcXF0ge1xuICAgIG1pbi13aWR0aDogMTk5cHg7XG4gIH1cblxuICAueGxcXFxcOm1heC13LVxcXFxbMjI1cHhcXFxcXSB7XG4gICAgbWF4LXdpZHRoOiAyMjVweDtcbiAgfVxuXG4gIC54bFxcXFw6bWF4LXctXFxcXFs0N3Z3XFxcXF0ge1xuICAgIG1heC13aWR0aDogNDd2dztcbiAgfVxuXG4gIC54bFxcXFw6bWF4LXctXFxcXFs1NDBweFxcXFxdIHtcbiAgICBtYXgtd2lkdGg6IDU0MHB4O1xuICB9XG5cbiAgLnhsXFxcXDptYXgtdy1cXFxcWzYzNXB4XFxcXF0ge1xuICAgIG1heC13aWR0aDogNjM1cHg7XG4gIH1cblxuICAueGxcXFxcOm1heC13LVxcXFxbNjgwXFxcXF0ge1xuICAgIG1heC13aWR0aDogNjgwO1xuICB9XG5cbiAgLnhsXFxcXDptYXgtdy1mdWxsIHtcbiAgICBtYXgtd2lkdGg6IDEwMCU7XG4gIH1cblxuICAueGxcXFxcOm1heC13LVxcXFxbNzNcXFxcXSB7XG4gICAgbWF4LXdpZHRoOiA3MztcbiAgfVxuXG4gIC54bFxcXFw6bWF4LXctXFxcXFs2ODBweFxcXFxdIHtcbiAgICBtYXgtd2lkdGg6IDY4MHB4O1xuICB9XG5cbiAgLnhsXFxcXDpqdXN0aWZ5LWVuZCB7XG4gICAganVzdGlmeS1jb250ZW50OiBmbGV4LWVuZDtcbiAgfVxuXG4gIC54bFxcXFw6Z2FwLVxcXFxbNDNweFxcXFxdIHtcbiAgICBnYXA6IDQzcHg7XG4gIH1cblxuICAueGxcXFxcOmdhcC1cXFxcWzQ4cHhcXFxcXSB7XG4gICAgZ2FwOiA0OHB4O1xuICB9XG5cbiAgLnhsXFxcXDpnYXAtXFxcXFs1NnB4XFxcXF0ge1xuICAgIGdhcDogNTZweDtcbiAgfVxuXG4gIC54bFxcXFw6b2JqZWN0LWNvdmVyIHtcbiAgICAtby1vYmplY3QtZml0OiBjb3ZlcjtcbiAgICAgICBvYmplY3QtZml0OiBjb3ZlcjtcbiAgfVxuXG4gIC54bFxcXFw6b2JqZWN0LWNlbnRlciB7XG4gICAgLW8tb2JqZWN0LXBvc2l0aW9uOiBjZW50ZXI7XG4gICAgICAgb2JqZWN0LXBvc2l0aW9uOiBjZW50ZXI7XG4gIH1cblxuICAueGxcXFxcOnB4LTAge1xuICAgIHBhZGRpbmctbGVmdDogMHB4O1xuICAgIHBhZGRpbmctcmlnaHQ6IDBweDtcbiAgfVxuXG4gIC54bFxcXFw6cGwtMCB7XG4gICAgcGFkZGluZy1sZWZ0OiAwcHg7XG4gIH1cblxuICAueGxcXFxcOnBsLVxcXFxbMTU0cHhcXFxcXSB7XG4gICAgcGFkZGluZy1sZWZ0OiAxNTRweDtcbiAgfVxuXG4gIC54bFxcXFw6cGwtXFxcXFszOXB4XFxcXF0ge1xuICAgIHBhZGRpbmctbGVmdDogMzlweDtcbiAgfVxuXG4gIC54bFxcXFw6cGwtXFxcXFs2OXB4XFxcXF0ge1xuICAgIHBhZGRpbmctbGVmdDogNjlweDtcbiAgfVxuXG4gIC54bFxcXFw6cHItMCB7XG4gICAgcGFkZGluZy1yaWdodDogMHB4O1xuICB9XG5cbiAgLnhsXFxcXDpwci1cXFxcWzEwNnB4XFxcXF0ge1xuICAgIHBhZGRpbmctcmlnaHQ6IDEwNnB4O1xuICB9XG5cbiAgLnhsXFxcXDp0ZXh0LVxcXFxbMTZweFxcXFxdIHtcbiAgICBmb250LXNpemU6IDE2cHg7XG4gIH1cblxuICAueGxcXFxcOnRleHQtXFxcXFsxOHB4XFxcXF0ge1xuICAgIGZvbnQtc2l6ZTogMThweDtcbiAgfVxuXG4gIC54bFxcXFw6dGV4dC1cXFxcWzU2cHhcXFxcXSB7XG4gICAgZm9udC1zaXplOiA1NnB4O1xuICB9XG5cbiAgLnhsXFxcXDp0ZXh0LVxcXFxbODBweFxcXFxdIHtcbiAgICBmb250LXNpemU6IDgwcHg7XG4gIH1cblxuICAueGxcXFxcOmxlYWRpbmctXFxcXFszMnB4XFxcXF0ge1xuICAgIGxpbmUtaGVpZ2h0OiAzMnB4O1xuICB9XG5cbiAgLnhsXFxcXDpsZWFkaW5nLVxcXFxbNjRweFxcXFxdIHtcbiAgICBsaW5lLWhlaWdodDogNjRweDtcbiAgfVxuXG4gIC54bFxcXFw6bGVhZGluZy1cXFxcWzg4cHhcXFxcXSB7XG4gICAgbGluZS1oZWlnaHQ6IDg4cHg7XG4gIH1cbn1cclxuXHJcbkBtZWRpYSAobWluLXdpZHRoOiAxNTAwcHgpIHtcblxuICAuc2NyZWVuMTUwMFxcXFw6bWF4LXctXFxcXFs3MDVweFxcXFxdIHtcbiAgICBtYXgtd2lkdGg6IDcwNXB4O1xuICB9XG59XHJcbmAsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovLy4vYXBwL3N0YXRpYy9wYWdlcy9nbG9iYWxzLmNzc1wiXSxc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bUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUEsaUJBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUEsV0FBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxXQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBLHdCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUEsdUJBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQSxzQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxxQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxrQkFBbUI7RUFBbkIsa0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUEsa0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsa0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsa0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBLHNCQUFtQjtLQUFuQjtBQUFtQjtBQUFuQjtFQUFBLG9CQUFtQjtLQUFuQjtBQUFtQjtBQUFuQjtFQUFBLG1CQUFtQjtLQUFuQjtBQUFtQjtBQUFuQjtFQUFBLHlCQUFtQjtLQUFuQjtBQUFtQjtBQUFuQjtFQUFBLDJCQUFtQjtLQUFuQjtBQUFtQjtBQUFuQjtFQUFBLDBCQUFtQjtLQUFuQjtBQUFtQjtBQUFuQjtFQUFBLHlCQUFtQjtLQUFuQjtBQUFtQjtBQUFuQjtFQUFBLHVCQUFtQjtLQUFuQjtBQUFtQjtBQUFuQjtFQUFBLHNCQUFtQjtLQUFuQjtBQUFtQjtBQUFuQjtFQUFBLHVCQUFtQjtLQUFuQjtBQUFtQjtBQUFuQjtFQUFBLHVCQUFtQjtLQUFuQjtBQUFtQjtBQUFuQjtFQUFBLDJCQUFtQjtLQUFuQjtBQUFtQjtBQUFuQjtFQUFBLHVCQUFtQjtLQUFuQjtBQUFtQjtBQUFuQjtFQUFBLDBCQUFtQjtLQUFuQjtBQUFtQjtBQUFuQjtFQUFBLGlCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLGtCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLGtCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLGdCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLGlCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLGdCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBLG9CQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLG9CQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUEsZ0tBQW1CO0VBQW5CLHdKQUFtQjtFQUFuQixpTEFBbUI7RUFBbkIsd0RBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsd0JBQW1CO0VBQW5CLHdEQUFtQjtFQUFuQjtBQUFtQjs7QUFHakI7RUFBQSxlQUFrSDtFQUFsSCxnQkFBa0g7RUFBbEg7QUFBa0g7O0FBQWxIOztFQUFBO0lBQUEsZUFBa0g7SUFBbEg7RUFBa0g7QUFBQTs7QUFBbEg7O0VBQUE7SUFBQSxlQUFrSDtJQUFsSDtFQUFrSDtBQUFBOztBQUlsSDtFQUFBLGVBQWlGO0VBQWpGLGdCQUFpRjtFQUFqRjtBQUFpRjs7QUFBakY7O0VBQUE7SUFBQSxlQUFpRjtJQUFqRjtFQUFpRjtBQUFBOztBQUlqRjtFQUFBLGVBQWdEO0VBQWhELGdCQUFnRDtFQUFoRDtBQUFnRDs7QUFJaEQ7RUFBQSxlQUFrRTtFQUFsRTtBQUFrRTs7QUFBbEU7O0VBQUE7SUFBQSxlQUFrRTtJQUFsRTtFQUFrRTtBQUFBOztBQUlsRTtFQUFBO0FBQWlDOztBQUFqQzs7RUFBQTtJQUFBO0VBQWlDO0FBQUE7O0FBS2pDOztFQUFBLGVBQXNDO0VBQXRDLHdCQUFzQztFQUF0Qyx3REFBc0M7RUFBdEM7QUFBc0M7QUFJdEM7O0VBQUE7QUFBdUI7O0FBR3pCO0VBQ0UsV0FBVztFQUNYLFlBQVk7RUFDWixhQUFhO0VBQ2IsbUJBQW1CO0VBQ25CLHVCQUF1QjtFQUN2QixlQUFlO0FBQ2pCOztBQUdFO0VBQUE7QUFBK0M7O0FBQS9DO0VBQUE7QUFBK0M7O0FBRGpEO0VBRUUsa0JBQWtCO0FBQ3BCOztBQUdFO0VBQUEsb0JBQStFO0VBQS9FLGFBQStFO0VBQS9FLFdBQStFO0VBQS9FLG9CQUErRTtLQUEvRSxpQkFBK0U7RUFBL0UseUJBQStFO0tBQS9FO0FBQStFOztBQUEvRTs7RUFBQTtJQUFBO0VBQStFO0FBQUE7O0FBSS9FO0VBQUEsOEJBQTJCO0VBQTNCLHdEQUEyQjtFQUEzQjtBQUEyQjs7QUFJM0I7RUFBQSxxQkFBNEM7RUFBNUMsa0JBQTRDO0VBQTVDLGtCQUE0QztFQUE1QztBQUE0Qzs7QUFJNUM7RUFBQTtBQUFtQjs7QUFJbkI7RUFBQSxhQUF1QjtFQUF2QixXQUF1QjtFQUN2QixXQUFXO0VBQ1gsa0JBQWtCO0VBQ2xCLFNBQVM7RUFDVCxPQUFPO0VBQ1Asb0ZBQW9GO0VBQ3BGO0FBTnVCOztBQVV2QjtFQUFBLFlBQXdCO0VBQXhCLFdBQXdCO0VBQ3hCO0FBRHdCOztBQUt4QjtFQUFBO0FBQTBCOztBQUkxQjtFQUFBLFlBQXdCO0VBQXhCLFdBQXdCO0VBQ3hCO0FBRHdCOztBQUt4QjtFQUFBLHFCQUFvQjtFQUFwQjtBQUFvQjs7QUFHdEI7RUFDRSw0QkFBNEI7RUFDNUIsYUFBd0M7RUFBeEMsc0JBQXdDO0VBQXhDLCtMQUF3QztBQUMxQzs7QUFERTs7RUFBQTtJQUFBO0VBQXdDO0FBQUE7O0FBRzFDO0VBRUk7SUFBQTtFQUEwQjs7RUFJMUI7SUFBQTtFQUEwQjs7RUFJMUI7SUFBQSxhQUF3QztJQUF4QyxpQkFBd0M7SUFBeEM7RUFBd0M7QUFFNUM7O0FBNUdBO0VBQUE7QUE2R0E7O0FBN0dBO0VBQUEsa0JBNkdBO0VBN0dBO0FBNkdBOztBQTdHQTtFQUFBLGtCQTZHQTtFQTdHQTtBQTZHQTs7QUE3R0E7RUFBQTtBQTZHQTs7QUE3R0E7RUFBQSxvQkE2R0E7RUE3R0E7QUE2R0E7O0FBN0dBOztFQUFBO0lBQUE7RUE2R0E7O0VBN0dBO0lBQUE7RUE2R0E7O0VBN0dBO0lBQUE7RUE2R0E7O0VBN0dBO0lBQUE7RUE2R0E7O0VBN0dBO0lBQUE7RUE2R0E7O0VBN0dBO0lBQUE7RUE2R0E7O0VBN0dBO0lBQUE7RUE2R0E7O0VBN0dBO0lBQUE7RUE2R0E7O0VBN0dBO0lBQUE7RUE2R0E7O0VBN0dBO0lBQUE7RUE2R0E7O0VBN0dBO0lBQUE7RUE2R0E7O0VBN0dBO0lBQUE7RUE2R0E7O0VBN0dBO0lBQUE7RUE2R0E7O0VBN0dBO0lBQUE7RUE2R0E7O0VBN0dBO0lBQUE7RUE2R0E7O0VBN0dBO0lBQUE7RUE2R0E7O0VBN0dBO0lBQUEsdUJBNkdBO0lBN0dBO0VBNkdBOztFQTdHQTtJQUFBO0VBNkdBOztFQTdHQTtJQUFBO0VBNkdBOztFQTdHQTtJQUFBO0VBNkdBOztFQTdHQTtJQUFBO0VBNkdBOztFQTdHQTtJQUFBO0VBNkdBOztFQTdHQTtJQUFBO0VBNkdBOztFQTdHQTtJQUFBO0VBNkdBOztFQTdHQTtJQUFBO0VBNkdBOztFQTdHQTtJQUFBO0VBNkdBOztFQTdHQTtJQUFBO0VBNkdBOztFQTdHQTtJQUFBO0VBNkdBOztFQTdHQTtJQUFBO0VBNkdBOztFQTdHQTtJQUFBLDJCQTZHQTtPQTdHQTtFQTZHQTs7RUE3R0E7SUFBQSxpQkE2R0E7SUE3R0E7RUE2R0E7O0VBN0dBO0lBQUEsZ0JBNkdBO0lBN0dBO0VBNkdBOztFQTdHQTtJQUFBO0VBNkdBOztFQTdHQTtJQUFBO0VBNkdBOztFQTdHQTtJQUFBO0VBNkdBOztFQTdHQTtJQUFBO0VBNkdBOztFQTdHQTtJQUFBO0VBNkdBOztFQTdHQTtJQUFBO0VBNkdBOztFQTdHQTtJQUFBO0VBNkdBO0FBQUE7O0FBN0dBOztFQUFBO0lBQUE7RUE2R0E7O0VBN0dBO0lBQUE7RUE2R0E7O0VBN0dBO0lBQUE7RUE2R0E7O0VBN0dBO0lBQUE7RUE2R0E7O0VBN0dBO0lBQUE7RUE2R0E7O0VBN0dBO0lBQUE7RUE2R0E7O0VBN0dBO0lBQUE7RUE2R0E7O0VBN0dBO0lBQUE7RUE2R0E7O0VBN0dBO0lBQUE7RUE2R0E7O0VBN0dBO0lBQUE7RUE2R0E7O0VBN0dBO0lBQUEsb0JBNkdBO09BN0dBO0VBNkdBOztFQTdHQTtJQUFBLDJCQTZHQTtPQTdHQTtFQTZHQTs7RUE3R0E7SUFBQSxpQkE2R0E7SUE3R0E7RUE2R0E7O0VBN0dBO0lBQUE7RUE2R0E7O0VBN0dBO0lBQUE7RUE2R0E7O0VBN0dBO0lBQUE7RUE2R0E7QUFBQTs7QUE3R0E7O0VBQUE7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQTtFQTZHQTs7RUE3R0E7SUFBQSx1QkE2R0E7SUE3R0E7RUE2R0E7O0VBN0dBO0lBQUE7RUE2R0E7O0VBN0dBO0lBQUE7RUE2R0E7O0VBN0dBO0lBQUE7RUE2R0E7O0VBN0dBO0lBQUE7RUE2R0E7O0VBN0dBO0lBQUE7RUE2R0E7O0VBN0dBO0lBQUE7RUE2R0E7O0VBN0dBO0lBQUE7RUE2R0E7O0VBN0dBO0lBQUE7RUE2R0E7O0VBN0dBO0lBQUE7RUE2R0E7O0VBN0dBO0lBQUE7RUE2R0E7O0VBN0dBO0lBQUE7RUE2R0E7O0VBN0dBO0lBQUE7RUE2R0E7O0VBN0dBO0lBQUE7RUE2R0E7O0VBN0dBO0lBQUE7RUE2R0E7O0VBN0dBO0lBQUEsb0JBNkdBO09BN0dBO0VBNkdBOztFQTdHQTtJQUFBLDBCQTZHQTtPQTdHQTtFQTZHQTs7RUE3R0E7SUFBQSxpQkE2R0E7SUE3R0E7RUE2R0E7O0VBN0dBO0lBQUE7RUE2R0E7O0VBN0dBO0lBQUE7RUE2R0E7O0VBN0dBO0lBQUE7RUE2R0E7O0VBN0dBO0lBQUE7RUE2R0E7O0VBN0dBO0lBQUE7RUE2R0E7O0VBN0dBO0lBQUE7RUE2R0E7O0VBN0dBO0lBQUE7RUE2R0E7O0VBN0dBO0lBQUE7RUE2R0E7O0VBN0dBO0lBQUE7RUE2R0E7O0VBN0dBO0lBQUE7RUE2R0E7O0VBN0dBO0lBQUE7RUE2R0E7O0VBN0dBO0lBQUE7RUE2R0E7O0VBN0dBO0lBQUE7RUE2R0E7QUFBQTs7QUE3R0E7O0VBQUE7SUFBQTtFQTZHQTtBQUFBXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIkB0YWlsd2luZCBiYXNlO1xcclxcbkB0YWlsd2luZCBjb21wb25lbnRzO1xcclxcbkB0YWlsd2luZCB1dGlsaXRpZXM7XFxyXFxuXFxyXFxuaDEge1xcclxcbiAgQGFwcGx5IHRleHQtWzQwcHhdIGZvbnQtZXh0cmFib2xkIGxlYWRpbmctWzQwcHhdIG1kOnRleHQtWzU2cHhdIG1kOmxlYWRpbmctWzU2cHhdIHhsOnRleHQtWzgwcHhdIHhsOmxlYWRpbmctWzg4cHhdO1xcclxcbn1cXHJcXG5cXHJcXG5oMiB7XFxyXFxuICBAYXBwbHkgdGV4dC1bMzJweF0gZm9udC1leHRyYWJvbGQgbGVhZGluZy1bNDBweF0geGw6dGV4dC1bNTZweF0geGw6bGVhZGluZy1bNjRweF07XFxyXFxufVxcclxcblxcclxcbmgzIHtcXHJcXG4gIEBhcHBseSB0ZXh0LVsyMHB4XSBmb250LWV4dHJhYm9sZCBsZWFkaW5nLVszMnB4XTtcXHJcXG59XFxyXFxuXFxyXFxucCB7XFxyXFxuICBAYXBwbHkgdGV4dC1bMTVweF0gbGVhZGluZy1bMjVweF0geGw6dGV4dC1bMThweF0geGw6bGVhZGluZy1bMzJweF07XFxyXFxufVxcclxcblxcclxcbmEge1xcclxcbiAgQGFwcGx5IHRleHQtWzE1cHhdIHhsOnRleHQtWzE2cHhdO1xcclxcbn1cXHJcXG5cXHJcXG4ucHJldmlvdXMsXFxyXFxuLm5leHQge1xcclxcbiAgQGFwcGx5IHN0cm9rZS1bI0Y5NEY0Rl0gdHJhbnNpdGlvbi1hbGw7XFxyXFxufVxcclxcbi5wcmV2aW91czpob3ZlcixcXHJcXG4ubmV4dDpob3ZlciB7XFxyXFxuICBAYXBwbHkgc3Ryb2tlLVsjRkY5MzkzXTtcXHJcXG59XFxyXFxuXFxyXFxuLnBhbmVsIHtcXHJcXG4gIHdpZHRoOiAxMDAlO1xcclxcbiAgaGVpZ2h0OiAxMDAlO1xcclxcbiAgZGlzcGxheTogZmxleDtcXHJcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxyXFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXHJcXG4gIGZvbnQtc2l6ZTogMjRweDtcXHJcXG59XFxyXFxuXFxyXFxuLmltYWdlLWNvbnRhaW5lciB7XFxyXFxuICBAYXBwbHkgaG92ZXI6Y3Vyc29yLWdyYWIgYWN0aXZlOmN1cnNvci1ncmFiYmluZztcXHJcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXHJcXG59XFxyXFxuXFxyXFxuLmNhcm91c2VsSW1hZ2Uge1xcclxcbiAgQGFwcGx5IHBvaW50ZXItZXZlbnRzLW5vbmUgaC1bNDcycHhdIHctZnVsbCBvYmplY3QtY292ZXIgb2JqZWN0LXJpZ2h0IHhsOmgtZnVsbDtcXHJcXG59XFxyXFxuXFxyXFxuLmFuaW1hdGlvbkVsZW1lbnQge1xcclxcbiAgQGFwcGx5IHRyYW5zaXRpb24tdHJhbnNmb3JtO1xcclxcbn1cXHJcXG5cXHJcXG4uYW5pbWF0aW9uRWxlbWVudC5hbmltYXRlVHJhbnNpdGlvbiB7XFxyXFxuICBAYXBwbHkgdHJhbnNsYXRlLXktWzBweF0gc2NhbGUtMTA1IHRyYW5zZm9ybTtcXHJcXG59XFxyXFxuXFxyXFxuLmFuaW1hdGlvbkVsZW1lbnQge1xcclxcbiAgQGFwcGx5IGR1cmF0aW9uLTUwMDtcXHJcXG59XFxyXFxuXFxyXFxuLmltYWdlLWNvbnRhaW5lcjo6YWZ0ZXIge1xcclxcbiAgQGFwcGx5IGgtWzIwMHB4XSB3LWZ1bGw7XFxyXFxuICBjb250ZW50OiAnJztcXHJcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG4gIGJvdHRvbTogMDtcXHJcXG4gIGxlZnQ6IDA7XFxyXFxuICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQodG8gYm90dG9tLCByZ2JhKDAsIDAsIDAsIDApIDAlLCByZ2JhKDAsIDAsIDAsIDAuNSkgMTAwJSk7XFxyXFxuICBwb2ludGVyLWV2ZW50czogbm9uZTtcXHJcXG59XFxyXFxuXFxyXFxuI21vYmlsZU5hdiB7XFxyXFxuICBAYXBwbHkgaC1bMThweF0gdy1bMjRweF07XFxyXFxuICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJy4uL2Fzc2V0cy9tb2JpbGUvaWNvbi1oYW1idXJnZXIuc3ZnJyk7XFxyXFxufVxcclxcblxcclxcbiNtYXNrIHtcXHJcXG4gIEBhcHBseSBwb2ludGVyLWV2ZW50cy1ub25lO1xcclxcbn1cXHJcXG5cXHJcXG4jbW9iaWxlTmF2Lm9wZW4ge1xcclxcbiAgQGFwcGx5IGgtWzIwcHhdIHctWzIwcHhdO1xcclxcbiAgYmFja2dyb3VuZC1pbWFnZTogdXJsKCcuLi9hc3NldHMvbW9iaWxlL2ljb24tY3Jvc3Muc3ZnJyk7XFxyXFxufVxcclxcblxcclxcbmJvZHk6aGFzKCNtb2JpbGVOYXYub3BlbikgI21vYmlsZU1lbnUge1xcclxcbiAgQGFwcGx5IHRyYW5zbGF0ZS14LTA7XFxyXFxufVxcclxcblxcclxcbiNtb2JpbGVNZW51IHtcXHJcXG4gIHRyYW5zaXRpb246IGFsbCAwLjVzIGVhc2UgMHM7XFxyXFxuICBAYXBwbHkgZmxleCB0cmFuc2xhdGUteC1bMTUwJV0gbWQ6aGlkZGVuO1xcclxcbn1cXHJcXG5cXHJcXG5AbWVkaWEgKG1heC13aWR0aDogNzY4cHgpIHtcXHJcXG4gIGJvZHk6aGFzKCNtb2JpbGVNZW51Lm9wZW4pICNtb2JpbGVNZW51TGlzdCB7XFxyXFxuICAgIEBhcHBseSBwb2ludGVyLWV2ZW50cy1hdXRvO1xcclxcbiAgfVxcclxcblxcclxcbiAgYm9keTpoYXMoI21vYmlsZU5hdi5vcGVuKSAjbWFzayB7XFxyXFxuICAgIEBhcHBseSBwb2ludGVyLWV2ZW50cy1hdXRvO1xcclxcbiAgfVxcclxcblxcclxcbiAgYm9keTpoYXMoI21vYmlsZU5hdi5vcGVuKSB7XFxyXFxuICAgIEBhcHBseSBmbGV4IG1pbi1oLXNjcmVlbiBvdmVyZmxvdy1oaWRkZW47XFxyXFxuICB9XFxyXFxufVxcclxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iLCIvLyBJbXBvcnRzXG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vLi4vY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvc291cmNlTWFwcy5qc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vLi4vY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCI7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgYC5mbGlja2luZy12aWV3cG9ydCB7XG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcbn1cblxuLmZsaWNraW5nLXZpZXdwb3J0LnZlcnRpY2FsIHtcbiAgZGlzcGxheTogaW5saW5lLWZsZXg7XG59XG5cbi5mbGlja2luZy12aWV3cG9ydC52ZXJ0aWNhbCA+IC5mbGlja2luZy1jYW1lcmEge1xuICBkaXNwbGF5OiBpbmxpbmUtZmxleDtcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbn1cblxuLmZsaWNraW5nLXZpZXdwb3J0LmZsaWNraW5nLWhpZGRlbiA+IC5mbGlja2luZy1jYW1lcmEgPiAqIHtcbiAgdmlzaWJpbGl0eTogaGlkZGVuO1xufVxuXG4uZmxpY2tpbmctY2FtZXJhIHtcbiAgd2lkdGg6IDEwMCU7XG4gIGhlaWdodDogMTAwJTtcbiAgZGlzcGxheTogZmxleDtcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xuICBmbGV4LWRpcmVjdGlvbjogcm93O1xuICB6LWluZGV4OiAxO1xuICB3aWxsLWNoYW5nZTogdHJhbnNmb3JtO1xufVxuXG4uZmxpY2tpbmctY2FtZXJhID4gKiB7XG4gIGZsZXgtc2hyaW5rOiAwO1xufVxuYCwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vLi9ub2RlX21vZHVsZXMvQGVnanMvcHJlYWN0LWZsaWNraW5nL2Rpc3QvZmxpY2tpbmcuY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBO0VBQ0Usa0JBQWtCO0VBQ2xCLGdCQUFnQjtBQUNsQjs7QUFFQTtFQUdFLG9CQUFvQjtBQUN0Qjs7QUFFQTtFQUdFLG9CQUFvQjtFQUlaLHNCQUFzQjtBQUNoQzs7QUFFQTtFQUNFLGtCQUFrQjtBQUNwQjs7QUFFQTtFQUNFLFdBQVc7RUFDWCxZQUFZO0VBR1osYUFBYTtFQUNiLGtCQUFrQjtFQUlWLG1CQUFtQjtFQUMzQixVQUFVO0VBQ1Ysc0JBQXNCO0FBQ3hCOztBQUVBO0VBRU0sY0FBYztBQUNwQlwiLFwic291cmNlc0NvbnRlbnRcIjpbXCIuZmxpY2tpbmctdmlld3BvcnQge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG59XFxuXFxuLmZsaWNraW5nLXZpZXdwb3J0LnZlcnRpY2FsIHtcXG4gIGRpc3BsYXk6IC13ZWJraXQtaW5saW5lLWJveDtcXG4gIGRpc3BsYXk6IC1tcy1pbmxpbmUtZmxleGJveDtcXG4gIGRpc3BsYXk6IGlubGluZS1mbGV4O1xcbn1cXG5cXG4uZmxpY2tpbmctdmlld3BvcnQudmVydGljYWwgPiAuZmxpY2tpbmctY2FtZXJhIHtcXG4gIGRpc3BsYXk6IC13ZWJraXQtaW5saW5lLWJveDtcXG4gIGRpc3BsYXk6IC1tcy1pbmxpbmUtZmxleGJveDtcXG4gIGRpc3BsYXk6IGlubGluZS1mbGV4O1xcbiAgLXdlYmtpdC1ib3gtb3JpZW50OiB2ZXJ0aWNhbDtcXG4gIC13ZWJraXQtYm94LWRpcmVjdGlvbjogbm9ybWFsO1xcbiAgICAgIC1tcy1mbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbn1cXG5cXG4uZmxpY2tpbmctdmlld3BvcnQuZmxpY2tpbmctaGlkZGVuID4gLmZsaWNraW5nLWNhbWVyYSA+ICoge1xcbiAgdmlzaWJpbGl0eTogaGlkZGVuO1xcbn1cXG5cXG4uZmxpY2tpbmctY2FtZXJhIHtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgaGVpZ2h0OiAxMDAlO1xcbiAgZGlzcGxheTogLXdlYmtpdC1ib3g7XFxuICBkaXNwbGF5OiAtbXMtZmxleGJveDtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAtd2Via2l0LWJveC1vcmllbnQ6IGhvcml6b250YWw7XFxuICAtd2Via2l0LWJveC1kaXJlY3Rpb246IG5vcm1hbDtcXG4gICAgICAtbXMtZmxleC1kaXJlY3Rpb246IHJvdztcXG4gICAgICAgICAgZmxleC1kaXJlY3Rpb246IHJvdztcXG4gIHotaW5kZXg6IDE7XFxuICB3aWxsLWNoYW5nZTogdHJhbnNmb3JtO1xcbn1cXG5cXG4uZmxpY2tpbmctY2FtZXJhID4gKiB7XFxuICAtbXMtZmxleC1uZWdhdGl2ZTogMDtcXG4gICAgICBmbGV4LXNocmluazogMDtcXG59XFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vKlxuICBNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICBBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3NzV2l0aE1hcHBpbmdUb1N0cmluZykge1xuICB2YXIgbGlzdCA9IFtdO1xuXG4gIC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcbiAgbGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgdmFyIGNvbnRlbnQgPSBcIlwiO1xuICAgICAgdmFyIG5lZWRMYXllciA9IHR5cGVvZiBpdGVtWzVdICE9PSBcInVuZGVmaW5lZFwiO1xuICAgICAgaWYgKGl0ZW1bNF0pIHtcbiAgICAgICAgY29udGVudCArPSBcIkBzdXBwb3J0cyAoXCIuY29uY2F0KGl0ZW1bNF0sIFwiKSB7XCIpO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZW1bMl0pIHtcbiAgICAgICAgY29udGVudCArPSBcIkBtZWRpYSBcIi5jb25jYXQoaXRlbVsyXSwgXCIge1wiKTtcbiAgICAgIH1cbiAgICAgIGlmIChuZWVkTGF5ZXIpIHtcbiAgICAgICAgY29udGVudCArPSBcIkBsYXllclwiLmNvbmNhdChpdGVtWzVdLmxlbmd0aCA+IDAgPyBcIiBcIi5jb25jYXQoaXRlbVs1XSkgOiBcIlwiLCBcIiB7XCIpO1xuICAgICAgfVxuICAgICAgY29udGVudCArPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0pO1xuICAgICAgaWYgKG5lZWRMYXllcikge1xuICAgICAgICBjb250ZW50ICs9IFwifVwiO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZW1bMl0pIHtcbiAgICAgICAgY29udGVudCArPSBcIn1cIjtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVtWzRdKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJ9XCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29udGVudDtcbiAgICB9KS5qb2luKFwiXCIpO1xuICB9O1xuXG4gIC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XG4gIGxpc3QuaSA9IGZ1bmN0aW9uIGkobW9kdWxlcywgbWVkaWEsIGRlZHVwZSwgc3VwcG9ydHMsIGxheWVyKSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCB1bmRlZmluZWRdXTtcbiAgICB9XG4gICAgdmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcbiAgICBpZiAoZGVkdXBlKSB7XG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IHRoaXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgdmFyIGlkID0gdGhpc1trXVswXTtcbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgX2sgPSAwOyBfayA8IG1vZHVsZXMubGVuZ3RoOyBfaysrKSB7XG4gICAgICB2YXIgaXRlbSA9IFtdLmNvbmNhdChtb2R1bGVzW19rXSk7XG4gICAgICBpZiAoZGVkdXBlICYmIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGxheWVyICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaXRlbVs1XSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIGl0ZW1bNV0gPSBsYXllcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtWzFdID0gXCJAbGF5ZXJcIi5jb25jYXQoaXRlbVs1XS5sZW5ndGggPiAwID8gXCIgXCIuY29uY2F0KGl0ZW1bNV0pIDogXCJcIiwgXCIge1wiKS5jb25jYXQoaXRlbVsxXSwgXCJ9XCIpO1xuICAgICAgICAgIGl0ZW1bNV0gPSBsYXllcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG1lZGlhKSB7XG4gICAgICAgIGlmICghaXRlbVsyXSkge1xuICAgICAgICAgIGl0ZW1bMl0gPSBtZWRpYTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtWzFdID0gXCJAbWVkaWEgXCIuY29uY2F0KGl0ZW1bMl0sIFwiIHtcIikuY29uY2F0KGl0ZW1bMV0sIFwifVwiKTtcbiAgICAgICAgICBpdGVtWzJdID0gbWVkaWE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzdXBwb3J0cykge1xuICAgICAgICBpZiAoIWl0ZW1bNF0pIHtcbiAgICAgICAgICBpdGVtWzRdID0gXCJcIi5jb25jYXQoc3VwcG9ydHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1bMV0gPSBcIkBzdXBwb3J0cyAoXCIuY29uY2F0KGl0ZW1bNF0sIFwiKSB7XCIpLmNvbmNhdChpdGVtWzFdLCBcIn1cIik7XG4gICAgICAgICAgaXRlbVs0XSA9IHN1cHBvcnRzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsaXN0LnB1c2goaXRlbSk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gbGlzdDtcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHVybCwgb3B0aW9ucykge1xuICBpZiAoIW9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgaWYgKCF1cmwpIHtcbiAgICByZXR1cm4gdXJsO1xuICB9XG4gIHVybCA9IFN0cmluZyh1cmwuX19lc01vZHVsZSA/IHVybC5kZWZhdWx0IDogdXJsKTtcblxuICAvLyBJZiB1cmwgaXMgYWxyZWFkeSB3cmFwcGVkIGluIHF1b3RlcywgcmVtb3ZlIHRoZW1cbiAgaWYgKC9eWydcIl0uKlsnXCJdJC8udGVzdCh1cmwpKSB7XG4gICAgdXJsID0gdXJsLnNsaWNlKDEsIC0xKTtcbiAgfVxuICBpZiAob3B0aW9ucy5oYXNoKSB7XG4gICAgdXJsICs9IG9wdGlvbnMuaGFzaDtcbiAgfVxuXG4gIC8vIFNob3VsZCB1cmwgYmUgd3JhcHBlZD9cbiAgLy8gU2VlIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3MtdmFsdWVzLTMvI3VybHNcbiAgaWYgKC9bXCInKCkgXFx0XFxuXXwoJTIwKS8udGVzdCh1cmwpIHx8IG9wdGlvbnMubmVlZFF1b3Rlcykge1xuICAgIHJldHVybiBcIlxcXCJcIi5jb25jYXQodXJsLnJlcGxhY2UoL1wiL2csICdcXFxcXCInKS5yZXBsYWNlKC9cXG4vZywgXCJcXFxcblwiKSwgXCJcXFwiXCIpO1xuICB9XG4gIHJldHVybiB1cmw7XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gIHZhciBjb250ZW50ID0gaXRlbVsxXTtcbiAgdmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuICBpZiAoIWNzc01hcHBpbmcpIHtcbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuICBpZiAodHlwZW9mIGJ0b2EgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShjc3NNYXBwaW5nKSkpKTtcbiAgICB2YXIgZGF0YSA9IFwic291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsXCIuY29uY2F0KGJhc2U2NCk7XG4gICAgdmFyIHNvdXJjZU1hcHBpbmcgPSBcIi8qIyBcIi5jb25jYXQoZGF0YSwgXCIgKi9cIik7XG4gICAgcmV0dXJuIFtjb250ZW50XS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKFwiXFxuXCIpO1xuICB9XG4gIHJldHVybiBbY29udGVudF0uam9pbihcIlxcblwiKTtcbn07IiwidmFyIG4sbCx1LHQsaSxvLHIsZixlLGMscyxhLGg9e30scD1bXSx2PS9hY2l0fGV4KD86c3xnfG58cHwkKXxycGh8Z3JpZHxvd3N8bW5jfG50d3xpbmVbY2hdfHpvb3xeb3JkfGl0ZXJhL2kseT1BcnJheS5pc0FycmF5O2Z1bmN0aW9uIGQobixsKXtmb3IodmFyIHUgaW4gbCluW3VdPWxbdV07cmV0dXJuIG59ZnVuY3Rpb24gdyhuKXt2YXIgbD1uLnBhcmVudE5vZGU7bCYmbC5yZW1vdmVDaGlsZChuKX1mdW5jdGlvbiBfKGwsdSx0KXt2YXIgaSxvLHIsZj17fTtmb3IociBpbiB1KVwia2V5XCI9PXI/aT11W3JdOlwicmVmXCI9PXI/bz11W3JdOmZbcl09dVtyXTtpZihhcmd1bWVudHMubGVuZ3RoPjImJihmLmNoaWxkcmVuPWFyZ3VtZW50cy5sZW5ndGg+Mz9uLmNhbGwoYXJndW1lbnRzLDIpOnQpLFwiZnVuY3Rpb25cIj09dHlwZW9mIGwmJm51bGwhPWwuZGVmYXVsdFByb3BzKWZvcihyIGluIGwuZGVmYXVsdFByb3BzKXZvaWQgMD09PWZbcl0mJihmW3JdPWwuZGVmYXVsdFByb3BzW3JdKTtyZXR1cm4gZyhsLGYsaSxvLG51bGwpfWZ1bmN0aW9uIGcobix0LGksbyxyKXt2YXIgZj17dHlwZTpuLHByb3BzOnQsa2V5OmkscmVmOm8sX19rOm51bGwsX186bnVsbCxfX2I6MCxfX2U6bnVsbCxfX2Q6dm9pZCAwLF9fYzpudWxsLGNvbnN0cnVjdG9yOnZvaWQgMCxfX3Y6bnVsbD09cj8rK3U6cixfX2k6LTEsX191OjB9O3JldHVybiBudWxsPT1yJiZudWxsIT1sLnZub2RlJiZsLnZub2RlKGYpLGZ9ZnVuY3Rpb24gbSgpe3JldHVybntjdXJyZW50Om51bGx9fWZ1bmN0aW9uIGsobil7cmV0dXJuIG4uY2hpbGRyZW59ZnVuY3Rpb24gYihuLGwpe3RoaXMucHJvcHM9bix0aGlzLmNvbnRleHQ9bH1mdW5jdGlvbiB4KG4sbCl7aWYobnVsbD09bClyZXR1cm4gbi5fXz94KG4uX18sbi5fX2krMSk6bnVsbDtmb3IodmFyIHU7bDxuLl9fay5sZW5ndGg7bCsrKWlmKG51bGwhPSh1PW4uX19rW2xdKSYmbnVsbCE9dS5fX2UpcmV0dXJuIHUuX19lO3JldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIG4udHlwZT94KG4pOm51bGx9ZnVuY3Rpb24gQyhuKXt2YXIgbCx1O2lmKG51bGwhPShuPW4uX18pJiZudWxsIT1uLl9fYyl7Zm9yKG4uX19lPW4uX19jLmJhc2U9bnVsbCxsPTA7bDxuLl9fay5sZW5ndGg7bCsrKWlmKG51bGwhPSh1PW4uX19rW2xdKSYmbnVsbCE9dS5fX2Upe24uX19lPW4uX19jLmJhc2U9dS5fX2U7YnJlYWt9cmV0dXJuIEMobil9fWZ1bmN0aW9uIE0obil7KCFuLl9fZCYmKG4uX19kPSEwKSYmaS5wdXNoKG4pJiYhUC5fX3IrK3x8byE9PWwuZGVib3VuY2VSZW5kZXJpbmcpJiYoKG89bC5kZWJvdW5jZVJlbmRlcmluZyl8fHIpKFApfWZ1bmN0aW9uIFAoKXt2YXIgbix1LHQsbyxyLGUsYyxzO2ZvcihpLnNvcnQoZik7bj1pLnNoaWZ0KCk7KW4uX19kJiYodT1pLmxlbmd0aCxvPXZvaWQgMCxlPShyPSh0PW4pLl9fdikuX19lLGM9W10scz1bXSx0Ll9fUCYmKChvPWQoe30scikpLl9fdj1yLl9fdisxLGwudm5vZGUmJmwudm5vZGUobyksTyh0Ll9fUCxvLHIsdC5fX24sdC5fX1AubmFtZXNwYWNlVVJJLDMyJnIuX191P1tlXTpudWxsLGMsbnVsbD09ZT94KHIpOmUsISEoMzImci5fX3UpLHMpLG8uX192PXIuX192LG8uX18uX19rW28uX19pXT1vLGooYyxvLHMpLG8uX19lIT1lJiZDKG8pKSxpLmxlbmd0aD51JiZpLnNvcnQoZikpO1AuX19yPTB9ZnVuY3Rpb24gUyhuLGwsdSx0LGksbyxyLGYsZSxjLHMpe3ZhciBhLHYseSxkLHcsXz10JiZ0Ll9fa3x8cCxnPWwubGVuZ3RoO2Zvcih1Ll9fZD1lLCQodSxsLF8pLGU9dS5fX2QsYT0wO2E8ZzthKyspbnVsbCE9KHk9dS5fX2tbYV0pJiZcImJvb2xlYW5cIiE9dHlwZW9mIHkmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHkmJih2PS0xPT09eS5fX2k/aDpfW3kuX19pXXx8aCx5Ll9faT1hLE8obix5LHYsaSxvLHIsZixlLGMscyksZD15Ll9fZSx5LnJlZiYmdi5yZWYhPXkucmVmJiYodi5yZWYmJk4odi5yZWYsbnVsbCx5KSxzLnB1c2goeS5yZWYseS5fX2N8fGQseSkpLG51bGw9PXcmJm51bGwhPWQmJih3PWQpLDY1NTM2JnkuX191fHx2Ll9faz09PXkuX19rP2U9SSh5LGUsbik6XCJmdW5jdGlvblwiPT10eXBlb2YgeS50eXBlJiZ2b2lkIDAhPT15Ll9fZD9lPXkuX19kOmQmJihlPWQubmV4dFNpYmxpbmcpLHkuX19kPXZvaWQgMCx5Ll9fdSY9LTE5NjYwOSk7dS5fX2Q9ZSx1Ll9fZT13fWZ1bmN0aW9uICQobixsLHUpe3ZhciB0LGksbyxyLGYsZT1sLmxlbmd0aCxjPXUubGVuZ3RoLHM9YyxhPTA7Zm9yKG4uX19rPVtdLHQ9MDt0PGU7dCsrKXI9dCthLG51bGwhPShpPW4uX19rW3RdPW51bGw9PShpPWxbdF0pfHxcImJvb2xlYW5cIj09dHlwZW9mIGl8fFwiZnVuY3Rpb25cIj09dHlwZW9mIGk/bnVsbDpcInN0cmluZ1wiPT10eXBlb2YgaXx8XCJudW1iZXJcIj09dHlwZW9mIGl8fFwiYmlnaW50XCI9PXR5cGVvZiBpfHxpLmNvbnN0cnVjdG9yPT1TdHJpbmc/ZyhudWxsLGksbnVsbCxudWxsLG51bGwpOnkoaSk/ZyhrLHtjaGlsZHJlbjppfSxudWxsLG51bGwsbnVsbCk6dm9pZCAwPT09aS5jb25zdHJ1Y3RvciYmaS5fX2I+MD9nKGkudHlwZSxpLnByb3BzLGkua2V5LGkucmVmP2kucmVmOm51bGwsaS5fX3YpOmkpPyhpLl9fPW4saS5fX2I9bi5fX2IrMSxmPUwoaSx1LHIscyksaS5fX2k9ZixvPW51bGwsLTEhPT1mJiYocy0tLChvPXVbZl0pJiYoby5fX3V8PTEzMTA3MikpLG51bGw9PW98fG51bGw9PT1vLl9fdj8oLTE9PWYmJmEtLSxcImZ1bmN0aW9uXCIhPXR5cGVvZiBpLnR5cGUmJihpLl9fdXw9NjU1MzYpKTpmIT09ciYmKGY9PXItMT9hPWYtcjpmPT1yKzE/YSsrOmY+cj9zPmUtcj9hKz1mLXI6YS0tOmY8ciYmYSsrLGYhPT10K2EmJihpLl9fdXw9NjU1MzYpKSk6KG89dVtyXSkmJm51bGw9PW8ua2V5JiZvLl9fZSYmMD09KDEzMTA3MiZvLl9fdSkmJihvLl9fZT09bi5fX2QmJihuLl9fZD14KG8pKSxWKG8sbywhMSksdVtyXT1udWxsLHMtLSk7aWYocylmb3IodD0wO3Q8Yzt0KyspbnVsbCE9KG89dVt0XSkmJjA9PSgxMzEwNzImby5fX3UpJiYoby5fX2U9PW4uX19kJiYobi5fX2Q9eChvKSksVihvLG8pKX1mdW5jdGlvbiBJKG4sbCx1KXt2YXIgdCxpO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIG4udHlwZSl7Zm9yKHQ9bi5fX2ssaT0wO3QmJmk8dC5sZW5ndGg7aSsrKXRbaV0mJih0W2ldLl9fPW4sbD1JKHRbaV0sbCx1KSk7cmV0dXJuIGx9bi5fX2UhPWwmJihsJiZuLnR5cGUmJiF1LmNvbnRhaW5zKGwpJiYobD14KG4pKSx1Lmluc2VydEJlZm9yZShuLl9fZSxsfHxudWxsKSxsPW4uX19lKTtkb3tsPWwmJmwubmV4dFNpYmxpbmd9d2hpbGUobnVsbCE9bCYmOD09PWwubm9kZVR5cGUpO3JldHVybiBsfWZ1bmN0aW9uIEgobixsKXtyZXR1cm4gbD1sfHxbXSxudWxsPT1ufHxcImJvb2xlYW5cIj09dHlwZW9mIG58fCh5KG4pP24uc29tZShmdW5jdGlvbihuKXtIKG4sbCl9KTpsLnB1c2gobikpLGx9ZnVuY3Rpb24gTChuLGwsdSx0KXt2YXIgaT1uLmtleSxvPW4udHlwZSxyPXUtMSxmPXUrMSxlPWxbdV07aWYobnVsbD09PWV8fGUmJmk9PWUua2V5JiZvPT09ZS50eXBlJiYwPT0oMTMxMDcyJmUuX191KSlyZXR1cm4gdTtpZih0PihudWxsIT1lJiYwPT0oMTMxMDcyJmUuX191KT8xOjApKWZvcig7cj49MHx8ZjxsLmxlbmd0aDspe2lmKHI+PTApe2lmKChlPWxbcl0pJiYwPT0oMTMxMDcyJmUuX191KSYmaT09ZS5rZXkmJm89PT1lLnR5cGUpcmV0dXJuIHI7ci0tfWlmKGY8bC5sZW5ndGgpe2lmKChlPWxbZl0pJiYwPT0oMTMxMDcyJmUuX191KSYmaT09ZS5rZXkmJm89PT1lLnR5cGUpcmV0dXJuIGY7ZisrfX1yZXR1cm4tMX1mdW5jdGlvbiBUKG4sbCx1KXtcIi1cIj09PWxbMF0/bi5zZXRQcm9wZXJ0eShsLG51bGw9PXU/XCJcIjp1KTpuW2xdPW51bGw9PXU/XCJcIjpcIm51bWJlclwiIT10eXBlb2YgdXx8di50ZXN0KGwpP3U6dStcInB4XCJ9ZnVuY3Rpb24gQShuLGwsdSx0LGkpe3ZhciBvO246aWYoXCJzdHlsZVwiPT09bClpZihcInN0cmluZ1wiPT10eXBlb2YgdSluLnN0eWxlLmNzc1RleHQ9dTtlbHNle2lmKFwic3RyaW5nXCI9PXR5cGVvZiB0JiYobi5zdHlsZS5jc3NUZXh0PXQ9XCJcIiksdClmb3IobCBpbiB0KXUmJmwgaW4gdXx8VChuLnN0eWxlLGwsXCJcIik7aWYodSlmb3IobCBpbiB1KXQmJnVbbF09PT10W2xdfHxUKG4uc3R5bGUsbCx1W2xdKX1lbHNlIGlmKFwib1wiPT09bFswXSYmXCJuXCI9PT1sWzFdKW89bCE9PShsPWwucmVwbGFjZSgvKFBvaW50ZXJDYXB0dXJlKSR8Q2FwdHVyZSQvaSxcIiQxXCIpKSxsPWwudG9Mb3dlckNhc2UoKWluIG58fFwib25Gb2N1c091dFwiPT09bHx8XCJvbkZvY3VzSW5cIj09PWw/bC50b0xvd2VyQ2FzZSgpLnNsaWNlKDIpOmwuc2xpY2UoMiksbi5sfHwobi5sPXt9KSxuLmxbbCtvXT11LHU/dD91LnU9dC51Oih1LnU9ZSxuLmFkZEV2ZW50TGlzdGVuZXIobCxvP3M6YyxvKSk6bi5yZW1vdmVFdmVudExpc3RlbmVyKGwsbz9zOmMsbyk7ZWxzZXtpZihcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI9PWkpbD1sLnJlcGxhY2UoL3hsaW5rKEh8OmgpLyxcImhcIikucmVwbGFjZSgvc05hbWUkLyxcInNcIik7ZWxzZSBpZihcIndpZHRoXCIhPWwmJlwiaGVpZ2h0XCIhPWwmJlwiaHJlZlwiIT1sJiZcImxpc3RcIiE9bCYmXCJmb3JtXCIhPWwmJlwidGFiSW5kZXhcIiE9bCYmXCJkb3dubG9hZFwiIT1sJiZcInJvd1NwYW5cIiE9bCYmXCJjb2xTcGFuXCIhPWwmJlwicm9sZVwiIT1sJiZcInBvcG92ZXJcIiE9bCYmbCBpbiBuKXRyeXtuW2xdPW51bGw9PXU/XCJcIjp1O2JyZWFrIG59Y2F0Y2gobil7fVwiZnVuY3Rpb25cIj09dHlwZW9mIHV8fChudWxsPT11fHwhMT09PXUmJlwiLVwiIT09bFs0XT9uLnJlbW92ZUF0dHJpYnV0ZShsKTpuLnNldEF0dHJpYnV0ZShsLFwicG9wb3ZlclwiPT1sJiYxPT11P1wiXCI6dSkpfX1mdW5jdGlvbiBGKG4pe3JldHVybiBmdW5jdGlvbih1KXtpZih0aGlzLmwpe3ZhciB0PXRoaXMubFt1LnR5cGUrbl07aWYobnVsbD09dS50KXUudD1lKys7ZWxzZSBpZih1LnQ8dC51KXJldHVybjtyZXR1cm4gdChsLmV2ZW50P2wuZXZlbnQodSk6dSl9fX1mdW5jdGlvbiBPKG4sdSx0LGksbyxyLGYsZSxjLHMpe3ZhciBhLGgscCx2LHcsXyxnLG0seCxDLE0sUCwkLEksSCxMLFQ9dS50eXBlO2lmKHZvaWQgMCE9PXUuY29uc3RydWN0b3IpcmV0dXJuIG51bGw7MTI4JnQuX191JiYoYz0hISgzMiZ0Ll9fdSkscj1bZT11Ll9fZT10Ll9fZV0pLChhPWwuX19iKSYmYSh1KTtuOmlmKFwiZnVuY3Rpb25cIj09dHlwZW9mIFQpdHJ5e2lmKG09dS5wcm9wcyx4PVwicHJvdG90eXBlXCJpbiBUJiZULnByb3RvdHlwZS5yZW5kZXIsQz0oYT1ULmNvbnRleHRUeXBlKSYmaVthLl9fY10sTT1hP0M/Qy5wcm9wcy52YWx1ZTphLl9fOmksdC5fX2M/Zz0oaD11Ll9fYz10Ll9fYykuX189aC5fX0U6KHg/dS5fX2M9aD1uZXcgVChtLE0pOih1Ll9fYz1oPW5ldyBiKG0sTSksaC5jb25zdHJ1Y3Rvcj1ULGgucmVuZGVyPXEpLEMmJkMuc3ViKGgpLGgucHJvcHM9bSxoLnN0YXRlfHwoaC5zdGF0ZT17fSksaC5jb250ZXh0PU0saC5fX249aSxwPWguX19kPSEwLGguX19oPVtdLGguX3NiPVtdKSx4JiZudWxsPT1oLl9fcyYmKGguX19zPWguc3RhdGUpLHgmJm51bGwhPVQuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzJiYoaC5fX3M9PWguc3RhdGUmJihoLl9fcz1kKHt9LGguX19zKSksZChoLl9fcyxULmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhtLGguX19zKSkpLHY9aC5wcm9wcyx3PWguc3RhdGUsaC5fX3Y9dSxwKXgmJm51bGw9PVQuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzJiZudWxsIT1oLmNvbXBvbmVudFdpbGxNb3VudCYmaC5jb21wb25lbnRXaWxsTW91bnQoKSx4JiZudWxsIT1oLmNvbXBvbmVudERpZE1vdW50JiZoLl9faC5wdXNoKGguY29tcG9uZW50RGlkTW91bnQpO2Vsc2V7aWYoeCYmbnVsbD09VC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMmJm0hPT12JiZudWxsIT1oLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMmJmguY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhtLE0pLCFoLl9fZSYmKG51bGwhPWguc2hvdWxkQ29tcG9uZW50VXBkYXRlJiYhMT09PWguc2hvdWxkQ29tcG9uZW50VXBkYXRlKG0saC5fX3MsTSl8fHUuX192PT09dC5fX3YpKXtmb3IodS5fX3YhPT10Ll9fdiYmKGgucHJvcHM9bSxoLnN0YXRlPWguX19zLGguX19kPSExKSx1Ll9fZT10Ll9fZSx1Ll9faz10Ll9fayx1Ll9fay5mb3JFYWNoKGZ1bmN0aW9uKG4pe24mJihuLl9fPXUpfSksUD0wO1A8aC5fc2IubGVuZ3RoO1ArKyloLl9faC5wdXNoKGguX3NiW1BdKTtoLl9zYj1bXSxoLl9faC5sZW5ndGgmJmYucHVzaChoKTticmVhayBufW51bGwhPWguY29tcG9uZW50V2lsbFVwZGF0ZSYmaC5jb21wb25lbnRXaWxsVXBkYXRlKG0saC5fX3MsTSkseCYmbnVsbCE9aC5jb21wb25lbnREaWRVcGRhdGUmJmguX19oLnB1c2goZnVuY3Rpb24oKXtoLmNvbXBvbmVudERpZFVwZGF0ZSh2LHcsXyl9KX1pZihoLmNvbnRleHQ9TSxoLnByb3BzPW0saC5fX1A9bixoLl9fZT0hMSwkPWwuX19yLEk9MCx4KXtmb3IoaC5zdGF0ZT1oLl9fcyxoLl9fZD0hMSwkJiYkKHUpLGE9aC5yZW5kZXIoaC5wcm9wcyxoLnN0YXRlLGguY29udGV4dCksSD0wO0g8aC5fc2IubGVuZ3RoO0grKyloLl9faC5wdXNoKGguX3NiW0hdKTtoLl9zYj1bXX1lbHNlIGRve2guX19kPSExLCQmJiQodSksYT1oLnJlbmRlcihoLnByb3BzLGguc3RhdGUsaC5jb250ZXh0KSxoLnN0YXRlPWguX19zfXdoaWxlKGguX19kJiYrK0k8MjUpO2guc3RhdGU9aC5fX3MsbnVsbCE9aC5nZXRDaGlsZENvbnRleHQmJihpPWQoZCh7fSxpKSxoLmdldENoaWxkQ29udGV4dCgpKSkseCYmIXAmJm51bGwhPWguZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUmJihfPWguZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUodix3KSksUyhuLHkoTD1udWxsIT1hJiZhLnR5cGU9PT1rJiZudWxsPT1hLmtleT9hLnByb3BzLmNoaWxkcmVuOmEpP0w6W0xdLHUsdCxpLG8scixmLGUsYyxzKSxoLmJhc2U9dS5fX2UsdS5fX3UmPS0xNjEsaC5fX2gubGVuZ3RoJiZmLnB1c2goaCksZyYmKGguX19FPWguX189bnVsbCl9Y2F0Y2gobil7aWYodS5fX3Y9bnVsbCxjfHxudWxsIT1yKXtmb3IodS5fX3V8PWM/MTYwOjMyO2UmJjg9PT1lLm5vZGVUeXBlJiZlLm5leHRTaWJsaW5nOyllPWUubmV4dFNpYmxpbmc7cltyLmluZGV4T2YoZSldPW51bGwsdS5fX2U9ZX1lbHNlIHUuX19lPXQuX19lLHUuX19rPXQuX19rO2wuX19lKG4sdSx0KX1lbHNlIG51bGw9PXImJnUuX192PT09dC5fX3Y/KHUuX19rPXQuX19rLHUuX19lPXQuX19lKTp1Ll9fZT16KHQuX19lLHUsdCxpLG8scixmLGMscyk7KGE9bC5kaWZmZWQpJiZhKHUpfWZ1bmN0aW9uIGoobix1LHQpe3UuX19kPXZvaWQgMDtmb3IodmFyIGk9MDtpPHQubGVuZ3RoO2krKylOKHRbaV0sdFsrK2ldLHRbKytpXSk7bC5fX2MmJmwuX19jKHUsbiksbi5zb21lKGZ1bmN0aW9uKHUpe3RyeXtuPXUuX19oLHUuX19oPVtdLG4uc29tZShmdW5jdGlvbihuKXtuLmNhbGwodSl9KX1jYXRjaChuKXtsLl9fZShuLHUuX192KX19KX1mdW5jdGlvbiB6KGwsdSx0LGksbyxyLGYsZSxjKXt2YXIgcyxhLHAsdixkLF8sZyxtPXQucHJvcHMsaz11LnByb3BzLGI9dS50eXBlO2lmKFwic3ZnXCI9PT1iP289XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiOlwibWF0aFwiPT09Yj9vPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTFwiOm98fChvPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiKSxudWxsIT1yKWZvcihzPTA7czxyLmxlbmd0aDtzKyspaWYoKGQ9cltzXSkmJlwic2V0QXR0cmlidXRlXCJpbiBkPT0hIWImJihiP2QubG9jYWxOYW1lPT09YjozPT09ZC5ub2RlVHlwZSkpe2w9ZCxyW3NdPW51bGw7YnJlYWt9aWYobnVsbD09bCl7aWYobnVsbD09PWIpcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGspO2w9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG8sYixrLmlzJiZrKSxyPW51bGwsZT0hMX1pZihudWxsPT09YiltPT09a3x8ZSYmbC5kYXRhPT09a3x8KGwuZGF0YT1rKTtlbHNle2lmKHI9ciYmbi5jYWxsKGwuY2hpbGROb2RlcyksbT10LnByb3BzfHxoLCFlJiZudWxsIT1yKWZvcihtPXt9LHM9MDtzPGwuYXR0cmlidXRlcy5sZW5ndGg7cysrKW1bKGQ9bC5hdHRyaWJ1dGVzW3NdKS5uYW1lXT1kLnZhbHVlO2ZvcihzIGluIG0paWYoZD1tW3NdLFwiY2hpbGRyZW5cIj09cyk7ZWxzZSBpZihcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI9PXMpcD1kO2Vsc2UgaWYoXCJrZXlcIiE9PXMmJiEocyBpbiBrKSl7aWYoXCJ2YWx1ZVwiPT1zJiZcImRlZmF1bHRWYWx1ZVwiaW4ga3x8XCJjaGVja2VkXCI9PXMmJlwiZGVmYXVsdENoZWNrZWRcImluIGspY29udGludWU7QShsLHMsbnVsbCxkLG8pfWZvcihzIGluIGspZD1rW3NdLFwiY2hpbGRyZW5cIj09cz92PWQ6XCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiPT1zP2E9ZDpcInZhbHVlXCI9PXM/Xz1kOlwiY2hlY2tlZFwiPT1zP2c9ZDpcImtleVwiPT09c3x8ZSYmXCJmdW5jdGlvblwiIT10eXBlb2YgZHx8bVtzXT09PWR8fEEobCxzLGQsbVtzXSxvKTtpZihhKWV8fHAmJihhLl9faHRtbD09PXAuX19odG1sfHxhLl9faHRtbD09PWwuaW5uZXJIVE1MKXx8KGwuaW5uZXJIVE1MPWEuX19odG1sKSx1Ll9faz1bXTtlbHNlIGlmKHAmJihsLmlubmVySFRNTD1cIlwiKSxTKGwseSh2KT92Olt2XSx1LHQsaSxcImZvcmVpZ25PYmplY3RcIj09PWI/XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCI6byxyLGYscj9yWzBdOnQuX19rJiZ4KHQsMCksZSxjKSxudWxsIT1yKWZvcihzPXIubGVuZ3RoO3MtLTspbnVsbCE9cltzXSYmdyhyW3NdKTtlfHwocz1cInZhbHVlXCIsdm9pZCAwIT09XyYmKF8hPT1sW3NdfHxcInByb2dyZXNzXCI9PT1iJiYhX3x8XCJvcHRpb25cIj09PWImJl8hPT1tW3NdKSYmQShsLHMsXyxtW3NdLG8pLHM9XCJjaGVja2VkXCIsdm9pZCAwIT09ZyYmZyE9PWxbc10mJkEobCxzLGcsbVtzXSxvKSl9cmV0dXJuIGx9ZnVuY3Rpb24gTihuLHUsdCl7dHJ5e2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIG4pe3ZhciBpPVwiZnVuY3Rpb25cIj09dHlwZW9mIG4uX191O2kmJm4uX191KCksaSYmbnVsbD09dXx8KG4uX191PW4odSkpfWVsc2Ugbi5jdXJyZW50PXV9Y2F0Y2gobil7bC5fX2Uobix0KX19ZnVuY3Rpb24gVihuLHUsdCl7dmFyIGksbztpZihsLnVubW91bnQmJmwudW5tb3VudChuKSwoaT1uLnJlZikmJihpLmN1cnJlbnQmJmkuY3VycmVudCE9PW4uX19lfHxOKGksbnVsbCx1KSksbnVsbCE9KGk9bi5fX2MpKXtpZihpLmNvbXBvbmVudFdpbGxVbm1vdW50KXRyeXtpLmNvbXBvbmVudFdpbGxVbm1vdW50KCl9Y2F0Y2gobil7bC5fX2Uobix1KX1pLmJhc2U9aS5fX1A9bnVsbH1pZihpPW4uX19rKWZvcihvPTA7bzxpLmxlbmd0aDtvKyspaVtvXSYmVihpW29dLHUsdHx8XCJmdW5jdGlvblwiIT10eXBlb2Ygbi50eXBlKTt0fHxudWxsPT1uLl9fZXx8dyhuLl9fZSksbi5fX2M9bi5fXz1uLl9fZT1uLl9fZD12b2lkIDB9ZnVuY3Rpb24gcShuLGwsdSl7cmV0dXJuIHRoaXMuY29uc3RydWN0b3Iobix1KX1mdW5jdGlvbiBCKHUsdCxpKXt2YXIgbyxyLGYsZTtsLl9fJiZsLl9fKHUsdCkscj0obz1cImZ1bmN0aW9uXCI9PXR5cGVvZiBpKT9udWxsOmkmJmkuX19rfHx0Ll9fayxmPVtdLGU9W10sTyh0LHU9KCFvJiZpfHx0KS5fX2s9XyhrLG51bGwsW3VdKSxyfHxoLGgsdC5uYW1lc3BhY2VVUkksIW8mJmk/W2ldOnI/bnVsbDp0LmZpcnN0Q2hpbGQ/bi5jYWxsKHQuY2hpbGROb2Rlcyk6bnVsbCxmLCFvJiZpP2k6cj9yLl9fZTp0LmZpcnN0Q2hpbGQsbyxlKSxqKGYsdSxlKX1mdW5jdGlvbiBEKG4sbCl7QihuLGwsRCl9ZnVuY3Rpb24gRShsLHUsdCl7dmFyIGksbyxyLGYsZT1kKHt9LGwucHJvcHMpO2ZvcihyIGluIGwudHlwZSYmbC50eXBlLmRlZmF1bHRQcm9wcyYmKGY9bC50eXBlLmRlZmF1bHRQcm9wcyksdSlcImtleVwiPT1yP2k9dVtyXTpcInJlZlwiPT1yP289dVtyXTplW3JdPXZvaWQgMD09PXVbcl0mJnZvaWQgMCE9PWY/ZltyXTp1W3JdO3JldHVybiBhcmd1bWVudHMubGVuZ3RoPjImJihlLmNoaWxkcmVuPWFyZ3VtZW50cy5sZW5ndGg+Mz9uLmNhbGwoYXJndW1lbnRzLDIpOnQpLGcobC50eXBlLGUsaXx8bC5rZXksb3x8bC5yZWYsbnVsbCl9ZnVuY3Rpb24gRyhuLGwpe3ZhciB1PXtfX2M6bD1cIl9fY0NcIithKyssX186bixDb25zdW1lcjpmdW5jdGlvbihuLGwpe3JldHVybiBuLmNoaWxkcmVuKGwpfSxQcm92aWRlcjpmdW5jdGlvbihuKXt2YXIgdSx0O3JldHVybiB0aGlzLmdldENoaWxkQ29udGV4dHx8KHU9W10sKHQ9e30pW2xdPXRoaXMsdGhpcy5nZXRDaGlsZENvbnRleHQ9ZnVuY3Rpb24oKXtyZXR1cm4gdH0sdGhpcy5jb21wb25lbnRXaWxsVW5tb3VudD1mdW5jdGlvbigpe3U9bnVsbH0sdGhpcy5zaG91bGRDb21wb25lbnRVcGRhdGU9ZnVuY3Rpb24obil7dGhpcy5wcm9wcy52YWx1ZSE9PW4udmFsdWUmJnUuc29tZShmdW5jdGlvbihuKXtuLl9fZT0hMCxNKG4pfSl9LHRoaXMuc3ViPWZ1bmN0aW9uKG4pe3UucHVzaChuKTt2YXIgbD1uLmNvbXBvbmVudFdpbGxVbm1vdW50O24uY29tcG9uZW50V2lsbFVubW91bnQ9ZnVuY3Rpb24oKXt1JiZ1LnNwbGljZSh1LmluZGV4T2YobiksMSksbCYmbC5jYWxsKG4pfX0pLG4uY2hpbGRyZW59fTtyZXR1cm4gdS5Qcm92aWRlci5fXz11LkNvbnN1bWVyLmNvbnRleHRUeXBlPXV9bj1wLnNsaWNlLGw9e19fZTpmdW5jdGlvbihuLGwsdSx0KXtmb3IodmFyIGksbyxyO2w9bC5fXzspaWYoKGk9bC5fX2MpJiYhaS5fXyl0cnl7aWYoKG89aS5jb25zdHJ1Y3RvcikmJm51bGwhPW8uZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yJiYoaS5zZXRTdGF0ZShvLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvcihuKSkscj1pLl9fZCksbnVsbCE9aS5jb21wb25lbnREaWRDYXRjaCYmKGkuY29tcG9uZW50RGlkQ2F0Y2gobix0fHx7fSkscj1pLl9fZCkscilyZXR1cm4gaS5fX0U9aX1jYXRjaChsKXtuPWx9dGhyb3cgbn19LHU9MCx0PWZ1bmN0aW9uKG4pe3JldHVybiBudWxsIT1uJiZudWxsPT1uLmNvbnN0cnVjdG9yfSxiLnByb3RvdHlwZS5zZXRTdGF0ZT1mdW5jdGlvbihuLGwpe3ZhciB1O3U9bnVsbCE9dGhpcy5fX3MmJnRoaXMuX19zIT09dGhpcy5zdGF0ZT90aGlzLl9fczp0aGlzLl9fcz1kKHt9LHRoaXMuc3RhdGUpLFwiZnVuY3Rpb25cIj09dHlwZW9mIG4mJihuPW4oZCh7fSx1KSx0aGlzLnByb3BzKSksbiYmZCh1LG4pLG51bGwhPW4mJnRoaXMuX192JiYobCYmdGhpcy5fc2IucHVzaChsKSxNKHRoaXMpKX0sYi5wcm90b3R5cGUuZm9yY2VVcGRhdGU9ZnVuY3Rpb24obil7dGhpcy5fX3YmJih0aGlzLl9fZT0hMCxuJiZ0aGlzLl9faC5wdXNoKG4pLE0odGhpcykpfSxiLnByb3RvdHlwZS5yZW5kZXI9ayxpPVtdLHI9XCJmdW5jdGlvblwiPT10eXBlb2YgUHJvbWlzZT9Qcm9taXNlLnByb3RvdHlwZS50aGVuLmJpbmQoUHJvbWlzZS5yZXNvbHZlKCkpOnNldFRpbWVvdXQsZj1mdW5jdGlvbihuLGwpe3JldHVybiBuLl9fdi5fX2ItbC5fX3YuX19ifSxQLl9fcj0wLGU9MCxjPUYoITEpLHM9RighMCksYT0wO2V4cG9ydHtiIGFzIENvbXBvbmVudCxrIGFzIEZyYWdtZW50LEUgYXMgY2xvbmVFbGVtZW50LEcgYXMgY3JlYXRlQ29udGV4dCxfIGFzIGNyZWF0ZUVsZW1lbnQsbSBhcyBjcmVhdGVSZWYsXyBhcyBoLEQgYXMgaHlkcmF0ZSx0IGFzIGlzVmFsaWRFbGVtZW50LGwgYXMgb3B0aW9ucyxCIGFzIHJlbmRlcixIIGFzIHRvQ2hpbGRBcnJheX07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcmVhY3QubW9kdWxlLmpzLm1hcFxuIiwiaW1wb3J0e29wdGlvbnMgYXMgbn1mcm9tXCJwcmVhY3RcIjt2YXIgdCxyLHUsaSxvPTAsZj1bXSxjPW4sZT1jLl9fYixhPWMuX19yLHY9Yy5kaWZmZWQsbD1jLl9fYyxtPWMudW5tb3VudCxzPWMuX187ZnVuY3Rpb24gZChuLHQpe2MuX19oJiZjLl9faChyLG4sb3x8dCksbz0wO3ZhciB1PXIuX19IfHwoci5fX0g9e19fOltdLF9faDpbXX0pO3JldHVybiBuPj11Ll9fLmxlbmd0aCYmdS5fXy5wdXNoKHt9KSx1Ll9fW25dfWZ1bmN0aW9uIGgobil7cmV0dXJuIG89MSxwKEQsbil9ZnVuY3Rpb24gcChuLHUsaSl7dmFyIG89ZCh0KyssMik7aWYoby50PW4sIW8uX19jJiYoby5fXz1baT9pKHUpOkQodm9pZCAwLHUpLGZ1bmN0aW9uKG4pe3ZhciB0PW8uX19OP28uX19OWzBdOm8uX19bMF0scj1vLnQodCxuKTt0IT09ciYmKG8uX19OPVtyLG8uX19bMV1dLG8uX19jLnNldFN0YXRlKHt9KSl9XSxvLl9fYz1yLCFyLnUpKXt2YXIgZj1mdW5jdGlvbihuLHQscil7aWYoIW8uX19jLl9fSClyZXR1cm4hMDt2YXIgdT1vLl9fYy5fX0guX18uZmlsdGVyKGZ1bmN0aW9uKG4pe3JldHVybiEhbi5fX2N9KTtpZih1LmV2ZXJ5KGZ1bmN0aW9uKG4pe3JldHVybiFuLl9fTn0pKXJldHVybiFjfHxjLmNhbGwodGhpcyxuLHQscik7dmFyIGk9ITE7cmV0dXJuIHUuZm9yRWFjaChmdW5jdGlvbihuKXtpZihuLl9fTil7dmFyIHQ9bi5fX1swXTtuLl9fPW4uX19OLG4uX19OPXZvaWQgMCx0IT09bi5fX1swXSYmKGk9ITApfX0pLCEoIWkmJm8uX19jLnByb3BzPT09bikmJighY3x8Yy5jYWxsKHRoaXMsbix0LHIpKX07ci51PSEwO3ZhciBjPXIuc2hvdWxkQ29tcG9uZW50VXBkYXRlLGU9ci5jb21wb25lbnRXaWxsVXBkYXRlO3IuY29tcG9uZW50V2lsbFVwZGF0ZT1mdW5jdGlvbihuLHQscil7aWYodGhpcy5fX2Upe3ZhciB1PWM7Yz12b2lkIDAsZihuLHQsciksYz11fWUmJmUuY2FsbCh0aGlzLG4sdCxyKX0sci5zaG91bGRDb21wb25lbnRVcGRhdGU9Zn1yZXR1cm4gby5fX058fG8uX199ZnVuY3Rpb24geShuLHUpe3ZhciBpPWQodCsrLDMpOyFjLl9fcyYmQyhpLl9fSCx1KSYmKGkuX189bixpLmk9dSxyLl9fSC5fX2gucHVzaChpKSl9ZnVuY3Rpb24gXyhuLHUpe3ZhciBpPWQodCsrLDQpOyFjLl9fcyYmQyhpLl9fSCx1KSYmKGkuX189bixpLmk9dSxyLl9faC5wdXNoKGkpKX1mdW5jdGlvbiBBKG4pe3JldHVybiBvPTUsVChmdW5jdGlvbigpe3JldHVybntjdXJyZW50Om59fSxbXSl9ZnVuY3Rpb24gRihuLHQscil7bz02LF8oZnVuY3Rpb24oKXtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiBuPyhuKHQoKSksZnVuY3Rpb24oKXtyZXR1cm4gbihudWxsKX0pOm4/KG4uY3VycmVudD10KCksZnVuY3Rpb24oKXtyZXR1cm4gbi5jdXJyZW50PW51bGx9KTp2b2lkIDB9LG51bGw9PXI/cjpyLmNvbmNhdChuKSl9ZnVuY3Rpb24gVChuLHIpe3ZhciB1PWQodCsrLDcpO3JldHVybiBDKHUuX19ILHIpJiYodS5fXz1uKCksdS5fX0g9cix1Ll9faD1uKSx1Ll9ffWZ1bmN0aW9uIHEobix0KXtyZXR1cm4gbz04LFQoZnVuY3Rpb24oKXtyZXR1cm4gbn0sdCl9ZnVuY3Rpb24geChuKXt2YXIgdT1yLmNvbnRleHRbbi5fX2NdLGk9ZCh0KyssOSk7cmV0dXJuIGkuYz1uLHU/KG51bGw9PWkuX18mJihpLl9fPSEwLHUuc3ViKHIpKSx1LnByb3BzLnZhbHVlKTpuLl9ffWZ1bmN0aW9uIFAobix0KXtjLnVzZURlYnVnVmFsdWUmJmMudXNlRGVidWdWYWx1ZSh0P3Qobik6bil9ZnVuY3Rpb24gYihuKXt2YXIgdT1kKHQrKywxMCksaT1oKCk7cmV0dXJuIHUuX189bixyLmNvbXBvbmVudERpZENhdGNofHwoci5jb21wb25lbnREaWRDYXRjaD1mdW5jdGlvbihuLHQpe3UuX18mJnUuX18obix0KSxpWzFdKG4pfSksW2lbMF0sZnVuY3Rpb24oKXtpWzFdKHZvaWQgMCl9XX1mdW5jdGlvbiBnKCl7dmFyIG49ZCh0KyssMTEpO2lmKCFuLl9fKXtmb3IodmFyIHU9ci5fX3Y7bnVsbCE9PXUmJiF1Ll9fbSYmbnVsbCE9PXUuX187KXU9dS5fXzt2YXIgaT11Ll9fbXx8KHUuX19tPVswLDBdKTtuLl9fPVwiUFwiK2lbMF0rXCItXCIraVsxXSsrfXJldHVybiBuLl9ffWZ1bmN0aW9uIGooKXtmb3IodmFyIG47bj1mLnNoaWZ0KCk7KWlmKG4uX19QJiZuLl9fSCl0cnl7bi5fX0guX19oLmZvckVhY2goeiksbi5fX0guX19oLmZvckVhY2goQiksbi5fX0guX19oPVtdfWNhdGNoKHQpe24uX19ILl9faD1bXSxjLl9fZSh0LG4uX192KX19Yy5fX2I9ZnVuY3Rpb24obil7cj1udWxsLGUmJmUobil9LGMuX189ZnVuY3Rpb24obix0KXtuJiZ0Ll9fayYmdC5fX2suX19tJiYobi5fX209dC5fX2suX19tKSxzJiZzKG4sdCl9LGMuX19yPWZ1bmN0aW9uKG4pe2EmJmEobiksdD0wO3ZhciBpPShyPW4uX19jKS5fX0g7aSYmKHU9PT1yPyhpLl9faD1bXSxyLl9faD1bXSxpLl9fLmZvckVhY2goZnVuY3Rpb24obil7bi5fX04mJihuLl9fPW4uX19OKSxuLmk9bi5fX049dm9pZCAwfSkpOihpLl9faC5mb3JFYWNoKHopLGkuX19oLmZvckVhY2goQiksaS5fX2g9W10sdD0wKSksdT1yfSxjLmRpZmZlZD1mdW5jdGlvbihuKXt2JiZ2KG4pO3ZhciB0PW4uX19jO3QmJnQuX19IJiYodC5fX0guX19oLmxlbmd0aCYmKDEhPT1mLnB1c2godCkmJmk9PT1jLnJlcXVlc3RBbmltYXRpb25GcmFtZXx8KChpPWMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKXx8dykoaikpLHQuX19ILl9fLmZvckVhY2goZnVuY3Rpb24obil7bi5pJiYobi5fX0g9bi5pKSxuLmk9dm9pZCAwfSkpLHU9cj1udWxsfSxjLl9fYz1mdW5jdGlvbihuLHQpe3Quc29tZShmdW5jdGlvbihuKXt0cnl7bi5fX2guZm9yRWFjaCh6KSxuLl9faD1uLl9faC5maWx0ZXIoZnVuY3Rpb24obil7cmV0dXJuIW4uX198fEIobil9KX1jYXRjaChyKXt0LnNvbWUoZnVuY3Rpb24obil7bi5fX2gmJihuLl9faD1bXSl9KSx0PVtdLGMuX19lKHIsbi5fX3YpfX0pLGwmJmwobix0KX0sYy51bm1vdW50PWZ1bmN0aW9uKG4pe20mJm0obik7dmFyIHQscj1uLl9fYztyJiZyLl9fSCYmKHIuX19ILl9fLmZvckVhY2goZnVuY3Rpb24obil7dHJ5e3oobil9Y2F0Y2gobil7dD1ufX0pLHIuX19IPXZvaWQgMCx0JiZjLl9fZSh0LHIuX192KSl9O3ZhciBrPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVlc3RBbmltYXRpb25GcmFtZTtmdW5jdGlvbiB3KG4pe3ZhciB0LHI9ZnVuY3Rpb24oKXtjbGVhclRpbWVvdXQodSksayYmY2FuY2VsQW5pbWF0aW9uRnJhbWUodCksc2V0VGltZW91dChuKX0sdT1zZXRUaW1lb3V0KHIsMTAwKTtrJiYodD1yZXF1ZXN0QW5pbWF0aW9uRnJhbWUocikpfWZ1bmN0aW9uIHoobil7dmFyIHQ9cix1PW4uX19jO1wiZnVuY3Rpb25cIj09dHlwZW9mIHUmJihuLl9fYz12b2lkIDAsdSgpKSxyPXR9ZnVuY3Rpb24gQihuKXt2YXIgdD1yO24uX19jPW4uX18oKSxyPXR9ZnVuY3Rpb24gQyhuLHQpe3JldHVybiFufHxuLmxlbmd0aCE9PXQubGVuZ3RofHx0LnNvbWUoZnVuY3Rpb24odCxyKXtyZXR1cm4gdCE9PW5bcl19KX1mdW5jdGlvbiBEKG4sdCl7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgdD90KG4pOnR9ZXhwb3J0e3EgYXMgdXNlQ2FsbGJhY2sseCBhcyB1c2VDb250ZXh0LFAgYXMgdXNlRGVidWdWYWx1ZSx5IGFzIHVzZUVmZmVjdCxiIGFzIHVzZUVycm9yQm91bmRhcnksZyBhcyB1c2VJZCxGIGFzIHVzZUltcGVyYXRpdmVIYW5kbGUsXyBhcyB1c2VMYXlvdXRFZmZlY3QsVCBhcyB1c2VNZW1vLHAgYXMgdXNlUmVkdWNlcixBIGFzIHVzZVJlZixoIGFzIHVzZVN0YXRlfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhvb2tzLm1vZHVsZS5qcy5tYXBcbiIsImltcG9ydHtvcHRpb25zIGFzIHIsRnJhZ21lbnQgYXMgZX1mcm9tXCJwcmVhY3RcIjtleHBvcnR7RnJhZ21lbnR9ZnJvbVwicHJlYWN0XCI7dmFyIHQ9L1tcIiY8XS87ZnVuY3Rpb24gbihyKXtpZigwPT09ci5sZW5ndGh8fCExPT09dC50ZXN0KHIpKXJldHVybiByO2Zvcih2YXIgZT0wLG49MCxvPVwiXCIsZj1cIlwiO248ci5sZW5ndGg7bisrKXtzd2l0Y2goci5jaGFyQ29kZUF0KG4pKXtjYXNlIDM0OmY9XCImcXVvdDtcIjticmVhaztjYXNlIDM4OmY9XCImYW1wO1wiO2JyZWFrO2Nhc2UgNjA6Zj1cIiZsdDtcIjticmVhaztkZWZhdWx0OmNvbnRpbnVlfW4hPT1lJiYobys9ci5zbGljZShlLG4pKSxvKz1mLGU9bisxfXJldHVybiBuIT09ZSYmKG8rPXIuc2xpY2UoZSxuKSksb312YXIgbz0vYWNpdHxleCg/OnN8Z3xufHB8JCl8cnBofGdyaWR8b3dzfG1uY3xudHd8aW5lW2NoXXx6b298Xm9yZHxpdGVyYS9pLGY9MCxpPUFycmF5LmlzQXJyYXk7ZnVuY3Rpb24gdShlLHQsbixvLGksdSl7dHx8KHQ9e30pO3ZhciBhLGMscD10O2lmKFwicmVmXCJpbiBwKWZvcihjIGluIHA9e30sdClcInJlZlwiPT1jP2E9dFtjXTpwW2NdPXRbY107dmFyIGw9e3R5cGU6ZSxwcm9wczpwLGtleTpuLHJlZjphLF9fazpudWxsLF9fOm51bGwsX19iOjAsX19lOm51bGwsX19kOnZvaWQgMCxfX2M6bnVsbCxjb25zdHJ1Y3Rvcjp2b2lkIDAsX192Oi0tZixfX2k6LTEsX191OjAsX19zb3VyY2U6aSxfX3NlbGY6dX07aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgZSYmKGE9ZS5kZWZhdWx0UHJvcHMpKWZvcihjIGluIGEpdm9pZCAwPT09cFtjXSYmKHBbY109YVtjXSk7cmV0dXJuIHIudm5vZGUmJnIudm5vZGUobCksbH1mdW5jdGlvbiBhKHIpe3ZhciB0PXUoZSx7dHBsOnIsZXhwcnM6W10uc2xpY2UuY2FsbChhcmd1bWVudHMsMSl9KTtyZXR1cm4gdC5rZXk9dC5fX3YsdH12YXIgYz17fSxwPS9bQS1aXS9nO2Z1bmN0aW9uIGwoZSx0KXtpZihyLmF0dHIpe3ZhciBmPXIuYXR0cihlLHQpO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBmKXJldHVybiBmfWlmKFwicmVmXCI9PT1lfHxcImtleVwiPT09ZSlyZXR1cm5cIlwiO2lmKFwic3R5bGVcIj09PWUmJlwib2JqZWN0XCI9PXR5cGVvZiB0KXt2YXIgaT1cIlwiO2Zvcih2YXIgdSBpbiB0KXt2YXIgYT10W3VdO2lmKG51bGwhPWEmJlwiXCIhPT1hKXt2YXIgbD1cIi1cIj09dVswXT91OmNbdV18fChjW3VdPXUucmVwbGFjZShwLFwiLSQmXCIpLnRvTG93ZXJDYXNlKCkpLF89XCI7XCI7XCJudW1iZXJcIiE9dHlwZW9mIGF8fGwuc3RhcnRzV2l0aChcIi0tXCIpfHxvLnRlc3QobCl8fChfPVwicHg7XCIpLGk9aStsK1wiOlwiK2ErX319cmV0dXJuIGUrJz1cIicraSsnXCInfXJldHVybiBudWxsPT10fHwhMT09PXR8fFwiZnVuY3Rpb25cIj09dHlwZW9mIHR8fFwib2JqZWN0XCI9PXR5cGVvZiB0P1wiXCI6ITA9PT10P2U6ZSsnPVwiJytuKHQpKydcIid9ZnVuY3Rpb24gXyhyKXtpZihudWxsPT1yfHxcImJvb2xlYW5cIj09dHlwZW9mIHJ8fFwiZnVuY3Rpb25cIj09dHlwZW9mIHIpcmV0dXJuIG51bGw7aWYoXCJvYmplY3RcIj09dHlwZW9mIHIpe2lmKHZvaWQgMD09PXIuY29uc3RydWN0b3IpcmV0dXJuIHI7aWYoaShyKSl7Zm9yKHZhciBlPTA7ZTxyLmxlbmd0aDtlKyspcltlXT1fKHJbZV0pO3JldHVybiByfX1yZXR1cm4gbihcIlwiK3IpfWV4cG9ydHt1IGFzIGpzeCxsIGFzIGpzeEF0dHIsdSBhcyBqc3hERVYsXyBhcyBqc3hFc2NhcGUsYSBhcyBqc3hUZW1wbGF0ZSx1IGFzIGpzeHN9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9anN4UnVudGltZS5tb2R1bGUuanMubWFwXG4iLCJcbiAgICAgIGltcG9ydCBBUEkgZnJvbSBcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIjtcbiAgICAgIGltcG9ydCBkb21BUEkgZnJvbSBcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZURvbUFQSS5qc1wiO1xuICAgICAgaW1wb3J0IGluc2VydEZuIGZyb20gXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5zZXJ0QnlTZWxlY3Rvci5qc1wiO1xuICAgICAgaW1wb3J0IHNldEF0dHJpYnV0ZXMgZnJvbSBcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXMuanNcIjtcbiAgICAgIGltcG9ydCBpbnNlcnRTdHlsZUVsZW1lbnQgZnJvbSBcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRTdHlsZUVsZW1lbnQuanNcIjtcbiAgICAgIGltcG9ydCBzdHlsZVRhZ1RyYW5zZm9ybUZuIGZyb20gXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc3R5bGVUYWdUcmFuc2Zvcm0uanNcIjtcbiAgICAgIGltcG9ydCBjb250ZW50LCAqIGFzIG5hbWVkRXhwb3J0IGZyb20gXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL2dsb2JhbHMuY3NzXCI7XG4gICAgICBcbiAgICAgIFxuXG52YXIgb3B0aW9ucyA9IHt9O1xuXG5vcHRpb25zLnN0eWxlVGFnVHJhbnNmb3JtID0gc3R5bGVUYWdUcmFuc2Zvcm1Gbjtcbm9wdGlvbnMuc2V0QXR0cmlidXRlcyA9IHNldEF0dHJpYnV0ZXM7XG5cbiAgICAgIG9wdGlvbnMuaW5zZXJ0ID0gaW5zZXJ0Rm4uYmluZChudWxsLCBcImhlYWRcIik7XG4gICAgXG5vcHRpb25zLmRvbUFQSSA9IGRvbUFQSTtcbm9wdGlvbnMuaW5zZXJ0U3R5bGVFbGVtZW50ID0gaW5zZXJ0U3R5bGVFbGVtZW50O1xuXG52YXIgdXBkYXRlID0gQVBJKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cbmlmIChtb2R1bGUuaG90KSB7XG4gIGlmICghY29udGVudC5sb2NhbHMgfHwgbW9kdWxlLmhvdC5pbnZhbGlkYXRlKSB7XG4gICAgdmFyIGlzRXF1YWxMb2NhbHMgPSBmdW5jdGlvbiBpc0VxdWFsTG9jYWxzKGEsIGIsIGlzTmFtZWRFeHBvcnQpIHtcbiAgaWYgKCFhICYmIGIgfHwgYSAmJiAhYikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcDtcbiAgZm9yIChwIGluIGEpIHtcbiAgICBpZiAoaXNOYW1lZEV4cG9ydCAmJiBwID09PSBcImRlZmF1bHRcIikge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRpbnVlXG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGFbcF0gIT09IGJbcF0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZm9yIChwIGluIGIpIHtcbiAgICBpZiAoaXNOYW1lZEV4cG9ydCAmJiBwID09PSBcImRlZmF1bHRcIikge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRpbnVlXG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKCFhW3BdKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufTtcbiAgICB2YXIgaXNOYW1lZEV4cG9ydCA9ICFjb250ZW50LmxvY2FscztcbiAgICB2YXIgb2xkTG9jYWxzID0gaXNOYW1lZEV4cG9ydCA/IG5hbWVkRXhwb3J0IDogY29udGVudC5sb2NhbHM7XG5cbiAgICBtb2R1bGUuaG90LmFjY2VwdChcbiAgICAgIFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvZGlzdC9janMuanMhLi9nbG9iYWxzLmNzc1wiLFxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWlzRXF1YWxMb2NhbHMob2xkTG9jYWxzLCBpc05hbWVkRXhwb3J0ID8gbmFtZWRFeHBvcnQgOiBjb250ZW50LmxvY2FscywgaXNOYW1lZEV4cG9ydCkpIHtcbiAgICAgICAgICAgICAgICBtb2R1bGUuaG90LmludmFsaWRhdGUoKTtcblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG9sZExvY2FscyA9IGlzTmFtZWRFeHBvcnQgPyBuYW1lZEV4cG9ydCA6IGNvbnRlbnQubG9jYWxzO1xuXG4gICAgICAgICAgICAgIHVwZGF0ZShjb250ZW50KTtcbiAgICAgIH1cbiAgICApXG4gIH1cblxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7XG4gICAgdXBkYXRlKCk7XG4gIH0pO1xufVxuXG5cbmV4cG9ydCAqIGZyb20gXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL2dsb2JhbHMuY3NzXCI7XG4gICAgICAgZXhwb3J0IGRlZmF1bHQgY29udGVudCAmJiBjb250ZW50LmxvY2FscyA/IGNvbnRlbnQubG9jYWxzIDogdW5kZWZpbmVkO1xuIiwiXG4gICAgICBpbXBvcnQgQVBJIGZyb20gXCIhLi4vLi4vLi4vc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIjtcbiAgICAgIGltcG9ydCBkb21BUEkgZnJvbSBcIiEuLi8uLi8uLi9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3N0eWxlRG9tQVBJLmpzXCI7XG4gICAgICBpbXBvcnQgaW5zZXJ0Rm4gZnJvbSBcIiEuLi8uLi8uLi9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydEJ5U2VsZWN0b3IuanNcIjtcbiAgICAgIGltcG9ydCBzZXRBdHRyaWJ1dGVzIGZyb20gXCIhLi4vLi4vLi4vc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXMuanNcIjtcbiAgICAgIGltcG9ydCBpbnNlcnRTdHlsZUVsZW1lbnQgZnJvbSBcIiEuLi8uLi8uLi9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydFN0eWxlRWxlbWVudC5qc1wiO1xuICAgICAgaW1wb3J0IHN0eWxlVGFnVHJhbnNmb3JtRm4gZnJvbSBcIiEuLi8uLi8uLi9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3N0eWxlVGFnVHJhbnNmb3JtLmpzXCI7XG4gICAgICBpbXBvcnQgY29udGVudCwgKiBhcyBuYW1lZEV4cG9ydCBmcm9tIFwiISEuLi8uLi8uLi9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uLy4uL3Bvc3Rjc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vZmxpY2tpbmcuY3NzXCI7XG4gICAgICBcbiAgICAgIFxuXG52YXIgb3B0aW9ucyA9IHt9O1xuXG5vcHRpb25zLnN0eWxlVGFnVHJhbnNmb3JtID0gc3R5bGVUYWdUcmFuc2Zvcm1Gbjtcbm9wdGlvbnMuc2V0QXR0cmlidXRlcyA9IHNldEF0dHJpYnV0ZXM7XG5cbiAgICAgIG9wdGlvbnMuaW5zZXJ0ID0gaW5zZXJ0Rm4uYmluZChudWxsLCBcImhlYWRcIik7XG4gICAgXG5vcHRpb25zLmRvbUFQSSA9IGRvbUFQSTtcbm9wdGlvbnMuaW5zZXJ0U3R5bGVFbGVtZW50ID0gaW5zZXJ0U3R5bGVFbGVtZW50O1xuXG52YXIgdXBkYXRlID0gQVBJKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cbmlmIChtb2R1bGUuaG90KSB7XG4gIGlmICghY29udGVudC5sb2NhbHMgfHwgbW9kdWxlLmhvdC5pbnZhbGlkYXRlKSB7XG4gICAgdmFyIGlzRXF1YWxMb2NhbHMgPSBmdW5jdGlvbiBpc0VxdWFsTG9jYWxzKGEsIGIsIGlzTmFtZWRFeHBvcnQpIHtcbiAgaWYgKCFhICYmIGIgfHwgYSAmJiAhYikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcDtcbiAgZm9yIChwIGluIGEpIHtcbiAgICBpZiAoaXNOYW1lZEV4cG9ydCAmJiBwID09PSBcImRlZmF1bHRcIikge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRpbnVlXG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGFbcF0gIT09IGJbcF0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZm9yIChwIGluIGIpIHtcbiAgICBpZiAoaXNOYW1lZEV4cG9ydCAmJiBwID09PSBcImRlZmF1bHRcIikge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRpbnVlXG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKCFhW3BdKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufTtcbiAgICB2YXIgaXNOYW1lZEV4cG9ydCA9ICFjb250ZW50LmxvY2FscztcbiAgICB2YXIgb2xkTG9jYWxzID0gaXNOYW1lZEV4cG9ydCA/IG5hbWVkRXhwb3J0IDogY29udGVudC5sb2NhbHM7XG5cbiAgICBtb2R1bGUuaG90LmFjY2VwdChcbiAgICAgIFwiISEuLi8uLi8uLi9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uLy4uL3Bvc3Rjc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vZmxpY2tpbmcuY3NzXCIsXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghaXNFcXVhbExvY2FscyhvbGRMb2NhbHMsIGlzTmFtZWRFeHBvcnQgPyBuYW1lZEV4cG9ydCA6IGNvbnRlbnQubG9jYWxzLCBpc05hbWVkRXhwb3J0KSkge1xuICAgICAgICAgICAgICAgIG1vZHVsZS5ob3QuaW52YWxpZGF0ZSgpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgb2xkTG9jYWxzID0gaXNOYW1lZEV4cG9ydCA/IG5hbWVkRXhwb3J0IDogY29udGVudC5sb2NhbHM7XG5cbiAgICAgICAgICAgICAgdXBkYXRlKGNvbnRlbnQpO1xuICAgICAgfVxuICAgIClcbiAgfVxuXG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHtcbiAgICB1cGRhdGUoKTtcbiAgfSk7XG59XG5cblxuZXhwb3J0ICogZnJvbSBcIiEhLi4vLi4vLi4vY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi8uLi9wb3N0Y3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL2ZsaWNraW5nLmNzc1wiO1xuICAgICAgIGV4cG9ydCBkZWZhdWx0IGNvbnRlbnQgJiYgY29udGVudC5sb2NhbHMgPyBjb250ZW50LmxvY2FscyA6IHVuZGVmaW5lZDtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgc3R5bGVzSW5ET00gPSBbXTtcbmZ1bmN0aW9uIGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpIHtcbiAgdmFyIHJlc3VsdCA9IC0xO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlc0luRE9NLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHN0eWxlc0luRE9NW2ldLmlkZW50aWZpZXIgPT09IGlkZW50aWZpZXIpIHtcbiAgICAgIHJlc3VsdCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKSB7XG4gIHZhciBpZENvdW50TWFwID0ge307XG4gIHZhciBpZGVudGlmaWVycyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IGxpc3RbaV07XG4gICAgdmFyIGlkID0gb3B0aW9ucy5iYXNlID8gaXRlbVswXSArIG9wdGlvbnMuYmFzZSA6IGl0ZW1bMF07XG4gICAgdmFyIGNvdW50ID0gaWRDb3VudE1hcFtpZF0gfHwgMDtcbiAgICB2YXIgaWRlbnRpZmllciA9IFwiXCIuY29uY2F0KGlkLCBcIiBcIikuY29uY2F0KGNvdW50KTtcbiAgICBpZENvdW50TWFwW2lkXSA9IGNvdW50ICsgMTtcbiAgICB2YXIgaW5kZXhCeUlkZW50aWZpZXIgPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICB2YXIgb2JqID0ge1xuICAgICAgY3NzOiBpdGVtWzFdLFxuICAgICAgbWVkaWE6IGl0ZW1bMl0sXG4gICAgICBzb3VyY2VNYXA6IGl0ZW1bM10sXG4gICAgICBzdXBwb3J0czogaXRlbVs0XSxcbiAgICAgIGxheWVyOiBpdGVtWzVdXG4gICAgfTtcbiAgICBpZiAoaW5kZXhCeUlkZW50aWZpZXIgIT09IC0xKSB7XG4gICAgICBzdHlsZXNJbkRPTVtpbmRleEJ5SWRlbnRpZmllcl0ucmVmZXJlbmNlcysrO1xuICAgICAgc3R5bGVzSW5ET01baW5kZXhCeUlkZW50aWZpZXJdLnVwZGF0ZXIob2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHVwZGF0ZXIgPSBhZGRFbGVtZW50U3R5bGUob2JqLCBvcHRpb25zKTtcbiAgICAgIG9wdGlvbnMuYnlJbmRleCA9IGk7XG4gICAgICBzdHlsZXNJbkRPTS5zcGxpY2UoaSwgMCwge1xuICAgICAgICBpZGVudGlmaWVyOiBpZGVudGlmaWVyLFxuICAgICAgICB1cGRhdGVyOiB1cGRhdGVyLFxuICAgICAgICByZWZlcmVuY2VzOiAxXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWRlbnRpZmllcnMucHVzaChpZGVudGlmaWVyKTtcbiAgfVxuICByZXR1cm4gaWRlbnRpZmllcnM7XG59XG5mdW5jdGlvbiBhZGRFbGVtZW50U3R5bGUob2JqLCBvcHRpb25zKSB7XG4gIHZhciBhcGkgPSBvcHRpb25zLmRvbUFQSShvcHRpb25zKTtcbiAgYXBpLnVwZGF0ZShvYmopO1xuICB2YXIgdXBkYXRlciA9IGZ1bmN0aW9uIHVwZGF0ZXIobmV3T2JqKSB7XG4gICAgaWYgKG5ld09iaikge1xuICAgICAgaWYgKG5ld09iai5jc3MgPT09IG9iai5jc3MgJiYgbmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiYgbmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcCAmJiBuZXdPYmouc3VwcG9ydHMgPT09IG9iai5zdXBwb3J0cyAmJiBuZXdPYmoubGF5ZXIgPT09IG9iai5sYXllcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBhcGkudXBkYXRlKG9iaiA9IG5ld09iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFwaS5yZW1vdmUoKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiB1cGRhdGVyO1xufVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobGlzdCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgbGlzdCA9IGxpc3QgfHwgW107XG4gIHZhciBsYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obGlzdCwgb3B0aW9ucyk7XG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGUobmV3TGlzdCkge1xuICAgIG5ld0xpc3QgPSBuZXdMaXN0IHx8IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGFzdElkZW50aWZpZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaWRlbnRpZmllciA9IGxhc3RJZGVudGlmaWVyc1tpXTtcbiAgICAgIHZhciBpbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgICAgc3R5bGVzSW5ET01baW5kZXhdLnJlZmVyZW5jZXMtLTtcbiAgICB9XG4gICAgdmFyIG5ld0xhc3RJZGVudGlmaWVycyA9IG1vZHVsZXNUb0RvbShuZXdMaXN0LCBvcHRpb25zKTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbGFzdElkZW50aWZpZXJzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIF9pZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW19pXTtcbiAgICAgIHZhciBfaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihfaWRlbnRpZmllcik7XG4gICAgICBpZiAoc3R5bGVzSW5ET01bX2luZGV4XS5yZWZlcmVuY2VzID09PSAwKSB7XG4gICAgICAgIHN0eWxlc0luRE9NW19pbmRleF0udXBkYXRlcigpO1xuICAgICAgICBzdHlsZXNJbkRPTS5zcGxpY2UoX2luZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGFzdElkZW50aWZpZXJzID0gbmV3TGFzdElkZW50aWZpZXJzO1xuICB9O1xufTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIG1lbW8gPSB7fTtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBnZXRUYXJnZXQodGFyZ2V0KSB7XG4gIGlmICh0eXBlb2YgbWVtb1t0YXJnZXRdID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdmFyIHN0eWxlVGFyZ2V0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpO1xuXG4gICAgLy8gU3BlY2lhbCBjYXNlIHRvIHJldHVybiBoZWFkIG9mIGlmcmFtZSBpbnN0ZWFkIG9mIGlmcmFtZSBpdHNlbGZcbiAgICBpZiAod2luZG93LkhUTUxJRnJhbWVFbGVtZW50ICYmIHN0eWxlVGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50KSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFjY2VzcyB0byBpZnJhbWUgaXMgYmxvY2tlZFxuICAgICAgICAvLyBkdWUgdG8gY3Jvc3Mtb3JpZ2luIHJlc3RyaWN0aW9uc1xuICAgICAgICBzdHlsZVRhcmdldCA9IHN0eWxlVGFyZ2V0LmNvbnRlbnREb2N1bWVudC5oZWFkO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICBzdHlsZVRhcmdldCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIG1lbW9bdGFyZ2V0XSA9IHN0eWxlVGFyZ2V0O1xuICB9XG4gIHJldHVybiBtZW1vW3RhcmdldF07XG59XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gaW5zZXJ0QnlTZWxlY3RvcihpbnNlcnQsIHN0eWxlKSB7XG4gIHZhciB0YXJnZXQgPSBnZXRUYXJnZXQoaW5zZXJ0KTtcbiAgaWYgKCF0YXJnZXQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGEgc3R5bGUgdGFyZ2V0LiBUaGlzIHByb2JhYmx5IG1lYW5zIHRoYXQgdGhlIHZhbHVlIGZvciB0aGUgJ2luc2VydCcgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO1xuICB9XG4gIHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGluc2VydEJ5U2VsZWN0b3I7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpIHtcbiAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gIG9wdGlvbnMuc2V0QXR0cmlidXRlcyhlbGVtZW50LCBvcHRpb25zLmF0dHJpYnV0ZXMpO1xuICBvcHRpb25zLmluc2VydChlbGVtZW50LCBvcHRpb25zLm9wdGlvbnMpO1xuICByZXR1cm4gZWxlbWVudDtcbn1cbm1vZHVsZS5leHBvcnRzID0gaW5zZXJ0U3R5bGVFbGVtZW50OyIsIlwidXNlIHN0cmljdFwiO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cbmZ1bmN0aW9uIHNldEF0dHJpYnV0ZXNXaXRob3V0QXR0cmlidXRlcyhzdHlsZUVsZW1lbnQpIHtcbiAgdmFyIG5vbmNlID0gdHlwZW9mIF9fd2VicGFja19ub25jZV9fICE9PSBcInVuZGVmaW5lZFwiID8gX193ZWJwYWNrX25vbmNlX18gOiBudWxsO1xuICBpZiAobm9uY2UpIHtcbiAgICBzdHlsZUVsZW1lbnQuc2V0QXR0cmlidXRlKFwibm9uY2VcIiwgbm9uY2UpO1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IHNldEF0dHJpYnV0ZXNXaXRob3V0QXR0cmlidXRlczsiLCJcInVzZSBzdHJpY3RcIjtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBhcHBseShzdHlsZUVsZW1lbnQsIG9wdGlvbnMsIG9iaikge1xuICB2YXIgY3NzID0gXCJcIjtcbiAgaWYgKG9iai5zdXBwb3J0cykge1xuICAgIGNzcyArPSBcIkBzdXBwb3J0cyAoXCIuY29uY2F0KG9iai5zdXBwb3J0cywgXCIpIHtcIik7XG4gIH1cbiAgaWYgKG9iai5tZWRpYSkge1xuICAgIGNzcyArPSBcIkBtZWRpYSBcIi5jb25jYXQob2JqLm1lZGlhLCBcIiB7XCIpO1xuICB9XG4gIHZhciBuZWVkTGF5ZXIgPSB0eXBlb2Ygb2JqLmxheWVyICE9PSBcInVuZGVmaW5lZFwiO1xuICBpZiAobmVlZExheWVyKSB7XG4gICAgY3NzICs9IFwiQGxheWVyXCIuY29uY2F0KG9iai5sYXllci5sZW5ndGggPiAwID8gXCIgXCIuY29uY2F0KG9iai5sYXllcikgOiBcIlwiLCBcIiB7XCIpO1xuICB9XG4gIGNzcyArPSBvYmouY3NzO1xuICBpZiAobmVlZExheWVyKSB7XG4gICAgY3NzICs9IFwifVwiO1xuICB9XG4gIGlmIChvYmoubWVkaWEpIHtcbiAgICBjc3MgKz0gXCJ9XCI7XG4gIH1cbiAgaWYgKG9iai5zdXBwb3J0cykge1xuICAgIGNzcyArPSBcIn1cIjtcbiAgfVxuICB2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcbiAgaWYgKHNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIuY29uY2F0KGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSksIFwiICovXCIpO1xuICB9XG5cbiAgLy8gRm9yIG9sZCBJRVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgICovXG4gIG9wdGlvbnMuc3R5bGVUYWdUcmFuc2Zvcm0oY3NzLCBzdHlsZUVsZW1lbnQsIG9wdGlvbnMub3B0aW9ucyk7XG59XG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KSB7XG4gIC8vIGlzdGFuYnVsIGlnbm9yZSBpZlxuICBpZiAoc3R5bGVFbGVtZW50LnBhcmVudE5vZGUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc3R5bGVFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50KTtcbn1cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBkb21BUEkob3B0aW9ucykge1xuICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKCkge30sXG4gICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHt9XG4gICAgfTtcbiAgfVxuICB2YXIgc3R5bGVFbGVtZW50ID0gb3B0aW9ucy5pbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG4gIHJldHVybiB7XG4gICAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUob2JqKSB7XG4gICAgICBhcHBseShzdHlsZUVsZW1lbnQsIG9wdGlvbnMsIG9iaik7XG4gICAgfSxcbiAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpO1xuICAgIH1cbiAgfTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZG9tQVBJOyIsIlwidXNlIHN0cmljdFwiO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cbmZ1bmN0aW9uIHN0eWxlVGFnVHJhbnNmb3JtKGNzcywgc3R5bGVFbGVtZW50KSB7XG4gIGlmIChzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKSB7XG4gICAgICBzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgICBzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gc3R5bGVUYWdUcmFuc2Zvcm07IiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBCbG9jazE7XG52YXIganN4X3J1bnRpbWVfMSA9IHJlcXVpcmUoXCJwcmVhY3QvanN4LXJ1bnRpbWVcIik7XG52YXIgcHJlYWN0X3JvdXRlcl8xID0gcmVxdWlyZShcInByZWFjdC1yb3V0ZXJcIik7XG52YXIgaW1hZ2VfaGVyb19qcGdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vYXNzZXRzL2Rlc2t0b3AvaW1hZ2UtaGVyby5qcGdcIikpO1xudmFyIGltYWdlX2hlcm9fanBnXzIgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uLy4uL2Fzc2V0cy90YWJsZXQvaW1hZ2UtaGVyby5qcGdcIikpO1xudmFyIGltYWdlX2hlcm9fanBnXzMgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uLy4uL2Fzc2V0cy9tb2JpbGUvaW1hZ2UtaGVyby5qcGdcIikpO1xudmFyIGl0ZW1zID0ge1xuICAgIHRpdGxlOiAnQnJhbmRpbmcgJiB3ZWJzaXRlIGRlc2lnbiBhZ2VuY3knLFxuICAgIGRlc2NyaXB0aW9uOiAnV2Ugc3BlY2lhbGl6ZSBpbiB2aXN1YWwgc3Rvcnl0ZWxsaW5nIGJ5IGNyZWF0aW5nIGNvaGVzaXZlIGJyYW5kIGFuZCB3ZWJzaXRlIGRlc2lnbiBzb2x1dGlvbnMgZm9yIHNtYWxsIGJ1c2luZXNzZXMsIGdpdmluZyBsYXN0aW5nIGltcHJlc3Npb25zIHRvIGF1ZGllbmNlcyBpbiBhIGRpZ2l0YWwgd29ybGQuJyxcbiAgICBidXR0b246ICdMZWFybiBNb3JlJyxcbn07XG52YXIgbGlua0l0ZW1zID0ge1xuICAgIHRpdGxlOiAnTGVhcm4gTW9yZScsXG4gICAgaHJlZjogJyMnLFxufTtcbmZ1bmN0aW9uIEJsb2NrMSgpIHtcbiAgICByZXR1cm4gKCgwLCBqc3hfcnVudGltZV8xLmpzeHMpKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJlbGF0aXZlIG1iLVs5NnB4XSBmbGV4IHctZnVsbCBtYXgtdy1bY2FsYygxMjc1cHgrMzlweCldIGZsZXgtY29sLXJldmVyc2UgaXRlbXMtY2VudGVyIGp1c3RpZnktYmV0d2VlbiBtZDptYi0wIG1kOmgtWzYwNnB4XSBtZDpmbGV4LXJvdyBtZDppdGVtcy1zdGFydCBtZDpzZWxmLWVuZCBtZDpwbC1bMzlweF0geGw6aC1bODAwcHhdXCIsIGNoaWxkcmVuOiBbKDAsIGpzeF9ydW50aW1lXzEuanN4cykoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwicmVsYXRpdmUgei1bMV0gbXQtWzU2cHhdIGZsZXggdy1maXQgbWF4LXctWzczMHB4XSBmbGV4LWNvbCBpdGVtcy1jZW50ZXIgZ2FwLVs0MHB4XSBweC1bMjRweF0gbWQ6bXQtWzc3cHhdIG1kOnctZnVsbCBtZDppdGVtcy1zdGFydCBtZDpnYXAtWzQ4cHhdIG1kOnB4LTAgeGw6bXQtWzExMnB4XVwiLCBjaGlsZHJlbjogWygwLCBqc3hfcnVudGltZV8xLmpzeHMpKFwic2VjdGlvblwiLCB7IGNsYXNzTmFtZTogXCJmbGV4IGZsZXgtY29sIGdhcC1bMjBweF0gbWQ6Z2FwLVszOXB4XVwiLCBjaGlsZHJlbjogWygwLCBqc3hfcnVudGltZV8xLmpzeCkoXCJoMVwiLCB7IGNsYXNzTmFtZTogXCJ3LWZ1bGwgbWQ6bWF4LXctWzM5OHB4XSB4bDptYXgtdy1bNjgwcHhdXCIsIGNoaWxkcmVuOiBpdGVtcy50aXRsZSB9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4KShcInBcIiwgeyBjbGFzc05hbWU6IFwidy1mdWxsIG1kOm1heC13LVszOThweF0geGw6bWF4LXctWzU0MHB4XVwiLCBjaGlsZHJlbjogaXRlbXMuZGVzY3JpcHRpb24gfSldIH0pLCAoMCwganN4X3J1bnRpbWVfMS5qc3gpKHByZWFjdF9yb3V0ZXJfMS5MaW5rLCB7IGNsYXNzTmFtZTogXCJmbGV4IGgtWzcycHhdIHctWzE3N3B4XSBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgc2VsZi1zdGFydCBiZy1bI0Y5NEY0Rl0gdGV4dC1bMThweF0gZm9udC1leHRyYWJvbGQgdGV4dC13aGl0ZSB0cmFuc2l0aW9uIGhvdmVyOmJnLVsjRkY5MzkzXVwiLCBocmVmOiBsaW5rSXRlbXMuaHJlZiwgY2hpbGRyZW46IGxpbmtJdGVtcy50aXRsZSB9KV0gfSksICgwLCBqc3hfcnVudGltZV8xLmpzeHMpKFwicGljdHVyZVwiLCB7IGNsYXNzTmFtZTogXCJyaWdodC0wIHctZnVsbCBtZDphYnNvbHV0ZSBtZDpoLVs2MDhweF0gbWQ6dy1maXQgeGw6aC1bODAwcHhdXCIsIGNoaWxkcmVuOiBbKDAsIGpzeF9ydW50aW1lXzEuanN4KShcInNvdXJjZVwiLCB7IG1lZGlhOiBcIihtYXgtd2lkdGg6IDc2OHB4KVwiLCBzcmNTZXQ6IGltYWdlX2hlcm9fanBnXzMuZGVmYXVsdCB9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4KShcInNvdXJjZVwiLCB7IG1lZGlhOiBcIihtYXgtd2lkdGg6IDEwMjRweClcIiwgc3JjU2V0OiBpbWFnZV9oZXJvX2pwZ18yLmRlZmF1bHQgfSksICgwLCBqc3hfcnVudGltZV8xLmpzeCkoXCJpbWdcIiwgeyBjbGFzc05hbWU6IFwibWQ6b2JqZWN0LWZpdCBzaXplLWZ1bGwgb2JqZWN0LWNvdmVyIG1kOmgtWzYwNnB4XSB4bDpoLVs4MDBweF1cIiwgc3JjOiBpbWFnZV9oZXJvX2pwZ18xLmRlZmF1bHQsIGFsdDogXCJtZW4gd29ya2luZyBvbiBjb21wdXRlcnNcIiB9KV0gfSldIH0pKTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gQmxvY2syO1xudmFyIGpzeF9ydW50aW1lXzEgPSByZXF1aXJlKFwicHJlYWN0L2pzeC1ydW50aW1lXCIpO1xudmFyIHByZWFjdF9yb3V0ZXJfMSA9IHJlcXVpcmUoXCJwcmVhY3Qtcm91dGVyXCIpO1xudmFyIGltYWdlX3N0cmF0ZWdpY19qcGdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vYXNzZXRzL2Rlc2t0b3AvaW1hZ2Utc3RyYXRlZ2ljLmpwZ1wiKSk7XG52YXIgaW1hZ2Vfc3RyYXRlZ2ljX2pwZ18yID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi8uLi9hc3NldHMvbW9iaWxlL2ltYWdlLXN0cmF0ZWdpYy5qcGdcIikpO1xudmFyIGJnX3BhdHRlcm5fd2F2ZV9yZWRfc3ZnXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uLy4uL2Fzc2V0cy9kZXNrdG9wL2JnLXBhdHRlcm4td2F2ZS1yZWQuc3ZnXCIpKTtcbnZhciBpdGVtcyA9IHtcbiAgICB0aXRsZTogJ0Rlc2lnbiBpcyBzdHJhdGVnaWMuJyxcbiAgICBkZXNjcmlwdGlvbjogJ+KAnEEgd2VsbC1jcmFmdGVkIGRlc2lnbiBzdHJhdGVneSBjb25zaXN0ZW50bHkgcHJvZHVjZXMgZGVzaXJlZCBvdXRjb21lcyBhbmQgYnJhbmQgYXdhcmVuZXNzLiBXZSBhcmUgZmlybSBiZWxpZXZlcnMgdGhhdCBzdWNjZXNzIGxpZXMgaW4gY3JlYXRpdmUgY29sbGFib3JhdGlvbiB3aXRoIG91ciBjbGllbnRzLuKAnScsXG4gICAgbGlua1RpdGxlOiAnU2NoZWR1bGUgYSBDYWxsJyxcbn07XG5mdW5jdGlvbiBCbG9jazIoKSB7XG4gICAgcmV0dXJuICgoMCwganN4X3J1bnRpbWVfMS5qc3hzKShcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJyZWxhdGl2ZSBmbGV4IHctZnVsbCBmbGV4LWNvbCBtZDpoLVs2NDhweF0gbWQ6ZmxleC1yb3cgIG1kOmp1c3RpZnktZW5kIGxnOmgtWzc1MHB4XSB4bDpoLVs5ODRweF1cIiwgY2hpbGRyZW46IFsoMCwganN4X3J1bnRpbWVfMS5qc3hzKShcInBpY3R1cmVcIiwgeyBjaGlsZHJlbjogWygwLCBqc3hfcnVudGltZV8xLmpzeCkoXCJzb3VyY2VcIiwgeyBtZWRpYTogXCIobWF4LXdpZHRoOiA3NjhweClcIiwgc3JjU2V0OiBpbWFnZV9zdHJhdGVnaWNfanBnXzIuZGVmYXVsdCB9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4KShcImltZ1wiLCB7IGNsYXNzTmFtZTogXCJsZWZ0LTAgb2JqZWN0LWNvdmVyIG1kOmFic29sdXRlIG1kOmgtWzY1OHB4XSBtZDp3LVs3MzVweF0gbWQ6b2JqZWN0LVsxMDAlXzAlXSB4bDpoLVs5ODRweF0geGw6b2JqZWN0LWNlbnRlclwiLCBoZWlnaHQ6IDk4NCwgd2lkdGg6IDczNSwgc3JjOiBpbWFnZV9zdHJhdGVnaWNfanBnXzEuZGVmYXVsdCwgYWx0OiBcInN0cmF0ZWdpY1wiIH0pXSB9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4KShcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJyZWxhdGl2ZSBmbGV4IGl0ZW1zLWNlbnRlciBiZy1bIzE5MTkyMV0gcHktWzcycHhdIG1kOmgtWzUzOHB4XSBtZDp3LVszOTBweF0gbWQ6cHktMCBtZDpwbC1bNjlweF0gbWQ6cHItWzQwcHhdIGxnOmgtWzU2MHB4XSBsZzp3LVs1MzBweF0gbGc6cGwtWzkwcHhdIGxnOnByLVs2MHB4XSB4bDpoLVs3ODRweF0geGw6dy1bNzA1cHhdIHhsOnBsLVsxNTRweF0geGw6cHItWzEwNnB4XVwiLCBjaGlsZHJlbjogKDAsIGpzeF9ydW50aW1lXzEuanN4cykoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmxleCBmbGV4LWNvbCBnYXAtWzQ4cHhdIHB4LVsyNHB4XSBtZDpweC0wXCIsIGNoaWxkcmVuOiBbKDAsIGpzeF9ydW50aW1lXzEuanN4KShcImltZ1wiLCB7IGNsYXNzTmFtZTogXCJhYnNvbHV0ZSB0b3AtWy0xNXB4XSBoLVsyOHB4XSB3LVs2MnB4XSBtZDpsZWZ0LVstMzFweF0gbWQ6dG9wLVsyMjBweF0geGw6bGVmdC1bLTY3cHhdIHhsOnRvcC1bMjM0cHhdIHhsOmgtWzYxcHhdIHhsOnctWzEzNXB4XVwiLCB3aWR0aDogMTM1LCBoZWlnaHQ6IDYxLCBzcmM6IGJnX3BhdHRlcm5fd2F2ZV9yZWRfc3ZnXzEuZGVmYXVsdCwgYWx0OiBcInBhdHRlcm5cIiB9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4cykoXCJzZWN0aW9uXCIsIHsgY2xhc3NOYW1lOiBcImZsZXggZmxleC1jb2wgZ2FwLVszMnB4XSBtZDptYXgtdy1bMjgxcHhdIGxnOm1heC13LWZ1bGwgeGw6Z2FwLVs0M3B4XVwiLCBjaGlsZHJlbjogWygwLCBqc3hfcnVudGltZV8xLmpzeHMpKFwiaDJcIiwgeyBjbGFzc05hbWU6IFwidGV4dC13aGl0ZSBtZDptYXgtdy1bMjUwcHhdIGxnOm1heC13LWZ1bGxcIiwgY2hpbGRyZW46IFsoMCwganN4X3J1bnRpbWVfMS5qc3gpKFwic3BhblwiLCB7IGNsYXNzTmFtZTogXCJ0ZXh0LVsjRjk0RjRGXVwiLCBjaGlsZHJlbjogaXRlbXMudGl0bGUuc3BsaXQoJyAnKVswXSB9KSwgXCIgXCIuY29uY2F0KGl0ZW1zLnRpdGxlLnNwbGl0KCcgJykuc2xpY2UoMSkuam9pbignICcpKV0gfSksICgwLCBqc3hfcnVudGltZV8xLmpzeCkoXCJwXCIsIHsgY2xhc3NOYW1lOiBcInRleHQtd2hpdGVcIiwgY2hpbGRyZW46IGl0ZW1zLmRlc2NyaXB0aW9uIH0pXSB9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4KShwcmVhY3Rfcm91dGVyXzEuTGluaywgeyBjbGFzc05hbWU6IFwiZm9udC1leHRyYWJvbGQgdGV4dC1bI0Y5NEY0Rl0gdW5kZXJsaW5lIHVuZGVybGluZS1vZmZzZXQtWzEycHhdIHRyYW5zaXRpb24gaG92ZXI6dGV4dC1bI0ZGOTM5M11cIiwgaHJlZjogXCIjXCIsIGNoaWxkcmVuOiBpdGVtcy5saW5rVGl0bGUgfSldIH0pIH0pXSB9KSk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IEJsb2NrMztcbnZhciBqc3hfcnVudGltZV8xID0gcmVxdWlyZShcInByZWFjdC9qc3gtcnVudGltZVwiKTtcbnZhciB0aXRsZSA9ICdPdXIgYXBwcm9hY2ggZm9yIGNyZWF0aW5nIGEgd2lubmluZyBicmFuZCc7XG52YXIgaXRlbXMgPSBbXG4gICAge1xuICAgICAgICB0aXRsZTogJ0JyYW5kIFN0cmF0ZWd5JyxcbiAgICAgICAgZGVzY3JpcHRpb246ICdCcmFuZCBzdHJhdGVneSBpcyBjcml0aWNhbCBmb3IgbG9uZy10ZXJtIHN1Y2Nlc3MuIE91dHNoaW5pbmcgY29tcGV0aXRvcnMgYW5kIGNhcHR1cmluZyB0aGUgdGFyZ2V0IGF1ZGllbmNlIGFyZSBrZXkuJyxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgdGl0bGU6ICdCcmFuZCBEZXNpZ24nLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ0tlZXBpbmcgdGhlIGJyYW5kIGRlc2lnbiB1bmlxdWUgYW5kIG1lYW5pbmdmdWwgaGVscHMgaW4gY29tbXVuaWNhdGluZyB0aGUgYnJhbmTigJlzIHRpbWVsZXNzIHZhbHVlIGVmZmVjdGl2ZWx5LicsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHRpdGxlOiAnV2ViIERlc2lnbicsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnQSBiZWF1dGlmdWxseSBjcmFmdGVkIHdlYnNpdGUgaXMgdGhlIGJlc3QgdG9vbCBmb3IgYnJhbmQgYXdhcmVuZXNzLCBhbmQgdWx0aW1hdGVseSByZXN1bHRzIGluIGluY3JlYXNlZCByZXZlbnVlcy4gJyxcbiAgICB9LFxuXTtcbmZ1bmN0aW9uIEJsb2NrMygpIHtcbiAgICByZXR1cm4gKCgwLCBqc3hfcnVudGltZV8xLmpzeHMpKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZsZXggdy1mdWxsIGp1c3RpZnktYmV0d2VlbiB4bDpqdXN0aWZ5LWVuZCB4bDpwbC1bMzlweF1cIiwgY2hpbGRyZW46IFsoMCwganN4X3J1bnRpbWVfMS5qc3gpKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJlbGF0aXZlIHotWzJdIGZsZXggIHctZnVsbCBqdXN0aWZ5LWNlbnRlciBweC1bMjRweF0gbGc6cHgtMCB4bDptci1bLTE2MHB4XSB4bDp3LWZpdFwiLCBjaGlsZHJlbjogKDAsIGpzeF9ydW50aW1lXzEuanN4KShcImgyXCIsIHsgY2xhc3NOYW1lOiBcInotWzJdIG10LVsxMjBweF0gaC1maXQgdy1mdWxsIG1heC13LVsyODFweF0gbGc6bXQtMCB4bDptdC1bMjAwcHhdIHhsOm1heC13LVs1NDBweF0geGw6cGwtMFwiLCBjaGlsZHJlbjogdGl0bGUgfSkgfSksICgwLCBqc3hfcnVudGltZV8xLmpzeCkoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiei1bMV0gZmxleCBoLVs3OTdweF0gdy1bMTQwMHB4XSBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgYmctWyNGOTRGNEZdIG1kOm10LVstMTIwcHhdIGxnOm10LVstMjAwcHhdIHhsOmgtWzExMDBweF0geGw6dy1bODk1cHhdIHhsOmp1c3RpZnktZW5kIHhsOnByLVsxMDZweF1cIiwgY2hpbGRyZW46ICgwLCBqc3hfcnVudGltZV8xLmpzeCkoXCJ1bFwiLCB7IGNsYXNzTmFtZTogXCJmbGV4IGZsZXgtY29sIGdhcC1bNDBweF0geGw6Z2FwLVs1NnB4XVwiLCBjaGlsZHJlbjogaXRlbXMubWFwKGZ1bmN0aW9uIChpdGVtLCBpbmRleCkgeyByZXR1cm4gKCgwLCBqc3hfcnVudGltZV8xLmpzeHMpKFwibGlcIiwgeyBjbGFzc05hbWU6IFwiZmxleCBoLVsyMDBweF0gdy1bMzU1cHhdIGZsZXgtY29sIGdhcC1bMjRweF0geGw6dy1bNTA0cHhdXCIsIGNoaWxkcmVuOiBbKDAsIGpzeF9ydW50aW1lXzEuanN4KShcInNwYW5cIiwgeyBjbGFzc05hbWU6IFwiYWJzb2x1dGUgdGV4dC1bODBweF0gZm9udC1leHRyYWJvbGQgbGVhZGluZy1bODhweF0gdGV4dC13aGl0ZS8yNVwiLCBjaGlsZHJlbjogKGluZGV4ICsgMSkudG9Mb2NhbGVTdHJpbmcoJ2VuLVVTJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluaW11bUludGVnZXJEaWdpdHM6IDIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VHcm91cGluZzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pIH0pLCAoMCwganN4X3J1bnRpbWVfMS5qc3hzKShcInNlY3Rpb25cIiwgeyBjbGFzc05hbWU6IFwibWwtWzU5cHhdIG10LVs0NHB4XSBmbGV4IGZsZXgtY29sIGdhcC1bMjRweF1cIiwgY2hpbGRyZW46IFsoMCwganN4X3J1bnRpbWVfMS5qc3gpKFwiaDNcIiwgeyBjbGFzc05hbWU6IFwidGV4dC13aGl0ZVwiLCBjaGlsZHJlbjogaXRlbS50aXRsZSB9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4KShcInBcIiwgeyBjbGFzc05hbWU6IFwidGV4dC13aGl0ZVwiLCBjaGlsZHJlbjogaXRlbS5kZXNjcmlwdGlvbiB9KV0gfSldIH0sIGl0ZW0pKTsgfSkgfSkgfSldIH0pKTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xudmFyIF9hO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gQmxvY2s0O1xudmFyIGpzeF9ydW50aW1lXzEgPSByZXF1aXJlKFwicHJlYWN0L2pzeC1ydW50aW1lXCIpO1xudmFyIGltYWdlX3NsaWRlXzFfanBnXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uLy4uL2Fzc2V0cy9kZXNrdG9wL2ltYWdlLXNsaWRlLTEuanBnXCIpKTtcbnZhciBpbWFnZV9zbGlkZV8yX2pwZ18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi8uLi9hc3NldHMvZGVza3RvcC9pbWFnZS1zbGlkZS0yLmpwZ1wiKSk7XG52YXIgaW1hZ2Vfc2xpZGVfM19qcGdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vYXNzZXRzL2Rlc2t0b3AvaW1hZ2Utc2xpZGUtMy5qcGdcIikpO1xudmFyIGJnX3BhdHRlcm5fd2F2eV93aGl0ZV9zdmdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vYXNzZXRzL2Rlc2t0b3AvYmctcGF0dGVybi13YXZ5LXdoaXRlLnN2Z1wiKSk7XG52YXIgaG9va3NfMSA9IHJlcXVpcmUoXCJwcmVhY3QvaG9va3NcIik7XG52YXIgcHJlYWN0X2ZsaWNraW5nXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIkBlZ2pzL3ByZWFjdC1mbGlja2luZ1wiKSk7XG5yZXF1aXJlKFwiQGVnanMvcHJlYWN0LWZsaWNraW5nL2Rpc3QvZmxpY2tpbmcuY3NzXCIpO1xudmFyIFRpdGxlS2V5O1xuKGZ1bmN0aW9uIChUaXRsZUtleSkge1xuICAgIFRpdGxlS2V5W1RpdGxlS2V5W1wiZ3VpZGVsaW5lc1wiXSA9IDBdID0gXCJndWlkZWxpbmVzXCI7XG4gICAgVGl0bGVLZXlbVGl0bGVLZXlbXCJtZXJjaGFuZGlzZVwiXSA9IDFdID0gXCJtZXJjaGFuZGlzZVwiO1xuICAgIFRpdGxlS2V5W1RpdGxlS2V5W1wiZGVzaWduXCJdID0gMl0gPSBcImRlc2lnblwiO1xufSkoVGl0bGVLZXkgfHwgKFRpdGxlS2V5ID0ge30pKTtcbnZhciB0aXRsZSA9IChfYSA9IHt9LFxuICAgIF9hW1RpdGxlS2V5Lmd1aWRlbGluZXNdID0ge1xuICAgICAgICBtYWluVGl0bGU6ICdCcmFuZCBuYW1pbmcgJiBndWlkZWxpbmVzJyxcbiAgICAgICAgdGl0bGU6ICdMZWFuIFByb2R1Y3QgUm9hZG1hcCcsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnMjAxOSBQcm9qZWN0JyxcbiAgICB9LFxuICAgIF9hW1RpdGxlS2V5Lm1lcmNoYW5kaXNlXSA9IHtcbiAgICAgICAgbWFpblRpdGxlOiAnQnJhbmQgaWRlbnRpdHkgJiBtZXJjaGFuZGlzZScsXG4gICAgICAgIHRpdGxlOiAnTmV3IE1hamVzdGljIEhvdGVsJyxcbiAgICAgICAgZGVzY3JpcHRpb246ICcyMDE4IFByb2plY3QnLFxuICAgIH0sXG4gICAgX2FbVGl0bGVLZXkuZGVzaWduXSA9IHtcbiAgICAgICAgbWFpblRpdGxlOiAnQnJhbmQgaWRlbnRpdHkgJiB3ZWIgZGVzaWduJyxcbiAgICAgICAgdGl0bGU6ICdDcnlwdG8gRGFzaGJvYXJkJyxcbiAgICAgICAgZGVzY3JpcHRpb246ICcyMDE2IFByb2plY3QnLFxuICAgIH0sXG4gICAgX2EpO1xudmFyIHRpdGxlc0J1dHRvbnMgPSB7XG4gICAgcHJldmlvdXM6ICdwcmV2aW91cyBzbGlkZScsXG4gICAgbmV4dDogJ25leHQgc2xpZGUnLFxufTtcbmZ1bmN0aW9uIEJsb2NrNCgpIHtcbiAgICB2YXIgZmxpY2tpbmcgPSAoMCwgaG9va3NfMS51c2VSZWYpKCk7XG4gICAgdmFyIG1haW5UaXRsZVJlZiA9ICgwLCBob29rc18xLnVzZVJlZikobnVsbCk7XG4gICAgdmFyIHNlY3Rpb25SZWYgPSAoMCwgaG9va3NfMS51c2VSZWYpKG51bGwpO1xuICAgIHZhciBfYSA9ICgwLCBob29rc18xLnVzZVN0YXRlKShUaXRsZUtleS5ndWlkZWxpbmVzKSwgY3VycmVudFNsaWRlID0gX2FbMF0sIHNldEN1cnJlbnRTbGlkZSA9IF9hWzFdO1xuICAgIHZhciBfYiA9ICgwLCBob29rc18xLnVzZVN0YXRlKShmYWxzZSksIGlzUGxheWluZyA9IF9iWzBdLCBzZXRJc1BsYXlpbmcgPSBfYlsxXTtcbiAgICByZXR1cm4gKCgwLCBqc3hfcnVudGltZV8xLmpzeHMpKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJlbGF0aXZlIGZsZXggbWluLWgtWzQ3MnB4XSB3LWZ1bGwganVzdGlmeS1zdGFydCB4bDptaW4taC1bNzI4cHhdXCIsIGNoaWxkcmVuOiBbKDAsIGpzeF9ydW50aW1lXzEuanN4cykoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwicmVsYXRpdmUgei1bMV0gZmxleCBoLVszNTJweF0gdy0xLzIgbWF4LXctWzczNXB4XSBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgYmctWyMxOTE5MjFdIHBsLVs0MHB4XSB4bDpoLVs1MjhweF1cIiwgY2hpbGRyZW46IFsoMCwganN4X3J1bnRpbWVfMS5qc3gpKFwiaW1nXCIsIHsgYWx0OiBcInBhdHRlcm5cIiwgY2xhc3NOYW1lOiBcImFic29sdXRlIHJpZ2h0LVstMzFweF0gdG9wLVsxMjZweF0gei1bMl0gaC1bMjhweF0gdy1bNjJweF0geGw6cmlnaHQtWy02N3B4XSB4bDp0b3AtWzE4NnB4XSB4bDpoLVs2MHB4XSB4bDp3LVsxMzRweF1cIiwgc3JjOiBiZ19wYXR0ZXJuX3dhdnlfd2hpdGVfc3ZnXzEuZGVmYXVsdCwgd2lkdGg6IDEzNCwgaGVpZ2h0OiA2MCB9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4cykoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmxleCBoLVsyMzNweF0gdy1bMzkwcHhdIGZsZXgtY29sIGp1c3RpZnktY2VudGVyIGdhcC1bNTFweF0geGw6dy1bNDQ1cHhdXCIsIGNoaWxkcmVuOiBbKDAsIGpzeF9ydW50aW1lXzEuanN4KShcImgyXCIsIHsgcmVmOiBtYWluVGl0bGVSZWYsIGNsYXNzTmFtZTogXCJhbmltYXRpb25FbGVtZW50IG1heC13LVsyODFweF0gdGV4dC13aGl0ZSB4bDptYXgtdy1mdWxsXCIsIGNoaWxkcmVuOiB0aXRsZVtjdXJyZW50U2xpZGVdLm1haW5UaXRsZSB9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4cykoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmxleCBnYXAtWzE2cHhdXCIsIGNoaWxkcmVuOiBbKDAsIGpzeF9ydW50aW1lXzEuanN4KShcImJ1dHRvblwiLCB7IGRpc2FibGVkOiBpc1BsYXlpbmcsIG9uQ2xpY2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2b2lkICgoX2EgPSBmbGlja2luZy5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucHJldigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCB0aXRsZTogXCJwcmV2aW91cyBzbGlkZVwiLCB0eXBlOiBcImJ1dHRvblwiLCBjbGFzc05hbWU6IFwicHJldmlvdXMgcmVsYXRpdmUgei00MCBzaXplLVs0MHB4XVwiLCBjaGlsZHJlbjogKDAsIGpzeF9ydW50aW1lXzEuanN4cykoXCJzdmdcIiwgeyB3aWR0aDogXCI0MFwiLCBoZWlnaHQ6IFwiNDBcIiwgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgY2hpbGRyZW46IFsoMCwganN4X3J1bnRpbWVfMS5qc3gpKFwidGl0bGVcIiwgeyBjaGlsZHJlbjogdGl0bGVzQnV0dG9ucy5wcmV2aW91cyB9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4cykoXCJnXCIsIHsgdHJhbnNmb3JtOiBcIm1hdHJpeCgtMSAwIDAgMSA0MCAwKVwiLCBmaWxsOiBcIm5vbmVcIiwgZmlsbFJ1bGU6IFwiZXZlbm9kZFwiLCBjaGlsZHJlbjogWygwLCBqc3hfcnVudGltZV8xLmpzeCkoXCJjaXJjbGVcIiwgeyBjeDogXCIyMFwiLCBjeTogXCIyMFwiLCByOiBcIjE5LjVcIiB9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4KShcInBhdGhcIiwgeyBzdHJva2VXaWR0aDogXCIyXCIsIGQ6IFwiTTE3LjUgMTVsNSA1LTUgNVwiIH0pXSB9KV0gfSkgfSksICgwLCBqc3hfcnVudGltZV8xLmpzeCkoXCJidXR0b25cIiwgeyBkaXNhYmxlZDogaXNQbGF5aW5nLCBvbkNsaWNrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdm9pZCAoKF9hID0gZmxpY2tpbmcuY3VycmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5leHQoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgdGl0bGU6IFwibmV4dCBzbGlkZVwiLCB0eXBlOiBcImJ1dHRvblwiLCBjbGFzc05hbWU6IFwicHJldmlvdXMgcmVsYXRpdmUgei00MCBzaXplLVs0MHB4XVwiLCBjaGlsZHJlbjogKDAsIGpzeF9ydW50aW1lXzEuanN4cykoXCJzdmdcIiwgeyB3aWR0aDogXCI0MFwiLCBoZWlnaHQ6IFwiNDBcIiwgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgY2hpbGRyZW46IFsoMCwganN4X3J1bnRpbWVfMS5qc3gpKFwidGl0bGVcIiwgeyBjaGlsZHJlbjogdGl0bGVzQnV0dG9ucy5uZXh0IH0pLCAoMCwganN4X3J1bnRpbWVfMS5qc3hzKShcImdcIiwgeyBmaWxsOiBcIm5vbmVcIiwgZmlsbFJ1bGU6IFwiZXZlbm9kZFwiLCBjaGlsZHJlbjogWygwLCBqc3hfcnVudGltZV8xLmpzeCkoXCJjaXJjbGVcIiwgeyBjeDogXCIyMFwiLCBjeTogXCIyMFwiLCByOiBcIjE5LjVcIiB9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4KShcInBhdGhcIiwgeyBzdHJva2VXaWR0aDogXCIyXCIsIGQ6IFwiTTE3LjUgMTVsNSA1LTUgNVwiIH0pXSB9KV0gfSkgfSldIH0pXSB9KV0gfSksICgwLCBqc3hfcnVudGltZV8xLmpzeHMpKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImFic29sdXRlIHJpZ2h0LTAgei0wIHctMy81IHhsOmgtWzcyOHB4XSB4bDp3LVs4OTVweF0gXCIsIGNoaWxkcmVuOiBbKDAsIGpzeF9ydW50aW1lXzEuanN4cykocHJlYWN0X2ZsaWNraW5nXzEuZGVmYXVsdCwgeyBvbk1vdmVTdGFydDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0SXNQbGF5aW5nKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChfYSA9IG1haW5UaXRsZVJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2xhc3NMaXN0LmFkZCgnYW5pbWF0ZVRyYW5zaXRpb24nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoX2IgPSBzZWN0aW9uUmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jbGFzc0xpc3QuYWRkKCdhbmltYXRlVHJhbnNpdGlvbicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgb25Nb3ZlRW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRJc1BsYXlpbmcoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChfYSA9IG1haW5UaXRsZVJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2xhc3NMaXN0LnJlbW92ZSgnYW5pbWF0ZVRyYW5zaXRpb24nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoX2IgPSBzZWN0aW9uUmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jbGFzc0xpc3QucmVtb3ZlKCdhbmltYXRlVHJhbnNpdGlvbicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgcmVmOiBmbGlja2luZywgY2lyY3VsYXI6IHRydWUsIG9uQ2hhbmdlZDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRDdXJyZW50U2xpZGUoZS5pbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBjaGlsZHJlbjogWygwLCBqc3hfcnVudGltZV8xLmpzeCkoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwicGFuZWwgaW1hZ2UtY29udGFpbmVyXCIsIGNoaWxkcmVuOiAoMCwganN4X3J1bnRpbWVfMS5qc3gpKFwiaW1nXCIsIHsgY2xhc3NOYW1lOiBcImNhcm91c2VsSW1hZ2VcIiwgc3JjOiBpbWFnZV9zbGlkZV8xX2pwZ18xLmRlZmF1bHQsIGFsdDogXCJTbGlkZSAxXCIgfSkgfSwgVGl0bGVLZXkuZ3VpZGVsaW5lcyksICgwLCBqc3hfcnVudGltZV8xLmpzeCkoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwicGFuZWwgaW1hZ2UtY29udGFpbmVyXCIsIGNoaWxkcmVuOiAoMCwganN4X3J1bnRpbWVfMS5qc3gpKFwiaW1nXCIsIHsgY2xhc3NOYW1lOiBcImNhcm91c2VsSW1hZ2VcIiwgc3JjOiBpbWFnZV9zbGlkZV8yX2pwZ18xLmRlZmF1bHQsIGFsdDogXCJTbGlkZSAyXCIgfSkgfSwgVGl0bGVLZXkubWVyY2hhbmRpc2UpLCAoMCwganN4X3J1bnRpbWVfMS5qc3gpKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInBhbmVsIGltYWdlLWNvbnRhaW5lclwiLCBjaGlsZHJlbjogKDAsIGpzeF9ydW50aW1lXzEuanN4KShcImltZ1wiLCB7IGNsYXNzTmFtZTogXCJjYXJvdXNlbEltYWdlXCIsIHNyYzogaW1hZ2Vfc2xpZGVfM19qcGdfMS5kZWZhdWx0LCBhbHQ6IFwiU2xpZGUgM1wiIH0pIH0sIFRpdGxlS2V5LmRlc2lnbildIH0pLCAoMCwganN4X3J1bnRpbWVfMS5qc3gpKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImFic29sdXRlIGJvdHRvbS1bNjhweF0gcmlnaHQtWzE1NHB4XSB6LVsxXVwiLCBjaGlsZHJlbjogKDAsIGpzeF9ydW50aW1lXzEuanN4cykoXCJzZWN0aW9uXCIsIHsgcmVmOiBzZWN0aW9uUmVmLCBjbGFzc05hbWU6IFwiYW5pbWF0aW9uRWxlbWVudCBmbGV4IGZsZXgtY29sIHRleHQtZW5kXCIsIGNoaWxkcmVuOiBbKDAsIGpzeF9ydW50aW1lXzEuanN4KShcImgzXCIsIHsgY2xhc3NOYW1lOiBcInRleHQtd2hpdGVcIiwgY2hpbGRyZW46IHRpdGxlW2N1cnJlbnRTbGlkZV0udGl0bGUgfSksICgwLCBqc3hfcnVudGltZV8xLmpzeCkoXCJwXCIsIHsgY2xhc3NOYW1lOiBcInRleHQtd2hpdGVcIiwgY2hpbGRyZW46IHRpdGxlW2N1cnJlbnRTbGlkZV0uZGVzY3JpcHRpb24gfSldIH0pIH0pXSB9KV0gfSkpO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBGb290ZXI7XG52YXIganN4X3J1bnRpbWVfMSA9IHJlcXVpcmUoXCJwcmVhY3QvanN4LXJ1bnRpbWVcIik7XG52YXIgYmdfcGF0dGVybl93YXZlX3JlZF9zdmdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vYXNzZXRzL2Rlc2t0b3AvYmctcGF0dGVybi13YXZlLXJlZC5zdmdcIikpO1xudmFyIGl0ZW1zID0ge1xuICAgIHRpdGxlOiAnTGV04oCZcyBidWlsZCBzb21ldGhpbmcgZ3JlYXQgdG9nZXRoZXIuJyxcbiAgICBidXR0b25EZXNjcmlwdGlvbjogJ1NjaGVkdWxlIGEgQ2FsbCcsXG59O1xuZnVuY3Rpb24gRm9vdGVyKCkge1xuICAgIHJldHVybiAoKDAsIGpzeF9ydW50aW1lXzEuanN4cykoXCJmb290ZXJcIiwgeyBjbGFzc05hbWU6IFwibXgtYXV0byBtYi1bMTAxcHhdIG10LVs3MHB4XSBmbGV4IHctZnVsbCBtYXgtdy1bMTM0MnB4XSBpdGVtcy1jZW50ZXIgcHgtWzQwcHhdIHhsOm1iLVsxMTVweF0geGw6bWwtWy02N3B4XSB4bDptdC1bMTIwcHhdIHhsOnB4LTBcIiwgY2hpbGRyZW46IFsoMCwganN4X3J1bnRpbWVfMS5qc3gpKFwiaW1nXCIsIHsgY2xhc3NOYW1lOiBcImhpZGRlbiB4bDpibG9ja1wiLCBhbHQ6IFwicGF0dGVyblwiLCBzcmM6IGJnX3BhdHRlcm5fd2F2ZV9yZWRfc3ZnXzEuZGVmYXVsdCwgd2lkdGg6IDEzNCwgaGVpZ2h0OiA2MCB9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4cykoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmxleCB3LWZ1bGwgaXRlbXMtY2VudGVyIGp1c3RpZnktYmV0d2VlbiB4bDptbC1bOThweF1cIiwgY2hpbGRyZW46IFsoMCwganN4X3J1bnRpbWVfMS5qc3gpKFwiaDJcIiwgeyBjbGFzc05hbWU6IFwibWF4LXctWzM5OHB4XSB4bDptYXgtdy1bNjM1cHhdXCIsIGNoaWxkcmVuOiBpdGVtcy50aXRsZSB9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4KShcImJ1dHRvblwiLCB7IHR5cGU6IFwiYnV0dG9uXCIsIGNsYXNzTmFtZTogXCJoLVs2NHB4XSB3LVsxOTlweF0gYmctWyNGOTRGNEZdIHRleHQtWzE2cHhdIGZvbnQtZXh0cmFib2xkIHRleHQtd2hpdGUgdHJhbnNpdGlvbiBob3ZlcjpiZy1bI0ZGOTM5M11cIiwgY2hpbGRyZW46IGl0ZW1zLmJ1dHRvbkRlc2NyaXB0aW9uIH0pXSB9KV0gfSkpO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBOYXZiYXI7XG52YXIganN4X3J1bnRpbWVfMSA9IHJlcXVpcmUoXCJwcmVhY3QvanN4LXJ1bnRpbWVcIik7XG52YXIgaG9va3NfMSA9IHJlcXVpcmUoXCJwcmVhY3QvaG9va3NcIik7XG52YXIgbG9nb19zdmdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vYXNzZXRzL2Rlc2t0b3AvbG9nby5zdmdcIikpO1xudmFyIHByZWFjdF9yb3V0ZXJfMSA9IHJlcXVpcmUoXCJwcmVhY3Qtcm91dGVyXCIpO1xudmFyIGl0ZW1zID0gW1xuICAgIHtcbiAgICAgICAgdGl0bGU6ICdBYm91dCcsXG4gICAgICAgIGhyZWY6ICcjJyxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgdGl0bGU6ICdTZXJ2aWNlJyxcbiAgICAgICAgaHJlZjogJyMnLFxuICAgIH0sXG4gICAge1xuICAgICAgICB0aXRsZTogJ1Byb2plY3RzJyxcbiAgICAgICAgaHJlZjogJyMnLFxuICAgIH0sXG5dO1xudmFyIGJ1dHRvblRpdGxlID0gJ1NjaGVkdWxlIGEgQ2FsbCc7XG5mdW5jdGlvbiBOYXZiYXIoKSB7XG4gICAgdmFyIG1lbnVCdXR0b25SZWYgPSAoMCwgaG9va3NfMS51c2VSZWYpKG51bGwpO1xuICAgIGZ1bmN0aW9uIGhhbmRsZU9wZW4oKSB7XG4gICAgICAgIGlmIChtZW51QnV0dG9uUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIG1lbnVCdXR0b25SZWYuY3VycmVudC5jbGFzc0xpc3QudG9nZ2xlKCdvcGVuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICgoMCwganN4X3J1bnRpbWVfMS5qc3hzKShcIm5hdlwiLCB7IGNsYXNzTmFtZTogXCJyZWxhdGl2ZSB6LVsyXSBmbGV4IGgtWzExMHB4XSB3LWZ1bGwgbWF4LXctW2NhbGMoMTI3NXB4KzM5cHgpXSBpdGVtcy1jZW50ZXIganVzdGlmeS1iZXR3ZWVuIHNlbGYtZW5kIG92ZXJmbG93LXgtY2xpcCBwbC1bMzlweF0gbWQ6aC1bMTc4cHhdXCIsIGNoaWxkcmVuOiBbKDAsIGpzeF9ydW50aW1lXzEuanN4KShcImRpdlwiLCB7IGlkOiBcIm1hc2tcIiwgY2xhc3NOYW1lOiBcImZpeGVkIGxlZnQtMCB0b3AtMCB6LVsxXSBmbGV4IHNpemUtZnVsbFwiIH0pLCAoMCwganN4X3J1bnRpbWVfMS5qc3hzKShcImRpdlwiLCB7IGlkOiBcIm1vYmlsZU1lbnVcIiwgY2xhc3NOYW1lOiBcImFic29sdXRlIHJpZ2h0LVsyNnB4XSB0b3AtWzExMHB4XSB6LTQwIGZsZXggaC1bMjkycHhdIHctZnVsbCBtYXgtdy1bMjUycHhdIGZsZXgtY29sIGl0ZW1zLWNlbnRlciBnYXAtWzI0cHhdIGJnLWJsYWNrIHB0LVszMnB4XVwiLCBjaGlsZHJlbjogWygwLCBqc3hfcnVudGltZV8xLmpzeCkoXCJ1bFwiLCB7IGNsYXNzTmFtZTogXCIgcmVsYXRpdmUgei00MCBmbGV4IGZsZXgtY29sIGl0ZW1zLWNlbnRlciBnYXAtWzI0cHhdXCIsIGNoaWxkcmVuOiBpdGVtcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuICgoMCwganN4X3J1bnRpbWVfMS5qc3gpKFwibGlcIiwgeyBjbGFzc05hbWU6IFwicmVsYXRpdmUgei00MFwiLCBjaGlsZHJlbjogKDAsIGpzeF9ydW50aW1lXzEuanN4KShwcmVhY3Rfcm91dGVyXzEuTGluaywgeyBjbGFzc05hbWU6IFwiIHJlbGF0aXZlIHotNDAgdGV4dC1bMThweF0gbGVhZGluZy1bMzJweF0gdGV4dC13aGl0ZSB0cmFuc2l0aW9uLWFsbFwiLCBocmVmOiBpdGVtLmhyZWYsIGNoaWxkcmVuOiBpdGVtLnRpdGxlIH0pIH0sIGl0ZW0udGl0bGUpKTsgfSkgfSksICgwLCBqc3hfcnVudGltZV8xLmpzeCkoXCJidXR0b25cIiwgeyB0eXBlOiBcImJ1dHRvblwiLCBjbGFzc05hbWU6IFwicmVsYXRpdmUgei00MCBoLVs2NHB4XSB3LVsxOTlweF0gYmctWyNGOTRGNEZdIHRleHQtWzE2cHhdIGZvbnQtZXh0cmFib2xkIHRleHQtd2hpdGVcIiwgY2hpbGRyZW46IGJ1dHRvblRpdGxlIH0pXSB9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4KShcImltZ1wiLCB7IGNsYXNzTmFtZTogXCJyZWxhdGl2ZSAtei0wIGZsZXhcIiwgc3JjOiBsb2dvX3N2Z18xLmRlZmF1bHQsIGFsdDogXCJsb2dvXCIgfSksICgwLCBqc3hfcnVudGltZV8xLmpzeHMpKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImhpZGRlbiBzaXplLWZ1bGwgbWF4LXctWzQzOHB4XSBpdGVtcy1jZW50ZXIgZ2FwLVsyOHB4XSBiZy1bI0Y5NEY0Rl0gcGwtWzMzcHhdIHByLVs0MHB4XSBtZDpmbGV4IGxnOm1heC13LVs1MzBweF0gbGc6Z2FwLVs1MHB4XSBsZzpwci1bMjBweF0geGw6bWF4LXctWzQ3dnddIHhsOmdhcC1bNDhweF0geGw6cGwtWzY5cHhdIHhsOnByLTAgc2NyZWVuMTUwMDptYXgtdy1bNzA1cHhdXCIsIGNoaWxkcmVuOiBbKDAsIGpzeF9ydW50aW1lXzEuanN4KShcInVsXCIsIHsgY2xhc3NOYW1lOiBcImZsZXggdy1mdWxsIG1heC13LVsxOTBweF0ganVzdGlmeS1iZXR3ZWVuIHhsOm1heC13LVsyMjVweF1cIiwgY2hpbGRyZW46IGl0ZW1zLm1hcChmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gKCgwLCBqc3hfcnVudGltZV8xLmpzeCkoXCJsaVwiLCB7IGNoaWxkcmVuOiAoMCwganN4X3J1bnRpbWVfMS5qc3gpKHByZWFjdF9yb3V0ZXJfMS5MaW5rLCB7IGNsYXNzTmFtZTogXCIgbGVhZGluZy1bMzJweF0gdGV4dC13aGl0ZSB0cmFuc2l0aW9uLWFsbCBob3Zlcjpmb250LWJvbGRcIiwgaHJlZjogaXRlbS5ocmVmLCBjaGlsZHJlbjogaXRlbS50aXRsZSB9KSB9LCBpdGVtLnRpdGxlKSk7IH0pIH0pLCAoMCwganN4X3J1bnRpbWVfMS5qc3gpKFwiYnV0dG9uXCIsIHsgdHlwZTogXCJidXR0b25cIiwgY2xhc3NOYW1lOiBcImgtWzY0cHhdIG1pbi13LVsxNDdweF0gYmctWyMxOTE5MjFdIHRleHQtWzE2cHhdIGZvbnQtZXh0cmFib2xkIHRleHQtd2hpdGUgdHJhbnNpdGlvbiBob3ZlcjpiZy1bIzQzNDM1Nl0geGw6bWluLXctWzE5OXB4XVwiLCBjaGlsZHJlbjogYnV0dG9uVGl0bGUgfSldIH0pLCAoMCwganN4X3J1bnRpbWVfMS5qc3gpKFwiYnV0dG9uXCIsIHsgcmVmOiBtZW51QnV0dG9uUmVmLCBvbkNsaWNrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZU9wZW4oKTtcbiAgICAgICAgICAgICAgICB9LCBpZDogXCJtb2JpbGVOYXZcIiwgdGl0bGU6IFwibW9iaWxlIG5hdmlnYXRpb25cIiwgdHlwZTogXCJidXR0b25cIiwgY2xhc3NOYW1lOiBcImFic29sdXRlIHJpZ2h0LVsyNHB4XSB6LVsyXSBtZDpvcGFjaXR5LTBcIiB9KV0gfSkpO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIganN4X3J1bnRpbWVfMSA9IHJlcXVpcmUoXCJwcmVhY3QvanN4LXJ1bnRpbWVcIik7XG52YXIgcHJlYWN0XzEgPSByZXF1aXJlKFwicHJlYWN0XCIpO1xuLy8gaW1wb3J0IERhdGFDb250ZXh0IGZyb20gJy4vX2xpYi9EYXRhQ29udGV4dCc7IC8vIHBsYWNlaG9sZGVyXG52YXIgTmF2YmFyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vY29tcG9uZW50cy9OYXZiYXJcIikpO1xudmFyIHBhZ2VfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9wYWdlXCIpKTtcbnZhciBGb290ZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9jb21wb25lbnRzL0Zvb3RlclwiKSk7XG5yZXF1aXJlKFwiLi9nbG9iYWxzLmNzc1wiKTtcbmRvY3VtZW50LmJvZHkuY2xhc3NOYW1lID1cbiAgICAnbWluLWgtZHZoIG14LWF1dG8gbWQ6bWluLWgtc2NyZWVuIG1heC13LVsxNDQwcHhdIGZsZXggZmxleC1jb2wgaXRlbXMtY2VudGVyIGZvbnQtY29tbWlzc2lvbmVyIGp1c3RpZnktc3BhY2UtYmV0d2Vlbic7XG5mdW5jdGlvbiBBcHAoKSB7XG4gICAgcmV0dXJuICgoMCwganN4X3J1bnRpbWVfMS5qc3hzKShqc3hfcnVudGltZV8xLkZyYWdtZW50LCB7IGNoaWxkcmVuOiBbKDAsIGpzeF9ydW50aW1lXzEuanN4KShOYXZiYXJfMS5kZWZhdWx0LCB7fSksICgwLCBqc3hfcnVudGltZV8xLmpzeCkoXCJtYWluXCIsIHsgY2xhc3NOYW1lOiBcIm14LWF1dG8gbWItYXV0byBmbGV4IHctZnVsbCBmbGV4LWNvbCBpdGVtcy1jZW50ZXIgb3ZlcmZsb3cteC1jbGlwXCIsIGNoaWxkcmVuOiAoMCwganN4X3J1bnRpbWVfMS5qc3gpKHBhZ2VfMS5kZWZhdWx0LCB7fSkgfSksICgwLCBqc3hfcnVudGltZV8xLmpzeCkoRm9vdGVyXzEuZGVmYXVsdCwge30pXSB9KSk7XG59XG5mdW5jdGlvbiBCb2R5KCkge1xuICAgIHJldHVybiAoMCwganN4X3J1bnRpbWVfMS5qc3gpKEFwcCwge30pO1xufVxuKDAsIHByZWFjdF8xLnJlbmRlcikoKDAsIGpzeF9ydW50aW1lXzEuanN4KShCb2R5LCB7fSksIGRvY3VtZW50LmJvZHkpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIganN4X3J1bnRpbWVfMSA9IHJlcXVpcmUoXCJwcmVhY3QvanN4LXJ1bnRpbWVcIik7XG52YXIgQmxvY2sxXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vY29tcG9uZW50cy9CbG9jazFcIikpO1xudmFyIEJsb2NrMl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2NvbXBvbmVudHMvQmxvY2syXCIpKTtcbnZhciBCbG9jazNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9jb21wb25lbnRzL0Jsb2NrM1wiKSk7XG52YXIgQmxvY2s0XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vY29tcG9uZW50cy9CbG9jazRcIikpO1xudmFyIEhvbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICgoMCwganN4X3J1bnRpbWVfMS5qc3hzKShqc3hfcnVudGltZV8xLkZyYWdtZW50LCB7IGNoaWxkcmVuOiBbKDAsIGpzeF9ydW50aW1lXzEuanN4KShCbG9jazFfMS5kZWZhdWx0LCB7fSksICgwLCBqc3hfcnVudGltZV8xLmpzeCkoQmxvY2syXzEuZGVmYXVsdCwge30pLCAoMCwganN4X3J1bnRpbWVfMS5qc3gpKEJsb2NrM18xLmRlZmF1bHQsIHt9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4KShCbG9jazRfMS5kZWZhdWx0LCB7fSldIH0pKTtcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBIb21lO1xuIiwiaW1wb3J0e2NyZWF0ZUNvbnRleHQgYXMgbixDb21wb25lbnQgYXMgdCx0b0NoaWxkQXJyYXkgYXMgcixjbG9uZUVsZW1lbnQgYXMgaSxoIGFzIG99ZnJvbVwicHJlYWN0XCI7aW1wb3J0e3VzZUNvbnRleHQgYXMgZSx1c2VTdGF0ZSBhcyB1LHVzZUVmZmVjdCBhcyBmfWZyb21cInByZWFjdC9ob29rc1wiO3ZhciBhPXt9O2Z1bmN0aW9uIGMobix0KXtmb3IodmFyIHIgaW4gdCluW3JdPXRbcl07cmV0dXJuIG59ZnVuY3Rpb24gcyhuLHQscil7dmFyIGksbz0vKD86XFw/KFteI10qKSk/KCMuKik/JC8sZT1uLm1hdGNoKG8pLHU9e307aWYoZSYmZVsxXSlmb3IodmFyIGY9ZVsxXS5zcGxpdChcIiZcIiksYz0wO2M8Zi5sZW5ndGg7YysrKXt2YXIgcz1mW2NdLnNwbGl0KFwiPVwiKTt1W2RlY29kZVVSSUNvbXBvbmVudChzWzBdKV09ZGVjb2RlVVJJQ29tcG9uZW50KHMuc2xpY2UoMSkuam9pbihcIj1cIikpfW49ZChuLnJlcGxhY2UobyxcIlwiKSksdD1kKHR8fFwiXCIpO2Zvcih2YXIgaD1NYXRoLm1heChuLmxlbmd0aCx0Lmxlbmd0aCksdj0wO3Y8aDt2KyspaWYodFt2XSYmXCI6XCI9PT10W3ZdLmNoYXJBdCgwKSl7dmFyIGw9dFt2XS5yZXBsYWNlKC8oXjp8WysqP10rJCkvZyxcIlwiKSxwPSh0W3ZdLm1hdGNoKC9bKyo/XSskLyl8fGEpWzBdfHxcIlwiLG09fnAuaW5kZXhPZihcIitcIikseT1+cC5pbmRleE9mKFwiKlwiKSxVPW5bdl18fFwiXCI7aWYoIVUmJiF5JiYocC5pbmRleE9mKFwiP1wiKTwwfHxtKSl7aT0hMTticmVha31pZih1W2xdPWRlY29kZVVSSUNvbXBvbmVudChVKSxtfHx5KXt1W2xdPW4uc2xpY2UodikubWFwKGRlY29kZVVSSUNvbXBvbmVudCkuam9pbihcIi9cIik7YnJlYWt9fWVsc2UgaWYodFt2XSE9PW5bdl0pe2k9ITE7YnJlYWt9cmV0dXJuKCEwPT09ci5kZWZhdWx0fHwhMSE9PWkpJiZ1fWZ1bmN0aW9uIGgobix0KXtyZXR1cm4gbi5yYW5rPHQucmFuaz8xOm4ucmFuaz50LnJhbms/LTE6bi5pbmRleC10LmluZGV4fWZ1bmN0aW9uIHYobix0KXtyZXR1cm4gbi5pbmRleD10LG4ucmFuaz1mdW5jdGlvbihuKXtyZXR1cm4gbi5wcm9wcy5kZWZhdWx0PzA6ZChuLnByb3BzLnBhdGgpLm1hcChsKS5qb2luKFwiXCIpfShuKSxuLnByb3BzfWZ1bmN0aW9uIGQobil7cmV0dXJuIG4ucmVwbGFjZSgvKF5cXC8rfFxcLyskKS9nLFwiXCIpLnNwbGl0KFwiL1wiKX1mdW5jdGlvbiBsKG4pe3JldHVyblwiOlwiPT1uLmNoYXJBdCgwKT8xK1wiKis/XCIuaW5kZXhPZihuLmNoYXJBdChuLmxlbmd0aC0xKSl8fDQ6NX12YXIgcD17fSxtPVtdLHk9W10sVT1udWxsLGc9e3VybDpSKCl9LGs9bihnKTtmdW5jdGlvbiBDKCl7dmFyIG49ZShrKTtpZihuPT09Zyl7dmFyIHQ9dSgpWzFdO2YoZnVuY3Rpb24oKXtyZXR1cm4geS5wdXNoKHQpLGZ1bmN0aW9uKCl7cmV0dXJuIHkuc3BsaWNlKHkuaW5kZXhPZih0KSwxKX19LFtdKX1yZXR1cm5bbiwkXX1mdW5jdGlvbiBSKCl7dmFyIG47cmV0dXJuXCJcIisoKG49VSYmVS5sb2NhdGlvbj9VLmxvY2F0aW9uOlUmJlUuZ2V0Q3VycmVudExvY2F0aW9uP1UuZ2V0Q3VycmVudExvY2F0aW9uKCk6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGxvY2F0aW9uP2xvY2F0aW9uOnApLnBhdGhuYW1lfHxcIlwiKSsobi5zZWFyY2h8fFwiXCIpfWZ1bmN0aW9uICQobix0KXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9ITEpLFwic3RyaW5nXCIhPXR5cGVvZiBuJiZuLnVybCYmKHQ9bi5yZXBsYWNlLG49bi51cmwpLGZ1bmN0aW9uKG4pe2Zvcih2YXIgdD1tLmxlbmd0aDt0LS07KWlmKG1bdF0uY2FuUm91dGUobikpcmV0dXJuITA7cmV0dXJuITF9KG4pJiZmdW5jdGlvbihuLHQpe3ZvaWQgMD09PXQmJih0PVwicHVzaFwiKSxVJiZVW3RdP1VbdF0obik6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGhpc3RvcnkmJmhpc3RvcnlbdCtcIlN0YXRlXCJdJiZoaXN0b3J5W3QrXCJTdGF0ZVwiXShudWxsLG51bGwsbil9KG4sdD9cInJlcGxhY2VcIjpcInB1c2hcIiksSShuKX1mdW5jdGlvbiBJKG4pe2Zvcih2YXIgdD0hMSxyPTA7cjxtLmxlbmd0aDtyKyspbVtyXS5yb3V0ZVRvKG4pJiYodD0hMCk7cmV0dXJuIHR9ZnVuY3Rpb24gTShuKXtpZihuJiZuLmdldEF0dHJpYnV0ZSl7dmFyIHQ9bi5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpLHI9bi5nZXRBdHRyaWJ1dGUoXCJ0YXJnZXRcIik7aWYodCYmdC5tYXRjaCgvXlxcLy9nKSYmKCFyfHxyLm1hdGNoKC9eXz9zZWxmJC9pKSkpcmV0dXJuICQodCl9fWZ1bmN0aW9uIGIobil7cmV0dXJuIG4uc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uJiZuLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpLG4uc3RvcFByb3BhZ2F0aW9uJiZuLnN0b3BQcm9wYWdhdGlvbigpLG4ucHJldmVudERlZmF1bHQoKSwhMX1mdW5jdGlvbiBXKG4pe2lmKCEobi5jdHJsS2V5fHxuLm1ldGFLZXl8fG4uYWx0S2V5fHxuLnNoaWZ0S2V5fHxuLmJ1dHRvbikpe3ZhciB0PW4udGFyZ2V0O2Rve2lmKFwiYVwiPT09dC5sb2NhbE5hbWUmJnQuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSl7aWYodC5oYXNBdHRyaWJ1dGUoXCJkYXRhLW5hdGl2ZVwiKXx8dC5oYXNBdHRyaWJ1dGUoXCJuYXRpdmVcIikpcmV0dXJuO2lmKE0odCkpcmV0dXJuIGIobil9fXdoaWxlKHQ9dC5wYXJlbnROb2RlKX19dmFyIHc9ITE7ZnVuY3Rpb24gRChuKXtuLmhpc3RvcnkmJihVPW4uaGlzdG9yeSksdGhpcy5zdGF0ZT17dXJsOm4udXJsfHxSKCl9fWMoRC5wcm90b3R5cGU9bmV3IHQse3Nob3VsZENvbXBvbmVudFVwZGF0ZTpmdW5jdGlvbihuKXtyZXR1cm4hMCE9PW4uc3RhdGljfHxuLnVybCE9PXRoaXMucHJvcHMudXJsfHxuLm9uQ2hhbmdlIT09dGhpcy5wcm9wcy5vbkNoYW5nZX0sY2FuUm91dGU6ZnVuY3Rpb24obil7dmFyIHQ9cih0aGlzLnByb3BzLmNoaWxkcmVuKTtyZXR1cm4gdm9pZCAwIT09dGhpcy5nKHQsbil9LHJvdXRlVG86ZnVuY3Rpb24obil7dGhpcy5zZXRTdGF0ZSh7dXJsOm59KTt2YXIgdD10aGlzLmNhblJvdXRlKG4pO3JldHVybiB0aGlzLnB8fHRoaXMuZm9yY2VVcGRhdGUoKSx0fSxjb21wb25lbnRXaWxsTW91bnQ6ZnVuY3Rpb24oKXt0aGlzLnA9ITB9LGNvbXBvbmVudERpZE1vdW50OmZ1bmN0aW9uKCl7dmFyIG49dGhpczt3fHwodz0hMCxVfHxhZGRFdmVudExpc3RlbmVyKFwicG9wc3RhdGVcIixmdW5jdGlvbigpe0koUigpKX0pLGFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLFcpKSxtLnB1c2godGhpcyksVSYmKHRoaXMudT1VLmxpc3RlbihmdW5jdGlvbih0KXt2YXIgcj10LmxvY2F0aW9ufHx0O24ucm91dGVUbyhcIlwiKyhyLnBhdGhuYW1lfHxcIlwiKSsoci5zZWFyY2h8fFwiXCIpKX0pKSx0aGlzLnA9ITF9LGNvbXBvbmVudFdpbGxVbm1vdW50OmZ1bmN0aW9uKCl7XCJmdW5jdGlvblwiPT10eXBlb2YgdGhpcy51JiZ0aGlzLnUoKSxtLnNwbGljZShtLmluZGV4T2YodGhpcyksMSl9LGNvbXBvbmVudFdpbGxVcGRhdGU6ZnVuY3Rpb24oKXt0aGlzLnA9ITB9LGNvbXBvbmVudERpZFVwZGF0ZTpmdW5jdGlvbigpe3RoaXMucD0hMX0sZzpmdW5jdGlvbihuLHQpe249bi5maWx0ZXIodikuc29ydChoKTtmb3IodmFyIHI9MDtyPG4ubGVuZ3RoO3IrKyl7dmFyIGk9bltyXSxvPXModCxpLnByb3BzLnBhdGgsaS5wcm9wcyk7aWYobylyZXR1cm5baSxvXX19LHJlbmRlcjpmdW5jdGlvbihuLHQpe3ZhciBlLHUsZj1uLm9uQ2hhbmdlLGE9dC51cmwscz10aGlzLmMsaD10aGlzLmcocihuLmNoaWxkcmVuKSxhKTtpZihoJiYodT1pKGhbMF0sYyhjKHt1cmw6YSxtYXRjaGVzOmU9aFsxXX0sZSkse2tleTp2b2lkIDAscmVmOnZvaWQgMH0pKSksYSE9PShzJiZzLnVybCkpe2MoZyxzPXRoaXMuYz17dXJsOmEscHJldmlvdXM6cyYmcy51cmwsY3VycmVudDp1LHBhdGg6dT91LnByb3BzLnBhdGg6bnVsbCxtYXRjaGVzOmV9KSxzLnJvdXRlcj10aGlzLHMuYWN0aXZlPXU/W3VdOltdO2Zvcih2YXIgdj15Lmxlbmd0aDt2LS07KXlbdl0oe30pO1wiZnVuY3Rpb25cIj09dHlwZW9mIGYmJmYocyl9cmV0dXJuIG8oay5Qcm92aWRlcix7dmFsdWU6c30sdSl9fSk7dmFyIEU9ZnVuY3Rpb24obil7cmV0dXJuIG8oXCJhXCIsYyh7b25DbGljazpXfSxuKSl9LEw9ZnVuY3Rpb24obil7cmV0dXJuIG8obi5jb21wb25lbnQsbil9O2V4cG9ydHtFIGFzIExpbmssTCBhcyBSb3V0ZSxEIGFzIFJvdXRlcixEIGFzIGRlZmF1bHQscyBhcyBleGVjLFIgYXMgZ2V0Q3VycmVudFVybCwkIGFzIHJvdXRlLEMgYXMgdXNlUm91dGVyfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByZWFjdC1yb3V0ZXIubW9kdWxlLmpzLm1hcFxuIiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdGlmIChjYWNoZWRNb2R1bGUuZXJyb3IgIT09IHVuZGVmaW5lZCkgdGhyb3cgY2FjaGVkTW9kdWxlLmVycm9yO1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHRpZDogbW9kdWxlSWQsXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHR0cnkge1xuXHRcdHZhciBleGVjT3B0aW9ucyA9IHsgaWQ6IG1vZHVsZUlkLCBtb2R1bGU6IG1vZHVsZSwgZmFjdG9yeTogX193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0sIHJlcXVpcmU6IF9fd2VicGFja19yZXF1aXJlX18gfTtcblx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmkuZm9yRWFjaChmdW5jdGlvbihoYW5kbGVyKSB7IGhhbmRsZXIoZXhlY09wdGlvbnMpOyB9KTtcblx0XHRtb2R1bGUgPSBleGVjT3B0aW9ucy5tb2R1bGU7XG5cdFx0ZXhlY09wdGlvbnMuZmFjdG9yeS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBleGVjT3B0aW9ucy5yZXF1aXJlKTtcblx0fSBjYXRjaChlKSB7XG5cdFx0bW9kdWxlLmVycm9yID0gZTtcblx0XHR0aHJvdyBlO1xuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4vLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuX193ZWJwYWNrX3JlcXVpcmVfXy5tID0gX193ZWJwYWNrX21vZHVsZXNfXztcblxuLy8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbl9fd2VicGFja19yZXF1aXJlX18uYyA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfXztcblxuLy8gZXhwb3NlIHRoZSBtb2R1bGUgZXhlY3V0aW9uIGludGVyY2VwdG9yXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmkgPSBbXTtcblxuIiwiLy8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbl9fd2VicGFja19yZXF1aXJlX18ubiA9IChtb2R1bGUpID0+IHtcblx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG5cdFx0KCkgPT4gKG1vZHVsZVsnZGVmYXVsdCddKSA6XG5cdFx0KCkgPT4gKG1vZHVsZSk7XG5cdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsIHsgYTogZ2V0dGVyIH0pO1xuXHRyZXR1cm4gZ2V0dGVyO1xufTsiLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCIvLyBUaGlzIGZ1bmN0aW9uIGFsbG93IHRvIHJlZmVyZW5jZSBhbGwgY2h1bmtzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmh1ID0gKGNodW5rSWQpID0+IHtcblx0Ly8gcmV0dXJuIHVybCBmb3IgZmlsZW5hbWVzIGJhc2VkIG9uIHRlbXBsYXRlXG5cdHJldHVybiBcIlwiICsgY2h1bmtJZCArIFwiLlwiICsgX193ZWJwYWNrX3JlcXVpcmVfXy5oKCkgKyBcIi5ob3QtdXBkYXRlLmpzXCI7XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18uaG1yRiA9ICgpID0+IChcIm1haW4uXCIgKyBfX3dlYnBhY2tfcmVxdWlyZV9fLmgoKSArIFwiLmhvdC11cGRhdGUuanNvblwiKTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLmggPSAoKSA9PiAoXCI4ZjA5N2ExNTQxZjkwNDUzMWIyOFwiKSIsIl9fd2VicGFja19yZXF1aXJlX18uZyA9IChmdW5jdGlvbigpIHtcblx0aWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSAnb2JqZWN0JykgcmV0dXJuIGdsb2JhbFRoaXM7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIHRoaXMgfHwgbmV3IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcpIHJldHVybiB3aW5kb3c7XG5cdH1cbn0pKCk7IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSIsInZhciBpblByb2dyZXNzID0ge307XG52YXIgZGF0YVdlYnBhY2tQcmVmaXggPSBcImZsYXNrLXByZWFjdC10eXBlc2NyaXB0LXRhaWx3aW5kLXRlbXBsYXRlOlwiO1xuLy8gbG9hZFNjcmlwdCBmdW5jdGlvbiB0byBsb2FkIGEgc2NyaXB0IHZpYSBzY3JpcHQgdGFnXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmwgPSAodXJsLCBkb25lLCBrZXksIGNodW5rSWQpID0+IHtcblx0aWYoaW5Qcm9ncmVzc1t1cmxdKSB7IGluUHJvZ3Jlc3NbdXJsXS5wdXNoKGRvbmUpOyByZXR1cm47IH1cblx0dmFyIHNjcmlwdCwgbmVlZEF0dGFjaDtcblx0aWYoa2V5ICE9PSB1bmRlZmluZWQpIHtcblx0XHR2YXIgc2NyaXB0cyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic2NyaXB0XCIpO1xuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBzY3JpcHRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgcyA9IHNjcmlwdHNbaV07XG5cdFx0XHRpZihzLmdldEF0dHJpYnV0ZShcInNyY1wiKSA9PSB1cmwgfHwgcy5nZXRBdHRyaWJ1dGUoXCJkYXRhLXdlYnBhY2tcIikgPT0gZGF0YVdlYnBhY2tQcmVmaXggKyBrZXkpIHsgc2NyaXB0ID0gczsgYnJlYWs7IH1cblx0XHR9XG5cdH1cblx0aWYoIXNjcmlwdCkge1xuXHRcdG5lZWRBdHRhY2ggPSB0cnVlO1xuXHRcdHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuXG5cdFx0c2NyaXB0LmNoYXJzZXQgPSAndXRmLTgnO1xuXHRcdHNjcmlwdC50aW1lb3V0ID0gMTIwO1xuXHRcdGlmIChfX3dlYnBhY2tfcmVxdWlyZV9fLm5jKSB7XG5cdFx0XHRzY3JpcHQuc2V0QXR0cmlidXRlKFwibm9uY2VcIiwgX193ZWJwYWNrX3JlcXVpcmVfXy5uYyk7XG5cdFx0fVxuXHRcdHNjcmlwdC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXdlYnBhY2tcIiwgZGF0YVdlYnBhY2tQcmVmaXggKyBrZXkpO1xuXG5cdFx0c2NyaXB0LnNyYyA9IHVybDtcblx0fVxuXHRpblByb2dyZXNzW3VybF0gPSBbZG9uZV07XG5cdHZhciBvblNjcmlwdENvbXBsZXRlID0gKHByZXYsIGV2ZW50KSA9PiB7XG5cdFx0Ly8gYXZvaWQgbWVtIGxlYWtzIGluIElFLlxuXHRcdHNjcmlwdC5vbmVycm9yID0gc2NyaXB0Lm9ubG9hZCA9IG51bGw7XG5cdFx0Y2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuXHRcdHZhciBkb25lRm5zID0gaW5Qcm9ncmVzc1t1cmxdO1xuXHRcdGRlbGV0ZSBpblByb2dyZXNzW3VybF07XG5cdFx0c2NyaXB0LnBhcmVudE5vZGUgJiYgc2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcblx0XHRkb25lRm5zICYmIGRvbmVGbnMuZm9yRWFjaCgoZm4pID0+IChmbihldmVudCkpKTtcblx0XHRpZihwcmV2KSByZXR1cm4gcHJldihldmVudCk7XG5cdH1cblx0dmFyIHRpbWVvdXQgPSBzZXRUaW1lb3V0KG9uU2NyaXB0Q29tcGxldGUuYmluZChudWxsLCB1bmRlZmluZWQsIHsgdHlwZTogJ3RpbWVvdXQnLCB0YXJnZXQ6IHNjcmlwdCB9KSwgMTIwMDAwKTtcblx0c2NyaXB0Lm9uZXJyb3IgPSBvblNjcmlwdENvbXBsZXRlLmJpbmQobnVsbCwgc2NyaXB0Lm9uZXJyb3IpO1xuXHRzY3JpcHQub25sb2FkID0gb25TY3JpcHRDb21wbGV0ZS5iaW5kKG51bGwsIHNjcmlwdC5vbmxvYWQpO1xuXHRuZWVkQXR0YWNoICYmIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbn07IiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwidmFyIGN1cnJlbnRNb2R1bGVEYXRhID0ge307XG52YXIgaW5zdGFsbGVkTW9kdWxlcyA9IF9fd2VicGFja19yZXF1aXJlX18uYztcblxuLy8gbW9kdWxlIGFuZCByZXF1aXJlIGNyZWF0aW9uXG52YXIgY3VycmVudENoaWxkTW9kdWxlO1xudmFyIGN1cnJlbnRQYXJlbnRzID0gW107XG5cbi8vIHN0YXR1c1xudmFyIHJlZ2lzdGVyZWRTdGF0dXNIYW5kbGVycyA9IFtdO1xudmFyIGN1cnJlbnRTdGF0dXMgPSBcImlkbGVcIjtcblxuLy8gd2hpbGUgZG93bmxvYWRpbmdcbnZhciBibG9ja2luZ1Byb21pc2VzID0gMDtcbnZhciBibG9ja2luZ1Byb21pc2VzV2FpdGluZyA9IFtdO1xuXG4vLyBUaGUgdXBkYXRlIGluZm9cbnZhciBjdXJyZW50VXBkYXRlQXBwbHlIYW5kbGVycztcbnZhciBxdWV1ZWRJbnZhbGlkYXRlZE1vZHVsZXM7XG5cbl9fd2VicGFja19yZXF1aXJlX18uaG1yRCA9IGN1cnJlbnRNb2R1bGVEYXRhO1xuXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmkucHVzaChmdW5jdGlvbiAob3B0aW9ucykge1xuXHR2YXIgbW9kdWxlID0gb3B0aW9ucy5tb2R1bGU7XG5cdHZhciByZXF1aXJlID0gY3JlYXRlUmVxdWlyZShvcHRpb25zLnJlcXVpcmUsIG9wdGlvbnMuaWQpO1xuXHRtb2R1bGUuaG90ID0gY3JlYXRlTW9kdWxlSG90T2JqZWN0KG9wdGlvbnMuaWQsIG1vZHVsZSk7XG5cdG1vZHVsZS5wYXJlbnRzID0gY3VycmVudFBhcmVudHM7XG5cdG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xuXHRjdXJyZW50UGFyZW50cyA9IFtdO1xuXHRvcHRpb25zLnJlcXVpcmUgPSByZXF1aXJlO1xufSk7XG5cbl9fd2VicGFja19yZXF1aXJlX18uaG1yQyA9IHt9O1xuX193ZWJwYWNrX3JlcXVpcmVfXy5obXJJID0ge307XG5cbmZ1bmN0aW9uIGNyZWF0ZVJlcXVpcmUocmVxdWlyZSwgbW9kdWxlSWQpIHtcblx0dmFyIG1lID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF07XG5cdGlmICghbWUpIHJldHVybiByZXF1aXJlO1xuXHR2YXIgZm4gPSBmdW5jdGlvbiAocmVxdWVzdCkge1xuXHRcdGlmIChtZS5ob3QuYWN0aXZlKSB7XG5cdFx0XHRpZiAoaW5zdGFsbGVkTW9kdWxlc1tyZXF1ZXN0XSkge1xuXHRcdFx0XHR2YXIgcGFyZW50cyA9IGluc3RhbGxlZE1vZHVsZXNbcmVxdWVzdF0ucGFyZW50cztcblx0XHRcdFx0aWYgKHBhcmVudHMuaW5kZXhPZihtb2R1bGVJZCkgPT09IC0xKSB7XG5cdFx0XHRcdFx0cGFyZW50cy5wdXNoKG1vZHVsZUlkKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y3VycmVudFBhcmVudHMgPSBbbW9kdWxlSWRdO1xuXHRcdFx0XHRjdXJyZW50Q2hpbGRNb2R1bGUgPSByZXF1ZXN0O1xuXHRcdFx0fVxuXHRcdFx0aWYgKG1lLmNoaWxkcmVuLmluZGV4T2YocmVxdWVzdCkgPT09IC0xKSB7XG5cdFx0XHRcdG1lLmNoaWxkcmVuLnB1c2gocmVxdWVzdCk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnNvbGUud2Fybihcblx0XHRcdFx0XCJbSE1SXSB1bmV4cGVjdGVkIHJlcXVpcmUoXCIgK1xuXHRcdFx0XHRcdHJlcXVlc3QgK1xuXHRcdFx0XHRcdFwiKSBmcm9tIGRpc3Bvc2VkIG1vZHVsZSBcIiArXG5cdFx0XHRcdFx0bW9kdWxlSWRcblx0XHRcdCk7XG5cdFx0XHRjdXJyZW50UGFyZW50cyA9IFtdO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVxdWlyZShyZXF1ZXN0KTtcblx0fTtcblx0dmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciA9IGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0cmV0dXJuIHJlcXVpcmVbbmFtZV07XG5cdFx0XHR9LFxuXHRcdFx0c2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdFx0cmVxdWlyZVtuYW1lXSA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH07XG5cdH07XG5cdGZvciAodmFyIG5hbWUgaW4gcmVxdWlyZSkge1xuXHRcdGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocmVxdWlyZSwgbmFtZSkgJiYgbmFtZSAhPT0gXCJlXCIpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbiwgbmFtZSwgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKG5hbWUpKTtcblx0XHR9XG5cdH1cblx0Zm4uZSA9IGZ1bmN0aW9uIChjaHVua0lkLCBmZXRjaFByaW9yaXR5KSB7XG5cdFx0cmV0dXJuIHRyYWNrQmxvY2tpbmdQcm9taXNlKHJlcXVpcmUuZShjaHVua0lkLCBmZXRjaFByaW9yaXR5KSk7XG5cdH07XG5cdHJldHVybiBmbjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTW9kdWxlSG90T2JqZWN0KG1vZHVsZUlkLCBtZSkge1xuXHR2YXIgX21haW4gPSBjdXJyZW50Q2hpbGRNb2R1bGUgIT09IG1vZHVsZUlkO1xuXHR2YXIgaG90ID0ge1xuXHRcdC8vIHByaXZhdGUgc3R1ZmZcblx0XHRfYWNjZXB0ZWREZXBlbmRlbmNpZXM6IHt9LFxuXHRcdF9hY2NlcHRlZEVycm9ySGFuZGxlcnM6IHt9LFxuXHRcdF9kZWNsaW5lZERlcGVuZGVuY2llczoge30sXG5cdFx0X3NlbGZBY2NlcHRlZDogZmFsc2UsXG5cdFx0X3NlbGZEZWNsaW5lZDogZmFsc2UsXG5cdFx0X3NlbGZJbnZhbGlkYXRlZDogZmFsc2UsXG5cdFx0X2Rpc3Bvc2VIYW5kbGVyczogW10sXG5cdFx0X21haW46IF9tYWluLFxuXHRcdF9yZXF1aXJlU2VsZjogZnVuY3Rpb24gKCkge1xuXHRcdFx0Y3VycmVudFBhcmVudHMgPSBtZS5wYXJlbnRzLnNsaWNlKCk7XG5cdFx0XHRjdXJyZW50Q2hpbGRNb2R1bGUgPSBfbWFpbiA/IHVuZGVmaW5lZCA6IG1vZHVsZUlkO1xuXHRcdFx0X193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCk7XG5cdFx0fSxcblxuXHRcdC8vIE1vZHVsZSBBUElcblx0XHRhY3RpdmU6IHRydWUsXG5cdFx0YWNjZXB0OiBmdW5jdGlvbiAoZGVwLCBjYWxsYmFjaywgZXJyb3JIYW5kbGVyKSB7XG5cdFx0XHRpZiAoZGVwID09PSB1bmRlZmluZWQpIGhvdC5fc2VsZkFjY2VwdGVkID0gdHJ1ZTtcblx0XHRcdGVsc2UgaWYgKHR5cGVvZiBkZXAgPT09IFwiZnVuY3Rpb25cIikgaG90Ll9zZWxmQWNjZXB0ZWQgPSBkZXA7XG5cdFx0XHRlbHNlIGlmICh0eXBlb2YgZGVwID09PSBcIm9iamVjdFwiICYmIGRlcCAhPT0gbnVsbCkge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGRlcC5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGhvdC5fYWNjZXB0ZWREZXBlbmRlbmNpZXNbZGVwW2ldXSA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9O1xuXHRcdFx0XHRcdGhvdC5fYWNjZXB0ZWRFcnJvckhhbmRsZXJzW2RlcFtpXV0gPSBlcnJvckhhbmRsZXI7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGhvdC5fYWNjZXB0ZWREZXBlbmRlbmNpZXNbZGVwXSA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9O1xuXHRcdFx0XHRob3QuX2FjY2VwdGVkRXJyb3JIYW5kbGVyc1tkZXBdID0gZXJyb3JIYW5kbGVyO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZGVjbGluZTogZnVuY3Rpb24gKGRlcCkge1xuXHRcdFx0aWYgKGRlcCA9PT0gdW5kZWZpbmVkKSBob3QuX3NlbGZEZWNsaW5lZCA9IHRydWU7XG5cdFx0XHRlbHNlIGlmICh0eXBlb2YgZGVwID09PSBcIm9iamVjdFwiICYmIGRlcCAhPT0gbnVsbClcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkZXAubGVuZ3RoOyBpKyspXG5cdFx0XHRcdFx0aG90Ll9kZWNsaW5lZERlcGVuZGVuY2llc1tkZXBbaV1dID0gdHJ1ZTtcblx0XHRcdGVsc2UgaG90Ll9kZWNsaW5lZERlcGVuZGVuY2llc1tkZXBdID0gdHJ1ZTtcblx0XHR9LFxuXHRcdGRpc3Bvc2U6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuXHRcdFx0aG90Ll9kaXNwb3NlSGFuZGxlcnMucHVzaChjYWxsYmFjayk7XG5cdFx0fSxcblx0XHRhZGREaXNwb3NlSGFuZGxlcjogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG5cdFx0XHRob3QuX2Rpc3Bvc2VIYW5kbGVycy5wdXNoKGNhbGxiYWNrKTtcblx0XHR9LFxuXHRcdHJlbW92ZURpc3Bvc2VIYW5kbGVyOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcblx0XHRcdHZhciBpZHggPSBob3QuX2Rpc3Bvc2VIYW5kbGVycy5pbmRleE9mKGNhbGxiYWNrKTtcblx0XHRcdGlmIChpZHggPj0gMCkgaG90Ll9kaXNwb3NlSGFuZGxlcnMuc3BsaWNlKGlkeCwgMSk7XG5cdFx0fSxcblx0XHRpbnZhbGlkYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGlzLl9zZWxmSW52YWxpZGF0ZWQgPSB0cnVlO1xuXHRcdFx0c3dpdGNoIChjdXJyZW50U3RhdHVzKSB7XG5cdFx0XHRcdGNhc2UgXCJpZGxlXCI6XG5cdFx0XHRcdFx0Y3VycmVudFVwZGF0ZUFwcGx5SGFuZGxlcnMgPSBbXTtcblx0XHRcdFx0XHRPYmplY3Qua2V5cyhfX3dlYnBhY2tfcmVxdWlyZV9fLmhtckkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHRcdFx0XHRcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5obXJJW2tleV0oXG5cdFx0XHRcdFx0XHRcdG1vZHVsZUlkLFxuXHRcdFx0XHRcdFx0XHRjdXJyZW50VXBkYXRlQXBwbHlIYW5kbGVyc1xuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRzZXRTdGF0dXMoXCJyZWFkeVwiKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcInJlYWR5XCI6XG5cdFx0XHRcdFx0T2JqZWN0LmtleXMoX193ZWJwYWNrX3JlcXVpcmVfXy5obXJJKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0XHRcdFx0XHRcdF9fd2VicGFja19yZXF1aXJlX18uaG1ySVtrZXldKFxuXHRcdFx0XHRcdFx0XHRtb2R1bGVJZCxcblx0XHRcdFx0XHRcdFx0Y3VycmVudFVwZGF0ZUFwcGx5SGFuZGxlcnNcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgXCJwcmVwYXJlXCI6XG5cdFx0XHRcdGNhc2UgXCJjaGVja1wiOlxuXHRcdFx0XHRjYXNlIFwiZGlzcG9zZVwiOlxuXHRcdFx0XHRjYXNlIFwiYXBwbHlcIjpcblx0XHRcdFx0XHQocXVldWVkSW52YWxpZGF0ZWRNb2R1bGVzID0gcXVldWVkSW52YWxpZGF0ZWRNb2R1bGVzIHx8IFtdKS5wdXNoKFxuXHRcdFx0XHRcdFx0bW9kdWxlSWRcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdC8vIGlnbm9yZSByZXF1ZXN0cyBpbiBlcnJvciBzdGF0ZXNcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Ly8gTWFuYWdlbWVudCBBUElcblx0XHRjaGVjazogaG90Q2hlY2ssXG5cdFx0YXBwbHk6IGhvdEFwcGx5LFxuXHRcdHN0YXR1czogZnVuY3Rpb24gKGwpIHtcblx0XHRcdGlmICghbCkgcmV0dXJuIGN1cnJlbnRTdGF0dXM7XG5cdFx0XHRyZWdpc3RlcmVkU3RhdHVzSGFuZGxlcnMucHVzaChsKTtcblx0XHR9LFxuXHRcdGFkZFN0YXR1c0hhbmRsZXI6IGZ1bmN0aW9uIChsKSB7XG5cdFx0XHRyZWdpc3RlcmVkU3RhdHVzSGFuZGxlcnMucHVzaChsKTtcblx0XHR9LFxuXHRcdHJlbW92ZVN0YXR1c0hhbmRsZXI6IGZ1bmN0aW9uIChsKSB7XG5cdFx0XHR2YXIgaWR4ID0gcmVnaXN0ZXJlZFN0YXR1c0hhbmRsZXJzLmluZGV4T2YobCk7XG5cdFx0XHRpZiAoaWR4ID49IDApIHJlZ2lzdGVyZWRTdGF0dXNIYW5kbGVycy5zcGxpY2UoaWR4LCAxKTtcblx0XHR9LFxuXG5cdFx0Ly9pbmhlcml0IGZyb20gcHJldmlvdXMgZGlzcG9zZSBjYWxsXG5cdFx0ZGF0YTogY3VycmVudE1vZHVsZURhdGFbbW9kdWxlSWRdXG5cdH07XG5cdGN1cnJlbnRDaGlsZE1vZHVsZSA9IHVuZGVmaW5lZDtcblx0cmV0dXJuIGhvdDtcbn1cblxuZnVuY3Rpb24gc2V0U3RhdHVzKG5ld1N0YXR1cykge1xuXHRjdXJyZW50U3RhdHVzID0gbmV3U3RhdHVzO1xuXHR2YXIgcmVzdWx0cyA9IFtdO1xuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgcmVnaXN0ZXJlZFN0YXR1c0hhbmRsZXJzLmxlbmd0aDsgaSsrKVxuXHRcdHJlc3VsdHNbaV0gPSByZWdpc3RlcmVkU3RhdHVzSGFuZGxlcnNbaV0uY2FsbChudWxsLCBuZXdTdGF0dXMpO1xuXG5cdHJldHVybiBQcm9taXNlLmFsbChyZXN1bHRzKS50aGVuKGZ1bmN0aW9uICgpIHt9KTtcbn1cblxuZnVuY3Rpb24gdW5ibG9jaygpIHtcblx0aWYgKC0tYmxvY2tpbmdQcm9taXNlcyA9PT0gMCkge1xuXHRcdHNldFN0YXR1cyhcInJlYWR5XCIpLnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKGJsb2NraW5nUHJvbWlzZXMgPT09IDApIHtcblx0XHRcdFx0dmFyIGxpc3QgPSBibG9ja2luZ1Byb21pc2VzV2FpdGluZztcblx0XHRcdFx0YmxvY2tpbmdQcm9taXNlc1dhaXRpbmcgPSBbXTtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0bGlzdFtpXSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gdHJhY2tCbG9ja2luZ1Byb21pc2UocHJvbWlzZSkge1xuXHRzd2l0Y2ggKGN1cnJlbnRTdGF0dXMpIHtcblx0XHRjYXNlIFwicmVhZHlcIjpcblx0XHRcdHNldFN0YXR1cyhcInByZXBhcmVcIik7XG5cdFx0LyogZmFsbHRocm91Z2ggKi9cblx0XHRjYXNlIFwicHJlcGFyZVwiOlxuXHRcdFx0YmxvY2tpbmdQcm9taXNlcysrO1xuXHRcdFx0cHJvbWlzZS50aGVuKHVuYmxvY2ssIHVuYmxvY2spO1xuXHRcdFx0cmV0dXJuIHByb21pc2U7XG5cdFx0ZGVmYXVsdDpcblx0XHRcdHJldHVybiBwcm9taXNlO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHdhaXRGb3JCbG9ja2luZ1Byb21pc2VzKGZuKSB7XG5cdGlmIChibG9ja2luZ1Byb21pc2VzID09PSAwKSByZXR1cm4gZm4oKTtcblx0cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG5cdFx0YmxvY2tpbmdQcm9taXNlc1dhaXRpbmcucHVzaChmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXNvbHZlKGZuKCkpO1xuXHRcdH0pO1xuXHR9KTtcbn1cblxuZnVuY3Rpb24gaG90Q2hlY2soYXBwbHlPblVwZGF0ZSkge1xuXHRpZiAoY3VycmVudFN0YXR1cyAhPT0gXCJpZGxlXCIpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJjaGVjaygpIGlzIG9ubHkgYWxsb3dlZCBpbiBpZGxlIHN0YXR1c1wiKTtcblx0fVxuXHRyZXR1cm4gc2V0U3RhdHVzKFwiY2hlY2tcIilcblx0XHQudGhlbihfX3dlYnBhY2tfcmVxdWlyZV9fLmhtck0pXG5cdFx0LnRoZW4oZnVuY3Rpb24gKHVwZGF0ZSkge1xuXHRcdFx0aWYgKCF1cGRhdGUpIHtcblx0XHRcdFx0cmV0dXJuIHNldFN0YXR1cyhhcHBseUludmFsaWRhdGVkTW9kdWxlcygpID8gXCJyZWFkeVwiIDogXCJpZGxlXCIpLnRoZW4oXG5cdFx0XHRcdFx0ZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gc2V0U3RhdHVzKFwicHJlcGFyZVwiKS50aGVuKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dmFyIHVwZGF0ZWRNb2R1bGVzID0gW107XG5cdFx0XHRcdGN1cnJlbnRVcGRhdGVBcHBseUhhbmRsZXJzID0gW107XG5cblx0XHRcdFx0cmV0dXJuIFByb21pc2UuYWxsKFxuXHRcdFx0XHRcdE9iamVjdC5rZXlzKF9fd2VicGFja19yZXF1aXJlX18uaG1yQykucmVkdWNlKGZ1bmN0aW9uIChcblx0XHRcdFx0XHRcdHByb21pc2VzLFxuXHRcdFx0XHRcdFx0a2V5XG5cdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmhtckNba2V5XShcblx0XHRcdFx0XHRcdFx0dXBkYXRlLmMsXG5cdFx0XHRcdFx0XHRcdHVwZGF0ZS5yLFxuXHRcdFx0XHRcdFx0XHR1cGRhdGUubSxcblx0XHRcdFx0XHRcdFx0cHJvbWlzZXMsXG5cdFx0XHRcdFx0XHRcdGN1cnJlbnRVcGRhdGVBcHBseUhhbmRsZXJzLFxuXHRcdFx0XHRcdFx0XHR1cGRhdGVkTW9kdWxlc1xuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdHJldHVybiBwcm9taXNlcztcblx0XHRcdFx0XHR9LCBbXSlcblx0XHRcdFx0KS50aGVuKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRyZXR1cm4gd2FpdEZvckJsb2NraW5nUHJvbWlzZXMoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0aWYgKGFwcGx5T25VcGRhdGUpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGludGVybmFsQXBwbHkoYXBwbHlPblVwZGF0ZSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gc2V0U3RhdHVzKFwicmVhZHlcIikudGhlbihmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHVwZGF0ZWRNb2R1bGVzO1xuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblx0XHR9KTtcbn1cblxuZnVuY3Rpb24gaG90QXBwbHkob3B0aW9ucykge1xuXHRpZiAoY3VycmVudFN0YXR1cyAhPT0gXCJyZWFkeVwiKSB7XG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0XHRcImFwcGx5KCkgaXMgb25seSBhbGxvd2VkIGluIHJlYWR5IHN0YXR1cyAoc3RhdGU6IFwiICtcblx0XHRcdFx0XHRjdXJyZW50U3RhdHVzICtcblx0XHRcdFx0XHRcIilcIlxuXHRcdFx0KTtcblx0XHR9KTtcblx0fVxuXHRyZXR1cm4gaW50ZXJuYWxBcHBseShvcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gaW50ZXJuYWxBcHBseShvcHRpb25zKSB7XG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdGFwcGx5SW52YWxpZGF0ZWRNb2R1bGVzKCk7XG5cblx0dmFyIHJlc3VsdHMgPSBjdXJyZW50VXBkYXRlQXBwbHlIYW5kbGVycy5tYXAoZnVuY3Rpb24gKGhhbmRsZXIpIHtcblx0XHRyZXR1cm4gaGFuZGxlcihvcHRpb25zKTtcblx0fSk7XG5cdGN1cnJlbnRVcGRhdGVBcHBseUhhbmRsZXJzID0gdW5kZWZpbmVkO1xuXG5cdHZhciBlcnJvcnMgPSByZXN1bHRzXG5cdFx0Lm1hcChmdW5jdGlvbiAocikge1xuXHRcdFx0cmV0dXJuIHIuZXJyb3I7XG5cdFx0fSlcblx0XHQuZmlsdGVyKEJvb2xlYW4pO1xuXG5cdGlmIChlcnJvcnMubGVuZ3RoID4gMCkge1xuXHRcdHJldHVybiBzZXRTdGF0dXMoXCJhYm9ydFwiKS50aGVuKGZ1bmN0aW9uICgpIHtcblx0XHRcdHRocm93IGVycm9yc1swXTtcblx0XHR9KTtcblx0fVxuXG5cdC8vIE5vdyBpbiBcImRpc3Bvc2VcIiBwaGFzZVxuXHR2YXIgZGlzcG9zZVByb21pc2UgPSBzZXRTdGF0dXMoXCJkaXNwb3NlXCIpO1xuXG5cdHJlc3VsdHMuZm9yRWFjaChmdW5jdGlvbiAocmVzdWx0KSB7XG5cdFx0aWYgKHJlc3VsdC5kaXNwb3NlKSByZXN1bHQuZGlzcG9zZSgpO1xuXHR9KTtcblxuXHQvLyBOb3cgaW4gXCJhcHBseVwiIHBoYXNlXG5cdHZhciBhcHBseVByb21pc2UgPSBzZXRTdGF0dXMoXCJhcHBseVwiKTtcblxuXHR2YXIgZXJyb3I7XG5cdHZhciByZXBvcnRFcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcblx0XHRpZiAoIWVycm9yKSBlcnJvciA9IGVycjtcblx0fTtcblxuXHR2YXIgb3V0ZGF0ZWRNb2R1bGVzID0gW107XG5cdHJlc3VsdHMuZm9yRWFjaChmdW5jdGlvbiAocmVzdWx0KSB7XG5cdFx0aWYgKHJlc3VsdC5hcHBseSkge1xuXHRcdFx0dmFyIG1vZHVsZXMgPSByZXN1bHQuYXBwbHkocmVwb3J0RXJyb3IpO1xuXHRcdFx0aWYgKG1vZHVsZXMpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0b3V0ZGF0ZWRNb2R1bGVzLnB1c2gobW9kdWxlc1tpXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXG5cdHJldHVybiBQcm9taXNlLmFsbChbZGlzcG9zZVByb21pc2UsIGFwcGx5UHJvbWlzZV0pLnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdC8vIGhhbmRsZSBlcnJvcnMgaW4gYWNjZXB0IGhhbmRsZXJzIGFuZCBzZWxmIGFjY2VwdGVkIG1vZHVsZSBsb2FkXG5cdFx0aWYgKGVycm9yKSB7XG5cdFx0XHRyZXR1cm4gc2V0U3RhdHVzKFwiZmFpbFwiKS50aGVuKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRpZiAocXVldWVkSW52YWxpZGF0ZWRNb2R1bGVzKSB7XG5cdFx0XHRyZXR1cm4gaW50ZXJuYWxBcHBseShvcHRpb25zKS50aGVuKGZ1bmN0aW9uIChsaXN0KSB7XG5cdFx0XHRcdG91dGRhdGVkTW9kdWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChtb2R1bGVJZCkge1xuXHRcdFx0XHRcdGlmIChsaXN0LmluZGV4T2YobW9kdWxlSWQpIDwgMCkgbGlzdC5wdXNoKG1vZHVsZUlkKTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHJldHVybiBsaXN0O1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNldFN0YXR1cyhcImlkbGVcIikudGhlbihmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gb3V0ZGF0ZWRNb2R1bGVzO1xuXHRcdH0pO1xuXHR9KTtcbn1cblxuZnVuY3Rpb24gYXBwbHlJbnZhbGlkYXRlZE1vZHVsZXMoKSB7XG5cdGlmIChxdWV1ZWRJbnZhbGlkYXRlZE1vZHVsZXMpIHtcblx0XHRpZiAoIWN1cnJlbnRVcGRhdGVBcHBseUhhbmRsZXJzKSBjdXJyZW50VXBkYXRlQXBwbHlIYW5kbGVycyA9IFtdO1xuXHRcdE9iamVjdC5rZXlzKF9fd2VicGFja19yZXF1aXJlX18uaG1ySSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0XHRxdWV1ZWRJbnZhbGlkYXRlZE1vZHVsZXMuZm9yRWFjaChmdW5jdGlvbiAobW9kdWxlSWQpIHtcblx0XHRcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5obXJJW2tleV0oXG5cdFx0XHRcdFx0bW9kdWxlSWQsXG5cdFx0XHRcdFx0Y3VycmVudFVwZGF0ZUFwcGx5SGFuZGxlcnNcblx0XHRcdFx0KTtcblx0XHRcdH0pO1xuXHRcdH0pO1xuXHRcdHF1ZXVlZEludmFsaWRhdGVkTW9kdWxlcyA9IHVuZGVmaW5lZDtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxufSIsInZhciBzY3JpcHRVcmw7XG5pZiAoX193ZWJwYWNrX3JlcXVpcmVfXy5nLmltcG9ydFNjcmlwdHMpIHNjcmlwdFVybCA9IF9fd2VicGFja19yZXF1aXJlX18uZy5sb2NhdGlvbiArIFwiXCI7XG52YXIgZG9jdW1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLmcuZG9jdW1lbnQ7XG5pZiAoIXNjcmlwdFVybCAmJiBkb2N1bWVudCkge1xuXHRpZiAoZG9jdW1lbnQuY3VycmVudFNjcmlwdClcblx0XHRzY3JpcHRVcmwgPSBkb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYztcblx0aWYgKCFzY3JpcHRVcmwpIHtcblx0XHR2YXIgc2NyaXB0cyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic2NyaXB0XCIpO1xuXHRcdGlmKHNjcmlwdHMubGVuZ3RoKSB7XG5cdFx0XHR2YXIgaSA9IHNjcmlwdHMubGVuZ3RoIC0gMTtcblx0XHRcdHdoaWxlIChpID4gLTEgJiYgKCFzY3JpcHRVcmwgfHwgIS9eaHR0cChzPyk6Ly50ZXN0KHNjcmlwdFVybCkpKSBzY3JpcHRVcmwgPSBzY3JpcHRzW2ktLV0uc3JjO1xuXHRcdH1cblx0fVxufVxuLy8gV2hlbiBzdXBwb3J0aW5nIGJyb3dzZXJzIHdoZXJlIGFuIGF1dG9tYXRpYyBwdWJsaWNQYXRoIGlzIG5vdCBzdXBwb3J0ZWQgeW91IG11c3Qgc3BlY2lmeSBhbiBvdXRwdXQucHVibGljUGF0aCBtYW51YWxseSB2aWEgY29uZmlndXJhdGlvblxuLy8gb3IgcGFzcyBhbiBlbXB0eSBzdHJpbmcgKFwiXCIpIGFuZCBzZXQgdGhlIF9fd2VicGFja19wdWJsaWNfcGF0aF9fIHZhcmlhYmxlIGZyb20geW91ciBjb2RlIHRvIHVzZSB5b3VyIG93biBsb2dpYy5cbmlmICghc2NyaXB0VXJsKSB0aHJvdyBuZXcgRXJyb3IoXCJBdXRvbWF0aWMgcHVibGljUGF0aCBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlclwiKTtcbnNjcmlwdFVybCA9IHNjcmlwdFVybC5yZXBsYWNlKC8jLiokLywgXCJcIikucmVwbGFjZSgvXFw/LiokLywgXCJcIikucmVwbGFjZSgvXFwvW15cXC9dKyQvLCBcIi9cIik7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBzY3JpcHRVcmw7IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5iID0gZG9jdW1lbnQuYmFzZVVSSSB8fCBzZWxmLmxvY2F0aW9uLmhyZWY7XG5cbi8vIG9iamVjdCB0byBzdG9yZSBsb2FkZWQgYW5kIGxvYWRpbmcgY2h1bmtzXG4vLyB1bmRlZmluZWQgPSBjaHVuayBub3QgbG9hZGVkLCBudWxsID0gY2h1bmsgcHJlbG9hZGVkL3ByZWZldGNoZWRcbi8vIFtyZXNvbHZlLCByZWplY3QsIFByb21pc2VdID0gY2h1bmsgbG9hZGluZywgMCA9IGNodW5rIGxvYWRlZFxudmFyIGluc3RhbGxlZENodW5rcyA9IF9fd2VicGFja19yZXF1aXJlX18uaG1yU19qc29ucCA9IF9fd2VicGFja19yZXF1aXJlX18uaG1yU19qc29ucCB8fCB7XG5cdFwibWFpblwiOiAwXG59O1xuXG4vLyBubyBjaHVuayBvbiBkZW1hbmQgbG9hZGluZ1xuXG4vLyBubyBwcmVmZXRjaGluZ1xuXG4vLyBubyBwcmVsb2FkZWRcblxudmFyIGN1cnJlbnRVcGRhdGVkTW9kdWxlc0xpc3Q7XG52YXIgd2FpdGluZ1VwZGF0ZVJlc29sdmVzID0ge307XG5mdW5jdGlvbiBsb2FkVXBkYXRlQ2h1bmsoY2h1bmtJZCwgdXBkYXRlZE1vZHVsZXNMaXN0KSB7XG5cdGN1cnJlbnRVcGRhdGVkTW9kdWxlc0xpc3QgPSB1cGRhdGVkTW9kdWxlc0xpc3Q7XG5cdHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdFx0d2FpdGluZ1VwZGF0ZVJlc29sdmVzW2NodW5rSWRdID0gcmVzb2x2ZTtcblx0XHQvLyBzdGFydCB1cGRhdGUgY2h1bmsgbG9hZGluZ1xuXHRcdHZhciB1cmwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLnAgKyBfX3dlYnBhY2tfcmVxdWlyZV9fLmh1KGNodW5rSWQpO1xuXHRcdC8vIGNyZWF0ZSBlcnJvciBiZWZvcmUgc3RhY2sgdW53b3VuZCB0byBnZXQgdXNlZnVsIHN0YWNrdHJhY2UgbGF0ZXJcblx0XHR2YXIgZXJyb3IgPSBuZXcgRXJyb3IoKTtcblx0XHR2YXIgbG9hZGluZ0VuZGVkID0gKGV2ZW50KSA9PiB7XG5cdFx0XHRpZih3YWl0aW5nVXBkYXRlUmVzb2x2ZXNbY2h1bmtJZF0pIHtcblx0XHRcdFx0d2FpdGluZ1VwZGF0ZVJlc29sdmVzW2NodW5rSWRdID0gdW5kZWZpbmVkXG5cdFx0XHRcdHZhciBlcnJvclR5cGUgPSBldmVudCAmJiAoZXZlbnQudHlwZSA9PT0gJ2xvYWQnID8gJ21pc3NpbmcnIDogZXZlbnQudHlwZSk7XG5cdFx0XHRcdHZhciByZWFsU3JjID0gZXZlbnQgJiYgZXZlbnQudGFyZ2V0ICYmIGV2ZW50LnRhcmdldC5zcmM7XG5cdFx0XHRcdGVycm9yLm1lc3NhZ2UgPSAnTG9hZGluZyBob3QgdXBkYXRlIGNodW5rICcgKyBjaHVua0lkICsgJyBmYWlsZWQuXFxuKCcgKyBlcnJvclR5cGUgKyAnOiAnICsgcmVhbFNyYyArICcpJztcblx0XHRcdFx0ZXJyb3IubmFtZSA9ICdDaHVua0xvYWRFcnJvcic7XG5cdFx0XHRcdGVycm9yLnR5cGUgPSBlcnJvclR5cGU7XG5cdFx0XHRcdGVycm9yLnJlcXVlc3QgPSByZWFsU3JjO1xuXHRcdFx0XHRyZWplY3QoZXJyb3IpO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5sKHVybCwgbG9hZGluZ0VuZGVkKTtcblx0fSk7XG59XG5cbnNlbGZbXCJ3ZWJwYWNrSG90VXBkYXRlZmxhc2tfcHJlYWN0X3R5cGVzY3JpcHRfdGFpbHdpbmRfdGVtcGxhdGVcIl0gPSAoY2h1bmtJZCwgbW9yZU1vZHVsZXMsIHJ1bnRpbWUpID0+IHtcblx0Zm9yKHZhciBtb2R1bGVJZCBpbiBtb3JlTW9kdWxlcykge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhtb3JlTW9kdWxlcywgbW9kdWxlSWQpKSB7XG5cdFx0XHRjdXJyZW50VXBkYXRlW21vZHVsZUlkXSA9IG1vcmVNb2R1bGVzW21vZHVsZUlkXTtcblx0XHRcdGlmKGN1cnJlbnRVcGRhdGVkTW9kdWxlc0xpc3QpIGN1cnJlbnRVcGRhdGVkTW9kdWxlc0xpc3QucHVzaChtb2R1bGVJZCk7XG5cdFx0fVxuXHR9XG5cdGlmKHJ1bnRpbWUpIGN1cnJlbnRVcGRhdGVSdW50aW1lLnB1c2gocnVudGltZSk7XG5cdGlmKHdhaXRpbmdVcGRhdGVSZXNvbHZlc1tjaHVua0lkXSkge1xuXHRcdHdhaXRpbmdVcGRhdGVSZXNvbHZlc1tjaHVua0lkXSgpO1xuXHRcdHdhaXRpbmdVcGRhdGVSZXNvbHZlc1tjaHVua0lkXSA9IHVuZGVmaW5lZDtcblx0fVxufTtcblxudmFyIGN1cnJlbnRVcGRhdGVDaHVua3M7XG52YXIgY3VycmVudFVwZGF0ZTtcbnZhciBjdXJyZW50VXBkYXRlUmVtb3ZlZENodW5rcztcbnZhciBjdXJyZW50VXBkYXRlUnVudGltZTtcbmZ1bmN0aW9uIGFwcGx5SGFuZGxlcihvcHRpb25zKSB7XG5cdGlmIChfX3dlYnBhY2tfcmVxdWlyZV9fLmYpIGRlbGV0ZSBfX3dlYnBhY2tfcmVxdWlyZV9fLmYuanNvbnBIbXI7XG5cdGN1cnJlbnRVcGRhdGVDaHVua3MgPSB1bmRlZmluZWQ7XG5cdGZ1bmN0aW9uIGdldEFmZmVjdGVkTW9kdWxlRWZmZWN0cyh1cGRhdGVNb2R1bGVJZCkge1xuXHRcdHZhciBvdXRkYXRlZE1vZHVsZXMgPSBbdXBkYXRlTW9kdWxlSWRdO1xuXHRcdHZhciBvdXRkYXRlZERlcGVuZGVuY2llcyA9IHt9O1xuXG5cdFx0dmFyIHF1ZXVlID0gb3V0ZGF0ZWRNb2R1bGVzLm1hcChmdW5jdGlvbiAoaWQpIHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGNoYWluOiBbaWRdLFxuXHRcdFx0XHRpZDogaWRcblx0XHRcdH07XG5cdFx0fSk7XG5cdFx0d2hpbGUgKHF1ZXVlLmxlbmd0aCA+IDApIHtcblx0XHRcdHZhciBxdWV1ZUl0ZW0gPSBxdWV1ZS5wb3AoKTtcblx0XHRcdHZhciBtb2R1bGVJZCA9IHF1ZXVlSXRlbS5pZDtcblx0XHRcdHZhciBjaGFpbiA9IHF1ZXVlSXRlbS5jaGFpbjtcblx0XHRcdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLmNbbW9kdWxlSWRdO1xuXHRcdFx0aWYgKFxuXHRcdFx0XHQhbW9kdWxlIHx8XG5cdFx0XHRcdChtb2R1bGUuaG90Ll9zZWxmQWNjZXB0ZWQgJiYgIW1vZHVsZS5ob3QuX3NlbGZJbnZhbGlkYXRlZClcblx0XHRcdClcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRpZiAobW9kdWxlLmhvdC5fc2VsZkRlY2xpbmVkKSB7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0dHlwZTogXCJzZWxmLWRlY2xpbmVkXCIsXG5cdFx0XHRcdFx0Y2hhaW46IGNoYWluLFxuXHRcdFx0XHRcdG1vZHVsZUlkOiBtb2R1bGVJZFxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0aWYgKG1vZHVsZS5ob3QuX21haW4pIHtcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHR0eXBlOiBcInVuYWNjZXB0ZWRcIixcblx0XHRcdFx0XHRjaGFpbjogY2hhaW4sXG5cdFx0XHRcdFx0bW9kdWxlSWQ6IG1vZHVsZUlkXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG1vZHVsZS5wYXJlbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHZhciBwYXJlbnRJZCA9IG1vZHVsZS5wYXJlbnRzW2ldO1xuXHRcdFx0XHR2YXIgcGFyZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXy5jW3BhcmVudElkXTtcblx0XHRcdFx0aWYgKCFwYXJlbnQpIGNvbnRpbnVlO1xuXHRcdFx0XHRpZiAocGFyZW50LmhvdC5fZGVjbGluZWREZXBlbmRlbmNpZXNbbW9kdWxlSWRdKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdHR5cGU6IFwiZGVjbGluZWRcIixcblx0XHRcdFx0XHRcdGNoYWluOiBjaGFpbi5jb25jYXQoW3BhcmVudElkXSksXG5cdFx0XHRcdFx0XHRtb2R1bGVJZDogbW9kdWxlSWQsXG5cdFx0XHRcdFx0XHRwYXJlbnRJZDogcGFyZW50SWRcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChvdXRkYXRlZE1vZHVsZXMuaW5kZXhPZihwYXJlbnRJZCkgIT09IC0xKSBjb250aW51ZTtcblx0XHRcdFx0aWYgKHBhcmVudC5ob3QuX2FjY2VwdGVkRGVwZW5kZW5jaWVzW21vZHVsZUlkXSkge1xuXHRcdFx0XHRcdGlmICghb3V0ZGF0ZWREZXBlbmRlbmNpZXNbcGFyZW50SWRdKVxuXHRcdFx0XHRcdFx0b3V0ZGF0ZWREZXBlbmRlbmNpZXNbcGFyZW50SWRdID0gW107XG5cdFx0XHRcdFx0YWRkQWxsVG9TZXQob3V0ZGF0ZWREZXBlbmRlbmNpZXNbcGFyZW50SWRdLCBbbW9kdWxlSWRdKTtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkZWxldGUgb3V0ZGF0ZWREZXBlbmRlbmNpZXNbcGFyZW50SWRdO1xuXHRcdFx0XHRvdXRkYXRlZE1vZHVsZXMucHVzaChwYXJlbnRJZCk7XG5cdFx0XHRcdHF1ZXVlLnB1c2goe1xuXHRcdFx0XHRcdGNoYWluOiBjaGFpbi5jb25jYXQoW3BhcmVudElkXSksXG5cdFx0XHRcdFx0aWQ6IHBhcmVudElkXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHR0eXBlOiBcImFjY2VwdGVkXCIsXG5cdFx0XHRtb2R1bGVJZDogdXBkYXRlTW9kdWxlSWQsXG5cdFx0XHRvdXRkYXRlZE1vZHVsZXM6IG91dGRhdGVkTW9kdWxlcyxcblx0XHRcdG91dGRhdGVkRGVwZW5kZW5jaWVzOiBvdXRkYXRlZERlcGVuZGVuY2llc1xuXHRcdH07XG5cdH1cblxuXHRmdW5jdGlvbiBhZGRBbGxUb1NldChhLCBiKSB7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IGJbaV07XG5cdFx0XHRpZiAoYS5pbmRleE9mKGl0ZW0pID09PSAtMSkgYS5wdXNoKGl0ZW0pO1xuXHRcdH1cblx0fVxuXG5cdC8vIGF0IGJlZ2luIGFsbCB1cGRhdGVzIG1vZHVsZXMgYXJlIG91dGRhdGVkXG5cdC8vIHRoZSBcIm91dGRhdGVkXCIgc3RhdHVzIGNhbiBwcm9wYWdhdGUgdG8gcGFyZW50cyBpZiB0aGV5IGRvbid0IGFjY2VwdCB0aGUgY2hpbGRyZW5cblx0dmFyIG91dGRhdGVkRGVwZW5kZW5jaWVzID0ge307XG5cdHZhciBvdXRkYXRlZE1vZHVsZXMgPSBbXTtcblx0dmFyIGFwcGxpZWRVcGRhdGUgPSB7fTtcblxuXHR2YXIgd2FyblVuZXhwZWN0ZWRSZXF1aXJlID0gZnVuY3Rpb24gd2FyblVuZXhwZWN0ZWRSZXF1aXJlKG1vZHVsZSkge1xuXHRcdGNvbnNvbGUud2Fybihcblx0XHRcdFwiW0hNUl0gdW5leHBlY3RlZCByZXF1aXJlKFwiICsgbW9kdWxlLmlkICsgXCIpIHRvIGRpc3Bvc2VkIG1vZHVsZVwiXG5cdFx0KTtcblx0fTtcblxuXHRmb3IgKHZhciBtb2R1bGVJZCBpbiBjdXJyZW50VXBkYXRlKSB7XG5cdFx0aWYgKF9fd2VicGFja19yZXF1aXJlX18ubyhjdXJyZW50VXBkYXRlLCBtb2R1bGVJZCkpIHtcblx0XHRcdHZhciBuZXdNb2R1bGVGYWN0b3J5ID0gY3VycmVudFVwZGF0ZVttb2R1bGVJZF07XG5cdFx0XHQvKiogQHR5cGUge1RPRE99ICovXG5cdFx0XHR2YXIgcmVzdWx0O1xuXHRcdFx0aWYgKG5ld01vZHVsZUZhY3RvcnkpIHtcblx0XHRcdFx0cmVzdWx0ID0gZ2V0QWZmZWN0ZWRNb2R1bGVFZmZlY3RzKG1vZHVsZUlkKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJlc3VsdCA9IHtcblx0XHRcdFx0XHR0eXBlOiBcImRpc3Bvc2VkXCIsXG5cdFx0XHRcdFx0bW9kdWxlSWQ6IG1vZHVsZUlkXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHQvKiogQHR5cGUge0Vycm9yfGZhbHNlfSAqL1xuXHRcdFx0dmFyIGFib3J0RXJyb3IgPSBmYWxzZTtcblx0XHRcdHZhciBkb0FwcGx5ID0gZmFsc2U7XG5cdFx0XHR2YXIgZG9EaXNwb3NlID0gZmFsc2U7XG5cdFx0XHR2YXIgY2hhaW5JbmZvID0gXCJcIjtcblx0XHRcdGlmIChyZXN1bHQuY2hhaW4pIHtcblx0XHRcdFx0Y2hhaW5JbmZvID0gXCJcXG5VcGRhdGUgcHJvcGFnYXRpb246IFwiICsgcmVzdWx0LmNoYWluLmpvaW4oXCIgLT4gXCIpO1xuXHRcdFx0fVxuXHRcdFx0c3dpdGNoIChyZXN1bHQudHlwZSkge1xuXHRcdFx0XHRjYXNlIFwic2VsZi1kZWNsaW5lZFwiOlxuXHRcdFx0XHRcdGlmIChvcHRpb25zLm9uRGVjbGluZWQpIG9wdGlvbnMub25EZWNsaW5lZChyZXN1bHQpO1xuXHRcdFx0XHRcdGlmICghb3B0aW9ucy5pZ25vcmVEZWNsaW5lZClcblx0XHRcdFx0XHRcdGFib3J0RXJyb3IgPSBuZXcgRXJyb3IoXG5cdFx0XHRcdFx0XHRcdFwiQWJvcnRlZCBiZWNhdXNlIG9mIHNlbGYgZGVjbGluZTogXCIgK1xuXHRcdFx0XHRcdFx0XHRcdHJlc3VsdC5tb2R1bGVJZCArXG5cdFx0XHRcdFx0XHRcdFx0Y2hhaW5JbmZvXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIFwiZGVjbGluZWRcIjpcblx0XHRcdFx0XHRpZiAob3B0aW9ucy5vbkRlY2xpbmVkKSBvcHRpb25zLm9uRGVjbGluZWQocmVzdWx0KTtcblx0XHRcdFx0XHRpZiAoIW9wdGlvbnMuaWdub3JlRGVjbGluZWQpXG5cdFx0XHRcdFx0XHRhYm9ydEVycm9yID0gbmV3IEVycm9yKFxuXHRcdFx0XHRcdFx0XHRcIkFib3J0ZWQgYmVjYXVzZSBvZiBkZWNsaW5lZCBkZXBlbmRlbmN5OiBcIiArXG5cdFx0XHRcdFx0XHRcdFx0cmVzdWx0Lm1vZHVsZUlkICtcblx0XHRcdFx0XHRcdFx0XHRcIiBpbiBcIiArXG5cdFx0XHRcdFx0XHRcdFx0cmVzdWx0LnBhcmVudElkICtcblx0XHRcdFx0XHRcdFx0XHRjaGFpbkluZm9cblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgXCJ1bmFjY2VwdGVkXCI6XG5cdFx0XHRcdFx0aWYgKG9wdGlvbnMub25VbmFjY2VwdGVkKSBvcHRpb25zLm9uVW5hY2NlcHRlZChyZXN1bHQpO1xuXHRcdFx0XHRcdGlmICghb3B0aW9ucy5pZ25vcmVVbmFjY2VwdGVkKVxuXHRcdFx0XHRcdFx0YWJvcnRFcnJvciA9IG5ldyBFcnJvcihcblx0XHRcdFx0XHRcdFx0XCJBYm9ydGVkIGJlY2F1c2UgXCIgKyBtb2R1bGVJZCArIFwiIGlzIG5vdCBhY2NlcHRlZFwiICsgY2hhaW5JbmZvXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIFwiYWNjZXB0ZWRcIjpcblx0XHRcdFx0XHRpZiAob3B0aW9ucy5vbkFjY2VwdGVkKSBvcHRpb25zLm9uQWNjZXB0ZWQocmVzdWx0KTtcblx0XHRcdFx0XHRkb0FwcGx5ID0gdHJ1ZTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcImRpc3Bvc2VkXCI6XG5cdFx0XHRcdFx0aWYgKG9wdGlvbnMub25EaXNwb3NlZCkgb3B0aW9ucy5vbkRpc3Bvc2VkKHJlc3VsdCk7XG5cdFx0XHRcdFx0ZG9EaXNwb3NlID0gdHJ1ZTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJVbmV4Y2VwdGlvbiB0eXBlIFwiICsgcmVzdWx0LnR5cGUpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGFib3J0RXJyb3IpIHtcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRlcnJvcjogYWJvcnRFcnJvclxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0aWYgKGRvQXBwbHkpIHtcblx0XHRcdFx0YXBwbGllZFVwZGF0ZVttb2R1bGVJZF0gPSBuZXdNb2R1bGVGYWN0b3J5O1xuXHRcdFx0XHRhZGRBbGxUb1NldChvdXRkYXRlZE1vZHVsZXMsIHJlc3VsdC5vdXRkYXRlZE1vZHVsZXMpO1xuXHRcdFx0XHRmb3IgKG1vZHVsZUlkIGluIHJlc3VsdC5vdXRkYXRlZERlcGVuZGVuY2llcykge1xuXHRcdFx0XHRcdGlmIChfX3dlYnBhY2tfcmVxdWlyZV9fLm8ocmVzdWx0Lm91dGRhdGVkRGVwZW5kZW5jaWVzLCBtb2R1bGVJZCkpIHtcblx0XHRcdFx0XHRcdGlmICghb3V0ZGF0ZWREZXBlbmRlbmNpZXNbbW9kdWxlSWRdKVxuXHRcdFx0XHRcdFx0XHRvdXRkYXRlZERlcGVuZGVuY2llc1ttb2R1bGVJZF0gPSBbXTtcblx0XHRcdFx0XHRcdGFkZEFsbFRvU2V0KFxuXHRcdFx0XHRcdFx0XHRvdXRkYXRlZERlcGVuZGVuY2llc1ttb2R1bGVJZF0sXG5cdFx0XHRcdFx0XHRcdHJlc3VsdC5vdXRkYXRlZERlcGVuZGVuY2llc1ttb2R1bGVJZF1cblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoZG9EaXNwb3NlKSB7XG5cdFx0XHRcdGFkZEFsbFRvU2V0KG91dGRhdGVkTW9kdWxlcywgW3Jlc3VsdC5tb2R1bGVJZF0pO1xuXHRcdFx0XHRhcHBsaWVkVXBkYXRlW21vZHVsZUlkXSA9IHdhcm5VbmV4cGVjdGVkUmVxdWlyZTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0Y3VycmVudFVwZGF0ZSA9IHVuZGVmaW5lZDtcblxuXHQvLyBTdG9yZSBzZWxmIGFjY2VwdGVkIG91dGRhdGVkIG1vZHVsZXMgdG8gcmVxdWlyZSB0aGVtIGxhdGVyIGJ5IHRoZSBtb2R1bGUgc3lzdGVtXG5cdHZhciBvdXRkYXRlZFNlbGZBY2NlcHRlZE1vZHVsZXMgPSBbXTtcblx0Zm9yICh2YXIgaiA9IDA7IGogPCBvdXRkYXRlZE1vZHVsZXMubGVuZ3RoOyBqKyspIHtcblx0XHR2YXIgb3V0ZGF0ZWRNb2R1bGVJZCA9IG91dGRhdGVkTW9kdWxlc1tqXTtcblx0XHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXy5jW291dGRhdGVkTW9kdWxlSWRdO1xuXHRcdGlmIChcblx0XHRcdG1vZHVsZSAmJlxuXHRcdFx0KG1vZHVsZS5ob3QuX3NlbGZBY2NlcHRlZCB8fCBtb2R1bGUuaG90Ll9tYWluKSAmJlxuXHRcdFx0Ly8gcmVtb3ZlZCBzZWxmLWFjY2VwdGVkIG1vZHVsZXMgc2hvdWxkIG5vdCBiZSByZXF1aXJlZFxuXHRcdFx0YXBwbGllZFVwZGF0ZVtvdXRkYXRlZE1vZHVsZUlkXSAhPT0gd2FyblVuZXhwZWN0ZWRSZXF1aXJlICYmXG5cdFx0XHQvLyB3aGVuIGNhbGxlZCBpbnZhbGlkYXRlIHNlbGYtYWNjZXB0aW5nIGlzIG5vdCBwb3NzaWJsZVxuXHRcdFx0IW1vZHVsZS5ob3QuX3NlbGZJbnZhbGlkYXRlZFxuXHRcdCkge1xuXHRcdFx0b3V0ZGF0ZWRTZWxmQWNjZXB0ZWRNb2R1bGVzLnB1c2goe1xuXHRcdFx0XHRtb2R1bGU6IG91dGRhdGVkTW9kdWxlSWQsXG5cdFx0XHRcdHJlcXVpcmU6IG1vZHVsZS5ob3QuX3JlcXVpcmVTZWxmLFxuXHRcdFx0XHRlcnJvckhhbmRsZXI6IG1vZHVsZS5ob3QuX3NlbGZBY2NlcHRlZFxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cblx0dmFyIG1vZHVsZU91dGRhdGVkRGVwZW5kZW5jaWVzO1xuXG5cdHJldHVybiB7XG5cdFx0ZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuXHRcdFx0Y3VycmVudFVwZGF0ZVJlbW92ZWRDaHVua3MuZm9yRWFjaChmdW5jdGlvbiAoY2h1bmtJZCkge1xuXHRcdFx0XHRkZWxldGUgaW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdO1xuXHRcdFx0fSk7XG5cdFx0XHRjdXJyZW50VXBkYXRlUmVtb3ZlZENodW5rcyA9IHVuZGVmaW5lZDtcblxuXHRcdFx0dmFyIGlkeDtcblx0XHRcdHZhciBxdWV1ZSA9IG91dGRhdGVkTW9kdWxlcy5zbGljZSgpO1xuXHRcdFx0d2hpbGUgKHF1ZXVlLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0dmFyIG1vZHVsZUlkID0gcXVldWUucG9wKCk7XG5cdFx0XHRcdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLmNbbW9kdWxlSWRdO1xuXHRcdFx0XHRpZiAoIW1vZHVsZSkgY29udGludWU7XG5cblx0XHRcdFx0dmFyIGRhdGEgPSB7fTtcblxuXHRcdFx0XHQvLyBDYWxsIGRpc3Bvc2UgaGFuZGxlcnNcblx0XHRcdFx0dmFyIGRpc3Bvc2VIYW5kbGVycyA9IG1vZHVsZS5ob3QuX2Rpc3Bvc2VIYW5kbGVycztcblx0XHRcdFx0Zm9yIChqID0gMDsgaiA8IGRpc3Bvc2VIYW5kbGVycy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRcdGRpc3Bvc2VIYW5kbGVyc1tqXS5jYWxsKG51bGwsIGRhdGEpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdF9fd2VicGFja19yZXF1aXJlX18uaG1yRFttb2R1bGVJZF0gPSBkYXRhO1xuXG5cdFx0XHRcdC8vIGRpc2FibGUgbW9kdWxlICh0aGlzIGRpc2FibGVzIHJlcXVpcmVzIGZyb20gdGhpcyBtb2R1bGUpXG5cdFx0XHRcdG1vZHVsZS5ob3QuYWN0aXZlID0gZmFsc2U7XG5cblx0XHRcdFx0Ly8gcmVtb3ZlIG1vZHVsZSBmcm9tIGNhY2hlXG5cdFx0XHRcdGRlbGV0ZSBfX3dlYnBhY2tfcmVxdWlyZV9fLmNbbW9kdWxlSWRdO1xuXG5cdFx0XHRcdC8vIHdoZW4gZGlzcG9zaW5nIHRoZXJlIGlzIG5vIG5lZWQgdG8gY2FsbCBkaXNwb3NlIGhhbmRsZXJcblx0XHRcdFx0ZGVsZXRlIG91dGRhdGVkRGVwZW5kZW5jaWVzW21vZHVsZUlkXTtcblxuXHRcdFx0XHQvLyByZW1vdmUgXCJwYXJlbnRzXCIgcmVmZXJlbmNlcyBmcm9tIGFsbCBjaGlsZHJlblxuXHRcdFx0XHRmb3IgKGogPSAwOyBqIDwgbW9kdWxlLmNoaWxkcmVuLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdFx0dmFyIGNoaWxkID0gX193ZWJwYWNrX3JlcXVpcmVfXy5jW21vZHVsZS5jaGlsZHJlbltqXV07XG5cdFx0XHRcdFx0aWYgKCFjaGlsZCkgY29udGludWU7XG5cdFx0XHRcdFx0aWR4ID0gY2hpbGQucGFyZW50cy5pbmRleE9mKG1vZHVsZUlkKTtcblx0XHRcdFx0XHRpZiAoaWR4ID49IDApIHtcblx0XHRcdFx0XHRcdGNoaWxkLnBhcmVudHMuc3BsaWNlKGlkeCwgMSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIHJlbW92ZSBvdXRkYXRlZCBkZXBlbmRlbmN5IGZyb20gbW9kdWxlIGNoaWxkcmVuXG5cdFx0XHR2YXIgZGVwZW5kZW5jeTtcblx0XHRcdGZvciAodmFyIG91dGRhdGVkTW9kdWxlSWQgaW4gb3V0ZGF0ZWREZXBlbmRlbmNpZXMpIHtcblx0XHRcdFx0aWYgKF9fd2VicGFja19yZXF1aXJlX18ubyhvdXRkYXRlZERlcGVuZGVuY2llcywgb3V0ZGF0ZWRNb2R1bGVJZCkpIHtcblx0XHRcdFx0XHRtb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLmNbb3V0ZGF0ZWRNb2R1bGVJZF07XG5cdFx0XHRcdFx0aWYgKG1vZHVsZSkge1xuXHRcdFx0XHRcdFx0bW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXMgPVxuXHRcdFx0XHRcdFx0XHRvdXRkYXRlZERlcGVuZGVuY2llc1tvdXRkYXRlZE1vZHVsZUlkXTtcblx0XHRcdFx0XHRcdGZvciAoaiA9IDA7IGogPCBtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llcy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRcdFx0XHRkZXBlbmRlbmN5ID0gbW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXNbal07XG5cdFx0XHRcdFx0XHRcdGlkeCA9IG1vZHVsZS5jaGlsZHJlbi5pbmRleE9mKGRlcGVuZGVuY3kpO1xuXHRcdFx0XHRcdFx0XHRpZiAoaWR4ID49IDApIG1vZHVsZS5jaGlsZHJlbi5zcGxpY2UoaWR4LCAxKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdGFwcGx5OiBmdW5jdGlvbiAocmVwb3J0RXJyb3IpIHtcblx0XHRcdC8vIGluc2VydCBuZXcgY29kZVxuXHRcdFx0Zm9yICh2YXIgdXBkYXRlTW9kdWxlSWQgaW4gYXBwbGllZFVwZGF0ZSkge1xuXHRcdFx0XHRpZiAoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGFwcGxpZWRVcGRhdGUsIHVwZGF0ZU1vZHVsZUlkKSkge1xuXHRcdFx0XHRcdF9fd2VicGFja19yZXF1aXJlX18ubVt1cGRhdGVNb2R1bGVJZF0gPSBhcHBsaWVkVXBkYXRlW3VwZGF0ZU1vZHVsZUlkXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBydW4gbmV3IHJ1bnRpbWUgbW9kdWxlc1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjdXJyZW50VXBkYXRlUnVudGltZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRjdXJyZW50VXBkYXRlUnVudGltZVtpXShfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gY2FsbCBhY2NlcHQgaGFuZGxlcnNcblx0XHRcdGZvciAodmFyIG91dGRhdGVkTW9kdWxlSWQgaW4gb3V0ZGF0ZWREZXBlbmRlbmNpZXMpIHtcblx0XHRcdFx0aWYgKF9fd2VicGFja19yZXF1aXJlX18ubyhvdXRkYXRlZERlcGVuZGVuY2llcywgb3V0ZGF0ZWRNb2R1bGVJZCkpIHtcblx0XHRcdFx0XHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXy5jW291dGRhdGVkTW9kdWxlSWRdO1xuXHRcdFx0XHRcdGlmIChtb2R1bGUpIHtcblx0XHRcdFx0XHRcdG1vZHVsZU91dGRhdGVkRGVwZW5kZW5jaWVzID1cblx0XHRcdFx0XHRcdFx0b3V0ZGF0ZWREZXBlbmRlbmNpZXNbb3V0ZGF0ZWRNb2R1bGVJZF07XG5cdFx0XHRcdFx0XHR2YXIgY2FsbGJhY2tzID0gW107XG5cdFx0XHRcdFx0XHR2YXIgZXJyb3JIYW5kbGVycyA9IFtdO1xuXHRcdFx0XHRcdFx0dmFyIGRlcGVuZGVuY2llc0ZvckNhbGxiYWNrcyA9IFtdO1xuXHRcdFx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llcy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRcdFx0XHR2YXIgZGVwZW5kZW5jeSA9IG1vZHVsZU91dGRhdGVkRGVwZW5kZW5jaWVzW2pdO1xuXHRcdFx0XHRcdFx0XHR2YXIgYWNjZXB0Q2FsbGJhY2sgPVxuXHRcdFx0XHRcdFx0XHRcdG1vZHVsZS5ob3QuX2FjY2VwdGVkRGVwZW5kZW5jaWVzW2RlcGVuZGVuY3ldO1xuXHRcdFx0XHRcdFx0XHR2YXIgZXJyb3JIYW5kbGVyID1cblx0XHRcdFx0XHRcdFx0XHRtb2R1bGUuaG90Ll9hY2NlcHRlZEVycm9ySGFuZGxlcnNbZGVwZW5kZW5jeV07XG5cdFx0XHRcdFx0XHRcdGlmIChhY2NlcHRDYWxsYmFjaykge1xuXHRcdFx0XHRcdFx0XHRcdGlmIChjYWxsYmFja3MuaW5kZXhPZihhY2NlcHRDYWxsYmFjaykgIT09IC0xKSBjb250aW51ZTtcblx0XHRcdFx0XHRcdFx0XHRjYWxsYmFja3MucHVzaChhY2NlcHRDYWxsYmFjayk7XG5cdFx0XHRcdFx0XHRcdFx0ZXJyb3JIYW5kbGVycy5wdXNoKGVycm9ySGFuZGxlcik7XG5cdFx0XHRcdFx0XHRcdFx0ZGVwZW5kZW5jaWVzRm9yQ2FsbGJhY2tzLnB1c2goZGVwZW5kZW5jeSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGZvciAodmFyIGsgPSAwOyBrIDwgY2FsbGJhY2tzLmxlbmd0aDsgaysrKSB7XG5cdFx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdFx0Y2FsbGJhY2tzW2tdLmNhbGwobnVsbCwgbW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXMpO1xuXHRcdFx0XHRcdFx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAodHlwZW9mIGVycm9ySGFuZGxlcnNba10gPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZXJyb3JIYW5kbGVyc1trXShlcnIsIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtb2R1bGVJZDogb3V0ZGF0ZWRNb2R1bGVJZCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkZXBlbmRlbmN5SWQ6IGRlcGVuZGVuY2llc0ZvckNhbGxiYWNrc1trXVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0XHRcdH0gY2F0Y2ggKGVycjIpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKG9wdGlvbnMub25FcnJvcmVkKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9ucy5vbkVycm9yZWQoe1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJhY2NlcHQtZXJyb3ItaGFuZGxlci1lcnJvcmVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtb2R1bGVJZDogb3V0ZGF0ZWRNb2R1bGVJZCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRlcGVuZGVuY3lJZDogZGVwZW5kZW5jaWVzRm9yQ2FsbGJhY2tzW2tdLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZXJyb3I6IGVycjIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvcmlnaW5hbEVycm9yOiBlcnJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIW9wdGlvbnMuaWdub3JlRXJyb3JlZCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlcG9ydEVycm9yKGVycjIpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlcG9ydEVycm9yKGVycik7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKG9wdGlvbnMub25FcnJvcmVkKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnMub25FcnJvcmVkKHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImFjY2VwdC1lcnJvcmVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bW9kdWxlSWQ6IG91dGRhdGVkTW9kdWxlSWQsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVwZW5kZW5jeUlkOiBkZXBlbmRlbmNpZXNGb3JDYWxsYmFja3Nba10sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZXJyb3I6IGVyclxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdGlmICghb3B0aW9ucy5pZ25vcmVFcnJvcmVkKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlcG9ydEVycm9yKGVycik7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIExvYWQgc2VsZiBhY2NlcHRlZCBtb2R1bGVzXG5cdFx0XHRmb3IgKHZhciBvID0gMDsgbyA8IG91dGRhdGVkU2VsZkFjY2VwdGVkTW9kdWxlcy5sZW5ndGg7IG8rKykge1xuXHRcdFx0XHR2YXIgaXRlbSA9IG91dGRhdGVkU2VsZkFjY2VwdGVkTW9kdWxlc1tvXTtcblx0XHRcdFx0dmFyIG1vZHVsZUlkID0gaXRlbS5tb2R1bGU7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0aXRlbS5yZXF1aXJlKG1vZHVsZUlkKTtcblx0XHRcdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRcdFx0aWYgKHR5cGVvZiBpdGVtLmVycm9ySGFuZGxlciA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRpdGVtLmVycm9ySGFuZGxlcihlcnIsIHtcblx0XHRcdFx0XHRcdFx0XHRtb2R1bGVJZDogbW9kdWxlSWQsXG5cdFx0XHRcdFx0XHRcdFx0bW9kdWxlOiBfX3dlYnBhY2tfcmVxdWlyZV9fLmNbbW9kdWxlSWRdXG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0fSBjYXRjaCAoZXJyMikge1xuXHRcdFx0XHRcdFx0XHRpZiAob3B0aW9ucy5vbkVycm9yZWQpIHtcblx0XHRcdFx0XHRcdFx0XHRvcHRpb25zLm9uRXJyb3JlZCh7XG5cdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInNlbGYtYWNjZXB0LWVycm9yLWhhbmRsZXItZXJyb3JlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0bW9kdWxlSWQ6IG1vZHVsZUlkLFxuXHRcdFx0XHRcdFx0XHRcdFx0ZXJyb3I6IGVycjIsXG5cdFx0XHRcdFx0XHRcdFx0XHRvcmlnaW5hbEVycm9yOiBlcnJcblx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZiAoIW9wdGlvbnMuaWdub3JlRXJyb3JlZCkge1xuXHRcdFx0XHRcdFx0XHRcdHJlcG9ydEVycm9yKGVycjIpO1xuXHRcdFx0XHRcdFx0XHRcdHJlcG9ydEVycm9yKGVycik7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0aWYgKG9wdGlvbnMub25FcnJvcmVkKSB7XG5cdFx0XHRcdFx0XHRcdG9wdGlvbnMub25FcnJvcmVkKHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInNlbGYtYWNjZXB0LWVycm9yZWRcIixcblx0XHRcdFx0XHRcdFx0XHRtb2R1bGVJZDogbW9kdWxlSWQsXG5cdFx0XHRcdFx0XHRcdFx0ZXJyb3I6IGVyclxuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICghb3B0aW9ucy5pZ25vcmVFcnJvcmVkKSB7XG5cdFx0XHRcdFx0XHRcdHJlcG9ydEVycm9yKGVycik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBvdXRkYXRlZE1vZHVsZXM7XG5cdFx0fVxuXHR9O1xufVxuX193ZWJwYWNrX3JlcXVpcmVfXy5obXJJLmpzb25wID0gZnVuY3Rpb24gKG1vZHVsZUlkLCBhcHBseUhhbmRsZXJzKSB7XG5cdGlmICghY3VycmVudFVwZGF0ZSkge1xuXHRcdGN1cnJlbnRVcGRhdGUgPSB7fTtcblx0XHRjdXJyZW50VXBkYXRlUnVudGltZSA9IFtdO1xuXHRcdGN1cnJlbnRVcGRhdGVSZW1vdmVkQ2h1bmtzID0gW107XG5cdFx0YXBwbHlIYW5kbGVycy5wdXNoKGFwcGx5SGFuZGxlcik7XG5cdH1cblx0aWYgKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oY3VycmVudFVwZGF0ZSwgbW9kdWxlSWQpKSB7XG5cdFx0Y3VycmVudFVwZGF0ZVttb2R1bGVJZF0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fLm1bbW9kdWxlSWRdO1xuXHR9XG59O1xuX193ZWJwYWNrX3JlcXVpcmVfXy5obXJDLmpzb25wID0gZnVuY3Rpb24gKFxuXHRjaHVua0lkcyxcblx0cmVtb3ZlZENodW5rcyxcblx0cmVtb3ZlZE1vZHVsZXMsXG5cdHByb21pc2VzLFxuXHRhcHBseUhhbmRsZXJzLFxuXHR1cGRhdGVkTW9kdWxlc0xpc3Rcbikge1xuXHRhcHBseUhhbmRsZXJzLnB1c2goYXBwbHlIYW5kbGVyKTtcblx0Y3VycmVudFVwZGF0ZUNodW5rcyA9IHt9O1xuXHRjdXJyZW50VXBkYXRlUmVtb3ZlZENodW5rcyA9IHJlbW92ZWRDaHVua3M7XG5cdGN1cnJlbnRVcGRhdGUgPSByZW1vdmVkTW9kdWxlcy5yZWR1Y2UoZnVuY3Rpb24gKG9iaiwga2V5KSB7XG5cdFx0b2JqW2tleV0gPSBmYWxzZTtcblx0XHRyZXR1cm4gb2JqO1xuXHR9LCB7fSk7XG5cdGN1cnJlbnRVcGRhdGVSdW50aW1lID0gW107XG5cdGNodW5rSWRzLmZvckVhY2goZnVuY3Rpb24gKGNodW5rSWQpIHtcblx0XHRpZiAoXG5cdFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8oaW5zdGFsbGVkQ2h1bmtzLCBjaHVua0lkKSAmJlxuXHRcdFx0aW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdICE9PSB1bmRlZmluZWRcblx0XHQpIHtcblx0XHRcdHByb21pc2VzLnB1c2gobG9hZFVwZGF0ZUNodW5rKGNodW5rSWQsIHVwZGF0ZWRNb2R1bGVzTGlzdCkpO1xuXHRcdFx0Y3VycmVudFVwZGF0ZUNodW5rc1tjaHVua0lkXSA9IHRydWU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGN1cnJlbnRVcGRhdGVDaHVua3NbY2h1bmtJZF0gPSBmYWxzZTtcblx0XHR9XG5cdH0pO1xuXHRpZiAoX193ZWJwYWNrX3JlcXVpcmVfXy5mKSB7XG5cdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5mLmpzb25wSG1yID0gZnVuY3Rpb24gKGNodW5rSWQsIHByb21pc2VzKSB7XG5cdFx0XHRpZiAoXG5cdFx0XHRcdGN1cnJlbnRVcGRhdGVDaHVua3MgJiZcblx0XHRcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vKGN1cnJlbnRVcGRhdGVDaHVua3MsIGNodW5rSWQpICYmXG5cdFx0XHRcdCFjdXJyZW50VXBkYXRlQ2h1bmtzW2NodW5rSWRdXG5cdFx0XHQpIHtcblx0XHRcdFx0cHJvbWlzZXMucHVzaChsb2FkVXBkYXRlQ2h1bmsoY2h1bmtJZCkpO1xuXHRcdFx0XHRjdXJyZW50VXBkYXRlQ2h1bmtzW2NodW5rSWRdID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9O1xuXHR9XG59O1xuXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmhtck0gPSAoKSA9PiB7XG5cdGlmICh0eXBlb2YgZmV0Y2ggPT09IFwidW5kZWZpbmVkXCIpIHRocm93IG5ldyBFcnJvcihcIk5vIGJyb3dzZXIgc3VwcG9ydDogbmVlZCBmZXRjaCBBUElcIik7XG5cdHJldHVybiBmZXRjaChfX3dlYnBhY2tfcmVxdWlyZV9fLnAgKyBfX3dlYnBhY2tfcmVxdWlyZV9fLmhtckYoKSkudGhlbigocmVzcG9uc2UpID0+IHtcblx0XHRpZihyZXNwb25zZS5zdGF0dXMgPT09IDQwNCkgcmV0dXJuOyAvLyBubyB1cGRhdGUgYXZhaWxhYmxlXG5cdFx0aWYoIXJlc3BvbnNlLm9rKSB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZmV0Y2ggdXBkYXRlIG1hbmlmZXN0IFwiICsgcmVzcG9uc2Uuc3RhdHVzVGV4dCk7XG5cdFx0cmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcblx0fSk7XG59O1xuXG4vLyBubyBvbiBjaHVua3MgbG9hZGVkXG5cbi8vIG5vIGpzb25wIGZ1bmN0aW9uIiwiX193ZWJwYWNrX3JlcXVpcmVfXy5uYyA9IHVuZGVmaW5lZDsiLCIiLCIvLyBtb2R1bGUgY2FjaGUgYXJlIHVzZWQgc28gZW50cnkgaW5saW5pbmcgaXMgZGlzYWJsZWRcbi8vIHN0YXJ0dXBcbi8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xudmFyIF9fd2VicGFja19leHBvcnRzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9hcHAvc3RhdGljL3BhZ2VzL2xheW91dC50c3hcIik7XG4iLCIiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=